(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def % rem)
(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro cast' [_ x] #_(ensure symbol? _) `(do ~x))

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(import
    [java.io File FileInputStream FileNotFoundException FileOutputStream InputStreamReader IOException LineNumberReader OutputStreamWriter PrintWriter PushbackReader Reader StringReader StringWriter]
  #_[java.lang Character Class Exception IllegalArgumentException IllegalStateException Integer Number NumberFormatException Object RuntimeException String StringBuilder Throwable UnsupportedOperationException]
    [java.lang.ref Reference ReferenceQueue SoftReference WeakReference]
    [java.lang.reflect Array Constructor Field InvocationHandler #_Method Modifier]
    [java.math BigDecimal BigInteger MathContext]
    [java.net JarURLConnection MalformedURLException URL URLClassLoader URLConnection]
    [java.nio ByteBuffer]
    [java.nio.charset Charset]
    [java.security AccessController PrivilegedAction]
    [java.util ArrayList Arrays Collection Comparator Enumeration HashMap HashSet Iterator LinkedList List Map Map$Entry NoSuchElementException Queue RandomAccess Set Stack TreeMap]
    [java.util.concurrent Callable ConcurrentHashMap ConcurrentMap CountDownLatch Executor ExecutorService Executors ThreadFactory TimeUnit]
    [java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicLong AtomicReference]
    [java.util.concurrent.locks ReentrantReadWriteLock]
    [java.util.regex Matcher Pattern]
    [cloiure.asm Attribute ByteVector ClassVisitor ClassWriter FieldVisitor Label MethodVisitor Opcodes Type]
    [cloiure.asm.commons GeneratorAdapter Method]
)

(declare AFn'new AFunction'new AMapEntry'new APersistentMap'new APersistentVector'new AReference'new ASeq'new ATransientMap'new AbortException'new AbstractMap'new ArgReader'new AssignParser'new Attribute'new BigDecimalOps'new BigIntOps'new BodyParser'new CaseParser'new ConditionalReader'new ConstantParser'new CtorReader'new DefParser'new DefaultComparator'new DeftypeParser'new DoubleOps'new EdnCharacterReader'new EdnCommentReader'new EdnDiscardReader'new EdnDispatchReader'new EdnListReader'new EdnMapReader'new EdnMetaReader'new EdnNamespaceMapReader'new EdnSetReader'new EdnStringReader'new EdnSymbolicValueReader'new EdnUnmatchedDelimiterReader'new EdnUnreadableReader'new EdnVectorReader'new EmptyBuffer'new EnumerationSeqState'new Error'new EvalReader'new Exception'new FieldExpr'new FnReader'new HostExpr'new HostParser'new IfParser'new IllegalArgumentException'new ImportParser'new IteratorSeqState'new LetFnParser'new LetParser'new LispCharacterReader'new LispCommentReader'new LispDiscardReader'new LispDispatchReader'new LispListReader'new LispMapReader'new LispMetaReader'new LispNamespaceMapReader'new LispSetReader'new LispStringReader'new LispSymbolicValueReader'new LispUnmatchedDelimiterReader'new LispUnreadableReader'new LispVectorReader'new LiteralExpr'new LockingTransaction'new LongOps'new MethodExpr'new MonitorEnterParser'new MonitorExitParser'new NewParser'new NilExpr'new Number'new Obj'new OpsP'new Primordial'new PushbackReader'new RatioOps'new RecurParser'new RegexReader'new ReifyParser'new RestFn'new RetryEx'new RuntimeException'new SyntaxQuoteReader'new TaggedReader'new TheVarParser'new ThrowParser'new TryParser'new URLClassLoader'new UnquoteReader'new UntypedExpr'new VarReader'new)
(declare AFn'applyToHelper)
(declare ActionQueue'EMPTY ActionQueue'new)
(declare AgentAction'new AgentAction'doRun)
(declare Agent'CONTINUE Agent'FAIL Agent'sendThreadPoolCounter Agent'sendOffThreadPoolCounter Agent'createThreadFactory Agent'pooledExecutor Agent'soloExecutor Agent'nested Agent'shutdown Agent'new-1 Agent'new-2 Agent'dispatchAction Agent'releasePendingSends)
(declare KeySeq'create KeySeq'createFromMap KeySeq'new-2 KeySeq'new-3)
(declare ValSeq'create ValSeq'createFromMap ValSeq'new-2 ValSeq'new-3)
(declare APersistentMap'mapEquals APersistentMap'mapHash APersistentMap'mapHasheq APersistentMap'MAKE_ENTRY APersistentMap'MAKE_KEY APersistentMap'MAKE_VAL)
(declare APersistentSet'new APersistentSet'setEquals)
(declare VSeq'new-2 VSeq'new-3)
(declare RSeq'new-2 RSeq'new-3)
(declare SubVector'new)
(declare APersistentVector'doEquals APersistentVector'doEquiv)
(declare ARef'new-0 ARef'new-1)
(declare AReference'new-0 AReference'new-1)
(declare ArityException'new-2 ArityException'new-3)
(declare ArrayChunk'new-1 ArrayChunk'new-2 ArrayChunk'new-3)
(declare ArrayIter_int'new ArrayIter_float'new ArrayIter_double'new ArrayIter_long'new ArrayIter_byte'new ArrayIter_char'new ArrayIter_short'new ArrayIter_boolean'new ArrayIter'EMPTY_ITERATOR ArrayIter'create-0 ArrayIter'create-1 ArrayIter'createFromObject ArrayIter'new)
(declare ArraySeq_int'new ArraySeq_float'new ArraySeq_double'new ArraySeq_long'new ArraySeq_byte'new ArraySeq_char'new ArraySeq_short'new ArraySeq_boolean'new ArraySeq'create-0 ArraySeq'create-1 ArraySeq'createFromObject ArraySeq'new-2 ArraySeq'new-3)
(declare ASeq'new-1 ASeq'new-0)
(declare Atom'new-1 Atom'new-2)
(declare ATransientMap'NOT_FOUND)
(declare ATransientSet'new)
(declare BigInt'ZERO BigInt'ONE BigInt'new BigInt'fromBigInteger BigInt'fromLong BigInt'valueOf)
(declare Binding'new-1 Binding'new-2)
(declare Box'new)
(declare ChunkBuffer'new)
(declare ChunkedCons'new-3 ChunkedCons'new-2)
(declare Compile'PATH_PROP Compile'REFLECTION_WARNING_PROP Compile'UNCHECKED_MATH_PROP Compile'compile_path Compile'compile Compile'warn_on_reflection Compile'unchecked_math Compile'main)
(declare DefExpr'bindRootMethod DefExpr'setTagMethod DefExpr'setMetaMethod DefExpr'setDynamicMethod DefExpr'symintern DefExpr'internVar DefExpr'new)
(declare AssignExpr'new)
(declare VarExpr'getMethod VarExpr'setMethod VarExpr'new)
(declare TheVarExpr'new)
(declare KeywordExpr'new)
(declare ImportExpr'forNameMethod ImportExpr'importClassMethod ImportExpr'derefMethod ImportExpr'new)
(declare HostExpr'BOOLEAN_TYPE HostExpr'CHAR_TYPE HostExpr'INTEGER_TYPE HostExpr'LONG_TYPE HostExpr'FLOAT_TYPE HostExpr'DOUBLE_TYPE HostExpr'SHORT_TYPE HostExpr'BYTE_TYPE HostExpr'NUMBER_TYPE HostExpr'charValueMethod HostExpr'booleanValueMethod HostExpr'charValueOfMethod HostExpr'intValueOfMethod HostExpr'longValueOfMethod HostExpr'floatValueOfMethod HostExpr'doubleValueOfMethod HostExpr'shortValueOfMethod HostExpr'byteValueOfMethod HostExpr'intValueMethod HostExpr'longValueMethod HostExpr'floatValueMethod HostExpr'doubleValueMethod HostExpr'byteValueMethod HostExpr'shortValueMethod HostExpr'fromIntMethod HostExpr'fromLongMethod HostExpr'fromDoubleMethod HostExpr'emitBoxReturn HostExpr'emitUnboxArg HostExpr'maybeClass HostExpr'maybeSpecialTag HostExpr'tagToClass)
(declare InstanceFieldExpr'invokeNoArgInstanceMember InstanceFieldExpr'setInstanceFieldMethod InstanceFieldExpr'new)
(declare StaticFieldExpr'new)
(declare MethodExpr'emitArgsAsArray MethodExpr'emitTypedArgs)
(declare InstanceMethodExpr'invokeInstanceMethodMethod InstanceMethodExpr'new)
(declare StaticMethodExpr'forNameMethod StaticMethodExpr'invokeStaticMethodMethod StaticMethodExpr'warnOnBoxedKeyword StaticMethodExpr'new StaticMethodExpr'isBoxedMath)
(declare UnresolvedVarExpr'new)
(declare NumberExpr'new NumberExpr'parse)
(declare ConstantParser'formKey)
(declare ConstantExpr'new)
(declare BooleanExpr'new)
(declare StringExpr'new)
(declare MonitorEnterExpr'new)
(declare MonitorExitExpr'new)
(declare CatchClause'new)
(declare TryExpr'new)
(declare ThrowExpr'new)
(declare NewExpr'invokeConstructorMethod NewExpr'forNameMethod NewExpr'new)
(declare MetaExpr'IOBJ_TYPE MetaExpr'withMetaMethod MetaExpr'new)
(declare IfExpr'new)
(declare EmptyExpr'HASHMAP_TYPE EmptyExpr'HASHSET_TYPE EmptyExpr'VECTOR_TYPE EmptyExpr'IVECTOR_TYPE EmptyExpr'TUPLE_TYPE EmptyExpr'LIST_TYPE EmptyExpr'EMPTY_LIST_TYPE EmptyExpr'new)
(declare ListExpr'arrayToListMethod ListExpr'new)
(declare MapExpr'mapMethod MapExpr'mapUniqueKeysMethod MapExpr'new MapExpr'parse)
(declare SetExpr'setMethod SetExpr'new SetExpr'parse)
(declare VectorExpr'vectorMethod VectorExpr'new VectorExpr'parse)
(declare KeywordInvokeExpr'ILOOKUP_TYPE KeywordInvokeExpr'new)
(declare InstanceOfExpr'new)
(declare StaticInvokeExpr'new StaticInvokeExpr'parse)
(declare InvokeExpr'onKey InvokeExpr'methodMapKey InvokeExpr'sigTag InvokeExpr'new InvokeExpr'parse)
(declare SourceDebugExtensionAttribute'new)
(declare FnExpr'aFnType FnExpr'restFnType FnExpr'new FnExpr'parse)
(declare ObjExpr'CONST_PREFIX ObjExpr'voidctor ObjExpr'kwintern ObjExpr'symintern ObjExpr'varintern ObjExpr'DYNAMIC_CLASSLOADER_TYPE ObjExpr'getClassMethod ObjExpr'getClassLoaderMethod ObjExpr'getConstantsMethod ObjExpr'readStringMethod ObjExpr'ILOOKUP_SITE_TYPE ObjExpr'ILOOKUP_THUNK_TYPE ObjExpr'KEYWORD_LOOKUPSITE_TYPE ObjExpr'new ObjExpr'trimGenID ObjExpr'varGetMethod ObjExpr'varGetRawMethod)
(declare PathNode'new)
(declare FnMethod'new FnMethod'classChar FnMethod'primInterface FnMethod'parse)
(declare ObjMethod'new ObjMethod'emitBody)
(declare LocalBinding'new)
(declare LocalBindingExpr'new)
(declare BodyExpr'new)
(declare BindingInit'new)
(declare LetFnExpr'new)
(declare LetExpr'new)
(declare RecurExpr'new)
(declare CompilerException'new)
(declare NewInstanceExpr'new NewInstanceExpr'build NewInstanceExpr'compileStub NewInstanceExpr'interfaceNames NewInstanceExpr'slashname NewInstanceExpr'msig NewInstanceExpr'considerMethod NewInstanceExpr'gatherMethods-2m NewInstanceExpr'gatherMethods-2s)
(declare NewInstanceMethod'dummyThis NewInstanceMethod'new NewInstanceMethod'msig NewInstanceMethod'parse NewInstanceMethod'findMethodsWithNameAndArity NewInstanceMethod'findMethodsWithName)
(declare MethodParamExpr'new)
(declare CaseExpr'NUMBER_TYPE CaseExpr'intValueMethod CaseExpr'hashMethod CaseExpr'hashCodeMethod CaseExpr'equivMethod CaseExpr'compactKey CaseExpr'sparseKey CaseExpr'hashIdentityKey CaseExpr'hashEquivKey CaseExpr'intKey CaseExpr'new CaseExpr'emitExpr)
(declare Compiler'DEF Compiler'LOOP Compiler'RECUR Compiler'IF Compiler'LET Compiler'LETFN Compiler'DO Compiler'FN Compiler'FNONCE Compiler'QUOTE Compiler'THE_VAR Compiler'DOT Compiler'ASSIGN Compiler'TRY Compiler'CATCH Compiler'FINALLY Compiler'THROW Compiler'MONITOR_ENTER Compiler'MONITOR_EXIT Compiler'IMPORT Compiler'DEFTYPE Compiler'CASE Compiler'CLASS Compiler'NEW Compiler'THIS Compiler'REIFY Compiler'LIST Compiler'HASHMAP Compiler'VECTOR Compiler'IDENTITY Compiler'_AMP_ Compiler'ISEQ Compiler'loadNs Compiler'inlineKey Compiler'inlineAritiesKey Compiler'staticKey Compiler'arglistsKey Compiler'INVOKE_STATIC Compiler'volatileKey Compiler'implementsKey Compiler'COMPILE_STUB_PREFIX Compiler'protocolKey Compiler'onKey Compiler'dynamicKey Compiler'redefKey Compiler'NS Compiler'IN_NS Compiler'specials Compiler'MAX_POSITIONAL_ARITY Compiler'OBJECT_TYPE Compiler'KEYWORD_TYPE Compiler'VAR_TYPE Compiler'SYMBOL_TYPE Compiler'IFN_TYPE Compiler'AFUNCTION_TYPE Compiler'RT_TYPE Compiler'NUMBERS_TYPE Compiler'CLASS_TYPE Compiler'NS_TYPE Compiler'UTIL_TYPE Compiler'REFLECTOR_TYPE Compiler'THROWABLE_TYPE Compiler'BOOLEAN_OBJECT_TYPE Compiler'IPERSISTENTMAP_TYPE Compiler'IOBJ_TYPE Compiler'TUPLE_TYPE Compiler'createTupleMethods Compiler'ARG_TYPES Compiler'EXCEPTION_TYPES Compiler'LOCAL_ENV Compiler'LOOP_LOCALS Compiler'LOOP_LABEL Compiler'CONSTANTS Compiler'CONSTANT_IDS Compiler'KEYWORD_CALLSITES Compiler'PROTOCOL_CALLSITES Compiler'VAR_CALLSITES Compiler'KEYWORDS Compiler'VARS Compiler'METHOD Compiler'IN_CATCH_FINALLY Compiler'METHOD_RETURN_CONTEXT Compiler'NO_RECUR Compiler'LOADER Compiler'SOURCE Compiler'SOURCE_PATH Compiler'COMPILE_PATH Compiler'COMPILE_FILES Compiler'INSTANCE Compiler'ADD_ANNOTATIONS Compiler'disableLocalsClearingKey Compiler'directLinkingKey Compiler'elideMetaKey Compiler'COMPILER_OPTIONS Compiler'getCompilerOption Compiler'elideMeta Compiler'LINE Compiler'COLUMN Compiler'lineDeref Compiler'columnDeref Compiler'LINE_BEFORE Compiler'COLUMN_BEFORE Compiler'LINE_AFTER Compiler'COLUMN_AFTER Compiler'NEXT_LOCAL_NUM Compiler'RET_LOCAL_NUM Compiler'COMPILE_STUB_SYM Compiler'COMPILE_STUB_CLASS Compiler'CLEAR_PATH Compiler'CLEAR_ROOT Compiler'CLEAR_SITES Compiler'RECUR_CLASS Compiler'isSpecial Compiler'inTailCall Compiler'resolveSymbol Compiler'maybePrimitiveType Compiler'maybeJavaClass Compiler'NIL_EXPR Compiler'TRUE_EXPR Compiler'FALSE_EXPR Compiler'subsumes Compiler'getTypeStringForArgs Compiler'getMatchingParams Compiler'CHAR_MAP Compiler'DEMUNGE_MAP Compiler'DEMUNGE_PATTERN Compiler'munge Compiler'demunge Compiler'clearPathRoot Compiler'registerLocal Compiler'getAndIncLocalNum Compiler'analyze-2 Compiler'analyze-3 Compiler'isMacro Compiler'isInline Compiler'namesStaticMember Compiler'preserveTag Compiler'MACRO_CHECK Compiler'MACRO_CHECK_LOADING Compiler'MACRO_CHECK_LOCK Compiler'ensureMacroCheck Compiler'checkSpecs Compiler'macroexpand1 Compiler'macroexpand Compiler'analyzeSeq Compiler'errorMsg Compiler'eval-1 Compiler'eval-2 Compiler'registerConstant Compiler'registerKeyword Compiler'registerKeywordCallsite Compiler'registerProtocolCallsite Compiler'registerVarCallsite Compiler'fwdPath Compiler'commonPath Compiler'addAnnotation Compiler'addParameterAnnotation Compiler'analyzeSymbol Compiler'destubClassName Compiler'getType Compiler'resolve-2 Compiler'resolve-1 Compiler'namespaceFor-1 Compiler'namespaceFor-2 Compiler'resolveIn Compiler'maybeResolveIn Compiler'lookupVar-3 Compiler'lookupVar-2 Compiler'registerVar Compiler'currentNS Compiler'closeOver Compiler'referenceLocal Compiler'tagOf Compiler'loadFile Compiler'load-1 Compiler'consumeWhitespaces Compiler'OPTS_COND_ALLOWED Compiler'readerOpts Compiler'load-3 Compiler'writeClassFile Compiler'pushNS Compiler'pushNSandLoader Compiler'getLookupThunk Compiler'compile1 Compiler'compile Compiler'inty Compiler'retType Compiler'primClass-1s Compiler'tagClass Compiler'primClass-1c Compiler'boxClass Compiler'emptyVarCallSites)
(declare Cons'new-2 Cons'new-3)
(declare Cycle'new-3 Cycle'new-5 Cycle'create)
(declare Delay'new Delay'force)
(declare DynamicClassLoader'classCache DynamicClassLoader'EMPTY_URLS DynamicClassLoader'RQ DynamicClassLoader'new-0 DynamicClassLoader'new-1 DynamicClassLoader'findInMemoryClass)
(declare EdnReaderException'new)
(declare EdnSymbolicValueReader'specials)
(declare TaggedReader'READERS TaggedReader'DEFAULT)
(declare EdnReader'macros EdnReader'dispatchMacros EdnReader'symbolPat EdnReader'intPat EdnReader'ratioPat EdnReader'floatPat EdnReader'taggedReader EdnReader'nonConstituent EdnReader'readString EdnReader'isWhitespace EdnReader'unread EdnReader'read1 EdnReader'EOF EdnReader'read-2 EdnReader'read-5 EdnReader'readToken EdnReader'readNumber EdnReader'readUnicodeChar-4 EdnReader'readUnicodeChar-5 EdnReader'interpretToken EdnReader'matchSymbol EdnReader'matchNumber EdnReader'getMacro EdnReader'isMacro EdnReader'isTerminatingMacro EdnReader'readDelimitedList)
(declare EnumerationSeq'create EnumerationSeq'new-1 EnumerationSeq'new-3)
(declare ExceptionInfo'new-2 ExceptionInfo'new-3)
(declare FnLoaderThunk'new)
(declare Intrinsics'oa Intrinsics'ops Intrinsics'preds)
(declare Iterate'UNREALIZED_SEED Iterate'new-3 Iterate'new-5 Iterate'create)
(declare IteratorSeq'create IteratorSeq'new-1 IteratorSeq'new-3)
(declare Keyword'TABLE Keyword'RQ Keyword'intern Keyword'intern-2 Keyword'intern-1 Keyword'new Keyword'find Keyword'find-2 Keyword'find-1)
(declare KeywordLookupSite'new)
(declare LazilyPersistentVector'createOwning LazilyPersistentVector'fcount LazilyPersistentVector'create)
(declare LazySeq'new-1 LazySeq'new-2)
(declare LineNumberingPushbackReader'newline LineNumberingPushbackReader'new-1 LineNumberingPushbackReader'new-2)
(declare LispReaderException'new)
(declare RegexReader'stringrdr)
(declare LispSymbolicValueReader'specials)
(declare WrappingReader'new)
(declare DeprecatedWrappingReader'new)
(declare SyntaxQuoteReader'syntaxQuote SyntaxQuoteReader'sqExpandList SyntaxQuoteReader'flattenMap)
(declare ConditionalReader'READ_STARTED ConditionalReader'DEFAULT_FEATURE ConditionalReader'RESERVED_FEATURES ConditionalReader'hasFeature ConditionalReader'readCondDelimited ConditionalReader'checkConditionalAllowed)
(declare LispReader'QUOTE LispReader'THE_VAR LispReader'UNQUOTE LispReader'UNQUOTE_SPLICING LispReader'CONCAT LispReader'SEQ LispReader'LIST LispReader'APPLY LispReader'HASHMAP LispReader'HASHSET LispReader'VECTOR LispReader'WITH_META LispReader'META LispReader'DEREF LispReader'READ_COND LispReader'READ_COND_SPLICING LispReader'UNKNOWN LispReader'macros LispReader'dispatchMacros LispReader'symbolPat LispReader'intPat LispReader'ratioPat LispReader'floatPat LispReader'GENSYM_ENV LispReader'ARG_ENV LispReader'ctorReader LispReader'READ_COND_ENV LispReader'isWhitespace LispReader'unread LispReader'read1 LispReader'OPT_EOF LispReader'OPT_FEATURES LispReader'OPT_READ_COND LispReader'EOFTHROW LispReader'PLATFORM_KEY LispReader'PLATFORM_FEATURES LispReader'COND_ALLOW LispReader'COND_PRESERVE LispReader'read-2 LispReader'read-4 LispReader'read-5 LispReader'read-6 LispReader'ensurePending LispReader'installPlatformFeature LispReader'read-9 LispReader'readToken LispReader'readNumber LispReader'readUnicodeChar-4 LispReader'readUnicodeChar-5 LispReader'interpretToken LispReader'matchSymbol LispReader'matchNumber LispReader'getMacro LispReader'isMacro LispReader'isTerminatingMacro LispReader'garg LispReader'registerArg LispReader'isUnquoteSplicing LispReader'isUnquote LispReader'READ_EOF LispReader'READ_FINISHED LispReader'readDelimitedList LispReader'isPreserveReadCond)
(declare LockingTransactionInfo'new)
(declare CFn'new)
(declare Notify'new)
(declare LockingTransaction'RETRY_LIMIT LockingTransaction'LOCK_WAIT_MSECS LockingTransaction'BARGE_WAIT_NANOS LockingTransaction'RUNNING LockingTransaction'COMMITTING LockingTransaction'RETRY LockingTransaction'KILLED LockingTransaction'COMMITTED LockingTransaction'transaction LockingTransaction'lastPoint LockingTransaction'getEx LockingTransaction'isRunning LockingTransaction'getRunning LockingTransaction'runInTransaction)
(declare LongRangeIterator'new)
(declare LongChunk'new)
(declare LongRange'CHUNK_SIZE LongRange'positiveStep LongRange'negativeStep LongRange'new-4 LongRange'new-6 LongRange'new-7 LongRange'create-1 LongRange'create-2 LongRange'create-3)
(declare MapEntry'create MapEntry'new)
(declare Entry'new)
(declare MethodImplCache'new-2 MethodImplCache'new-5 MethodImplCache'new-3)
(declare MultiFn'assoc MultiFn'dissoc MultiFn'isa MultiFn'parents MultiFn'new)
(declare Murmur3'seed Murmur3'C1 Murmur3'C2 Murmur3'hashInt Murmur3'hashLong Murmur3'hashUnencodedChars Murmur3'mixCollHash Murmur3'hashOrdered Murmur3'hashUnordered Murmur3'mixK1 Murmur3'mixH1 Murmur3'fmix)
(declare Namespace'namespaces Namespace'new Namespace'all Namespace'areDifferentInstancesOfSameClassName Namespace'findOrCreate Namespace'remove Namespace'find)
(declare LongOps'gcd)
(declare RatioOps'normalizeRet)
(declare BigDecimalOps'MATH_CONTEXT)
(declare Numbers'isZero-1o Numbers'isPos-1o Numbers'isNeg-1o Numbers'minus-1o Numbers'minusP-1o Numbers'inc-1o Numbers'incP-1o Numbers'dec-1o Numbers'decP-1o Numbers'add-2oo Numbers'addP-2oo Numbers'minus-2oo Numbers'minusP-2oo Numbers'multiply-2oo Numbers'multiplyP-2oo Numbers'divide-2oo Numbers'quotient-2oo Numbers'remainder-2oo Numbers'quotient-2dd Numbers'remainder-2dd Numbers'equiv-2oo Numbers'equiv-2nn Numbers'equal Numbers'lt-2oo Numbers'lte-2oo Numbers'gt-2oo Numbers'gte-2oo Numbers'compare Numbers'toBigInt Numbers'toBigInteger Numbers'toBigDecimal Numbers'toRatio Numbers'rationalize Numbers'reduceBigInt Numbers'divide-2ii Numbers'shiftLeftInt Numbers'shiftLeft-2oo Numbers'shiftLeft-2ol Numbers'shiftLeft-2lo Numbers'shiftLeft-2ll Numbers'shiftRightInt Numbers'shiftRight-2oo Numbers'shiftRight-2ol Numbers'shiftRight-2lo Numbers'shiftRight-2ll Numbers'unsignedShiftRightInt Numbers'unsignedShiftRight-2oo Numbers'unsignedShiftRight-2ol Numbers'unsignedShiftRight-2lo Numbers'unsignedShiftRight-2ll Numbers'LONG_OPS Numbers'DOUBLE_OPS Numbers'RATIO_OPS Numbers'BIGINT_OPS Numbers'BIGDECIMAL_OPS Numbers'ops Numbers'hasheqFrom Numbers'hasheq Numbers'category Numbers'bitOpsCast Numbers'float_array-2 Numbers'float_array-1 Numbers'double_array-2 Numbers'double_array-1 Numbers'int_array-2 Numbers'int_array-1 Numbers'long_array-2 Numbers'long_array-1 Numbers'short_array-2 Numbers'short_array-1 Numbers'char_array-2 Numbers'char_array-1 Numbers'byte_array-2 Numbers'byte_array-1 Numbers'boolean_array-2 Numbers'boolean_array-1 Numbers'booleans Numbers'bytes Numbers'chars Numbers'shorts Numbers'floats Numbers'doubles Numbers'ints Numbers'longs Numbers'num-1o Numbers'num-1f Numbers'num-1d Numbers'add-2dd Numbers'addP-2dd Numbers'minus-2dd Numbers'minusP-2dd Numbers'minus-1d Numbers'minusP-1d Numbers'inc-1d Numbers'incP-1d Numbers'dec-1d Numbers'decP-1d Numbers'multiply-2dd Numbers'multiplyP-2dd Numbers'divide-2dd Numbers'equiv-2dd Numbers'lt-2dd Numbers'lte-2dd Numbers'gt-2dd Numbers'gte-2dd Numbers'isPos-1d Numbers'isNeg-1d Numbers'isZero-1d Numbers'throwIntOverflow Numbers'unchecked_int_add Numbers'unchecked_int_subtract Numbers'unchecked_int_negate Numbers'unchecked_int_inc Numbers'unchecked_int_dec Numbers'unchecked_int_multiply Numbers'not-1o Numbers'not-1l Numbers'and-2oo Numbers'and-2ol Numbers'and-2lo Numbers'and-2ll Numbers'or-2oo Numbers'or-2ol Numbers'or-2lo Numbers'or-2ll Numbers'xor-2oo Numbers'xor-2ol Numbers'xor-2lo Numbers'xor-2ll Numbers'andNot-2oo Numbers'andNot-2ol Numbers'andNot-2lo Numbers'andNot-2ll Numbers'clearBit-2oo Numbers'clearBit-2ol Numbers'clearBit-2lo Numbers'clearBit-2ll Numbers'setBit-2oo Numbers'setBit-2ol Numbers'setBit-2lo Numbers'setBit-2ll Numbers'flipBit-2oo Numbers'flipBit-2ol Numbers'flipBit-2lo Numbers'flipBit-2ll Numbers'testBit-2oo Numbers'testBit-2ol Numbers'testBit-2lo Numbers'testBit-2ll Numbers'unchecked_int_divide Numbers'unchecked_int_remainder Numbers'num-1l Numbers'unchecked_add-2ll Numbers'unchecked_minus-2ll Numbers'unchecked_multiply-2ll Numbers'unchecked_minus-1l Numbers'unchecked_inc-1l Numbers'unchecked_dec-1l Numbers'unchecked_add-2oo Numbers'unchecked_minus-2oo Numbers'unchecked_multiply-2oo Numbers'unchecked_minus-1o Numbers'unchecked_inc-1o Numbers'unchecked_dec-1o Numbers'unchecked_add-2dd Numbers'unchecked_minus-2dd Numbers'unchecked_multiply-2dd Numbers'unchecked_minus-1d Numbers'unchecked_inc-1d Numbers'unchecked_dec-1d Numbers'unchecked_add-2do Numbers'unchecked_minus-2do Numbers'unchecked_multiply-2do Numbers'unchecked_add-2od Numbers'unchecked_minus-2od Numbers'unchecked_multiply-2od Numbers'unchecked_add-2dl Numbers'unchecked_minus-2dl Numbers'unchecked_multiply-2dl Numbers'unchecked_add-2ld Numbers'unchecked_minus-2ld Numbers'unchecked_multiply-2ld Numbers'unchecked_add-2lo Numbers'unchecked_minus-2lo Numbers'unchecked_multiply-2lo Numbers'unchecked_add-2ol Numbers'unchecked_minus-2ol Numbers'unchecked_multiply-2ol Numbers'quotient-2do Numbers'quotient-2od Numbers'quotient-2lo Numbers'quotient-2ol Numbers'quotient-2dl Numbers'quotient-2ld Numbers'remainder-2do Numbers'remainder-2od Numbers'remainder-2lo Numbers'remainder-2ol Numbers'remainder-2dl Numbers'remainder-2ld Numbers'add-2ll Numbers'addP-2ll Numbers'minus-2ll Numbers'minusP-2ll Numbers'minus-1l Numbers'minusP-1l Numbers'inc-1l Numbers'incP-1l Numbers'dec-1l Numbers'decP-1l Numbers'multiply-2ll Numbers'multiplyP-2ll Numbers'quotient-2ll Numbers'remainder-2ll Numbers'equiv-2ll Numbers'lt-2ll Numbers'lte-2ll Numbers'gt-2ll Numbers'gte-2ll Numbers'isPos-1l Numbers'isNeg-1l Numbers'isZero-1l Numbers'add-2lo Numbers'add-2ol Numbers'addP-2lo Numbers'addP-2ol Numbers'add-2do Numbers'add-2od Numbers'add-2dl Numbers'add-2ld Numbers'addP-2do Numbers'addP-2od Numbers'addP-2dl Numbers'addP-2ld Numbers'minus-2lo Numbers'minus-2ol Numbers'minusP-2lo Numbers'minusP-2ol Numbers'minus-2do Numbers'minus-2od Numbers'minus-2dl Numbers'minus-2ld Numbers'minusP-2do Numbers'minusP-2od Numbers'minusP-2dl Numbers'minusP-2ld Numbers'multiply-2lo Numbers'multiply-2ol Numbers'multiplyP-2lo Numbers'multiplyP-2ol Numbers'multiply-2do Numbers'multiply-2od Numbers'multiply-2dl Numbers'multiply-2ld Numbers'multiplyP-2do Numbers'multiplyP-2od Numbers'multiplyP-2dl Numbers'multiplyP-2ld Numbers'divide-2lo Numbers'divide-2ol Numbers'divide-2do Numbers'divide-2od Numbers'divide-2dl Numbers'divide-2ld Numbers'divide-2ll Numbers'lt-2lo Numbers'lt-2ol Numbers'lt-2do Numbers'lt-2od Numbers'lt-2dl Numbers'lt-2ld Numbers'lte-2lo Numbers'lte-2ol Numbers'lte-2do Numbers'lte-2od Numbers'lte-2dl Numbers'lte-2ld Numbers'gt-2lo Numbers'gt-2ol Numbers'gt-2do Numbers'gt-2od Numbers'gt-2dl Numbers'gt-2ld Numbers'gte-2lo Numbers'gte-2ol Numbers'gte-2do Numbers'gte-2od Numbers'gte-2dl Numbers'gte-2ld Numbers'equiv-2lo Numbers'equiv-2ol Numbers'equiv-2do Numbers'equiv-2od Numbers'equiv-2dl Numbers'equiv-2ld Numbers'isNaN Numbers'max-2dd Numbers'max-2dl Numbers'max-2do Numbers'max-2ld Numbers'max-2ll Numbers'max-2lo Numbers'max-2ol Numbers'max-2od Numbers'max-2oo Numbers'min-2dd Numbers'min-2dl Numbers'min-2do Numbers'min-2ld Numbers'min-2ll Numbers'min-2lo Numbers'min-2ol Numbers'min-2od Numbers'min-2oo)
(declare Obj'new-1 Obj'new-0)
(declare MSeq'new-2 MSeq'new-3)
(declare MIter'new-2 MIter'new-3)
(declare TransientArrayMap'new)
(declare PersistentArrayMap'EMPTY PersistentArrayMap'HASHTABLE_THRESHOLD PersistentArrayMap'create PersistentArrayMap'new-0 PersistentArrayMap'createWithCheck PersistentArrayMap'createAsIfByAssoc PersistentArrayMap'new-1 PersistentArrayMap'new-2 PersistentArrayMap'equalKey)
(declare TransientHashMap'new-1 TransientHashMap'new-5)
(declare HSeq'create-1 HSeq'create-4 HSeq'new)
(declare HIter'new)
(declare ArrayNode'new ArrayNode'foldTasks)
(declare BitmapIndexedNode'EMPTY BitmapIndexedNode'new)
(declare HashCollisionNode'new)
(declare NodeIter'NULL NodeIter'new)
(declare NodeSeq'new-2 NodeSeq'create-1 NodeSeq'kvreduce NodeSeq'create-3 NodeSeq'new-4)
(declare PersistentHashMap'EMPTY PersistentHashMap'NOT_FOUND PersistentHashMap'create-1m PersistentHashMap'create-1a PersistentHashMap'createWithCheck-1a PersistentHashMap'create-1s PersistentHashMap'createWithCheck-1s PersistentHashMap'create-2 PersistentHashMap'new-4 PersistentHashMap'new-5 PersistentHashMap'hash PersistentHashMap'EMPTY_ITER PersistentHashMap'mask PersistentHashMap'cloneAndSet-3 PersistentHashMap'cloneAndSet-5 PersistentHashMap'removePair PersistentHashMap'createNode-6 PersistentHashMap'createNode-7 PersistentHashMap'bitpos)
(declare TransientHashSet'new)
(declare PersistentHashSet'EMPTY PersistentHashSet'create-1a PersistentHashSet'create-1l PersistentHashSet'create-1s PersistentHashSet'createWithCheck-1a PersistentHashSet'createWithCheck-1l PersistentHashSet'createWithCheck-1s PersistentHashSet'new)
(declare Primordial'invokeStatic)
(declare EmptyList'HASHEQ EmptyList'new EmptyList'hasheq)
(declare PersistentList'creator PersistentList'EMPTY PersistentList'new-1 PersistentList'new-4 PersistentList'create)
(declare QSeq'new-2 QSeq'new-3)
(declare PersistentQueue'EMPTY PersistentQueue'new)
(declare TNode'new)
(declare Black'new)
(declare BlackVal'new)
(declare BlackBranch'new)
(declare BlackBranchVal'new)
(declare Red'new)
(declare RedVal'new)
(declare RedBranch'new)
(declare RedBranchVal'new)
(declare TSeq'new-2 TSeq'new-3 TSeq'new-4 TSeq'create TSeq'push)
(declare NodeIterator'new)
(declare KeyIterator'new)
(declare ValIterator'new)
(declare PersistentTreeMap'EMPTY PersistentTreeMap'create-1m PersistentTreeMap'new-0 PersistentTreeMap'new-1 PersistentTreeMap'new-2 PersistentTreeMap'new-4m PersistentTreeMap'create-1s PersistentTreeMap'create-2 PersistentTreeMap'append PersistentTreeMap'balanceLeftDel PersistentTreeMap'balanceRightDel PersistentTreeMap'leftBalance PersistentTreeMap'rightBalance PersistentTreeMap'new-4c PersistentTreeMap'red PersistentTreeMap'black)
(declare PersistentTreeSet'EMPTY PersistentTreeSet'create-1 PersistentTreeSet'create-2 PersistentTreeSet'new)
(declare VNode'new-2 VNode'new-1)
(declare ChunkedSeq'new-3 ChunkedSeq'new-5 ChunkedSeq'new-4)
(declare TransientVector'new-4 TransientVector'new-1 TransientVector'editableRoot TransientVector'editableTail TransientVector'NOT_FOUND)
(declare PersistentVector'NOEDIT PersistentVector'EMPTY_NODE PersistentVector'EMPTY PersistentVector'TRANSIENT_VECTOR_CONJ PersistentVector'adopt PersistentVector'create-1r PersistentVector'create-1s PersistentVector'create-1l PersistentVector'create-1i PersistentVector'create-1a PersistentVector'new-4 PersistentVector'new-5 PersistentVector'doAssoc PersistentVector'newPath)
(declare ProxyHandler'new)
(declare RangeIterator'new)
(declare Range'CHUNK_SIZE Range'positiveStep Range'negativeStep Range'new-4 Range'new-6 Range'new-7 Range'create-1 Range'create-2 Range'create-3)
(declare Ratio'new)
(declare ReaderConditional'FORM_KW ReaderConditional'SPLICING_KW ReaderConditional'create ReaderConditional'new)
(declare RecordIterator'new)
(declare Reduced'new)
(declare RefTVal'new-3 RefTVal'new-2)
(declare Ref'ids Ref'new-1 Ref'new-2)
(declare Reflector'invokeInstanceMethod Reflector'getCauseOrElse Reflector'throwCauseOrElseException Reflector'noMethodReport Reflector'invokeMatchingMethod Reflector'getAsMethodOfPublicBase Reflector'isMatch Reflector'invokeConstructor Reflector'invokeStaticMethodVariadic Reflector'invokeStaticMethod-3s Reflector'invokeStaticMethod-3c Reflector'getStaticField-2s Reflector'getStaticField-2c Reflector'setStaticField-3s Reflector'setStaticField-3c Reflector'getInstanceField Reflector'setInstanceField Reflector'invokeNoArgInstanceMember-2 Reflector'invokeNoArgInstanceMember-3 Reflector'invokeInstanceMember-2 Reflector'invokeInstanceMember-3o Reflector'invokeInstanceMember-3a Reflector'getField Reflector'getMethods Reflector'boxArg Reflector'boxArgs Reflector'paramArgTypeMatch Reflector'isCongruent Reflector'prepRet)
(declare Repeat'INFINITE Repeat'new-2 Repeat'new-3 Repeat'create-1 Repeat'create-2)
(declare RestFn'ontoArrayPrepend RestFn'findKey)
(declare RT'T RT'F RT'LOADER_SUFFIX RT'DEFAULT_IMPORTS RT'UTF8 RT'readTrueFalseUnknown RT'CLOIURE_NS RT'OUT RT'IN RT'ERR RT'TAG_KEY RT'CONST_KEY RT'AGENT RT'readeval RT'READEVAL RT'DATA_READERS RT'DEFAULT_DATA_READER_FN RT'DEFAULT_DATA_READERS RT'SUPPRESS_READ RT'ASSERT RT'MATH_CONTEXT RT'LINE_KEY RT'COLUMN_KEY RT'FILE_KEY RT'DECLARED_KEY RT'DOC_KEY RT'USE_CONTEXT_CLASSLOADER RT'UNCHECKED_MATH RT'LOAD_FILE RT'IN_NAMESPACE RT'NAMESPACE RT'IDENTICAL RT'CMD_LINE_ARGS RT'CURRENT_NS RT'FLUSH_ON_NEWLINE RT'PRINT_META RT'PRINT_READABLY RT'PRINT_DUP RT'WARN_ON_REFLECTION RT'ALLOW_UNRESOLVED_VARS RT'READER_RESOLVER RT'IN_NS_VAR RT'NS_VAR RT'FN_LOADER_VAR RT'PRINT_INITIALIZED RT'PR_ON RT'inNamespace RT'bootNamespace RT'processCommandLine RT'errPrintWriter RT'EMPTY_ARRAY RT'DEFAULT_COMPARATOR RT'ID RT'addURL RT'CHECK_SPEC_ASSERTS RT'INSTRUMENT_MACROS RT'CHECK_SPECS RT'keyword RT'var-2 RT'var-3 RT'loadResourceScript-1 RT'maybeLoadResourceScript RT'loadResourceScript-2s RT'loadResourceScript-2c RT'loadResourceScript-3 RT'lastModified RT'compile RT'load-1 RT'load-2 RT'doInit RT'nextID RT'loadLibrary RT'CHUNK_SIZE RT'chunkIteratorSeq RT'seq RT'seqFrom RT'canSeq RT'iter RT'seqOrElse RT'keys RT'vals RT'meta RT'count RT'countFrom RT'conj RT'cons RT'first RT'second RT'third RT'fourth RT'next RT'more RT'peek RT'pop RT'get-2 RT'getFrom-2 RT'get-3 RT'getFrom-3 RT'assoc RT'contains RT'find RT'findKey RT'dissoc RT'nth-2 RT'nthFrom-2 RT'nth-3 RT'nthFrom-3 RT'assocN RT'hasTag RT'box-1o RT'box-1c RT'box-1z RT'box-1Z RT'box-1b RT'box-1s RT'box-1i RT'box-1l RT'box-1f RT'box-1d RT'charCast-1o RT'charCast-1b RT'charCast-1s RT'charCast-1c RT'charCast-1i RT'charCast-1l RT'charCast-1f RT'charCast-1d RT'booleanCast-1o RT'booleanCast-1b RT'byteCast-1o RT'byteCast-1b RT'byteCast-1s RT'byteCast-1i RT'byteCast-1l RT'byteCast-1f RT'byteCast-1d RT'shortCast-1o RT'shortCast-1b RT'shortCast-1s RT'shortCast-1i RT'shortCast-1l RT'shortCast-1f RT'shortCast-1d RT'intCast-1o RT'intCast-1c RT'intCast-1b RT'intCast-1s RT'intCast-1i RT'intCast-1f RT'intCast-1l RT'intCast-1d RT'longCast-1o RT'longCast-1b RT'longCast-1s RT'longCast-1i RT'longCast-1f RT'longCast-1l RT'longCast-1d RT'floatCast-1o RT'floatCast-1b RT'floatCast-1s RT'floatCast-1i RT'floatCast-1f RT'floatCast-1l RT'floatCast-1d RT'doubleCast-1o RT'doubleCast-1b RT'doubleCast-1s RT'doubleCast-1i RT'doubleCast-1f RT'doubleCast-1l RT'doubleCast-1d RT'uncheckedByteCast-1o RT'uncheckedByteCast-1b RT'uncheckedByteCast-1s RT'uncheckedByteCast-1i RT'uncheckedByteCast-1l RT'uncheckedByteCast-1f RT'uncheckedByteCast-1d RT'uncheckedShortCast-1o RT'uncheckedShortCast-1b RT'uncheckedShortCast-1s RT'uncheckedShortCast-1i RT'uncheckedShortCast-1l RT'uncheckedShortCast-1f RT'uncheckedShortCast-1d RT'uncheckedCharCast-1o RT'uncheckedCharCast-1b RT'uncheckedCharCast-1s RT'uncheckedCharCast-1c RT'uncheckedCharCast-1i RT'uncheckedCharCast-1l RT'uncheckedCharCast-1f RT'uncheckedCharCast-1d RT'uncheckedIntCast-1o RT'uncheckedIntCast-1b RT'uncheckedIntCast-1s RT'uncheckedIntCast-1c RT'uncheckedIntCast-1i RT'uncheckedIntCast-1l RT'uncheckedIntCast-1f RT'uncheckedIntCast-1d RT'uncheckedLongCast-1o RT'uncheckedLongCast-1b RT'uncheckedLongCast-1s RT'uncheckedLongCast-1i RT'uncheckedLongCast-1l RT'uncheckedLongCast-1f RT'uncheckedLongCast-1d RT'uncheckedFloatCast-1o RT'uncheckedFloatCast-1b RT'uncheckedFloatCast-1s RT'uncheckedFloatCast-1i RT'uncheckedFloatCast-1l RT'uncheckedFloatCast-1f RT'uncheckedFloatCast-1d RT'uncheckedDoubleCast-1o RT'uncheckedDoubleCast-1b RT'uncheckedDoubleCast-1s RT'uncheckedDoubleCast-1i RT'uncheckedDoubleCast-1l RT'uncheckedDoubleCast-1f RT'uncheckedDoubleCast-1d RT'map RT'mapUniqueKeys RT'set RT'vector RT'subvec RT'list-0 RT'list-1 RT'list-2 RT'list-3 RT'list-4 RT'list-5 RT'listStar-2 RT'listStar-3 RT'listStar-4 RT'listStar-5 RT'listStar-6 RT'arrayToList RT'object_array RT'toArray RT'seqToArray RT'seqToPassedArray RT'seqToTypedArray-1 RT'seqToTypedArray-2 RT'length RT'boundedLength RT'readRet RT'readChar RT'peekChar RT'getLineNumber RT'getColumnNumber RT'getLineNumberingReader RT'isLineNumberingReader RT'isReduced RT'resolveClassNameInContext RT'suppressRead RT'printString RT'readString-1 RT'readString-2 RT'print RT'printInnerSeq RT'formatAesthetic RT'formatStandard RT'format RT'doFormat RT'setValues RT'makeClassLoader RT'baseLoader RT'resourceAsStream RT'getResource RT'classForName-3 RT'classForName-1 RT'classForNameNonLoading RT'loadClassForName RT'aget-2f RT'aset-3f RT'alength-1f RT'aclone-1f RT'aget-2d RT'aset-3d RT'alength-1d RT'aclone-1d RT'aget-2i RT'aset-3i RT'alength-1i RT'aclone-1i RT'aget-2l RT'aset-3l RT'alength-1l RT'aclone-1l RT'aget-2c RT'aset-3c RT'alength-1c RT'aclone-1c RT'aget-2b RT'aset-3b RT'alength-1b RT'aclone-1b RT'aget-2s RT'aset-3s RT'alength-1s RT'aclone-1s RT'aget-2z RT'aset-3z RT'alength-1z RT'aclone-1z RT'aget-2o RT'aset-3o RT'alength-1o RT'aclone-1o)
(declare SeqEnumeration'new)
(declare SeqIterator'START SeqIterator'new)
(declare StringSeq'create StringSeq'new)
(declare Symbol'create-2 Symbol'create-1 Symbol'intern-2 Symbol'intern-1 Symbol'new-2 Symbol'new-3)
(declare TaggedLiteral'TAG_KW TaggedLiteral'FORM_KW TaggedLiteral'create TaggedLiteral'new)
(declare TransactionalHashMap'new-0 TransactionalHashMap'new-1i TransactionalHashMap'new-1m)
(declare SingleBuffer'new)
(declare ManyBuffer'new)
(declare MultiIterator'new)
(declare TransformerIterator'EMPTY TransformerIterator'NONE TransformerIterator'new TransformerIterator'create TransformerIterator'createMulti)
(declare Tuple'MAX_SIZE Tuple'create-0 Tuple'create-1 Tuple'create-2 Tuple'create-3 Tuple'create-4 Tuple'create-5 Tuple'create-6)
(declare Util'equiv-2oo Util'equivNull Util'equivEquals Util'equivNumber Util'equivColl Util'equivPred Util'equiv-2ll Util'equiv-2ol Util'equiv-2lo Util'equiv-2dd Util'equiv-2od Util'equiv-2do Util'equiv-2bb Util'equiv-2ob Util'equiv-2bo Util'equiv-2cc Util'pcequiv Util'equals Util'identical Util'classOf Util'compare Util'hash Util'hasheq Util'dohasheq Util'hashCombine Util'isPrimitive Util'isInteger Util'ret1 Util'clearCache Util'runtimeException-1 Util'runtimeException-2 Util'sneakyThrow Util'sneakyThrow0 Util'loadWithClass)
(declare TBox'new)
(declare Unbound'new)
(declare Frame'TOP Frame'new)
(declare Var'dvals Var'rev Var'privateKey Var'privateMeta Var'macroKey Var'nameKey Var'nsKey Var'getThreadBindingFrame Var'cloneThreadBindingFrame Var'resetThreadBindingFrame Var'intern-3 Var'intern-4 Var'find Var'intern-2s Var'internPrivate Var'intern-2n Var'create-0 Var'create-1 Var'new-2 Var'new-3 Var'pushThreadBindings Var'popThreadBindings Var'getThreadBindings Var'assoc Var'dissoc)
(declare Volatile'new)
(declare main'CLOIURE_MAIN main'REQUIRE main'MAIN)

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_protected
    (defn #_"AFn" AFn'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"AFn" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"AFn" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
        (.throwArity this, 0)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1]
        (.throwArity this, 1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (.throwArity this, 2)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (.throwArity this, 3)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (.throwArity this, 4)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (.throwArity this, 5)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (.throwArity this, 6)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (.throwArity this, 7)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (.throwArity this, 8)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (.throwArity this, 9)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (.throwArity this, 10)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (.throwArity this, 11)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (.throwArity this, 12)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (.throwArity this, 13)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (.throwArity this, 14)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (.throwArity this, 15)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (.throwArity this, 16)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (.throwArity this, 17)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (.throwArity this, 18)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (.throwArity this, 19)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (.throwArity this, 20)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (.throwArity this, 21)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"AFn" this, #_"ISeq" ___arglist]
        (ß AFn'applyToHelper(this, Util'ret1(___arglist, (§ ass ___arglist nil))))
    )

    (defn #_"Object" AFn'applyToHelper [#_"IFn" ___ifn, #_"ISeq" ___arglist]
        (§ switch (RT'boundedLength ___arglist, 20)
            (§ case 0)
            (do
                (§ ass ___arglist nil)
                (.invoke ___ifn)
            )
            (§ case 1)
            (do
                (ß ___ifn.invoke(Util'ret1((first ___arglist), (§ ass ___arglist nil))))
            )
            (§ case 2)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 3)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 4)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 5)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 6)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 7)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 8)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 9)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 10)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 11)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 12)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 13)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 14)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 15)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 16)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 17)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 18)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 19)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ case 20)
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        Util'ret1((§ ass ___arglist (next ___arglist)).first(), (§ ass ___arglist nil))))
            )
            (§ default )
            (do
                (ß ___ifn.invoke((first ___arglist),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        (§ ass ___arglist (next ___arglist)).first(),
                        RT'seqToArray(Util'ret1((next ___arglist), (§ ass ___arglist nil)))))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"AFn" this, #_"int" ___n]
        (let [#_"String" ___name (ß getClass().getSimpleName())]
            (throw (ß ArityException'new-2(___n, Compiler'demunge(___name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (defn- #_"AFunction" AFunction'init []
        (hash-map
            #_volatile
            #_"MethodImplCache" :__methodImplCache nil
        )
    )

    #_protected
    (defn #_"AFunction" AFunction'new []
        (merge (AFn'new) (AFunction'init))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"AFunction" this]
        nil
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"AFunction" this, #_"IPersistentMap" ___meta]
        (§ reify RestFn()
            #_protected
            #_method
            (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___args]
                (ß (§ this AFunction).applyTo((cast' ISeq ___args)))
            )

            #_method
            (§ defn #_"IPersistentMap" (§ method meta) [#_"RestFn" this]
                ___meta
            )

            #_method
            (§ defn #_"IObj" (§ method withMeta) [#_"RestFn" this, #_"IPersistentMap" ___meta]
                (ß (§ this AFunction).withMeta(___meta))
            )

            #_method
            (§ defn #_"int" (§ method getRequiredArity) [#_"RestFn" this]
                0
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method compare) [#_"AFunction" this, #_"Object" ___o1, #_"Object" ___o2]
        (let [#_"Object" ___o (.invoke this, ___o1, ___o2)]
            (when (ß ___o instanceof Boolean)
                (when (RT'booleanCast-1o ___o)
                    (§ return -1)
                )
                (§ return (if (RT'booleanCast-1o (.invoke this, ___o2, ___o1)) 1 0))
            )

            (let [#_"Number" ___n (ß (Number) ___o)]
                (.intValue ___n)
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns ActionQueue
    (§ def #_"ActionQueue" ActionQueue'EMPTY (ActionQueue'new PersistentQueue'EMPTY, nil))

    (defn- #_"ActionQueue" ActionQueue'init []
        (hash-map
            #_"IPersistentStack" :q nil
            #_"Throwable" :error nil ;; non-null indicates fail state
        )
    )

    (defn #_"ActionQueue" ActionQueue'new [#_"IPersistentStack" ___q, #_"Throwable" ___error]
        (let [this (ActionQueue'init)]
            (§ ass (:q this) ___q)
            (§ ass (:error this) ___error)
            this
        )
    )
)

(class-ns AgentAction (§ implements Runnable)
    (defn- #_"AgentAction" AgentAction'init []
        (hash-map
            #_"Agent" :agent nil
            #_"IFn" :fn nil
            #_"ISeq" :args nil
            #_"Executor" :exec nil
        )
    )

    (defn #_"AgentAction" AgentAction'new [#_"Agent" ___agent, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [this (AgentAction'init)]
            (§ ass (:agent this) ___agent)
            (§ ass (:args this) ___args)
            (§ ass (:fn this) ___fn)
            (§ ass (:exec this) ___exec)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method execute) [#_"AgentAction" this]
        (try
            (ß (:exec this).execute(this))
            (catch Throwable ___error
                (when (ß (:errorHandler (:agent this)) != nil)
                    (try
                        (ß (:errorHandler (:agent this)).invoke((:agent this), ___error))
                        (catch Throwable ___e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AgentAction'doRun [#_"AgentAction" ___action]
        (try
            (ß Agent'nested.set(PersistentVector'EMPTY))

            (let [#_"Throwable" ___error nil]
                (try
                    (let [#_"Object" ___oldval (:state (:agent ___action))]
                        (let [#_"Object" ___newval (ß (:fn ___action).applyTo(RT'cons((:state (:agent ___action)), (:args ___action))))]
                            (ß (:agent ___action).setState(___newval))
                            (ß (:agent ___action).notifyWatches(___oldval, ___newval))
                        )
                    )
                    (catch Throwable ___e
                        (§ ass ___error ___e)
                    )
                )

                (if (nil? ___error)
                    (do
                        (ß releasePendingSends())
                    )
                    (do
                        (ß Agent'nested.set(nil)) ;; allow errorHandler to send
                        (when (ß (:errorHandler (:agent ___action)) != nil)
                            (try
                                (ß (:errorHandler (:agent ___action)).invoke((:agent ___action), ___error))
                                (catch Throwable ___e
                                    ;; ignore errorHandler errors
                                )
                            )
                        )
                        (when (ß (:errorMode (:agent ___action)) == Agent'CONTINUE)
                            (§ ass ___error nil)
                        )
                    )
                )

                (let [#_"boolean" ___popped false]
                    (let [#_"ActionQueue" ___next nil]
                        (while (not ___popped)
                            (let [#_"ActionQueue" ___prior (ß (:aq (:agent ___action)).get())]
                                (§ ass ___next (ß ActionQueue'new((:q ___prior).pop(), ___error)))
                                (§ ass ___popped (ß (:aq (:agent ___action)).compareAndSet(___prior, ___next)))
                            )
                        )

                        (when (ß ___error == nil && (:q ___next).count() > 0)
                            (ß ((AgentAction) (:q ___next).peek()).execute())
                        )
                    )
                )
            )
            (finally
                (ß Agent'nested.set(nil))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"AgentAction" this]
        (AgentAction'doRun this)
        nil
    )
)

(class-ns Agent (§ extends ARef)
    (§ def #_"Keyword" Agent'CONTINUE (Keyword'intern-2 nil, "continue"))
    (§ def #_"Keyword" Agent'FAIL (Keyword'intern-2 nil, "fail"))

    (def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" ___format, #_"AtomicLong" ___threadPoolCounter]
        (§ reify ThreadFactory()
            #_method
            (§ defn #_"Thread" (§ method newThread) [#_"ThreadFactory" this, #_"Runnable" ___runnable]
                (let [#_"Thread" ___thread (Thread. ___runnable)]
                    (ß ___thread.setName(String/format(___format, (object-array [ (.getAndIncrement ___threadPoolCounter) ]))))
                    ___thread
                )
            )
        )
    )

    #_volatile
    (def #_"ExecutorService" Agent'pooledExecutor (ß Executors/newFixedThreadPool(2 + Runtime/getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))))

    #_volatile
    (def #_"ExecutorService" Agent'soloExecutor (ß Executors/newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))))

    (def #_"ThreadLocal<IPersistentVector>" Agent'nested (ThreadLocal.))

    (defn #_"void" Agent'shutdown []
        (.shutdown Agent'soloExecutor)
        (.shutdown Agent'pooledExecutor)
        nil
    )

    (defn- #_"Agent" Agent'init []
        (hash-map
            #_volatile
            #_"Object" :state nil
            #_"AtomicReference<ActionQueue>" :aq (AtomicReference. ActionQueue'EMPTY)

            #_volatile
            #_"Keyword" :errorMode Agent'CONTINUE
            #_volatile
            #_"IFn" :errorHandler nil
        )
    )

    (defn #_"Agent" Agent'new-1 [#_"Object" ___state]
        (Agent'new-2 ___state, nil)
    )

    (defn #_"Agent" Agent'new-2 [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Agent'init))]
            (.setState this, ___state)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method setState) [#_"Agent" this, #_"Object" ___newState]
        (.validate this, ___newState)
        (let [#_"boolean" ___ret (ß ((:state this) != ___newState))]
            (§ ass (:state this) ___newState)
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Agent" this]
        (:state this)
    )

    #_method
    (§ defn #_"Throwable" (§ method getError) [#_"Agent" this]
        (:error (.get (:aq this)))
    )

    #_method
    (§ defn #_"void" (§ method setErrorMode) [#_"Agent" this, #_"Keyword" ___k]
        (§ ass (:errorMode this) ___k)
        nil
    )

    #_method
    (§ defn #_"Keyword" (§ method getErrorMode) [#_"Agent" this]
        (:errorMode this)
    )

    #_method
    (§ defn #_"void" (§ method setErrorHandler) [#_"Agent" this, #_"IFn" ___f]
        (§ ass (:errorHandler this) ___f)
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method getErrorHandler) [#_"Agent" this]
        (:errorHandler this)
    )

    #_method
    (§ defn #_"Object" (§ method restart) [#_"Agent" this, #_"Object" ___newState, #_"boolean" ___clearActions]
        (§ sync this
            (when (ß (.getError this) == nil)
                (throw (Util'runtimeException-1 "Agent does not need a restart"))
            )
            (.validate this, ___newState)
            (§ ass (:state this) ___newState)

            (if ___clearActions
                (do
                    (ß (:aq this).set(ActionQueue'EMPTY))
                )
                (do
                    (let [#_"boolean" ___restarted false]
                        (let [#_"ActionQueue" ___prior nil]
                            (while (not ___restarted)
                                (§ ass ___prior (.get (:aq this)))
                                (§ ass ___restarted (ß (:aq this).compareAndSet(___prior, ActionQueue'new((:q ___prior), nil))))
                            )

                            (when (ß (:q ___prior).count() > 0)
                                (ß ((AgentAction) (:q ___prior).peek()).execute())
                            )
                        )
                    )
                )
            )

            ___newState
        )
    )

    #_method
    (§ defn #_"Object" (§ method dispatch) [#_"Agent" this, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [#_"Throwable" ___error (.getError this)]
            (when (some? ___error)
                (throw (Util'runtimeException-2 "Agent is failed, needs restart", ___error))
            )
            (let [#_"AgentAction" ___action (AgentAction'new this, ___fn, ___args, ___exec)]
                (ß dispatchAction(___action))

                this
            )
        )
    )

    (defn #_"void" Agent'dispatchAction [#_"AgentAction" ___action]
        (let [#_"LockingTransaction" ___trans (LockingTransaction'getRunning)]
            (cond (some? ___trans)
                (do
                    (.enqueue ___trans, ___action)
                )
                (ß (.get Agent'nested) != nil)
                (do
                    (ß Agent'nested.set((.get Agent'nested).cons(___action)))
                )
                :else
                (do
                    (ß (:agent ___action).enqueue(___action))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method enqueue) [#_"Agent" this, #_"AgentAction" ___action]
        (let [#_"boolean" ___queued false]
            (let [#_"ActionQueue" ___prior nil]
                (while (not ___queued)
                    (§ ass ___prior (.get (:aq this)))
                    (§ ass ___queued (ß (:aq this).compareAndSet(___prior, ActionQueue'new((IPersistentStack)(:q ___prior).cons(___action), (:error ___prior)))))
                )

                (when (ß (:q ___prior).count() == 0 && (:error ___prior) == nil)
                    (.execute ___action)
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method getQueueCount) [#_"Agent" this]
        (ß (:q (.get (:aq this))).count())
    )

    (defn #_"int" Agent'releasePendingSends []
        (let [#_"IPersistentVector" ___sends (.get Agent'nested)]
            (when (nil? ___sends)
                (§ return 0)
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___sends)) [(inc ___i)]
                (let [#_"AgentAction" ___a (ß (AgentAction) ___sends.valAt(___i))]
                    (ß (:agent ___a).enqueue(___a))
                )
            )
            (ß Agent'nested.set(PersistentVector'EMPTY))
            (count ___sends)
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_protected
    (defn #_"AMapEntry" AMapEntry'new []
        (APersistentVector'new)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"AMapEntry" this, #_"int" ___i]
        (cond (ß ___i == 0)
            (do
                (.key this)
            )
            (ß ___i == 1)
            (do
                (.val this)
            )
            :else
            (do
                (throw (IndexOutOfBoundsException.))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" (§ method asVector) [#_"AMapEntry" this]
        (ß LazilyPersistentVector'createOwning((.key this), (.val this)))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assocN) [#_"AMapEntry" this, #_"int" ___i, #_"Object" ___val]
        (ß (.asVector this).assocN(___i, ___val))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"AMapEntry" this]
        2
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"AMapEntry" this]
        (.seq (.asVector this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method cons) [#_"AMapEntry" this, #_"Object" ___o]
        (ß (.asVector this).cons(___o))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"AMapEntry" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" (§ method pop) [#_"AMapEntry" this]
        (ß LazilyPersistentVector'createOwning((.key this)))
    )

    #_method
    (§ defn #_"Object" (§ method setValue) [#_"AMapEntry" this, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

(class-ns KeySeq (§ extends ASeq)
    (defn #_"KeySeq" KeySeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (KeySeq'new-2 ___seq, nil)
    )

    (defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (.seq ___map)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (KeySeq'new-2 ___seq, ___map)
        )
    )

    (defn- #_"KeySeq" KeySeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"KeySeq" KeySeq'new-2 [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new) (KeySeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    (defn- #_"KeySeq" KeySeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new ___meta) (KeySeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"KeySeq" this]
        (ß ((Map$Entry) (:seq this).first()).getKey())
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"KeySeq" this]
        (ß this.create((:seq this).next()))
    )

    #_method
    (§ defn #_"KeySeq" (§ method withMeta) [#_"KeySeq" this, #_"IPersistentMap" ___meta]
        (KeySeq'new-3 ___meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"KeySeq" this]
        (when (nil? (:iterable this))
            (§ return (.iterator super))
        )

        (when (ß (:iterable this) instanceof IMapIterable)
            (§ return (ß ((IMapIterable)(:iterable this)).keyIterator()))
        )

        (let [#_"Iterator" ___mapIter (.iterator (:iterable this))]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (.hasNext ___mapIter)
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (ß ((Map$Entry)___mapIter.next()).getKey())
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

(class-ns ValSeq (§ extends ASeq)
    (defn #_"ValSeq" ValSeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (ValSeq'new-2 ___seq, nil)
    )

    (defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (.seq ___map)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ValSeq'new-2 ___seq, ___map)
        )
    )

    (defn- #_"ValSeq" ValSeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"ValSeq" ValSeq'new-2 [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new) (ValSeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    (defn- #_"ValSeq" ValSeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new ___meta) (ValSeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ValSeq" this]
        (ß ((Map$Entry) (:seq this).first()).getValue())
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ValSeq" this]
        (ß this.create((:seq this).next()))
    )

    #_method
    (§ defn #_"ValSeq" (§ method withMeta) [#_"ValSeq" this, #_"IPersistentMap" ___meta]
        (ValSeq'new-3 ___meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ValSeq" this]
        (when (nil? (:iterable this))
            (§ return (.iterator super))
        )

        (when (ß (:iterable this) instanceof IMapIterable)
            (§ return (ß ((IMapIterable)(:iterable this)).valIterator()))
        )

        (let [#_"Iterator" ___mapIter (.iterator (:iterable this))]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (.hasNext ___mapIter)
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (ß ((Map$Entry)___mapIter.next()).getValue())
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (defn- #_"APersistentMap" APersistentMap'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentMap" APersistentMap'new []
        (merge (AFn'new) (APersistentMap'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentMap" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method cons) [#_"APersistentMap" this, #_"Object" ___o]
        (cond (ß ___o instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (§ return (ß this.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (ß ___o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
                    (when (ß (count ___v) != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß this.assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ___ret this]
            (loop-when-recur [#_"ISeq" ___es (RT'seq ___o)] (some? ___es) [(next ___es)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) (first ___es))]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentMap" this, #_"Object" ___obj]
        (ß mapEquals(this, ___obj))
    )

    (defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" ___m1, #_"Object" ___obj]
        (when (ß ___m1 == ___obj)
            (§ return true)
        )
        (when (not (ß ___obj instanceof Map))
            (§ return false)
        )
        (let [#_"Map" ___m (ß (Map) ___obj)]
            (when (ß (.size ___m) != (count ___m1))
                (§ return false)
            )

            (loop-when-recur [#_"ISeq" ___s (.seq ___m1)] (some? ___s) [(next ___s)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) (first ___s))]
                    (let [#_"boolean" ___found (ß ___m.containsKey((.getKey ___e)))]
                        (when (ß (not ___found) || (not (Util'equals (.getValue ___e), (ß ___m.get((.getKey ___e))))))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentMap" this, #_"Object" ___obj]
        (when (not (ß ___obj instanceof Map))
            (§ return false)
        )
        (when (ß ___obj instanceof IPersistentMap && (not (ß ___obj instanceof MapEquivalence)))
            (§ return false)
        )

        (let [#_"Map" ___m (ß (Map) ___obj)]
            (when (ß (.size ___m) != (.size this))
                (§ return false)
            )

            (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) (first ___s))]
                    (let [#_"boolean" ___found (ß ___m.containsKey((.getKey ___e)))]
                        (when (ß (not ___found) || (not (Util'equiv-2oo (.getValue ___e), (ß ___m.get((.getKey ___e))))))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentMap" this]
        (let [#_"int" ___cached (:_hash this)]
            (when (ß ___cached == 0)
                (§ ass (:_hash this) (§ ass ___cached (ß mapHash(this))))
            )
            ___cached
        )
    )

    (defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" ___m]
        (let [#_"int" ___hash 0]
            (loop-when-recur [#_"ISeq" ___s (.seq ___m)] (some? ___s) [(next ___s)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) (first ___s))]
                    (§ ass ___hash (+ ___hash (ß (if (ß (.getKey ___e) == nil) 0 (ß (.getKey ___e).hashCode())) :xor (if (ß (.getValue ___e) == nil) 0 (ß (.getValue ___e).hashCode())))))
                )
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentMap" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (ß ___cached == 0)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashUnordered this)))
            )
            ___cached
        )
    )

    (defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" ___m]
        (Murmur3'hashUnordered ___m)
    )

    (def #_"IFn" APersistentMap'MAKE_ENTRY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                (MapEntry'create ___key, ___val)
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_KEY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                ___key
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_VAL
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                ___val
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentMap" this, #_"Object" ___arg1]
        (.valAt this, ___arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (.valAt this, ___arg1, ___notFound)
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsValue) [#_"APersistentMap" this, #_"Object" ___value]
        (ß (.values this).contains(___value))
    )

    #_method
    (§ defn #_"Set" (§ method entrySet) [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet" this]
                (ß (§ this APersistentMap).iterator())
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractSet" this]
                (count this)
            )

            #_method
            (§ defn #_"int" (§ method hashCode) [#_"AbstractSet" this]
                (ß (§ this APersistentMap).hashCode())
            )

            #_method
            (§ defn #_"boolean" (§ method contains) [#_"AbstractSet" this, #_"Object" ___o]
                (when (ß ___o instanceof Entry)
                    (let [#_"Entry" ___e (ß (Entry) ___o)]
                        (let [#_"Entry" ___found (ß this.entryAt((.getKey ___e)))]
                            (when (ß ___found != nil && Util'equals((.getValue ___found), (.getValue ___e)))
                                (§ return true)
                            )
                        )
                    )
                )
                false
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentMap" this, #_"Object" ___key]
        (.valAt this, ___key)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentMap" this]
        (ß ((count this) == 0))
    )

    #_method
    (§ defn #_"Set" (§ method keySet) [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet" this]
                (let [#_"Iterator" ___mi (ß (§ this APersistentMap).iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext ___mi)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [#_"Entry" ___e (ß (Entry) (next ___mi))]
                                (.getKey ___e)
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractSet" this]
                (count this)
            )

            #_method
            (§ defn #_"boolean" (§ method contains) [#_"AbstractSet" this, #_"Object" ___o]
                (ß (§ this APersistentMap).containsKey(___o))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method put) [#_"APersistentMap" this, #_"Object" ___key, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method putAll) [#_"APersistentMap" this, #_"Map" ___t]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"APersistentMap" this, #_"Object" ___key]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentMap" this]
        (count this)
    )

    #_method
    (§ defn #_"Collection" (§ method values) [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_method
            (§ defn #_"Iterator" (§ method iterator) [#_"AbstractCollection" this]
                (let [#_"Iterator" ___mi (ß (§ this APersistentMap).iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (.hasNext ___mi)
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (let [#_"Entry" ___e (ß (Entry) (next ___mi))]
                                (.getValue ___e)
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" (§ method size) [#_"AbstractCollection" this]
                (count this)
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (defn- #_"APersistentSet" APersistentSet'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
            #_"IPersistentMap" :impl nil
        )
    )

    #_protected
    (defn #_"APersistentSet" APersistentSet'new [#_"IPersistentMap" ___impl]
        (let [this (merge (AFn'new) (APersistentSet'init))]
            (§ ass (:impl this) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentSet" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"APersistentSet" this, #_"Object" ___key]
        (ß (:impl this).containsKey(___key))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentSet" this, #_"Object" ___key]
        (ß (:impl this).valAt(___key))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"APersistentSet" this]
        (count (:impl this))
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"APersistentSet" this]
        (RT'keys (:impl this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentSet" this, #_"Object" ___arg1]
        (.get this, ___arg1)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentSet" this, #_"Object" ___obj]
        (APersistentSet'setEquals this, ___obj)
    )

    (defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" ___s1, #_"Object" ___obj]
        (when (ß ___s1 == ___obj)
            (§ return true)
        )
        (when (not (ß ___obj instanceof Set))
            (§ return false)
        )
        (let [#_"Set" ___m (ß (Set) ___obj)]
            (when (ß (.size ___m) != (count ___s1))
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (not (ß ___s1.contains(___aM)))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentSet" this, #_"Object" ___obj]
        (when (not (ß ___obj instanceof Set))
            (§ return false)
        )

        (let [#_"Set" ___m (ß (Set) ___obj)]
            (when (ß (.size ___m) != (.size this))
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (not (ß this.contains(___aM)))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentSet" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (ß ___hash == 0)
                (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                    (let [#_"Object" ___e (first ___s)]
                        (§ ass ___hash (ß ___hash + Util'hash(___e)))
                    )
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentSet" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (ß ___cached == 0)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashUnordered this)))
            )
            ___cached
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentSet" this]
        (ß RT'seqToArray((.seq this)))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"APersistentSet" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (ß this.contains(___o)))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentSet" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentSet" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentSet" this]
        (ß ((count this) == 0))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"APersistentSet" this]
        (if (ß (:impl this) instanceof IMapIterable)
            (do
                (ß ((IMapIterable)(:impl this)).keyIterator())
            )
            (do
                (§ reify Iterator()
                    (§ init
                        (hash-map
                            #_"Iterator" :iter (.iterator (:impl this))
                        )
                    )

                    #_method
                    (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                        (.hasNext (:iter this))
                    )

                    #_method
                    (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                        (ß ((IMapEntry)(:iter this).next()).key())
                    )

                    #_method
                    (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

(class-ns VSeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"VSeq" VSeq'init []
        (hash-map
            ;; todo - something more efficient
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"VSeq" VSeq'new-2 [#_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new) (VSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"VSeq" VSeq'new-3 [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (VSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"VSeq" this]
        (ß (:v this).nth((:i this)))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"VSeq" this]
        (when (ß (:i this) + 1 < (:v this).count())
            (§ return (ß VSeq'new-2((:v this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"VSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"VSeq" this]
        (ß (:v this).count() - (:i this))
    )

    #_method
    (§ defn #_"VSeq" (§ method withMeta) [#_"VSeq" this, #_"IPersistentMap" ___meta]
        (VSeq'new-3 ___meta, (:v this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"VSeq" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:v this).nth((:i this)))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:v this).count()) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:v this).nth(___x))))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"VSeq" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:v this).nth((:i this))))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:v this).count()) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:v this).nth(___x))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )
)

(class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
    (defn- #_"RSeq" RSeq'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"RSeq" RSeq'new-2 [#_"IPersistentVector" ___vector, #_"int" ___i]
        (let [this (merge (ASeq'new) (RSeq'init))]
            (§ ass (:v this) ___vector)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"RSeq" RSeq'new-3 [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (RSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"RSeq" this]
        (ß (:v this).nth((:i this)))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"RSeq" this]
        (when (> (:i this) 0)
            (§ return (ß RSeq'new-2((:v this), (:i this) - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"RSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"RSeq" this]
        (+ (:i this) 1)
    )

    #_method
    (§ defn #_"RSeq" (§ method withMeta) [#_"RSeq" this, #_"IPersistentMap" ___meta]
        (RSeq'new-3 ___meta, (:v this), (:i this))
    )
)

(class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
    (defn- #_"SubVector" SubVector'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :start 0
            #_"int" :end 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"SubVector" SubVector'new [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (let [this (merge (APersistentVector'new) (SubVector'init))]
            (§ ass (:_meta this) ___meta)

            (when (ß ___v instanceof SubVector)
                (let [#_"SubVector" ___sv (ß (SubVector) ___v)]
                    (§ ass ___start (ß ___start + (:start ___sv)))
                    (§ ass ___end (ß ___end + (:start ___sv)))
                    (§ ass ___v (:v ___sv))
                )
            )
            (§ ass (:v this) ___v)
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"SubVector" this]
        (when (ß (:v this) instanceof APersistentVector)
            (§ return (ß ((APersistentVector)(:v this)).rangedIterator((:start this), (:end this))))
        )
        (.iterator super)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"SubVector" this, #_"int" ___i]
        (when (ß ((:start this) + ___i >= (:end this)) || (___i < 0))
            (throw (IndexOutOfBoundsException.))
        )
        (ß (:v this).nth((:start this) + ___i))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assocN) [#_"SubVector" this, #_"int" ___i, #_"Object" ___val]
        (cond (ß (:start this) + ___i > (:end this))
            (do
                (throw (IndexOutOfBoundsException.))
            )
            (ß (:start this) + ___i == (:end this))
            (do
                (§ return (.cons this, ___val))
            )
        )
        (ß SubVector'new((:_meta this), (:v this).assocN((:start this) + ___i, ___val), (:start this), (:end this)))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"SubVector" this]
        (- (:end this) (:start this))
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method cons) [#_"SubVector" this, #_"Object" ___o]
        (ß SubVector'new((:_meta this), (:v this).assocN((:end this), ___o), (:start this), (:end this) + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"SubVector" this]
        (ß PersistentVector'EMPTY.withMeta((.meta this)))
    )

    #_method
    (§ defn #_"IPersistentStack" (§ method pop) [#_"SubVector" this]
        (when (ß (:end this) - 1 == (:start this))
            (§ return PersistentVector'EMPTY)
        )
        (ß SubVector'new((:_meta this), (:v this), (:start this), (:end this) - 1))
    )

    #_method
    (§ defn #_"SubVector" (§ method withMeta) [#_"SubVector" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (SubVector'new ___meta, (:v this), (:start this), (:end this))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"SubVector" this]
        (:_meta this)
    )
)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (defn- #_"APersistentVector" APersistentVector'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentVector" APersistentVector'new []
        (merge (AFn'new) (APersistentVector'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"APersistentVector" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"APersistentVector" this]
        (when (ß (count this) > 0)
            (§ return (VSeq'new-2 this, 0))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"APersistentVector" this]
        (when (ß (count this) > 0)
            (§ return (ß RSeq'new-2(this, (count this) - 1)))
        )
        nil
    )

    (defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (ß ___obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___ov (ß (IPersistentVector) ___obj)]
                    (when (ß (count ___ov) != (count ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___v)) [(inc ___i)]
                        (when (not (ß Util'equals(___v.nth(___i), ___ov.nth(___i))))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß ___obj instanceof List)
            (do
                (let [#_"Collection" ___ma (ß (Collection) ___obj)]
                    (when (ß (.size ___ma) != (count ___v) || (.hashCode ___ma) != (.hashCode ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"Iterator" ___i1 (ß (cast List ___v).iterator()) #_"Iterator" ___i2 (.iterator ___ma)] (.hasNext ___i1) [___i1 ___i2]
                        (when (not (Util'equals (next ___i1), (next ___i2)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (not (ß ___obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (RT'seq ___obj)]
                    (loop-when-recur [#_"int" ___i 0 ___ms ___ms] (ß ___i < (count ___v)) [(inc ___i) (next ___ms)]
                        (when (ß ___ms == nil || (not (ß Util'equals(___v.nth(___i), (first ___ms)))))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (ß ___obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___ov (ß (IPersistentVector) ___obj)]
                    (when (ß (count ___ov) != (count ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___v)) [(inc ___i)]
                        (when (not (ß Util'equiv-2oo(___v.nth(___i), ___ov.nth(___i))))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß ___obj instanceof List)
            (do
                (let [#_"Collection" ___ma (ß (Collection) ___obj)]
                    (when (ß (.size ___ma) != (count ___v))
                        (§ return false)
                    )
                    (loop-when-recur [#_"Iterator" ___i1 (ß (cast List ___v).iterator()) #_"Iterator" ___i2 (.iterator ___ma)] (.hasNext ___i1) [___i1 ___i2]
                        (when (not (Util'equiv-2oo (next ___i1), (next ___i2)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (not (ß ___obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (RT'seq ___obj)]
                    (loop-when-recur [#_"int" ___i 0 ___ms ___ms] (ß ___i < (count ___v)) [(inc ___i) (next ___ms)]
                        (when (ß ___ms == nil || (not (ß Util'equiv-2oo(___v.nth(___i), (first ___ms)))))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"APersistentVector" this, #_"Object" ___obj]
        (when (ß ___obj == this)
            (§ return true)
        )
        (ß doEquals(this, ___obj))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"APersistentVector" this, #_"Object" ___obj]
        (when (ß ___obj == this)
            (§ return true)
        )
        (APersistentVector'doEquiv this, ___obj)
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"APersistentVector" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (ß ___hash == 0)
                (§ ass ___hash 1)
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
                    (let [#_"Object" ___obj (.nth this, ___i)]
                        (§ ass ___hash (+ (* 31 ___hash) (if (nil? ___obj) 0 (.hashCode ___obj))))
                    )
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"APersistentVector" this]
        (let [#_"int" ___hash (:_hasheq this)]
            (when (ß ___hash == 0)
                (§ let [#_"int" ___n]
                    (§ ass ___hash 1)

                    (loop-when-recur [___n 0] (ß ___n < (count this)) [(inc ___n)]
                        (§ ass ___hash (ß 31 * ___hash + Util'hasheq(this.nth(___n))))
                    )

                    (§ ass (:_hasheq this) (§ ass ___hash (Murmur3'mixCollHash ___hash, ___n)))
                )
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"APersistentVector" this, #_"int" ___index]
        (.nth this, ___index)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (count this))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"APersistentVector" this, #_"int" ___i]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
            (when (ß Util'equiv-2oo(this.nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"int" ___i (ß (count this) - 1)] (ß ___i >= 0) [(dec ___i)]
            (when (ß Util'equiv-2oo(this.nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"APersistentVector" this]
        (.listIterator this, 0)
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"APersistentVector" this, #_"int" ___index]
        (§ reify ListIterator()
            (let [#_"int" ___nexti ___index]
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"ListIterator" this]
                    (ß (___nexti < (count this)))
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"ListIterator" this]
                    (if (ß ___nexti < (count this))
                        (let [_ (.nth this, ___nexti)]
                            (§ ass ___nexti (inc ___nexti))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"boolean" (§ method hasPrevious) [#_"ListIterator" this]
                    (ß ___nexti > 0)
                )

                #_method
                (§ defn #_"Object" (§ method previous) [#_"ListIterator" this]
                    (if (> ___nexti 0)
                        (do
                            (§ ass ___nexti (dec ___nexti))
                            (.nth this, ___nexti)
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"int" (§ method nextIndex) [#_"ListIterator" this]
                    ___nexti
                )

                #_method
                (§ defn #_"int" (§ method previousIndex) [#_"ListIterator" this]
                    (dec ___nexti)
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"ListIterator" this]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" (§ method set) [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" (§ method add) [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method rangedIterator) [#_"APersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (let [#_"int" ___i ___start]
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (ß ___i < ___end)
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (if (< ___i ___end)
                        (let [_ (.nth this, ___i)]
                            (§ ass ___i (inc ___i))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"APersistentVector" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (List) RT'subvec(this, ___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentVector" this, #_"int" ___i, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"APersistentVector" this, #_"Object" ___arg1]
        (when (Util'isInteger ___arg1)
            (§ return (ß this.nth((cast Number ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (let [#_"int" ___i 0]
                #_method
                (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                    (ß (___i < (count this)))
                )

                #_method
                (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                    (if (ß ___i < (count this))
                        (let [_ (.nth this, ___i)]
                            (§ ass ___i (inc ___i))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"APersistentVector" this]
        (when (ß (count this) > 0)
            (§ return (ß this.nth((count this) - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"APersistentVector" this, #_"Object" ___key]
        (when (not (Util'isInteger ___key))
            (§ return false)
        )
        (let [#_"int" ___i (ß (cast Number ___key).intValue())]
            (ß (___i >= 0 && ___i < (count this)))
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"APersistentVector" this, #_"Object" ___key]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß (cast Number ___key).intValue())]
                (when (ß ___i >= 0 && ___i < (count this))
                    (§ return (ß (IMapEntry) MapEntry'create(___key, this.nth(___i))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method assoc) [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___val]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß (cast Number ___key).intValue())]
                (§ return (.assocN this, ___i, ___val))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß (cast Number ___key).intValue())]
                (when (ß ___i >= 0 && ___i < (count this))
                    (§ return (.nth this, ___i))
                )
            )
        )
        ___notFound
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"APersistentVector" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentVector" this]
        (let [#_"Object[]" ___ret (make-array Object (count this))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
                (§ ass (ß ___ret[___i]) (.nth this, ___i))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"APersistentVector" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (ß this.contains(___o)))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"APersistentVector" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"APersistentVector" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"APersistentVector" this]
        (ß ((count this) == 0))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"int" (§ method length) [#_"APersistentVector" this]
        (count this)
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"APersistentVector" this, #_"Object" ___o]
        (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
            (cond (ß (count this) < (count ___v))
                (do
                    (§ return -1)
                )
                (ß (count this) > (count ___v))
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count this)) [(inc ___i)]
                (let [#_"int" ___c (ß Util'compare(this.nth(___i), ___v.nth(___i)))]
                    (when (ß ___c != 0)
                        (§ return ___c)
                    )
                )
            )
            0
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (defn- #_"ARef" ARef'init []
        (hash-map
            #_protected
            #_volatile
            #_"IFn" :validator nil
            #_volatile
            #_"IPersistentMap" :watches PersistentHashMap'EMPTY
        )
    )

    (defn #_"ARef" ARef'new-0 []
        (merge (AReference'new) (ARef'init))
    )

    (defn #_"ARef" ARef'new-1 [#_"IPersistentMap" ___meta]
        (merge (AReference'new ___meta) (ARef'init))
    )

    #_method
    (§ defn #_"void" (§ method validate) [#_"ARef" this, #_"IFn" ___vf, #_"Object" ___val]
        (try
            (when (ß ___vf != nil && (not (ß RT'booleanCast-1o(___vf.invoke(___val)))))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException ___re
                (throw ___re)
            )
            (catch Exception ___e
                (throw (IllegalStateException. "Invalid reference state", ___e))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method validate) [#_"ARef" this, #_"Object" ___val]
        (.validate this, (:validator this), ___val)
        nil
    )

    #_method
    (§ defn #_"void" (§ method setValidator) [#_"ARef" this, #_"IFn" ___vf]
        (ß this.validate(___vf, (deref this)))
        (§ ass (:validator this) ___vf)
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method getValidator) [#_"ARef" this]
        (:validator this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getWatches) [#_"ARef" this]
        (:watches this)
    )

    #_method
    (§ defn #_"IRef" (§ method addWatch) [#_"ARef" this, #_"Object" ___key, #_"IFn" ___callback]
        (§ sync this
            (§ ass (:watches this) (ß (:watches this).assoc(___key, ___callback)))
            this
        )
    )

    #_method
    (§ defn #_"IRef" (§ method removeWatch) [#_"ARef" this, #_"Object" ___key]
        (§ sync this
            (§ ass (:watches this) (ß (:watches this).without(___key)))
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method notifyWatches) [#_"ARef" this, #_"Object" ___oldval, #_"Object" ___newval]
        (let [#_"IPersistentMap" ___ws (:watches this)]
            (when (ß (count ___ws) > 0)
                (loop-when-recur [#_"ISeq" ___s (.seq ___ws)] (some? ___s) [(next ___s)]
                    (let [#_"Map$Entry" ___e (ß (Map$Entry) (first ___s))]
                        (let [#_"IFn" ___fn (ß (IFn) (.getValue ___e))]
                            (when (some? ___fn)
                                (ß ___fn.invoke((.getKey ___e), this, ___oldval, ___newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (defn- #_"AReference" AReference'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"AReference" AReference'new-0 []
        (AReference'new-1 nil)
    )

    (defn #_"AReference" AReference'new-1 [#_"IPersistentMap" ___meta]
        (let [this (AReference'init)]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"AReference" this]
        (§ sync this
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method alterMeta) [#_"AReference" this, #_"IFn" ___alter, #_"ISeq" ___args]
        (§ sync this
            (§ ass (:_meta this) (ß (IPersistentMap) ___alter.applyTo(Cons'new-2((:_meta this), ___args))))
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method resetMeta) [#_"AReference" this, #_"IPersistentMap" ___m]
        (§ sync this
            (§ ass (:_meta this) ___m)
            ___m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (defn- #_"ArityException" ArityException'init []
        (hash-map
            #_"int" :actual 0
            #_"String" :name nil
        )
    )

    (defn #_"ArityException" ArityException'new-2 [#_"int" ___actual, #_"String" ___name]
        (ArityException'new-3 ___actual, ___name, nil)
    )

    (defn #_"ArityException" ArityException'new-3 [#_"int" ___actual, #_"String" ___name, #_"Throwable" ___cause]
        (let [this (merge (§ foreign IllegalArgumentException'new (str "Wrong number of args (" ___actual ") passed to: " ___name), ___cause) (ArityException'init))]
            (§ ass (:actual this) ___actual)
            (§ ass (:name this) ___name)
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (defn- #_"ArrayChunk" ArrayChunk'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :off 0
            #_"int" :end 0
        )
    )

    (defn #_"ArrayChunk" ArrayChunk'new-1 [#_"Object[]" ___array]
        (ArrayChunk'new-3 ___array, 0, (ß ___array.length))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-2 [#_"Object[]" ___array, #_"int" ___off]
        (ArrayChunk'new-3 ___array, ___off, (ß ___array.length))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-3 [#_"Object[]" ___array, #_"int" ___off, #_"int" ___end]
        (let [this (ArrayChunk'init)]
            (§ ass (:array this) ___array)
            (§ ass (:off this) ___off)
            (§ ass (:end this) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"ArrayChunk" this, #_"int" ___i]
        (ß (:array this)[(:off this) + ___i])
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"ArrayChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (count this))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArrayChunk" this]
        (- (:end this) (:off this))
    )

    #_method
    (§ defn #_"IChunk" (§ method dropFirst) [#_"ArrayChunk" this]
        (when (ß (:off this) == (:end this))
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß ArrayChunk'new-3((:array this), (:off this) + 1, (:end this)))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArrayChunk" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:off this)]))]
            (when (RT'isReduced ___ret)
                (§ return ___ret)
            )
            (loop-when-recur [#_"int" ___x (+ (:off this) 1)] (< ___x (:end this)) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return ___ret)
                )
            )
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter_int (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_int" ArrayIter_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_int" ArrayIter_int'new [#_"int[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_int'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_int" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_int" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_int" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_float (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_float" ArrayIter_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_float" ArrayIter_float'new [#_"float[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_float'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_float" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Double" (§ method next) [#_"ArrayIter_float" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Double/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_float" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_double (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_double" ArrayIter_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_double" ArrayIter_double'new [#_"double[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_double'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_double" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Double" (§ method next) [#_"ArrayIter_double" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_double" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_long (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_long" ArrayIter_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_long" ArrayIter_long'new [#_"long[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_long'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_long" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_long" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_long" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_byte (§ implements Iterator<Byte>)
    (defn- #_"ArrayIter_byte" ArrayIter_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_byte" ArrayIter_byte'new [#_"byte[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_byte'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_byte" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Byte" (§ method next) [#_"ArrayIter_byte" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_byte" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_char (§ implements Iterator<Character>)
    (defn- #_"ArrayIter_char" ArrayIter_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_char" ArrayIter_char'new [#_"char[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_char'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_char" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Character" (§ method next) [#_"ArrayIter_char" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_char" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_short (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_short" ArrayIter_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_short" ArrayIter_short'new [#_"short[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_short'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_short" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Long" (§ method next) [#_"ArrayIter_short" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_short" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
    (defn- #_"ArrayIter_boolean" ArrayIter_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_boolean" ArrayIter_boolean'new [#_"boolean[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_boolean'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter_boolean" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Boolean" (§ method next) [#_"ArrayIter_boolean" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Boolean/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter_boolean" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter (§ implements Iterator)
    (def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (java.util.NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException. "remove() not supported"))
            )
        )
    )

    (defn #_"Iterator" ArrayIter'create-0 []
        ArrayIter'EMPTY_ITERATOR
    )

    (defn #_"Iterator" ArrayIter'create-1 [#_"Object..." ___array]
        (when (ß ___array == nil || ___array.length == 0)
            (§ return ArrayIter'EMPTY_ITERATOR)
        )
        (ArrayIter'new ___array, 0)
    )

    (defn #_"Iterator" ArrayIter'createFromObject [#_"Object" ___array]
        (when (ß ___array == nil || Array/getLength(___array) == 0)
            (§ return ArrayIter'EMPTY_ITERATOR)
        )
        (let [#_"Class" ___aclass (.getClass ___array)]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß ArrayIter_int'new((int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß ArrayIter_float'new((float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß ArrayIter_double'new((double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß ArrayIter_long'new((long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß ArrayIter_byte'new((byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß ArrayIter_char'new((char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß ArrayIter_short'new((short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß ArrayIter_boolean'new((boolean[]) ___array, 0)))
            )
            (ArrayIter'new ___array, 0)
        )
    )

    (defn- #_"ArrayIter" ArrayIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter" ArrayIter'new [#_"Object" ___array, #_"int" ___i]
        (let [this (ArrayIter'init)]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ArrayIter" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"ArrayIter" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ArrayIter" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_int" ArraySeq_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_int" ArraySeq_int'new [#_"IPersistentMap" ___meta, #_"int[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_int'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_int" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_int" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_int'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_int" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_int" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_int" (§ method withMeta) [#_"ArraySeq_int" this, #_"IPersistentMap" ___meta]
        (ArraySeq_int'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_int" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_int" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"int" ___k (ß (cast Number ___o).intValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___k == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"int" ___k (ß (cast Number ___o).intValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___k == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_float" ArraySeq_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_float" ArraySeq_float'new [#_"IPersistentMap" ___meta, #_"float[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_float'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_float" this]
        (ß Numbers'num-1f((:array this)[(:i this)]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_float" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_float'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_float" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_float" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_float" (§ method withMeta) [#_"ArraySeq_float" this, #_"IPersistentMap" ___meta]
        (ArraySeq_float'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_float" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num-1f((:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1f((:array this)[___x]))))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_float" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num-1f((:array this)[(:i this)])))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1f((:array this)[___x]))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"float" ___f (ß (cast Number ___o).floatValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___f == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"float" ___f (ß (cast Number ___o).floatValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___f == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        -1
    )
)

(class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_double" ArraySeq_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_double" ArraySeq_double'new [#_"IPersistentMap" ___meta, #_"double[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_double'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_double" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_double" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_double'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_double" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_double" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_double" (§ method withMeta) [#_"ArraySeq_double" this, #_"IPersistentMap" ___meta]
        (ArraySeq_double'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_double" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_double" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"double" ___d (ß (cast Number ___o).doubleValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___d == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"double" ___d (ß (cast Number ___o).doubleValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___d == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_long" ArraySeq_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_long" ArraySeq_long'new [#_"IPersistentMap" ___meta, #_"long[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_long'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_long" this]
        (ß Numbers'num-1l((:array this)[(:i this)]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_long" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_long'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_long" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_long" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_long" (§ method withMeta) [#_"ArraySeq_long" this, #_"IPersistentMap" ___meta]
        (ArraySeq_long'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_long" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num-1l((:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1l((:array this)[___x]))))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_long" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num-1l((:array this)[(:i this)])))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1l((:array this)[___x]))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"long" ___l (ß (cast Number ___o).longValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___l == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"long" ___l (ß (cast Number ___o).longValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___l == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_byte" ArraySeq_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_byte" ArraySeq_byte'new [#_"IPersistentMap" ___meta, #_"byte[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_byte'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_byte" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_byte" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_byte'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_byte" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_byte" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_byte" (§ method withMeta) [#_"ArraySeq_byte" this, #_"IPersistentMap" ___meta]
        (ArraySeq_byte'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_byte" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_byte" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (ß ___o instanceof Byte)
            (let [#_"byte" ___b (ß (cast Byte ___o).byteValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (ß ___o instanceof Byte)
            (let [#_"byte" ___b (ß (cast Byte ___o).byteValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_char" ArraySeq_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_char" ArraySeq_char'new [#_"IPersistentMap" ___meta, #_"char[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_char'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_char" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_char" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_char'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_char" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_char" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_char" (§ method withMeta) [#_"ArraySeq_char" this, #_"IPersistentMap" ___meta]
        (ArraySeq_char'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_char" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_char" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (ß ___o instanceof Character)
            (let [#_"char" ___c (ß (cast Character ___o).charValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___c == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (ß ___o instanceof Character)
            (let [#_"char" ___c (ß (cast Character ___o).charValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___c == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_short" ArraySeq_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_short" ArraySeq_short'new [#_"IPersistentMap" ___meta, #_"short[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_short'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_short" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_short" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_short'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_short" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_short" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_short" (§ method withMeta) [#_"ArraySeq_short" this, #_"IPersistentMap" ___meta]
        (ArraySeq_short'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_short" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_short" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (ß ___o instanceof Short)
            (let [#_"short" ___s (ß (cast Short ___o).shortValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___s == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (ß ___o instanceof Short)
            (let [#_"short" ___s (ß (cast Short ___o).shortValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___s == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_boolean" ArraySeq_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_boolean" ArraySeq_boolean'new [#_"IPersistentMap" ___meta, #_"boolean[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_boolean'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq_boolean" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq_boolean" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_boolean'new((.meta this), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq_boolean" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq_boolean" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_boolean" (§ method withMeta) [#_"ArraySeq_boolean" this, #_"IPersistentMap" ___meta]
        (ArraySeq_boolean'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_boolean" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq_boolean" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (ß ___o instanceof Boolean)
            (let [#_"boolean" ___b (ß (cast Boolean ___o).booleanValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (ß ___o instanceof Boolean)
            (let [#_"boolean" ___b (ß (cast Boolean ___o).booleanValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn #_"ArraySeq" ArraySeq'create-0 []
        nil
    )

    (defn #_"ArraySeq" ArraySeq'create-1 [#_"Object..." ___array]
        (when (ß ___array == nil || ___array.length == 0)
            (§ return nil)
        )
        (ArraySeq'new-2 ___array, 0)
    )

    (defn #_"ISeq" ArraySeq'createFromObject [#_"Object" ___array]
        (when (ß ___array == nil || Array/getLength(___array) == 0)
            (§ return nil)
        )
        (let [#_"Class" ___aclass (.getClass ___array)]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß ArraySeq_int'new(nil, (int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß ArraySeq_float'new(nil, (float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß ArraySeq_double'new(nil, (double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß ArraySeq_long'new(nil, (long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß ArraySeq_byte'new(nil, (byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß ArraySeq_char'new(nil, (char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß ArraySeq_short'new(nil, (short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß ArraySeq_boolean'new(nil, (boolean[]) ___array, 0)))
            )
            (ArraySeq'new-2 ___array, 0)
        )
    )

    (defn- #_"ArraySeq" ArraySeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-2 [#_"Object" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new) (ArraySeq'init))]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-3 [#_"IPersistentMap" ___meta, #_"Object" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq'init))]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ArraySeq" this]
        (when (some? (:array this))
            (§ return (ß (:array this)[(:i this)]))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ArraySeq" this]
        (when (ß (:array this) != nil && (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq'new-2((:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ArraySeq" this]
        (when (some? (:array this))
            (§ return (ß (:array this).length - (:i this)))
        )
        0
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"ArraySeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq" (§ method withMeta) [#_"ArraySeq" this, #_"IPersistentMap" ___meta]
        (ArraySeq'new-3 ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq" this, #_"IFn" ___f]
        (when (some? (:array this))
            (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
                (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                    (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                    (when (RT'isReduced ___ret)
                        (§ return (ß (cast' IDeref ___ret).deref()))
                    )
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"ArraySeq" this, #_"IFn" ___f, #_"Object" ___start]
        (when (some? (:array this))
            (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
                (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                    (when (RT'isReduced ___ret)
                        (§ return (ß (cast' IDeref ___ret).deref()))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                )
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? (:array this))
            (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                (when (ß Util'equals(___o, (:array this)[___j]))
                    (§ return (- ___j (:i this)))
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? (:array this))
            (if (nil? ___o)
                (do
                    (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                        (when (ß (:array this)[___j] == nil)
                            (§ return (- ___j (:i this)))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                        (when (ß ___o.equals((:array this)[___j]))
                            (§ return (- ___j (:i this)))
                        )
                    )
                )
            )
        )
        -1
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (defn- #_"ASeq" ASeq'init []
        (hash-map
            #_transient
            #_"int" :_hash 0
            #_transient
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"ASeq" ASeq'new-1 [#_"IPersistentMap" ___meta]
        (merge (Obj'new ___meta) (ASeq'init))
    )

    #_protected
    (defn #_"ASeq" ASeq'new-0 []
        (merge (Obj'new) (ASeq'init))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ASeq" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"ASeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"ASeq" this, #_"Object" ___obj]
        (when (not (ß ___obj instanceof Sequential || ___obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (ß ___ms == nil || (not (ß Util'equiv-2oo((first ___s), (first ___ms)))))
                    (§ return false)
                )
            )
            (ß ___ms == nil)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"ASeq" this, #_"Object" ___obj]
        (when (ß this == ___obj)
            (§ return true)
        )
        (when (not (ß ___obj instanceof Sequential || ___obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (ß ___ms == nil || (not (ß Util'equals((first ___s), (first ___ms)))))
                    (§ return false)
                )
            )
            (ß ___ms == nil)
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"ASeq" this]
        (when (ß (:_hash this) == 0)
            (let [#_"int" ___hash 1]
                (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                    (§ ass ___hash (+ (* 31 ___hash) (if (nil? (first ___s)) 0 (.hashCode (first ___s)))))
                )
                (§ ass (:_hash this) ___hash)
            )
        )
        (:_hash this)
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"ASeq" this]
        (when (ß (:_hasheq this) == 0)
            (§ ass (:_hasheq this) (Murmur3'hashOrdered this))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ASeq" this]
        (let [#_"int" ___i 1]
            (loop-when-recur [#_"ISeq" ___s (next this) ___i ___i] (some? ___s) [(next ___s) (inc ___i)]
                (when (ß ___s instanceof Counted)
                    (§ return (ß ___i + (count ___s)))
                )
            )
            ___i
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"ASeq" this]
        this
    )

    #_method
    (§ defn #_"ISeq" (§ method cons) [#_"ASeq" this, #_"Object" ___o]
        (Cons'new-2 ___o, this)
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"ASeq" this]
        (let [#_"ISeq" ___s (next this)]
            (when (nil? ___s)
                (§ return PersistentList'EMPTY)
            )
            ___s
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"ASeq" this]
        (ß RT'seqToArray((.seq this)))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"ASeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (ß this.contains(___o)))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"ASeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"ASeq" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"ASeq" this]
        (ß ((.seq this) == nil))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ASeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"ASeq" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"ASeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (.reify this).subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"ASeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this) #_"int" ___i 0] (some? ___s) [(next ___s) (inc ___i)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"ASeq" this, #_"Object" ___o]
        (ß (.reify this).lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"ASeq" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"ASeq" this, #_"int" ___index]
        (ß (.reify this).listIterator(___index))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"ASeq" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"ASeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Associative

(§ defprotocol Associative #_(§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" Associative'''(§ method containsKey) [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" Associative'''(§ method entryAt) [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"Associative" Associative'''(§ method assoc) [#_"Associative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (defn- #_"Atom" Atom'init []
        (hash-map
            #_"AtomicReference" :state nil
        )
    )

    (defn #_"Atom" Atom'new-1 [#_"Object" ___state]
        (let [this (merge (ARef'new-0) (Atom'init))]
            (§ ass (:state this) (AtomicReference. ___state))
            this
        )
    )

    (defn #_"Atom" Atom'new-2 [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Atom'init))]
            (§ ass (:state this) (AtomicReference. ___state))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Atom" this]
        (.get (:state this))
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___v (deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___v)]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___v (deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___v, ___arg)]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___v (deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___v, ___arg1, ___arg2)]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method swap) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___v (deref this)]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar-4(___v, ___x, ___y, ___args)))]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (.notifyWatches this, ___v, ___newv)
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___oldv (deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___oldv)]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___oldv (deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___oldv, ___arg)]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___oldv (deref this)]
                (let [#_"Object" ___newv (.invoke ___f, ___oldv, ___arg1, ___arg2)]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method swapVals) [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___oldv (deref this)]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar-4(___oldv, ___x, ___y, ___args)))]
                    (.validate this, ___newv)
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (.notifyWatches this, ___oldv, ___newv)
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method compareAndSet) [#_"Atom" this, #_"Object" ___oldv, #_"Object" ___newv]
        (.validate this, ___newv)
        (let [#_"boolean" ___ret (ß (:state this).compareAndSet(___oldv, ___newv))]
            (when ___ret
                (.notifyWatches this, ___oldv, ___newv)
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reset) [#_"Atom" this, #_"Object" ___newval]
        (let [#_"Object" ___oldval (.get (:state this))]
            (.validate this, ___newval)
            (ß (:state this).set(___newval))
            (.notifyWatches this, ___oldval, ___newval)
            ___newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" (§ method resetVals) [#_"Atom" this, #_"Object" ___newv]
        (.validate this, ___newv)
        (while true
            (let [#_"Object" ___oldv (deref this)]
                (when (ß (:state this).compareAndSet(___oldv, ___newv))
                    (.notifyWatches this, ___oldv, ___newv)
                    (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_protected
    (defn #_"ATransientMap" ATransientMap'new []
        (AFn'new)
    )

    #_abstract
    (§ defn #_"void" (§ method ensureEditable) [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"ATransientMap" this, #_"Object" ___key])
    #_abstract
    (§ defn #_"Object" (§ method doValAt) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (§ defn #_"int" (§ method doCount) [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"ATransientMap" this])

    #_method
    (§ defn #_"ITransientMap" (§ method conj) [#_"ATransientMap" this, #_"Object" ___o]
        (.ensureEditable this)
        (cond (ß ___o instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (§ return (ß this.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (ß ___o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
                    (when (ß (count ___v) != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß this.assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ___ret this]
            (loop-when-recur [#_"ISeq" ___es (RT'seq ___o)] (some? ___es) [(next ___es)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) (first ___es))]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientMap" this, #_"Object" ___arg1]
        (.valAt this, ___arg1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (.valAt this, ___arg1, ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ATransientMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"ITransientMap" (§ method assoc) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val]
        (.ensureEditable this)
        (.doAssoc this, ___key, ___val)
    )

    #_method
    (§ defn #_"ITransientMap" (§ method without) [#_"ATransientMap" this, #_"Object" ___key]
        (.ensureEditable this)
        (.doWithout this, ___key)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method persistent) [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doPersistent this)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (.ensureEditable this)
        (.doValAt this, ___key, ___notFound)
    )

    (def- #_"Object" ATransientMap'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"ATransientMap" this, #_"Object" ___key]
        (ß (this.valAt(___key, ATransientMap'NOT_FOUND) != ATransientMap'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"ATransientMap" this, #_"Object" ___key]
        (let [#_"Object" ___v (ß this.valAt(___key, ATransientMap'NOT_FOUND))]
            (when (ß ___v != ATransientMap'NOT_FOUND)
                (§ return (MapEntry'create ___key, ___v))
            )
            nil
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ATransientMap" this]
        (.ensureEditable this)
        (.doCount this)
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (defn- #_"ATransientSet" ATransientSet'init []
        (hash-map
            #_volatile
            #_"ITransientMap" :impl nil
        )
    )

    (defn #_"ATransientSet" ATransientSet'new [#_"ITransientMap" ___impl]
        (let [this (merge (AFn'new) (ATransientSet'init))]
            (§ ass (:impl this) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ATransientSet" this]
        (count (:impl this))
    )

    #_method
    (§ defn #_"ITransientSet" (§ method conj) [#_"ATransientSet" this, #_"Object" ___val]
        (let [#_"ITransientMap" ___m (ß (:impl this).assoc(___val, ___val))]
            (when (ß ___m != (:impl this))
                (§ ass (:impl this) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"ATransientSet" this, #_"Object" ___key]
        (ß (.this != (:impl this).valAt(___key, this)))
    )

    #_method
    (§ defn #_"ITransientSet" (§ method disjoin) [#_"ATransientSet" this, #_"Object" ___key]
        (let [#_"ITransientMap" ___m (ß (:impl this).without(___key))]
            (when (ß ___m != (:impl this))
                (§ ass (:impl this) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"ATransientSet" this, #_"Object" ___key]
        (ß (:impl this).valAt(___key))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientSet" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß (:impl this).valAt(___key, ___notFound))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ATransientSet" this, #_"Object" ___key]
        (ß (:impl this).valAt(___key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" BigInt'ZERO (BigInt'new 0, nil))
    (§ def #_"BigInt" BigInt'ONE (BigInt'new 1, nil))

    (defn- #_"BigInt" BigInt'init []
        (hash-map
            #_"long" :lpart 0
            #_"BigInteger" :bipart nil
        )
    )

    (defn- #_"BigInt" BigInt'new [#_"long" ___lpart, #_"BigInteger" ___bipart]
        (let [this (merge (Number'new) (BigInt'init))]
            (§ ass (:lpart this) ___lpart)
            (§ ass (:bipart this) ___bipart)
            this
        )
    )

    ;; must follow Long
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (ß (int) ((:lpart this) :xor ((:lpart this) >>> 32))))
        )
        (.hashCode (:bipart this))
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (Murmur3'hashLong (:lpart this)))
        )
        (.hashCode (:bipart this))
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"BigInt" this, #_"Object" ___obj]
        (when (ß this == ___obj)
            (§ return true)
        )
        (when (ß ___obj instanceof BigInt)
            (let [#_"BigInt" ___o (ß (BigInt) ___obj)]
                (when (nil? (:bipart this))
                    (§ return (ß ((:bipart ___o) == nil && (:lpart this) == (:lpart ___o))))
                )
                (§ return (ß ((:bipart ___o) != nil && (:bipart this).equals((:bipart ___o)))))
            )
        )
        false
    )

    (defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" ___val]
        (if (ß (.bitLength ___val) < 64)
            (do
                (ß BigInt'new((.longValue ___val), nil))
            )
            (do
                (BigInt'new 0, ___val)
            )
        )
    )

    (defn #_"BigInt" BigInt'fromLong [#_"long" ___val]
        (BigInt'new ___val, nil)
    )

    #_method
    (§ defn #_"BigInteger" (§ method toBigInteger) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (BigInteger/valueOf (:lpart this))
            )
            (do
                (:bipart this)
            )
        )
    )

    #_method
    (§ defn #_"BigDecimal" (§ method toBigDecimal) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (BigDecimal/valueOf (:lpart this))
            )
            (do
                (BigDecimal. (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method intValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (int) (:lpart this))
            )
            (do
                (.intValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"long" (§ method longValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (.longValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"float" (§ method floatValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (.floatValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"double" (§ method doubleValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (.doubleValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"byte" (§ method byteValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (byte) (:lpart this))
            )
            (do
                (.byteValue (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"short" (§ method shortValue) [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (short) (:lpart this))
            )
            (do
                (.shortValue (:bipart this))
            )
        )
    )

    (defn #_"BigInt" BigInt'valueOf [#_"long" ___val]
        (BigInt'new ___val, nil)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (String/valueOf (:lpart this)))
        )
        (.toString (:bipart this))
    )

    #_method
    (§ defn #_"int" (§ method bitLength) [#_"BigInt" this]
        (.bitLength (.toBigInteger this))
    )

    #_method
    (§ defn #_"BigInt" (§ method add) [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (let [#_"long" ___ret (ß (:lpart this) + (:lpart ___y))]
                (when (ß (___ret :xor (:lpart this)) >= 0 || (___ret :xor (:lpart ___y)) >= 0)
                    (§ return (BigInt'valueOf ___ret))
                )
            )
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).add((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"BigInt" (§ method multiply) [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (let [#_"long" ___ret (ß (:lpart this) * (:lpart ___y))]
                (when (ß (:lpart ___y) == 0 || (___ret / (:lpart ___y) == (:lpart this) && (:lpart this) != Long/MIN_VALUE))
                    (§ return (BigInt'valueOf ___ret))
                )
            )
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).multiply((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"BigInt" (§ method quotient) [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (when (ß (:lpart this) == Long/MIN_VALUE && (:lpart ___y) == -1)
                (§ return (ß BigInt'fromBigInteger((.toBigInteger this).negate())))
            )
            (§ return (ß BigInt'valueOf((:lpart this) / (:lpart ___y))))
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).divide((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"BigInt" (§ method remainder) [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (§ return (ß BigInt'valueOf((:lpart this) % (:lpart ___y))))
        )
        (ß BigInt'fromBigInteger((.toBigInteger this).remainder((.toBigInteger ___y))))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (§ return (ß ((:lpart this) < (:lpart ___y))))
        )
        (ß ((.toBigInteger this).compareTo((.toBigInteger ___y)) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (defn- #_"Binding" Binding'init []
        (hash-map
            #_"T" :val nil
            #_"Binding" :rest nil
        )
    )

    (defn #_"Binding" Binding'new-1 [#_"T" ___val]
        (let [this (Binding'init)]
            (§ ass (:val this) ___val)
            (§ ass (:rest this) nil)
            this
        )
    )

    (defn #_"Binding" Binding'new-2 [#_"T" ___val, #_"Binding" ___rest]
        (let [this (Binding'init)]
            (§ ass (:val this) ___val)
            (§ ass (:rest this) ___rest)
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (defn- #_"Box" Box'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Box" Box'new [#_"Object" ___val]
        (let [this (Box'init)]
            (§ ass (:val this) ___val)
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (defn- #_"ChunkBuffer" ChunkBuffer'init []
        (hash-map
            #_"Object[]" :buffer nil
            #_"int" :end 0
        )
    )

    (defn #_"ChunkBuffer" ChunkBuffer'new [#_"int" ___capacity]
        (let [this (ChunkBuffer'init)]
            (§ ass (:buffer this) (make-array Object ___capacity))
            (§ ass (:end this) 0)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"ChunkBuffer" this, #_"Object" ___o]
        (§ ass (ß (:buffer this)[(:end this)]) ___o)
        (§ ass (:end this) (+ (:end this) 1))
        nil
    )

    #_method
    (§ defn #_"IChunk" (§ method chunk) [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ___ret (ArrayChunk'new-3 (:buffer this), 0, (:end this))]
            (§ ass (:buffer this) nil)
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ChunkBuffer" this]
        (:end this)
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (defn- #_"ChunkedCons" ChunkedCons'init []
        (hash-map
            #_"IChunk" :chunk nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-3 [#_"IPersistentMap" ___meta, #_"IChunk" ___chunk, #_"ISeq" ___more]
        (let [this (merge (ASeq'new ___meta) (ChunkedCons'init))]
            (§ ass (:chunk this) ___chunk)
            (§ ass (:_more this) ___more)
            this
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-2 [#_"IChunk" ___chunk, #_"ISeq" ___more]
        (ChunkedCons'new-3 nil, ___chunk, ___more)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"ChunkedCons" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (:_meta this))
            (§ return (ChunkedCons'new-3 ___meta, (:chunk this), (:_more this)))
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ChunkedCons" this]
        (ß (:chunk this).nth(0))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ChunkedCons" this]
        (when (ß (:chunk this).count() > 1)
            (§ return (ß ChunkedCons'new-2((:chunk this).dropFirst(), (:_more this))))
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"ChunkedCons" this]
        (when (ß (:chunk this).count() > 1)
            (§ return (ß ChunkedCons'new-2((:chunk this).dropFirst(), (:_more this))))
        )
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"ChunkedCons" this]
        (:chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"ChunkedCons" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"ChunkedCons" this]
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

#_stateless
(class-ns Compile
    (def- #_"String" Compile'PATH_PROP "cloiure.compile.path")
    (def- #_"String" Compile'REFLECTION_WARNING_PROP "cloiure.compile.warn-on-reflection")
    (def- #_"String" Compile'UNCHECKED_MATH_PROP "cloiure.compile.unchecked-math")

    (§ def- #_"Var" Compile'compile_path (RT'var-2 "cloiure.core", "*compile-path*"))
    (§ def- #_"Var" Compile'compile (RT'var-2 "cloiure.core", "compile"))
    (§ def- #_"Var" Compile'warn_on_reflection (RT'var-2 "cloiure.core", "*warn-on-reflection*"))
    (§ def- #_"Var" Compile'unchecked_math (RT'var-2 "cloiure.core", "*unchecked-math*"))

    (defn #_"void" Compile'main [#_"String[]" ___args] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" ___out (ß (OutputStreamWriter) RT'OUT.deref())]
            (let [#_"PrintWriter" ___err (RT'errPrintWriter)]
                (let [#_"String" ___path (System/getProperty Compile'PATH_PROP)]
                    (let [#_"int" ___count (ß ___args.length)]
                        (when (nil? ___path)
                            (.println ___err, (str "ERROR: Must set system property " Compile'PATH_PROP "\nto the location for compiled .class files." "\nThis directory must also be on your CLASSPATH."))
                            (System/exit 1)
                        )

                        (let [#_"boolean" ___warnOnReflection (ß System/getProperty(Compile'REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" ___uncheckedMathProp (System/getProperty Compile'UNCHECKED_MATH_PROP)]
                                (let [#_"Object" ___uncheckedMath Boolean/FALSE]
                                    (cond (ß "true".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath Boolean/TRUE)
                                        )
                                        (ß "warn-on-boxed".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath (Keyword'intern-1 "warn-on-boxed"))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (RT'load-1 "cloiure/core/specs/alpha")

                                    (try
                                        (ß Var'pushThreadBindings(RT'map(
                                            (object-array [
                                                compile_path       ___path
                                                warn_on_reflection ___warnOnReflection
                                                unchecked_math     ___uncheckedMath
                                            ])
                                        )))

                                        (doseq [#_"String" ___lib ___args]
                                            (.write ___out, (str "Compiling " ___lib " to " ___path "\n"))
                                            (.flush ___out)
                                            (.invoke Compile'compile, (Symbol'intern-1 ___lib))
                                        )
                                        (finally
                                            (Var'popThreadBindings)
                                            (try
                                                (.flush ___out)
                                                (catch IOException ___e
                                                    (.printStackTrace ___e, ___err)
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

#_private
#_stateless
(class-ns Recur
)

(§ defprotocol Expr
    #_abstract
    (#_"Object" Expr'''(§ method eval) [#_"Expr" this])
    #_abstract
    (#_"void" Expr'''(§ method emit) [#_"Expr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
    #_abstract
    (#_"boolean" Expr'''(§ method hasJavaClass) [#_"Expr" this])
    #_abstract
    (#_"Class" Expr'''(§ method getJavaClass) [#_"Expr" this])
)

#_stateless
#_abstract
(class-ns UntypedExpr (§ implements Expr)
    #_protected
    (defn #_"UntypedExpr" UntypedExpr'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"UntypedExpr" this]
        false
    )
)

(§ defprotocol IParser
    #_abstract
    (#_"Expr" IParser'''(§ method parse) [#_"IParser" this, #_"Context" ___context, #_"Object" ___form])
)

#_closure
(class-ns DefParser (§ implements IParser)
    (defn #_"DefParser" DefParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"DefParser" this, #_"Context" ___context, #_"Object" ___form]
        ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
        (let [#_"String" ___docstring nil]
            (when (ß RT'count(___form) == 4 && (RT'third(___form) instanceof String))
                (§ ass ___docstring (ß (String) RT'third(___form)))
                (§ ass ___form (ß RT'list-3(RT'first(___form), RT'second(___form), RT'fourth(___form))))
            )
            (cond (ß RT'count(___form) > 3)
                (do
                    (throw (Util'runtimeException-1 "Too many arguments to def"))
                )
                (ß RT'count(___form) < 2)
                (do
                    (throw (Util'runtimeException-1 "Too few arguments to def"))
                )
                (not (ß RT'second(___form) instanceof Symbol))
                (do
                    (throw (Util'runtimeException-1 "First argument to def must be a Symbol"))
                )
            )
            (let [#_"Symbol" ___sym (ß (Symbol) RT'second(___form))]
                (let [#_"Var" ___v (ß Compiler'lookupVar-2(___sym, true))]
                    (when (nil? ___v)
                        (throw (Util'runtimeException-1 "Can't refer to qualified var that doesn't exist"))
                    )
                    (let [#_"boolean" ___shadowsCoreMapping false]
                        (when (not (ß (:ns ___v).equals((.currentNS this))))
                            (if (ß (:ns ___sym) == nil)
                                (do
                                    (§ ass ___v (.intern (.currentNS this), ___sym))
                                    (§ ass ___shadowsCoreMapping true)
                                    (ß registerVar(___v))
                                )
                                (do
                                    (throw (Util'runtimeException-1 "Can't create defs outside of current ns"))
                                )
                            )
                        )
                        (let [#_"IPersistentMap" ___mm (.meta ___sym)]
                            (let [#_"boolean" ___isDynamic (ß RT'booleanCast-1o(RT'get-2(___mm, dynamicKey)))]
                                (when ___isDynamic
                                    (.setDynamic ___v)
                                )
                                (when (ß (not ___isDynamic) && (:name ___sym).startsWith("*") && (:name ___sym).endsWith("*") && (:name ___sym).length() > 2)
                                    (.format (RT'errPrintWriter), "Warning: %1$s not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", (object-array [ ___sym, (.get Compiler'SOURCE_PATH), (.get Compiler'LINE) ]))
                                )
                                (when (RT'booleanCast-1o (RT'get-2 ___mm, arglistsKey))
                                    (let [#_"IPersistentMap" ___vm (.meta ___v)]
                                        ;; drop quote
                                        (§ ass ___vm (ß (IPersistentMap) RT'assoc(___vm, arglistsKey, RT'second(___mm.valAt(arglistsKey)))))
                                        (.setMeta ___v, ___vm)
                                    )
                                )
                                (let [#_"Object" ___source_path (or (.get Compiler'SOURCE_PATH) "NO_SOURCE_FILE")]
                                    (§ ass ___mm (ß (IPersistentMap) RT'assoc(___mm, RT'LINE_KEY, Compiler'LINE.get()).assoc(RT'COLUMN_KEY, Compiler'COLUMN.get()).assoc(RT'FILE_KEY, ___source_path)))
                                    (when (some? ___docstring)
                                        (§ ass ___mm (ß (IPersistentMap) RT'assoc(___mm, RT'DOC_KEY, ___docstring)))
                                    )
                                    (§ ass ___mm (ß (IPersistentMap) elideMeta(___mm)))
                                    (let [#_"Expr" ___meta (if (zero? (count ___mm)) nil (analyze (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), ___mm))]
                                        (DefExpr'new (cast String (ß Compiler'SOURCE.deref())), (ß Compiler'lineDeref()), (ß Compiler'columnDeref()), ___v, (analyze (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (RT'third ___form), (:name (:sym ___v))), ___meta, (ß RT'count(___form) == 3), ___isDynamic, ___shadowsCoreMapping)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr (§ implements Expr)
    (def #_"Method" DefExpr'bindRootMethod (Method/getMethod "void bindRoot(Object)"))
    (def #_"Method" DefExpr'setTagMethod (Method/getMethod "void setTag(cloiure.lang.Symbol)"))
    (def #_"Method" DefExpr'setMetaMethod (Method/getMethod "void setMeta(cloiure.lang.IPersistentMap)"))
    (def #_"Method" DefExpr'setDynamicMethod (Method/getMethod "cloiure.lang.Var setDynamic(boolean)"))
    (def #_"Method" DefExpr'symintern (Method/getMethod "cloiure.lang.Symbol intern(String, String)"))
    (def #_"Method" DefExpr'internVar (Method/getMethod "cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

    (defn- #_"DefExpr" DefExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Expr" :init nil
            #_"Expr" :meta nil
            #_"boolean" :initProvided false
            #_"boolean" :isDynamic false
            #_"boolean" :shadowsCoreMapping false
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"DefExpr" DefExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Var" ___var, #_"Expr" ___init, #_"Expr" ___meta, #_"boolean" ___initProvided, #_"boolean" ___isDynamic, #_"boolean" ___shadowsCoreMapping]
        (let [this (DefExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:var this) ___var)
            (§ ass (:init this) ___init)
            (§ ass (:meta this) ___meta)
            (§ ass (:isDynamic this) ___isDynamic)
            (§ ass (:shadowsCoreMapping this) ___shadowsCoreMapping)
            (§ ass (:initProvided this) ___initProvided)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method includesExplicitMetadata) [#_"DefExpr" this, #_"MapExpr" ___expr]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals ___expr).count()) [(+ ___i 2)]
            (let [#_"Keyword" ___k (:k (cast' KeywordExpr (ß (:keyvals ___expr).nth(___i))))]
                (when (ß (___k != RT'FILE_KEY) && (___k != RT'DECLARED_KEY) && (___k != RT'LINE_KEY) && (___k != RT'COLUMN_KEY))
                    (§ return true)
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"DefExpr" this]
        (try
            (when (:initProvided this)
                (ß (:var this).bindRoot((:init this).eval()))
            )
            (when (some? (:meta this))
                (let [#_"IPersistentMap" ___metaMap (ß (IPersistentMap) (:meta this).eval())]
                    (when (ß (:initProvided this) || true) ;; includesExplicitMetadata((MapExpr) meta)
                        (ß (:var this).setMeta(___metaMap))
                    )
                )
            )
            (ß (:var this).setDynamic((:isDynamic this)))
            (catch Throwable ___e
                (if (not (ß ___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"DefExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitVar ___objx, ___gen, (:var this))

        (when (:shadowsCoreMapping this)
            (.dup ___gen)
            (ß ___gen.getField(Compiler'VAR_TYPE, "ns", Compiler'NS_TYPE))
            (.swap ___gen)
            (.dup ___gen)
            (ß ___gen.getField(Compiler'VAR_TYPE, "sym", Compiler'SYMBOL_TYPE))
            (.swap ___gen)
            (ß ___gen.invokeVirtual(Compiler'NS_TYPE, DefExpr'internVar))
        )

        (when (:isDynamic this)
            (.push ___gen, (:isDynamic this))
            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, setDynamicMethod))
        )
        (when (some? (:meta this))
            (when (ß (:initProvided this) || true) ;; includesExplicitMetadata((MapExpr) meta)
                (.dup ___gen)
                (ß (:meta this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(Compiler'IPERSISTENTMAP_TYPE))
                (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, setMetaMethod))
            )
        )
        (when (:initProvided this)
            (.dup ___gen)
            (if (ß (:init this) instanceof FnExpr)
                (do
                    (ß ((FnExpr)(:init this)).emitForDefn(___objx, ___gen))
                )
                (do
                    (ß (:init this).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
            )
            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, bindRootMethod))
        )

        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"DefExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"DefExpr" this]
        (§ class Var)
    )
)

#_closure
(class-ns AssignParser (§ implements IParser)
    (defn #_"AssignParser" AssignParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"AssignParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß RT'length(___form) != 3)
                (throw (IllegalArgumentException. "Malformed assignment, expecting (set! target val)"))
            )
            (let [#_"Expr" ___target (ß analyze(:Context'EXPRESSION, RT'second(___form)))]
                (when (not (ß ___target instanceof AssignableExpr))
                    (throw (IllegalArgumentException. "Invalid assignment target"))
                )
                (ß AssignExpr'new((AssignableExpr) ___target, analyze(:Context'EXPRESSION, RT'third(___form))))
            )
        )
    )
)

(class-ns AssignExpr (§ implements Expr)
    (defn- #_"AssignExpr" AssignExpr'init []
        (hash-map
            #_"AssignableExpr" :target nil
            #_"Expr" :val nil
        )
    )

    (defn #_"AssignExpr" AssignExpr'new [#_"AssignableExpr" ___target, #_"Expr" ___val]
        (let [this (AssignExpr'init)]
            (§ ass (:target this) ___target)
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"AssignExpr" this]
        (ß (:target this).evalAssign((:val this)))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"AssignExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emitAssign(___context, ___objx, ___gen, (:val this)))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"AssignExpr" this]
        (.hasJavaClass (:val this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"AssignExpr" this]
        (.getJavaClass (:val this))
    )
)

(class-ns VarExpr (§ implements Expr, AssignableExpr)
    (def #_"Method" VarExpr'getMethod (Method/getMethod "Object get()"))
    (def #_"Method" VarExpr'setMethod (Method/getMethod "Object set(Object)"))

    (defn- #_"VarExpr" VarExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"VarExpr" VarExpr'new [#_"Var" ___var, #_"Symbol" ___tag]
        (let [this (VarExpr'init)]
            (§ ass (:var this) ___var)
            (§ ass (:tag this) (or ___tag (.getTag ___var)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"VarExpr" this]
        (deref (:var this))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitVarValue ___objx, ___gen, (:var this))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"VarExpr" this]
        (ß ((:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"VarExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"VarExpr" this, #_"Expr" ___val]
        (ß (:var this).set((.eval ___val)))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (.emitVar ___objx, ___gen, (:var this))
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, VarExpr'setMethod))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )
)

#_closure
(class-ns TheVarParser (§ implements IParser)
    (defn #_"TheVarParser" TheVarParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"TheVarParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"Symbol" ___sym (ß (Symbol) RT'second(___form))]
            (let [#_"Var" ___v (ß Compiler'lookupVar-2(___sym, false))]
                (when (some? ___v)
                    (§ return (TheVarExpr'new ___v))
                )
                (throw (Util'runtimeException-1 (str "Unable to resolve var: " ___sym " in this context")))
            )
        )
    )
)

(class-ns TheVarExpr (§ implements Expr)
    (defn- #_"TheVarExpr" TheVarExpr'init []
        (hash-map
            #_"Var" :var nil
        )
    )

    (defn #_"TheVarExpr" TheVarExpr'new [#_"Var" ___var]
        (let [this (TheVarExpr'init)]
            (§ ass (:var this) ___var)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"TheVarExpr" this]
        (:var this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"TheVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitVar ___objx, ___gen, (:var this))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"TheVarExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"TheVarExpr" this]
        (§ class Var)
    )
)

(class-ns KeywordExpr (§ extends LiteralExpr)
    (defn- #_"KeywordExpr" KeywordExpr'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordExpr" KeywordExpr'new [#_"Keyword" ___k]
        (let [this (merge (LiteralExpr'new) (KeywordExpr'init))]
            (§ ass (:k this) ___k)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"KeywordExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitKeyword ___objx, ___gen, (:k this))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"KeywordExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"KeywordExpr" this]
        (§ class Keyword)
    )
)

#_closure
(class-ns ImportParser (§ implements IParser)
    (defn #_"ImportParser" ImportParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ImportParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß ImportExpr'new((String) RT'second(___form)))
    )
)

(class-ns ImportExpr (§ implements Expr)
    (def #_"Method" ImportExpr'forNameMethod (Method/getMethod "Class classForNameNonLoading(String)"))
    (def #_"Method" ImportExpr'importClassMethod (Method/getMethod "Class importClass(Class)"))
    (def #_"Method" ImportExpr'derefMethod (Method/getMethod "Object deref()"))

    (defn- #_"ImportExpr" ImportExpr'init []
        (hash-map
            #_"String" :c nil
        )
    )

    (defn #_"ImportExpr" ImportExpr'new [#_"String" ___c]
        (let [this (ImportExpr'init)]
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ImportExpr" this]
        (let [#_"Namespace" ___ns (ß (Namespace) RT'CURRENT_NS.deref())]
            (ß ___ns.importClass(RT'classForNameNonLoading((:c this))))
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ImportExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.getStatic(Compiler'RT_TYPE, "CURRENT_NS", Compiler'VAR_TYPE))
        (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, ImportExpr'derefMethod))
        (ß ___gen.checkCast(Compiler'NS_TYPE))
        (.push ___gen, (:c this))
        (ß ___gen.invokeStatic(Compiler'RT_TYPE, forNameMethod))
        (ß ___gen.invokeVirtual(Compiler'NS_TYPE, importClassMethod))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ImportExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

#_stateless
#_abstract
(class-ns LiteralExpr (§ implements Expr)
    #_protected
    (defn #_"LiteralExpr" LiteralExpr'new []
        (hash-map)
    )

    #_abstract
    (§ defn #_"Object" (§ method val) [#_"LiteralExpr" this])

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LiteralExpr" this]
        (.val this)
    )
)

(§ defprotocol AssignableExpr
    #_abstract
    (#_"Object" AssignableExpr'''(§ method evalAssign) [#_"AssignableExpr" this, #_"Expr" ___val])
    #_abstract
    (#_"void" AssignableExpr'''(§ method emitAssign) [#_"AssignableExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val])
)

(§ defprotocol MaybePrimitiveExpr #_(§ extends Expr)
    #_abstract
    (#_"boolean" MaybePrimitiveExpr'''(§ method canEmitPrimitive) [#_"MaybePrimitiveExpr" this])
    #_abstract
    (#_"void" MaybePrimitiveExpr'''(§ method emitUnboxed) [#_"MaybePrimitiveExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
)

#_closure
(class-ns HostParser (§ implements IParser)
    (defn #_"HostParser" HostParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"HostParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (. x fieldname-sym) or
            ;; (. x 0-ary-method)
            ;; (. x methodname-sym args+)
            ;; (. x (methodname-sym args?))
            (when (ß RT'length(___form) < 3)
                (throw (IllegalArgumentException. "Malformed member expression, expecting (. target member ...)"))
            )
            ;; determine static or instance
            ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
            (let [#_"int" ___line (ß Compiler'lineDeref())]
                (let [#_"int" ___column (ß Compiler'columnDeref())]
                    (let [#_"String" ___source (ß (String) Compiler'SOURCE.deref())]
                        (let [#_"Class" ___c (ß maybeClass(RT'second(___form), false))]
                            ;; at this point c will be non-null if static
                            (let [#_"Expr" ___instance nil]
                                (when (nil? ___c)
                                    (§ ass ___instance (analyze (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (RT'second ___form)))
                                )

                                (let [#_"boolean" ___maybeField (ß (RT'length(___form) == 3) && (RT'third(___form) instanceof Symbol))]
                                    (when (ß ___maybeField && ((:name (cast' Symbol (ß RT'third(___form)))).charAt(0) != \-))
                                        (let [#_"Symbol" ___sym (ß (Symbol) RT'third(___form))]
                                            (cond (some? ___c)
                                                (do
                                                    (§ ass ___maybeField (ß Reflector'getMethods(___c, 0, munge((:name ___sym)), true).size() == 0))
                                                )
                                                (ß ___instance != nil && (.hasJavaClass ___instance) && (.getJavaClass ___instance) != nil)
                                                (do
                                                    (§ ass ___maybeField (ß Reflector'getMethods((.getJavaClass ___instance), 0, munge((:name ___sym)), false).size() == 0))
                                                )
                                            )
                                        )
                                    )

                                    (if ___maybeField ;; field
                                        (do
                                            (let [#_"Symbol" ___sym (ß ((:name (cast' Symbol (ß RT'third(___form)))).charAt(0) == \-) ? Symbol'intern-1((:name (cast' Symbol (ß RT'third(___form)))).substring(1)) :or (Symbol) RT'third(___form))]
                                                (let [#_"Symbol" ___tag (ß tagOf(___form))]
                                                    (if (some? ___c)
                                                        (do
                                                            (ß StaticFieldExpr'new(___line, ___column, ___c, munge((:name ___sym)), ___tag))
                                                        )
                                                        (do
                                                            (ß InstanceFieldExpr'new(___line, ___column, ___instance, munge((:name ___sym)), ___tag, ((:name (cast' Symbol (ß RT'third(___form)))).charAt(0) == \-)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (let [#_"ISeq" ___call (ß (ISeq) ((RT'third(___form) instanceof ISeq) ? RT'third(___form) :or RT'next(RT'next(___form))))]
                                                (when (not (ß RT'first(___call) instanceof Symbol))
                                                    (throw (IllegalArgumentException. "Malformed member expression"))
                                                )
                                                (let [#_"Symbol" ___sym (ß (Symbol) RT'first(___call))]
                                                    (let [#_"Symbol" ___tag (ß tagOf(___form))]
                                                        (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                                                            (let [#_"boolean" ___tailPosition (ß inTailCall(___context))]
                                                                (loop-when-recur [#_"ISeq" ___s (RT'next ___call)] (some? ___s) [(next ___s)]
                                                                    (§ ass ___args (ß ___args.cons(analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (first ___s)))))
                                                                )
                                                                (if (some? ___c)
                                                                    (do
                                                                        (ß StaticMethodExpr'new(___source, ___line, ___column, ___tag, ___c, munge((:name ___sym)), ___args, ___tailPosition))
                                                                    )
                                                                    (do
                                                                        (ß InstanceMethodExpr'new(___source, ___line, ___column, ___tag, ___instance, munge((:name ___sym)), ___args, ___tailPosition))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
#_abstract
(class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
    #_protected
    (defn #_"HostExpr" HostExpr'new []
        (hash-map)
    )

    (def #_"Type" HostExpr'BOOLEAN_TYPE (Type/getType Boolean))
    (def #_"Type" HostExpr'CHAR_TYPE (Type/getType Character))
    (def #_"Type" HostExpr'INTEGER_TYPE (Type/getType Integer))
    (def #_"Type" HostExpr'LONG_TYPE (Type/getType Long))
    (def #_"Type" HostExpr'FLOAT_TYPE (Type/getType Float))
    (def #_"Type" HostExpr'DOUBLE_TYPE (Type/getType Double))
    (def #_"Type" HostExpr'SHORT_TYPE (Type/getType Short))
    (def #_"Type" HostExpr'BYTE_TYPE (Type/getType Byte))
    (def #_"Type" HostExpr'NUMBER_TYPE (Type/getType Number))

    (def #_"Method" HostExpr'charValueMethod (Method/getMethod "char charValue()"))
    (def #_"Method" HostExpr'booleanValueMethod (Method/getMethod "boolean booleanValue()"))

    (def #_"Method" HostExpr'charValueOfMethod (Method/getMethod "Character valueOf(char)"))
    (def #_"Method" HostExpr'intValueOfMethod (Method/getMethod "Integer valueOf(int)"))
    (def #_"Method" HostExpr'longValueOfMethod (Method/getMethod "Long valueOf(long)"))
    (def #_"Method" HostExpr'floatValueOfMethod (Method/getMethod "Float valueOf(float)"))
    (def #_"Method" HostExpr'doubleValueOfMethod (Method/getMethod "Double valueOf(double)"))
    (def #_"Method" HostExpr'shortValueOfMethod (Method/getMethod "Short valueOf(short)"))
    (def #_"Method" HostExpr'byteValueOfMethod (Method/getMethod "Byte valueOf(byte)"))

    (def #_"Method" HostExpr'intValueMethod (Method/getMethod "int intValue()"))
    (def #_"Method" HostExpr'longValueMethod (Method/getMethod "long longValue()"))
    (def #_"Method" HostExpr'floatValueMethod (Method/getMethod "float floatValue()"))
    (def #_"Method" HostExpr'doubleValueMethod (Method/getMethod "double doubleValue()"))
    (def #_"Method" HostExpr'byteValueMethod (Method/getMethod "byte byteValue()"))
    (def #_"Method" HostExpr'shortValueMethod (Method/getMethod "short shortValue()"))

    (def #_"Method" HostExpr'fromIntMethod (Method/getMethod "cloiure.lang.Num from(int)"))
    (def #_"Method" HostExpr'fromLongMethod (Method/getMethod "cloiure.lang.Num from(long)"))
    (def #_"Method" HostExpr'fromDoubleMethod (Method/getMethod "cloiure.lang.Num from(double)"))

    (defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___returnType]
        (when (.isPrimitive ___returnType)
            (cond (ß ___returnType == (§ class boolean))
                (do
                    (let [#_"Label" ___falseLabel (.newLabel ___gen)]
                        (let [#_"Label" ___endLabel (.newLabel ___gen)]
                            (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___falseLabel))
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE))
                            (.goTo ___gen, ___endLabel)
                            (.mark ___gen, ___falseLabel)
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
                            (.mark ___gen, ___endLabel)
                        )
                    )
                )
                (ß ___returnType == (§ class void))
                (do
                    (ß Compiler'NIL_EXPR.emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___returnType == (§ class char))
                (do
                    (ß ___gen.invokeStatic(HostExpr'CHAR_TYPE, charValueOfMethod))
                )
                :else
                (do
                    (cond (ß ___returnType == (§ class int))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'INTEGER_TYPE, intValueOfMethod))
                        )
                        (ß ___returnType == (§ class float))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'FLOAT_TYPE, floatValueOfMethod))
                        )
                        (ß ___returnType == (§ class double))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'DOUBLE_TYPE, doubleValueOfMethod))
                        )
                        (ß ___returnType == (§ class long))
                        (do
                            (ß ___gen.invokeStatic(Compiler'NUMBERS_TYPE, Method/getMethod("Number num(long)")))
                        )
                        (ß ___returnType == (§ class byte))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'BYTE_TYPE, byteValueOfMethod))
                        )
                        (ß ___returnType == (§ class short))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'SHORT_TYPE, shortValueOfMethod))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___paramType]
        (if (.isPrimitive ___paramType)
            (do
                (cond (ß ___paramType == (§ class boolean))
                    (do
                        (ß ___gen.checkCast(HostExpr'BOOLEAN_TYPE))
                        (ß ___gen.invokeVirtual(HostExpr'BOOLEAN_TYPE, booleanValueMethod))
                    )
                    (ß ___paramType == (§ class char))
                    (do
                        (ß ___gen.checkCast(HostExpr'CHAR_TYPE))
                        (ß ___gen.invokeVirtual(HostExpr'CHAR_TYPE, charValueMethod))
                    )
                    :else
                    (do
                        (let [#_"Method" ___m nil]
                            (ß ___gen.checkCast(HostExpr'NUMBER_TYPE))
                            (if (ß RT'booleanCast-1o(RT'UNCHECKED_MATH.deref()))
                                (do
                                    (cond (ß ___paramType == (§ class int))
                                        (do
                                            (§ ass ___m (Method/getMethod "int uncheckedIntCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class float))
                                        (do
                                            (§ ass ___m (Method/getMethod "float uncheckedFloatCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class double))
                                        (do
                                            (§ ass ___m (Method/getMethod "double uncheckedDoubleCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class long))
                                        (do
                                            (§ ass ___m (Method/getMethod "long uncheckedLongCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class byte))
                                        (do
                                            (§ ass ___m (Method/getMethod "byte uncheckedByteCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class short))
                                        (do
                                            (§ ass ___m (Method/getMethod "short uncheckedShortCast(Object)"))
                                        )
                                    )
                                )
                                (do
                                    (cond (ß ___paramType == (§ class int))
                                        (do
                                            (§ ass ___m (Method/getMethod "int intCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class float))
                                        (do
                                            (§ ass ___m (Method/getMethod "float floatCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class double))
                                        (do
                                            (§ ass ___m (Method/getMethod "double doubleCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class long))
                                        (do
                                            (§ ass ___m (Method/getMethod "long longCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class byte))
                                        (do
                                            (§ ass ___m (Method/getMethod "byte byteCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class short))
                                        (do
                                            (§ ass ___m (Method/getMethod "short shortCast(Object)"))
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, ___m))
                        )
                    )
                )
            )
            (do
                (ß ___gen.checkCast(Type/getType(___paramType)))
            )
        )
        nil
    )

    (defn #_"Class" HostExpr'maybeClass [#_"Object" ___form, #_"boolean" ___stringOk]
        (when (ß ___form instanceof Class)
            (§ return (ß (Class) ___form))
        )
        (let [#_"Class" ___c nil]
            (cond (ß ___form instanceof Symbol)
                (do
                    (let [#_"Symbol" ___sym (ß (Symbol) ___form)]
                        (when (ß (:ns ___sym) == nil) ;; if ns-qualified can't be classname
                            (when (ß Util'equals(___sym, Compiler'COMPILE_STUB_SYM.get()))
                                (§ return (ß (Class) Compiler'COMPILE_STUB_CLASS.get()))
                            )
                            (if (ß (:name ___sym).indexOf(\.) > 0 || (:name ___sym).charAt(0) == \[)
                                (do
                                    (§ ass ___c (ß RT'classForNameNonLoading((:name ___sym))))
                                )
                                (do
                                    (let [#_"Object" ___o (ß (.currentNS this).getMapping(___sym))]
                                        (cond (ß ___o instanceof Class)
                                            (do
                                                (§ ass ___c (ß (Class) ___o))
                                            )
                                            (ß Compiler'LOCAL_ENV.deref() != nil && ((java.util.Map)Compiler'LOCAL_ENV.deref()).containsKey(___form))
                                            (do
                                                (§ return nil)
                                            )
                                            :else
                                            (do
                                                (try
                                                    (§ ass ___c (ß RT'classForNameNonLoading((:name ___sym))))
                                                    (catch Exception ___e
                                                        ;; aargh
                                                        ;; leave c set to nil -> return nil
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (ß ___stringOk && ___form instanceof String)
                (do
                    (§ ass ___c (ß RT'classForNameNonLoading((cast String ___form))))
                )
            )
            ___c
        )
    )

    (defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" ___sym]
        (let [#_"Class" ___c (ß primClass(___sym))]
            (cond (some? ___c)
                (do
                    (§ return ___c)
                )
                (ß (:name ___sym).equals("objects"))
                (do
                    (§ ass ___c (§ class Object[]))
                )
                (ß (:name ___sym).equals("ints"))
                (do
                    (§ ass ___c (§ class int[]))
                )
                (ß (:name ___sym).equals("longs"))
                (do
                    (§ ass ___c (§ class long[]))
                )
                (ß (:name ___sym).equals("floats"))
                (do
                    (§ ass ___c (§ class float[]))
                )
                (ß (:name ___sym).equals("doubles"))
                (do
                    (§ ass ___c (§ class double[]))
                )
                (ß (:name ___sym).equals("chars"))
                (do
                    (§ ass ___c (§ class char[]))
                )
                (ß (:name ___sym).equals("shorts"))
                (do
                    (§ ass ___c (§ class short[]))
                )
                (ß (:name ___sym).equals("bytes"))
                (do
                    (§ ass ___c (§ class byte[]))
                )
                (ß (:name ___sym).equals("booleans"))
                (do
                    (§ ass ___c (§ class boolean[]))
                )
            )
            ___c
        )
    )

    (defn #_"Class" HostExpr'tagToClass [#_"Object" ___tag]
        (let [#_"Class" ___c nil]
            (when (ß ___tag instanceof Symbol)
                (let [#_"Symbol" ___sym (ß (Symbol) ___tag)]
                    (when (ß (:ns ___sym) == nil) ;; if ns-qualified can't be classname
                        (§ ass ___c (ß maybeSpecialTag(___sym)))
                    )
                )
            )
            (when (nil? ___c)
                (§ ass ___c (ß maybeClass(___tag, true)))
            )
            (when (some? ___c)
                (§ return ___c)
            )
            (throw (IllegalArgumentException. (str "Unable to resolve classname: " ___tag)))
        )
    )
)

#_stateless
#_abstract
(class-ns FieldExpr (§ extends HostExpr)
    #_protected
    (defn #_"FieldExpr" FieldExpr'new []
        (HostExpr'new)
    )

)

(class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (Method/getMethod "Object invokeNoArgInstanceMember(Object, String, boolean)"))
    (def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (Method/getMethod "Object setInstanceField(Object, String, Object)"))

    (defn- #_"InstanceFieldExpr" InstanceFieldExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"Class" :targetClass nil
            #_"java.lang.reflect.Field" :field nil
            #_"String" :fieldName nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :requireField false

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceFieldExpr" InstanceFieldExpr'new [#_"int" ___line, #_"int" ___column, #_"Expr" ___target, #_"String" ___fieldName, #_"Symbol" ___tag, #_"boolean" ___requireField]
        (let [this (merge (FieldExpr'new) (InstanceFieldExpr'init))]
            (§ ass (:target this) ___target)
            (§ ass (:targetClass this) (when (.hasJavaClass ___target) (.getJavaClass ___target)))
            (§ ass (:field this) (when (some? (:targetClass this)) (Reflector'getField (:targetClass this), ___fieldName, false)))
            (§ ass (:fieldName this) ___fieldName)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:requireField this) ___requireField)

            (when (ß (:field this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                (if (nil? (:targetClass this))
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, ___fieldName ])))
                    )
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, ___fieldName, (.getName (:targetClass this)) ])))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceFieldExpr" this]
        (ß Reflector'invokeNoArgInstanceMember-3((:target this).eval(), (:fieldName this), (:requireField this)))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceFieldExpr" this]
        (ß ((:targetClass this) != nil && (:field this) != nil && Util'isPrimitive((:field this).getType())))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:targetClass this) != nil && (:field this) != nil)
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.checkCast(getType((:targetClass this))))
                (ß ___gen.getField(getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:targetClass this) != nil && (:field this) != nil)
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.checkCast(getType((:targetClass this))))
                (ß ___gen.getField(getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
                (ß HostExpr'emitBoxReturn(___objx, ___gen, (:field this).getType()))
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.push ___gen, (:fieldName this))
                (.push ___gen, (:requireField this))
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, invokeNoArgInstanceMember))
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceFieldExpr" this]
        (ß ((:field this) != nil || (:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"InstanceFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setInstanceField((:target this).eval(), (:fieldName this), (.eval ___val)))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (if (ß (:targetClass this) != nil && (:field this) != nil)
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(getType((:targetClass this))))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.dupX1 ___gen)
                (ß HostExpr'emitUnboxArg(___objx, ___gen, (:field this).getType()))
                (ß ___gen.putField(getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.push ___gen, (:fieldName this))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )
)

(class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (defn- #_"StaticFieldExpr" StaticFieldExpr'init []
        (hash-map
            #_"String" :fieldName nil
            #_"Class" :c nil
            #_"java.lang.reflect.Field" :field nil
            #_"Symbol" :tag nil

            #_"int" :line 0
            #_"int" :column 0

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticFieldExpr" StaticFieldExpr'new [#_"int" ___line, #_"int" ___column, #_"Class" ___c, #_"String" ___fieldName, #_"Symbol" ___tag]
        (let [this (merge (FieldExpr'new) (StaticFieldExpr'init))]
            (§ ass (:fieldName this) ___fieldName)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:c this) ___c)
            (try
                (§ ass (:field this) (.getField ___c, ___fieldName))
                (catch NoSuchFieldException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticFieldExpr" this]
        (Reflector'getStaticField-2c (:c this), (:fieldName this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticFieldExpr" this]
        (ß Util'isPrimitive((:field this).getType()))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
        (ß ___gen.getStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

        (ß ___gen.getStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        (ß HostExpr'emitBoxReturn(___objx, ___gen, (:field this).getType()))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticFieldExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"StaticFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setStaticField-3c((:c this), (:fieldName this), (.eval ___val)))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
        (.dup ___gen)
        (ß HostExpr'emitUnboxArg(___objx, ___gen, (:field this).getType()))
        (ß ___gen.putStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )
)

#_stateless
#_abstract
(class-ns MethodExpr (§ extends HostExpr)
    #_protected
    (defn #_"MethodExpr" MethodExpr'new []
        (HostExpr'new)
    )

    (defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" ___args, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push((count ___args)))
        (ß ___gen.newArray(Compiler'OBJECT_TYPE))
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
            (.dup ___gen)
            (.push ___gen, ___i)
            (ß ((Expr) ___args.nth(___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
            (ß ___gen.arrayStore(Compiler'OBJECT_TYPE))
        )
        nil
    )

    (defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class[]" ___parameterTypes, #_"IPersistentVector" ___args]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___parameterTypes.length) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) ___args.nth(___i))]
                (try
                    (let [#_"Class" ___primc (ß maybePrimitiveType(___e))]
                        (cond (ß ___primc == ___parameterTypes[___i])
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                            )
                            (ß ___primc == (§ class int) && ___parameterTypes[___i] == (§ class long))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (.visitInsn ___gen, Opcodes/I2L)
                                )
                            )
                            (ß ___primc == (§ class long) && ___parameterTypes[___i] == (§ class int))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (if (ß RT'booleanCast-1o(RT'UNCHECKED_MATH.deref()))
                                        (do
                                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int uncheckedIntCast(long)")))
                                        )
                                        (do
                                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                                        )
                                    )
                                )
                            )
                            (ß ___primc == (§ class float) && ___parameterTypes[___i] == (§ class double))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (.visitInsn ___gen, Opcodes/F2D)
                                )
                            )
                            (ß ___primc == (§ class double) && ___parameterTypes[___i] == (§ class float))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (.visitInsn ___gen, Opcodes/D2F)
                                )
                            )
                            :else
                            (do
                                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (ß HostExpr'emitUnboxArg(___objx, ___gen, ___parameterTypes[___i]))
                            )
                        )
                    )
                    (catch Exception ___e1
                        (throw (Util'sneakyThrow ___e1))
                    )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr (§ extends MethodExpr)
    (def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (Method/getMethod "Object invokeInstanceMethod(Object, String, Object[])"))

    (defn- #_"InstanceMethodExpr" InstanceMethodExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
            #_"java.lang.reflect.Method" :method nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceMethodExpr" InstanceMethodExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___target, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (merge (MethodExpr'new) (InstanceMethodExpr'init))]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:args this) ___args)
            (§ ass (:methodName this) ___methodName)
            (§ ass (:target this) ___target)
            (§ ass (:tag this) ___tag)
            (§ ass (:tailPosition this) ___tailPosition)
            (if (ß (.hasJavaClass ___target) && (.getJavaClass ___target) != nil)
                (do
                    (let [#_"List" ___methods (ß Reflector'getMethods((.getJavaClass ___target), (count ___args), ___methodName, false))]
                        (if (.isEmpty ___methods)
                            (do
                                (§ ass (:method this) nil)
                                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName, (.getName (.getJavaClass ___target)) ])))
                                )
                            )
                            (do
                                (let [#_"int" ___methodidx 0]
                                    (when (ß (.size ___methods) > 1)
                                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___methods)) [(inc ___i)]
                                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                                        (ß ___params.add((.getParameterTypes ___m)))
                                                        (ß ___rets.add((.getReturnType ___m)))
                                                    )
                                                )
                                                (§ ass ___methodidx (ß getMatchingParams(___methodName, ___params, ___args, ___rets)))
                                            )
                                        )
                                    )
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ((___methodidx >= 0) ? (ß ___methods.get(___methodidx)) :or nil))]
                                        (when (ß ___m != nil && (not (ß Modifier/isPublic((.getDeclaringClass ___m).getModifiers()))))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (§ ass ___m (ß Reflector'getAsMethodOfPublicBase((.getDeclaringClass ___m), ___m)))
                                        )
                                        (§ ass (:method this) ___m)
                                        (when (ß (:method this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                            (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName, (.getName (.getJavaClass ___target)), (ß getTypeStringForArgs(___args)) ])))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (§ ass (:method this) nil)
                    (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName ])))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" ___targetval (.eval (:target this))]
                (let [#_"Object[]" ___argvals (make-array Object (count (:args this)))]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                        (§ ass (ß ___argvals[___i]) (ß ((Expr) (:args this).nth(___i)).eval()))
                    )
                    (when (some? (:method this))
                        (let [#_"LinkedList" ___ms (LinkedList.)]
                            (.add ___ms, (:method this))
                            (§ return (Reflector'invokeMatchingMethod (:methodName this), ___ms, ___targetval, ___argvals))
                        )
                    )
                    (Reflector'invokeInstanceMethod ___targetval, (:methodName this), ___argvals)
                )
            )
            (catch Throwable ___e
                (if (not (ß ___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceMethodExpr" this]
        (ß ((:method this) != nil && Util'isPrimitive((:method this).getReturnType())))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (let [#_"Type" ___type (ß Type/getType((:method this).getDeclaringClass()))]
                    (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (.checkCast ___gen, ___type)
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                    (when (ß (:tailPosition this) && (not (:canBeDirect ___objx)))
                        (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                            (.emitClearThis ___method, ___gen)
                        )
                    )
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (if (ß (:method this).getDeclaringClass().isInterface())
                            (do
                                (.invokeInterface ___gen, ___type, ___m)
                            )
                            (do
                                (.invokeVirtual ___gen, ___type, ___m)
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (let [#_"Type" ___type (ß Type/getType((:method this).getDeclaringClass()))]
                    (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (.checkCast ___gen, ___type)
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                    (when (ß ___context == :Context'RETURN)
                        (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                            (.emitClearLocals ___method, ___gen)
                        )
                    )
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (if (ß (:method this).getDeclaringClass().isInterface())
                            (do
                                (.invokeInterface ___gen, ___type, ___m)
                            )
                            (do
                                (.invokeVirtual ___gen, ___type, ___m)
                            )
                        )
                        (ß HostExpr'emitBoxReturn(___objx, ___gen, (:method this).getReturnType()))
                    )
                )
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (.push ___gen, (:methodName this))
                (ß emitArgsAsArray((:args this), ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceMethodExpr" this]
        (ß ((:method this) != nil || (:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß retType(((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or nil, ((:method this) != nil) ? (:method this).getReturnType() :or nil)))
        )
        (:jc this)
    )
)

(class-ns StaticMethodExpr (§ extends MethodExpr)
    (def #_"Method" StaticMethodExpr'forNameMethod (Method/getMethod "Class classForName(String)"))
    (def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (Method/getMethod "Object invokeStaticMethod(Class, String, Object[])"))
    (§ def #_"Keyword" StaticMethodExpr'warnOnBoxedKeyword (Keyword'intern-1 "warn-on-boxed"))

    (defn- #_"StaticMethodExpr" StaticMethodExpr'init []
        (hash-map
            #_"Class" :c nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
            #_"java.lang.reflect.Method" :method nil
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticMethodExpr" StaticMethodExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Class" ___c, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (merge (MethodExpr'new) (StaticMethodExpr'init))]
            (§ ass (:c this) ___c)
            (§ ass (:methodName this) ___methodName)
            (§ ass (:args this) ___args)
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:tailPosition this) ___tailPosition)

            (let [#_"List" ___methods (ß Reflector'getMethods(___c, (count ___args), ___methodName, true))]
                (when (.isEmpty ___methods)
                    (throw (IllegalArgumentException. (str "No matching method: " ___methodName)))
                )

                (let [#_"int" ___methodidx 0]
                    (when (ß (.size ___methods) > 1)
                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___methods)) [(inc ___i)]
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                        (ß ___params.add((.getParameterTypes ___m)))
                                        (ß ___rets.add((.getReturnType ___m)))
                                    )
                                )
                                (§ ass ___methodidx (ß getMatchingParams(___methodName, ___params, ___args, ___rets)))
                            )
                        )
                    )
                    (§ ass (:method this) (ß (java.lang.reflect.Method) ((___methodidx >= 0) ? (ß ___methods.get(___methodidx)) :or nil)))
                    (when (ß (:method this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, ___methodName, (.getName ___c), (ß getTypeStringForArgs(___args)) ])))
                    )
                    (when (ß (:method this) != nil && warnOnBoxedKeyword.equals(RT'UNCHECKED_MATH.deref()) && StaticMethodExpr'isBoxedMath((:method this)))
                        (ß RT'errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, (.toString (:method this)) ])))
                    )
                    this
                )
            )
        )
    )

    (defn #_"boolean" StaticMethodExpr'isBoxedMath [#_"java.lang.reflect.Method" ___m]
        (let [#_"Class" ___c (.getDeclaringClass ___m)]
            (when (ß ___c.equals((§ class Numbers)))
                (let [#_"Class[]" ___argTypes (.getParameterTypes ___m)]
                    (doseq [#_"Class" ___argType ___argTypes]
                        (when (ß ___argType.equals((§ class Object)) || ___argType.equals((§ class Number)))
                            (§ return true)
                        )
                    )
                )
            )
            false
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" ___argvals (make-array Object (count (:args this)))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                    (§ ass (ß ___argvals[___i]) (ß ((Expr) (:args this).nth(___i)).eval()))
                )
                (when (some? (:method this))
                    (let [#_"LinkedList" ___ms (LinkedList.)]
                        (.add ___ms, (:method this))
                        (§ return (Reflector'invokeMatchingMethod (:methodName this), ___ms, nil, ___argvals))
                    )
                )
                (Reflector'invokeStaticMethod-3c (:c this), (:methodName this), ___argvals)
            )
            (catch Throwable ___e
                (if (not (ß ___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticMethodExpr" this]
        (ß ((:method this) != nil && Util'isPrimitive((:method this).getReturnType())))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitIntrinsicPredicate) [#_"StaticMethodExpr" this]
        (ß ((:method this) != nil && RT'get-2(Intrinsics'preds, (:method this).toString()) != nil))
    )

    #_method
    (§ defn #_"void" (§ method emitIntrinsicPredicate) [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Label" ___falseLabel]
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (let [#_"Object[]" ___predOps (ß (Object[]) RT'get-2(Intrinsics'preds, (:method this).toString()))]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___predOps.length - 1) [(inc ___i)]
                        (ß ___gen.visitInsn((Integer)___predOps[___i]))
                    )
                    (ß ___gen.visitJumpInsn((Integer)___predOps[___predOps.length - 1], ___falseLabel))
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (let [#_"Object" ___ops (ß RT'get-2(Intrinsics'ops, (:method this).toString()))]
                    (if (some? ___ops)
                        (do
                            (if (ß ___ops instanceof Object[])
                                (do
                                    (doseq [#_"Object" ___op (ß (Object[])___ops)]
                                        (ß ___gen.visitInsn((cast Integer ___op)))
                                    )
                                )
                                (do
                                    (ß ___gen.visitInsn((cast Integer ___ops)))
                                )
                            )
                        )
                        (do
                            (let [#_"Type" ___type (Type/getType (:c this))]
                                (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                                    (.invokeStatic ___gen, ___type, ___m)
                                )
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß (:tailPosition this) && (not (:canBeDirect ___objx)))
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (.emitClearThis ___method, ___gen)
                    )
                )
                (let [#_"Type" ___type (Type/getType (:c this))]
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (.invokeStatic ___gen, ___type, ___m)
                        (let [#_"Class" ___retClass (.getReturnType (:method this))]
                            (if (ß ___context == :Context'STATEMENT)
                                (do
                                    (cond (ß ___retClass == (§ class long) || ___retClass == (§ class double))
                                        (do
                                            (.pop2 ___gen)
                                        )
                                        (ß ___retClass != (§ class void))
                                        (do
                                            (.pop ___gen)
                                        )
                                    )
                                )
                                (do
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, (:method this).getReturnType()))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.push((:c this).getName()))
                (ß ___gen.invokeStatic(Compiler'RT_TYPE, forNameMethod))
                (.push ___gen, (:methodName this))
                (ß emitArgsAsArray((:args this), ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (.emitClearLocals ___method, ___gen)
                    )
                )
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, invokeStaticMethodMethod))
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticMethodExpr" this]
        (ß ((:method this) != nil || (:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß retType(((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or nil, ((:method this) != nil) ? (:method this).getReturnType() :or nil)))
        )
        (:jc this)
    )
)

(class-ns UnresolvedVarExpr (§ implements Expr)
    (defn- #_"UnresolvedVarExpr" UnresolvedVarExpr'init []
        (hash-map
            #_"Symbol" :symbol nil
        )
    )

    (defn #_"UnresolvedVarExpr" UnresolvedVarExpr'new [#_"Symbol" ___symbol]
        (let [this (UnresolvedVarExpr'init)]
            (§ ass (:symbol this) ___symbol)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"UnresolvedVarExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"UnresolvedVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
    (defn- #_"NumberExpr" NumberExpr'init []
        (hash-map
            #_"Number" :n nil
            #_"int" :id 0
        )
    )

    (defn #_"NumberExpr" NumberExpr'new [#_"Number" ___n]
        (let [this (merge (LiteralExpr'new) (NumberExpr'init))]
            (§ ass (:n this) ___n)
            (§ ass (:id this) (ß registerConstant(___n)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"NumberExpr" this]
        (:n this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (.emitConstant ___objx, ___gen, (:id this))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NumberExpr" this]
        (cond (ß (:n this) instanceof Integer)
            (do
                (§ class long)
            )
            (ß (:n this) instanceof Double)
            (do
                (§ class double)
            )
            (ß (:n this) instanceof Long)
            (do
                (§ class long)
            )
            :else
            (do
                (throw (IllegalStateException. (str "Unsupported Number type: " (ß (:n this).getClass().getName()))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (ß (:n this) instanceof Integer)
            (do
                (ß ___gen.push((:n this).longValue()))
            )
            (ß (:n this) instanceof Double)
            (do
                (ß ___gen.push((:n this).doubleValue()))
            )
            (ß (:n this) instanceof Long)
            (do
                (ß ___gen.push((:n this).longValue()))
            )
        )
        nil
    )

    (defn #_"Expr" NumberExpr'parse [#_"Number" ___form]
        (if (ß ___form instanceof Integer || ___form instanceof Double || ___form instanceof Long)
            (do
                (NumberExpr'new ___form)
            )
            (do
                (ConstantExpr'new ___form)
            )
        )
    )
)

#_closure
(class-ns ConstantParser (§ implements IParser)
    (§ def #_"Keyword" ConstantParser'formKey (Keyword'intern-1 "form"))

    (defn #_"ConstantParser" ConstantParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ConstantParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"int" ___argCount (ß RT'count(___form) - 1)]
            (when (ß ___argCount != 1)
                (let [#_"IPersistentMap" ___exData (PersistentArrayMap'new-1 (object-array [ ConstantParser'formKey, ___form ]))]
                    (throw (ExceptionInfo'new-2 (str "Wrong number of args (" ___argCount ") passed to quote"), ___exData))
                )
            )
            (let [#_"Object" ___v (RT'second ___form)]
                (cond (nil? ___v)
                    (do
                        (§ return Compiler'NIL_EXPR)
                    )
                    (ß ___v == Boolean/TRUE)
                    (do
                        (§ return Compiler'TRUE_EXPR)
                    )
                    (ß ___v == Boolean/FALSE)
                    (do
                        (§ return Compiler'FALSE_EXPR)
                    )
                )
                (cond (ß ___v instanceof Number)
                    (do
                        (ß NumberExpr'parse((cast Number ___v)))
                    )
                    (ß ___v instanceof String)
                    (do
                        (ß StringExpr'new((cast String ___v)))
                    )
                    (ß ___v instanceof IPersistentCollection && (cast' IPersistentCollection ___v).count() == 0)
                    (do
                        (EmptyExpr'new ___v)
                    )
                    :else
                    (do
                        (ConstantExpr'new ___v)
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr (§ extends LiteralExpr)
    (defn- #_"ConstantExpr" ConstantExpr'init []
        (hash-map
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            #_"Object" :v nil
            #_"int" :id 0
        )
    )

    (defn #_"ConstantExpr" ConstantExpr'new [#_"Object" ___v]
        (let [this (merge (LiteralExpr'new) (ConstantExpr'init))]
            (§ ass (:v this) ___v)
            (§ ass (:id this) (ß registerConstant(___v)))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"ConstantExpr" this]
        (:v this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ConstantExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitConstant ___objx, ___gen, (:id this))

        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ConstantExpr" this]
        (ß Modifier/isPublic((:v this).getClass().getModifiers()))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ConstantExpr" this]
        (cond (ß (:v this) instanceof APersistentMap)
            (do
                (§ class APersistentMap)
            )
            (ß (:v this) instanceof APersistentSet)
            (do
                (§ class APersistentSet)
            )
            (ß (:v this) instanceof APersistentVector)
            (do
                (§ class APersistentVector)
            )
            :else
            (do
                (.getClass (:v this))
            )
        )
    )
)

(class-ns NilExpr (§ extends LiteralExpr)
    (defn #_"NilExpr" NilExpr'new []
        (LiteralExpr'new)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"NilExpr" this]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NilExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NilExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr (§ extends LiteralExpr)
    (defn- #_"BooleanExpr" BooleanExpr'init []
        (hash-map
            #_"boolean" :val false
        )
    )

    (defn #_"BooleanExpr" BooleanExpr'new [#_"boolean" ___val]
        (let [this (merge (LiteralExpr'new) (BooleanExpr'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BooleanExpr" this]
        (ß (:val this) ? RT'T :or RT'F)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"BooleanExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (:val this)
            (do
                (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE))
            )
            (do
                (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"BooleanExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"BooleanExpr" this]
        (§ class Boolean)
    )
)

(class-ns StringExpr (§ extends LiteralExpr)
    (defn- #_"StringExpr" StringExpr'init []
        (hash-map
            #_"String" :str nil
        )
    )

    (defn #_"StringExpr" StringExpr'new [#_"String" ___str]
        (let [this (merge (LiteralExpr'new) (StringExpr'init))]
            (§ ass (:str this) ___str)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"StringExpr" this]
        (:str this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StringExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (.push ___gen, (:str this))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StringExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StringExpr" this]
        (§ class String)
    )
)

#_closure
(class-ns MonitorEnterParser (§ implements IParser)
    (defn #_"MonitorEnterParser" MonitorEnterParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"MonitorEnterParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß MonitorEnterExpr'new(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorEnterExpr (§ extends UntypedExpr)
    (defn- #_"MonitorEnterExpr" MonitorEnterExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorEnterExpr" MonitorEnterExpr'new [#_"Expr" ___target]
        (let [this (merge (UntypedExpr'new) (MonitorEnterExpr'init))]
            (§ ass (:target this) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MonitorEnterExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.monitorEnter ___gen)
        (ß Compiler'NIL_EXPR.emit(___context, ___objx, ___gen))
        nil
    )
)

#_closure
(class-ns MonitorExitParser (§ implements IParser)
    (defn #_"MonitorExitParser" MonitorExitParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"MonitorExitParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß MonitorExitExpr'new(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorExitExpr (§ extends UntypedExpr)
    (defn- #_"MonitorExitExpr" MonitorExitExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorExitExpr" MonitorExitExpr'new [#_"Expr" ___target]
        (let [this (merge (UntypedExpr'new) (MonitorExitExpr'init))]
            (§ ass (:target this) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MonitorExitExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (.monitorExit ___gen)
        (ß Compiler'NIL_EXPR.emit(___context, ___objx, ___gen))
        nil
    )
)

(class-ns CatchClause
    (defn- #_"CatchClause" CatchClause'init []
        (hash-map
            #_"Class" :c nil
            #_"LocalBinding" :lb nil
            #_"Expr" :handler nil
            #_"Label" :label nil
            #_"Label" :endLabel nil
        )
    )

    (defn #_"CatchClause" CatchClause'new [#_"Class" ___c, #_"LocalBinding" ___lb, #_"Expr" ___handler]
        (let [this (CatchClause'init)]
            (§ ass (:c this) ___c)
            (§ ass (:lb this) ___lb)
            (§ ass (:handler this) ___handler)
            this
        )
    )
)

#_closure
(class-ns TryParser (§ implements IParser)
    (defn #_"TryParser" TryParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"TryParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß ___context != :Context'RETURN)
                (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )

            ;; (try try-expr* catch-expr* finally-expr?)
            ;; catch-expr: (catch class sym expr*)
            ;; finally-expr: (finally expr*)

            (let [#_"PersistentVector" ___body PersistentVector'EMPTY]
                (let [#_"PersistentVector" ___catches PersistentVector'EMPTY]
                    (let [#_"Expr" ___bodyExpr nil]
                        (let [#_"Expr" ___finallyExpr nil]
                            (let [#_"boolean" ___caught false]
                                (let [#_"int" ___retLocal (ß getAndIncLocalNum())]
                                    (let [#_"int" ___finallyLocal (ß getAndIncLocalNum())]
                                        (loop-when-recur [#_"ISeq" ___fs (next ___form)] (some? ___fs) [(next ___fs)]
                                            (let [#_"Object" ___f (first ___fs)]
                                                (let [#_"Object" ___op (ß (___f instanceof ISeq) ? (cast' ISeq ___f).first() :or nil)]
                                                    (if (and (not (Util'equals ___op, Compiler'CATCH)) (not (Util'equals ___op, Compiler'FINALLY)))
                                                        (do
                                                            (when ___caught
                                                                (throw (Util'runtimeException-1 "Only catch or finally clause can follow catch in try expression"))
                                                            )
                                                            (§ ass ___body (.cons ___body, ___f))
                                                        )
                                                        (do
                                                            (when (nil? ___bodyExpr)
                                                                (try
                                                                    (ß Var'pushThreadBindings(RT'map(
                                                                        (object-array [
                                                                            Compiler'NO_RECUR              true
                                                                            Compiler'METHOD_RETURN_CONTEXT nil
                                                                        ])
                                                                    )))
                                                                    (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___context, RT'seq(___body))))
                                                                    (finally
                                                                        (Var'popThreadBindings)
                                                                    )
                                                                )
                                                            )

                                                            (cond (Util'equals ___op, Compiler'CATCH)
                                                                (do
                                                                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___f), false))]
                                                                        (when (nil? ___c)
                                                                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (ß RT'second(___f)))))
                                                                        )
                                                                        (when (not (ß RT'third(___f) instanceof Symbol))
                                                                            (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (ß RT'third(___f)))))
                                                                        )
                                                                        (let [#_"Symbol" ___sym (ß (Symbol) RT'third(___f))]
                                                                            (when (ß (.getNamespace ___sym) != nil)
                                                                                (throw (Util'runtimeException-1 (str "Can't bind qualified name:" ___sym)))
                                                                            )

                                                                            (let [#_"IPersistentMap" ___dynamicBindings
                                                                                    (ß RT'map(
                                                                                        (object-array [
                                                                                            Compiler'LOCAL_ENV        Compiler'LOCAL_ENV.deref()
                                                                                            Compiler'NEXT_LOCAL_NUM   Compiler'NEXT_LOCAL_NUM.deref()
                                                                                            Compiler'IN_CATCH_FINALLY RT'T
                                                                                        ])
                                                                                    ))]
                                                                                (try
                                                                                    (Var'pushThreadBindings ___dynamicBindings)
                                                                                    (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___sym, (Symbol) ((RT'second(___f) instanceof Symbol) ? RT'second(___f) :or nil), nil, false))]
                                                                                        (let [#_"Expr" ___handler (ß (BodyParser'new()).parse(:Context'EXPRESSION, RT'next(RT'next(RT'next(___f)))))]
                                                                                            (§ ass ___catches (ß ___catches.cons(CatchClause'new(___c, ___lb, ___handler))))
                                                                                        )
                                                                                    )
                                                                                    (finally
                                                                                        (Var'popThreadBindings)
                                                                                    )
                                                                                )
                                                                                (§ ass ___caught true)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                :else ;; finally
                                                                (do
                                                                    (when (ß (next ___fs) != nil)
                                                                        (throw (Util'runtimeException-1 "finally clause must be last in try expression"))
                                                                    )
                                                                    (try
                                                                        (ß Var'pushThreadBindings(RT'map(
                                                                            (object-array [
                                                                                Compiler'IN_CATCH_FINALLY RT'T
                                                                            ])
                                                                        )))
                                                                        (§ ass ___finallyExpr (ß (BodyParser'new()).parse(:Context'STATEMENT, RT'next(___f))))
                                                                        (finally
                                                                            (Var'popThreadBindings)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (when (nil? ___bodyExpr)
                                            ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                            ;; return a body expr directly
                                            (try
                                                (ß Var'pushThreadBindings(RT'map(
                                                    (object-array [
                                                        Compiler'NO_RECUR true
                                                    ])
                                                )))
                                                (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___context, RT'seq(___body))))
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                            (§ return ___bodyExpr)
                                        )

                                        (TryExpr'new ___bodyExpr, ___catches, ___finallyExpr, ___retLocal, ___finallyLocal)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr (§ implements Expr)
    (defn- #_"TryExpr" TryExpr'init []
        (hash-map
            #_"Expr" :tryExpr nil
            #_"Expr" :finallyExpr nil
            #_"PersistentVector" :catchExprs nil
            #_"int" :retLocal 0
            #_"int" :finallyLocal 0
        )
    )

    (defn #_"TryExpr" TryExpr'new [#_"Expr" ___tryExpr, #_"PersistentVector" ___catchExprs, #_"Expr" ___finallyExpr, #_"int" ___retLocal, #_"int" ___finallyLocal]
        (let [this (TryExpr'init)]
            (§ ass (:tryExpr this) ___tryExpr)
            (§ ass (:catchExprs this) ___catchExprs)
            (§ ass (:finallyExpr this) ___finallyExpr)
            (§ ass (:retLocal this) ___retLocal)
            (§ ass (:finallyLocal this) ___finallyLocal)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"TryExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___startTry (.newLabel ___gen)]
            (let [#_"Label" ___endTry (.newLabel ___gen)]
                (let [#_"Label" ___end (.newLabel ___gen)]
                    (let [#_"Label" ___ret (.newLabel ___gen)]
                        (let [#_"Label" ___finallyLabel (.newLabel ___gen)]
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (§ ass (:label ___clause) (.newLabel ___gen))
                                    (§ ass (:endLabel ___clause) (.newLabel ___gen))
                                )
                            )

                            (.mark ___gen, ___startTry)
                            (ß (:tryExpr this).emit(___context, ___objx, ___gen))
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:retLocal this)))
                            )
                            (.mark ___gen, ___endTry)
                            (when (some? (:finallyExpr this))
                                (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                            )
                            (.goTo ___gen, ___ret)

                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (.mark ___gen, (:label ___clause))
                                    ;; exception should be on stack
                                    ;; put in clause local
                                    (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:lb ___clause))))
                                    (ß (:handler ___clause).emit(___context, ___objx, ___gen))
                                    (when (ß ___context != :Context'STATEMENT)
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:retLocal this)))
                                    )
                                    (.mark ___gen, (:endLabel ___clause))

                                    (when (some? (:finallyExpr this))
                                        (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                                    )
                                    (.goTo ___gen, ___ret)
                                )
                            )
                            (when (some? (:finallyExpr this))
                                (.mark ___gen, ___finallyLabel)
                                ;; exception should be on stack
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:finallyLocal this)))
                                (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:finallyLocal this)))
                                (.throwException ___gen)
                            )
                            (.mark ___gen, ___ret)
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:retLocal this)))
                            )
                            (.mark ___gen, ___end)
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (ß ___gen.visitTryCatchBlock(___startTry, ___endTry, (:label ___clause), (:c ___clause).getName().replace(\., \/)))
                                )
                            )
                            (when (some? (:finallyExpr this))
                                (.visitTryCatchBlock ___gen, ___startTry, ___endTry, ___finallyLabel, nil)
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                    (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                        (.visitTryCatchBlock ___gen, (:label ___clause), (:endLabel ___clause), ___finallyLabel, nil)
                                    )
                                )
                            )
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (ß ___gen.visitLocalVariable((:name (:lb ___clause)), "Ljava/lang/Object;", nil, (:label ___clause), (:endLabel ___clause), (:idx (:lb ___clause))))
                                )
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"TryExpr" this]
        (.hasJavaClass (:tryExpr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"TryExpr" this]
        (.getJavaClass (:tryExpr this))
    )
)

#_closure
(class-ns ThrowParser (§ implements IParser)
    (defn #_"ThrowParser" ThrowParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ThrowParser" this, #_"Context" ___context, #_"Object" ___form]
        (cond (ß ___context == :Context'EVAL)
            (do
                (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (ß RT'count(___form) == 1)
            (do
                (throw (Util'runtimeException-1 "Too few arguments to throw, throw expects a single Throwable instance"))
            )
            (ß RT'count(___form) > 2)
            (do
                (throw (Util'runtimeException-1 "Too many arguments to throw, throw expects a single Throwable instance"))
            )
        )
        (ß ThrowExpr'new(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns ThrowExpr (§ extends UntypedExpr)
    (defn- #_"ThrowExpr" ThrowExpr'init []
        (hash-map
            #_"Expr" :excExpr nil
        )
    )

    (defn #_"ThrowExpr" ThrowExpr'new [#_"Expr" ___excExpr]
        (let [this (merge (UntypedExpr'new) (ThrowExpr'init))]
            (§ ass (:excExpr this) ___excExpr)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ThrowExpr" this]
        (throw (Util'runtimeException-1 "Can't eval throw"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ThrowExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:excExpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(Compiler'THROWABLE_TYPE))
        (.throwException ___gen)
        nil
    )
)

#_closure
(class-ns NewParser (§ implements IParser)
    (defn #_"NewParser" NewParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"NewParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (ß Compiler'lineDeref())]
            (let [#_"int" ___column (ß Compiler'columnDeref())]
                (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
                    ;; (new Classname args...)
                    (when (ß (count ___form) < 2)
                        (throw (Util'runtimeException-1 "wrong number of arguments, expecting: (new Classname args...)"))
                    )
                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___form), false))]
                        (when (nil? ___c)
                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (ß RT'second(___form)))))
                        )
                        (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                            (loop-when-recur [#_"ISeq" ___s (ß RT'next(RT'next(___form)))] (some? ___s) [(next ___s)]
                                (§ ass ___args (ß ___args.cons(analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (first ___s)))))
                            )
                            (NewExpr'new ___c, ___args, ___line, ___column)
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr (§ implements Expr)
    (def #_"Method" NewExpr'invokeConstructorMethod (Method/getMethod "Object invokeConstructor(Class, Object[])"))
    (def #_"Method" NewExpr'forNameMethod (Method/getMethod "Class classForName(String)"))

    (defn- #_"NewExpr" NewExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"Constructor" :ctor nil
            #_"Class" :c nil
        )
    )

    (defn #_"NewExpr" NewExpr'new [#_"Class" ___c, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column]
        (let [this (NewExpr'init)]
            (§ ass (:args this) ___args)
            (§ ass (:c this) ___c)
            (let [#_"Constructor[]" ___allctors (.getConstructors ___c)]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                        (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allctors.length) [(inc ___i)]
                                (let [#_"Constructor" ___ctor (ß ___allctors[___i])]
                                    (when (ß (.getParameterTypes ___ctor).length == (count ___args))
                                        (.add ___ctors, ___ctor)
                                        (ß ___params.add((.getParameterTypes ___ctor)))
                                        (.add ___rets, ___c)
                                    )
                                )
                            )
                            (when (.isEmpty ___ctors)
                                (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                            )

                            (let [#_"int" ___ctoridx 0]
                                (when (ß (.size ___ctors) > 1)
                                    (§ ass ___ctoridx (ß getMatchingParams((.getName ___c), ___params, ___args, ___rets)))
                                )

                                (§ ass (:ctor this) (ß (___ctoridx >= 0) ? (Constructor) ___ctors.get(___ctoridx) :or nil))
                                (when (ß (:ctor this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column, (.getName ___c) ])))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"NewExpr" this]
        (let [#_"Object[]" ___argvals (make-array Object (count (:args this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass (ß ___argvals[___i]) (ß ((Expr) (:args this).nth(___i)).eval()))
            )
            (when (ß (:ctor this) != nil)
                (try
                    (§ return (ß (:ctor this).newInstance(Reflector'boxArgs((:ctor this).getParameterTypes(), ___argvals))))
                    (catch Exception ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
            (Reflector'invokeConstructor (:c this), ___argvals)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NewExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:ctor this) != nil)
            (do
                (let [#_"Type" ___type (ß getType((:c this)))]
                    (.newInstance ___gen, ___type)
                    (.dup ___gen)
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:ctor this).getParameterTypes(), (:args this)))
                    (ß ___gen.invokeConstructor(___type, (Method. "<init>", (Type/getConstructorDescriptor (:ctor this)))))
                )
            )
            (do
                (ß ___gen.push(destubClassName((:c this).getName())))
                (ß ___gen.invokeStatic(Compiler'RT_TYPE, NewExpr'forNameMethod))
                (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, invokeConstructorMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"NewExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"NewExpr" this]
        (:c this)
    )
)

(class-ns MetaExpr (§ implements Expr)
    (def #_"Type" MetaExpr'IOBJ_TYPE (ß Type/getType((§ class IObj))))
    (def #_"Method" MetaExpr'withMetaMethod (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

    (defn- #_"MetaExpr" MetaExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Expr" :meta nil
        )
    )

    (defn #_"MetaExpr" MetaExpr'new [#_"Expr" ___expr, #_"Expr" ___meta]
        (let [this (MetaExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MetaExpr" this]
        (ß ((IObj) (:expr this).eval()).withMeta((IPersistentMap) (:meta this).eval()))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MetaExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(MetaExpr'IOBJ_TYPE))
        (ß (:meta this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(Compiler'IPERSISTENTMAP_TYPE))
        (ß ___gen.invokeInterface(MetaExpr'IOBJ_TYPE, MetaExpr'withMetaMethod))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MetaExpr" this]
        (.hasJavaClass (:expr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MetaExpr" this]
        (.getJavaClass (:expr this))
    )
)

#_closure
(class-ns IfParser (§ implements IParser)
    (defn #_"IfParser" IfParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"IfParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (if test then) or (if test then else)
            (cond (ß (count ___form) > 4)
                (do
                    (throw (Util'runtimeException-1 "Too many arguments to if"))
                )
                (ß (count ___form) < 3)
                (do
                    (throw (Util'runtimeException-1 "Too few arguments to if"))
                )
            )
            (let [#_"PathNode" ___branch (ß PathNode'new(:PathType'BRANCH, (PathNode) Compiler'CLEAR_PATH.get()))]
                (let [#_"Expr" ___testexpr (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'second(___form)))]
                    (let [(ß Expr thenexpr, elseexpr)]
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'CLEAR_PATH PathNode'new(:PathType'PATH, ___branch)
                                ])
                            )))
                            (§ ass thenexpr (ß analyze(___context, RT'third(___form))))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'CLEAR_PATH PathNode'new(:PathType'PATH, ___branch)
                                ])
                            )))
                            (§ ass elseexpr (ß analyze(___context, RT'fourth(___form))))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                        (ß IfExpr'new(Compiler'lineDeref(), Compiler'columnDeref(), ___testexpr, thenexpr, elseexpr))
                    )
                )
            )
        )
    )
)

(class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"IfExpr" IfExpr'init []
        (hash-map
            #_"Expr" :testExpr nil
            #_"Expr" :thenExpr nil
            #_"Expr" :elseExpr nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"IfExpr" IfExpr'new [#_"int" ___line, #_"int" ___column, #_"Expr" ___testExpr, #_"Expr" ___thenExpr, #_"Expr" ___elseExpr]
        (let [this (IfExpr'init)]
            (§ ass (:testExpr this) ___testExpr)
            (§ ass (:thenExpr this) ___thenExpr)
            (§ ass (:elseExpr this) ___elseExpr)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"IfExpr" this]
        (let [#_"Object" ___t (.eval (:testExpr this))]
            (when (ß ___t != nil && ___t != Boolean/FALSE)
                (§ return (.eval (:thenExpr this)))
            )
            (.eval (:elseExpr this))
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___nullLabel (.newLabel ___gen)]
            (let [#_"Label" ___falseLabel (.newLabel ___gen)]
                (let [#_"Label" ___endLabel (.newLabel ___gen)]
                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

                    (cond (ß (:testExpr this) instanceof StaticMethodExpr && ((StaticMethodExpr)(:testExpr this)).canEmitIntrinsicPredicate())
                        (do
                            (ß ((StaticMethodExpr) (:testExpr this)).emitIntrinsicPredicate(:Context'EXPRESSION, ___objx, ___gen, ___falseLabel))
                        )
                        (ß maybePrimitiveType((:testExpr this)) == (§ class boolean))
                        (do
                            (ß ((MaybePrimitiveExpr) (:testExpr this)).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.ifZCmp(___gen.EQ, ___falseLabel))
                        )
                        :else
                        (do
                            (ß (:testExpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                            (.dup ___gen)
                            (.ifNull ___gen, ___nullLabel)
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
                            (.visitJumpInsn ___gen, Opcodes/IF_ACMPEQ, ___falseLabel)
                        )
                    )
                    (if ___emitUnboxed
                        (do
                            (ß ((MaybePrimitiveExpr)(:thenExpr this)).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (ß (:thenExpr this).emit(___context, ___objx, ___gen))
                        )
                    )
                    (.goTo ___gen, ___endLabel)
                    (.mark ___gen, ___nullLabel)
                    (.pop ___gen)
                    (.mark ___gen, ___falseLabel)
                    (if ___emitUnboxed
                        (do
                            (ß ((MaybePrimitiveExpr)(:elseExpr this)).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (ß (:elseExpr this).emit(___context, ___objx, ___gen))
                        )
                    )
                    (.mark ___gen, ___endLabel)
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"IfExpr" this]
        (ß (:thenExpr this).hasJavaClass()
            && (:elseExpr this).hasJavaClass()
            && ((:thenExpr this).getJavaClass() == (:elseExpr this).getJavaClass()
                || (:thenExpr this).getJavaClass() == Compiler'RECUR_CLASS
                || (:elseExpr this).getJavaClass() == Compiler'RECUR_CLASS
                || ((:thenExpr this).getJavaClass() == nil && (not (ß (:elseExpr this).getJavaClass().isPrimitive())))
                || ((:elseExpr this).getJavaClass() == nil && (not (ß (:thenExpr this).getJavaClass().isPrimitive())))))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"IfExpr" this]
        (try
            (ß (:thenExpr this) instanceof MaybePrimitiveExpr
                && (:elseExpr this) instanceof MaybePrimitiveExpr
                && ((:thenExpr this).getJavaClass() == (:elseExpr this).getJavaClass()
                        || (:thenExpr this).getJavaClass() == Compiler'RECUR_CLASS
                        || (:elseExpr this).getJavaClass() == Compiler'RECUR_CLASS)
                && ((MaybePrimitiveExpr)(:thenExpr this)).canEmitPrimitive()
                && ((MaybePrimitiveExpr)(:elseExpr this)).canEmitPrimitive())
            (catch Exception ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"IfExpr" this]
        (let [#_"Class" ___thenClass (.getJavaClass (:thenExpr this))]
            (when (ß ___thenClass != nil && ___thenClass != Compiler'RECUR_CLASS)
                (§ return ___thenClass)
            )
            (.getJavaClass (:elseExpr this))
        )
    )
)

(class-ns EmptyExpr (§ implements Expr)
    (def #_"Type" EmptyExpr'HASHMAP_TYPE (ß Type/getType((§ class PersistentArrayMap))))
    (def #_"Type" EmptyExpr'HASHSET_TYPE (ß Type/getType((§ class PersistentHashSet))))
    (def #_"Type" EmptyExpr'VECTOR_TYPE (ß Type/getType((§ class PersistentVector))))
    (def #_"Type" EmptyExpr'IVECTOR_TYPE (ß Type/getType((§ class IPersistentVector))))
    (def #_"Type" EmptyExpr'TUPLE_TYPE (ß Type/getType((§ class Tuple))))
    (def #_"Type" EmptyExpr'LIST_TYPE (ß Type/getType((§ class PersistentList))))
    (def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (ß Type/getType((§ class EmptyList))))

    (defn- #_"EmptyExpr" EmptyExpr'init []
        (hash-map
            #_"Object" :coll nil
        )
    )

    (defn #_"EmptyExpr" EmptyExpr'new [#_"Object" ___coll]
        (let [this (EmptyExpr'init)]
            (§ ass (:coll this) ___coll)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"EmptyExpr" this]
        (:coll this)
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"EmptyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (ß (:coll this) instanceof IPersistentList)
            (do
                (ß ___gen.getStatic(EmptyExpr'LIST_TYPE, "EMPTY", EmptyExpr'EMPTY_LIST_TYPE))
            )
            (ß (:coll this) instanceof IPersistentVector)
            (do
                (ß ___gen.getStatic(EmptyExpr'VECTOR_TYPE, "EMPTY", EmptyExpr'VECTOR_TYPE))
            )
            (ß (:coll this) instanceof IPersistentMap)
            (do
                (ß ___gen.getStatic(EmptyExpr'HASHMAP_TYPE, "EMPTY", EmptyExpr'HASHMAP_TYPE))
            )
            (ß (:coll this) instanceof IPersistentSet)
            (do
                (ß ___gen.getStatic(EmptyExpr'HASHSET_TYPE, "EMPTY", EmptyExpr'HASHSET_TYPE))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"EmptyExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"EmptyExpr" this]
        (cond (ß (:coll this) instanceof IPersistentList)
            (do
                (§ class IPersistentList)
            )
            (ß (:coll this) instanceof IPersistentVector)
            (do
                (§ class IPersistentVector)
            )
            (ß (:coll this) instanceof IPersistentMap)
            (do
                (§ class IPersistentMap)
            )
            (ß (:coll this) instanceof IPersistentSet)
            (do
                (§ class IPersistentSet)
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
    )
)

(class-ns ListExpr (§ implements Expr)
    (def #_"Method" ListExpr'arrayToListMethod (Method/getMethod "cloiure.lang.ISeq arrayToList(Object[])"))

    (defn- #_"ListExpr" ListExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"ListExpr" ListExpr'new [#_"IPersistentVector" ___args]
        (let [this (ListExpr'init)]
            (§ ass (:args this) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ListExpr" this]
        (let [#_"IPersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass ___ret (ß (IPersistentVector) ___ret.cons(((Expr) (:args this).nth(___i)).eval())))
            )
            (.seq ___ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ListExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
        (ß ___gen.invokeStatic(Compiler'RT_TYPE, ListExpr'arrayToListMethod))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ListExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ListExpr" this]
        (§ class IPersistentList)
    )
)

(class-ns MapExpr (§ implements Expr)
    (def #_"Method" MapExpr'mapMethod (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
    (def #_"Method" MapExpr'mapUniqueKeysMethod (Method/getMethod "cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

    (defn- #_"MapExpr" MapExpr'init []
        (hash-map
            #_"IPersistentVector" :keyvals nil
        )
    )

    (defn #_"MapExpr" MapExpr'new [#_"IPersistentVector" ___keyvals]
        (let [this (MapExpr'init)]
            (§ ass (:keyvals this) ___keyvals)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MapExpr" this]
        (let [#_"Object[]" ___ret (make-array Object (count (:keyvals this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals this).count()) [(inc ___i)]
                (§ ass (ß ___ret[___i]) (ß ((Expr) (:keyvals this).nth(___i)).eval()))
            )
            (RT'map ___ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MapExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___allKeysConstant true]
            (let [#_"boolean" ___allConstantKeysUnique true]
                (let [#_"IPersistentSet" ___constantKeys PersistentHashSet'EMPTY]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals this).count()) [(+ ___i 2)]
                        (let [#_"Expr" ___k (ß (Expr) (:keyvals this).nth(___i))]
                            (if (ß ___k instanceof LiteralExpr)
                                (do
                                    (let [#_"Object" ___kval (.eval ___k)]
                                        (if (.contains ___constantKeys, ___kval)
                                            (do
                                                (§ ass ___allConstantKeysUnique false)
                                            )
                                            (do
                                                (§ ass ___constantKeys (ß (IPersistentSet)___constantKeys.cons(___kval)))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (§ ass ___allKeysConstant false)
                                )
                            )
                        )
                    )
                    (MethodExpr'emitArgsAsArray (:keyvals this), ___objx, ___gen)
                    (if (ß (___allKeysConstant && ___allConstantKeysUnique) || ((:keyvals this).count() <= 2))
                        (do
                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, mapUniqueKeysMethod))
                        )
                        (do
                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, mapMethod))
                        )
                    )
                    (when (ß ___context == :Context'STATEMENT)
                        (.pop ___gen)
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MapExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MapExpr" this]
        (§ class IPersistentMap)
    )

    (defn #_"Expr" MapExpr'parse [#_"Context" ___context, #_"IPersistentMap" ___form]
        (let [#_"IPersistentVector" ___keyvals PersistentVector'EMPTY]
            (let [#_"boolean" ___keysConstant true]
                (let [#_"boolean" ___valsConstant true]
                    (let [#_"boolean" ___allConstantKeysUnique true]
                        (let [#_"IPersistentSet" ___constantKeys PersistentHashSet'EMPTY]
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(next ___s)]
                                (let [#_"IMapEntry" ___e (ß (IMapEntry) (first ___s))]
                                    (let [#_"Expr" ___k (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (.key ___e)))]
                                        (let [#_"Expr" ___v (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (.val ___e)))]
                                            (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___k)))
                                            (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___v)))
                                            (if (ß ___k instanceof LiteralExpr)
                                                (do
                                                    (let [#_"Object" ___kval (.eval ___k)]
                                                        (if (.contains ___constantKeys, ___kval)
                                                            (do
                                                                (§ ass ___allConstantKeysUnique false)
                                                            )
                                                            (do
                                                                (§ ass ___constantKeys (ß (IPersistentSet)___constantKeys.cons(___kval)))
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (§ ass ___keysConstant false)
                                                )
                                            )
                                            (when (not (ß ___v instanceof LiteralExpr))
                                                (§ ass ___valsConstant false)
                                            )
                                        )
                                    )
                                )
                            )

                            (let [#_"Expr" ___ret (MapExpr'new ___keyvals)]
                                (cond (ß ___form instanceof IObj && (cast' IObj ___form).meta() != nil)
                                    (do
                                        (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (cast' IObj ___form).meta())))
                                    )
                                    ___keysConstant
                                    (do
                                        ;; TBD: Add more detail to exception thrown below.
                                        (when (not ___allConstantKeysUnique)
                                            (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                                        )
                                        (if ___valsConstant
                                            (do
                                                (let [#_"IPersistentMap" ___m PersistentArrayMap'EMPTY]
                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (.length ___keyvals)) [(+ ___i 2)]
                                                        (§ ass ___m (ß ___m.assoc(((LiteralExpr)___keyvals.nth(___i)).val(), ((LiteralExpr)___keyvals.nth(___i + 1)).val())))
                                                    )
                                                    (ConstantExpr'new ___m)
                                                )
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                    :else
                                    (do
                                        ___ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns SetExpr (§ implements Expr)
    (def #_"Method" SetExpr'setMethod (Method/getMethod "cloiure.lang.IPersistentSet set(Object[])"))

    (defn- #_"SetExpr" SetExpr'init []
        (hash-map
            #_"IPersistentVector" :keys nil
        )
    )

    (defn #_"SetExpr" SetExpr'new [#_"IPersistentVector" ___keys]
        (let [this (SetExpr'init)]
            (§ ass (:keys this) ___keys)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"SetExpr" this]
        (let [#_"Object[]" ___ret (make-array Object (count (:keys this)))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keys this).count()) [(inc ___i)]
                (§ ass (ß ___ret[___i]) (ß ((Expr) (:keys this).nth(___i)).eval()))
            )
            (RT'set ___ret)
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"SetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (MethodExpr'emitArgsAsArray (:keys this), ___objx, ___gen)
        (ß ___gen.invokeStatic(Compiler'RT_TYPE, setMethod))
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"SetExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"SetExpr" this]
        (§ class IPersistentSet)
    )

    (defn #_"Expr" SetExpr'parse [#_"Context" ___context, #_"IPersistentSet" ___form]
        (let [#_"IPersistentVector" ___keys PersistentVector'EMPTY]
            (let [#_"boolean" ___constant true]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(next ___s)]
                    (let [#_"Object" ___e (first ___s)]
                        (let [#_"Expr" ___expr (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e))]
                            (§ ass ___keys (ß (IPersistentVector) ___keys.cons(___expr)))
                            (when (not (ß ___expr instanceof LiteralExpr))
                                (§ ass ___constant false)
                            )
                        )
                    )
                )
                (let [#_"Expr" ___ret (SetExpr'new ___keys)]
                    (cond (ß ___form instanceof IObj && (cast' IObj ___form).meta() != nil)
                        (do
                            (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (cast' IObj ___form).meta())))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentSet" ___set PersistentHashSet'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___keys)) [(inc ___i)]
                                    (let [#_"LiteralExpr" ___ve (ß (LiteralExpr)___keys.nth(___i))]
                                        (§ ass ___set (ß (IPersistentSet)___set.cons((.val ___ve))))
                                    )
                                )
                                (ConstantExpr'new ___set)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns VectorExpr (§ implements Expr)
    (def #_"Method" VectorExpr'vectorMethod (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))

    (defn- #_"VectorExpr" VectorExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"VectorExpr" VectorExpr'new [#_"IPersistentVector" ___args]
        (let [this (VectorExpr'init)]
            (§ ass (:args this) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"VectorExpr" this]
        (let [#_"IPersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass ___ret (ß (IPersistentVector) ___ret.cons(((Expr) (:args this).nth(___i)).eval())))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"VectorExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:args this).count() <= Tuple'MAX_SIZE)
            (do
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                    (ß ((Expr) (:args this).nth(___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___gen.invokeStatic(Compiler'TUPLE_TYPE, createTupleMethods[(:args this).count()]))
            )
            (do
                (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
                (ß ___gen.invokeStatic(Compiler'RT_TYPE, vectorMethod))
            )
        )

        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"VectorExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"VectorExpr" this]
        (§ class IPersistentVector)
    )

    (defn #_"Expr" VectorExpr'parse [#_"Context" ___context, #_"IPersistentVector" ___form]
        (let [#_"boolean" ___constant true]
            (let [#_"IPersistentVector" ___args PersistentVector'EMPTY]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___form)) [(inc ___i)]
                    (let [#_"Expr" ___v (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___form.nth(___i)))]
                        (§ ass ___args (ß (IPersistentVector) ___args.cons(___v)))
                        (when (not (ß ___v instanceof LiteralExpr))
                            (§ ass ___constant false)
                        )
                    )
                )
                (let [#_"Expr" ___ret (VectorExpr'new ___args)]
                    (cond (ß ___form instanceof IObj && (cast' IObj ___form).meta() != nil)
                        (do
                            (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, (cast' IObj ___form).meta())))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentVector" ___rv PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
                                    (let [#_"LiteralExpr" ___ve (ß (LiteralExpr)___args.nth(___i))]
                                        (§ ass ___rv (ß ___rv.cons((.val ___ve))))
                                    )
                                )
                                (ConstantExpr'new ___rv)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns KeywordInvokeExpr (§ implements Expr)
    (def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (ß Type/getType((§ class ILookup))))

    (defn- #_"KeywordInvokeExpr" KeywordInvokeExpr'init []
        (hash-map
            #_"KeywordExpr" :kw nil
            #_"Object" :tag nil
            #_"Expr" :target nil
            #_"int" :line 0
            #_"int" :column 0
            #_"int" :siteIndex 0
            #_"String" :source nil

            #_"Class" :jc nil
        )
    )

    (defn #_"KeywordInvokeExpr" KeywordInvokeExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"KeywordExpr" ___kw, #_"Expr" ___target]
        (let [this (KeywordInvokeExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:kw this) ___kw)
            (§ ass (:target this) ___target)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:siteIndex this) (ß registerKeywordCallsite((:k ___kw))))
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"KeywordInvokeExpr" this]
        (try
            (ß (:k (:kw this)).invoke((:target this).eval()))
            (catch Throwable ___e
                (if (not (ß ___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"KeywordInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___endLabel (.newLabel ___gen)]
            (let [#_"Label" ___faultLabel (.newLabel ___gen)]
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.getStatic((:objtype ___objx), ___objx.thunkNameStatic((:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE))
                (.dup ___gen) ;; thunk, thunk
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen)) ;; thunk, thunk, target
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.dupX2 ___gen) ;; target, thunk, thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; target, thunk, result
                (.dupX2 ___gen) ;; result, target, thunk, result
                (.visitJumpInsn ___gen, Opcodes/IF_ACMPEQ, ___faultLabel) ;; result, target
                (.pop ___gen) ;; result
                (.goTo ___gen, ___endLabel)

                (.mark ___gen, ___faultLabel) ;; result, target
                (.swap ___gen) ;; target, result
                (.pop ___gen) ;; target
                (.dup ___gen) ;; target, target
                (ß ___gen.getStatic((:objtype ___objx), ___objx.siteNameStatic((:siteIndex this)), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                (.swap ___gen) ;; target, site, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_SITE_TYPE, Method/getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                (.dup ___gen) ;; target, new-thunk, new-thunk
                (ß ___gen.putStatic((:objtype ___objx), ___objx.thunkNameStatic((:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                (.swap ___gen) ;; new-thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; result

                (.mark ___gen, ___endLabel)
                (when (ß ___context == :Context'STATEMENT)
                    (.pop ___gen)
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"KeywordInvokeExpr" this]
        (ß ((:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"KeywordInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )
)

(class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"InstanceOfExpr" InstanceOfExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Class" :c nil
        )
    )

    (defn #_"InstanceOfExpr" InstanceOfExpr'new [#_"Class" ___c, #_"Expr" ___expr]
        (let [this (InstanceOfExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InstanceOfExpr" this]
        (when (ß (:c this).isInstance((:expr this).eval()))
            (§ return RT'T)
        )
        RT'F
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.instanceOf(getType((:c this))))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitUnboxed this, ___context, ___objx, ___gen)
        (HostExpr'emitBoxReturn ___objx, ___gen, Boolean/TYPE)
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InstanceOfExpr" this]
        Boolean/TYPE
    )
)

(class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"StaticInvokeExpr" StaticInvokeExpr'init []
        (hash-map
            #_"Type" :target nil
            #_"Class" :retClass nil
            #_"Class[]" :paramclasses nil
            #_"Type[]" :paramtypes nil
            #_"IPersistentVector" :args nil
            #_"boolean" :variadic false
            #_"boolean" :tailPosition false
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticInvokeExpr" StaticInvokeExpr'new [#_"Type" ___target, #_"Class" ___retClass, #_"Class[]" ___paramclasses, #_"Type[]" ___paramtypes, #_"boolean" ___variadic, #_"IPersistentVector" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (let [this (StaticInvokeExpr'init)]
            (§ ass (:target this) ___target)
            (§ ass (:retClass this) ___retClass)
            (§ ass (:paramclasses this) ___paramclasses)
            (§ ass (:paramtypes this) ___paramtypes)
            (§ ass (:args this) ___args)
            (§ ass (:variadic this) ___variadic)
            (§ ass (:tailPosition this) ___tailPosition)
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitUnboxed this, ___context, ___objx, ___gen)
        (when (ß ___context != :Context'STATEMENT)
            (HostExpr'emitBoxReturn ___objx, ___gen, (:retClass this))
        )
        (when (ß ___context == :Context'STATEMENT)
            (if (ß (:retClass this) == (§ class long) || (:retClass this) == (§ class double))
                (do
                    (.pop2 ___gen)
                )
                (do
                    (.pop ___gen)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"StaticInvokeExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"StaticInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß retType(((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or nil, (:retClass this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"StaticInvokeExpr" this]
        (.isPrimitive (:retClass this))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Method" ___ms (Method. "invokeStatic", (.getReturnType this), (:paramtypes this))]
            (if (:variadic this)
                (do
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:paramclasses this).length - 1) [(inc ___i)]
                        (let [#_"Expr" ___e (ß (Expr) (:args this).nth(___i))]
                            (if (ß maybePrimitiveType(___e) == (:paramclasses this)[___i])
                                (do
                                    (ß (cast' MaybePrimitiveExpr ___e).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                                (do
                                    (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß HostExpr'emitUnboxArg(___objx, ___gen, (:paramclasses this)[___i]))
                                )
                            )
                        )
                    )
                    (let [#_"IPersistentVector" ___restArgs (ß RT'subvec((:args this), (:paramclasses this).length - 1, (:args this).count()))]
                        (MethodExpr'emitArgsAsArray ___restArgs, ___objx, ___gen)
                        (ß ___gen.invokeStatic(Type/getType((§ class ArraySeq)), Method/getMethod("cloiure.lang.ArraySeq create(Object[])")))
                    )
                )
                (do
                    (MethodExpr'emitTypedArgs ___objx, ___gen, (:paramclasses this), (:args this))
                )
            )

            (when (ß (:tailPosition this) && (not (:canBeDirect ___objx)))
                (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                    (.emitClearThis ___method, ___gen)
                )
            )

            (.invokeStatic ___gen, (:target this), ___ms)
            nil
        )
    )

    #_method
    (§ defn- #_"Type" (§ method getReturnType) [#_"StaticInvokeExpr" this]
        (Type/getType (:retClass this))
    )

    (defn #_"Expr" StaticInvokeExpr'parse [#_"Var" ___v, #_"ISeq" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (when (ß (not (ß ___v.isBound())) || (.get ___v) == nil)
            (§ return nil)
        )
        (let [#_"Class" ___c (.getClass (.get ___v))]
            (let [#_"String" ___cname (.getName ___c)]
                (let [#_"java.lang.reflect.Method[]" ___allmethods (.getMethods ___c)]
                    (let [#_"boolean" ___variadic false]
                        (let [#_"int" ___argcount (RT'count ___args)]
                            (let [#_"java.lang.reflect.Method" ___method nil]
                                (doseq [#_"java.lang.reflect.Method" ___m ___allmethods]
                                    (when (ß Modifier/isStatic((.getModifiers ___m)) && (.getName ___m).equals("invokeStatic"))
                                        (let [#_"Class[]" ___params (.getParameterTypes ___m)]
                                            (cond (ß ___argcount == ___params.length)
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic (ß (___argcount > 0 && ___params[___params.length - 1] == (§ class ISeq))))
                                                    (§ break )
                                                )
                                                (ß ___argcount > ___params.length && ___params.length > 0 && ___params[___params.length - 1] == (§ class ISeq))
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic true)
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                                (when (nil? ___method)
                                    (§ return nil)
                                )

                                (let [#_"Class" ___retClass (.getReturnType ___method)]
                                    (let [#_"Class[]" ___paramClasses (.getParameterTypes ___method)]
                                        (let [#_"Type[]" ___paramTypes (make-array Type (ß ___paramClasses.length))]
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___paramClasses.length) [(inc ___i)]
                                                (§ ass (ß ___paramTypes[___i]) (ß Type/getType(___paramClasses[___i])))
                                            )

                                            (let [#_"Type" ___target (§ unsure Type/getType ___c)]
                                                (let [#_"PersistentVector" ___argv PersistentVector'EMPTY]
                                                    (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(next ___s)]
                                                        (§ ass ___argv (ß ___argv.cons(analyze(:Context'EXPRESSION, (first ___s)))))
                                                    )

                                                    (StaticInvokeExpr'new ___target, ___retClass, ___paramClasses, ___paramTypes, ___variadic, ___argv, ___tag, ___tailPosition)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr (§ implements Expr)
    (§ def #_"Keyword" InvokeExpr'onKey (Keyword'intern-1 "on"))
    (§ def #_"Keyword" InvokeExpr'methodMapKey (Keyword'intern-1 "method-map"))

    (defn #_"Object" InvokeExpr'sigTag [#_"int" ___argcount, #_"Var" ___v]
        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
            (let [#_"Object" ___sigTag nil]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___arglists)] (some? ___s) [(next ___s)]
                    (let [#_"APersistentVector" ___sig (ß (APersistentVector) (first ___s))]
                        (let [#_"int" ___restOffset (ß ___sig.indexOf(Compiler'_AMP_))]
                            (when (ß ___argcount == (count ___sig) || (___restOffset > -1 && ___argcount >= ___restOffset))
                                (§ return (ß tagOf(___sig)))
                            )
                        )
                    )
                )
                nil
            )
        )
    )

    (defn- #_"InvokeExpr" InvokeExpr'init []
        (hash-map
            #_"Expr" :fexpr nil
            #_"Object" :tag nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :tailPosition false
            #_"String" :source nil

            #_"boolean" :isProtocol false
            #_"boolean" :isDirect false
            #_"int" :siteIndex -1
            #_"Class" :protocolOn nil
            #_"java.lang.reflect.Method" :onMethod nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InvokeExpr" InvokeExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___fexpr, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (InvokeExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:fexpr this) ___fexpr)
            (§ ass (:args this) ___args)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tailPosition this) ___tailPosition)

            (when (ß ___fexpr instanceof VarExpr)
                (let [#_"Var" ___fvar (:var (cast' VarExpr ___fexpr))]
                    (let [#_"Var" ___pvar (ß (Var)RT'get-2((.meta ___fvar), protocolKey))]
                        (when (ß ___pvar != nil && Compiler'PROTOCOL_CALLSITES.isBound())
                            (§ ass (:isProtocol this) true)
                            (§ ass (:siteIndex this) (ß registerProtocolCallsite((:var (cast' VarExpr ___fexpr)))))
                            (let [#_"Object" ___pon (ß RT'get-2((.get ___pvar), onKey))]
                                (§ ass (:protocolOn this) (HostExpr'maybeClass ___pon, false))
                                (when (ß (:protocolOn this) != nil)
                                    (let [#_"IPersistentMap" ___mmap (ß (IPersistentMap) RT'get-2((.get ___pvar), methodMapKey))]
                                        (let [#_"Keyword" ___mmapVal (ß (Keyword) ___mmap.valAt(Keyword'intern((:sym ___fvar))))]
                                            (when (nil? ___mmapVal)
                                                (throw (IllegalArgumentException. (str "No method of interface: " (.getName (:protocolOn this)) " found for function: " (:sym ___fvar) " of protocol: " (:sym ___pvar) " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" ___mname (ß munge((:sym ___mmapVal).toString()))]
                                                (let [#_"List" ___methods (ß Reflector'getMethods((:protocolOn this), (count ___args) - 1, ___mname, false))]
                                                    (when (ß (.size ___methods) != 1)
                                                        (throw (IllegalArgumentException. (str "No single method: " ___mname " of interface: " (.getName (:protocolOn this)) " found for function: " (:sym ___fvar) " of protocol: " (:sym ___pvar))))
                                                    )
                                                    (§ ass (:onMethod this) (ß (java.lang.reflect.Method) ___methods.get(0)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (some? ___tag)
                (do
                    (§ ass (:tag this) ___tag)
                )
                (ß ___fexpr instanceof VarExpr)
                (do
                    (let [#_"Var" ___v (:var (cast' VarExpr ___fexpr))]
                        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
                            (let [#_"Object" ___sigTag (ß ___sigTag((count ___args), ___v))]
                                (§ ass (:tag this) (ß (nil? ___sigTag) ? (:tag (cast' VarExpr ___fexpr)) :or ___sigTag))
                            )
                        )
                    )
                )
                :else
                (do
                    (§ ass (:tag this) nil)
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" ___fn (ß (IFn) (:fexpr this).eval())]
                (let [#_"PersistentVector" ___argvs PersistentVector'EMPTY]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                        (§ ass ___argvs (ß ___argvs.cons(((Expr) (:args this).nth(___i)).eval())))
                    )
                    (ß ___fn.applyTo(RT'seq(Util'ret1(___argvs, (§ ass ___argvs nil)))))
                )
            )
            (catch Throwable ___e
                (if (not (ß ___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (:isProtocol this)
            (do
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (.emitProto this, ___context, ___objx, ___gen)
            )
            (do
                (ß (:fexpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))
                (ß ___gen.checkCast(Compiler'IFN_TYPE))
                (.emitArgsAndCall this, 0, ___context, ___objx, ___gen)
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitProto) [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___onLabel (.newLabel ___gen)]
            (let [#_"Label" ___callLabel (.newLabel ___gen)]
                (let [#_"Label" ___endLabel (.newLabel ___gen)]
                    (let [#_"Var" ___v (:var (cast' VarExpr (:fexpr this)))]
                        (let [#_"Expr" ___e (ß (Expr) (:args this).nth(0))]
                            (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                            (.dup ___gen) ;; target, target
                            (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.getStatic((:objtype ___objx), ___objx.cachedClassName((:siteIndex this)), Compiler'CLASS_TYPE)) ;; target, class, cached-class
                            (.visitJumpInsn ___gen, Opcodes/IF_ACMPEQ, ___callLabel) ;; target
                            (when (some? (:protocolOn this))
                                (.dup ___gen) ;; target, target
                                (ß ___gen.instanceOf(Type/getType((:protocolOn this))))
                                (ß ___gen.ifZCmp(GeneratorAdapter/NE, ___onLabel))
                            )

                            (.dup ___gen) ;; target, target
                            (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.putStatic((:objtype ___objx), ___objx.cachedClassName((:siteIndex this)), Compiler'CLASS_TYPE)) ;; target

                            (.mark ___gen, ___callLabel) ;; target
                            (.emitVar ___objx, ___gen, ___v)
                            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, Method/getMethod("Object getRawRoot()"))) ;; target, proto-fn
                            (.swap ___gen)
                            (.emitArgsAndCall this, 1, ___context, ___objx, ___gen)
                            (.goTo ___gen, ___endLabel)

                            (.mark ___gen, ___onLabel) ;; target
                            (when (some? (:protocolOn this))
                                (ß ___gen.checkCast(Type/getType((:protocolOn this))))
                                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:onMethod this).getParameterTypes(), RT'subvec((:args this), 1, (:args this).count())))
                                (when (ß ___context == :Context'RETURN)
                                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                                        (.emitClearLocals ___method, ___gen)
                                    )
                                )
                                (let [#_"Method" ___m (Method. (.getName (:onMethod this)), (Type/getReturnType (:onMethod this)), (Type/getArgumentTypes (:onMethod this)))]
                                    (ß ___gen.invokeInterface(Type/getType((:protocolOn this)), ___m))
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, (:onMethod this).getReturnType()))
                                )
                            )
                            (.mark ___gen, ___endLabel)
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitArgsAndCall) [#_"InvokeExpr" this, #_"int" ___firstArgToEmit, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i ___firstArgToEmit] (ß ___i < Math/min(Compiler'MAX_POSITIONAL_ARITY, (:args this).count())) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) (:args this).nth(___i))]
                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        (when (ß (:args this).count() > Compiler'MAX_POSITIONAL_ARITY)
            (let [#_"PersistentVector" ___restArgs PersistentVector'EMPTY]
                (loop-when-recur [#_"int" ___i Compiler'MAX_POSITIONAL_ARITY] (ß ___i < (:args this).count()) [(inc ___i)]
                    (§ ass ___restArgs (ß ___restArgs.cons((:args this).nth(___i))))
                )
                (MethodExpr'emitArgsAsArray ___restArgs, ___objx, ___gen)
            )
        )
        (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

        (when (ß (:tailPosition this) && (not (:canBeDirect ___objx)))
            (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                (.emitClearThis ___method, ___gen)
            )
        )

        (ß ___gen.invokeInterface(Compiler'IFN_TYPE, (Method. "invoke", Compiler'OBJECT_TYPE, (ß Compiler'ARG_TYPES[Math/min(Compiler'MAX_POSITIONAL_ARITY + 1, (:args this).count())]))))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"InvokeExpr" this]
        (ß ((:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"InvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )

    (defn #_"Expr" InvokeExpr'parse [#_"Context" ___context, #_"ISeq" ___form]
        (let [#_"boolean" ___tailPosition (ß inTailCall(___context))]
            (when (ß ___context != :Context'EVAL)
                (§ ass ___context (ß :Context'EXPRESSION))
            )
            (let [#_"Expr" ___fexpr (ß analyze(___context, (first ___form)))]
                (when (ß ___fexpr instanceof VarExpr && (:var (cast' VarExpr ___fexpr)).equals(Compiler'INSTANCE) && RT'count(___form) == 3)
                    (let [#_"Expr" ___sexpr (ß analyze(:Context'EXPRESSION, RT'second(___form)))]
                        (when (ß ___sexpr instanceof ConstantExpr)
                            (let [#_"Object" ___val (ß (cast' ConstantExpr ___sexpr).val())]
                                (when (ß ___val instanceof Class)
                                    (§ return (ß InstanceOfExpr'new((Class) ___val, analyze(___context, RT'third(___form)))))
                                )
                            )
                        )
                    )
                )

                (when (ß RT'booleanCast-1o(Compiler'getCompilerOption(directLinkingKey)) && ___fexpr instanceof VarExpr && ___context != :Context'EVAL)
                    (let [#_"Var" ___v (:var (cast' VarExpr ___fexpr))]
                        (when (ß (not (ß ___v.isDynamic())) && (not (RT'booleanCast-1o (RT'get-3 (.meta ___v), redefKey, false))))
                            (let [#_"Symbol" ___formtag (ß tagOf(___form))]
                                (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
                                    (let [#_"int" ___arity (ß RT'count((next ___form)))]
                                        (let [#_"Object" ___sigtag (ß sigTag(___arity, ___v))]
                                            (let [#_"Object" ___vtag (ß RT'get-2(RT'meta(___v), RT'TAG_KEY))]
                                                (let [#_"Expr" ___ret (ß StaticInvokeExpr'parse(___v, RT'next(___form), (some? ___formtag) ? ___formtag :or (some? ___sigtag) ? ___sigtag :or ___vtag, ___tailPosition))]
                                                    (when (some? ___ret)
                                                        (§ return ___ret)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (ß ___fexpr instanceof VarExpr && ___context != :Context'EVAL)
                    (let [#_"Var" ___v (:var (cast' VarExpr ___fexpr))]
                        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
                            (let [#_"int" ___arity (ß RT'count((next ___form)))]
                                (loop-when-recur [#_"ISeq" ___s (RT'seq ___arglists)] (some? ___s) [(next ___s)]
                                    (let [#_"IPersistentVector" ___args (ß (IPersistentVector) (first ___s))]
                                        (when (ß (count ___args) == ___arity)
                                            (let [#_"String" ___primc (FnMethod'primInterface ___args)]
                                                (when (some? ___primc)
                                                    (§ return (ß analyze(___context, ((IObj)RT'listStar-3(Symbol'intern-1(".invokePrim"), ((Symbol) (first ___form)).withMeta(RT'map(RT'TAG_KEY, Symbol'intern-1(___primc))), (next ___form))).withMeta((IPersistentMap)RT'conj(RT'meta(___v), RT'meta(___form))))))
                                                )
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (ß ___fexpr instanceof KeywordExpr && RT'count(___form) == 2 && Compiler'KEYWORD_CALLSITES.isBound())
                    (let [#_"Expr" ___target (ß analyze(___context, RT'second(___form)))]
                        (§ return (ß KeywordInvokeExpr'new((String) Compiler'SOURCE.deref(), Compiler'lineDeref(), Compiler'columnDeref(), tagOf(___form), (KeywordExpr) ___fexpr, ___target)))
                    )
                )
                (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                    (loop-when-recur [#_"ISeq" ___s (ß RT'seq((next ___form)))] (some? ___s) [(next ___s)]
                        (§ ass ___args (ß ___args.cons(analyze(___context, (first ___s)))))
                    )

                    (ß InvokeExpr'new((String) Compiler'SOURCE.deref(), Compiler'lineDeref(), Compiler'columnDeref(), tagOf(___form), ___fexpr, ___args, ___tailPosition))
                )
            )
        )
    )
)

#_stateless
(class-ns SourceDebugExtensionAttribute (§ extends Attribute)
    (defn #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute'new []
        (Attribute'new "SourceDebugExtension")
    )

    #_method
    (§ defn #_"void" (§ method writeSMAP) [#_"SourceDebugExtensionAttribute" this, #_"ClassWriter" ___cw, #_"String" ___smap]
        (let [#_"ByteVector" ___bv (ß write(___cw, nil, -1, -1, -1))]
            (.putUTF8 ___bv, ___smap)
            nil
        )
    )
)

(class-ns FnExpr (§ extends ObjExpr)
    (def #_"Type" FnExpr'aFnType (ß Type/getType((§ class AFunction))))
    (def #_"Type" FnExpr'restFnType (ß Type/getType((§ class RestFn))))

    (defn- #_"FnExpr" FnExpr'init []
        (hash-map
            ;; if there is a variadic overload (there can only be one) it is stored here
            #_"FnMethod" :variadicMethod nil
            #_"IPersistentCollection" :methods nil
            #_"boolean" :hasPrimSigs false
            #_"boolean" :hasMeta false
            #_"boolean" :hasEnclosingMethod false

            #_"Class" :jc nil
        )
    )

    (defn #_"FnExpr" FnExpr'new [#_"Object" ___tag]
        (merge (ObjExpr'new ___tag) (FnExpr'init))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"FnExpr" this]
        true
    )

    #_method
    (§ defn #_"boolean" (§ method supportsMeta) [#_"FnExpr" this]
        (:hasMeta this)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"FnExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (§ class AFunction)))
        )
        (:jc this)
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"FnExpr" this, #_"ClassVisitor" ___cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [#_"ISeq" ___s (RT'seq (:methods this))] (some? ___s) [(next ___s)]
            (let [#_"ObjMethod" ___method (ß (ObjMethod) (first ___s))]
                (.emit ___method, this, ___cv)
            )
        )

        (when (.isVariadic this)
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, (Method/getMethod "int getRequiredArity()"), nil, nil, ___cv)]
                (.visitCode ___gen)
                (ß ___gen.push((:reqParms (:variadicMethod this)).count()))
                (.returnValue ___gen)
                (.endMethod ___gen)
            )
        )
        nil
    )

    (defn #_"Expr" FnExpr'parse [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"ISeq" ___origForm ___form]
            (let [#_"FnExpr" ___fn (ß FnExpr'new(tagOf(___form)))]
                (let [#_"Keyword" ___retkey (Keyword'intern-2 nil, "rettag")]
                    (let [#_"Object" ___rettag (ß RT'get-2(RT'meta(___form), ___retkey))]
                        (§ ass (:src ___fn) ___form)
                        (let [#_"ObjMethod" ___enclosingMethod (ß (ObjMethod) Compiler'METHOD.deref())]
                            (§ ass (:hasEnclosingMethod ___fn) (ß ___enclosingMethod != nil))
                            (when (ß ((IMeta) (first ___form)).meta() != nil)
                                (§ ass (:onceOnly ___fn) (ß RT'booleanCast-1o(RT'get-2(RT'meta((first ___form)), Keyword'intern-2(nil, "once")))))
                            )

                            (let [#_"String" ___basename (str (if (ß ___enclosingMethod != nil) (:name (:objx ___enclosingMethod)) (ß munge((:name (:name (.currentNS this)))))) "$")]
                                (let [#_"Symbol" ___nm nil]
                                    (if (ß RT'second(___form) instanceof Symbol)
                                        (do
                                            (§ ass ___nm (cast' Symbol (RT'second ___form)))
                                            (§ ass ___name (str (:name ___nm) "__" (RT'nextID)))
                                        )
                                        (do
                                            (cond (nil? ___name)
                                                (do
                                                    (§ ass ___name (str "fn__" (RT'nextID)))
                                                )
                                                (some? ___enclosingMethod)
                                                (do
                                                    (§ ass ___name (str ___name "__"(RT'nextID)))
                                                )
                                            )
                                        )
                                    )

                                    (let [#_"String" ___simpleName (ß munge(___name).replace(".", "_DOT_"))]
                                        (§ ass (:name ___fn) (+ ___basename ___simpleName))
                                        (§ ass (:internalName ___fn) (ß (:name ___fn).replace(\., \/)))
                                        (§ ass (:objtype ___fn) (ß Type/getObjectType((:internalName ___fn))))
                                        (let [#_"ArrayList<String>" ___prims (ArrayList.)]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (object-array [
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (ß emptyVarCallSites())
                                                        Compiler'NO_RECUR           nil
                                                    ])
                                                )))

                                                ;; arglist might be preceded by symbol naming this fn
                                                (when (some? ___nm)
                                                    (§ ass (:thisName ___fn) (:name ___nm))
                                                    (§ ass ___form (ß RT'cons(Compiler'FN, RT'next(RT'next(___form)))))
                                                )

                                                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                ;; turn former into latter
                                                (when (ß RT'second(___form) instanceof IPersistentVector)
                                                    (§ ass ___form (ß RT'list-2(Compiler'FN, RT'next(___form))))
                                                )
                                                (§ ass (:line ___fn) (ß Compiler'lineDeref()))
                                                (§ ass (:column ___fn) (ß Compiler'columnDeref()))
                                                (let [#_"FnMethod[]" ___methodArray (ß FnMethod'new[Compiler'MAX_POSITIONAL_ARITY + 1])]
                                                    (let [#_"FnMethod" ___variadicMethod nil]
                                                        (let [#_"boolean" ___usesThis false]
                                                            (loop-when-recur [#_"ISeq" ___s (RT'next ___form)] (some? ___s) [(RT'next ___s)]
                                                                (let [#_"FnMethod" ___f (ß FnMethod'parse(___fn, (ISeq) RT'first(___s), ___rettag))]
                                                                    (when (:usesThis ___f)
                                                                        (§ ass ___usesThis true)
                                                                    )
                                                                    (cond (.isVariadic ___f)
                                                                        (do
                                                                            (if (nil? ___variadicMethod)
                                                                                (do
                                                                                    (§ ass ___variadicMethod ___f)
                                                                                )
                                                                                (do
                                                                                    (throw (Util'runtimeException-1 "Can't have more than 1 variadic overload"))
                                                                                )
                                                                            )
                                                                        )
                                                                        (ß ___methodArray[(:reqParms ___f).count()] == nil)
                                                                        (do
                                                                            (§ ass (ß ___methodArray[(:reqParms ___f).count()]) ___f)
                                                                        )
                                                                        :else
                                                                        (do
                                                                            (throw (Util'runtimeException-1 "Can't have 2 overloads with same arity"))
                                                                        )
                                                                    )
                                                                    (when (ß (:prim ___f) != nil)
                                                                        (.add ___prims, (:prim ___f))
                                                                    )
                                                                )
                                                            )
                                                            (when (some? ___variadicMethod)
                                                                (loop-when-recur [#_"int" ___i (ß (:reqParms ___variadicMethod).count() + 1)] (ß ___i <= Compiler'MAX_POSITIONAL_ARITY) [(inc ___i)]
                                                                    (when (ß ___methodArray[___i] != nil)
                                                                        (throw (Util'runtimeException-1 "Can't have fixed arity function with more params than variadic function"))
                                                                    )
                                                                )
                                                            )

                                                            (§ ass (:canBeDirect ___fn) (ß (!(:hasEnclosingMethod ___fn) && (:closes ___fn).count() == 0 && (not ___usesThis))))

                                                            (let [#_"IPersistentCollection" ___methods nil]
                                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___methodArray.length) [(inc ___i)]
                                                                    (when (ß ___methodArray[___i] != nil)
                                                                        (§ ass ___methods (ß RT'conj(___methods, ___methodArray[___i])))
                                                                    )
                                                                )
                                                                (when (some? ___variadicMethod)
                                                                    (§ ass ___methods (RT'conj ___methods, ___variadicMethod))
                                                                )

                                                                (when (:canBeDirect ___fn)
                                                                    (doseq [#_"FnMethod" ___fm (ß (Collection<FnMethod>)___methods)]
                                                                        (when (ß (:locals ___fm) != nil)
                                                                            (doseq [#_"LocalBinding" ___lb (ß (Collection<LocalBinding>)RT'keys((:locals ___fm)))]
                                                                                (when (:isArg ___lb)
                                                                                    (§ ass (:idx ___lb) (ß (:idx ___lb) - 1))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )

                                                                (§ ass (:methods ___fn) ___methods)
                                                                (§ ass (:variadicMethod ___fn) ___variadicMethod)
                                                                (§ ass (:keywords ___fn) (ß (IPersistentMap) Compiler'KEYWORDS.deref()))
                                                                (§ ass (:vars ___fn) (ß (IPersistentMap) Compiler'VARS.deref()))
                                                                (§ ass (:constants ___fn) (ß (PersistentVector) Compiler'CONSTANTS.deref()))
                                                                (§ ass (:keywordCallsites ___fn) (ß (IPersistentVector) Compiler'KEYWORD_CALLSITES.deref()))
                                                                (§ ass (:protocolCallsites ___fn) (ß (IPersistentVector) Compiler'PROTOCOL_CALLSITES.deref()))
                                                                (§ ass (:varCallsites ___fn) (ß (IPersistentSet) Compiler'VAR_CALLSITES.deref()))

                                                                (§ ass (:constantsID ___fn) (RT'nextID))
                                                            )
                                                        )
                                                    )
                                                )
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                            (§ ass (:hasPrimSigs ___fn) (ß (.size ___prims) > 0))
                                            (let [#_"IPersistentMap" ___fmeta (RT'meta ___origForm)]
                                                (when (some? ___fmeta)
                                                    (§ ass ___fmeta (ß ___fmeta.without(RT'LINE_KEY).without(RT'COLUMN_KEY).without(RT'FILE_KEY).without(___retkey)))
                                                )

                                                (§ ass (:hasMeta ___fn) (ß RT'count(___fmeta) > 0))

                                                (try
                                                    (ß ___fn.compile((ß (.isVariadic ___fn) ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction"), (ß ((.size ___prims) == 0) ? nil :or (ß ___prims.toArray(.new String[(.size ___prims)]))), (:onceOnly ___fn)))
                                                    (catch IOException ___e
                                                        (throw (Util'sneakyThrow ___e))
                                                    )
                                                )
                                                (.getCompiledClass ___fn)

                                                (if (.supportsMeta ___fn)
                                                    (do
                                                        (ß MetaExpr'new(___fn, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___fmeta)))
                                                    )
                                                    (do
                                                        ___fn
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ObjMethod" (§ method variadicMethod) [#_"FnExpr" this]
        (:variadicMethod this)
    )

    #_method
    (§ defn #_"boolean" (§ method isVariadic) [#_"FnExpr" this]
        (ß ((:variadicMethod this) != nil))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method methods) [#_"FnExpr" this]
        (:methods this)
    )

    #_method
    (§ defn #_"void" (§ method emitForDefn) [#_"FnExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß this.emit(:Context'EXPRESSION, ___objx, ___gen))
        nil
    )
)

(class-ns ObjExpr (§ implements Expr)
    (def #_"String" ObjExpr'CONST_PREFIX "const__")

    (def #_"Method" ObjExpr'voidctor (Method/getMethod "void <init>()"))

    (def #_"Method" ObjExpr'kwintern (Method/getMethod "cloiure.lang.Keyword intern(String, String)"))
    (def #_"Method" ObjExpr'symintern (Method/getMethod "cloiure.lang.Symbol intern(String)"))
    (def #_"Method" ObjExpr'varintern (Method/getMethod "cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)"))

    (def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (ß Type/getType((§ class DynamicClassLoader))))
    (def #_"Method" ObjExpr'getClassMethod (Method/getMethod "Class getClass()"))
    (def #_"Method" ObjExpr'getClassLoaderMethod (Method/getMethod "ClassLoader getClassLoader()"))
    (def #_"Method" ObjExpr'getConstantsMethod (Method/getMethod "Object[] getConstants(int)"))
    (def #_"Method" ObjExpr'readStringMethod (Method/getMethod "Object readString(String)"))

    (def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (ß Type/getType((§ class ILookupSite))))
    (def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (ß Type/getType((§ class ILookupThunk))))
    (def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (ß Type/getType((§ class KeywordLookupSite))))

    (defn- #_"ObjExpr" ObjExpr'init []
        (hash-map
            #_"String" :name nil
            #_"String" :internalName nil
            #_"String" :thisName nil
            #_"Type" :objtype nil
            #_"Object" :tag nil
            ;; localbinding->itself
            #_"IPersistentMap" :closes PersistentHashMap'EMPTY
            ;; localbndingexprs
            #_"IPersistentVector" :closesExprs PersistentVector'EMPTY
            ;; symbols
            #_"IPersistentSet" :volatiles PersistentHashSet'EMPTY

            ;; symbol->lb
            #_"IPersistentMap" :fields nil

            ;; hinted fields
            #_"IPersistentVector" :hintedFields PersistentVector'EMPTY

            ;; Keyword->KeywordExpr
            #_"IPersistentMap" :keywords PersistentHashMap'EMPTY
            #_"IPersistentMap" :vars PersistentHashMap'EMPTY
            #_"Class" :compiledClass nil
            #_"int" :line 0
            #_"int" :column 0
            #_"PersistentVector" :constants nil
            #_"IPersistentSet" :usedConstants PersistentHashSet'EMPTY

            #_"int" :constantsID 0
            #_"int" :altCtorDrops 0

            #_"IPersistentVector" :keywordCallsites nil
            #_"IPersistentVector" :protocolCallsites nil
            #_"IPersistentSet" :varCallsites nil
            #_"boolean" :onceOnly false

            #_"Object" :src nil

            #_"IPersistentMap" :opts PersistentHashMap'EMPTY

            #_protected
            #_"IPersistentMap" :classMeta nil
            #_protected
            #_"boolean" :canBeDirect false

            #_"DynamicClassLoader" :loader nil
            #_"byte[]" :bytecode nil

            #_"Class" :jc nil
        )
    )

    (defn #_"ObjExpr" ObjExpr'new [#_"Object" ___tag]
        (let [this (ObjExpr'init)]
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method name) [#_"ObjExpr" this]
        (:name this)
    )

    #_method
    (§ defn #_"String" (§ method internalName) [#_"ObjExpr" this]
        (:internalName this)
    )

    #_method
    (§ defn #_"String" (§ method thisName) [#_"ObjExpr" this]
        (:thisName this)
    )

    #_method
    (§ defn #_"Type" (§ method objtype) [#_"ObjExpr" this]
        (:objtype this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method closes) [#_"ObjExpr" this]
        (:closes this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method keywords) [#_"ObjExpr" this]
        (:keywords this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method vars) [#_"ObjExpr" this]
        (:vars this)
    )

    #_method
    (§ defn #_"Class" (§ method compiledClass) [#_"ObjExpr" this]
        (:compiledClass this)
    )

    #_method
    (§ defn #_"int" (§ method line) [#_"ObjExpr" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" (§ method column) [#_"ObjExpr" this]
        (:column this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method constants) [#_"ObjExpr" this]
        (:constants this)
    )

    #_method
    (§ defn #_"int" (§ method constantsID) [#_"ObjExpr" this]
        (:constantsID this)
    )

    (defn #_"String" ObjExpr'trimGenID [#_"String" ___name]
        (let [#_"int" ___i (.lastIndexOf ___name, "__")]
            (ß (___i == -1) ? ___name :or (ß ___name.substring(0, ___i)))
        )
    )

    #_method
    (§ defn #_"Type[]" (§ method ctorTypes) [#_"ObjExpr" this]
        (let [#_"IPersistentVector" ___tv (ß (not (ß this.supportsMeta())) ? PersistentVector'EMPTY :or RT'vector(Compiler'IPERSISTENTMAP_TYPE))]
            (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(next ___s)]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___s))]
                    (if (ß (.getPrimitiveType ___lb) != nil)
                        (do
                            (§ ass ___tv (ß ___tv.cons(Type/getType((.getPrimitiveType ___lb)))))
                        )
                        (do
                            (§ ass ___tv (ß ___tv.cons(Compiler'OBJECT_TYPE)))
                        )
                    )
                )
            )
            (let [#_"Type[]" ___ret (make-array Type (count ___tv))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___tv)) [(inc ___i)]
                    (§ ass (ß ___ret[___i]) (ß (Type) ___tv.nth(___i)))
                )
                ___ret
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method compile) [#_"ObjExpr" this, #_"String" ___superName, #_"String[]" ___interfaceNames, #_"boolean" ___oneTimeUse] #_(§ throws IOException)
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" ___cv ___cw]
                (ß ___cv.visit(Opcodes/V1_5, Opcodes/ACC_PUBLIC + Opcodes/ACC_SUPER + Opcodes/ACC_FINAL, (:internalName this), nil, ___superName, ___interfaceNames))
                (let [#_"String" ___source (ß (String) Compiler'SOURCE.deref())]
                    (let [#_"int" ___lineBefore (ß (Integer) Compiler'LINE_BEFORE.deref())]
                        (let [#_"int" ___lineAfter (ß (Integer) Compiler'LINE_AFTER.deref() + 1)]
                            (let [#_"int" ___columnBefore (ß (Integer) Compiler'COLUMN_BEFORE.deref())]
                                (let [#_"int" ___columnAfter (ß (Integer) Compiler'COLUMN_AFTER.deref() + 1)]
                                    (when (ß ___source != nil && Compiler'SOURCE_PATH.deref() != nil)
                                        (let [#_"String" ___smap
                                                (str "SMAP\n"
                                                    (ß (___source.lastIndexOf(\.) > 0) ? (ß ___source.substring(0, ___source.lastIndexOf(\.))) :or ___source) ;; :or simpleName
                                                    ".java\n"
                                                    "Cloiure\n"
                                                    "*S Cloiure\n"
                                                    "*F\n"
                                                    "+ 1 " ___source "\n"
                                                    (ß (String) Compiler'SOURCE_PATH.deref()) "\n"
                                                    "*L\n"
                                                    (ß String/format("%d#1,%d:%d\n", (object-array [ ___lineBefore, (- ___lineAfter ___lineBefore), ___lineBefore ])))
                                                    "*E"
                                                )]
                                            (.visitSource ___cv, ___source, ___smap)
                                        )
                                    )
                                    (ß addAnnotation(___cv, (:classMeta this)))

                                    (when (.supportsMeta this)
                                        (ß ___cv.visitField(Opcodes/ACC_FINAL, "__meta", Compiler'IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                    )
                                    ;; instance fields for closed-overs
                                    (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(next ___s)]
                                        (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___s))]
                                            (if (.isDeftype this)
                                                (do
                                                    (let [#_"int" ___access (ß (ß this.isVolatile(___lb)) ? Opcodes/ACC_VOLATILE :or (ß (ß this.isMutable(___lb)) ? 0 :or (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL)))]
                                                        (§ let [#_"FieldVisitor" ___fv]
                                                            (if (ß (.getPrimitiveType ___lb) != nil)
                                                                (do
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, (:name ___lb), Type/getType((.getPrimitiveType ___lb)).getDescriptor(), nil, nil)))
                                                                )
                                                                (do
                                                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil)))
                                                                )
                                                            )
                                                            (ß addAnnotation(___fv, RT'meta((:sym ___lb))))
                                                        )
                                                    )
                                                )
                                                (do
                                                    ;; todo - only enable this non-private+writability for letfns where we need it
                                                    (if (ß (.getPrimitiveType ___lb) != nil)
                                                        (do
                                                            (ß ___cv.visitField(0 + (this.isVolatile(___lb) ? Opcodes/ACC_VOLATILE :or 0), (:name ___lb), Type/getType((.getPrimitiveType ___lb)).getDescriptor(), nil, nil))
                                                        )
                                                        (do
                                                            (ß ___cv.visitField(0, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )

                                    ;; static fields for callsites and thunks
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:protocolCallsites this).count()) [(inc ___i)]
                                        (ß ___cv.visitField(Opcodes/ACC_PRIVATE + Opcodes/ACC_STATIC, this.cachedClassName(___i), Compiler'CLASS_TYPE.getDescriptor(), nil, nil))
                                    )

                                    ;; ctor that takes closed-overs and inits base + fields
                                    (let [#_"Method" ___m (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))]
                                        (let [#_"GeneratorAdapter" ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, nil, ___cv)]
                                            (let [#_"Label" ___start (.newLabel ___ctorgen)]
                                                (let [#_"Label" ___end (.newLabel ___ctorgen)]
                                                    (.visitCode ___ctorgen)
                                                    (ß ___ctorgen.visitLineNumber((:line this), (.mark ___ctorgen)))
                                                    (.visitLabel ___ctorgen, ___start)
                                                    (.loadThis ___ctorgen)
                                                    (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))

                                                    (when (.supportsMeta this)
                                                        (.loadThis ___ctorgen)
                                                        (ß ___ctorgen.visitVarInsn(Compiler'IPERSISTENTMAP_TYPE.getOpcode(Opcodes/ILOAD), 1))
                                                        (ß ___ctorgen.putField((:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE))
                                                    )

                                                    (let [#_"int" ___a (ß (.supportsMeta this) ? 2 :or 1)]
                                                        (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this)) ___a ___a] (some? ___s) [(next ___s) (inc ___a)]
                                                            (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___s))]
                                                                (.loadThis ___ctorgen)
                                                                (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                                                    (if (some? ___primc)
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                                                                            (when (ß ___primc == Long/TYPE || ___primc == Double/TYPE)
                                                                                (§ ass ___a (inc ___a))
                                                                            )
                                                                        )
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                                                                        )
                                                                    )
                                                                    (§ ass (:closesExprs this) (ß (:closesExprs this).cons(LocalBindingExpr'new(___lb, nil))))
                                                                )
                                                            )
                                                        )

                                                        (.visitLabel ___ctorgen, ___end)

                                                        (.returnValue ___ctorgen)

                                                        (.endMethod ___ctorgen)

                                                        (when (> (:altCtorDrops this) 0)
                                                            ;; ctor that takes closed-overs and inits base + fields
                                                            (let [#_"Type[]" ___ctorTypes (ß ___ctorTypes())]
                                                                (let [#_"Type[]" ___altCtorTypes (make-array Type (ß ___ctorTypes.length - (:altCtorDrops this)))]
                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                                                        (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                                                    )
                                                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes)]
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (.visitCode ___ctorgen)
                                                                        (.loadThis ___ctorgen)
                                                                        (.loadArgs ___ctorgen)

                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __meta
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __extmap
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (.returnValue ___ctorgen)
                                                                        (.endMethod ___ctorgen)

                                                                        ;; alt ctor no __hash, __hasheq
                                                                        (§ ass ___altCtorTypes (make-array Type (ß ___ctorTypes.length - 2)))
                                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                                                            (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                                                        )

                                                                        (§ ass ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes))
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (.visitCode ___ctorgen)
                                                                        (.loadThis ___ctorgen)
                                                                        (.loadArgs ___ctorgen)

                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (.returnValue ___ctorgen)
                                                                        (.endMethod ___ctorgen)
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (when (.supportsMeta this)
                                                            ;; ctor that takes closed-overs but not meta
                                                            (let [#_"Type[]" ___ctorTypes (ß ___ctorTypes())]
                                                                (let [#_"Type[]" ___noMetaCtorTypes (make-array Type (ß ___ctorTypes.length - 1))]
                                                                    (loop-when-recur [#_"int" ___i 1] (ß ___i < ___ctorTypes.length) [(inc ___i)]
                                                                        (§ ass (ß ___noMetaCtorTypes[___i - 1]) (ß ___ctorTypes[___i]))
                                                                    )
                                                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___noMetaCtorTypes)]
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (.visitCode ___ctorgen)
                                                                        (.loadThis ___ctorgen)
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; nil meta
                                                                        (.loadArgs ___ctorgen)
                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (.returnValue ___ctorgen)
                                                                        (.endMethod ___ctorgen)

                                                                        ;; meta()
                                                                        (let [#_"Method" ___meth (Method/getMethod "cloiure.lang.IPersistentMap meta()")]
                                                                            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___meth, nil, nil, ___cv)]
                                                                                (.visitCode ___gen)
                                                                                (.loadThis ___gen)
                                                                                (ß ___gen.getField((:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE))

                                                                                (.returnValue ___gen)
                                                                                (.endMethod ___gen)

                                                                                ;; withMeta()
                                                                                (§ ass ___meth (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                                                                                (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___meth, nil, nil, ___cv))
                                                                                (.visitCode ___gen)
                                                                                (.newInstance ___gen, (:objtype this))
                                                                                (.dup ___gen)
                                                                                (.loadArg ___gen, 0)

                                                                                (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this)) ___a ___a] (some? ___s) [(next ___s) (inc ___a)]
                                                                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___s))]
                                                                                        (.loadThis ___gen)
                                                                                        (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                                                                            (if (some? ___primc)
                                                                                                (do
                                                                                                    (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                                                                                                )
                                                                                                (do
                                                                                                    (ß ___gen.getField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )

                                                                                (ß ___gen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))
                                                                                (.returnValue ___gen)
                                                                                (.endMethod ___gen)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (.emitStatics this, ___cv)
                                                        (.emitMethods this, ___cv)

                                                        ;; static fields for constants
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants this).count()) [(inc ___i)]
                                                            (when (ß (:usedConstants this).contains(___i))
                                                                (ß ___cv.visitField(Opcodes/ACC_PUBLIC + Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, this.constantName(___i), this.constantType(___i).getDescriptor(), nil, nil))
                                                            )
                                                        )

                                                        ;; static fields for lookup sites
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keywordCallsites this).count()) [(inc ___i)]
                                                            (ß ___cv.visitField(Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, this.siteNameStatic(___i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                            (ß ___cv.visitField(Opcodes/ACC_STATIC, this.thunkNameStatic(___i), ObjExpr'ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                        )

                                                        ;; static init for constants, keywords and vars
                                                        (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, ___cv)]
                                                            (.visitCode ___clinitgen)
                                                            (ß ___clinitgen.visitLineNumber((:line this), (.mark ___clinitgen)))

                                                            (when (ß (:constants this).count() > 0)
                                                                (.emitConstants this, ___clinitgen)
                                                            )

                                                            (when (ß (:keywordCallsites this).count() > 0)
                                                                (.emitKeywordCallsites this, ___clinitgen)
                                                            )

                                                            (when (ß (.isDeftype this) && RT'booleanCast-1o(RT'get-2((:opts this), loadNs)))
                                                                (let [#_"String" ___nsname (ß ((Symbol)RT'second((:src this))).getNamespace())]
                                                                    (when (not (ß ___nsname.equals("cloiure.core")))
                                                                        (.push ___clinitgen, "cloiure.core")
                                                                        (.push ___clinitgen, "require")
                                                                        (ß ___clinitgen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Var var(String, String)")))
                                                                        (ß ___clinitgen.invokeVirtual(Compiler'VAR_TYPE, Method/getMethod("Object getRawRoot()")))
                                                                        (ß ___clinitgen.checkCast(Compiler'IFN_TYPE))
                                                                        (.push ___clinitgen, ___nsname)
                                                                        (ß ___clinitgen.invokeStatic(Compiler'SYMBOL_TYPE, Method/getMethod("cloiure.lang.Symbol create(String)")))
                                                                        (ß ___clinitgen.invokeInterface(Compiler'IFN_TYPE, Method/getMethod("Object invoke(Object)")))
                                                                        (.pop ___clinitgen)
                                                                    )
                                                                )
                                                            )

                                                            (.returnValue ___clinitgen)

                                                            (.endMethod ___clinitgen)

                                                            ;; end of class
                                                            (.visitEnd ___cv)

                                                            (§ ass (:bytecode this) (.toByteArray ___cw))
                                                            (when (ß RT'booleanCast-1o(Compiler'COMPILE_FILES.deref()))
                                                                (ß writeClassFile((:internalName this), (:bytecode this)))
                                                            )
                                                            nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" (§ method emitKeywordCallsites) [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keywordCallsites this).count()) [(inc ___i)]
            (let [#_"Keyword" ___k (ß (Keyword) (:keywordCallsites this).nth(___i))]
                (ß ___clinitgen.newInstance(ObjExpr'KEYWORD_LOOKUPSITE_TYPE))
                (.dup ___clinitgen)
                (.emitValue this, ___k, ___clinitgen)
                (ß ___clinitgen.invokeConstructor(ObjExpr'KEYWORD_LOOKUPSITE_TYPE, Method/getMethod("void <init>(cloiure.lang.Keyword)")))
                (.dup ___clinitgen)
                (ß ___clinitgen.putStatic((:objtype this), this.siteNameStatic(___i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE))
                (ß ___clinitgen.putStatic((:objtype this), this.thunkNameStatic(___i), ObjExpr'ILOOKUP_THUNK_TYPE))
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitStatics) [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitListAsObjectArray) [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push((cast List ___value).size()))
        (ß ___gen.newArray(Compiler'OBJECT_TYPE))
        (loop-when-recur [#_"Iterator" ___it (ß (cast List ___value).iterator()) #_"int" ___i 0] (.hasNext ___it) [___it (inc ___i)]
            (.dup ___gen)
            (.push ___gen, ___i)
            (ß this.emitValue((next ___it), ___gen))
            (ß ___gen.arrayStore(Compiler'OBJECT_TYPE))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitValue) [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___partial true]
            (cond (nil? ___value)
                (do
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                )
                (ß ___value instanceof String)
                (do
                    (ß ___gen.push((cast String ___value)))
                )
                (ß ___value instanceof Boolean)
                (do
                    (if (ß (cast Boolean ___value).booleanValue())
                        (do
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE))
                        )
                        (do
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
                        )
                    )
                )
                (ß ___value instanceof Integer)
                (do
                    (ß ___gen.push((cast Integer ___value).intValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Integer)), Method/getMethod("Integer valueOf(int)")))
                )
                (ß ___value instanceof Long)
                (do
                    (ß ___gen.push((cast Long ___value).longValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Long)), Method/getMethod("Long valueOf(long)")))
                )
                (ß ___value instanceof Double)
                (do
                    (ß ___gen.push((cast Double ___value).doubleValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Double)), Method/getMethod("Double valueOf(double)")))
                )
                (ß ___value instanceof Character)
                (do
                    (ß ___gen.push((cast Character ___value).charValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Character)), Method/getMethod("Character valueOf(char)")))
                )
                (ß ___value instanceof Class)
                (do
                    (let [#_"Class" ___cc (ß (Class)___value)]
                        (if (.isPrimitive ___cc)
                            (do
                                (§ let [#_"Type" ___bt]
                                    (cond (ß ___cc == (§ class boolean))
                                        (do
                                            (§ ass ___bt (Type/getType Boolean))
                                        )
                                        (ß ___cc == (§ class byte))
                                        (do
                                            (§ ass ___bt (Type/getType Byte))
                                        )
                                        (ß ___cc == (§ class char))
                                        (do
                                            (§ ass ___bt (Type/getType Character))
                                        )
                                        (ß ___cc == (§ class double))
                                        (do
                                            (§ ass ___bt (Type/getType Double))
                                        )
                                        (ß ___cc == (§ class float))
                                        (do
                                            (§ ass ___bt (Type/getType Float))
                                        )
                                        (ß ___cc == (§ class int))
                                        (do
                                            (§ ass ___bt (Type/getType Integer))
                                        )
                                        (ß ___cc == (§ class long))
                                        (do
                                            (§ ass ___bt (Type/getType Long))
                                        )
                                        (ß ___cc == (§ class short))
                                        (do
                                            (§ ass ___bt (Type/getType Short))
                                        )
                                        :else
                                        (do
                                            (throw (Util'runtimeException-1 (str "Can't embed unknown primitive in code: " ___value)))
                                        )
                                    )
                                    (ß ___gen.getStatic(___bt, "TYPE", Type/getType((§ class Class))))
                                )
                            )
                            (do
                                (ß ___gen.push(destubClassName((.getName ___cc))))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("Class classForName(String)")))
                            )
                        )
                    )
                )
                (ß ___value instanceof Symbol)
                (do
                    (ß ___gen.push((:ns (cast' Symbol ___value))))
                    (ß ___gen.push((:name (cast' Symbol ___value))))
                    (ß ___gen.invokeStatic(Type/getType((§ class Symbol)), Method/getMethod("cloiure.lang.Symbol intern(String, String)")))
                )
                (ß ___value instanceof Keyword)
                (do
                    (ß ___gen.push((:ns (:sym (cast' Keyword ___value)))))
                    (ß ___gen.push((:name (:sym (cast' Keyword ___value)))))
                    (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Keyword keyword(String, String)")))
                )
                (ß ___value instanceof Var)
                (do
                    (let [#_"Var" ___var (ß (Var) ___value)]
                        (ß ___gen.push((:name (:ns ___var)).toString()))
                        (ß ___gen.push((:sym ___var).toString()))
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Var var(String, String)")))
                    )
                )
                (ß ___value instanceof IType)
                (do
                    (let [#_"Method" ___ctor (Method. "<init>", (Type/getConstructorDescriptor (ß (.getClass ___value).getConstructors()[0])))]
                        (ß ___gen.newInstance(Type/getType((.getClass ___value))))
                        (.dup ___gen)
                        (let [#_"IPersistentVector" ___fields (ß (IPersistentVector) Reflector'invokeStaticMethod-3c((.getClass ___value), "getBasis", (object-array 0)))]
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___fields)] (some? ___s) [(next ___s)]
                                (let [#_"Symbol" ___field (ß (Symbol) (first ___s))]
                                    (let [#_"Class" ___k (ß tagClass(tagOf(___field)))]
                                        (let [#_"Object" ___val (ß Reflector'getInstanceField(___value, munge((:name ___field))))]
                                            (.emitValue this, ___val, ___gen)

                                            (when (.isPrimitive ___k)
                                                (let [#_"Type" ___b (ß Type/getType(boxClass(___k)))]
                                                    (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                        (let [#_"String" ___n (.getName ___k)]
                                                            (ß ___gen.invokeVirtual(___b, (Method. (str ___n "Value"), (str "()" ___p))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeConstructor(Type/getType((.getClass ___value)), ___ctor))
                        )
                    )
                )
                (ß ___value instanceof IRecord)
                (do
                    (let [#_"Method" ___createMethod (Method/getMethod (str (ß (.getClass ___value).getName()) " create(cloiure.lang.IPersistentMap)"))]
                        (ß this.emitValue(PersistentArrayMap'create((java.util.Map) ___value), ___gen))
                        (ß ___gen.invokeStatic(getType((.getClass ___value)), ___createMethod))
                    )
                )
                (ß ___value instanceof IPersistentMap)
                (do
                    (let [#_"List" ___entries (ArrayList.)]
                        (doseq [#_"Map$Entry" ___entry (ß (Set<Map$Entry>) (cast Map ___value).entrySet())]
                            (ß ___entries.add((.getKey ___entry)))
                            (ß ___entries.add((.getValue ___entry)))
                        )
                        (.emitListAsObjectArray this, ___entries, ___gen)
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                    )
                )
                (ß ___value instanceof IPersistentVector)
                (do
                    (let [#_"IPersistentVector" ___args (ß (IPersistentVector) ___value)]
                        (if (ß (count ___args) <= Tuple'MAX_SIZE)
                            (do
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
                                    (ß this.emitValue(___args.nth(___i), ___gen))
                                )
                                (ß ___gen.invokeStatic(Compiler'TUPLE_TYPE, createTupleMethods[(count ___args)]))
                            )
                            (do
                                (.emitListAsObjectArray this, ___value, ___gen)
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                            )
                        )
                    )
                )
                (ß ___value instanceof PersistentHashSet)
                (do
                    (let [#_"ISeq" ___vs (RT'seq ___value)]
                        (if (nil? ___vs)
                            (do
                                (ß ___gen.getStatic(Type/getType((§ class PersistentHashSet)), "EMPTY", Type/getType((§ class PersistentHashSet))))
                            )
                            (do
                                (.emitListAsObjectArray this, ___vs, ___gen)
                                (ß ___gen.invokeStatic(Type/getType((§ class PersistentHashSet)), Method/getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                            )
                        )
                    )
                )
                (ß ___value instanceof ISeq || ___value instanceof IPersistentList)
                (do
                    (.emitListAsObjectArray this, ___value, ___gen)
                    (ß ___gen.invokeStatic(Type/getType((§ class java.util.Arrays)), Method/getMethod("java.util.List asList(Object[])")))
                    (ß ___gen.invokeStatic(Type/getType((§ class PersistentList)), Method/getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                )
                (ß ___value instanceof Pattern)
                (do
                    (ß this.emitValue((.toString ___value), ___gen))
                    (ß ___gen.invokeStatic(Type/getType((§ class Pattern)), Method/getMethod("java.util.regex.Pattern compile(String)")))
                )
                :else
                (do
                    (let [#_"String" ___cs nil]
                        (try
                            (§ ass ___cs (RT'printString ___value))
                            (catch Exception ___e
                                (throw (Util'runtimeException-1 (str "Can't embed object in code, maybe print-dup not defined: " ___value)))
                            )
                        )
                        (when (ß (.length ___cs) == 0)
                            (throw (Util'runtimeException-1 (str "Can't embed unreadable object in code: " ___value)))
                        )

                        (when (.startsWith ___cs, "#<")
                            (throw (Util'runtimeException-1 (str "Can't embed unreadable object in code: " ___cs)))
                        )

                        (.push ___gen, ___cs)
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, readStringMethod))
                        (§ ass ___partial false)
                    )
                )
            )

            (when ___partial
                (when (ß ___value instanceof IObj && RT'count((cast' IObj ___value).meta()) > 0)
                    (ß ___gen.checkCast(Compiler'IOBJ_TYPE))
                    (let [#_"Object" ___m (ß (cast' IObj ___value).meta())]
                        (ß this.emitValue(elideMeta(___m), ___gen))
                        (ß ___gen.checkCast(Compiler'IPERSISTENTMAP_TYPE))
                        (ß ___gen.invokeInterface(Compiler'IOBJ_TYPE, Method/getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                    )
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emitConstants) [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (try
            (ß Var'pushThreadBindings(RT'map(
                (object-array [
                    RT'PRINT_DUP RT'T
                ])
            )))

            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants this).count()) [(inc ___i)]
                (when (ß (:usedConstants this).contains(___i))
                    (ß this.emitValue((:constants this).nth(___i), ___clinitgen))
                    (ß ___clinitgen.checkCast(this.constantType(___i)))
                    (ß ___clinitgen.putStatic((:objtype this), this.constantName(___i), this.constantType(___i)))
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isMutable) [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (ß this.isVolatile(___lb) || RT'booleanCast-1o(RT'contains((:fields this), (:sym ___lb))) && RT'booleanCast-1o(RT'get-2((:sym ___lb).meta(), Keyword'intern-1("unsynchronized-mutable"))))
    )

    #_method
    (§ defn #_"boolean" (§ method isVolatile) [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (ß RT'booleanCast-1o(RT'contains((:fields this), (:sym ___lb))) && RT'booleanCast-1o(RT'get-2((:sym ___lb).meta(), Keyword'intern-1("volatile-mutable"))))
    )

    #_method
    (§ defn #_"boolean" (§ method isDeftype) [#_"ObjExpr" this]
        (ß ((:fields this) != nil))
    )

    #_method
    (§ defn #_"boolean" (§ method supportsMeta) [#_"ObjExpr" this]
        (not (ß this.isDeftype()))
    )

    #_method
    (§ defn #_"void" (§ method emitClearCloses) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Class" (§ method getCompiledClass) [#_"ObjExpr" this]
        (§ sync this
            (when (nil? (:compiledClass this))
                (§ ass (:loader this) (ß (DynamicClassLoader) Compiler'LOADER.deref()))
                (§ ass (:compiledClass this) (ß (:loader this).defineClass((:name this), (:bytecode this), (:src this))))
            )
            (:compiledClass this)
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"ObjExpr" this]
        (when (.isDeftype this)
            (§ return nil)
        )
        (try
            (.newInstance (.getCompiledClass this))
            (catch Exception ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitLetFnInits) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"IPersistentSet" ___letFnLocals]
        ;; objx arg is enclosing objx, not this
        (.checkCast ___gen, (:objtype this))

        (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(next ___s)]
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___s))]
                (when (.contains ___letFnLocals, ___lb)
                    (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                        (.dup ___gen)
                        (if (some? ___primc)
                            (do
                                (.emitUnboxedLocal ___objx, ___gen, ___lb)
                                (ß ___gen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                            )
                            (do
                                (.emitLocal ___objx, ___gen, ___lb, false)
                                (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
        )
        (.pop ___gen)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"ObjExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (if (.isDeftype this)
            (do
                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
            )
            (do
                (.newInstance ___gen, (:objtype this))
                (.dup ___gen)
                (when (.supportsMeta this)
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                )
                (loop-when-recur [#_"ISeq" ___s (RT'seq (:closesExprs this))] (some? ___s) [(next ___s)]
                    (let [#_"LocalBindingExpr" ___lbe (ß (LocalBindingExpr) (first ___s))]
                        (let [#_"LocalBinding" ___lb (:b ___lbe)]
                            (if (ß (.getPrimitiveType ___lb) != nil)
                                (do
                                    (.emitUnboxedLocal ___objx, ___gen, ___lb)
                                )
                                (do
                                    (.emitLocal ___objx, ___gen, ___lb, (:shouldClear ___lbe))
                                )
                            )
                        )
                    )
                )
                (ß ___gen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (.pop ___gen)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"ObjExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"ObjExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:compiledClass this) != nil) ? (:compiledClass this) :or ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (§ class IFn)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"void" (§ method emitAssignLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"Expr" ___val]
        (when (not (ß this.isMutable(___lb)))
            (throw (IllegalArgumentException. (str "Cannot assign to non-mutable: " (:name ___lb))))
        )
        (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
            (.loadThis ___gen)
            (if (some? ___primc)
                (do
                    (when (not (ß ___val instanceof MaybePrimitiveExpr && (cast' MaybePrimitiveExpr ___val).canEmitPrimitive()))
                        (throw (IllegalArgumentException. (str "Must assign primitive to primitive mutable: " (:name ___lb))))
                    )
                    (let [#_"MaybePrimitiveExpr" ___me (ß (MaybePrimitiveExpr) ___val)]
                        (ß ___me.emitUnboxed(:Context'EXPRESSION, this, ___gen))
                        (ß ___gen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                    )
                )
                (do
                    (ß ___val.emit(:Context'EXPRESSION, this, ___gen))
                    (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                )
            )
            nil
        )
    )

    #_method
    (§ defn- #_"void" (§ method emitLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"boolean" ___clear]
        (if (ß (:closes this).containsKey(___lb))
            (do
                (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                    (.loadThis ___gen)
                    (if (some? ___primc)
                        (do
                            (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                            (HostExpr'emitBoxReturn this, ___gen, ___primc)
                        )
                        (do
                            (ß ___gen.getField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            (when (ß (:onceOnly this) && ___clear && (:canBeCleared ___lb))
                                (.loadThis ___gen)
                                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
            (do
                (let [#_"int" ___argoff (ß (:canBeDirect this) ? 0 :or 1)]
                    (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                        (if (:isArg ___lb)
                            (do
                                (ß ___gen.loadArg(___lb.idx-argoff))
                                (cond (some? ___primc)
                                    (do
                                        (HostExpr'emitBoxReturn this, ___gen, ___primc)
                                    )
                                    (ß ___clear && (:canBeCleared ___lb))
                                    (do
                                        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                        (ß ___gen.storeArg((:idx ___lb) - ___argoff))
                                    )
                                )
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                                        (HostExpr'emitBoxReturn this, ___gen, ___primc)
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                                        (when (ß ___clear && (:canBeCleared ___lb))
                                            (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                            (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitUnboxedLocal) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb]
        (let [#_"int" ___argoff (ß (:canBeDirect this) ? 0 :or 1)]
            (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                (cond (ß (:closes this).containsKey(___lb))
                    (do
                        (.loadThis ___gen)
                        (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                    )
                    (:isArg ___lb)
                    (do
                        (ß ___gen.loadArg(___lb.idx-argoff))
                    )
                    :else
                    (do
                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                    )
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitVar) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___var]
        (let [#_"Integer" ___i (ß (Integer) (:vars this).valAt(___var))]
            (.emitConstant this, ___gen, ___i)
            nil
        )
    )

    (def #_"Method" ObjExpr'varGetMethod (Method/getMethod "Object get()"))
    (def #_"Method" ObjExpr'varGetRawMethod (Method/getMethod "Object getRawRoot()"))

    #_method
    (§ defn #_"void" (§ method emitVarValue) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___v]
        (let [#_"Integer" ___i (ß (Integer) (:vars this).valAt(___v))]
            (if (not (ß ___v.isDynamic()))
                (do
                    (.emitConstant this, ___gen, ___i)
                    (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, ObjExpr'varGetRawMethod))
                )
                (do
                    (.emitConstant this, ___gen, ___i)
                    (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, varGetMethod))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emitKeyword) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Keyword" ___k]
        (let [#_"Integer" ___i (ß (Integer) (:keywords this).valAt(___k))]
            (.emitConstant this, ___gen, ___i)
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emitConstant) [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"int" ___id]
        (§ ass (:usedConstants this) (ß (IPersistentSet) (:usedConstants this).cons(___id)))
        (ß ___gen.getStatic((:objtype this), this.constantName(___id), this.constantType(___id)))
        nil
    )

    #_method
    (§ defn #_"String" (§ method constantName) [#_"ObjExpr" this, #_"int" ___id]
        (str ObjExpr'CONST_PREFIX ___id)
    )

    #_method
    (§ defn #_"String" (§ method siteName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__site__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method siteNameStatic) [#_"ObjExpr" this, #_"int" ___n]
        (str (ß this.siteName(___n)) "__")
    )

    #_method
    (§ defn #_"String" (§ method thunkName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__thunk__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method cachedClassName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__cached_class__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method cachedVarName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__cached_var__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method varCallsiteName) [#_"ObjExpr" this, #_"int" ___n]
        (str "__var__callsite__" ___n)
    )

    #_method
    (§ defn #_"String" (§ method thunkNameStatic) [#_"ObjExpr" this, #_"int" ___n]
        (str (ß this.thunkName(___n)) "__")
    )

    #_method
    (§ defn #_"Type" (§ method constantType) [#_"ObjExpr" this, #_"int" ___id]
        (let [#_"Object" ___o (ß (:constants this).nth(___id))]
            (let [#_"Class" ___c (ß cloiure.lang.Util'classOf(___o))]
                (when (ß ___c != nil && Modifier/isPublic((.getModifiers ___c)))
                    ;; can't emit derived fn types due to visibility
                    (cond (ß (§ class LazySeq).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class ISeq))))
                        )
                        (ß ___c == (§ class Keyword))
                        (do
                            (§ return (ß Type/getType((§ class Keyword))))
                        )
                        (ß (§ class RestFn).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class RestFn))))
                        )
                        (ß (§ class AFn).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class AFn))))
                        )
                        (ß ___c == (§ class Var))
                        (do
                            (§ return (ß Type/getType((§ class Var))))
                        )
                        (ß ___c == (§ class String))
                        (do
                            (§ return (Type/getType String))
                        )
                    )
                )
                Compiler'OBJECT_TYPE
            )
        )
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (defn- #_"PathNode" PathNode'init []
        (hash-map
            #_"PathType" :type nil
            #_"PathNode" :parent nil
        )
    )

    (defn #_"PathNode" PathNode'new [#_"PathType" ___type, #_"PathNode" ___parent]
        (let [this (PathNode'init)]
            (§ ass (:type this) ___type)
            (§ ass (:parent this) ___parent)
            this
        )
    )
)

(def PState'enum-set
    (hash-set
        :PState'REQ
        :PState'REST
        :PState'DONE
    )
)

(class-ns FnMethod (§ extends ObjMethod)
    (defn- #_"FnMethod" FnMethod'init []
        (hash-map
            ;; localbinding->localbinding
            #_"PersistentVector" :reqParms PersistentVector'EMPTY
            #_"LocalBinding" :restParm nil
            #_"Type[]" :argtypes nil
            #_"Class[]" :argclasses nil
            #_"Class" :retClass nil
            #_"String" :prim nil
        )
    )

    (defn #_"FnMethod" FnMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (merge (ObjMethod'new ___objx, ___parent) (FnMethod'init))
    )

    (defn #_"char" FnMethod'classChar [#_"Object" ___x]
        (let [#_"Class" ___c nil]
            (cond (ß ___x instanceof Class)
                (do
                    (§ ass ___c (ß (Class) ___x))
                )
                (ß ___x instanceof Symbol)
                (do
                    (§ ass ___c (ß primClass((cast' Symbol ___x))))
                )
            )
            (when (ß ___c == nil || (not (ß ___c.isPrimitive())))
                (§ return \O)
            )
            (when (ß ___c == (§ class long))
                (§ return \L)
            )
            (when (ß ___c == (§ class double))
                (§ return \D)
            )
            (throw (IllegalArgumentException. "Only long and double primitives are supported"))
        )
    )

    (defn #_"String" FnMethod'primInterface [#_"IPersistentVector" ___arglist]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___arglist)) [(inc ___i)]
                (ß ___sb.append(classChar(tagOf(___arglist.nth(___i)))))
            )
            (ß ___sb.append(classChar(tagOf(___arglist))))
            (let [#_"String" ___ret (.toString ___sb)]
                (let [#_"boolean" ___prim (ß ___ret.contains("L") || ___ret.contains("D"))]
                    (when (ß ___prim && (count ___arglist) > 4)
                        (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    )
                    (when ___prim
                        (§ return (str "cloiure.lang.IFn$" ___ret))
                    )
                    nil
                )
            )
        )
    )

    (defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Object" ___rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" ___parms (ß (IPersistentVector) RT'first(___form))]
            (let [#_"ISeq" ___body (RT'next ___form)]
                (try
                    (let [#_"FnMethod" ___method (ß FnMethod'new(___objx, (ObjMethod) Compiler'METHOD.deref()))]
                        (§ ass (:line ___method) (ß Compiler'lineDeref()))
                        (§ ass (:column ___method) (ß Compiler'columnDeref()))
                        ;; register as the current method and set up a new env frame
                        (let [#_"PathNode" ___pnode (ß (PathNode) Compiler'CLEAR_PATH.get())]
                            (when (nil? ___pnode)
                                (§ ass ___pnode (ß PathNode'new(:PathType'PATH, nil)))
                            )
                            (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                (object-array [
                                    Compiler'METHOD                ___method
                                    Compiler'LOCAL_ENV             (deref Compiler'LOCAL_ENV)
                                    Compiler'LOOP_LOCALS           nil
                                    Compiler'NEXT_LOCAL_NUM        0
                                    Compiler'CLEAR_PATH            ___pnode
                                    Compiler'CLEAR_ROOT            ___pnode
                                    Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                    Compiler'METHOD_RETURN_CONTEXT RT'T
                                ])
                            )))

                            (§ ass (:prim ___method) (ß primInterface(___parms)))
                            (when (ß (:prim ___method) != nil)
                                (§ ass (:prim ___method) (ß (:prim ___method).replace(\., \/)))
                            )

                            (when (ß ___rettag instanceof String)
                                (§ ass ___rettag (ß Symbol'intern-2(nil, (String) ___rettag)))
                            )
                            (when (not (ß ___rettag instanceof Symbol))
                                (§ ass ___rettag nil)
                            )
                            (when (some? ___rettag)
                                (let [#_"String" ___retstr (ß (cast' Symbol ___rettag).getName())]
                                    (when (not (ß ___retstr.equals("long") || ___retstr.equals("double")))
                                        (§ ass ___rettag nil)
                                    )
                                )
                            )
                            (§ ass (:retClass ___method) (ß tagClass((tagOf(___parms) != nil) ? tagOf(___parms) :or ___rettag)))
                            (if (.isPrimitive (:retClass ___method))
                                (do
                                    (when (not (ß (:retClass ___method) == (§ class double) || (:retClass ___method) == (§ class long)))
                                        (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                    )
                                )
                                (do
                                    (§ ass (:retClass ___method) (§ class Object))
                                )
                            )
                            ;; register 'this' as local 0
                            (if (ß (:thisName ___objx) != nil)
                                (do
                                    (ß Compiler'registerLocal(Symbol'intern-1((:thisName ___objx)), nil, nil, false))
                                )
                                (do
                                    (ß getAndIncLocalNum())
                                )
                            )
                            (let [#_"PState" ___state (ß :PState'REQ)]
                                (let [#_"PersistentVector" ___argLocals PersistentVector'EMPTY]
                                    (let [#_"ArrayList<Type>" ___argtypes (ArrayList.)]
                                        (let [#_"ArrayList<Class>" ___argclasses (ArrayList.)]
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                (when (not (ß ___parms.nth(___i) instanceof Symbol))
                                                    (throw (IllegalArgumentException. "fn params must be Symbols"))
                                                )
                                                (let [#_"Symbol" ___p (ß (Symbol) ___parms.nth(___i))]
                                                    (when (ß (.getNamespace ___p) != nil)
                                                        (throw (Util'runtimeException-1 (str "Can't use qualified name as parameter: " ___p)))
                                                    )
                                                    (if (ß ___p.equals(Compiler'_AMP_))
                                                        (do
                                                            (if (ß ___state == :PState'REQ)
                                                                (do
                                                                    (§ ass ___state (ß :PState'REST))
                                                                )
                                                                (do
                                                                    (throw (Util'runtimeException-1 "Invalid parameter list"))
                                                                )
                                                            )
                                                        )
                                                        (do
                                                            (let [#_"Class" ___pc (ß primClass(tagClass(tagOf(___p))))]
                                                                (when (ß (.isPrimitive ___pc) && (not (ß ___pc == (§ class double) || ___pc == (§ class long))))
                                                                    (throw (IllegalArgumentException. (str "Only long and double primitives are supported: " ___p)))
                                                                )

                                                                (when (ß ___state == :PState'REST && tagOf(___p) != nil)
                                                                    (throw (Util'runtimeException-1 "& arg cannot have type hint"))
                                                                )
                                                                (when (ß ___state == :PState'REST && (:prim ___method) != nil)
                                                                    (throw (Util'runtimeException-1 "fns taking primitives cannot be variadic"))
                                                                )

                                                                (when (ß ___state == :PState'REST)
                                                                    (§ ass ___pc (§ class ISeq))
                                                                )
                                                                (ß ___argtypes.add(Type/getType(___pc)))
                                                                (.add ___argclasses, ___pc)
                                                                (let [#_"LocalBinding" ___lb (ß (.isPrimitive ___pc) ? Compiler'registerLocal(___p, nil, MethodParamExpr'new(___pc), true) :or Compiler'registerLocal(___p, (___state == :PState'REST) ? Compiler'ISEQ :or tagOf(___p), nil, true))]
                                                                    (§ ass ___argLocals (.cons ___argLocals, ___lb))
                                                                    (§ switch ___state
                                                                        (§ case :PState'REQ)
                                                                        (do
                                                                            (§ ass (:reqParms ___method) (ß (:reqParms ___method).cons(___lb)))
                                                                            (§ break )
                                                                        )
                                                                        (§ case :PState'REST)
                                                                        (do
                                                                            (§ ass (:restParm ___method) ___lb)
                                                                            (§ ass ___state (ß :PState'DONE))
                                                                            (§ break )
                                                                        )
                                                                        (§ default )
                                                                        (do
                                                                            (throw (Util'runtimeException-1 "Unexpected parameter"))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (when (ß (:reqParms ___method).count() > Compiler'MAX_POSITIONAL_ARITY)
                                                (throw (Util'runtimeException-1 (str "Can't specify more than " Compiler'MAX_POSITIONAL_ARITY " params")))
                                            )
                                            (ß Compiler'LOOP_LOCALS.set(___argLocals))
                                            (§ ass (:argLocals ___method) ___argLocals)
                                            (§ ass (:argtypes ___method) (ß ___argtypes.toArray(.new Type[(.size ___argtypes)])))
                                            (§ ass (:argclasses ___method) (ß ___argclasses.toArray(.new Class[(.size ___argtypes)])))
                                            (when (ß (:prim ___method) != nil)
                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argclasses ___method).length) [(inc ___i)]
                                                    (when (ß (:argclasses ___method)[___i] == (§ class long) || (:argclasses ___method)[___i] == (§ class double))
                                                        (ß getAndIncLocalNum())
                                                    )
                                                )
                                            )
                                            (§ ass (:body ___method) (ß (BodyParser'new()).parse(:Context'RETURN, ___body)))
                                            ___method
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (cond (:canBeDirect ___fn)
            (do
                (.doEmitStatic this, ___fn, ___cv)
            )
            (some? (:prim this))
            (do
                (.doEmitPrim this, ___fn, ___cv)
            )
            :else
            (do
                (.doEmit this, ___fn, ___cv)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmitStatic) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Type" ___returnType (Type/getType (:retClass this))]
            (let [#_"Method" ___ms (Method. "invokeStatic", ___returnType, (:argtypes this))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ___ms, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                    (.visitCode ___gen)
                    (let [#_"Label" ___loopLabel (.mark ___gen)]
                        (.visitLineNumber ___gen, (:line this), ___loopLabel)
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'LOOP_LABEL ___loopLabel
                                    Compiler'METHOD     this
                                ])
                            )))
                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))

                            (let [#_"Label" ___end (.mark ___gen)]
                                (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___lbs))]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argtypes this)[(:idx ___lb)].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue ___gen)
                        (.endMethod ___gen)

                        ;; generate the regular invoke, calling the static method
                        (let [#_"Method" ___m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv))
                            (.visitCode ___gen)
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argtypes this).length) [(inc ___i)]
                                (.loadArg ___gen, ___i)
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, (:argclasses this)[___i]))
                                (when (not (ß (:argclasses this)[___i].isPrimitive()))
                                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                    (.storeArg ___gen, ___i)
                                )
                            )
                            (let [#_"Label" ___callLabel (.mark ___gen)]
                                (.visitLineNumber ___gen, (:line this), ___callLabel)
                                (ß ___gen.invokeStatic((:objtype (:objx this)), ___ms))
                                (.box ___gen, ___returnType)

                                (.returnValue ___gen)
                                (.endMethod ___gen)

                                ;; generate primInvoke if prim
                                (when (some? (:prim this))
                                    (when (ß (:retClass this) == (§ class double) || (:retClass this) == (§ class long))
                                        (§ ass ___returnType (.getReturnType this))
                                    )
                                    (let [#_"else" ___returnType Compiler'OBJECT_TYPE]
                                        (let [#_"Method" ___pm (Method. "invokePrim", ___returnType, (:argtypes this))]
                                            ;; todo don't hardwire EXCEPTION_TYPES
                                            (§ ass ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ___pm, nil, Compiler'EXCEPTION_TYPES, ___cv))
                                            (.visitCode ___gen)
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argtypes this).length) [(inc ___i)]
                                                (.loadArg ___gen, ___i)
                                                (when (not (ß (:argclasses this)[___i].isPrimitive()))
                                                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                                    (.storeArg ___gen, ___i)
                                                )
                                            )
                                            (ß ___gen.invokeStatic((:objtype (:objx this)), ___ms))

                                            (.returnValue ___gen)
                                            (.endMethod ___gen)
                                        )
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method doEmitPrim) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (§ let [#_"Type" ___returnType]
            (if (ß (:retClass this) == (§ class double) || (:retClass this) == (§ class long))
                (do
                    (§ ass ___returnType (.getReturnType this))
                )
                (do
                    (§ ass ___returnType Compiler'OBJECT_TYPE)
                )
            )
            (let [#_"Method" ___ms (Method. "invokePrim", ___returnType, (:argtypes this))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ___ms, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                    (.visitCode ___gen)

                    (let [#_"Label" ___loopLabel (.mark ___gen)]
                        (.visitLineNumber ___gen, (:line this), ___loopLabel)
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (object-array [
                                    Compiler'LOOP_LABEL ___loopLabel
                                    Compiler'METHOD     this
                                ])
                            )))
                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))

                            (let [#_"Label" ___end (.mark ___gen)]
                                (.visitLocalVariable ___gen, "this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0)
                                (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___lbs))]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argtypes this)[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue ___gen)
                        (.endMethod ___gen)

                        ;; generate the regular invoke, calling the prim method
                        (let [#_"Method" ___m (Method. (.getMethodName this), Compiler'OBJECT_TYPE, (.getArgTypes this))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv))
                            (.visitCode ___gen)
                            (.loadThis ___gen)
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argtypes this).length) [(inc ___i)]
                                (.loadArg ___gen, ___i)
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, (:argclasses this)[___i]))
                            )
                            (.invokeInterface ___gen, (Type/getType (str "L" (:prim this) ";")), ___ms)
                            (ß ___gen.box((.getReturnType this)))

                            (.returnValue ___gen)
                            (.endMethod ___gen)
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                (.visitCode ___gen)

                (let [#_"Label" ___loopLabel (.mark ___gen)]
                    (.visitLineNumber ___gen, (:line this), ___loopLabel)
                    (try
                        (ß Var'pushThreadBindings(RT'map(
                            (object-array [
                                Compiler'LOOP_LABEL ___loopLabel
                                Compiler'METHOD     this
                            ])
                        )))

                        (ß (:body this).emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (.mark ___gen)]
                            (.visitLocalVariable ___gen, "this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0)
                            (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___lbs))]
                                    (.visitLocalVariable ___gen, (:name ___lb), "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx ___lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue ___gen)
                    (.endMethod ___gen)
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"PersistentVector" (§ method reqParms) [#_"FnMethod" this]
        (:reqParms this)
    )

    #_method
    (§ defn #_"LocalBinding" (§ method restParm) [#_"FnMethod" this]
        (:restParm this)
    )

    #_method
    (§ defn #_"boolean" (§ method isVariadic) [#_"FnMethod" this]
        (ß ((:restParm this) != nil))
    )

    #_method
    (§ defn #_"int" (§ method numParams) [#_"FnMethod" this]
        (ß (:reqParms this).count() + ((.isVariadic this) ? 1 :or 0))
    )

    #_method
    (§ defn #_"String" (§ method getMethodName) [#_"FnMethod" this]
        (ß (.isVariadic this) ? "doInvoke" :or "invoke")
    )

    #_method
    (§ defn #_"Type" (§ method getReturnType) [#_"FnMethod" this]
        (when (some? (:prim this)) ;; objx.isStatic
            (§ return (Type/getType (:retClass this)))
        )
        Compiler'OBJECT_TYPE
    )

    #_method
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"FnMethod" this]
        (when (ß (.isVariadic this) && (:reqParms this).count() == Compiler'MAX_POSITIONAL_ARITY)
            (let [#_"Type[]" ___ret (make-array Type (ß Compiler'MAX_POSITIONAL_ARITY + 1))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < Compiler'MAX_POSITIONAL_ARITY + 1) [(inc ___i)]
                    (§ ass (ß ___ret[___i]) Compiler'OBJECT_TYPE)
                )
                (§ return ___ret)
            )
        )
        (ß Compiler'ARG_TYPES[(.numParams this)])
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocals) [#_"FnMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )
)

#_abstract
(class-ns ObjMethod
    (defn- #_"ObjMethod" ObjMethod'init []
        (hash-map
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            #_"ObjMethod" :parent nil
            ;; localbinding->localbinding
            #_"IPersistentMap" :locals nil
            ;; num->localbinding
            #_"IPersistentMap" :indexlocals nil
            #_"Expr" :body nil
            #_"ObjExpr" :objx nil
            #_"PersistentVector" :argLocals nil
            #_"int" :maxLocal 0
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :usesThis false
            #_"PersistentHashSet" :localsUsedInCatchFinally PersistentHashSet'EMPTY
            #_protected
            #_"IPersistentMap" :methodMeta nil
        )
    )

    (defn #_"ObjMethod" ObjMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (let [this (ObjMethod'init)]
            (§ ass (:parent this) ___parent)
            (§ ass (:objx this) ___objx)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method locals) [#_"ObjMethod" this]
        (:locals this)
    )

    #_method
    (§ defn #_"Expr" (§ method body) [#_"ObjMethod" this]
        (:body this)
    )

    #_method
    (§ defn #_"ObjExpr" (§ method objx) [#_"ObjMethod" this]
        (:objx this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method argLocals) [#_"ObjMethod" this]
        (:argLocals this)
    )

    #_method
    (§ defn #_"int" (§ method maxLocal) [#_"ObjMethod" this]
        (:maxLocal this)
    )

    #_method
    (§ defn #_"int" (§ method line) [#_"ObjMethod" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" (§ method column) [#_"ObjMethod" this]
        (:column this)
    )

    (defn #_"void" ObjMethod'emitBody [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___retClass, #_"Expr" ___body]
        (let [#_"MaybePrimitiveExpr" ___be (ß (MaybePrimitiveExpr) ___body)]
            (if (ß Util'isPrimitive(___retClass) && (.canEmitPrimitive ___be))
                (do
                    (let [#_"Class" ___bc (ß maybePrimitiveType(___be))]
                        (cond (ß ___bc == ___retClass)
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                            )
                            (ß ___retClass == (§ class long) && ___bc == (§ class int))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (.visitInsn ___gen, Opcodes/I2L)
                            )
                            (ß ___retClass == (§ class double) && ___bc == (§ class float))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (.visitInsn ___gen, Opcodes/F2D)
                            )
                            (ß ___retClass == (§ class int) && ___bc == (§ class long))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                            )
                            (ß ___retClass == (§ class float) && ___bc == (§ class double))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (.visitInsn ___gen, Opcodes/D2F)
                            )
                            :else
                            (do
                                (throw (IllegalArgumentException. (str "Mismatched primitive return, expected: " ___retClass ", had: " (.getJavaClass ___be))))
                            )
                        )
                    )
                )
                (do
                    (ß ___body.emit(:Context'RETURN, ___objx, ___gen))
                    (if (ß ___retClass == (§ class void))
                        (do
                            (.pop ___gen)
                        )
                        (do
                            (ß ___gen.unbox(Type/getType(___retClass)))
                        )
                    )
                )
            )
            nil
        )
    )

    #_abstract
    (§ defn #_"int" (§ method numParams) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"String" (§ method getMethodName) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type" (§ method getReturnType) [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"ObjMethod" this])

    #_method
    (§ defn #_"void" (§ method emit) [#_"ObjMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                (.visitCode ___gen)

                (let [#_"Label" ___loopLabel (.mark ___gen)]
                    (.visitLineNumber ___gen, (:line this), ___loopLabel)
                    (try
                        (ß Var'pushThreadBindings(RT'map(
                            (object-array [
                                Compiler'LOOP_LABEL ___loopLabel
                                Compiler'METHOD     this
                            ])
                        )))

                        (ß (:body this).emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (.mark ___gen)]
                            (.visitLocalVariable ___gen, "this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0)
                            (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___lbs))]
                                    (.visitLocalVariable ___gen, (:name ___lb), "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx ___lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue ___gen)
                    (.endMethod ___gen)
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocals) [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearLocalsOld) [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argLocals this).count()) [(inc ___i)]
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) (:argLocals this).nth(___i))]
                (when (ß (not (ß (:localsUsedInCatchFinally this).contains((:idx ___lb)))) && (.getPrimitiveType ___lb) == nil)
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                    (ß ___gen.storeArg((:idx ___lb) - 1))
                )
            )
        )
        (loop-when-recur [#_"int" ___i (ß (.numParams this) + 1)] (ß ___i < (:maxLocal this) + 1) [(inc ___i)]
            (when (not (ß (:localsUsedInCatchFinally this).contains(___i)))
                (let [#_"LocalBinding" ___b (ß (LocalBinding) RT'get-2((:indexlocals this), ___i))]
                    (when (ß ___b == nil || maybePrimitiveType((:init ___b)) == nil)
                        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___i))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitClearThis) [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
        (ß ___gen.visitVarInsn(Opcodes/ASTORE, 0))
        nil
    )
)

(class-ns LocalBinding
    (defn- #_"LocalBinding" LocalBinding'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"Symbol" :tag nil
            #_"Expr" :init nil
            #_"int" :idx 0
            #_"String" :name nil
            #_"boolean" :isArg false
            #_"PathNode" :clearPathRoot nil
            #_"boolean" :canBeCleared (.not (RT'booleanCast-1o (Compiler'getCompilerOption Compiler'disableLocalsClearingKey)))
            #_"boolean" :recurMistmatch false
            #_"boolean" :used false

            #_"Boolean" :hjc nil

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBinding" LocalBinding'new [#_"int" ___num, #_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg, #_"PathNode" ___clearPathRoot]
        (let [this (LocalBinding'init)]
            (when (ß maybePrimitiveType(___init) != nil && ___tag != nil)
                (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
            )
            (§ ass (:idx this) ___num)
            (§ ass (:sym this) ___sym)
            (§ ass (:tag this) ___tag)
            (§ ass (:init this) ___init)
            (§ ass (:isArg this) ___isArg)
            (§ ass (:clearPathRoot this) ___clearPathRoot)
            (§ ass (:name this) (ß munge((:name ___sym))))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LocalBinding" this]
        (when (nil? (:hjc this))
            (if (ß ((:init this) != nil) && (:init this).hasJavaClass() && Util'isPrimitive((:init this).getJavaClass()) && (not (ß (:init this) instanceof MaybePrimitiveExpr)))
                (do
                    (§ ass (:hjc this) false)
                )
                (do
                    (§ ass (:hjc this) (ß ((:tag this) != nil || ((:init this) != nil && (:init this).hasJavaClass()))))
                )
            )
        )
        (:hjc this)
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LocalBinding" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (:init this).getJavaClass()))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Class" (§ method getPrimitiveType) [#_"LocalBinding" this]
        (ß maybePrimitiveType((:init this)))
    )
)

(class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
    (defn- #_"LocalBindingExpr" LocalBindingExpr'init []
        (hash-map
            #_"LocalBinding" :b nil
            #_"Symbol" :tag nil

            #_"PathNode" :clearPath nil
            #_"PathNode" :clearRoot nil
            #_"boolean" :shouldClear false

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBindingExpr" LocalBindingExpr'new [#_"LocalBinding" ___b, #_"Symbol" ___tag]
        (let [this (LocalBindingExpr'init)]
            (when (ß (.getPrimitiveType ___b) != nil && ___tag != nil)
                (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            )
            (§ ass (:b this) ___b)
            (§ ass (:tag this) ___tag)

            (§ ass (:clearPath this) (ß (PathNode)Compiler'CLEAR_PATH.get()))
            (§ ass (:clearRoot this) (ß (PathNode)Compiler'CLEAR_ROOT.get()))
            (let [#_"IPersistentCollection" ___sites (ß (IPersistentCollection) RT'get-2(Compiler'CLEAR_SITES.get(), ___b))]
                (§ ass (:used ___b) true)

                (when (ß (:idx ___b) > 0)
                    (when (some? ___sites)
                        (loop-when-recur [#_"ISeq" ___s (.seq ___sites)] (some? ___s) [(next ___s)]
                            (let [#_"LocalBindingExpr" ___o (ß (LocalBindingExpr) (first ___s))]
                                (let [#_"PathNode" ___common (ß commonPath((:clearPath this), (:clearPath ___o)))]
                                    (when (ß ___common != nil && (:type ___common) == :PathType'PATH)
                                        (§ ass (:shouldClear ___o) false)
                                    )
                                )
                            )
                        )
                    )

                    (when (ß (:clearRoot this) == (:clearPathRoot ___b))
                        (§ ass (:shouldClear this) true)
                        (§ ass ___sites (RT'conj ___sites, this))
                        (ß Compiler'CLEAR_SITES.set(RT'assoc(Compiler'CLEAR_SITES.get(), ___b, ___sites)))
                    )
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"LocalBindingExpr" this]
        (ß ((:b this).getPrimitiveType() != nil))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emitUnboxedLocal ___objx, ___gen, (:b this))
        nil
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (.emitLocal ___objx, ___gen, (:b this), (:shouldClear this))
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method evalAssign) [#_"LocalBindingExpr" this, #_"Expr" ___val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"void" (§ method emitAssign) [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (.emitAssignLocal ___objx, ___gen, (:b this), ___val)
        (when (ß ___context != :Context'STATEMENT)
            (.emitLocal ___objx, ___gen, (:b this), false)
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LocalBindingExpr" this]
        (ß ((:tag this) != nil || (:b this).hasJavaClass()))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LocalBindingExpr" this]
        (when (nil? (:jc this))
            (if (some? (:tag this))
                (do
                    (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
                )
                (do
                    (§ ass (:jc this) (.getJavaClass (:b this)))
                )
            )
        )
        (:jc this)
    )
)

#_closure
(class-ns BodyParser (§ implements IParser)
    (defn #_"BodyParser" BodyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"BodyParser" this, #_"Context" ___context, #_"Object" ___frms]
        (let [#_"ISeq" ___forms (ß (ISeq) ___frms)]
            (when (ß Util'equals(RT'first(___forms), Compiler'DO))
                (§ ass ___forms (RT'next ___forms))
            )
            (let [#_"PersistentVector" ___exprs PersistentVector'EMPTY]
                (loop-when-recur [___forms ___forms] (some? ___forms) [(next ___forms)]
                    (let [#_"Expr" ___e (ß (___context != :Context'EVAL && (___context == :Context'STATEMENT || (next ___forms) != nil)) ? analyze(:Context'STATEMENT, (first ___forms)) :or analyze(___context, (first ___forms)))]
                        (§ ass ___exprs (.cons ___exprs, ___e))
                    )
                )
                (when (ß (count ___exprs) == 0)
                    (§ ass ___exprs (ß ___exprs.cons(Compiler'NIL_EXPR)))
                )
                (BodyExpr'new ___exprs)
            )
        )
    )
)

(class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"BodyExpr" BodyExpr'init []
        (hash-map
            #_"PersistentVector" :exprs nil
        )
    )

    (defn #_"BodyExpr" BodyExpr'new [#_"PersistentVector" ___exprs]
        (let [this (BodyExpr'init)]
            (§ ass (:exprs this) ___exprs)
            this
        )
    )

    #_method
    (§ defn #_"PersistentVector" (§ method exprs) [#_"BodyExpr" this]
        (:exprs this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"BodyExpr" this]
        (let [#_"Object" ___ret nil]
            (doseq [#_"Object" ___o (:exprs this)]
                (let [#_"Expr" ___e (ß (Expr) ___o)]
                    (§ ass ___ret (.eval ___e))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"BodyExpr" this]
        (ß ((.lastExpr this) instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)this.lastExpr()).canEmitPrimitive()))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exprs this).count() - 1) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) (:exprs this).nth(___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"MaybePrimitiveExpr" ___last (ß (MaybePrimitiveExpr) (:exprs this).nth((:exprs this).count() - 1))]
            (.emitUnboxed ___last, ___context, ___objx, ___gen)
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exprs this).count() - 1) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) (:exprs this).nth(___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"Expr" ___last (ß (Expr) (:exprs this).nth((:exprs this).count() - 1))]
            (.emit ___last, ___context, ___objx, ___gen)
            nil
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"BodyExpr" this]
        (.hasJavaClass (.lastExpr this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"BodyExpr" this]
        (.getJavaClass (.lastExpr this))
    )

    #_method
    (§ defn- #_"Expr" (§ method lastExpr) [#_"BodyExpr" this]
        (ß (Expr) (:exprs this).nth((:exprs this).count() - 1))
    )
)

(class-ns BindingInit
    (defn- #_"BindingInit" BindingInit'init []
        (hash-map
            #_"LocalBinding" :binding nil
            #_"Expr" :init nil
        )
    )

    (defn #_"BindingInit" BindingInit'new [#_"LocalBinding" ___binding, #_"Expr" ___init]
        (let [this (BindingInit'init)]
            (§ ass (:binding this) ___binding)
            (§ ass (:init this) ___init)
            this
        )
    )

    #_method
    (§ defn #_"LocalBinding" (§ method binding) [#_"BindingInit" this]
        (:binding this)
    )

    #_method
    (§ defn #_"Expr" (§ method init) [#_"BindingInit" this]
        (:init this)
    )
)

#_closure
(class-ns LetFnParser (§ implements IParser)
    (defn #_"LetFnParser" LetFnParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"LetFnParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (letfns* [var (fn [args] body) ...] body...)
            (when (not (ß RT'second(___form) instanceof IPersistentVector))
                (throw (IllegalArgumentException. "Bad binding form, expected vector"))
            )

            (let [#_"IPersistentVector" ___bindings (ß (IPersistentVector) RT'second(___form))]
                (when (ß ((count ___bindings) % 2) != 0)
                    (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                )

                (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                    (when (ß ___context == :Context'EVAL)
                        (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
                    )

                    (let [#_"IPersistentMap" ___dynamicBindings
                            (ß RT'map(
                                (object-array [
                                    Compiler'LOCAL_ENV      Compiler'LOCAL_ENV.deref()
                                    Compiler'NEXT_LOCAL_NUM Compiler'NEXT_LOCAL_NUM.deref()
                                ])
                            ))]
                        (try
                            (Var'pushThreadBindings ___dynamicBindings)

                            ;; pre-seed env (like Lisp labels)
                            (let [#_"PersistentVector" ___lbs PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings)) [(+ ___i 2)]
                                    (when (not (ß ___bindings.nth(___i) instanceof Symbol))
                                        (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth ___bindings, ___i))))
                                    )
                                    (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                        (when (ß (.getNamespace ___sym) != nil)
                                            (throw (Util'runtimeException-1 (str "Can't let qualified name: " ___sym)))
                                        )
                                        (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___sym, tagOf(___sym), nil, false))]
                                            (§ ass (:canBeCleared ___lb) false)
                                            (§ ass ___lbs (.cons ___lbs, ___lb))
                                        )
                                    )
                                )
                                (let [#_"PersistentVector" ___bindingInits PersistentVector'EMPTY]
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings)) [(+ ___i 2)]
                                        (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                            (let [#_"Expr" ___init (ß analyze(:Context'EXPRESSION, ___bindings.nth(___i + 1), (:name ___sym)))]
                                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.nth(___i / 2))]
                                                    (§ ass (:init ___lb) ___init)
                                                    (let [#_"BindingInit" ___bi (BindingInit'new ___lb, ___init)]
                                                        (§ ass ___bindingInits (.cons ___bindingInits, ___bi))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß LetFnExpr'new(___bindingInits, (BodyParser'new()).parse(___context, ___body)))
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr (§ implements Expr)
    (defn- #_"LetFnExpr" LetFnExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
        )
    )

    (defn #_"LetFnExpr" LetFnExpr'new [#_"PersistentVector" ___bindingInits, #_"Expr" ___body]
        (let [this (LetFnExpr'init)]
            (§ ass (:bindingInits this) ___bindingInits)
            (§ ass (:body this) ___body)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LetFnExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
            (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
            )
        )

        (let [#_"IPersistentSet" ___lbset PersistentHashSet'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                    (§ ass ___lbset (ß (IPersistentSet) ___lbset.cons((:binding ___bi))))
                    (ß (:init ___bi).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
                )
            )

            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                    (let [#_"ObjExpr" ___fe (ß (ObjExpr) (:init ___bi))]
                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:idx (:binding ___bi))))
                        (.emitLetFnInits ___fe, ___gen, ___objx, ___lbset)
                    )
                )
            )

            (let [#_"Label" ___loopLabel (.mark ___gen)]
                (ß (:body this).emit(___context, ___objx, ___gen))

                (let [#_"Label" ___end (.mark ___gen)]
                    (loop-when-recur [#_"ISeq" ___bis (.seq (:bindingInits this))] (some? ___bis) [(next ___bis)]
                        (let [#_"BindingInit" ___bi (ß (BindingInit) (first ___bis))]
                            (let [#_"String" ___lname (:name (:binding ___bi))]
                                (when (.endsWith ___lname, "__auto__")
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (ß maybePrimitiveType((:init ___bi)))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___loopLabel, ___end, (:idx (:binding ___bi))))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx (:binding ___bi))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LetFnExpr" this]
        (.hasJavaClass (:body this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LetFnExpr" this]
        (.getJavaClass (:body this))
    )
)

#_closure
(class-ns LetParser (§ implements IParser)
    (defn #_"LetParser" LetParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"LetParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (let [var val var2 val2 ...] body...)
            (let [#_"boolean" ___isLoop (ß RT'first(___form).equals(Compiler'LOOP))]
                (when (not (ß RT'second(___form) instanceof IPersistentVector))
                    (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                )

                (let [#_"IPersistentVector" ___bindings (ß (IPersistentVector) RT'second(___form))]
                    (when (ß ((count ___bindings) % 2) != 0)
                        (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                    )

                    (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                        (when (ß ___context == :Context'EVAL || (___context == :Context'EXPRESSION && ___isLoop))
                            (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
                        )

                        (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                            (let [#_"IPersistentMap" ___backupMethodLocals (:locals ___method)]
                                (let [#_"IPersistentMap" ___backupMethodIndexLocals (:indexlocals ___method)]
                                    (let [#_"IPersistentVector" ___recurMismatches PersistentVector'EMPTY]
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings) / 2) [(inc ___i)]
                                            (§ ass ___recurMismatches (ß ___recurMismatches.cons(RT'F)))
                                        )

                                        ;; may repeat once for each binding with a mismatch, return breaks
                                        (while true
                                            (let [#_"IPersistentMap" ___dynamicBindings
                                                    (ß RT'map(
                                                        (object-array [
                                                            Compiler'LOCAL_ENV      Compiler'LOCAL_ENV.deref()
                                                            Compiler'NEXT_LOCAL_NUM Compiler'NEXT_LOCAL_NUM.deref()
                                                        ])
                                                    ))]
                                                (§ ass (:locals ___method) ___backupMethodLocals)
                                                (§ ass (:indexlocals ___method) ___backupMethodIndexLocals)

                                                (let [#_"PathNode" ___looproot (ß PathNode'new(:PathType'PATH, (PathNode) Compiler'CLEAR_PATH.get()))]
                                                    (let [#_"PathNode" ___clearroot (ß PathNode'new(:PathType'PATH, ___looproot))]
                                                        (let [#_"PathNode" ___clearpath (ß PathNode'new(:PathType'PATH, ___looproot))]
                                                            (when ___isLoop
                                                                (§ ass ___dynamicBindings (ß ___dynamicBindings.assoc(Compiler'LOOP_LOCALS, nil)))
                                                            )

                                                            (try
                                                                (Var'pushThreadBindings ___dynamicBindings)

                                                                (let [#_"PersistentVector" ___bindingInits PersistentVector'EMPTY]
                                                                    (let [#_"PersistentVector" ___loopLocals PersistentVector'EMPTY]
                                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___bindings)) [(+ ___i 2)]
                                                                            (when (not (ß ___bindings.nth(___i) instanceof Symbol))
                                                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (.nth ___bindings, ___i))))
                                                                            )
                                                                            (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                                                                (when (ß (.getNamespace ___sym) != nil)
                                                                                    (throw (Util'runtimeException-1 (str "Can't let qualified name: " ___sym)))
                                                                                )
                                                                                (let [#_"Expr" ___init (ß analyze(:Context'EXPRESSION, ___bindings.nth(___i + 1), (:name ___sym)))]
                                                                                    (when ___isLoop
                                                                                        (cond (ß ___recurMismatches != nil && RT'booleanCast-1o(___recurMismatches.nth(___i / 2)))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "box", RT'vector(___init), false)))
                                                                                                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                                                                                    (.println (RT'errPrintWriter), (str "Auto-boxing loop arg: " ___sym))
                                                                                                )
                                                                                            )
                                                                                            (ß maybePrimitiveType(___init) == (§ class int))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "longCast", RT'vector(___init), false)))
                                                                                            )
                                                                                            (ß maybePrimitiveType(___init) == (§ class float))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "doubleCast", RT'vector(___init), false)))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                    ;; sequential enhancement of env (like Lisp let*)
                                                                                    (try
                                                                                        (when ___isLoop
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (object-array [
                                                                                                    Compiler'CLEAR_PATH ___clearpath
                                                                                                    Compiler'CLEAR_ROOT ___clearroot
                                                                                                    Compiler'NO_RECUR   nil
                                                                                                ])
                                                                                            )))
                                                                                        )
                                                                                        (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___sym, tagOf(___sym), ___init, false))]
                                                                                            (let [#_"BindingInit" ___bi (BindingInit'new ___lb, ___init)]
                                                                                                (§ ass ___bindingInits (.cons ___bindingInits, ___bi))
                                                                                                (when ___isLoop
                                                                                                    (§ ass ___loopLocals (.cons ___loopLocals, ___lb))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (finally
                                                                                            (when ___isLoop
                                                                                                (Var'popThreadBindings)
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (when ___isLoop
                                                                            (ß Compiler'LOOP_LOCALS.set(___loopLocals))
                                                                        )
                                                                        (§ let [#_"Expr" ___bodyExpr]
                                                                            (let [#_"boolean" ___moreMismatches false]
                                                                                (try
                                                                                    (when ___isLoop
                                                                                        (let [#_"Object" ___methodReturnContext (ß (___context == :Context'RETURN) ? Compiler'METHOD_RETURN_CONTEXT.deref() :or nil)]
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (object-array [
                                                                                                    Compiler'CLEAR_PATH            ___clearpath
                                                                                                    Compiler'CLEAR_ROOT            ___clearroot
                                                                                                    Compiler'NO_RECUR              nil
                                                                                                    Compiler'METHOD_RETURN_CONTEXT ___methodReturnContext
                                                                                                ])
                                                                                            )))
                                                                                        )
                                                                                    )
                                                                                    (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___isLoop ? :Context'RETURN :or ___context, ___body)))
                                                                                    (finally
                                                                                        (when ___isLoop
                                                                                            (Var'popThreadBindings)
                                                                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___loopLocals)) [(inc ___i)]
                                                                                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___loopLocals.nth(___i))]
                                                                                                    (when (:recurMistmatch ___lb)
                                                                                                        (§ ass ___recurMismatches (ß (IPersistentVector)___recurMismatches.assoc(___i, RT'T)))
                                                                                                        (§ ass ___moreMismatches true)
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when (not ___moreMismatches)
                                                                                    (§ return (LetExpr'new ___bindingInits, ___bodyExpr, ___isLoop))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (finally
                                                                    (Var'popThreadBindings)
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"LetExpr" LetExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
            #_"boolean" :isLoop false
        )
    )

    (defn #_"LetExpr" LetExpr'new [#_"PersistentVector" ___bindingInits, #_"Expr" ___body, #_"boolean" ___isLoop]
        (let [this (LetExpr'init)]
            (§ ass (:bindingInits this) ___bindingInits)
            (§ ass (:body this) ___body)
            (§ ass (:isLoop this) ___isLoop)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" ___bindingLabels (HashMap.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                    (let [#_"Class" ___primc (ß maybePrimitiveType((:init ___bi)))]
                        (if (some? ___primc)
                            (do
                                (ß ((MaybePrimitiveExpr) (:init ___bi)).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
                            )
                            (do
                                (ß (:init ___bi).emit(:Context'EXPRESSION, ___objx, ___gen))
                                (if (and (not (:used (:binding ___bi))) (:canBeCleared (:binding ___bi)))
                                    (do
                                        (.pop ___gen)
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx (:binding ___bi))))
                                    )
                                )
                            )
                        )
                        (ß ___bindingLabels.put(___bi, (.mark ___gen)))
                    )
                )
            )
            (let [#_"Label" ___loopLabel (.mark ___gen)]
                (if (:isLoop this)
                    (do
                        (try
                            (ß Var'pushThreadBindings(RT'map(Compiler'LOOP_LABEL, ___loopLabel)))
                            (if ___emitUnboxed
                                (do
                                    (ß ((MaybePrimitiveExpr)(:body this)).emitUnboxed(___context, ___objx, ___gen))
                                )
                                (do
                                    (ß (:body this).emit(___context, ___objx, ___gen))
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                    (do
                        (if ___emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)(:body this)).emitUnboxed(___context, ___objx, ___gen))
                            )
                            (do
                                (ß (:body this).emit(___context, ___objx, ___gen))
                            )
                        )
                    )
                )
                (let [#_"Label" ___end (.mark ___gen)]
                    (loop-when-recur [#_"ISeq" ___bis (.seq (:bindingInits this))] (some? ___bis) [(next ___bis)]
                        (let [#_"BindingInit" ___bi (ß (BindingInit) (first ___bis))]
                            (let [#_"String" ___lname (:name (:binding ___bi))]
                                (when (.endsWith ___lname, "__auto__")
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (ß maybePrimitiveType((:init ___bi)))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___bindingLabels.get(___bi), ___end, (:idx (:binding ___bi))))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___bindingLabels.get(___bi), ___end, (:idx (:binding ___bi))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"LetExpr" this]
        (.hasJavaClass (:body this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"LetExpr" this]
        (.getJavaClass (:body this))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"LetExpr" this]
        (ß ((:body this) instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)(:body this)).canEmitPrimitive()))
    )
)

#_closure
(class-ns RecurParser (§ implements IParser)
    (defn #_"RecurParser" RecurParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"RecurParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (ß Compiler'lineDeref())]
            (let [#_"int" ___column (ß Compiler'columnDeref())]
                (let [#_"String" ___source (ß (String) Compiler'SOURCE.deref())]
                    (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
                        (let [#_"IPersistentVector" ___loopLocals (ß (IPersistentVector) Compiler'LOOP_LOCALS.deref())]
                            (when (ß ___context != :Context'RETURN || ___loopLocals == nil)
                                (throw (UnsupportedOperationException. "Can only recur from tail position"))
                            )
                            (when (ß Compiler'NO_RECUR.deref() != nil)
                                (throw (UnsupportedOperationException. "Cannot recur across try"))
                            )
                            (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                                (loop-when-recur [#_"ISeq" ___s (ß RT'seq((next ___form)))] (some? ___s) [(next ___s)]
                                    (§ ass ___args (ß ___args.cons(analyze(:Context'EXPRESSION, (first ___s)))))
                                )
                                (when (ß (count ___args) != (count ___loopLocals))
                                    (throw (IllegalArgumentException. (String/format "Mismatched argument count to recur, expected: %d args, got: %d", (object-array [ (count ___loopLocals), (count ___args) ]))))
                                )
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___loopLocals)) [(inc ___i)]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___loopLocals.nth(___i))]
                                        (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                            (when (some? ___primc)
                                                (let [#_"boolean" ___mismatch false]
                                                    (let [#_"Class" ___pc (ß maybePrimitiveType((Expr) ___args.nth(___i)))]
                                                        (cond (ß ___primc == (§ class long))
                                                            (do
                                                                (when (not (ß ___pc == (§ class long) || ___pc == (§ class int) || ___pc == (§ class short) || ___pc == (§ class char) || ___pc == (§ class byte)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                            (ß ___primc == (§ class double))
                                                            (do
                                                                (when (not (ß ___pc == (§ class double) || ___pc == (§ class float)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                        )
                                                        (when ___mismatch
                                                            (§ ass (:recurMistmatch ___lb) true)
                                                            (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                                                (.println (RT'errPrintWriter), (str ___source ":" ___line " recur arg for primitive local: " (:name ___lb) " is not matching primitive, had: " (if (some? ___pc) (.getName ___pc) "Object") ", needed: " (.getName ___primc)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (RecurExpr'new ___loopLocals, ___args, ___line, ___column, ___source)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"RecurExpr" RecurExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"IPersistentVector" :loopLocals nil

            #_"int" :line 0
            #_"int" :column 0
            #_"String" :source nil
        )
    )

    (defn #_"RecurExpr" RecurExpr'new [#_"IPersistentVector" ___loopLocals, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column, #_"String" ___source]
        (let [this (RecurExpr'init)]
            (§ ass (:loopLocals this) ___loopLocals)
            (§ ass (:args this) ___args)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:source this) ___source)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___loopLabel (ß (Label) Compiler'LOOP_LABEL.deref())]
            (when (nil? ___loopLabel)
                (throw (IllegalStateException.))
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:loopLocals this).count()) [(inc ___i)]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (:loopLocals this).nth(___i))]
                    (let [#_"Expr" ___arg (ß (Expr) (:args this).nth(___i))]
                        (if (ß (.getPrimitiveType ___lb) != nil)
                            (do
                                (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                                    (let [#_"Class" ___pc (ß maybePrimitiveType(___arg))]
                                        (cond (ß ___pc == ___primc)
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                            )
                                            (ß ___primc == (§ class long) && ___pc == (§ class int))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (.visitInsn ___gen, Opcodes/I2L)
                                            )
                                            (ß ___primc == (§ class double) && ___pc == (§ class float))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (.visitInsn ___gen, Opcodes/F2D)
                                            )
                                            (ß ___primc == (§ class int) && ___pc == (§ class long))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                                            )
                                            (ß ___primc == (§ class float) && ___pc == (§ class double))
                                            (do
                                                (ß (cast' MaybePrimitiveExpr ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (.visitInsn ___gen, Opcodes/D2F)
                                            )
                                            :else
                                            (do
                                                (throw (IllegalArgumentException. (str "recur arg for primitive local: " (:name ___lb) " is not matching primitive, had: " (if (.hasJavaClass ___arg) (.getName (.getJavaClass ___arg)) "Object") ", needed: " (.getName ___primc))))
                                            )
                                        )
                                    )
                                )
                            )
                            (do
                                (ß ___arg.emit(:Context'EXPRESSION, ___objx, ___gen))
                            )
                        )
                    )
                )
            )

            (loop-when-recur [#_"int" ___i (ß (:loopLocals this).count() - 1)] (ß ___i >= 0) [(dec ___i)]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (:loopLocals this).nth(___i))]
                    (let [#_"Class" ___primc (.getPrimitiveType ___lb)]
                        (if (:isArg ___lb)
                            (do
                                (.storeArg ___gen, (- (:idx ___lb) (if (:canBeDirect ___objx) 0 1)))
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (.goTo ___gen, ___loopLabel)
            nil
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"RecurExpr" this]
        Compiler'RECUR_CLASS
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.emit this, ___context, ___objx, ___gen)
        nil
    )
)

(class-ns CompilerException (§ extends RuntimeException)
    (defn- #_"CompilerException" CompilerException'init []
        (hash-map
            #_"String" :source nil
            #_"int" :line 0
        )
    )

    (defn #_"CompilerException" CompilerException'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new (ß errorMsg(___source, ___line, ___column, (.toString ___cause))), ___cause) (CompilerException'init))]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"CompilerException" this]
        (ß getMessage())
    )
)

#_closure
(class-ns DeftypeParser (§ implements IParser)
    (defn #_"DeftypeParser" DeftypeParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"DeftypeParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___rform (ß (ISeq) ___frm)]
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            (§ ass ___rform (RT'next ___rform))
            (let [#_"String" ___tagname (ß ((Symbol) (first ___rform)).getName())]
                (§ ass ___rform (next ___rform))
                (let [#_"Symbol" ___classname (ß (Symbol) (first ___rform))]
                    (§ ass ___rform (next ___rform))
                    (let [#_"IPersistentVector" ___fields (ß (IPersistentVector) (first ___rform))]
                        (§ ass ___rform (next ___rform))
                        (let [#_"IPersistentMap" ___opts PersistentHashMap'EMPTY]
                            (while (ß ___rform != nil && (first ___rform) instanceof Keyword)
                                (§ ass ___opts (ß ___opts.assoc((first ___rform), RT'second(___rform))))
                                (§ ass ___rform (next (next ___rform)))
                            )

                            (let [#_"ObjExpr" ___ret (ß build((IPersistentVector)RT'get-3(___opts, implementsKey, PersistentVector'EMPTY), ___fields, nil, ___tagname, ___classname, (Symbol) RT'get-2(___opts, RT'TAG_KEY), ___rform, ___frm, ___opts))]
                                ___ret
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ReifyParser (§ implements IParser)
    (defn #_"ReifyParser" ReifyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" (§ method parse) [#_"ReifyParser" this, #_"Context" ___context, #_"Object" ___frm]
        ;; (reify this-name? [interfaces] (method-name [args] body)*)
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (let [#_"ObjMethod" ___enclosingMethod (ß (ObjMethod) Compiler'METHOD.deref())]
                (let [#_"String" ___basename (str (if (ß ___enclosingMethod != nil) (ß trimGenID((:name (:objx ___enclosingMethod)))) (ß munge((:name (:name (.currentNS this)))))) "$")]
                    (let [#_"String" ___simpleName (str "reify__" (RT'nextID))]
                        (let [#_"String" ___classname (+ ___basename ___simpleName)]
                            (let [#_"ISeq" ___rform (RT'next ___form)]
                                (let [#_"IPersistentVector" ___interfaces (ß ((IPersistentVector) RT'first(___rform)).cons(Symbol'intern-1("cloiure.lang.IObj")))]
                                    (§ ass ___rform (RT'next ___rform))

                                    (let [#_"ObjExpr" ___ret (ß build(___interfaces, nil, nil, ___classname, Symbol'intern-1(___classname), nil, ___rform, ___frm, nil))]
                                        (if (ß ___frm instanceof IObj && (cast' IObj ___frm).meta() != nil)
                                            (do
                                                (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (ß (cast' IObj ___frm).meta())))
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewInstanceExpr (§ extends ObjExpr)
    (defn- #_"NewInstanceExpr" NewInstanceExpr'init []
        (hash-map
            #_"IPersistentCollection" :methods nil

            #_"Map<IPersistentVector, java.lang.reflect.Method>" :mmap nil
            #_"Map<IPersistentVector, Set<Class>>" :covariants nil
        )
    )

    (defn #_"NewInstanceExpr" NewInstanceExpr'new [#_"Object" ___tag]
        (merge (ObjExpr'new ___tag) (NewInstanceExpr'init))
    )

    (defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" ___interfaceSyms, #_"IPersistentVector" ___fieldSyms, #_"Symbol" ___thisSym, #_"String" ___tagName, #_"Symbol" ___className, #_"Symbol" ___typeTag, #_"ISeq" ___methodForms, #_"Object" ___frm, #_"IPersistentMap" ___opts]
        (let [#_"NewInstanceExpr" ___ret (NewInstanceExpr'new nil)]
            (§ ass (:src ___ret) ___frm)
            (§ ass (:name ___ret) (.toString ___className))
            (§ ass (:classMeta ___ret) (RT'meta ___className))
            (§ ass (:internalName ___ret) (ß (:name ___ret).replace(\., \/)))
            (§ ass (:objtype ___ret) (ß Type/getObjectType((:internalName ___ret))))
            (§ ass (:opts ___ret) ___opts)

            (when (some? ___thisSym)
                (§ ass (:thisName ___ret) (:name ___thisSym))
            )

            (when (some? ___fieldSyms)
                (let [#_"IPersistentMap" ___fmap PersistentHashMap'EMPTY]
                    (let [#_"Object[]" ___closesvec (make-array Object (ß 2 * (count ___fieldSyms)))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___fieldSyms)) [(inc ___i)]
                            (let [#_"Symbol" ___sym (ß (Symbol) ___fieldSyms.nth(___i))]
                                (let [#_"LocalBinding" ___lb (ß LocalBinding'new(-1, ___sym, nil, MethodParamExpr'new(tagClass(tagOf(___sym))), false, nil))]
                                    (§ ass ___fmap (.assoc ___fmap, ___sym, ___lb))
                                    (§ ass (ß ___closesvec[___i * 2]) ___lb)
                                    (§ ass (ß ___closesvec[___i * 2 + 1]) ___lb)
                                )
                            )
                        )

                        ;; todo - inject __meta et al into closes - when?
                        ;; use array map to preserve ctor order
                        (§ ass (:closes ___ret) (PersistentArrayMap'new-1 ___closesvec))
                        (§ ass (:fields ___ret) ___fmap)
                        (loop-when-recur [#_"int" ___i (ß (count ___fieldSyms) - 1)] (ß (ß ___i >= 0) && ((ß (:name (cast' Symbol (.nth ___fieldSyms, ___i))).equals("__meta")) || (ß (:name (cast' Symbol (.nth ___fieldSyms, ___i))).equals("__extmap")) || (ß (:name (cast' Symbol (.nth ___fieldSyms, ___i))).equals("__hash")) || (ß (:name (cast' Symbol (.nth ___fieldSyms, ___i))).equals("__hasheq")))) [(dec ___i)]
                            (§ ass (:altCtorDrops ___ret) (ß (:altCtorDrops ___ret) + 1))
                        )
                    )
                )
            )

            (let [#_"PersistentVector" ___interfaces PersistentVector'EMPTY]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___interfaceSyms)] (some? ___s) [(next ___s)]
                    (let [#_"Class" ___c (ß (Class) resolve((Symbol) (first ___s)))]
                        (when (not (ß ___c.isInterface()))
                            (throw (IllegalArgumentException. (str "only interfaces are supported, had: " (.getName ___c))))
                        )
                        (§ ass ___interfaces (.cons ___interfaces, ___c))
                    )
                )
                (let [#_"Class" ___superClass (§ class Object)]
                    (let [#_"Map[]" ___mc (ß NewInstanceExpr'gatherMethods-2s(___superClass, RT'seq(___interfaces)))]
                        (let [#_"Map" ___overrideables (ß ___mc[0])]
                            (let [#_"Map" ___covariants (ß ___mc[1])]
                                (§ ass (:mmap ___ret) ___overrideables)
                                (§ ass (:covariants ___ret) ___covariants)

                                (let [#_"String[]" ___inames (ß interfaceNames(___interfaces))]
                                    (let [#_"Class" ___stub (ß compileStub(slashname(___superClass), ___ret, ___inames, ___frm))]
                                        (let [#_"Symbol" ___thistag (ß Symbol'intern-2(nil, (.getName ___stub)))]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (object-array [
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (ß emptyVarCallSites())
                                                        Compiler'NO_RECUR           nil
                                                    ])
                                                )))
                                                (when (.isDeftype ___ret)
                                                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                        (object-array [
                                                            Compiler'METHOD             nil
                                                            Compiler'LOCAL_ENV          (:fields ___ret)
                                                            Compiler'COMPILE_STUB_SYM   (Symbol'intern-2 nil, ___tagName)
                                                            Compiler'COMPILE_STUB_CLASS ___stub
                                                        ])
                                                    )))

                                                    (§ ass (:hintedFields ___ret) (ß RT'subvec(___fieldSyms, 0, (count ___fieldSyms) - (:altCtorDrops ___ret))))
                                                )

                                                ;; now (methodname [args] body)*
                                                (§ ass (:line ___ret) (ß Compiler'lineDeref()))
                                                (§ ass (:column ___ret) (ß Compiler'columnDeref()))
                                                (let [#_"IPersistentCollection" ___methods nil]
                                                    (loop-when-recur [#_"ISeq" ___s ___methodForms] (some? ___s) [(RT'next ___s)]
                                                        (let [#_"NewInstanceMethod" ___m (ß NewInstanceMethod'parse(___ret, (ISeq) RT'first(___s), ___thistag, ___overrideables))]
                                                            (§ ass ___methods (RT'conj ___methods, ___m))
                                                        )
                                                    )

                                                    (§ ass (:methods ___ret) ___methods)
                                                    (§ ass (:keywords ___ret) (ß (IPersistentMap) Compiler'KEYWORDS.deref()))
                                                    (§ ass (:vars ___ret) (ß (IPersistentMap) Compiler'VARS.deref()))
                                                    (§ ass (:constants ___ret) (ß (PersistentVector) Compiler'CONSTANTS.deref()))
                                                    (§ ass (:constantsID ___ret) (RT'nextID))
                                                    (§ ass (:keywordCallsites ___ret) (ß (IPersistentVector) Compiler'KEYWORD_CALLSITES.deref()))
                                                    (§ ass (:protocolCallsites ___ret) (ß (IPersistentVector) Compiler'PROTOCOL_CALLSITES.deref()))
                                                    (§ ass (:varCallsites ___ret) (ß (IPersistentSet) Compiler'VAR_CALLSITES.deref()))
                                                )
                                                (finally
                                                    (when (.isDeftype ___ret)
                                                        (Var'popThreadBindings)
                                                    )
                                                    (Var'popThreadBindings)
                                                )
                                            )

                                            (try
                                                (ß ___ret.compile(slashname(___superClass), ___inames, false))
                                                (catch IOException ___e
                                                    (throw (Util'sneakyThrow ___e))
                                                )
                                            )
                                            (.getCompiledClass ___ret)
                                            ___ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Current host interop uses reflection, which requires pre-existing classes
     ; Work around this by:
     ; Generate a stub class that has the same interfaces and fields as the class we are generating.
     ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
     ; Unmunge the name (using a magic prefix) on any code gen for classes
     ;;
    (defn #_"Class" NewInstanceExpr'compileStub [#_"String" ___superName, #_"NewInstanceExpr" ___ret, #_"String[]" ___interfaceNames, #_"Object" ___frm]
        (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" ___cv ___cw]
                (.visit ___cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER), (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ___ret)), nil, ___superName, ___interfaceNames)

                ;; instance fields for closed-overs
                (loop-when-recur [#_"ISeq" ___s (ß RT'keys((:closes ___ret)))] (some? ___s) [(next ___s)]
                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___s))]
                        (let [#_"int" ___access (+ Opcodes/ACC_PUBLIC (if (ß ___ret.isVolatile(___lb)) Opcodes/ACC_VOLATILE (if (ß ___ret.isMutable(___lb)) 0 Opcodes/ACC_FINAL)))]
                            (if (ß (.getPrimitiveType ___lb) != nil)
                                (do
                                    (ß ___cv.visitField(___access, (:name ___lb), Type/getType((.getPrimitiveType ___lb)).getDescriptor(), nil, nil))
                                )
                                (do
                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                    (ß ___cv.visitField(___access, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil))
                                )
                            )
                        )
                    )
                )

                ;; ctor that takes closed-overs and does nothing
                (let [#_"Method" ___m (Method. "<init>", Type/VOID_TYPE, (.ctorTypes ___ret))]
                    (let [#_"GeneratorAdapter" ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, nil, ___cv)]
                        (.visitCode ___ctorgen)
                        (.loadThis ___ctorgen)
                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))
                        (.returnValue ___ctorgen)
                        (.endMethod ___ctorgen)

                        (when (ß (:altCtorDrops ___ret) > 0)
                            (let [#_"Type[]" ___ctorTypes (.ctorTypes ___ret)]
                                (let [#_"Type[]" ___altCtorTypes (make-array Type (ß ___ctorTypes.length - (:altCtorDrops ret)))]
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                        (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                    )
                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes)]
                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                        (.visitCode ___ctorgen)
                                        (.loadThis ___ctorgen)
                                        (.loadArgs ___ctorgen)

                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __meta
                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __extmap
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                        (.invokeConstructor ___ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ___ret))), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes))

                                        (.returnValue ___ctorgen)
                                        (.endMethod ___ctorgen)

                                        ;; alt ctor no __hash, __hasheq
                                        (§ ass ___altCtorTypes (make-array Type (ß ___ctorTypes.length - 2)))
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                            (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                        )

                                        (§ ass ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes))
                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                        (.visitCode ___ctorgen)
                                        (.loadThis ___ctorgen)
                                        (.loadArgs ___ctorgen)

                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                        (.invokeConstructor ___ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ___ret))), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes))

                                        (.returnValue ___ctorgen)
                                        (.endMethod ___ctorgen)
                                    )
                                )
                            )
                        )
                        ;; end of class
                        (.visitEnd ___cv)

                        (let [#_"byte[]" ___bytecode (.toByteArray ___cw)]
                            (let [#_"DynamicClassLoader" ___loader (ß (DynamicClassLoader) Compiler'LOADER.deref())]
                                (.defineClass ___loader, (str Compiler'COMPILE_STUB_PREFIX "." (:name ___ret)), ___bytecode, ___frm)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" ___interfaces]
        (let [#_"int" ___icnt (count ___interfaces)]
            (let [#_"String[]" ___inames (when (pos? ___icnt) (make-array String ___icnt))]
                (loop-when-recur [#_"int" ___i 0] (< ___i ___icnt) [(inc ___i)]
                    (§ ass (ß ___inames[___i]) (ß slashname((Class) ___interfaces.nth(___i))))
                )
                ___inames
            )
        )
    )

    (defn #_"String" NewInstanceExpr'slashname [#_"Class" ___c]
        (ß (.getName ___c).replace(\., \/))
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitStatics) [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (when (.isDeftype this)
            ;; getBasis()
            (let [#_"Method" ___meth (Method/getMethod "cloiure.lang.IPersistentVector getBasis()")]
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ___meth, nil, nil, ___cv)]
                    (.emitValue this, (:hintedFields this), ___gen)
                    (.returnValue ___gen)
                    (.endMethod ___gen)

                    (when (ß (.isDeftype this) && (:fields this).count() > (:hintedFields this).count())
                        ;; create(IPersistentMap)
                        (let [#_"String" ___className (ß (:name this).replace(\., \/))]
                            (let [#_"int" ___i 1]
                                (let [#_"int" ___fieldCount (count (:hintedFields this))]
                                    (let [#_"MethodVisitor" ___mv (.visitMethod ___cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), "create", (str "(Lcloiure/lang/IPersistentMap;)L" ___className ";"), nil, nil)]
                                        (.visitCode ___mv)

                                        (loop-when-recur [#_"ISeq" ___s (RT'seq (:hintedFields this)) ___i ___i] (some? ___s) [(next ___s) (inc ___i)]
                                            (let [#_"String" ___bName (:name (cast' Symbol (first ___s)))]
                                                (let [#_"Class" ___k (ß tagClass(tagOf((first ___s))))]
                                                    (.visitVarInsn ___mv, Opcodes/ALOAD, 0)
                                                    (.visitLdcInsn ___mv, ___bName)
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                                    (.visitInsn ___mv, Opcodes/ACONST_NULL)
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                                                    (when (.isPrimitive ___k)
                                                        (ß ___mv.visitTypeInsn(Opcodes/CHECKCAST, Type/getType(boxClass(___k)).getInternalName()))
                                                    )
                                                    (.visitVarInsn ___mv, Opcodes/ASTORE, ___i)
                                                    (.visitVarInsn ___mv, Opcodes/ALOAD, 0)
                                                    (.visitLdcInsn ___mv, ___bName)
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                                    (.visitMethodInsn ___mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                                                    (.visitVarInsn ___mv, Opcodes/ASTORE, 0)
                                                )
                                            )
                                        )

                                        (ß ___mv.visitTypeInsn(Opcodes/NEW, ___className))
                                        (.visitInsn ___mv, Opcodes/DUP)

                                        (let [#_"Method" ___ctor (Method. "<init>", Type/VOID_TYPE, (.ctorTypes this))]
                                            (when (ß (:hintedFields this).count() > 0)
                                                (loop-when-recur [___i 1] (ß ___i <= ___fieldCount) [(inc ___i)]
                                                    (.visitVarInsn ___mv, Opcodes/ALOAD, ___i)
                                                    (let [#_"Class" ___k (ß tagClass(tagOf((:hintedFields this).nth(___i - 1))))]
                                                        (when (.isPrimitive ___k)
                                                            (let [#_"String" ___b (ß Type/getType(boxClass(___k)).getInternalName())]
                                                                (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                                    (let [#_"String" ___n (.getName ___k)]
                                                                        (.visitMethodInsn ___mv, Opcodes/INVOKEVIRTUAL, ___b, (str ___n "Value"), (str "()" ___p))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )

                                            (.visitInsn ___mv, Opcodes/ACONST_NULL) ;; __meta
                                            (.visitVarInsn ___mv, Opcodes/ALOAD, 0) ;; __extmap
                                            (.visitMethodInsn ___mv, Opcodes/INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                                            (.visitInsn ___mv, Opcodes/ICONST_0) ;; __hash
                                            (.visitInsn ___mv, Opcodes/ICONST_0) ;; __hasheq
                                            (ß ___mv.visitMethodInsn(Opcodes/INVOKESPECIAL, ___className, "<init>", (.getDescriptor ___ctor)))
                                            (.visitInsn ___mv, Opcodes/ARETURN)
                                            (ß ___mv.visitMaxs(4 + ___fieldCount, 1 + ___fieldCount))
                                            (.visitEnd ___mv)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" (§ method emitMethods) [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (loop-when-recur [#_"ISeq" ___s (RT'seq (:methods this))] (some? ___s) [(next ___s)]
            (let [#_"ObjMethod" ___method (ß (ObjMethod) (first ___s))]
                (.emit ___method, this, ___cv)
            )
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" ___e (.entrySet (:covariants this))]
            (let [#_"java.lang.reflect.Method" ___m (ß (:mmap this).get((.getKey ___e)))]
                (let [#_"Class[]" ___params (.getParameterTypes ___m)]
                    (let [#_"Type[]" ___argTypes (make-array Type (ß ___params.length))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___params.length) [(inc ___i)]
                            (§ ass (ß ___argTypes[___i]) (ß Type/getType(___params[___i])))
                        )

                        (let [#_"Method" ___target (Method. (.getName ___m), (Type/getType (.getReturnType ___m)), ___argTypes)]
                            (doseq [#_"Class" ___retType (.getValue ___e)]
                                (let [#_"Method" ___meth (Method. (.getName ___m), (Type/getType ___retType), ___argTypes)]
                                    ;; todo don't hardwire EXCEPTION_TYPES
                                    (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_BRIDGE), ___meth, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                                        (.visitCode ___gen)
                                        (.loadThis ___gen)
                                        (.loadArgs ___gen)
                                        (ß ___gen.invokeInterface(Type/getType((.getDeclaringClass ___m)), ___target))
                                        (.returnValue ___gen)
                                        (.endMethod ___gen)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" ___m]
        (ß RT'vector((.getName ___m), RT'seq((.getParameterTypes ___m)), (.getReturnType ___m)))
    )

    (defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" ___m, #_"Map" ___mm]
        (let [#_"IPersistentVector" ___mk (ß msig(___m))]
            (let [#_"int" ___mods (.getModifiers ___m)]
                (when (not (ß ___mm.containsKey(___mk) || (not (ß Modifier/isPublic(___mods) || Modifier/isProtected(___mods))) || Modifier/isStatic(___mods) || Modifier/isFinal(___mods)))
                    (.put ___mm, ___mk, ___m)
                )
                nil
            )
        )
    )

    (defn #_"void" NewInstanceExpr'gatherMethods-2m [#_"Class" ___c, #_"Map" ___mm]
        (loop-when-recur [___c ___c] (some? ___c) [(.getSuperclass ___c)]
            (doseq [#_"java.lang.reflect.Method" ___m (.getDeclaredMethods ___c)]
                (ß considerMethod(___m, ___mm))
            )
            (doseq [#_"java.lang.reflect.Method" ___m (.getMethods ___c)]
                (ß considerMethod(___m, ___mm))
            )
        )
        nil
    )

    (defn #_"Map[]" NewInstanceExpr'gatherMethods-2s [#_"Class" ___sc, #_"ISeq" ___interfaces]
        (let [#_"Map" ___allm (HashMap.)]
            (NewInstanceExpr'gatherMethods-2m ___sc, ___allm)
            (loop-when-recur [___interfaces ___interfaces] (some? ___interfaces) [(next ___interfaces)]
                (ß NewInstanceExpr'gatherMethods-2m((Class) (first ___interfaces), ___allm))
            )

            (let [#_"Map<IPersistentVector, java.lang.reflect.Method>" ___mm (HashMap.)]
                (let [#_"Map<IPersistentVector, Set<Class>>" ___covariants (HashMap.)]
                    (doseq [#_"Object" ___o (.entrySet ___allm)]
                        (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                            (let [#_"IPersistentVector" ___mk (ß (IPersistentVector) (.getKey ___e))]
                                (§ ass ___mk (ß (IPersistentVector) (.pop ___mk)))
                                (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) (.getValue ___e))]
                                    (if (.containsKey ___mm, ___mk) ;; covariant return
                                        (do
                                            (let [#_"Set<Class>" ___cvs (.get ___covariants, ___mk)]
                                                (when (nil? ___cvs)
                                                    (§ ass ___cvs (HashSet.))
                                                    (.put ___covariants, ___mk, ___cvs)
                                                )
                                                (let [#_"java.lang.reflect.Method" ___om (.get ___mm, ___mk)]
                                                    (if (ß (.getReturnType ___om).isAssignableFrom((.getReturnType ___m)))
                                                        (do
                                                            (ß ___cvs.add((.getReturnType ___om)))
                                                            (.put ___mm, ___mk, ___m)
                                                        )
                                                        (do
                                                            (ß ___cvs.add((.getReturnType ___m)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (.put ___mm, ___mk, ___m)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß new Map[] (object-array [ ___mm, ___covariants ]))
                )
            )
        )
    )
)

(class-ns NewInstanceMethod (§ extends ObjMethod)
    (§ def #_"Symbol" NewInstanceMethod'dummyThis (Symbol'intern-2 nil, "dummy_this_dlskjsdfower"))

    (defn- #_"NewInstanceMethod" NewInstanceMethod'init []
        (hash-map
            #_"String" :name nil
            #_"Type[]" :argTypes nil
            #_"Type" :retType nil
            #_"Class" :retClass nil
            #_"Class[]" :exclasses nil

            #_"IPersistentVector" :parms nil
        )
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (merge (ObjMethod'new ___objx, ___parent) (NewInstanceMethod'init))
    )

    #_method
    (§ defn #_"int" (§ method numParams) [#_"NewInstanceMethod" this]
        (count (:argLocals this))
    )

    #_method
    (§ defn #_"String" (§ method getMethodName) [#_"NewInstanceMethod" this]
        (:name this)
    )

    #_method
    (§ defn #_"Type" (§ method getReturnType) [#_"NewInstanceMethod" this]
        (:retType this)
    )

    #_method
    (§ defn #_"Type[]" (§ method getArgTypes) [#_"NewInstanceMethod" this]
        (:argTypes this)
    )

    (defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" ___name, #_"Class[]" ___paramTypes]
        (ß RT'vector(___name, RT'seq(___paramTypes)))
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Symbol" ___thistag, #_"Map" ___overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" ___method (ß NewInstanceMethod'new(___objx, (ObjMethod) Compiler'METHOD.deref()))]
            (let [#_"Symbol" ___dotname (ß (Symbol)RT'first(___form))]
                (let [#_"Symbol" ___name (ß (Symbol) Symbol'intern-2(nil, munge((:name ___dotname))).withMeta(RT'meta(___dotname)))]
                    (let [#_"IPersistentVector" ___parms (ß (IPersistentVector) RT'second(___form))]
                        (when (ß (count ___parms) == 0)
                            (throw (IllegalArgumentException. (str "Must supply at least one argument for 'this' in: " ___dotname)))
                        )
                        (let [#_"Symbol" ___thisName (ß (Symbol) ___parms.nth(0))]
                            (§ ass ___parms (ß RT'subvec(___parms, 1, (count ___parms))))
                            (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                                (try
                                    (§ ass (:line ___method) (ß Compiler'lineDeref()))
                                    (§ ass (:column ___method) (ß Compiler'columnDeref()))
                                    ;; register as the current method and set up a new env frame
                                    (let [#_"PathNode" ___pnode (ß PathNode'new(:PathType'PATH, (PathNode) Compiler'CLEAR_PATH.get()))]
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (object-array [
                                                Compiler'METHOD                ___method
                                                Compiler'LOCAL_ENV             (deref Compiler'LOCAL_ENV)
                                                Compiler'LOOP_LOCALS           nil
                                                Compiler'NEXT_LOCAL_NUM        0
                                                Compiler'CLEAR_PATH            ___pnode
                                                Compiler'CLEAR_ROOT            ___pnode
                                                Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                                Compiler'METHOD_RETURN_CONTEXT RT'T
                                            ])
                                        )))

                                        ;; register 'this' as local 0
                                        (if (some? ___thisName)
                                            (do
                                                (Compiler'registerLocal (or ___thisName NewInstanceMethod'dummyThis), ___thistag, nil, false)
                                            )
                                            (do
                                                (ß getAndIncLocalNum())
                                            )
                                        )

                                        (let [#_"PersistentVector" ___argLocals PersistentVector'EMPTY]
                                            (§ ass (:retClass ___method) (ß tagClass(tagOf(___name))))
                                            (§ ass (:argTypes ___method) (make-array Type (count ___parms)))
                                            (let [#_"boolean" ___hinted (ß tagOf(___name) != nil)]
                                                (let [#_"Class[]" ___pclasses (make-array Class (count ___parms))]
                                                    (let [#_"Symbol[]" ___psyms (§ typeless make-array Symbol (count ___parms))]
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                            (when (not (ß ___parms.nth(___i) instanceof Symbol))
                                                                (throw (IllegalArgumentException. "params must be Symbols"))
                                                            )
                                                            (let [#_"Symbol" ___p (ß (Symbol) ___parms.nth(___i))]
                                                                (let [#_"Object" ___tag (ß tagOf(___p))]
                                                                    (when (some? ___tag)
                                                                        (§ ass ___hinted true)
                                                                    )
                                                                    (when (ß (.getNamespace ___p) != nil)
                                                                        (§ ass ___p (ß Symbol'intern-1((:name ___p))))
                                                                    )
                                                                    (let [#_"Class" ___pclass (ß tagClass(___tag))]
                                                                        (§ ass (ß ___pclasses[___i]) ___pclass)
                                                                        (§ ass (ß ___psyms[___i]) ___p)
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (let [#_"Map" ___matches (ß findMethodsWithNameAndArity((:name ___name), (count ___parms), ___overrideables))]
                                                            (let [#_"Object" ___mk (ß msig((:name ___name), ___pclasses))]
                                                                (let [#_"java.lang.reflect.Method" ___m nil]
                                                                    (if (ß (.size ___matches) > 0)
                                                                        (do
                                                                            ;; multiple methods
                                                                            (cond (ß (.size ___matches) > 1)
                                                                                (do
                                                                                    ;; must be hinted and match one method
                                                                                    (when (not ___hinted)
                                                                                        (throw (IllegalArgumentException. (str "Must hint overloaded method: " (:name ___name))))
                                                                                    )
                                                                                    (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                    (when (nil? ___m)
                                                                                        (throw (IllegalArgumentException. (str "Can't find matching overloaded method: " (:name ___name))))
                                                                                    )
                                                                                    (when (ß (.getReturnType ___m) != (:retClass ___method))
                                                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name ___name) ", expected: " (.getName (.getReturnType ___m)) ", had: " (.getName (:retClass ___method)))))
                                                                                    )
                                                                                )
                                                                                :else ;; one match
                                                                                (do
                                                                                    ;; if hinted, validate match
                                                                                    (cond ___hinted
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                            (when (nil? ___m)
                                                                                                (throw (IllegalArgumentException. (str "Can't find matching method: " (:name ___name) ", leave off hints for auto match.")))
                                                                                            )
                                                                                            (when (ß (.getReturnType ___m) != (:retClass ___method))
                                                                                                (throw (IllegalArgumentException. (str "Mismatched return type: " (:name ___name) ", expected: " (.getName (.getReturnType ___m)) ", had: " (.getName (:retClass ___method)))))
                                                                                            )
                                                                                        )
                                                                                        :else ;; adopt found method sig
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) (.values ___matches).iterator().next()))
                                                                                            (§ ass (:retClass ___method) (.getReturnType ___m))
                                                                                            (§ ass ___pclasses (.getParameterTypes ___m))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (do
                                                                            (throw (IllegalArgumentException. (str "Can't define method not in interfaces: " (:name ___name))))
                                                                        )
                                                                    )

                                                                    ;; validate unque name+arity among additional methods

                                                                    (§ ass (:retType ___method) (ß Type/getType((:retClass ___method))))
                                                                    (§ ass (:exclasses ___method) (.getExceptionTypes ___m))

                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                                        (let [#_"LocalBinding" ___lb (ß Compiler'registerLocal(___psyms[___i], nil, MethodParamExpr'new(___pclasses[___i]), true))]
                                                                            (§ ass ___argLocals (.assocN ___argLocals, ___i, ___lb))
                                                                            (§ ass (ß (:argTypes ___method)[___i]) (ß Type/getType(___pclasses[___i])))
                                                                        )
                                                                    )
                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___parms)) [(inc ___i)]
                                                                        (when (ß ___pclasses[___i] == (§ class long) || ___pclasses[___i] == (§ class double))
                                                                            (ß getAndIncLocalNum())
                                                                        )
                                                                    )
                                                                    (ß Compiler'LOOP_LOCALS.set(___argLocals))
                                                                    (§ ass (:name ___method) (:name ___name))
                                                                    (§ ass (:methodMeta ___method) (RT'meta ___name))
                                                                    (§ ass (:parms ___method) ___parms)
                                                                    (§ ass (:argLocals ___method) ___argLocals)
                                                                    (§ ass (:body ___method) (ß (BodyParser'new()).parse(:Context'RETURN, ___body)))
                                                                    ___method
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (finally
                                        (Var'popThreadBindings)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" ___name, #_"int" ___arity, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (.entrySet ___mm)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) (.getValue ___e))]
                        (when (ß ___name.equals((.getName ___m)) && (.getParameterTypes ___m).length == ___arity)
                            (ß ___ret.put((.getKey ___e), (.getValue ___e)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" ___name, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (.entrySet ___mm)]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) (.getValue ___e))]
                        (when (ß ___name.equals((.getName ___m)))
                            (ß ___ret.put((.getKey ___e), (.getValue ___e)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"NewInstanceMethod" this, #_"ObjExpr" ___obj, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (.getMethodName this), (.getReturnType this), (.getArgTypes this))]
            (let [#_"Type[]" ___extypes nil]
                (when (ß (:exclasses this).length > 0)
                    (§ ass ___extypes (make-array Type (ß (:exclasses this).length)))
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exclasses this).length) [(inc ___i)]
                        (§ ass (ß ___extypes[___i]) (ß Type/getType((:exclasses this)[___i])))
                    )
                )
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, ___extypes, ___cv)]
                    (ß addAnnotation(___gen, (:methodMeta this)))
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:parms this).count()) [(inc ___i)]
                        (let [#_"IPersistentMap" ___meta (ß RT'meta((:parms this).nth(___i)))]
                            (ß addParameterAnnotation(___gen, ___meta, ___i))
                        )
                    )
                    (.visitCode ___gen)

                    (let [#_"Label" ___loopLabel (.mark ___gen)]
                        (.visitLineNumber ___gen, (:line this), ___loopLabel)
                        (try
                            (ß Var'pushThreadBindings(RT'map(Compiler'LOOP_LABEL, ___loopLabel, Compiler'METHOD, this)))

                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))
                            (let [#_"Label" ___end (.mark ___gen)]
                                (ß ___gen.visitLocalVariable("this", (:objtype ___obj).getDescriptor(), nil, ___loopLabel, ___end, 0))
                                (loop-when-recur [#_"ISeq" ___lbs (.seq (:argLocals this))] (some? ___lbs) [(next ___lbs)]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) (first ___lbs))]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argTypes this)[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )

                        (.returnValue ___gen)
                        (.endMethod ___gen)
                        nil
                    )
                )
            )
        )
    )
)

(class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"MethodParamExpr" MethodParamExpr'init []
        (hash-map
            #_"Class" :c nil
        )
    )

    (defn #_"MethodParamExpr" MethodParamExpr'new [#_"Class" ___c]
        (let [this (MethodParamExpr'init)]
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"MethodParamExpr" this]
        (throw (Util'runtimeException-1 "Can't eval"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (Util'runtimeException-1 "Can't emit"))
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"MethodParamExpr" this]
        (ß ((:c this) != nil))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"MethodParamExpr" this]
        (:c this)
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"MethodParamExpr" this]
        (Util'isPrimitive (:c this))
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (Util'runtimeException-1 "Can't emit"))
    )
)

#_closure
(class-ns CaseParser (§ implements IParser)
    (defn #_"CaseParser" CaseParser'new []
        (hash-map)
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    ;; prepared by case macro and presumed correct
    ;; case macro binds actual expr in let so expr is always a local,
    ;; no need to worry about multiple evaluation
    #_method
    (§ defn #_"Expr" (§ method parse) [#_"CaseParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß ___context == :Context'EVAL)
                (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (let [#_"IPersistentVector" ___args (ß LazilyPersistentVector'create((next ___form)))]
                (let [#_"Object" ___exprForm (.nth ___args, 0)]
                    (let [#_"int" ___shift (ß ((Number)___args.nth(1)).intValue())]
                        (let [#_"int" ___mask (ß ((Number)___args.nth(2)).intValue())]
                            (let [#_"Object" ___defaultForm (.nth ___args, 3)]
                                (let [#_"Map" ___caseMap (ß (Map)___args.nth(4))]
                                    (let [#_"Keyword" ___switchType (ß ((Keyword)___args.nth(5)))]
                                        (let [#_"Keyword" ___testType (ß ((Keyword)___args.nth(6)))]
                                            (let [#_"Set" ___skipCheck (ß (RT'count(___args) < 8) ? nil :or (Set)___args.nth(7))]
                                                (let [#_"ISeq" ___keys (RT'keys ___caseMap)]
                                                    (let [#_"int" ___low (ß ((Number)RT'first(___keys)).intValue())]
                                                        (let [#_"int" ___high (ß ((Number)RT'nth-2(___keys, RT'count(___keys) - 1)).intValue())]
                                                            (let [#_"LocalBindingExpr" ___testexpr (ß (LocalBindingExpr) analyze(:Context'EXPRESSION, ___exprForm))]
                                                                (§ ass (:shouldClear ___testexpr) false)

                                                                (let [#_"SortedMap<Integer, Expr>" ___tests (TreeMap.)]
                                                                    (let [#_"HashMap<Integer, Expr>" ___thens (HashMap.)]
                                                                        (let [#_"PathNode" ___branch (ß PathNode'new(:PathType'BRANCH, (PathNode) Compiler'CLEAR_PATH.get()))]
                                                                            (doseq [#_"Object" ___o (.entrySet ___caseMap)]
                                                                                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                                                                                    (let [#_"Integer" ___minhash (ß ((Number)___e.getKey()).intValue())]
                                                                                        (let [#_"Object" ___pair (.getValue ___e)] ;; [test-val then-expr]
                                                                                            (let [#_"Expr" ___testExpr (ß (___testType == intKey) ? NumberExpr'parse(((Number)RT'first(___pair)).intValue()) :or ConstantExpr'new(RT'first(___pair)))]
                                                                                                (.put ___tests, ___minhash, ___testExpr)

                                                                                                (§ let [#_"Expr" ___thenExpr]
                                                                                                    (try
                                                                                                        (ß Var'pushThreadBindings(RT'map(Compiler'CLEAR_PATH, PathNode'new(:PathType'PATH, ___branch))))
                                                                                                        (§ ass ___thenExpr (ß analyze(___context, RT'second(___pair))))
                                                                                                        (finally
                                                                                                            (Var'popThreadBindings)
                                                                                                        )
                                                                                                    )
                                                                                                    (.put ___thens, ___minhash, ___thenExpr)
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )

                                                                            (§ let [#_"Expr" ___defaultExpr]
                                                                                (try
                                                                                    (ß Var'pushThreadBindings(RT'map(Compiler'CLEAR_PATH, PathNode'new(:PathType'PATH, ___branch))))
                                                                                    (§ ass ___defaultExpr (ß analyze(___context, ___args.nth(3))))
                                                                                    (finally
                                                                                        (Var'popThreadBindings)
                                                                                    )
                                                                                )

                                                                                (let [#_"int" ___line (ß ((Number)Compiler'LINE.deref()).intValue())]
                                                                                    (let [#_"int" ___column (ß ((Number)Compiler'COLUMN.deref()).intValue())]
                                                                                        (CaseExpr'new ___line, ___column, ___testexpr, ___shift, ___mask, ___low, ___high, ___defaultExpr, ___tests, ___thens, ___switchType, ___testType, ___skipCheck)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
    (def #_"Type" CaseExpr'NUMBER_TYPE (Type/getType Number))
    (def #_"Method" CaseExpr'intValueMethod (Method/getMethod "int intValue()"))

    (def #_"Method" CaseExpr'hashMethod (Method/getMethod "int hash(Object)"))
    (def #_"Method" CaseExpr'hashCodeMethod (Method/getMethod "int hashCode()"))
    (def #_"Method" CaseExpr'equivMethod (Method/getMethod "boolean equiv(Object, Object)"))
    (§ def #_"Keyword" CaseExpr'compactKey (Keyword'intern-2 nil, "compact"))
    (§ def #_"Keyword" CaseExpr'sparseKey (Keyword'intern-2 nil, "sparse"))
    (§ def #_"Keyword" CaseExpr'hashIdentityKey (Keyword'intern-2 nil, "hash-identity"))
    (§ def #_"Keyword" CaseExpr'hashEquivKey (Keyword'intern-2 nil, "hash-equiv"))
    (§ def #_"Keyword" CaseExpr'intKey (Keyword'intern-2 nil, "int"))

    (defn- #_"CaseExpr" CaseExpr'init []
        (hash-map
            #_"LocalBindingExpr" :expr nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"int" :low 0
            #_"int" :high 0
            #_"Expr" :defaultExpr nil
            #_"SortedMap<Integer, Expr>" :tests nil
            #_"HashMap<Integer, Expr>" :thens nil
            #_"Keyword" :switchType nil
            #_"Keyword" :testType nil
            #_"Set<Integer>" :skipCheck nil
            #_"Class" :returnType nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (defn #_"CaseExpr" CaseExpr'new [#_"int" ___line, #_"int" ___column, #_"LocalBindingExpr" ___expr, #_"int" ___shift, #_"int" ___mask, #_"int" ___low, #_"int" ___high, #_"Expr" ___defaultExpr, #_"SortedMap<Integer, Expr>" ___tests, #_"HashMap<Integer, Expr>" ___thens, #_"Keyword" ___switchType, #_"Keyword" ___testType, #_"Set<Integer>" ___skipCheck]
        (let [this (CaseExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:shift this) ___shift)
            (§ ass (:mask this) ___mask)
            (§ ass (:low this) ___low)
            (§ ass (:high this) ___high)
            (§ ass (:defaultExpr this) ___defaultExpr)
            (§ ass (:tests this) ___tests)
            (§ ass (:thens this) ___thens)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (when (ß ___switchType != compactKey && ___switchType != sparseKey)
                (throw (IllegalArgumentException. (str "Unexpected switch type: " ___switchType)))
            )
            (§ ass (:switchType this) ___switchType)
            (when (ß ___testType != intKey && ___testType != hashEquivKey && ___testType != hashIdentityKey)
                (throw (IllegalArgumentException. (str "Unexpected test type: " ___switchType)))
            )
            (§ ass (:testType this) ___testType)
            (§ ass (:skipCheck this) ___skipCheck)
            (let [#_"Collection<Expr>" ___returns (ArrayList. (.values ___thens))]
                (.add ___returns, ___defaultExpr)
                (§ ass (:returnType this) (ß maybeJavaClass(___returns)))
                (when (ß RT'count(___skipCheck) > 0 && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", (object-array [ (deref Compiler'SOURCE_PATH), ___line, ___column ])))
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasJavaClass) [#_"CaseExpr" this]
        (ß ((:returnType this) != nil))
    )

    #_method
    (§ defn #_"boolean" (§ method canEmitPrimitive) [#_"CaseExpr" this]
        (Util'isPrimitive (:returnType this))
    )

    #_method
    (§ defn #_"Class" (§ method getJavaClass) [#_"CaseExpr" this]
        (:returnType this)
    )

    #_method
    (§ defn #_"Object" (§ method eval) [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_method
    (§ defn #_"void" (§ method emit) [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, false)
        nil
    )

    #_method
    (§ defn #_"void" (§ method emitUnboxed) [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (.doEmit this, ___context, ___objx, ___gen, true)
        nil
    )

    #_method
    (§ defn #_"void" (§ method doEmit) [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___defaultLabel (.newLabel ___gen)]
            (let [#_"Label" ___endLabel (.newLabel ___gen)]
                (let [#_"SortedMap<Integer, Label>" ___labels (TreeMap.)]
                    (doseq [#_"Integer" ___i (.keySet (:tests this))]
                        (ß ___labels.put(___i, (.newLabel ___gen)))
                    )

                    (ß ___gen.visitLineNumber((:line this), (.mark ___gen)))

                    (let [#_"Class" ___primExprClass (ß maybePrimitiveType((:expr this)))]
                        (let [#_"Type" ___primExprType (ß (nil? ___primExprClass) ? nil :or Type/getType(___primExprClass))]
                            (if (ß (:testType this) == intKey)
                                (do
                                    (.emitExprForInts this, ___objx, ___gen, ___primExprType, ___defaultLabel)
                                )
                                (do
                                    (.emitExprForHashes this, ___objx, ___gen)
                                )
                            )

                            (if (ß (:switchType this) == sparseKey)
                                (do
                                    (let [#_"Label[]" ___la (make-array Label (.size ___labels))]
                                        (§ ass ___la (ß (.values ___labels).toArray(___la)))
                                        (let [#_"int[]" ___ints (ß Numbers'int_array-1((:tests this).keySet()))]
                                            (.visitLookupSwitchInsn ___gen, ___defaultLabel, ___ints, ___la)
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Label[]" ___la (make-array Label (ß ((:high this) - (:low this)) + 1))]
                                        (loop-when-recur [#_"int" ___i (:low this)] (ß ___i <= (:high this)) [(inc ___i)]
                                            (§ ass (ß ___la[___i - (:low this)]) (if (ß ___labels.containsKey(___i)) (ß ___labels.get(___i)) ___defaultLabel))
                                        )
                                        (.visitTableSwitchInsn ___gen, (:low this), (:high this), ___defaultLabel, ___la)
                                    )
                                )
                            )

                            (doseq [#_"Integer" ___i (.keySet ___labels)]
                                (ß ___gen.mark(___labels.get(___i)))
                                (cond (ß (:testType this) == intKey)
                                    (do
                                        (ß this.emitThenForInts(___objx, ___gen, ___primExprType, (:tests this).get(___i), (:thens this).get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                    (ß RT'contains((:skipCheck this), ___i) == RT'T)
                                    (do
                                        (ß CaseExpr'emitExpr(___objx, ___gen, (:thens this).get(___i), ___emitUnboxed))
                                    )
                                    :else
                                    (do
                                        (ß this.emitThenForHashes(___objx, ___gen, (:tests this).get(___i), (:thens this).get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                )
                                (.goTo ___gen, ___endLabel)
                            )

                            (.mark ___gen, ___defaultLabel)
                            (CaseExpr'emitExpr ___objx, ___gen, (:defaultExpr this), ___emitUnboxed)
                            (.mark ___gen, ___endLabel)
                            (when (ß ___context == :Context'STATEMENT)
                                (.pop ___gen)
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method isShiftMasked) [#_"CaseExpr" this]
        (ß ((:mask this) != 0))
    )

    #_method
    (§ defn- #_"void" (§ method emitShiftMask) [#_"CaseExpr" this, #_"GeneratorAdapter" ___gen]
        (when (.isShiftMasked this)
            (.push ___gen, (:shift this))
            (.visitInsn ___gen, Opcodes/ISHR)
            (.push ___gen, (:mask this))
            (.visitInsn ___gen, Opcodes/IAND)
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitExprForInts) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Label" ___defaultLabel]
        (cond (nil? ___exprType)
            (do
                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", (object-array [ (deref Compiler'SOURCE_PATH), (:line this), (:column this) ])))
                )
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.instanceOf(CaseExpr'NUMBER_TYPE))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(CaseExpr'NUMBER_TYPE))
                (ß ___gen.invokeVirtual(CaseExpr'NUMBER_TYPE, intValueMethod))
                (.emitShiftMask this, ___gen)
            )
            (ß ___exprType == Type/LONG_TYPE || ___exprType == Type/INT_TYPE || ___exprType == Type/SHORT_TYPE || ___exprType == Type/BYTE_TYPE)
            (do
                (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.cast(___exprType, Type/INT_TYPE))
                (.emitShiftMask this, ___gen)
            )
            :else
            (do
                (.goTo ___gen, ___defaultLabel)
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitThenForInts) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (cond (nil? ___exprType)
            (do
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, equivMethod))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            (ß ___exprType == Type/LONG_TYPE)
            (do
                (ß (cast' NumberExpr ___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.ifCmp(Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel))
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            (ß ___exprType == Type/INT_TYPE || ___exprType == Type/SHORT_TYPE || ___exprType == Type/BYTE_TYPE)
            (do
                (when (.isShiftMasked this)
                    (ß (cast' NumberExpr ___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.cast(___exprType, Type/LONG_TYPE))
                    (ß ___gen.ifCmp(Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel))
                )
                ;; else direct match
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            :else
            (do
                (.goTo ___gen, ___defaultLabel)
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitExprForHashes) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, hashMethod))
        (.emitShiftMask this, ___gen)
        nil
    )

    #_method
    (§ defn- #_"void" (§ method emitThenForHashes) [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
        (if (ß (:testType this) == hashIdentityKey)
            (do
                (.visitJumpInsn ___gen, Opcodes/IF_ACMPNE, ___defaultLabel)
            )
            (do
                (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, equivMethod))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
            )
        )
        (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
        nil
    )

    (defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___expr, #_"boolean" ___emitUnboxed]
        (if (ß ___emitUnboxed && ___expr instanceof MaybePrimitiveExpr)
            (do
                (ß (cast' MaybePrimitiveExpr ___expr).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
            )
            (do
                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        nil
    )
)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" Compiler'DEF (Symbol'intern-1 "def"))
    (§ def #_"Symbol" Compiler'LOOP (Symbol'intern-1 "loop*"))
    (§ def #_"Symbol" Compiler'RECUR (Symbol'intern-1 "recur"))
    (§ def #_"Symbol" Compiler'IF (Symbol'intern-1 "if"))
    (§ def #_"Symbol" Compiler'LET (Symbol'intern-1 "let*"))
    (§ def #_"Symbol" Compiler'LETFN (Symbol'intern-1 "letfn*"))
    (§ def #_"Symbol" Compiler'DO (Symbol'intern-1 "do"))
    (§ def #_"Symbol" Compiler'FN (Symbol'intern-1 "fn*"))
    (§ def #_"Symbol" Compiler'FNONCE (ß (Symbol) Symbol'intern-1("fn*").withMeta(RT'map(Keyword'intern-2(nil, "once"), RT'T))))
    (§ def #_"Symbol" Compiler'QUOTE (Symbol'intern-1 "quote"))
    (§ def #_"Symbol" Compiler'THE_VAR (Symbol'intern-1 "var"))
    (§ def #_"Symbol" Compiler'DOT (Symbol'intern-1 "."))
    (§ def #_"Symbol" Compiler'ASSIGN (Symbol'intern-1 "set!"))
    (§ def #_"Symbol" Compiler'TRY (Symbol'intern-1 "try"))
    (§ def #_"Symbol" Compiler'CATCH (Symbol'intern-1 "catch"))
    (§ def #_"Symbol" Compiler'FINALLY (Symbol'intern-1 "finally"))
    (§ def #_"Symbol" Compiler'THROW (Symbol'intern-1 "throw"))
    (§ def #_"Symbol" Compiler'MONITOR_ENTER (Symbol'intern-1 "monitor-enter"))
    (§ def #_"Symbol" Compiler'MONITOR_EXIT (Symbol'intern-1 "monitor-exit"))
    (§ def #_"Symbol" Compiler'IMPORT (Symbol'intern-2 "cloiure.core", "import*"))
    (§ def #_"Symbol" Compiler'DEFTYPE (Symbol'intern-1 "deftype*"))
    (§ def #_"Symbol" Compiler'CASE (Symbol'intern-1 "case*"))

    (§ def #_"Symbol" Compiler'CLASS (Symbol'intern-1 "Class"))
    (§ def #_"Symbol" Compiler'NEW (Symbol'intern-1 "new"))
    (§ def #_"Symbol" Compiler'THIS (Symbol'intern-1 "this"))
    (§ def #_"Symbol" Compiler'REIFY (Symbol'intern-1 "reify*"))
    (§ def #_"Symbol" Compiler'LIST (Symbol'intern-2 "cloiure.core", "list"))
    (§ def #_"Symbol" Compiler'HASHMAP (Symbol'intern-2 "cloiure.core", "hash-map"))
    (§ def #_"Symbol" Compiler'VECTOR (Symbol'intern-2 "cloiure.core", "vector"))
    (§ def #_"Symbol" Compiler'IDENTITY (Symbol'intern-2 "cloiure.core", "identity"))

    (§ def #_"Symbol" Compiler'_AMP_ (Symbol'intern-1 "&"))
    (§ def #_"Symbol" Compiler'ISEQ (Symbol'intern-1 "cloiure.lang.ISeq"))

    (§ def #_"Keyword" Compiler'loadNs (Keyword'intern-2 nil, "load-ns"))
    (§ def #_"Keyword" Compiler'inlineKey (Keyword'intern-2 nil, "inline"))
    (§ def #_"Keyword" Compiler'inlineAritiesKey (Keyword'intern-2 nil, "inline-arities"))
    (§ def #_"Keyword" Compiler'staticKey (Keyword'intern-2 nil, "static"))
    (§ def #_"Keyword" Compiler'arglistsKey (Keyword'intern-2 nil, "arglists"))
    (§ def #_"Symbol" Compiler'INVOKE_STATIC (Symbol'intern-1 "invokeStatic"))

    (§ def #_"Keyword" Compiler'volatileKey (Keyword'intern-2 nil, "volatile"))
    (§ def #_"Keyword" Compiler'implementsKey (Keyword'intern-2 nil, "implements"))
    (def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" Compiler'protocolKey (Keyword'intern-2 nil, "protocol"))
    (§ def #_"Keyword" Compiler'onKey (Keyword'intern-2 nil, "on"))
    (§ def #_"Keyword" Compiler'dynamicKey (Keyword'intern-1 "dynamic"))
    (§ def #_"Keyword" Compiler'redefKey (Keyword'intern-2 nil, "redef"))

    (§ def #_"Symbol" Compiler'NS (Symbol'intern-1 "ns"))
    (§ def #_"Symbol" Compiler'IN_NS (Symbol'intern-1 "in-ns"))

    (def #_"IPersistentMap" Compiler'specials (ß PersistentHashMap'create-1a(
        (object-array [
            Compiler'DEF           (DefParser'new)
            Compiler'LOOP          (LetParser'new)
            Compiler'RECUR         (RecurParser'new)
            Compiler'IF            (IfParser'new)
            Compiler'CASE          (CaseParser'new)
            Compiler'LET           (LetParser'new)
            Compiler'LETFN         (LetFnParser'new)
            Compiler'DO            (BodyParser'new)
            Compiler'FN            nil
            Compiler'QUOTE         (ConstantParser'new)
            Compiler'THE_VAR       (TheVarParser'new)
            Compiler'IMPORT        (ImportParser'new)
            Compiler'DOT           (HostParser'new)
            Compiler'ASSIGN        (AssignParser'new)
            Compiler'DEFTYPE       (DeftypeParser'new)
            Compiler'REIFY         (ReifyParser'new)
            Compiler'TRY           (TryParser'new)
            Compiler'THROW         (ThrowParser'new)
            Compiler'MONITOR_ENTER (MonitorEnterParser'new)
            Compiler'MONITOR_EXIT  (MonitorExitParser'new)
            Compiler'CATCH         nil
            Compiler'FINALLY       nil
            Compiler'NEW           (NewParser'new)
            Compiler'_AMP_         nil
        ])
    )))

    (def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)

    (def #_"Type" Compiler'CLASS_TYPE (Type/getType Class))
    (def #_"Type" Compiler'OBJECT_TYPE (Type/getType Object))
    (def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (Type/getType Boolean))
    (def #_"Type" Compiler'THROWABLE_TYPE (Type/getType Throwable))

    (def- #_"Type" Compiler'KEYWORD_TYPE (ß Type/getType((§ class Keyword))))
    (def- #_"Type" Compiler'VAR_TYPE (ß Type/getType((§ class Var))))
    (def- #_"Type" Compiler'SYMBOL_TYPE (ß Type/getType((§ class Symbol))))
    (def- #_"Type" Compiler'IFN_TYPE (ß Type/getType((§ class IFn))))
    (def- #_"Type" Compiler'AFUNCTION_TYPE (ß Type/getType((§ class AFunction))))
    (def- #_"Type" Compiler'RT_TYPE (ß Type/getType((§ class RT))))
    (def- #_"Type" Compiler'NUMBERS_TYPE (ß Type/getType((§ class Numbers))))

    (def #_"Type" Compiler'NS_TYPE (ß Type/getType((§ class Namespace))))
    (def #_"Type" Compiler'UTIL_TYPE (ß Type/getType((§ class Util))))
    (def #_"Type" Compiler'REFLECTOR_TYPE (ß Type/getType((§ class Reflector))))
    (def #_"Type" Compiler'IPERSISTENTMAP_TYPE (ß Type/getType((§ class IPersistentMap))))
    (def #_"Type" Compiler'IOBJ_TYPE (ß Type/getType((§ class IObj))))
    (def #_"Type" Compiler'TUPLE_TYPE (ß Type/getType((§ class Tuple))))

    (def #_"Method[]" Compiler'createTupleMethods
        (object-array [
            (Method/getMethod "cloiure.lang.IPersistentVector create()")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object, Object)")
        ])
    )

    (def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (def- #_"Type[]" Compiler'EXCEPTION_TYPES (object-array 0))

    (§ static
        (§ ass Compiler'ARG_TYPES (ß new Type[Compiler'MAX_POSITIONAL_ARITY + 2][]))
        (loop-when-recur [#_"int" ___i 0] (ß ___i <= Compiler'MAX_POSITIONAL_ARITY) [(inc ___i)]
            (let [#_"Type[]" ___a (make-array Type ___i)]
                (loop-when-recur [#_"int" ___j 0] (< ___j ___i) [(inc ___j)]
                    (§ ass (ß ___a[___j]) Compiler'OBJECT_TYPE)
                )
                (§ ass (ß Compiler'ARG_TYPES[___i]) ___a)
            )
        )
        (let [#_"Type[]" ___a (make-array Type (ß Compiler'MAX_POSITIONAL_ARITY + 1))]
            (loop-when-recur [#_"int" ___j 0] (ß ___j < Compiler'MAX_POSITIONAL_ARITY) [(inc ___j)]
                (§ ass (ß ___a[___j]) Compiler'OBJECT_TYPE)
            )
            (§ ass (ß ___a[Compiler'MAX_POSITIONAL_ARITY]) (Type/getType "[Ljava/lang/Object;"))
            (§ ass (ß Compiler'ARG_TYPES[Compiler'MAX_POSITIONAL_ARITY + 1]) ___a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" Compiler'LOCAL_ENV (ß Var'create-1(nil).setDynamic()))

    ;; vector<localbinding>
    (§ def #_"Var" Compiler'LOOP_LOCALS (ß Var'create-0().setDynamic()))

    ;; Label
    (§ def #_"Var" Compiler'LOOP_LABEL (ß Var'create-0().setDynamic()))

    ;; vector<object>
    (§ def #_"Var" Compiler'CONSTANTS (ß Var'create-0().setDynamic()))

    ;; IdentityHashMap
    (§ def #_"Var" Compiler'CONSTANT_IDS (ß Var'create-0().setDynamic()))

    ;; vector<keyword>
    (§ def #_"Var" Compiler'KEYWORD_CALLSITES (ß Var'create-0().setDynamic()))

    ;; vector<var>
    (§ def #_"Var" Compiler'PROTOCOL_CALLSITES (ß Var'create-0().setDynamic()))

    ;; set<var>
    (§ def #_"Var" Compiler'VAR_CALLSITES (ß Var'create-0().setDynamic()))

    ;; keyword->constid
    (§ def #_"Var" Compiler'KEYWORDS (ß Var'create-0().setDynamic()))

    ;; var->constid
    (§ def #_"Var" Compiler'VARS (ß Var'create-0().setDynamic()))

    ;; FnFrame
    (§ def #_"Var" Compiler'METHOD (ß Var'create-1(nil).setDynamic()))

    ;; nil or not
    (§ def #_"Var" Compiler'IN_CATCH_FINALLY (ß Var'create-1(nil).setDynamic()))

    (§ def #_"Var" Compiler'METHOD_RETURN_CONTEXT (ß Var'create-1(nil).setDynamic()))

    (§ def #_"Var" Compiler'NO_RECUR (ß Var'create-1(nil).setDynamic()))

    ;; DynamicClassLoader
    (§ def #_"Var" Compiler'LOADER (ß Var'create-0().setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*source-path*"), "NO_SOURCE_FILE").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE_PATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*file*"), "NO_SOURCE_PATH").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'COMPILE_PATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compile-path*"), nil).setDynamic()))
    ;; boolean
    (§ def #_"Var" Compiler'COMPILE_FILES (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compile-files*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Var" Compiler'INSTANCE (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("instance?"))))

    (§ def #_"Var" Compiler'ADD_ANNOTATIONS (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("add-annotations"))))

    (§ def #_"Keyword" Compiler'disableLocalsClearingKey (Keyword'intern-1 "disable-locals-clearing"))
    (§ def #_"Keyword" Compiler'directLinkingKey (Keyword'intern-1 "direct-linking"))
    (§ def #_"Keyword" Compiler'elideMetaKey (Keyword'intern-1 "elide-meta"))

    (def #_"Var" Compiler'COMPILER_OPTIONS nil)

    (defn #_"Object" Compiler'getCompilerOption [#_"Keyword" ___k]
        (ß RT'get-2(Compiler'COMPILER_OPTIONS.deref(), ___k))
    )

    (§ static
        (let [#_"Object" ___compilerOptions nil]
            (doseq [#_"Map$Entry" ___e (ß System/getProperties().entrySet())]
                (let [#_"String" ___name (ß (String) (.getKey ___e))]
                    (let [#_"String" ___v (ß (String) (.getValue ___e))]
                        (when (.startsWith ___name, "cloiure.compiler.")
                            (§ ass ___compilerOptions (ß RT'assoc(___compilerOptions, RT'keyword(nil, ___name.substring(1 + ___name.lastIndexOf(\.))), RT'readString-1(___v))))
                        )
                    )
                )
            )

            (§ ass Compiler'COMPILER_OPTIONS (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compiler-options*"), ___compilerOptions).setDynamic()))
        )
    )

    (defn #_"Object" Compiler'elideMeta [#_"Object" ___m]
        (let [#_"Collection<Object>" ___elides (ß (Collection<Object>) Compiler'getCompilerOption(elideMetaKey))]
            (when (some? ___elides)
                (doseq [#_"Object" ___k ___elides]
                    (§ ass ___m (RT'dissoc ___m, ___k))
                )
            )
            ___m
        )
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN (ß Var'create-1(0).setDynamic()))

    (defn #_"int" Compiler'lineDeref []
        (ß ((Number)Compiler'LINE.deref()).intValue())
    )

    (defn #_"int" Compiler'columnDeref []
        (ß ((Number)Compiler'COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE_BEFORE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_BEFORE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'LINE_AFTER (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_AFTER (ß Var'create-1(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'NEXT_LOCAL_NUM (ß Var'create-1(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'RET_LOCAL_NUM (ß Var'create-0().setDynamic()))

    (§ def #_"Var" Compiler'COMPILE_STUB_SYM (ß Var'create-1(nil).setDynamic()))
    (§ def #_"Var" Compiler'COMPILE_STUB_CLASS (ß Var'create-1(nil).setDynamic()))

    ;; PathNode chain
    (§ def #_"Var" Compiler'CLEAR_PATH (ß Var'create-1(nil).setDynamic()))

    ;; tail of PathNode chain
    (§ def #_"Var" Compiler'CLEAR_ROOT (ß Var'create-1(nil).setDynamic()))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" Compiler'CLEAR_SITES (ß Var'create-1(nil).setDynamic()))

    (def #_"Class" Compiler'RECUR_CLASS (§ class Recur))

    (defn #_"boolean" Compiler'isSpecial [#_"Object" ___sym]
        (.containsKey Compiler'specials, ___sym)
    )

    (defn #_"boolean" Compiler'inTailCall [#_"Context" ___context]
        (ß (___context == :Context'RETURN) && (Compiler'METHOD_RETURN_CONTEXT.deref() != nil) && (Compiler'IN_CATCH_FINALLY.deref() == nil))
    )

    (defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" ___sym]
        ;; already qualified or classname?
        (when (ß (:name ___sym).indexOf(\.) > 0)
            (§ return ___sym)
        )
        (when (ß (:ns ___sym) != nil)
            (let [#_"Namespace" ___ns (ß namespaceFor(___sym))]
                (when (ß ___ns == nil || (((:name (:name ___ns)) == nil) ? ((:ns ___sym) == nil) :or (:name (:name ___ns)).equals((:ns ___sym))))
                    (§ return ___sym)
                )
                (§ return (ß Symbol'intern-2((:name (:name ___ns)), (:name ___sym))))
            )
        )
        (let [#_"Object" ___o (ß (.currentNS this).getMapping(___sym))]
            (cond (nil? ___o)
                (do
                    (§ return (ß Symbol'intern-2((:name (:name (.currentNS this))), (:name ___sym))))
                )
                (ß ___o instanceof Class)
                (do
                    (§ return (ß Symbol'intern-2(nil, (cast Class ___o).getName())))
                )
                (ß ___o instanceof Var)
                (do
                    (let [#_"Var" ___v (ß (Var) ___o)]
                        (§ return (ß Symbol'intern-2((:name (:name (:ns ___v))), (:name (:sym ___v)))))
                    )
                )
            )
            nil
        )
    )

    (defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" ___e]
        (when (ß ___e instanceof MaybePrimitiveExpr && (.hasJavaClass ___e) && (cast' MaybePrimitiveExpr ___e).canEmitPrimitive())
            (let [#_"Class" ___c (.getJavaClass ___e)]
                (when (Util'isPrimitive ___c)
                    (§ return ___c)
                )
            )
        )
        nil
    )

    (defn #_"Class" Compiler'maybeJavaClass [#_"Collection<Expr>" ___exprs]
        (let [#_"Class" ___match nil]
            (try
                (doseq [#_"Expr" ___e ___exprs]
                    (when (ß ___e instanceof ThrowExpr)
                        (§ continue )
                    )
                    (when (not (ß ___e.hasJavaClass()))
                        (§ return nil)
                    )
                    (let [#_"Class" ___c (.getJavaClass ___e)]
                        (cond (nil? ___match)
                            (do
                                (§ ass ___match ___c)
                            )
                            (ß ___match != ___c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception ___e
                    (§ return nil)
                )
            )
            ___match
        )
    )

    (§ def #_"NilExpr" Compiler'NIL_EXPR (NilExpr'new))

    (§ def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr'new true))
    (§ def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr'new false))

    (defn #_"boolean" Compiler'subsumes [#_"Class[]" ___c1, #_"Class[]" ___c2]
        ;; presumes matching lengths
        (let [#_"Boolean" ___better false]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___c1.length) [(inc ___i)]
                (when (ß ___c1[___i] != ___c2[___i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (or (and (not (ß ___c1[___i].isPrimitive())) (ß ___c2[___i].isPrimitive())) (ß ___c2[___i].isAssignableFrom(___c1[___i])))
                        (do
                            (§ ass ___better true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            ___better
        )
    )

    (defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" ___args]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___args)) [(inc ___i)]
                (let [#_"Expr" ___arg (ß (Expr) ___args.nth(___i))]
                    (when (> ___i 0)
                        (.append ___sb, ", ")
                    )
                    (ß ___sb.append(((.hasJavaClass ___arg) && (.getJavaClass ___arg) != nil) ? (.getJavaClass ___arg).getName() :or "unknown"))
                )
            )
            (.toString ___sb)
        )
    )

    (defn #_"int" Compiler'getMatchingParams [#_"String" ___methodName, #_"ArrayList<Class[]>" ___paramlists, #_"IPersistentVector" ___argexprs, #_"List<Class>" ___rets]
        ;; presumes matching lengths
        (let [#_"int" ___matchIdx -1]
            (let [#_"boolean" ___tied false]
                (let [#_"boolean" ___foundExact false]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___paramlists)) [(inc ___i)]
                        (let [#_"boolean" ___match true]
                            (let [#_"ISeq" ___aseq (.seq ___argexprs)]
                                (let [#_"int" ___exact 0]
                                    (loop-when-recur [#_"int" ___p 0 ___aseq ___aseq] (ß ___match && ___p < (count ___argexprs) && ___aseq != nil) [(inc ___p) (next ___aseq)]
                                        (let [#_"Expr" ___arg (ß (Expr) (first ___aseq))]
                                            (let [#_"Class" ___aclass (if (.hasJavaClass ___arg) (.getJavaClass ___arg) Object)]
                                                (let [#_"Class" ___pclass (ß ___paramlists.get(___i)[___p])]
                                                    (if (ß (.hasJavaClass ___arg) && ___aclass == ___pclass)
                                                        (do
                                                            (§ ass ___exact (inc ___exact))
                                                        )
                                                        (do
                                                            (§ ass ___match (Reflector'paramArgTypeMatch ___pclass, ___aclass))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß ___exact == (count ___argexprs))
                                        (do
                                            (when (ß (not ___foundExact) || ___matchIdx == -1 || ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                (§ ass ___matchIdx ___i)
                                            )
                                            (§ ass ___tied false)
                                            (§ ass ___foundExact true)
                                        )
                                        (and ___match (not ___foundExact))
                                        (do
                                            (if (ß ___matchIdx == -1)
                                                (do
                                                    (§ ass ___matchIdx ___i)
                                                )
                                                (do
                                                    (cond (ß subsumes(___paramlists.get(___i), ___paramlists.get(___matchIdx)))
                                                        (do
                                                            (§ ass ___matchIdx ___i)
                                                            (§ ass ___tied false)
                                                        )
                                                        (ß Arrays/equals(___paramlists.get(___matchIdx), ___paramlists.get(___i)))
                                                        (do
                                                            (when (ß ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                                (§ ass ___matchIdx ___i)
                                                            )
                                                        )
                                                        (not (ß subsumes(___paramlists.get(___matchIdx), ___paramlists.get(___i))))
                                                        (do
                                                            (§ ass ___tied true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when ___tied
                        (throw (IllegalArgumentException. (str "More than one matching method found: " ___methodName)))
                    )

                    ___matchIdx
                )
            )
        )
    )

    (def #_"IPersistentMap" Compiler'CHAR_MAP (ß PersistentHashMap'create-1a(
        (object-array [
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        ])
    )))

    (def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" ___m (ß RT'map("$", \/))]
            (loop-when-recur [#_"ISeq" ___s (RT'seq Compiler'CHAR_MAP)] (some? ___s) [(next ___s)]
                (let [#_"IMapEntry" ___e (ß (IMapEntry) (first ___s))]
                    (let [#_"Character" ___origCh (ß (Character) (.key ___e))]
                        (let [#_"String" ___escapeStr (ß (String) (.val ___e))]
                            (§ ass ___m (.assoc ___m, ___escapeStr, ___origCh))
                        )
                    )
                )
            )
            (§ ass Compiler'DEMUNGE_MAP ___m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired. Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" ___mungeStrs (ß RT'toArray(RT'keys(___m)))]
                (ß Arrays/sort(___mungeStrs,
                        (§ reify Comparator()
                            #_method
                            (§ defn #_"int" (§ method compare) [#_"Comparator" this, #_"Object" ___s1, #_"Object" ___s2]
                                (ß (cast String ___s2).length() - (cast String ___s1).length())
                            )
                        )
                    )
                )
                (let [#_"StringBuilder" ___sb (StringBuilder.)]
                    (let [#_"boolean" ___first true]
                        (doseq [#_"Object" ___s ___mungeStrs]
                            (let [#_"String" ___escapeStr (ß (String) ___s)]
                                (when (not ___first)
                                    (.append ___sb, "|")
                                )
                                (§ ass ___first false)
                                (.append ___sb, "\\Q")
                                (.append ___sb, ___escapeStr)
                                (.append ___sb, "\\E")
                            )
                        )
                        (§ ass Compiler'DEMUNGE_PATTERN (ß Pattern/compile((.toString ___sb))))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'munge [#_"String" ___name]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (doseq [#_"char" ___c (.toCharArray ___name)]
                (let [#_"String" ___sub (cast String (.valAt Compiler'CHAR_MAP, ___c))]
                    (if (some? ___sub)
                        (do
                            (.append ___sb, ___sub)
                        )
                        (do
                            (.append ___sb, ___c)
                        )
                    )
                )
            )
            (.toString ___sb)
        )
    )

    (defn #_"String" Compiler'demunge [#_"String" ___mungedName]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Matcher" ___m (ß Compiler'DEMUNGE_PATTERN.matcher(___mungedName))]
                (let [#_"int" ___lastMatchEnd 0]
                    (while (.find ___m)
                        (let [#_"int" ___start (.start ___m)]
                            (let [#_"int" ___end (.end ___m)]
                                ;; Keep everything before the match
                                (ß ___sb.append(___mungedName.substring(___lastMatchEnd, ___start)))
                                (§ ass ___lastMatchEnd ___end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" ___origCh (cast Character (.valAt Compiler'DEMUNGE_MAP, (.group ___m)))]
                                    (.append ___sb, ___origCh)
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß ___sb.append(___mungedName.substring(___lastMatchEnd)))
                    (.toString ___sb)
                )
            )
        )
    )

    (defn #_"PathNode" Compiler'clearPathRoot []
        (ß (PathNode) Compiler'CLEAR_ROOT.get())
    )

    (defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg]
        (let [#_"int" ___num (ß getAndIncLocalNum())]
            (let [#_"LocalBinding" ___b (ß LocalBinding'new(___num, ___sym, ___tag, ___init, ___isArg, clearPathRoot()))]
                (let [#_"IPersistentMap" ___localsMap (ß (IPersistentMap) Compiler'LOCAL_ENV.deref())]
                    (ß Compiler'LOCAL_ENV.set(RT'assoc(___localsMap, (:sym ___b), ___b)))
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (§ ass (:locals ___method) (ß (IPersistentMap) RT'assoc((:locals ___method), ___b, ___b)))
                        (§ ass (:indexlocals ___method) (ß (IPersistentMap) RT'assoc((:indexlocals ___method), ___num, ___b)))
                        ___b
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" ___num (ß ((Number) Compiler'NEXT_LOCAL_NUM.deref()).intValue())]
            (let [#_"ObjMethod" ___m (ß (ObjMethod) Compiler'METHOD.deref())]
                (when (ß ___num > (:maxLocal ___m))
                    (§ ass (:maxLocal ___m) ___num)
                )
                (ß Compiler'NEXT_LOCAL_NUM.set(___num + 1))
                ___num
            )
        )
    )

    (defn #_"Expr" Compiler'analyze-2 [#_"Context" ___context, #_"Object" ___form]
        (ß analyze(___context, ___form, nil))
    )

    (defn- #_"Expr" Compiler'analyze-3 [#_"Context" ___context, #_"Object" ___form, #_"String" ___name]
        ;; todo symbol macro expansion?
        (try
            (when (ß ___form instanceof LazySeq)
                (let [#_"Object" ___mform ___form]
                    (§ ass ___form (RT'seq ___form))
                    (when (nil? ___form)
                        (§ ass ___form PersistentList'EMPTY)
                    )
                    (§ ass ___form (ß (cast' IObj ___form).withMeta(RT'meta(___mform))))
                )
            )
            (cond (nil? ___form)
                (do
                    (§ return Compiler'NIL_EXPR)
                )
                (ß ___form == Boolean/TRUE)
                (do
                    (§ return Compiler'TRUE_EXPR)
                )
                (ß ___form == Boolean/FALSE)
                (do
                    (§ return Compiler'FALSE_EXPR)
                )
            )
            (let [#_"Class" ___fclass (.getClass ___form)]
                (cond (ß ___fclass == (§ class Symbol))
                    (do
                        (§ return (ß analyzeSymbol((cast' Symbol ___form))))
                    )
                    (ß ___fclass == (§ class Keyword))
                    (do
                        (§ return (ß registerKeyword((cast' Keyword ___form))))
                    )
                    (ß ___form instanceof Number)
                    (do
                        (§ return (ß NumberExpr'parse((cast Number ___form))))
                    )
                    (ß ___fclass == (§ class String))
                    (do
                        (§ return (StringExpr'new (.intern (cast String ___form))))
                    )
                    (ß ___form instanceof IPersistentCollection && (not (___form instanceof IRecord)) && (not (___form instanceof IType)) && (cast' IPersistentCollection ___form).count() == 0)
                    (do
                        (let [#_"Expr" ___ret (EmptyExpr'new ___form)]
                            (when (ß RT'meta(___form) != nil)
                                (§ ass ___ret (MetaExpr'new ___ret, (MapExpr'parse (if (= ___context :Context'EVAL) ___context :Context'EXPRESSION), (ß (cast' IObj ___form).meta()))))
                            )
                            (§ return ___ret)
                        )
                    )
                    (ß ___form instanceof ISeq)
                    (do
                        (§ return (ß analyzeSeq(___context, (ISeq) ___form, ___name)))
                    )
                    (ß ___form instanceof IPersistentVector)
                    (do
                        (§ return (ß VectorExpr'parse(___context, (IPersistentVector) ___form)))
                    )
                    (ß ___form instanceof IRecord)
                    (do
                        (§ return (ConstantExpr'new ___form))
                    )
                    (ß ___form instanceof IType)
                    (do
                        (§ return (ConstantExpr'new ___form))
                    )
                    (ß ___form instanceof IPersistentMap)
                    (do
                        (§ return (ß MapExpr'parse(___context, (IPersistentMap) ___form)))
                    )
                    (ß ___form instanceof IPersistentSet)
                    (do
                        (§ return (ß SetExpr'parse(___context, (IPersistentSet) ___form)))
                    )
                )

                (ConstantExpr'new ___form)
            )
            (catch Throwable ___e
                (if (not (ß ___e instanceof CompilerException))
                    (do
                        (throw (ß CompilerException'new((String) Compiler'SOURCE_PATH.deref(), Compiler'lineDeref(), Compiler'columnDeref(), ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    (defn #_"Var" Compiler'isMacro [#_"Object" ___op]
        ;; no local macros for now
        (when (ß ___op instanceof Symbol && referenceLocal((cast' Symbol ___op)) != nil)
            (§ return nil)
        )
        (when (ß ___op instanceof Symbol || ___op instanceof Var)
            (let [#_"Var" ___v (if (ß ___op instanceof Var) (cast' Var ___op) (Compiler'lookupVar-3 (cast' Symbol ___op), false, false))]
                (when (ß ___v != nil && (.isMacro ___v))
                    (when (ß (:ns ___v) != (.currentNS this) && (not (ß ___v.isPublic())))
                        (throw (IllegalStateException. (str "var: " ___v " is not public")))
                    )
                    (§ return ___v)
                )
            )
        )
        nil
    )

    (defn #_"IFn" Compiler'isInline [#_"Object" ___op, #_"int" ___arity]
        ;; no local inlines for now
        (when (ß ___op instanceof Symbol && referenceLocal((cast' Symbol ___op)) != nil)
            (§ return nil)
        )
        (when (ß ___op instanceof Symbol || ___op instanceof Var)
            (let [#_"Var" ___v (if (ß ___op instanceof Var) (cast' Var ___op) (Compiler'lookupVar-2 (cast' Symbol ___op), false))]
                (when (some? ___v)
                    (when (ß (:ns ___v) != (.currentNS this) && (not (ß ___v.isPublic())))
                        (throw (IllegalStateException. (str "var: " ___v " is not public")))
                    )
                    (let [#_"IFn" ___ret (ß (IFn) RT'get-2((.meta ___v), inlineKey))]
                        (when (some? ___ret)
                            (let [#_"IFn" ___arityPred (ß (IFn) RT'get-2((.meta ___v), inlineAritiesKey))]
                                (when (ß ___arityPred == nil || RT'booleanCast-1o(___arityPred.invoke(___arity)))
                                    (§ return ___ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" ___sym]
        (ß ((:ns ___sym) != nil && namespaceFor(___sym) == nil))
    )

    (defn #_"Object" Compiler'preserveTag [#_"ISeq" ___src, #_"Object" ___dst]
        (let [#_"Symbol" ___tag (ß tagOf(___src))]
            (when (ß ___tag != nil && ___dst instanceof IObj)
                (let [#_"IPersistentMap" ___meta (RT'meta ___dst)]
                    (§ return (ß (cast' IObj ___dst).withMeta((IPersistentMap) RT'assoc(___meta, RT'TAG_KEY, ___tag))))
                )
            )
            ___dst
        )
    )

    #_volatile
    (def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (defn- #_"Var" Compiler'ensureMacroCheck [] #_(§ throws ClassNotFoundException, IOException)
        (when (nil? Compiler'MACRO_CHECK)
            (§ sync Compiler'MACRO_CHECK_LOCK
                (when (nil? Compiler'MACRO_CHECK)
                    (§ ass Compiler'MACRO_CHECK_LOADING true)
                    (RT'load-1 "cloiure/spec/alpha")
                    (RT'load-1 "cloiure/core/specs/alpha")
                    (§ ass Compiler'MACRO_CHECK (ß Var'find(Symbol'intern-2("cloiure.spec.alpha", "macroexpand-check"))))
                    (§ ass Compiler'MACRO_CHECK_LOADING false)
                )
            )
        )
        Compiler'MACRO_CHECK
    )

    (defn #_"void" Compiler'checkSpecs [#_"Var" ___v, #_"ISeq" ___form]
        (when (ß RT'CHECK_SPECS && (not Compiler'MACRO_CHECK_LOADING))
            (try
                (ß ensureMacroCheck().applyTo(RT'cons(___v, RT'list-1((next ___form)))))
                (catch Exception ___e
                    (throw (ß CompilerException'new((String) Compiler'SOURCE_PATH.deref(), Compiler'lineDeref(), Compiler'columnDeref(), ___e)))
                )
            )
        )
        nil
    )

    (defn #_"Object" Compiler'macroexpand1 [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (let [#_"ISeq" ___form (ß (ISeq) ___x)]
                (let [#_"Object" ___op (RT'first ___form)]
                    (when (ß isSpecial(___op))
                        (§ return ___x)
                    )
                    ;; macro expansion
                    (let [#_"Var" ___v (Compiler'isMacro ___op)]
                        (if (some? ___v)
                            (do
                                (ß checkSpecs(___v, ___form))

                                (try
                                    (let [#_"ISeq" ___args (ß RT'cons(___form, RT'cons(Compiler'LOCAL_ENV.get(), (next ___form))))]
                                        (§ return (.applyTo ___v, ___args))
                                    )
                                    (§ catch ArityException ___e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß ArityException'new-2((:actual ___e) - 2, (:name ___e))))
                                    )
                                )
                            )
                            (do
                                (when (ß ___op instanceof Symbol)
                                    (let [#_"Symbol" ___sym (ß (Symbol) ___op)]
                                        (let [#_"String" ___sname (:name ___sym)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß (:name ___sym).charAt(0) == \.)
                                                (do
                                                    (when (ß RT'length(___form) < 2)
                                                        (throw (IllegalArgumentException. "Malformed member expression, expecting (.member target ...)"))
                                                    )
                                                    (let [#_"Symbol" ___meth (ß Symbol'intern-1(___sname.substring(1)))]
                                                        (let [#_"Object" ___target (RT'second ___form)]
                                                            (when (ß HostExpr'maybeClass(___target, false) != nil)
                                                                (§ ass ___target (ß ((IObj)RT'list-2(Compiler'IDENTITY, ___target)).withMeta(RT'map(RT'TAG_KEY, Compiler'CLASS))))
                                                            )
                                                            (§ return (ß preserveTag(___form, RT'listStar-4(Compiler'DOT, ___target, ___meth, (next ___form).next()))))
                                                        )
                                                    )
                                                )
                                                (ß namesStaticMember(___sym))
                                                (do
                                                    (let [#_"Symbol" ___target (ß Symbol'intern-1((:ns ___sym)))]
                                                        (let [#_"Class" ___c (HostExpr'maybeClass ___target, false)]
                                                            (when (some? ___c)
                                                                (let [#_"Symbol" ___meth (ß Symbol'intern-1((:name ___sym)))]
                                                                    (§ return (ß preserveTag(___form, RT'listStar-4(Compiler'DOT, ___target, ___meth, (next ___form)))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" ___idx (.lastIndexOf ___sname, \.)]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß ___idx == (.length ___sname) - 1)
                                                            (§ return (ß RT'listStar-3(Compiler'NEW, Symbol'intern-1(___sname.substring(0, ___idx)), (next ___form))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        ___x
    )

    (defn #_"Object" Compiler'macroexpand [#_"Object" ___form]
        (let [#_"Object" ___exf (ß macroexpand1(___form))]
            (when (ß ___exf != ___form)
                (§ return (ß macroexpand(___exf)))
            )
            ___form
        )
    )

    (defn- #_"Expr" Compiler'analyzeSeq [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"Object" ___line (ß Compiler'lineDeref())]
            (let [#_"Object" ___column (ß Compiler'columnDeref())]
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(Compiler'LINE, ___line, Compiler'COLUMN, ___column)))
                (try
                    (let [#_"Object" ___me (ß macroexpand1(___form))]
                        (when (ß ___me != ___form)
                            (§ return (ß analyze(___context, ___me, ___name)))
                        )

                        (let [#_"Object" ___op (RT'first ___form)]
                            (when (nil? ___op)
                                (throw (IllegalArgumentException. (str "Can't call nil, form: " ___form)))
                            )
                            (let [#_"IFn" ___inline (ß isInline(___op, RT'count(RT'next(___form))))]
                                (when (some? ___inline)
                                    (§ return (ß analyze(___context, preserveTag(___form, ___inline.applyTo(RT'next(___form))))))
                                )
                                (§ let [#_"IParser" ___p]
                                    (cond (ß ___op.equals(Compiler'FN))
                                        (do
                                            (FnExpr'parse ___context, ___form, ___name)
                                        )
                                        (some? (§ ass ___p (ß (IParser) Compiler'specials.valAt(___op))))
                                        (do
                                            (.parse ___p, ___context, ___form)
                                        )
                                        :else
                                        (do
                                            (InvokeExpr'parse ___context, ___form)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable ___e
                        (if (not (ß ___e instanceof CompilerException))
                            (do
                                (throw (ß CompilerException'new((String) Compiler'SOURCE_PATH.deref(), Compiler'lineDeref(), Compiler'columnDeref(), ___e)))
                            )
                            (do
                                (throw (ß (CompilerException) ___e))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'errorMsg [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"String" ___s]
        (String/format "%s, compiling:(%s:%d:%d)", (object-array [ ___s, ___source, ___line, ___column ]))
    )

    (defn #_"Object" Compiler'eval-1 [#_"Object" ___form]
        (Compiler'eval-2 ___form, true)
    )

    (defn #_"Object" Compiler'eval-2 [#_"Object" ___form, #_"boolean" ___freshLoader]
        (let [#_"boolean" ___createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var'pushThreadBindings(RT'map(Compiler'LOADER, RT'makeClassLoader())))
                (§ ass ___createdLoader true)
            )
            (try
                (let [#_"Object" ___line (ß Compiler'lineDeref())]
                    (let [#_"Object" ___column (ß Compiler'columnDeref())]
                        (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                            (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                        )
                        (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                            (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                        )
                        (ß Var'pushThreadBindings(RT'map(Compiler'LINE, ___line, Compiler'COLUMN, ___column)))
                        (try
                            (§ ass ___form (ß macroexpand(___form)))
                            (cond (ß ___form instanceof ISeq && Util'equals(RT'first(___form), Compiler'DO))
                                (do
                                    (let [#_"ISeq" ___s (RT'next ___form)]
                                        (loop-when-recur [___s ___s] (ß RT'next(___s) != nil) [(RT'next ___s)]
                                            (ß Compiler'eval-2(RT'first(___s), false))
                                        )
                                        (ß Compiler'eval-2(RT'first(___s), false))
                                    )
                                )
                                (ß (___form instanceof IType) || (___form instanceof IPersistentCollection && (not (ß RT'first(___form) instanceof Symbol && (:name (cast' Symbol (ß RT'first(___form)))).startsWith("def")))))
                                (do
                                    (let [#_"ObjExpr" ___fexpr (ß (ObjExpr) analyze(:Context'EXPRESSION, RT'list-3(Compiler'FN, PersistentVector'EMPTY, ___form), (str "eval" (RT'nextID))))]
                                        (let [#_"IFn" ___fn (ß (IFn) (.eval ___fexpr))]
                                            (.invoke ___fn)
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" ___expr (ß analyze(:Context'EVAL, ___form))]
                                        (.eval ___expr)
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
                (finally
                    (when ___createdLoader
                        (Var'popThreadBindings)
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'registerConstant [#_"Object" ___o]
        (when (not (ß Compiler'CONSTANTS.isBound()))
            (§ return -1)
        )
        (let [#_"PersistentVector" ___v (ß (PersistentVector) Compiler'CONSTANTS.deref())]
            (let [#_"IdentityHashMap<Object, Integer>" ___ids (ß (IdentityHashMap<Object, Integer>) Compiler'CONSTANT_IDS.deref())]
                (let [#_"Integer" ___i (.get ___ids, ___o)]
                    (when (some? ___i)
                        (§ return ___i)
                    )
                    (ß Compiler'CONSTANTS.set(RT'conj(___v, ___o)))
                    (ß ___ids.put(___o, (count ___v)))
                    (count ___v)
                )
            )
        )
    )

    (defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" ___keyword]
        (when (not (ß Compiler'KEYWORDS.isBound()))
            (§ return (KeywordExpr'new ___keyword))
        )

        (let [#_"IPersistentMap" ___keywordsMap (ß (IPersistentMap) Compiler'KEYWORDS.deref())]
            (let [#_"Object" ___id (RT'get-2 ___keywordsMap, ___keyword)]
                (when (nil? ___id)
                    (ß Compiler'KEYWORDS.set(RT'assoc(___keywordsMap, ___keyword, registerConstant(___keyword))))
                )
                (KeywordExpr'new ___keyword)
            )
        )
    )

    (defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" ___keyword]
        (when (not (ß Compiler'KEYWORD_CALLSITES.isBound()))
            (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___keywordCallsites (ß (IPersistentVector) Compiler'KEYWORD_CALLSITES.deref())]
            (§ ass ___keywordCallsites (.cons ___keywordCallsites, ___keyword))
            (ß Compiler'KEYWORD_CALLSITES.set(___keywordCallsites))
            (ß (count ___keywordCallsites) - 1)
        )
    )

    (defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" ___v]
        (when (not (ß Compiler'PROTOCOL_CALLSITES.isBound()))
            (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___protocolCallsites (ß (IPersistentVector) Compiler'PROTOCOL_CALLSITES.deref())]
            (§ ass ___protocolCallsites (.cons ___protocolCallsites, ___v))
            (ß Compiler'PROTOCOL_CALLSITES.set(___protocolCallsites))
            (ß (count ___protocolCallsites) - 1)
        )
    )

    (defn- #_"void" Compiler'registerVarCallsite [#_"Var" ___v]
        (when (not (ß Compiler'VAR_CALLSITES.isBound()))
            (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
        )

        (let [#_"IPersistentCollection" ___varCallsites (ß (IPersistentCollection) Compiler'VAR_CALLSITES.deref())]
            (§ ass ___varCallsites (.cons ___varCallsites, ___v))
            (ß Compiler'VAR_CALLSITES.set(___varCallsites))
            nil
        )
    )

    (defn #_"ISeq" Compiler'fwdPath [#_"PathNode" ___p1]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [___p1 ___p1] (some? ___p1) [(:parent ___p1)]
                (§ ass ___ret (RT'cons ___p1, ___ret))
            )
            ___ret
        )
    )

    (defn #_"PathNode" Compiler'commonPath [#_"PathNode" ___n1, #_"PathNode" ___n2]
        (let [#_"ISeq" ___xp (ß fwdPath(___n1))]
            (let [#_"ISeq" ___yp (ß fwdPath(___n2))]
                (when (ß RT'first(___xp) != RT'first(___yp))
                    (§ return nil)
                )
                (while (ß RT'second(___xp) != nil && RT'second(___xp) == RT'second(___yp))
                    (§ ass ___xp (next ___xp))
                    (§ ass ___yp (next ___yp))
                )
                (ß (PathNode) RT'first(___xp))
            )
        )
    )

    (defn #_"void" Compiler'addAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta]
        (when (ß ___meta != nil && Compiler'ADD_ANNOTATIONS.isBound())
            (ß Compiler'ADD_ANNOTATIONS.invoke(___visitor, ___meta))
        )
        nil
    )

    (defn #_"void" Compiler'addParameterAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta, #_"int" ___i]
        (when (ß ___meta != nil && Compiler'ADD_ANNOTATIONS.isBound())
            (ß Compiler'ADD_ANNOTATIONS.invoke(___visitor, ___meta, ___i))
        )
        nil
    )

    (defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" ___sym]
        (let [#_"Symbol" ___tag (ß tagOf(___sym))]
            (cond (ß (:ns ___sym) == nil) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" ___b (ß referenceLocal(___sym))]
                        (when (some? ___b)
                            (§ return (LocalBindingExpr'new ___b, ___tag))
                        )
                    )
                )
                (ß namespaceFor(___sym) == nil)
                (do
                    (let [#_"Symbol" ___nsSym (ß Symbol'intern-1((:ns ___sym)))]
                        (let [#_"Class" ___c (HostExpr'maybeClass ___nsSym, false)]
                            (when (some? ___c)
                                (when (ß Reflector'getField(___c, (:name ___sym), true) != nil)
                                    (§ return (ß StaticFieldExpr'new(Compiler'lineDeref(), Compiler'columnDeref(), ___c, (:name ___sym), ___tag)))
                                )
                                (throw (Util'runtimeException-1 (str "Unable to find static field: " (:name ___sym) " in " ___c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" ___o (ß resolve(___sym))]
                (cond (ß ___o instanceof Var)
                    (do
                        (let [#_"Var" ___v (ß (Var) ___o)]
                            (when (some? (Compiler'isMacro ___v))
                                (throw (Util'runtimeException-1 (str "Can't take value of a macro: " ___v)))
                            )
                            (when (ß RT'booleanCast-1o(RT'get-2((.meta ___v), RT'CONST_KEY)))
                                (§ return (ß analyze(:Context'EXPRESSION, RT'list-2(Compiler'QUOTE, (.get ___v)))))
                            )
                            (ß registerVar(___v))
                            (§ return (VarExpr'new ___v, ___tag))
                        )
                    )
                    (ß ___o instanceof Class)
                    (do
                        (§ return (ConstantExpr'new ___o))
                    )
                    (ß ___o instanceof Symbol)
                    (do
                        (§ return (ß UnresolvedVarExpr'new((cast' Symbol ___o))))
                    )
                )

                (throw (Util'runtimeException-1 (str "Unable to resolve symbol: " ___sym " in this context")))
            )
        )
    )

    (defn #_"String" Compiler'destubClassName [#_"String" ___className]
        ;; skip over prefix + '.' or '/'
        (when (ß ___className.startsWith(Compiler'COMPILE_STUB_PREFIX))
            (§ return (ß ___className.substring(Compiler'COMPILE_STUB_PREFIX.length() + 1)))
        )
        ___className
    )

    (defn #_"Type" Compiler'getType [#_"Class" ___c]
        (let [#_"String" ___descriptor (ß Type/getType(___c).getDescriptor())]
            (when (.startsWith ___descriptor, "L")
                (§ ass ___descriptor (str "L" (ß destubClassName(___descriptor.substring(1)))))
            )
            (§ unsure Type/getType ___descriptor)
        )
    )

    (defn #_"Object" Compiler'resolve-2 [#_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        (ß resolveIn((.currentNS this), ___sym, ___allowPrivate))
    )

    (defn #_"Object" Compiler'resolve-1 [#_"Symbol" ___sym]
        (ß resolveIn((.currentNS this), ___sym, false))
    )

    (defn #_"Namespace" Compiler'namespaceFor-1 [#_"Symbol" ___sym]
        (ß namespaceFor((.currentNS this), ___sym))
    )

    (defn #_"Namespace" Compiler'namespaceFor-2 [#_"Namespace" ___inns, #_"Symbol" ___sym]
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" ___nsSym (ß Symbol'intern-1((:ns ___sym)))]
            (let [#_"Namespace" ___ns (.lookupAlias ___inns, ___nsSym)]
                (when (nil? ___ns)
                    ;; ...otherwise check the Namespaces map.
                    (§ ass ___ns (Namespace'find ___nsSym))
                )
                ___ns
            )
        )
    )

    (defn #_"Object" Compiler'resolveIn [#_"Namespace" ___n, #_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond (ß (:ns ___sym) != nil)
            (do
                (let [#_"Namespace" ___ns (ß namespaceFor(___n, ___sym))]
                    (when (nil? ___ns)
                        (throw (Util'runtimeException-1 (str "No such namespace: " (:ns ___sym))))
                    )

                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern-1((:name ___sym))))]
                        (cond (nil? ___v)
                            (do
                                (throw (Util'runtimeException-1 (str "No such var: " ___sym)))
                            )
                            (ß (:ns ___v) != (.currentNS this) && (not (ß ___v.isPublic())) && (not ___allowPrivate))
                            (do
                                (throw (IllegalStateException. (str "var: " ___sym " is not public")))
                            )
                        )
                        ___v
                    )
                )
            )
            (ß (:name ___sym).indexOf(\.) > 0 || (:name ___sym).charAt(0) == \[)
            (do
                (ß RT'classForName-1((:name ___sym)))
            )
            (ß ___sym.equals(Compiler'NS))
            (do
                RT'NS_VAR
            )
            (ß ___sym.equals(Compiler'IN_NS))
            (do
                RT'IN_NS_VAR
            )
            :else
            (do
                (when (ß Util'equals(___sym, Compiler'COMPILE_STUB_SYM.get()))
                    (§ return (.get Compiler'COMPILE_STUB_CLASS))
                )
                (let [#_"Object" ___o (.getMapping ___n, ___sym)]
                    (when (nil? ___o)
                        (if (ß RT'booleanCast-1o(RT'ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return ___sym)
                            )
                            (do
                                (throw (Util'runtimeException-1 (str "Unable to resolve symbol: " ___sym " in this context")))
                            )
                        )
                    )
                    ___o
                )
            )
        )
    )

    (defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" ___n, #_"Symbol" ___sym]
        ;; note - ns-qualified vars must already exist
        (cond (ß (:ns ___sym) != nil)
            (do
                (let [#_"Namespace" ___ns (ß namespaceFor(___n, ___sym))]
                    (when (nil? ___ns)
                        (§ return nil)
                    )
                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern-1((:name ___sym))))]
                        (when (nil? ___v)
                            (§ return nil)
                        )
                        ___v
                    )
                )
            )
            (ß (:name ___sym).indexOf(\.) > 0 && (not (ß (:name ___sym).endsWith("."))) || (:name ___sym).charAt(0) == \[)
            (do
                (ß RT'classForName-1((:name ___sym)))
            )
            (ß ___sym.equals(Compiler'NS))
            (do
                RT'NS_VAR
            )
            (ß ___sym.equals(Compiler'IN_NS))
            (do
                RT'IN_NS_VAR
            )
            :else
            (do
                (let [#_"Object" ___o (.getMapping ___n, ___sym)]
                    ___o
                )
            )
        )
    )

    (defn #_"Var" Compiler'lookupVar-3 [#_"Symbol" ___sym, #_"boolean" ___internNew, #_"boolean" ___registerMacro]
        (let [#_"Var" ___var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß (:ns ___sym) != nil)
                (do
                    (let [#_"Namespace" ___ns (ß namespaceFor(___sym))]
                        (when (nil? ___ns)
                            (§ return nil)
                        )
                        (let [#_"Symbol" ___name (ß Symbol'intern-1((:name ___sym)))]
                            (if (ß ___internNew && ___ns == (.currentNS this))
                                (do
                                    (§ ass ___var (.intern (.currentNS this), ___name))
                                )
                                (do
                                    (§ ass ___var (.findInternedVar ___ns, ___name))
                                )
                            )
                        )
                    )
                )
                (ß ___sym.equals(Compiler'NS))
                (do
                    (§ ass ___var RT'NS_VAR)
                )
                (ß ___sym.equals(Compiler'IN_NS))
                (do
                    (§ ass ___var RT'IN_NS_VAR)
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" ___o (ß (.currentNS this).getMapping(___sym))]
                        (cond (nil? ___o)
                            (do
                                ;; introduce a new var in the current ns
                                (when ___internNew
                                    (§ ass ___var (.intern (.currentNS this), (Symbol'intern-1 (:name ___sym))))
                                )
                            )
                            (ß ___o instanceof Var)
                            (do
                                (§ ass ___var (ß (Var) ___o))
                            )
                            :else
                            (do
                                (throw (Util'runtimeException-1 (str "Expecting var, but " ___sym " is mapped to " ___o)))
                            )
                        )
                    )
                )
            )
            (when (ß ___var != nil && (ß (not (.isMacro ___var)) || ___registerMacro))
                (ß registerVar(___var))
            )
            ___var
        )
    )

    (defn #_"Var" Compiler'lookupVar-2 [#_"Symbol" ___sym, #_"boolean" ___internNew]
        (Compiler'lookupVar-3 ___sym, ___internNew, true)
    )

    (defn- #_"void" Compiler'registerVar [#_"Var" ___var]
        (when (not (ß Compiler'VARS.isBound()))
            (§ return nil)
        )
        (let [#_"IPersistentMap" ___varsMap (ß (IPersistentMap) Compiler'VARS.deref())]
            (let [#_"Object" ___id (RT'get-2 ___varsMap, ___var)]
                (when (nil? ___id)
                    (ß Compiler'VARS.set(RT'assoc(___varsMap, ___var, registerConstant(___var))))
                )
                nil
            )
        )
    )

    (defn #_"Namespace" Compiler'currentNS []
        (ß (Namespace) RT'CURRENT_NS.deref())
    )

    (defn #_"void" Compiler'closeOver [#_"LocalBinding" ___b, #_"ObjMethod" ___method]
        (when (ß ___b != nil && ___method != nil)
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) RT'get-2((:locals ___method), ___b))]
                (if (nil? ___lb)
                    (do
                        (§ ass (:closes (:objx ___method)) (ß (IPersistentMap) RT'assoc((:closes (:objx ___method)), ___b, ___b)))
                        (ß closeOver(___b, (:parent ___method)))
                    )
                    (do
                        (when (ß (:idx ___lb) == 0)
                            (§ ass (:usesThis ___method) true)
                        )
                        (when (ß Compiler'IN_CATCH_FINALLY.deref() != nil)
                            (§ ass (:localsUsedInCatchFinally ___method) (ß (PersistentHashSet) (:localsUsedInCatchFinally ___method).cons((:idx ___b))))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" ___sym]
        (when (not (ß Compiler'LOCAL_ENV.isBound()))
            (§ return nil)
        )
        (let [#_"LocalBinding" ___b (ß (LocalBinding) RT'get-2(Compiler'LOCAL_ENV.deref(), ___sym))]
            (when (some? ___b)
                (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                    (when (ß (:idx ___b) == 0)
                        (§ ass (:usesThis ___method) true)
                    )
                    (ß closeOver(___b, ___method))
                )
            )
            ___b
        )
    )

    (defn- #_"Symbol" Compiler'tagOf [#_"Object" ___o]
        (let [#_"Object" ___tag (ß RT'get-2(RT'meta(___o), RT'TAG_KEY))]
            (cond (ß ___tag instanceof Symbol)
                (do
                    (§ return (ß (Symbol) ___tag))
                )
                (ß ___tag instanceof String)
                (do
                    (§ return (ß Symbol'intern-2(nil, (String) ___tag)))
                )
            )
            nil
        )
    )

    (defn #_"Object" Compiler'loadFile [#_"String" ___file] #_(§ throws IOException)
        (let [#_"FileInputStream" ___f (FileInputStream. ___file)]
            (try
                (Compiler'load-3 (InputStreamReader. ___f, RT'UTF8), (ß (File. ___file).getAbsolutePath()), (ß (File. ___file).getName()))
                (finally
                    (.close ___f)
                )
            )
        )
    )

    (defn #_"Object" Compiler'load-1 [#_"Reader" ___rdr]
        (Compiler'load-3 ___rdr, nil, "NO_SOURCE_FILE")
    )

    (defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" ___pushbackReader]
        (let [#_"int" ___ch (LispReader'read1 ___pushbackReader)]
            (while (LispReader'isWhitespace ___ch)
                (§ ass ___ch (LispReader'read1 ___pushbackReader))
            )
            (LispReader'unread ___pushbackReader, ___ch)
            nil
        )
    )

    (§ def- #_"Object" Compiler'OPTS_COND_ALLOWED (RT'mapUniqueKeys LispReader'OPT_READ_COND, LispReader'COND_ALLOW))

    (defn- #_"Object" Compiler'readerOpts [#_"String" ___sourceName]
        (if (ß ___sourceName != nil && ___sourceName.endsWith(".clic"))
            (do
                Compiler'OPTS_COND_ALLOWED
            )
            (do
                nil
            )
        )
    )

    (defn #_"Object" Compiler'load-3 [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName]
        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (ß (___rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) ___rdr :or LineNumberingPushbackReader'new-1(___rdr))]
                    (ß consumeWhitespaces(___pushbackReader))
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (object-array [
                            Compiler'LOADER                (RT'makeClassLoader)
                            Compiler'SOURCE_PATH           ___sourcePath
                            Compiler'SOURCE                ___sourceName
                            Compiler'METHOD                nil
                            Compiler'LOCAL_ENV             nil
                            Compiler'LOOP_LOCALS           nil
                            Compiler'NEXT_LOCAL_NUM        0
                            RT'READEVAL           RT'T
                            RT'CURRENT_NS         (deref RT'CURRENT_NS)
                            Compiler'LINE_BEFORE           (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_BEFORE         (.getColumnNumber ___pushbackReader)
                            Compiler'LINE_AFTER            (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_AFTER          (.getColumnNumber ___pushbackReader)
                            RT'UNCHECKED_MATH     (deref RT'UNCHECKED_MATH)
                            RT'WARN_ON_REFLECTION (deref RT'WARN_ON_REFLECTION)
                            RT'DATA_READERS       (deref RT'DATA_READERS)
                        ])
                    )))

                    (let [#_"Object" ___readerOpts (ß ___readerOpts(___sourceName))]
                        (try
                            (loop-when-recur [#_"Object" ___r (LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)] (ß ___r != ___EOF) [(LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)]
                                (ß consumeWhitespaces(___pushbackReader))
                                (ß Compiler'LINE_AFTER.set((.getLineNumber ___pushbackReader)))
                                (ß Compiler'COLUMN_AFTER.set((.getColumnNumber ___pushbackReader)))
                                (§ ass ___ret (Compiler'eval-2 ___r, false))
                                (ß Compiler'LINE_BEFORE.set((.getLineNumber ___pushbackReader)))
                                (ß Compiler'COLUMN_BEFORE.set((.getColumnNumber ___pushbackReader)))
                            )
                            (§ catch LispReaderException ___e
                                (throw (ß CompilerException'new(___sourcePath, (:line ___e), (:column ___e), (.getCause ___e))))
                            )
                            (catch Throwable ___e
                                (if (not (ß ___e instanceof CompilerException))
                                    (do
                                        (throw (ß CompilerException'new(___sourcePath, (Integer) Compiler'LINE_BEFORE.deref(), (Integer) Compiler'COLUMN_BEFORE.deref(), ___e)))
                                    )
                                    (do
                                        (throw (ß (CompilerException) ___e))
                                    )
                                )
                            )
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                        ___ret
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'writeClassFile [#_"String" ___internalName, #_"byte[]" ___bytecode] #_(§ throws IOException)
        (let [#_"String" ___genPath (ß (String) Compiler'COMPILE_PATH.deref())]
            (when (nil? ___genPath)
                (throw (Util'runtimeException-1 "*compile-path* not set"))
            )
            (let [#_"String[]" ___dirs (.split ___internalName, "/")]
                (let [#_"String" ___p ___genPath]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___dirs.length - 1) [(inc ___i)]
                        (§ ass ___p (ß ___p + File/separator + ___dirs[___i]))
                        (ß (File. ___p).mkdir())
                    )
                    (let [#_"String" ___path (str ___genPath File/separator ___internalName ".class")]
                        (let [#_"File" ___cf (§ unsure File. ___path)]
                            (.createNewFile ___cf)
                            (let [#_"FileOutputStream" ___cfs (§ unsure FileOutputStream. ___cf)]
                                (try
                                    (.write ___cfs, ___bytecode)
                                    (.flush ___cfs)
                                    (finally
                                        (.close ___cfs)
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'pushNS []
        (ß Var'pushThreadBindings(PersistentHashMap'create-1a(
            (object-array [
                Var'intern-2s(Symbol'intern-1("cloiure.core"), Symbol'intern-1("*ns*")).setDynamic() nil
            ])
        )))
        nil
    )

    (defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" ___loader]
        (ß Var'pushThreadBindings(RT'map(
            (object-array [
                Var'intern-2s(Symbol'intern-1("cloiure.core"), Symbol'intern-1("*ns*")).setDynamic() nil
                RT'FN_LOADER_VAR                                                                    ___loader
                RT'READEVAL                                                                         RT'T
            ])
        )))
        nil
    )

    (defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" ___target, #_"Keyword" ___k]
        nil
    )

    (defn #_"void" Compiler'compile1 [#_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"Object" ___form]
        (let [#_"Object" ___line (ß Compiler'lineDeref())]
            (let [#_"Object" ___column (ß Compiler'columnDeref())]
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(
                    (object-array [
                        Compiler'LINE   ___line
                        Compiler'COLUMN ___column
                        Compiler'LOADER (RT'makeClassLoader)
                    ])
                )))
                (try
                    (§ ass ___form (ß macroexpand(___form)))
                    (if (ß ___form instanceof ISeq && Util'equals(RT'first(___form), Compiler'DO))
                        (do
                            (loop-when-recur [#_"ISeq" ___s (RT'next ___form)] (some? ___s) [(RT'next ___s)]
                                (ß compile1(___gen, ___objx, RT'first(___s)))
                            )
                        )
                        (do
                            (let [#_"Expr" ___expr (ß analyze(:Context'EVAL, ___form))]
                                (§ ass (:keywords ___objx) (ß (IPersistentMap) Compiler'KEYWORDS.deref()))
                                (§ ass (:vars ___objx) (ß (IPersistentMap) Compiler'VARS.deref()))
                                (§ ass (:constants ___objx) (ß (PersistentVector) Compiler'CONSTANTS.deref()))
                                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (.eval ___expr)
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
                nil
            )
        )
    )

    (defn #_"Object" Compiler'compile [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName] #_(§ throws IOException)
        (when (ß Compiler'COMPILE_PATH.deref() == nil)
            (throw (Util'runtimeException-1 "*compile-path* not set"))
        )

        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (ß (___rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) ___rdr :or LineNumberingPushbackReader'new-1(___rdr))]
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (object-array [
                            Compiler'SOURCE_PATH           ___sourcePath
                            Compiler'SOURCE                ___sourceName
                            Compiler'METHOD                nil
                            Compiler'LOCAL_ENV             nil
                            Compiler'LOOP_LOCALS           nil
                            Compiler'NEXT_LOCAL_NUM        0
                            RT'READEVAL           RT'T
                            RT'CURRENT_NS         (deref RT'CURRENT_NS)
                            Compiler'LINE_BEFORE           (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_BEFORE         (.getColumnNumber ___pushbackReader)
                            Compiler'LINE_AFTER            (.getLineNumber ___pushbackReader)
                            Compiler'COLUMN_AFTER          (.getColumnNumber ___pushbackReader)
                            Compiler'CONSTANTS             PersistentVector'EMPTY
                            Compiler'CONSTANT_IDS          (IdentityHashMap.)
                            Compiler'KEYWORDS              PersistentHashMap'EMPTY
                            Compiler'VARS                  PersistentHashMap'EMPTY
                            RT'UNCHECKED_MATH     (deref RT'UNCHECKED_MATH)
                            RT'WARN_ON_REFLECTION (deref RT'WARN_ON_REFLECTION)
                            RT'DATA_READERS       (deref RT'DATA_READERS)
                        ])
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" ___objx (ObjExpr'new nil)]
                            (§ ass (:internalName ___objx) (ß ___sourcePath.replace(File/separator, "/").substring(0, ___sourcePath.lastIndexOf(\.)) + RT'LOADER_SUFFIX))

                            (§ ass (:objtype ___objx) (ß Type/getObjectType((:internalName ___objx))))
                            (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
                                (let [#_"ClassVisitor" ___cv ___cw]
                                    (ß ___cv.visit(Opcodes/V1_5, Opcodes/ACC_PUBLIC + Opcodes/ACC_SUPER, (:internalName ___objx), nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void load ()"), nil, nil, ___cv)]
                                        (.visitCode ___gen)

                                        (let [#_"Object" ___readerOpts (ß ___readerOpts(___sourceName))]
                                            (loop-when-recur [#_"Object" ___r (LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)] (ß ___r != ___EOF) [(LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)]
                                                (ß Compiler'LINE_AFTER.set((.getLineNumber ___pushbackReader)))
                                                (ß Compiler'COLUMN_AFTER.set((.getColumnNumber ___pushbackReader)))
                                                (ß compile1(___gen, ___objx, ___r))
                                                (ß Compiler'LINE_BEFORE.set((.getLineNumber ___pushbackReader)))
                                                (ß Compiler'COLUMN_BEFORE.set((.getColumnNumber ___pushbackReader)))
                                            )
                                            ;; end of load
                                            (.returnValue ___gen)
                                            (.endMethod ___gen)

                                            ;; static fields for constants
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants ___objx).count()) [(inc ___i)]
                                                (when (ß (:usedConstants ___objx).contains(___i))
                                                    (ß ___cv.visitField(Opcodes/ACC_PUBLIC + Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, ___objx.constantName(___i), ___objx.constantType(___i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [#_"int" ___INITS_PER 100]
                                                (let [#_"int" ___numInits (ß (:constants ___objx).count() / ___INITS_PER)]
                                                    (when (ß (:constants ___objx).count() % ___INITS_PER != 0)
                                                        (§ ass ___numInits (inc ___numInits))
                                                    )

                                                    (loop-when-recur [#_"int" ___n 0] (< ___n ___numInits) [(inc ___n)]
                                                        (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod (str "void __init" ___n"()")), nil, nil, ___cv)]
                                                            (.visitCode ___clinitgen)
                                                            (try
                                                                (ß Var'pushThreadBindings(RT'map(RT'PRINT_DUP, RT'T)))

                                                                (loop-when-recur [#_"int" ___i (* ___n ___INITS_PER)] (ß ___i < (:constants ___objx).count() && ___i < (___n + 1) * ___INITS_PER) [(inc ___i)]
                                                                    (when (ß (:usedConstants ___objx).contains(___i))
                                                                        (ß ___objx.emitValue((:constants ___objx).nth(___i), ___clinitgen))
                                                                        (ß ___clinitgen.checkCast(___objx.constantType(___i)))
                                                                        (ß ___clinitgen.putStatic((:objtype ___objx), ___objx.constantName(___i), ___objx.constantType(___i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (Var'popThreadBindings)
                                                                )
                                                            )
                                                            (.returnValue ___clinitgen)
                                                            (.endMethod ___clinitgen)
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, ___cv)]
                                                        (.visitCode ___clinitgen)
                                                        (let [#_"Label" ___startTry (.newLabel ___clinitgen)]
                                                            (let [#_"Label" ___endTry (.newLabel ___clinitgen)]
                                                                (let [#_"Label" ___end (.newLabel ___clinitgen)]
                                                                    (let [#_"Label" ___finallyLabel (.newLabel ___clinitgen)]
                                                                        (loop-when-recur [#_"int" ___n 0] (< ___n ___numInits) [(inc ___n)]
                                                                            (.invokeStatic ___clinitgen, (:objtype ___objx), (Method/getMethod (str "void __init" ___n "()")))
                                                                        )

                                                                        (ß ___clinitgen.push((:internalName ___objx).replace(\/, \.)))
                                                                        (ß ___clinitgen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("Class classForName(String)")))
                                                                        (ß ___clinitgen.invokeVirtual(Compiler'CLASS_TYPE, Method/getMethod("ClassLoader getClassLoader()")))
                                                                        (ß ___clinitgen.invokeStatic(Type/getType((§ class Compiler)), Method/getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (.mark ___clinitgen, ___startTry)
                                                                        (ß ___clinitgen.invokeStatic((:objtype ___objx), Method/getMethod("void load()")))
                                                                        (.mark ___clinitgen, ___endTry)
                                                                        (ß ___clinitgen.invokeStatic(Compiler'VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (.goTo ___clinitgen, ___end)

                                                                        (.mark ___clinitgen, ___finallyLabel)
                                                                        ;; exception should be on stack
                                                                        (ß ___clinitgen.invokeStatic(Compiler'VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (.throwException ___clinitgen)
                                                                        (.mark ___clinitgen, ___end)
                                                                        (.visitTryCatchBlock ___clinitgen, ___startTry, ___endTry, ___finallyLabel, nil)

                                                                        ;; end of static init
                                                                        (.returnValue ___clinitgen)
                                                                        (.endMethod ___clinitgen)

                                                                        ;; end of class
                                                                        (.visitEnd ___cv)

                                                                        (ß writeClassFile((:internalName ___objx), (.toByteArray ___cw)))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (§ catch LispReaderException ___e
                            (throw (ß CompilerException'new(___sourcePath, (:line ___e), (:column ___e), (.getCause ___e))))
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                    ___ret
                )
            )
        )
    )

    (defn #_"boolean" Compiler'inty [#_"Class" ___c]
        (ß (___c == (§ class int) || ___c == (§ class short) || ___c == (§ class byte) || ___c == (§ class char)))
    )

    (defn #_"Class" Compiler'retType [#_"Class" ___tc, #_"Class" ___ret]
        (when (nil? ___tc)
            (§ return ___ret)
        )
        (when (nil? ___ret)
            (§ return ___tc)
        )
        (when (ß (.isPrimitive ___ret) && (.isPrimitive ___tc))
            (when (ß (inty(___ret) && inty(___tc)) || (___ret == ___tc))
                (§ return ___tc)
            )
            (throw (UnsupportedOperationException. (str "Cannot coerce " ___ret " to " ___tc ", use a cast instead")))
        )
        ___tc
    )

    (defn #_"Class" Compiler'primClass-1s [#_"Symbol" ___sym]
        (when (nil? ___sym)
            (§ return nil)
        )
        (let [#_"Class" ___c nil]
            (cond (ß (:name ___sym).equals("int"))
                (do
                    (§ ass ___c (§ class int))
                )
                (ß (:name ___sym).equals("long"))
                (do
                    (§ ass ___c (§ class long))
                )
                (ß (:name ___sym).equals("float"))
                (do
                    (§ ass ___c (§ class float))
                )
                (ß (:name ___sym).equals("double"))
                (do
                    (§ ass ___c (§ class double))
                )
                (ß (:name ___sym).equals("char"))
                (do
                    (§ ass ___c (§ class char))
                )
                (ß (:name ___sym).equals("short"))
                (do
                    (§ ass ___c (§ class short))
                )
                (ß (:name ___sym).equals("byte"))
                (do
                    (§ ass ___c (§ class byte))
                )
                (ß (:name ___sym).equals("boolean"))
                (do
                    (§ ass ___c (§ class boolean))
                )
                (ß (:name ___sym).equals("void"))
                (do
                    (§ ass ___c (§ class void))
                )
            )
            ___c
        )
    )

    (defn #_"Class" Compiler'tagClass [#_"Object" ___tag]
        (when (nil? ___tag)
            (§ return (§ class Object))
        )
        (let [#_"Class" ___c nil]
            (when (ß ___tag instanceof Symbol)
                (§ ass ___c (ß primClass((cast' Symbol ___tag))))
            )
            (when (nil? ___c)
                (§ ass ___c (HostExpr'tagToClass ___tag))
            )
            ___c
        )
    )

    (defn #_"Class" Compiler'primClass-1c [#_"Class" ___c]
        (if (.isPrimitive ___c) ___c Object)
    )

    (defn #_"Class" Compiler'boxClass [#_"Class" ___p]
        (when (not (ß ___p.isPrimitive()))
            (§ return ___p)
        )

        (let [#_"Class" ___c nil]
            (cond (ß ___p == Integer/TYPE)
                (do
                    (§ ass ___c (§ class Integer))
                )
                (ß ___p == Long/TYPE)
                (do
                    (§ ass ___c (§ class Long))
                )
                (ß ___p == Float/TYPE)
                (do
                    (§ ass ___c (§ class Float))
                )
                (ß ___p == Double/TYPE)
                (do
                    (§ ass ___c (§ class Double))
                )
                (ß ___p == Character/TYPE)
                (do
                    (§ ass ___c (§ class Character))
                )
                (ß ___p == Short/TYPE)
                (do
                    (§ ass ___c (§ class Short))
                )
                (ß ___p == Byte/TYPE)
                (do
                    (§ ass ___c (§ class Byte))
                )
                (ß ___p == Boolean/TYPE)
                (do
                    (§ ass ___c (§ class Boolean))
                )
            )

            ___c
        )
    )

    (defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        PersistentHashSet'EMPTY
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (defn- #_"Cons" Cons'init []
        (hash-map
            #_"Object" :_first nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"Cons" Cons'new-2 [#_"Object" ___first, #_"ISeq" ____more]
        (let [this (merge (ASeq'new) (Cons'init))]
            (§ ass (:_first this) ___first)
            (§ ass (:_more this) ____more)
            this
        )
    )

    (defn #_"Cons" Cons'new-3 [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"ISeq" ____more]
        (let [this (merge (ASeq'new ___meta) (Cons'init))]
            (§ ass (:_first this) ____first)
            (§ ass (:_more this) ____more)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Cons" this]
        (:_first this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Cons" this]
        (.seq (.more this))
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"Cons" this]
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"Cons" this]
        (ß 1 + RT'count((:_more this)))
    )

    #_method
    (§ defn #_"Cons" (§ method withMeta) [#_"Cons" this, #_"IPersistentMap" ___meta]
        (Cons'new-3 ___meta, (:_first this), (:_more this))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ defprotocol Counted
    #_abstract
    (#_"int" Counted'''(§ method count) [#_"Counted" this])
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (defn- #_"Cycle" Cycle'init []
        (hash-map
            #_"ISeq" :all nil ;; never nil
            #_"ISeq" :prev nil
            #_volatile
            #_"ISeq" :_current nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Cycle" Cycle'new-3 [#_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current]
        (let [this (merge (ASeq'new) (Cycle'init))]
            (§ ass (:all this) ___all)
            (§ ass (:prev this) ___prev)
            (§ ass (:_current this) ___current)
            this
        )
    )

    (defn- #_"Cycle" Cycle'new-5 [#_"IPersistentMap" ___meta, #_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current, #_"ISeq" ___next]
        (let [this (merge (ASeq'new ___meta) (Cycle'init))]
            (§ ass (:all this) ___all)
            (§ ass (:prev this) ___prev)
            (§ ass (:_current this) ___current)
            (§ ass (:_next this) ___next)
            this
        )
    )

    (defn #_"ISeq" Cycle'create [#_"ISeq" ___vals]
        (when (nil? ___vals)
            (§ return PersistentList'EMPTY)
        )
        (Cycle'new-3 ___vals, nil, ___vals)
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" (§ method current) [#_"Cycle" this]
        (when (nil? (:_current this))
            (let [#_"ISeq" ___current (next (:prev this))]
                (§ ass (:_current this) (or ___current (:all this)))
            )
        )
        (:_current this)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Cycle" this]
        (ß ((:_current this) != nil))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Cycle" this]
        (first (.current this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Cycle" this]
        (when (nil? (:_next this))
            (§ ass (:_next this) (ß Cycle'new-3((:all this), (.current this), nil)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Cycle" (§ method withMeta) [#_"Cycle" this, #_"IPersistentMap" ___meta]
        (Cycle'new-5 ___meta, (:all this), (:prev this), (:_current this), (:_next this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Cycle" this, #_"IFn" ___f]
        (let [#_"ISeq" ___s (.current this)]
            (let [#_"Object" ___ret (first ___s)]
                (while true
                    (§ ass ___s (next ___s))
                    (when (nil? ___s)
                        (§ ass ___s (:all this))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
                    (when (RT'isReduced ___ret)
                        (§ return (ß (cast' IDeref ___ret).deref()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Cycle" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"ISeq" ___s (.current this)]
                (while true
                    (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
                    (when (RT'isReduced ___ret)
                        (§ return (ß (cast' IDeref ___ret).deref()))
                    )
                    (§ ass ___s (next ___s))
                    (when (nil? ___s)
                        (§ ass ___s (:all this))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (defn- #_"Delay" Delay'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Throwable" :exception nil
            #_volatile
            #_"IFn" :fn nil
        )
    )

    (defn #_"Delay" Delay'new [#_"IFn" ___fn]
        (let [this (Delay'init)]
            (§ ass (:fn this) ___fn)
            (§ ass (:val this) nil)
            (§ ass (:exception this) nil)
            this
        )
    )

    (defn #_"Object" Delay'force [#_"Object" ___x]
        (if (ß ___x instanceof Delay) (.deref (cast' Delay ___x)) ___x)
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Delay" this]
        (when (some? (:fn this))
            (§ sync this
                ;; double check
                (when (some? (:fn this))
                    (try
                        (§ ass (:val this) (.invoke (:fn this)))
                        (catch Throwable ___t
                            (§ ass (:exception this) ___t)
                        )
                    )
                    (§ ass (:fn this) nil)
                )
            )
        )
        (when (some? (:exception this))
            (throw (Util'sneakyThrow (:exception this)))
        )
        (:val this)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Delay" this]
        (§ sync this
            (ß ((:fn this) == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ConcurrentHashMap.))

    (def #_"URL[]" DynamicClassLoader'EMPTY_URLS (make-array URL 0))

    (def #_"ReferenceQueue" DynamicClassLoader'RQ (ReferenceQueue.))

    (defn- #_"DynamicClassLoader" DynamicClassLoader'init []
        (hash-map
            #_"HashMap<Integer, Object[]>" :constantVals (HashMap.)
        )
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new-0 []
        ;; pseudo test in lieu of hasContextClassLoader()
        (merge (URLClassLoader'new DynamicClassLoader'EMPTY_URLS, (ß (Thread/currentThread().getContextClassLoader() == nil || Thread/currentThread().getContextClassLoader() == ClassLoader/getSystemClassLoader()) ? (§ class Compiler).getClassLoader() :or Thread/currentThread().getContextClassLoader())) (DynamicClassLoader'init))
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new-1 [#_"ClassLoader" ___parent]
        (merge (URLClassLoader'new DynamicClassLoader'EMPTY_URLS, ___parent) (DynamicClassLoader'init))
    )

    #_method
    (§ defn #_"Class" (§ method defineClass) [#_"DynamicClassLoader" this, #_"String" ___name, #_"byte[]" ___bytes, #_"Object" ___srcForm]
        (Util'clearCache DynamicClassLoader'RQ, DynamicClassLoader'classCache)
        (let [#_"Class" ___c (ß this.defineClass(___name, ___bytes, 0, ___bytes.length))]
            (ß DynamicClassLoader'classCache.put(___name, (SoftReference. ___c, DynamicClassLoader'RQ)))
            ___c
        )
    )

    (defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" ___name]
        (let [#_"Reference<Class>" ___cr (.get DynamicClassLoader'classCache, ___name)]
            (when (some? ___cr)
                (let [#_"Class" ___c (.get ___cr)]
                    (if (some? ___c)
                        (do
                            (§ return ___c)
                        )
                        (do
                            (.remove DynamicClassLoader'classCache, ___name, ___cr)
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" (§ method findClass) [#_"DynamicClassLoader" this, #_"String" ___name] #_(§ throws ClassNotFoundException)
        (let [#_"Class" ___c (DynamicClassLoader'findInMemoryClass ___name)]
            (if (some? ___c)
                (do
                    ___c
                )
                (do
                    (.findClass super, ___name)
                )
            )
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" (§ method loadClass) [#_"DynamicClassLoader" this, #_"String" ___name, #_"boolean" ___resolve] #_(§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" ___c (ß findLoadedClass(___name))]
                (when (nil? ___c)
                    (§ ass ___c (DynamicClassLoader'findInMemoryClass ___name))
                    (when (nil? ___c)
                        (§ ass ___c (.loadClass super, ___name, false))
                    )
                )
                (when ___resolve
                    (.resolveClass this, ___c)
                )
                ___c
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method registerConstants) [#_"DynamicClassLoader" this, #_"int" ___id, #_"Object[]" ___val]
        (ß (:constantVals this).put(___id, ___val))
        nil
    )

    #_method
    (§ defn #_"Object[]" (§ method getConstants) [#_"DynamicClassLoader" this, #_"int" ___id]
        (ß (:constantVals this).get(___id))
    )

    #_method
    (§ defn #_"void" (§ method addURL) [#_"DynamicClassLoader" this, #_"URL" ___url]
        (.addURL super, ___url)
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReaderException (§ extends RuntimeException)
    (defn- #_"EdnReaderException" EdnReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"EdnReaderException" EdnReaderException'new [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new ___cause) (EdnReaderException'init))]
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )
)

#_closure
(class-ns EdnStringReader (§ extends AFn)
    (defn #_"EdnStringReader" EdnStringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [#_"int" ___ch (ß EdnReader'read1(___r))] (ß ___ch != \") [(ß EdnReader'read1(___r))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading string"))
                    )
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß EdnReader'read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (Util'runtimeException-1 "EOF while reading string"))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch \tab)
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch \return)
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch \newline)
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch \backspace)
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch \formfeed)
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (ß EdnReader'read1(___r)))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (Util'runtimeException-1 (str "Invalid unicode escape: \\u" (ß (char) ___ch))))
                                )
                                (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (Character/isDigit ___ch)
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 8, 3, false)))
                                        (when (> ___ch 0377)
                                            (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (Util'runtimeException-1 (str "Unsupported escape character: \\" (ß (char) ___ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (.toString ___sb)
            )
        )
    )
)

#_closure
(class-ns EdnCommentReader (§ extends AFn)
    (defn #_"EdnCommentReader" EdnCommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts]
        (let [#_"Reader" ___r (ß (Reader) ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (ß EdnReader'read1(___r)))
                    (§ recur-if (___ch != -1 && ___ch != \newline && ___ch != \return))
                )
                ___r
            )
        )
    )
)

#_closure
(class-ns EdnDiscardReader (§ extends AFn)
    (defn #_"EdnDiscardReader" EdnDiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (EdnReader'read-5 ___r, true, nil, true, ___opts)
            ___r
        )
    )
)

#_closure
(class-ns EdnNamespaceMapReader (§ extends AFn)
    (defn #_"EdnNamespaceMapReader" EdnNamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            ;; Read ns symbol
            (let [#_"Object" ___sym (EdnReader'read-5 ___r, true, nil, false, ___opts)]
                (when (ß (not (ß ___sym instanceof Symbol)) || (cast' Symbol ___sym).getNamespace() != nil)
                    (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " ___sym)))
                )
                (let [#_"String" ___ns (ß (cast' Symbol ___sym).getName())]
                    ;; Read map
                    (let [#_"int" ___nextChar (ß EdnReader'read1(___r))]
                        (while (ß isWhitespace(___nextChar))
                            (§ ass ___nextChar (ß EdnReader'read1(___r)))
                        )
                        (when (ß \{ != ___nextChar)
                            (throw (RuntimeException. "Namespaced map must specify a map"))
                        )
                        (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts))]
                            (when (ß ((.size ___kvs) & 1) == 1)
                                (throw (Util'runtimeException-1 "Namespaced map literal must contain an even number of forms"))
                            )

                            ;; Construct output map
                            (let [#_"Object[]" ___a (make-array Object (.size ___kvs))]
                                (let [#_"Iterator" ___iter (.iterator ___kvs)]
                                    (loop-when-recur [#_"int" ___i 0] (.hasNext ___iter) [(+ ___i 2)]
                                        (let [#_"Object" ___key (next ___iter)]
                                            (let [#_"Object" ___val (next ___iter)]
                                                (cond (ß ___key instanceof Keyword)
                                                    (do
                                                        (let [#_"Keyword" ___kw (ß (Keyword) ___key)]
                                                            (cond (ß (.getNamespace ___kw) == nil)
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern-2(___ns, (.getName ___kw))))
                                                                )
                                                                (ß (.getNamespace ___kw).equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern-2(nil, (.getName ___kw))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (ß ___key instanceof Symbol)
                                                    (do
                                                        (let [#_"Symbol" ___s (ß (Symbol) ___key)]
                                                            (cond (ß (.getNamespace ___s) == nil)
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern-2(___ns, (.getName ___s))))
                                                                )
                                                                (ß (.getNamespace ___s).equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern-2(nil, (.getName ___s))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (§ ass (ß ___a[___i]) ___key)
                                                (§ ass (ß ___a[___i + 1]) ___val)
                                            )
                                        )
                                    )
                                    (RT'map ___a)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnDispatchReader (§ extends AFn)
    (defn #_"EdnDispatchReader" EdnDispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts]
        (let [#_"int" ___ch (ß EdnReader'read1((Reader)___reader))]
            (when (ß ___ch == -1)
                (throw (Util'runtimeException-1 "EOF while reading character"))
            )
            (let [#_"IFn" ___fn (ß dispatchMacros[___ch])]
                (when (nil? ___fn)
                    ;; try tagged reader
                    (when (Character/isLetter ___ch)
                        (EdnReader'unread (cast PushbackReader ___reader), ___ch)
                        (§ return (.invoke taggedReader, ___reader, ___ch, ___opts))
                    )

                    (throw (ß Util'runtimeException-1(String/format("No dispatch macro for: %c", (object-array [ (ß (char) ___ch) ])))))
                )
                (.invoke ___fn, ___reader, ___ch, ___opts)
            )
        )
    )
)

#_closure
(class-ns EdnMetaReader (§ extends AFn)
    (defn #_"EdnMetaReader" EdnMetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß (cast' LineNumberingPushbackReader ___r).getLineNumber()))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (let [#_"Object" ___meta (EdnReader'read-5 ___r, true, nil, true, ___opts)]
                        (cond (ß ___meta instanceof Symbol || ___meta instanceof String)
                            (do
                                (§ ass ___meta (RT'map RT'TAG_KEY, ___meta))
                            )
                            (ß ___meta instanceof Keyword)
                            (do
                                (§ ass ___meta (RT'map ___meta, RT'T))
                            )
                            (not (ß ___meta instanceof IPersistentMap))
                            (do
                                (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                            )
                        )

                        (let [#_"Object" ___o (EdnReader'read-5 ___r, true, nil, true, ___opts)]
                            (if (ß ___o instanceof IMeta)
                                (do
                                    (when (ß ___line != -1 && ___o instanceof ISeq)
                                        (§ ass ___meta (ß (cast' IPersistentMap ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (ß ___o instanceof IReference)
                                        (ß (cast' IReference ___o).resetMeta((cast' IPersistentMap ___meta)))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (RT'meta ___o)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'seq ___meta)] (some? ___s) [(next ___s)]
                                            (let [#_"IMapEntry" ___kv (ß (IMapEntry) (first ___s))]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, (.getKey ___kv), (.getValue ___kv))))
                                            )
                                        )
                                        (ß (cast' IObj ___o).withMeta((cast' IPersistentMap ___ometa)))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnCharacterReader (§ extends AFn)
    (defn #_"EdnCharacterReader" EdnCharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß EdnReader'read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch, false))]
                    (cond (ß (.length ___token) == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (.equals ___token, "newline")
                        (do
                            (§ return \newline)
                        )
                        (.equals ___token, "space")
                        (do
                            (§ return \space)
                        )
                        (.equals ___token, "tab")
                        (do
                            (§ return \tab)
                        )
                        (.equals ___token, "backspace")
                        (do
                            (§ return \backspace)
                        )
                        (.equals ___token, "formfeed")
                        (do
                            (§ return \formfeed)
                        )
                        (.equals ___token, "return")
                        (do
                            (§ return \return)
                        )
                        (.startsWith ___token, "u")
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (ß ___c >= (§ char "\ud800") && ___c <= (§ char "\udfff")) ;; surrogate code unit?
                                    (throw (Util'runtimeException-1 (str "Invalid character constant: \\u" (Integer/toString ___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (.startsWith ___token, "o")
                        (do
                            (let [#_"int" ___len (ß (.length ___token) - 1)]
                                (when (> ___len 3)
                                    (throw (Util'runtimeException-1 (str "Invalid octal escape sequence length: " ___len)))
                                )
                                (let [#_"int" ___uc (ß readUnicodeChar(___token, 1, ___len, 8))]
                                    (when (> ___uc 0377)
                                        (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (Util'runtimeException-1 (str "Unsupported character: \\" ___token)))
                )
            )
        )
    )
)

#_closure
(class-ns EdnListReader (§ extends AFn)
    (defn #_"EdnListReader" EdnListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß (cast' LineNumberingPushbackReader ___r).getLineNumber()))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts))]
                        (when (.isEmpty ___list)
                            (§ return PersistentList'EMPTY)
                        )
                        (let [#_"IObj" ___s (ß (IObj) PersistentList'create(___list))]
                            ___s
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnVectorReader (§ extends AFn)
    (defn #_"EdnVectorReader" EdnVectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts)))
        )
    )
)

#_closure
(class-ns EdnMapReader (§ extends AFn)
    (defn #_"EdnMapReader" EdnMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts).toArray())]
                (when (ß (___a.length & 1) == 1)
                    (throw (Util'runtimeException-1 "Map literal must contain an even number of forms"))
                )
                (RT'map ___a)
            )
        )
    )
)

#_closure
(class-ns EdnSetReader (§ extends AFn)
    (defn #_"EdnSetReader" EdnSetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß PersistentHashSet'createWithCheck-1l(readDelimitedList(\}, ___r, true, ___opts)))
        )
    )
)

#_closure
(class-ns EdnUnmatchedDelimiterReader (§ extends AFn)
    (defn #_"EdnUnmatchedDelimiterReader" EdnUnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts]
        (throw (Util'runtimeException-1 (str "Unmatched delimiter: " ___rightdelim)))
    )
)

#_closure
(class-ns EdnUnreadableReader (§ extends AFn)
    (defn #_"EdnUnreadableReader" EdnUnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts]
        (throw (Util'runtimeException-1 "Unreadable form"))
    )
)

#_closure
(class-ns EdnSymbolicValueReader (§ extends AFn)
    (defn #_"EdnSymbolicValueReader" EdnSymbolicValueReader'new []
        (AFn'new)
    )

    (def #_"IPersistentMap" EdnSymbolicValueReader'specials (ß PersistentHashMap'create-1a(
        (object-array [
            (Symbol'intern-1 "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern-1 "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern-1 "NaN")  Double/NaN
        ])
    )))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EdnSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (EdnReader'read-5 ___r, true, nil, true, ___opts)]
                (when (not (ß ___o instanceof Symbol))
                    (throw (Util'runtimeException-1 (str "Invalid token: ##" ___o)))
                )
                (when (not (ß EdnSymbolicValueReader'specials.containsKey(___o)))
                    (throw (Util'runtimeException-1 (str "Unknown symbolic value: ##" ___o)))
                )

                (ß EdnSymbolicValueReader'specials.valAt(___o))
            )
        )
    )
)

#_closure
(class-ns TaggedReader (§ extends AFn)
    (defn #_"TaggedReader" TaggedReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"TaggedReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___name (EdnReader'read-5 ___r, true, nil, false, ___opts)]
                (when (not (ß ___name instanceof Symbol))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (ß (Symbol)___name)]
                    (ß this.readTagged(___r, ___sym, (IPersistentMap) ___opts))
                )
            )
        )
    )

    (§ def #_"Keyword" TaggedReader'READERS (Keyword'intern-2 nil, "readers"))
    (§ def #_"Keyword" TaggedReader'DEFAULT (Keyword'intern-2 nil, "default"))

    #_method
    (§ defn- #_"Object" (§ method readTagged) [#_"TaggedReader" this, #_"PushbackReader" ___reader, #_"Symbol" ___tag, #_"IPersistentMap" ___opts]
        (let [#_"Object" ___o (EdnReader'read-5 ___reader, true, nil, true, ___opts)]
            (let [#_"ILookup" ___readers (ß (ILookup)RT'get-2(___opts, TaggedReader'READERS))]
                (let [#_"IFn" ___dataReader (ß (IFn)RT'get-2(___readers, ___tag))]
                    (when (nil? ___dataReader)
                        (§ ass ___dataReader (ß (IFn)RT'get-2(RT'DEFAULT_DATA_READERS.deref(), ___tag)))
                    )
                    (if (nil? ___dataReader)
                        (do
                            (let [#_"IFn" ___defaultReader (ß (IFn)RT'get-2(___opts, TaggedReader'DEFAULT))]
                                (if (some? ___defaultReader)
                                    (do
                                        (.invoke ___defaultReader, ___tag, ___o)
                                    )
                                    (do
                                        (throw (RuntimeException. (str "No reader function for tag " (.toString ___tag))))
                                    )
                                )
                            )
                        )
                        (do
                            (.invoke ___dataReader, ___o)
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnReader
    (def #_"IFn[]" EdnReader'macros (§ typeless make-array IFn 256))
    (def #_"IFn[]" EdnReader'dispatchMacros (§ typeless make-array IFn 256))
    (def #_"Pattern" EdnReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" EdnReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" EdnReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" EdnReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    (§ def #_"IFn" EdnReader'taggedReader (TaggedReader'new))

    (§ static
        (§ ass (ß macros[\"]) (EdnStringReader'new)) ;; oops! "
        (§ ass (ß macros[\;]) (EdnCommentReader'new))
        (§ ass (ß macros[\^]) (EdnMetaReader'new))
        (§ ass (ß macros[\(]) (EdnListReader'new))
        (§ ass (ß macros[\)]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\[]) (EdnVectorReader'new))
        (§ ass (ß macros[\]]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\{]) (EdnMapReader'new))
        (§ ass (ß macros[\}]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\\]) (EdnCharacterReader'new))
        (§ ass (ß macros[\#]) (EdnDispatchReader'new))

        (§ ass (ß dispatchMacros[\#]) (EdnSymbolicValueReader'new))
        (§ ass (ß dispatchMacros[\^]) (EdnMetaReader'new))
        (§ ass (ß dispatchMacros[\{]) (EdnSetReader'new))
        (§ ass (ß dispatchMacros[\<]) (EdnUnreadableReader'new))
        (§ ass (ß dispatchMacros[\_]) (EdnDiscardReader'new))
        (§ ass (ß dispatchMacros[\:]) (EdnNamespaceMapReader'new))
    )

    (defn #_"boolean" EdnReader'nonConstituent [#_"int" ___ch]
        (ß ___ch == \@ || ___ch == \` || ___ch == \~)
    )

    (defn #_"Object" EdnReader'readString [#_"String" ___s, #_"IPersistentMap" ___opts]
        (let [#_"PushbackReader" ___r (PushbackReader. (java.io.StringReader. ___s))]
            (EdnReader'read-2 ___r, ___opts)
        )
    )

    (defn #_"boolean" EdnReader'isWhitespace [#_"int" ___ch]
        (ß (Character/isWhitespace(___ch) || ___ch == \,))
    )

    (defn #_"void" EdnReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (ß ___ch != -1)
            (try
                (.unread ___r, ___ch)
                (catch IOException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
        )
        nil
    )

    (defn #_"int" EdnReader'read1 [#_"Reader" ___r]
        (try
            (.read ___r)
            (catch IOException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (§ def #_"Keyword" EdnReader'EOF (Keyword'intern-2 nil, "eof"))

    (defn #_"Object" EdnReader'read-2 [#_"PushbackReader" ___r, #_"IPersistentMap" ___opts]
        (EdnReader'read-5 ___r, (not (ß ___opts.containsKey(EdnReader'EOF))), (ß ___opts.valAt(EdnReader'EOF)), false, ___opts)
    )

    (defn #_"Object" EdnReader'read-5 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (try
            (while true
                (let [#_"int" ___ch (ß EdnReader'read1(___r))]
                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß EdnReader'read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (when ___eofIsError
                            (throw (Util'runtimeException-1 "EOF while reading"))
                        )
                        (§ return ___eofValue)
                    )

                    (when (Character/isDigit ___ch)
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (when (RT'suppressRead)
                                (§ return nil)
                            )
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                (when (RT'suppressRead)
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (ß ___ret == ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (ß ___ch == \+ || ___ch == \-)
                            (let [#_"int" ___ch2 (ß EdnReader'read1(___r))]
                                (when (Character/isDigit ___ch2)
                                    (EdnReader'unread ___r, ___ch2)
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (when (RT'suppressRead)
                                            (§ return nil)
                                        )
                                        (§ return ___n)
                                    )
                                )
                                (EdnReader'unread ___r, ___ch2)
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch, true))]
                            (when (RT'suppressRead)
                                (§ return nil)
                            )
                            (§ return (ß interpretToken(___token)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (ß ___isRecursive || (not (ß ___r instanceof LineNumberingPushbackReader)))
                    (throw (Util'sneakyThrow ___e))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (ß (LineNumberingPushbackReader) ___r)]
                    (throw (ß EdnReaderException'new((.getLineNumber ___rdr), (.getColumnNumber ___rdr), ___e)))
                )
            )
        )
    )

    (defn- #_"String" EdnReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch, #_"boolean" ___leadConstituent]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (when (ß ___leadConstituent && nonConstituent(___initch))
                (throw (Util'runtimeException-1 (str "Invalid leading character: " (ß (char)___initch))))
            )

            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (ß EdnReader'read1(___r))]
                    (cond (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                        (do
                            (EdnReader'unread ___r, ___ch)
                            (§ return (.toString ___sb))
                        )
                        (ß nonConstituent(___ch))
                        (do
                            (throw (Util'runtimeException-1 (str "Invalid constituent character: " (ß (char)___ch))))
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (defn- #_"Object" EdnReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (ß EdnReader'read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || EdnReader'isMacro(___ch))
                        (EdnReader'unread ___r, ___ch)
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (.toString ___sb)]
                (let [#_"Object" ___n (ß matchNumber(___s))]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (str "Invalid number: " ___s)))
                    )
                    ___n
                )
            )
        )
    )

    (defn- #_"int" EdnReader'readUnicodeChar-4 [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß (.length ___token) != ___offset + ___length)
            (throw (IllegalArgumentException. (str "Invalid unicode character: \\" ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [#_"int" ___i ___offset] (ß ___i < ___offset + ___length) [(inc ___i)]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (ß ___d == -1)
                        (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt ___token, ___i))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (defn- #_"int" EdnReader'readUnicodeChar-5 [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (Character/digit ___initch, ___base)]
            (when (ß ___uc == -1)
                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___initch))))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [___i ___i] (< ___i ___length) [(inc ___i)]
                    (let [#_"int" ___ch (ß EdnReader'read1(___r))]
                        (when (ß ___ch == -1 || isWhitespace(___ch) || EdnReader'isMacro(___ch))
                            (EdnReader'unread ___r, ___ch)
                            (§ break )
                        )
                        (let [#_"int" ___d (Character/digit ___ch, ___base)]
                            (when (ß ___d == -1)
                                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___ch))))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (ß ___i != ___length && ___exact)
                    (throw (IllegalArgumentException. (str "Invalid character length: " ___i ", should be: " ___length)))
                )
                ___uc
            )
        )
    )

    (defn- #_"Object" EdnReader'interpretToken [#_"String" ___s]
        (cond (.equals ___s, "nil")
            (do
                (§ return nil)
            )
            (.equals ___s, "true")
            (do
                (§ return RT'T)
            )
            (.equals ___s, "false")
            (do
                (§ return RT'F)
            )
        )

        (let [#_"Object" ___ret nil]
            (§ ass ___ret (ß matchSymbol(___s)))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (Util'runtimeException-1 (str "Invalid token: " ___s)))
        )
    )

    (defn- #_"Object" EdnReader'matchSymbol [#_"String" ___s]
        (let [#_"Matcher" ___m (.matcher EdnReader'symbolPat, ___s)]
            (when (.matches ___m)
                (let [#_"int" ___gc (.groupCount ___m)]
                    (let [#_"String" ___ns (.group ___m, 1)]
                        (let [#_"String" ___name (.group ___m, 2)]
                            (when (ß ___ns != nil && ___ns.endsWith(":/") || ___name.endsWith(":") || ___s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (.startsWith ___s, "::")
                                (§ return nil)
                            )
                            (let [#_"boolean" ___isKeyword (ß ___s.charAt(0) == \:)]
                                (let [#_"Symbol" ___sym (Symbol'intern-1 (.substring ___s, (if ___isKeyword 1 0)))]
                                    (when ___isKeyword
                                        (§ return (Keyword'intern ___sym))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"Object" EdnReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (.matcher EdnReader'intPat, ___s)]
            (when (.matches ___m)
                (when (ß ___m.group(2) != nil)
                    (when (ß ___m.group(8) != nil)
                        (§ return BigInt'ZERO)
                    )
                    (§ return (Numbers'num-1l 0))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (.group ___m, 3)))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (.group ___m, 4)))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (.group ___m, 5)))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (.group ___m, 7)))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (BigInteger. ___n, ___radix)]
                                (when ___negate
                                    (§ ass ___bn (.negate ___bn))
                                )
                                (when (ß ___m.group(8) != nil)
                                    (§ return (BigInt'fromBigInteger ___bn))
                                )
                                (§ return (if (< (.bitLength ___bn) 64) (Numbers'num-1l (.longValue ___bn)) (BigInt'fromBigInteger ___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (.matcher EdnReader'floatPat, ___s))
            (when (.matches ___m)
                (when (ß ___m.group(4) != nil)
                    (§ return (§ unsure BigDecimal. (.group ___m, 1)))
                )
                (§ return (Double/parseDouble ___s))
            )
            (§ ass ___m (.matcher EdnReader'ratioPat, ___s))
            (when (.matches ___m)
                (let [#_"String" ___numerator (.group ___m, 1)]
                    (when (.startsWith ___numerator, "+")
                        (§ ass ___numerator (.substring ___numerator, 1))
                    )

                    (§ return (Numbers'divide-2oo (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. ___numerator))), (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. (.group ___m, 2))))))
                )
            )
            nil
        )
    )

    (defn- #_"IFn" EdnReader'getMacro [#_"int" ___ch]
        (when (ß ___ch < macros.length)
            (§ return (ß macros[___ch]))
        )
        nil
    )

    (defn- #_"boolean" EdnReader'isMacro [#_"int" ___ch]
        (ß ___ch < macros.length && macros[___ch] != nil)
    )

    (defn- #_"boolean" EdnReader'isTerminatingMacro [#_"int" ___ch]
        (ß (___ch != \# && ___ch != \' && EdnReader'isMacro(___ch)))
    )

    (defn #_"List" EdnReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? (cast' LineNumberingPushbackReader ___r).getLineNumber() :or -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (while true
                    (let [#_"int" ___ch (ß EdnReader'read1(___r))]
                        (while (ß isWhitespace(___ch))
                            (§ ass ___ch (ß EdnReader'read1(___r)))
                        )

                        (when (ß ___ch == -1)
                            (if (< ___firstline 0)
                                (do
                                    (throw (Util'runtimeException-1 "EOF while reading"))
                                )
                                (do
                                    (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                )
                            )
                        )

                        (when (ß ___ch == ___delim)
                            (§ break )
                        )

                        (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                            (if (some? ___macroFn)
                                (do
                                    (let [#_"Object" ___mret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                        ;; no op macros return the reader
                                        (when (ß ___mret != ___r)
                                            (.add ___a, ___mret)
                                        )
                                    )
                                )
                                (do
                                    (EdnReader'unread ___r, ___ch)

                                    (let [#_"Object" ___o (EdnReader'read-5 ___r, true, nil, ___isRecursive, ___opts)]
                                        (when (ß ___o != ___r)
                                            (.add ___a, ___o)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                ___a
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeqState
    (defn- #_"EnumerationSeqState" EnumerationSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"EnumerationSeqState" EnumerationSeqState'new []
        (EnumerationSeqState'init)
    )
)

(class-ns EnumerationSeq (§ extends ASeq)
    (defn #_"EnumerationSeq" EnumerationSeq'create [#_"Enumeration" ___iter]
        (when (.hasMoreElements ___iter)
            (§ return (EnumerationSeq'new-1 ___iter))
        )
        nil
    )

    (defn- #_"EnumerationSeq" EnumerationSeq'init []
        (hash-map
            #_"Enumeration" :iter nil
            #_"EnumerationSeqState" :state nil
        )
    )

    (defn #_"EnumerationSeq" EnumerationSeq'new-1 [#_"Enumeration" ___iter]
        (let [this (merge (ASeq'new) (EnumerationSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) (EnumerationSeqState'new))
            (§ ass (:val (:state this)) (:state this))
            (§ ass (:_rest (:state this)) (:state this))
            this
        )
    )

    (defn #_"EnumerationSeq" EnumerationSeq'new-3 [#_"IPersistentMap" ___meta, #_"Enumeration" ___iter, #_"EnumerationSeqState" ___state]
        (let [this (merge (ASeq'new ___meta) (EnumerationSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"EnumerationSeq" this]
        (when (ß (:val (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:val (:state this)) == (:state this))
                    (§ ass (:val (:state this)) (.nextElement (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"EnumerationSeq" this]
        (when (ß (:_rest (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:_rest (:state this)) == (:state this))
                    (first this)
                    (§ ass (:_rest (:state this)) (EnumerationSeq'create (:iter this)))
                )
            )
        )
        (ß (ISeq) (:_rest (:state this)))
    )

    #_method
    (§ defn #_"EnumerationSeq" (§ method withMeta) [#_"EnumerationSeq" this, #_"IPersistentMap" ___meta]
        (EnumerationSeq'new-3 ___meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (defn- #_"ExceptionInfo" ExceptionInfo'init []
        (hash-map
            #_"IPersistentMap" :data nil
        )
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-2 [#_"String" ___s, #_"IPersistentMap" ___data]
        (ExceptionInfo'new-3 ___s, ___data, nil)
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-3 [#_"String" ___s, #_"IPersistentMap" ___data, #_"Throwable" ___throwable]
        (let [this (merge (§ foreign RuntimeException'new ___s, ___throwable) (ExceptionInfo'init))]
            ;; nil cause is equivalent to not passing a cause
            (if (some? ___data)
                (do
                    (§ ass (:data this) ___data)
                )
                (do
                    (throw (IllegalArgumentException. "Additional data must be non-nil."))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getData) [#_"ExceptionInfo" this]
        (:data this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ExceptionInfo" this]
        (str "cloiure.lang.ExceptionInfo: " (ß this.getMessage()) " " (ß (:data this).toString()))
    )
)
)

(java-ns cloiure.lang.Fn

(§ defprotocol Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (defn- #_"FnLoaderThunk" FnLoaderThunk'init []
        (hash-map
            #_"Var" :v nil
            #_"ClassLoader" :loader nil
            #_"String" :fnClassName nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"FnLoaderThunk" FnLoaderThunk'new [#_"Var" ___v, #_"String" ___fnClassName]
        (let [this (merge (RestFn'new) (FnLoaderThunk'init))]
            (§ ass (:v this) ___v)
            (§ ass (:loader this) (ß (ClassLoader) RT'FN_LOADER_VAR.get()))
            (§ ass (:fnClassName this) ___fnClassName)
            (§ ass (:fn this) nil)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" ___arg1]
        (.load this)
        (ß (:fn this).invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (.load this)
        (ß (:fn this).invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (.load this)
        (ß (:fn this).invoke(___arg1, ___arg2, ___arg3))
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"FnLoaderThunk" this, #_"Object" ___args]
        (.load this)
        (ß (:fn this).applyTo((cast' ISeq ___args)))
    )

    #_method
    (§ defn- #_"void" (§ method load) [#_"FnLoaderThunk" this]
        (when (nil? (:fn this))
            (try
                (§ ass (:fn this) (ß (IFn) Class/forName((:fnClassName this), true, (:loader this)).newInstance()))
                (catch Exception ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
            (§ ass (:root (:v this)) (:fn this))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getRequiredArity) [#_"FnLoaderThunk" this]
        0
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"FnLoaderThunk" this, #_"IPersistentMap" ___meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ defprotocol IAtom
    #_abstract
    (#_"Object" IAtom'''(§ method swap-2) [#_"IAtom" this, #_"IFn" ___f])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-3) [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-4) [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IAtom'''(§ method swap-5) [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"boolean" IAtom'''(§ method compareAndSet) [#_"IAtom" this, #_"Object" ___oldv, #_"Object" ___newv])
    #_abstract
    (#_"Object" IAtom'''(§ method reset) [#_"IAtom" this, #_"Object" ___newval])
)
)

(java-ns cloiure.lang.IAtom2

(§ defprotocol IAtom2 #_(§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-2) [#_"IAtom2" this, #_"IFn" ___f])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-3) [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-4) [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method swapVals-5) [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentVector" IAtom2'''(§ method resetVals) [#_"IAtom2" this, #_"Object" ___newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ defprotocol IBlockingDeref
    #_abstract
    (#_"Object" IBlockingDeref'''(§ method deref) [#_"IBlockingDeref" this, #_"long" ___ms, #_"Object" ___timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(§ defprotocol IChunk #_(§ extends Indexed)
    #_abstract
    (#_"IChunk" IChunk'''(§ method dropFirst) [#_"IChunk" this])
    #_abstract
    (#_"Object" IChunk'''(§ method reduce) [#_"IChunk" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ defprotocol IChunkedSeq #_(§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" IChunkedSeq'''(§ method chunkedFirst) [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''(§ method chunkedNext) [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''(§ method chunkedMore) [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(§ defprotocol IDeref
    #_abstract
    (#_"Object" IDeref'''(§ method deref) [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(§ defprotocol IEditableCollection
    #_abstract
    (#_"ITransientCollection" IEditableCollection'''(§ method asTransient) [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ defprotocol IExceptionInfo
    #_abstract
    (#_"IPersistentMap" IExceptionInfo'''(§ method getData) [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

(§ defprotocol L
    #_abstract
    (#_"long" L'''(§ method invokePrim) [#_"L" this])
)

(§ defprotocol D
    #_abstract
    (#_"double" D'''(§ method invokePrim) [#_"D" this])
)

(§ defprotocol OL
    #_abstract
    (#_"long" OL'''(§ method invokePrim) [#_"OL" this, #_"Object" ___arg0])
)

(§ defprotocol OD
    #_abstract
    (#_"double" OD'''(§ method invokePrim) [#_"OD" this, #_"Object" ___arg0])
)

(§ defprotocol LO
    #_abstract
    (#_"Object" LO'''(§ method invokePrim) [#_"LO" this, #_"long" ___arg0])
)

(§ defprotocol LL
    #_abstract
    (#_"long" LL'''(§ method invokePrim) [#_"LL" this, #_"long" ___arg0])
)

(§ defprotocol LD
    #_abstract
    (#_"double" LD'''(§ method invokePrim) [#_"LD" this, #_"long" ___arg0])
)

(§ defprotocol DO
    #_abstract
    (#_"Object" DO'''(§ method invokePrim) [#_"DO" this, #_"double" ___arg0])
)

(§ defprotocol DL
    #_abstract
    (#_"long" DL'''(§ method invokePrim) [#_"DL" this, #_"double" ___arg0])
)

(§ defprotocol DD
    #_abstract
    (#_"double" DD'''(§ method invokePrim) [#_"DD" this, #_"double" ___arg0])
)

(§ defprotocol OOL
    #_abstract
    (#_"long" OOL'''(§ method invokePrim) [#_"OOL" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol OOD
    #_abstract
    (#_"double" OOD'''(§ method invokePrim) [#_"OOD" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol OLO
    #_abstract
    (#_"Object" OLO'''(§ method invokePrim) [#_"OLO" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(§ defprotocol OLL
    #_abstract
    (#_"long" OLL'''(§ method invokePrim) [#_"OLL" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(§ defprotocol OLD
    #_abstract
    (#_"double" OLD'''(§ method invokePrim) [#_"OLD" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(§ defprotocol ODO
    #_abstract
    (#_"Object" ODO'''(§ method invokePrim) [#_"ODO" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(§ defprotocol ODL
    #_abstract
    (#_"long" ODL'''(§ method invokePrim) [#_"ODL" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(§ defprotocol ODD
    #_abstract
    (#_"double" ODD'''(§ method invokePrim) [#_"ODD" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(§ defprotocol LOO
    #_abstract
    (#_"Object" LOO'''(§ method invokePrim) [#_"LOO" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol LOL
    #_abstract
    (#_"long" LOL'''(§ method invokePrim) [#_"LOL" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol LOD
    #_abstract
    (#_"double" LOD'''(§ method invokePrim) [#_"LOD" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol LLO
    #_abstract
    (#_"Object" LLO'''(§ method invokePrim) [#_"LLO" this, #_"long" ___arg0, #_"long" ___arg1])
)

(§ defprotocol LLL
    #_abstract
    (#_"long" LLL'''(§ method invokePrim) [#_"LLL" this, #_"long" ___arg0, #_"long" ___arg1])
)

(§ defprotocol LLD
    #_abstract
    (#_"double" LLD'''(§ method invokePrim) [#_"LLD" this, #_"long" ___arg0, #_"long" ___arg1])
)

(§ defprotocol LDO
    #_abstract
    (#_"Object" LDO'''(§ method invokePrim) [#_"LDO" this, #_"long" ___arg0, #_"double" ___arg1])
)

(§ defprotocol LDL
    #_abstract
    (#_"long" LDL'''(§ method invokePrim) [#_"LDL" this, #_"long" ___arg0, #_"double" ___arg1])
)

(§ defprotocol LDD
    #_abstract
    (#_"double" LDD'''(§ method invokePrim) [#_"LDD" this, #_"long" ___arg0, #_"double" ___arg1])
)

(§ defprotocol DOO
    #_abstract
    (#_"Object" DOO'''(§ method invokePrim) [#_"DOO" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol DOL
    #_abstract
    (#_"long" DOL'''(§ method invokePrim) [#_"DOL" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol DOD
    #_abstract
    (#_"double" DOD'''(§ method invokePrim) [#_"DOD" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(§ defprotocol DLO
    #_abstract
    (#_"Object" DLO'''(§ method invokePrim) [#_"DLO" this, #_"double" ___arg0, #_"long" ___arg1])
)

(§ defprotocol DLL
    #_abstract
    (#_"long" DLL'''(§ method invokePrim) [#_"DLL" this, #_"double" ___arg0, #_"long" ___arg1])
)

(§ defprotocol DLD
    #_abstract
    (#_"double" DLD'''(§ method invokePrim) [#_"DLD" this, #_"double" ___arg0, #_"long" ___arg1])
)

(§ defprotocol DDO
    #_abstract
    (#_"Object" DDO'''(§ method invokePrim) [#_"DDO" this, #_"double" ___arg0, #_"double" ___arg1])
)

(§ defprotocol DDL
    #_abstract
    (#_"long" DDL'''(§ method invokePrim) [#_"DDL" this, #_"double" ___arg0, #_"double" ___arg1])
)

(§ defprotocol DDD
    #_abstract
    (#_"double" DDD'''(§ method invokePrim) [#_"DDD" this, #_"double" ___arg0, #_"double" ___arg1])
)

(§ defprotocol OOOL
    #_abstract
    (#_"long" OOOL'''(§ method invokePrim) [#_"OOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OOOD
    #_abstract
    (#_"double" OOOD'''(§ method invokePrim) [#_"OOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OOLO
    #_abstract
    (#_"Object" OOLO'''(§ method invokePrim) [#_"OOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OOLL
    #_abstract
    (#_"long" OOLL'''(§ method invokePrim) [#_"OOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OOLD
    #_abstract
    (#_"double" OOLD'''(§ method invokePrim) [#_"OOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OODO
    #_abstract
    (#_"Object" OODO'''(§ method invokePrim) [#_"OODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OODL
    #_abstract
    (#_"long" OODL'''(§ method invokePrim) [#_"OODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OODD
    #_abstract
    (#_"double" OODD'''(§ method invokePrim) [#_"OODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OLOO
    #_abstract
    (#_"Object" OLOO'''(§ method invokePrim) [#_"OLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OLOL
    #_abstract
    (#_"long" OLOL'''(§ method invokePrim) [#_"OLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OLOD
    #_abstract
    (#_"double" OLOD'''(§ method invokePrim) [#_"OLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol OLLO
    #_abstract
    (#_"Object" OLLO'''(§ method invokePrim) [#_"OLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OLLL
    #_abstract
    (#_"long" OLLL'''(§ method invokePrim) [#_"OLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OLLD
    #_abstract
    (#_"double" OLLD'''(§ method invokePrim) [#_"OLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol OLDO
    #_abstract
    (#_"Object" OLDO'''(§ method invokePrim) [#_"OLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OLDL
    #_abstract
    (#_"long" OLDL'''(§ method invokePrim) [#_"OLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OLDD
    #_abstract
    (#_"double" OLDD'''(§ method invokePrim) [#_"OLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol ODOO
    #_abstract
    (#_"Object" ODOO'''(§ method invokePrim) [#_"ODOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol ODOL
    #_abstract
    (#_"long" ODOL'''(§ method invokePrim) [#_"ODOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol ODOD
    #_abstract
    (#_"double" ODOD'''(§ method invokePrim) [#_"ODOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol ODLO
    #_abstract
    (#_"Object" ODLO'''(§ method invokePrim) [#_"ODLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol ODLL
    #_abstract
    (#_"long" ODLL'''(§ method invokePrim) [#_"ODLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol ODLD
    #_abstract
    (#_"double" ODLD'''(§ method invokePrim) [#_"ODLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol ODDO
    #_abstract
    (#_"Object" ODDO'''(§ method invokePrim) [#_"ODDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol ODDL
    #_abstract
    (#_"long" ODDL'''(§ method invokePrim) [#_"ODDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol ODDD
    #_abstract
    (#_"double" ODDD'''(§ method invokePrim) [#_"ODDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LOOO
    #_abstract
    (#_"Object" LOOO'''(§ method invokePrim) [#_"LOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LOOL
    #_abstract
    (#_"long" LOOL'''(§ method invokePrim) [#_"LOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LOOD
    #_abstract
    (#_"double" LOOD'''(§ method invokePrim) [#_"LOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LOLO
    #_abstract
    (#_"Object" LOLO'''(§ method invokePrim) [#_"LOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LOLL
    #_abstract
    (#_"long" LOLL'''(§ method invokePrim) [#_"LOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LOLD
    #_abstract
    (#_"double" LOLD'''(§ method invokePrim) [#_"LOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LODO
    #_abstract
    (#_"Object" LODO'''(§ method invokePrim) [#_"LODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LODL
    #_abstract
    (#_"long" LODL'''(§ method invokePrim) [#_"LODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LODD
    #_abstract
    (#_"double" LODD'''(§ method invokePrim) [#_"LODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LLOO
    #_abstract
    (#_"Object" LLOO'''(§ method invokePrim) [#_"LLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LLOL
    #_abstract
    (#_"long" LLOL'''(§ method invokePrim) [#_"LLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LLOD
    #_abstract
    (#_"double" LLOD'''(§ method invokePrim) [#_"LLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LLLO
    #_abstract
    (#_"Object" LLLO'''(§ method invokePrim) [#_"LLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LLLL
    #_abstract
    (#_"long" LLLL'''(§ method invokePrim) [#_"LLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LLLD
    #_abstract
    (#_"double" LLLD'''(§ method invokePrim) [#_"LLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LLDO
    #_abstract
    (#_"Object" LLDO'''(§ method invokePrim) [#_"LLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LLDL
    #_abstract
    (#_"long" LLDL'''(§ method invokePrim) [#_"LLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LLDD
    #_abstract
    (#_"double" LLDD'''(§ method invokePrim) [#_"LLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LDOO
    #_abstract
    (#_"Object" LDOO'''(§ method invokePrim) [#_"LDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LDOL
    #_abstract
    (#_"long" LDOL'''(§ method invokePrim) [#_"LDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LDOD
    #_abstract
    (#_"double" LDOD'''(§ method invokePrim) [#_"LDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol LDLO
    #_abstract
    (#_"Object" LDLO'''(§ method invokePrim) [#_"LDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LDLL
    #_abstract
    (#_"long" LDLL'''(§ method invokePrim) [#_"LDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LDLD
    #_abstract
    (#_"double" LDLD'''(§ method invokePrim) [#_"LDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol LDDO
    #_abstract
    (#_"Object" LDDO'''(§ method invokePrim) [#_"LDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LDDL
    #_abstract
    (#_"long" LDDL'''(§ method invokePrim) [#_"LDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol LDDD
    #_abstract
    (#_"double" LDDD'''(§ method invokePrim) [#_"LDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DOOO
    #_abstract
    (#_"Object" DOOO'''(§ method invokePrim) [#_"DOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DOOL
    #_abstract
    (#_"long" DOOL'''(§ method invokePrim) [#_"DOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DOOD
    #_abstract
    (#_"double" DOOD'''(§ method invokePrim) [#_"DOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DOLO
    #_abstract
    (#_"Object" DOLO'''(§ method invokePrim) [#_"DOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DOLL
    #_abstract
    (#_"long" DOLL'''(§ method invokePrim) [#_"DOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DOLD
    #_abstract
    (#_"double" DOLD'''(§ method invokePrim) [#_"DOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DODO
    #_abstract
    (#_"Object" DODO'''(§ method invokePrim) [#_"DODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DODL
    #_abstract
    (#_"long" DODL'''(§ method invokePrim) [#_"DODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DODD
    #_abstract
    (#_"double" DODD'''(§ method invokePrim) [#_"DODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DLOO
    #_abstract
    (#_"Object" DLOO'''(§ method invokePrim) [#_"DLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DLOL
    #_abstract
    (#_"long" DLOL'''(§ method invokePrim) [#_"DLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DLOD
    #_abstract
    (#_"double" DLOD'''(§ method invokePrim) [#_"DLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DLLO
    #_abstract
    (#_"Object" DLLO'''(§ method invokePrim) [#_"DLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DLLL
    #_abstract
    (#_"long" DLLL'''(§ method invokePrim) [#_"DLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DLLD
    #_abstract
    (#_"double" DLLD'''(§ method invokePrim) [#_"DLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DLDO
    #_abstract
    (#_"Object" DLDO'''(§ method invokePrim) [#_"DLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DLDL
    #_abstract
    (#_"long" DLDL'''(§ method invokePrim) [#_"DLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DLDD
    #_abstract
    (#_"double" DLDD'''(§ method invokePrim) [#_"DLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DDOO
    #_abstract
    (#_"Object" DDOO'''(§ method invokePrim) [#_"DDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DDOL
    #_abstract
    (#_"long" DDOL'''(§ method invokePrim) [#_"DDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DDOD
    #_abstract
    (#_"double" DDOD'''(§ method invokePrim) [#_"DDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(§ defprotocol DDLO
    #_abstract
    (#_"Object" DDLO'''(§ method invokePrim) [#_"DDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DDLL
    #_abstract
    (#_"long" DDLL'''(§ method invokePrim) [#_"DDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DDLD
    #_abstract
    (#_"double" DDLD'''(§ method invokePrim) [#_"DDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(§ defprotocol DDDO
    #_abstract
    (#_"Object" DDDO'''(§ method invokePrim) [#_"DDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DDDL
    #_abstract
    (#_"long" DDDL'''(§ method invokePrim) [#_"DDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol DDDD
    #_abstract
    (#_"double" DDDD'''(§ method invokePrim) [#_"DDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(§ defprotocol OOOOL
    #_abstract
    (#_"long" OOOOL'''(§ method invokePrim) [#_"OOOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOOOD
    #_abstract
    (#_"double" OOOOD'''(§ method invokePrim) [#_"OOOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOOLO
    #_abstract
    (#_"Object" OOOLO'''(§ method invokePrim) [#_"OOOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOOLL
    #_abstract
    (#_"long" OOOLL'''(§ method invokePrim) [#_"OOOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOOLD
    #_abstract
    (#_"double" OOOLD'''(§ method invokePrim) [#_"OOOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOODO
    #_abstract
    (#_"Object" OOODO'''(§ method invokePrim) [#_"OOODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOODL
    #_abstract
    (#_"long" OOODL'''(§ method invokePrim) [#_"OOODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOODD
    #_abstract
    (#_"double" OOODD'''(§ method invokePrim) [#_"OOODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOLOO
    #_abstract
    (#_"Object" OOLOO'''(§ method invokePrim) [#_"OOLOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOLOL
    #_abstract
    (#_"long" OOLOL'''(§ method invokePrim) [#_"OOLOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOLOD
    #_abstract
    (#_"double" OOLOD'''(§ method invokePrim) [#_"OOLOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OOLLO
    #_abstract
    (#_"Object" OOLLO'''(§ method invokePrim) [#_"OOLLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOLLL
    #_abstract
    (#_"long" OOLLL'''(§ method invokePrim) [#_"OOLLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOLLD
    #_abstract
    (#_"double" OOLLD'''(§ method invokePrim) [#_"OOLLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OOLDO
    #_abstract
    (#_"Object" OOLDO'''(§ method invokePrim) [#_"OOLDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOLDL
    #_abstract
    (#_"long" OOLDL'''(§ method invokePrim) [#_"OOLDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OOLDD
    #_abstract
    (#_"double" OOLDD'''(§ method invokePrim) [#_"OOLDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OODOO
    #_abstract
    (#_"Object" OODOO'''(§ method invokePrim) [#_"OODOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OODOL
    #_abstract
    (#_"long" OODOL'''(§ method invokePrim) [#_"OODOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OODOD
    #_abstract
    (#_"double" OODOD'''(§ method invokePrim) [#_"OODOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OODLO
    #_abstract
    (#_"Object" OODLO'''(§ method invokePrim) [#_"OODLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OODLL
    #_abstract
    (#_"long" OODLL'''(§ method invokePrim) [#_"OODLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OODLD
    #_abstract
    (#_"double" OODLD'''(§ method invokePrim) [#_"OODLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OODDO
    #_abstract
    (#_"Object" OODDO'''(§ method invokePrim) [#_"OODDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OODDL
    #_abstract
    (#_"long" OODDL'''(§ method invokePrim) [#_"OODDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OODDD
    #_abstract
    (#_"double" OODDD'''(§ method invokePrim) [#_"OODDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLOOO
    #_abstract
    (#_"Object" OLOOO'''(§ method invokePrim) [#_"OLOOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLOOL
    #_abstract
    (#_"long" OLOOL'''(§ method invokePrim) [#_"OLOOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLOOD
    #_abstract
    (#_"double" OLOOD'''(§ method invokePrim) [#_"OLOOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLOLO
    #_abstract
    (#_"Object" OLOLO'''(§ method invokePrim) [#_"OLOLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLOLL
    #_abstract
    (#_"long" OLOLL'''(§ method invokePrim) [#_"OLOLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLOLD
    #_abstract
    (#_"double" OLOLD'''(§ method invokePrim) [#_"OLOLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLODO
    #_abstract
    (#_"Object" OLODO'''(§ method invokePrim) [#_"OLODO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLODL
    #_abstract
    (#_"long" OLODL'''(§ method invokePrim) [#_"OLODL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLODD
    #_abstract
    (#_"double" OLODD'''(§ method invokePrim) [#_"OLODD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLLOO
    #_abstract
    (#_"Object" OLLOO'''(§ method invokePrim) [#_"OLLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLLOL
    #_abstract
    (#_"long" OLLOL'''(§ method invokePrim) [#_"OLLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLLOD
    #_abstract
    (#_"double" OLLOD'''(§ method invokePrim) [#_"OLLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLLLO
    #_abstract
    (#_"Object" OLLLO'''(§ method invokePrim) [#_"OLLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLLLL
    #_abstract
    (#_"long" OLLLL'''(§ method invokePrim) [#_"OLLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLLLD
    #_abstract
    (#_"double" OLLLD'''(§ method invokePrim) [#_"OLLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLLDO
    #_abstract
    (#_"Object" OLLDO'''(§ method invokePrim) [#_"OLLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLLDL
    #_abstract
    (#_"long" OLLDL'''(§ method invokePrim) [#_"OLLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLLDD
    #_abstract
    (#_"double" OLLDD'''(§ method invokePrim) [#_"OLLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLDOO
    #_abstract
    (#_"Object" OLDOO'''(§ method invokePrim) [#_"OLDOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLDOL
    #_abstract
    (#_"long" OLDOL'''(§ method invokePrim) [#_"OLDOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLDOD
    #_abstract
    (#_"double" OLDOD'''(§ method invokePrim) [#_"OLDOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol OLDLO
    #_abstract
    (#_"Object" OLDLO'''(§ method invokePrim) [#_"OLDLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLDLL
    #_abstract
    (#_"long" OLDLL'''(§ method invokePrim) [#_"OLDLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLDLD
    #_abstract
    (#_"double" OLDLD'''(§ method invokePrim) [#_"OLDLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol OLDDO
    #_abstract
    (#_"Object" OLDDO'''(§ method invokePrim) [#_"OLDDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLDDL
    #_abstract
    (#_"long" OLDDL'''(§ method invokePrim) [#_"OLDDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol OLDDD
    #_abstract
    (#_"double" OLDDD'''(§ method invokePrim) [#_"OLDDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODOOO
    #_abstract
    (#_"Object" ODOOO'''(§ method invokePrim) [#_"ODOOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODOOL
    #_abstract
    (#_"long" ODOOL'''(§ method invokePrim) [#_"ODOOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODOOD
    #_abstract
    (#_"double" ODOOD'''(§ method invokePrim) [#_"ODOOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODOLO
    #_abstract
    (#_"Object" ODOLO'''(§ method invokePrim) [#_"ODOLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODOLL
    #_abstract
    (#_"long" ODOLL'''(§ method invokePrim) [#_"ODOLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODOLD
    #_abstract
    (#_"double" ODOLD'''(§ method invokePrim) [#_"ODOLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODODO
    #_abstract
    (#_"Object" ODODO'''(§ method invokePrim) [#_"ODODO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODODL
    #_abstract
    (#_"long" ODODL'''(§ method invokePrim) [#_"ODODL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODODD
    #_abstract
    (#_"double" ODODD'''(§ method invokePrim) [#_"ODODD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODLOO
    #_abstract
    (#_"Object" ODLOO'''(§ method invokePrim) [#_"ODLOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODLOL
    #_abstract
    (#_"long" ODLOL'''(§ method invokePrim) [#_"ODLOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODLOD
    #_abstract
    (#_"double" ODLOD'''(§ method invokePrim) [#_"ODLOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODLLO
    #_abstract
    (#_"Object" ODLLO'''(§ method invokePrim) [#_"ODLLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODLLL
    #_abstract
    (#_"long" ODLLL'''(§ method invokePrim) [#_"ODLLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODLLD
    #_abstract
    (#_"double" ODLLD'''(§ method invokePrim) [#_"ODLLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODLDO
    #_abstract
    (#_"Object" ODLDO'''(§ method invokePrim) [#_"ODLDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODLDL
    #_abstract
    (#_"long" ODLDL'''(§ method invokePrim) [#_"ODLDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODLDD
    #_abstract
    (#_"double" ODLDD'''(§ method invokePrim) [#_"ODLDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODDOO
    #_abstract
    (#_"Object" ODDOO'''(§ method invokePrim) [#_"ODDOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODDOL
    #_abstract
    (#_"long" ODDOL'''(§ method invokePrim) [#_"ODDOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODDOD
    #_abstract
    (#_"double" ODDOD'''(§ method invokePrim) [#_"ODDOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol ODDLO
    #_abstract
    (#_"Object" ODDLO'''(§ method invokePrim) [#_"ODDLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODDLL
    #_abstract
    (#_"long" ODDLL'''(§ method invokePrim) [#_"ODDLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODDLD
    #_abstract
    (#_"double" ODDLD'''(§ method invokePrim) [#_"ODDLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol ODDDO
    #_abstract
    (#_"Object" ODDDO'''(§ method invokePrim) [#_"ODDDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODDDL
    #_abstract
    (#_"long" ODDDL'''(§ method invokePrim) [#_"ODDDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol ODDDD
    #_abstract
    (#_"double" ODDDD'''(§ method invokePrim) [#_"ODDDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOOOO
    #_abstract
    (#_"Object" LOOOO'''(§ method invokePrim) [#_"LOOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOOOL
    #_abstract
    (#_"long" LOOOL'''(§ method invokePrim) [#_"LOOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOOOD
    #_abstract
    (#_"double" LOOOD'''(§ method invokePrim) [#_"LOOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOOLO
    #_abstract
    (#_"Object" LOOLO'''(§ method invokePrim) [#_"LOOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOOLL
    #_abstract
    (#_"long" LOOLL'''(§ method invokePrim) [#_"LOOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOOLD
    #_abstract
    (#_"double" LOOLD'''(§ method invokePrim) [#_"LOOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOODO
    #_abstract
    (#_"Object" LOODO'''(§ method invokePrim) [#_"LOODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOODL
    #_abstract
    (#_"long" LOODL'''(§ method invokePrim) [#_"LOODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOODD
    #_abstract
    (#_"double" LOODD'''(§ method invokePrim) [#_"LOODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOLOO
    #_abstract
    (#_"Object" LOLOO'''(§ method invokePrim) [#_"LOLOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOLOL
    #_abstract
    (#_"long" LOLOL'''(§ method invokePrim) [#_"LOLOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOLOD
    #_abstract
    (#_"double" LOLOD'''(§ method invokePrim) [#_"LOLOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LOLLO
    #_abstract
    (#_"Object" LOLLO'''(§ method invokePrim) [#_"LOLLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOLLL
    #_abstract
    (#_"long" LOLLL'''(§ method invokePrim) [#_"LOLLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOLLD
    #_abstract
    (#_"double" LOLLD'''(§ method invokePrim) [#_"LOLLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LOLDO
    #_abstract
    (#_"Object" LOLDO'''(§ method invokePrim) [#_"LOLDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOLDL
    #_abstract
    (#_"long" LOLDL'''(§ method invokePrim) [#_"LOLDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LOLDD
    #_abstract
    (#_"double" LOLDD'''(§ method invokePrim) [#_"LOLDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LODOO
    #_abstract
    (#_"Object" LODOO'''(§ method invokePrim) [#_"LODOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LODOL
    #_abstract
    (#_"long" LODOL'''(§ method invokePrim) [#_"LODOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LODOD
    #_abstract
    (#_"double" LODOD'''(§ method invokePrim) [#_"LODOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LODLO
    #_abstract
    (#_"Object" LODLO'''(§ method invokePrim) [#_"LODLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LODLL
    #_abstract
    (#_"long" LODLL'''(§ method invokePrim) [#_"LODLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LODLD
    #_abstract
    (#_"double" LODLD'''(§ method invokePrim) [#_"LODLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LODDO
    #_abstract
    (#_"Object" LODDO'''(§ method invokePrim) [#_"LODDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LODDL
    #_abstract
    (#_"long" LODDL'''(§ method invokePrim) [#_"LODDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LODDD
    #_abstract
    (#_"double" LODDD'''(§ method invokePrim) [#_"LODDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLOOO
    #_abstract
    (#_"Object" LLOOO'''(§ method invokePrim) [#_"LLOOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLOOL
    #_abstract
    (#_"long" LLOOL'''(§ method invokePrim) [#_"LLOOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLOOD
    #_abstract
    (#_"double" LLOOD'''(§ method invokePrim) [#_"LLOOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLOLO
    #_abstract
    (#_"Object" LLOLO'''(§ method invokePrim) [#_"LLOLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLOLL
    #_abstract
    (#_"long" LLOLL'''(§ method invokePrim) [#_"LLOLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLOLD
    #_abstract
    (#_"double" LLOLD'''(§ method invokePrim) [#_"LLOLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLODO
    #_abstract
    (#_"Object" LLODO'''(§ method invokePrim) [#_"LLODO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLODL
    #_abstract
    (#_"long" LLODL'''(§ method invokePrim) [#_"LLODL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLODD
    #_abstract
    (#_"double" LLODD'''(§ method invokePrim) [#_"LLODD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLLOO
    #_abstract
    (#_"Object" LLLOO'''(§ method invokePrim) [#_"LLLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLLOL
    #_abstract
    (#_"long" LLLOL'''(§ method invokePrim) [#_"LLLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLLOD
    #_abstract
    (#_"double" LLLOD'''(§ method invokePrim) [#_"LLLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLLLO
    #_abstract
    (#_"Object" LLLLO'''(§ method invokePrim) [#_"LLLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLLLL
    #_abstract
    (#_"long" LLLLL'''(§ method invokePrim) [#_"LLLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLLLD
    #_abstract
    (#_"double" LLLLD'''(§ method invokePrim) [#_"LLLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLLDO
    #_abstract
    (#_"Object" LLLDO'''(§ method invokePrim) [#_"LLLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLLDL
    #_abstract
    (#_"long" LLLDL'''(§ method invokePrim) [#_"LLLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLLDD
    #_abstract
    (#_"double" LLLDD'''(§ method invokePrim) [#_"LLLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLDOO
    #_abstract
    (#_"Object" LLDOO'''(§ method invokePrim) [#_"LLDOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLDOL
    #_abstract
    (#_"long" LLDOL'''(§ method invokePrim) [#_"LLDOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLDOD
    #_abstract
    (#_"double" LLDOD'''(§ method invokePrim) [#_"LLDOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LLDLO
    #_abstract
    (#_"Object" LLDLO'''(§ method invokePrim) [#_"LLDLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLDLL
    #_abstract
    (#_"long" LLDLL'''(§ method invokePrim) [#_"LLDLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLDLD
    #_abstract
    (#_"double" LLDLD'''(§ method invokePrim) [#_"LLDLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LLDDO
    #_abstract
    (#_"Object" LLDDO'''(§ method invokePrim) [#_"LLDDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLDDL
    #_abstract
    (#_"long" LLDDL'''(§ method invokePrim) [#_"LLDDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LLDDD
    #_abstract
    (#_"double" LLDDD'''(§ method invokePrim) [#_"LLDDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDOOO
    #_abstract
    (#_"Object" LDOOO'''(§ method invokePrim) [#_"LDOOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDOOL
    #_abstract
    (#_"long" LDOOL'''(§ method invokePrim) [#_"LDOOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDOOD
    #_abstract
    (#_"double" LDOOD'''(§ method invokePrim) [#_"LDOOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDOLO
    #_abstract
    (#_"Object" LDOLO'''(§ method invokePrim) [#_"LDOLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDOLL
    #_abstract
    (#_"long" LDOLL'''(§ method invokePrim) [#_"LDOLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDOLD
    #_abstract
    (#_"double" LDOLD'''(§ method invokePrim) [#_"LDOLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDODO
    #_abstract
    (#_"Object" LDODO'''(§ method invokePrim) [#_"LDODO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDODL
    #_abstract
    (#_"long" LDODL'''(§ method invokePrim) [#_"LDODL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDODD
    #_abstract
    (#_"double" LDODD'''(§ method invokePrim) [#_"LDODD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDLOO
    #_abstract
    (#_"Object" LDLOO'''(§ method invokePrim) [#_"LDLOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDLOL
    #_abstract
    (#_"long" LDLOL'''(§ method invokePrim) [#_"LDLOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDLOD
    #_abstract
    (#_"double" LDLOD'''(§ method invokePrim) [#_"LDLOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDLLO
    #_abstract
    (#_"Object" LDLLO'''(§ method invokePrim) [#_"LDLLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDLLL
    #_abstract
    (#_"long" LDLLL'''(§ method invokePrim) [#_"LDLLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDLLD
    #_abstract
    (#_"double" LDLLD'''(§ method invokePrim) [#_"LDLLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDLDO
    #_abstract
    (#_"Object" LDLDO'''(§ method invokePrim) [#_"LDLDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDLDL
    #_abstract
    (#_"long" LDLDL'''(§ method invokePrim) [#_"LDLDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDLDD
    #_abstract
    (#_"double" LDLDD'''(§ method invokePrim) [#_"LDLDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDDOO
    #_abstract
    (#_"Object" LDDOO'''(§ method invokePrim) [#_"LDDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDDOL
    #_abstract
    (#_"long" LDDOL'''(§ method invokePrim) [#_"LDDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDDOD
    #_abstract
    (#_"double" LDDOD'''(§ method invokePrim) [#_"LDDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol LDDLO
    #_abstract
    (#_"Object" LDDLO'''(§ method invokePrim) [#_"LDDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDDLL
    #_abstract
    (#_"long" LDDLL'''(§ method invokePrim) [#_"LDDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDDLD
    #_abstract
    (#_"double" LDDLD'''(§ method invokePrim) [#_"LDDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol LDDDO
    #_abstract
    (#_"Object" LDDDO'''(§ method invokePrim) [#_"LDDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDDDL
    #_abstract
    (#_"long" LDDDL'''(§ method invokePrim) [#_"LDDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol LDDDD
    #_abstract
    (#_"double" LDDDD'''(§ method invokePrim) [#_"LDDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOOOO
    #_abstract
    (#_"Object" DOOOO'''(§ method invokePrim) [#_"DOOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOOOL
    #_abstract
    (#_"long" DOOOL'''(§ method invokePrim) [#_"DOOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOOOD
    #_abstract
    (#_"double" DOOOD'''(§ method invokePrim) [#_"DOOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOOLO
    #_abstract
    (#_"Object" DOOLO'''(§ method invokePrim) [#_"DOOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOOLL
    #_abstract
    (#_"long" DOOLL'''(§ method invokePrim) [#_"DOOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOOLD
    #_abstract
    (#_"double" DOOLD'''(§ method invokePrim) [#_"DOOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOODO
    #_abstract
    (#_"Object" DOODO'''(§ method invokePrim) [#_"DOODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOODL
    #_abstract
    (#_"long" DOODL'''(§ method invokePrim) [#_"DOODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOODD
    #_abstract
    (#_"double" DOODD'''(§ method invokePrim) [#_"DOODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOLOO
    #_abstract
    (#_"Object" DOLOO'''(§ method invokePrim) [#_"DOLOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOLOL
    #_abstract
    (#_"long" DOLOL'''(§ method invokePrim) [#_"DOLOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOLOD
    #_abstract
    (#_"double" DOLOD'''(§ method invokePrim) [#_"DOLOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DOLLO
    #_abstract
    (#_"Object" DOLLO'''(§ method invokePrim) [#_"DOLLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOLLL
    #_abstract
    (#_"long" DOLLL'''(§ method invokePrim) [#_"DOLLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOLLD
    #_abstract
    (#_"double" DOLLD'''(§ method invokePrim) [#_"DOLLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DOLDO
    #_abstract
    (#_"Object" DOLDO'''(§ method invokePrim) [#_"DOLDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOLDL
    #_abstract
    (#_"long" DOLDL'''(§ method invokePrim) [#_"DOLDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DOLDD
    #_abstract
    (#_"double" DOLDD'''(§ method invokePrim) [#_"DOLDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DODOO
    #_abstract
    (#_"Object" DODOO'''(§ method invokePrim) [#_"DODOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DODOL
    #_abstract
    (#_"long" DODOL'''(§ method invokePrim) [#_"DODOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DODOD
    #_abstract
    (#_"double" DODOD'''(§ method invokePrim) [#_"DODOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DODLO
    #_abstract
    (#_"Object" DODLO'''(§ method invokePrim) [#_"DODLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DODLL
    #_abstract
    (#_"long" DODLL'''(§ method invokePrim) [#_"DODLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DODLD
    #_abstract
    (#_"double" DODLD'''(§ method invokePrim) [#_"DODLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DODDO
    #_abstract
    (#_"Object" DODDO'''(§ method invokePrim) [#_"DODDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DODDL
    #_abstract
    (#_"long" DODDL'''(§ method invokePrim) [#_"DODDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DODDD
    #_abstract
    (#_"double" DODDD'''(§ method invokePrim) [#_"DODDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLOOO
    #_abstract
    (#_"Object" DLOOO'''(§ method invokePrim) [#_"DLOOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLOOL
    #_abstract
    (#_"long" DLOOL'''(§ method invokePrim) [#_"DLOOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLOOD
    #_abstract
    (#_"double" DLOOD'''(§ method invokePrim) [#_"DLOOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLOLO
    #_abstract
    (#_"Object" DLOLO'''(§ method invokePrim) [#_"DLOLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLOLL
    #_abstract
    (#_"long" DLOLL'''(§ method invokePrim) [#_"DLOLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLOLD
    #_abstract
    (#_"double" DLOLD'''(§ method invokePrim) [#_"DLOLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLODO
    #_abstract
    (#_"Object" DLODO'''(§ method invokePrim) [#_"DLODO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLODL
    #_abstract
    (#_"long" DLODL'''(§ method invokePrim) [#_"DLODL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLODD
    #_abstract
    (#_"double" DLODD'''(§ method invokePrim) [#_"DLODD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLLOO
    #_abstract
    (#_"Object" DLLOO'''(§ method invokePrim) [#_"DLLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLLOL
    #_abstract
    (#_"long" DLLOL'''(§ method invokePrim) [#_"DLLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLLOD
    #_abstract
    (#_"double" DLLOD'''(§ method invokePrim) [#_"DLLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLLLO
    #_abstract
    (#_"Object" DLLLO'''(§ method invokePrim) [#_"DLLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLLLL
    #_abstract
    (#_"long" DLLLL'''(§ method invokePrim) [#_"DLLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLLLD
    #_abstract
    (#_"double" DLLLD'''(§ method invokePrim) [#_"DLLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLLDO
    #_abstract
    (#_"Object" DLLDO'''(§ method invokePrim) [#_"DLLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLLDL
    #_abstract
    (#_"long" DLLDL'''(§ method invokePrim) [#_"DLLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLLDD
    #_abstract
    (#_"double" DLLDD'''(§ method invokePrim) [#_"DLLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLDOO
    #_abstract
    (#_"Object" DLDOO'''(§ method invokePrim) [#_"DLDOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLDOL
    #_abstract
    (#_"long" DLDOL'''(§ method invokePrim) [#_"DLDOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLDOD
    #_abstract
    (#_"double" DLDOD'''(§ method invokePrim) [#_"DLDOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DLDLO
    #_abstract
    (#_"Object" DLDLO'''(§ method invokePrim) [#_"DLDLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLDLL
    #_abstract
    (#_"long" DLDLL'''(§ method invokePrim) [#_"DLDLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLDLD
    #_abstract
    (#_"double" DLDLD'''(§ method invokePrim) [#_"DLDLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DLDDO
    #_abstract
    (#_"Object" DLDDO'''(§ method invokePrim) [#_"DLDDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLDDL
    #_abstract
    (#_"long" DLDDL'''(§ method invokePrim) [#_"DLDDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DLDDD
    #_abstract
    (#_"double" DLDDD'''(§ method invokePrim) [#_"DLDDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDOOO
    #_abstract
    (#_"Object" DDOOO'''(§ method invokePrim) [#_"DDOOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDOOL
    #_abstract
    (#_"long" DDOOL'''(§ method invokePrim) [#_"DDOOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDOOD
    #_abstract
    (#_"double" DDOOD'''(§ method invokePrim) [#_"DDOOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDOLO
    #_abstract
    (#_"Object" DDOLO'''(§ method invokePrim) [#_"DDOLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDOLL
    #_abstract
    (#_"long" DDOLL'''(§ method invokePrim) [#_"DDOLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDOLD
    #_abstract
    (#_"double" DDOLD'''(§ method invokePrim) [#_"DDOLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDODO
    #_abstract
    (#_"Object" DDODO'''(§ method invokePrim) [#_"DDODO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDODL
    #_abstract
    (#_"long" DDODL'''(§ method invokePrim) [#_"DDODL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDODD
    #_abstract
    (#_"double" DDODD'''(§ method invokePrim) [#_"DDODD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDLOO
    #_abstract
    (#_"Object" DDLOO'''(§ method invokePrim) [#_"DDLOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDLOL
    #_abstract
    (#_"long" DDLOL'''(§ method invokePrim) [#_"DDLOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDLOD
    #_abstract
    (#_"double" DDLOD'''(§ method invokePrim) [#_"DDLOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDLLO
    #_abstract
    (#_"Object" DDLLO'''(§ method invokePrim) [#_"DDLLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDLLL
    #_abstract
    (#_"long" DDLLL'''(§ method invokePrim) [#_"DDLLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDLLD
    #_abstract
    (#_"double" DDLLD'''(§ method invokePrim) [#_"DDLLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDLDO
    #_abstract
    (#_"Object" DDLDO'''(§ method invokePrim) [#_"DDLDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDLDL
    #_abstract
    (#_"long" DDLDL'''(§ method invokePrim) [#_"DDLDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDLDD
    #_abstract
    (#_"double" DDLDD'''(§ method invokePrim) [#_"DDLDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDDOO
    #_abstract
    (#_"Object" DDDOO'''(§ method invokePrim) [#_"DDDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDDOL
    #_abstract
    (#_"long" DDDOL'''(§ method invokePrim) [#_"DDDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDDOD
    #_abstract
    (#_"double" DDDOD'''(§ method invokePrim) [#_"DDDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(§ defprotocol DDDLO
    #_abstract
    (#_"Object" DDDLO'''(§ method invokePrim) [#_"DDDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDDLL
    #_abstract
    (#_"long" DDDLL'''(§ method invokePrim) [#_"DDDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDDLD
    #_abstract
    (#_"double" DDDLD'''(§ method invokePrim) [#_"DDDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(§ defprotocol DDDDO
    #_abstract
    (#_"Object" DDDDO'''(§ method invokePrim) [#_"DDDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDDDL
    #_abstract
    (#_"long" DDDDL'''(§ method invokePrim) [#_"DDDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(§ defprotocol DDDDD
    #_abstract
    (#_"double" DDDDD'''(§ method invokePrim) [#_"DDDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ defprotocol IFn #_(§ extends Callable, Runnable)
    #_abstract
    (#_"Object" IFn'''(§ method invoke-1) [#_"IFn" this])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-2) [#_"IFn" this, #_"Object" ___arg1])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-3) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-4) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-5) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-6) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-7) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-8) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7])
    #_abstract
    (#_"Object" IFn'''(§ method invoke-9) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-10) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-11) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-12) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-13) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-14) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-15) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-16) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-17) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-18) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-19) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18])

    #_abstract
  #_(#_"Object" IFn'''(§ method invoke-20) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
  #_(#_"Object" IFn'''(§ method invoke-21) [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
    (#_"Object" IFn'''(§ method invoke-22) [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" #_arg19, #_"Object" #_arg20, #_"Object..." ___args])

    #_abstract
    (#_"Object" IFn'''(§ method applyTo) [#_"IFn" this, #_"ISeq" ___arglist])
)
)

(java-ns cloiure.lang.IHashEq

(§ defprotocol IHashEq
    #_abstract
    (#_"int" IHashEq'''(§ method hasheq) [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ defprotocol IKeywordLookup
    #_abstract
    (#_"ILookupThunk" IKeywordLookup'''(§ method getLookupThunk) [#_"IKeywordLookup" this, #_"Keyword" ___k])
)
)

(java-ns cloiure.lang.IKVReduce

(§ defprotocol IKVReduce
    #_abstract
    (#_"Object" IKVReduce'''(§ method kvreduce) [#_"IKVReduce" this, #_"IFn" ___f, #_"Object" ___init])
)
)

(java-ns cloiure.lang.ILookup

(§ defprotocol ILookup
    #_abstract
    (#_"Object" ILookup'''(§ method valAt-2) [#_"ILookup" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ILookup'''(§ method valAt-3) [#_"ILookup" this, #_"Object" ___key, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(§ defprotocol ILookupSite
    #_abstract
    (#_"ILookupThunk" ILookupSite'''(§ method fault) [#_"ILookupSite" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.ILookupThunk

(§ defprotocol ILookupThunk
    #_abstract
    (#_"Object" ILookupThunk'''(§ method get) [#_"ILookupThunk" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ defprotocol IMapEntry #_(§ extends Map$Entry)
    #_abstract
    (#_"Object" IMapEntry'''(§ method key) [#_"IMapEntry" this])
    #_abstract
    (#_"Object" IMapEntry'''(§ method val) [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ defprotocol IMapIterable
    #_abstract
    (#_"Iterator" IMapIterable'''(§ method keyIterator) [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" IMapIterable'''(§ method valIterator) [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(§ defprotocol IMeta
    #_abstract
    (#_"IPersistentMap" IMeta'''(§ method meta) [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(§ defprotocol Indexed #_(§ extends Counted)
    #_abstract
    (#_"Object" Indexed'''(§ method nth-2) [#_"Indexed" this, #_"int" ___i])
    #_abstract
    (#_"Object" Indexed'''(§ method nth-3) [#_"Indexed" this, #_"int" ___i, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(§ defprotocol IndexedSeq #_(§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" IndexedSeq'''(§ method index) [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (defn- #_"Object[]" Intrinsics'oa [#_"Object..." ___arr]
        ___arr
    )

    (def #_"IPersistentMap" Intrinsics'ops (ß RT'map(
        (object-array [
            "public static double cloiure.lang.Numbers.add(double,double)"                Opcodes/DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      Opcodes/LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       Opcodes/LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      Opcodes/LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           Opcodes/DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             Opcodes/DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                Opcodes/LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (ß oa(Opcodes/L2I, Opcodes/LSHL))
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (ß oa(Opcodes/L2I, Opcodes/LSHR))
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (ß oa(Opcodes/L2I, Opcodes/LUSHR))
            "public static double cloiure.lang.Numbers.minus(double)"                     Opcodes/DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              Opcodes/DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (ß oa(Opcodes/DCONST_1, Opcodes/DADD))
            "public static double cloiure.lang.Numbers.dec(double)"                       (ß oa(Opcodes/DCONST_1, Opcodes/DSUB))
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 Opcodes/LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                Opcodes/ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               Opcodes/ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       Opcodes/IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           Opcodes/IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      Opcodes/ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            Opcodes/INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (ß oa(Opcodes/ICONST_1, Opcodes/IADD))
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (ß oa(Opcodes/ICONST_1, Opcodes/ISUB))
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      Opcodes/IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        Opcodes/IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     Opcodes/IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            Opcodes/LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      Opcodes/DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               Opcodes/LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           Opcodes/DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    Opcodes/DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          Opcodes/LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       Opcodes/LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" Opcodes/DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (ß oa(Opcodes/DCONST_1, Opcodes/DADD))
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (ß oa(Opcodes/LCONST_1, Opcodes/LADD))
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (ß oa(Opcodes/DCONST_1, Opcodes/DSUB))
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (ß oa(Opcodes/LCONST_1, Opcodes/LSUB))

            "public static short cloiure.lang.RT.aget(short[],int)"                       Opcodes/SALOAD
            "public static float cloiure.lang.RT.aget(float[],int)"                       Opcodes/FALOAD
            "public static double cloiure.lang.RT.aget(double[],int)"                     Opcodes/DALOAD
            "public static int cloiure.lang.RT.aget(int[],int)"                           Opcodes/IALOAD
            "public static long cloiure.lang.RT.aget(long[],int)"                         Opcodes/LALOAD
            "public static char cloiure.lang.RT.aget(char[],int)"                         Opcodes/CALOAD
            "public static byte cloiure.lang.RT.aget(byte[],int)"                         Opcodes/BALOAD
            "public static boolean cloiure.lang.RT.aget(boolean[],int)"                   Opcodes/BALOAD
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)" Opcodes/AALOAD
            "public static int cloiure.lang.RT.alength(int[])"                            Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(long[])"                           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(char[])"                           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(java.lang.Object[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(byte[])"                           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(float[])"                          Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(short[])"                          Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(boolean[])"                        Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(double[])"                         Opcodes/ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            Opcodes/L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          Opcodes/NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           Opcodes/F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" Opcodes/NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  Opcodes/F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   Opcodes/L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   Opcodes/I2D
            "public static long cloiure.lang.RT.longCast(long)"                Opcodes/NOP
            "public static long cloiure.lang.RT.longCast(short)"               Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(byte)"                Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(int)"                 Opcodes/I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         Opcodes/L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       Opcodes/D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        Opcodes/F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      Opcodes/F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     D2
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       Opcodes/NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        Opcodes/I2L
        ])
    )))

    ;; map to instructions terminated with comparator for branch to false
    (def #_"IPersistentMap" Intrinsics'preds (ß RT'map(
        (object-array [
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (ß oa(Opcodes/DCMPG, Opcodes/IFGE))
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (ß oa(Opcodes/LCMP, Opcodes/IFGE))
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (ß oa(Opcodes/DCMPL, Opcodes/IFNE))
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (ß oa(Opcodes/LCMP, Opcodes/IFNE))
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (ß oa(Opcodes/DCMPG, Opcodes/IFGT))
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (ß oa(Opcodes/LCMP, Opcodes/IFGT))
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (ß oa(Opcodes/LCMP, Opcodes/IFLE))
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (ß oa(Opcodes/DCMPL, Opcodes/IFLE))
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (ß oa(Opcodes/LCMP, Opcodes/IFLT))
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (ß oa(Opcodes/DCMPL, Opcodes/IFLT))
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (ß oa(Opcodes/LCMP, Opcodes/IFNE))
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (ß oa(Opcodes/IF_ICMPNE))
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (ß oa(Opcodes/DCMPL, Opcodes/IFNE))

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (ß oa(Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFNE))
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (ß oa(Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFNE))
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (ß oa(Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFLE))
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (ß oa(Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFLE))
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (ß oa(Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFGE))
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (ß oa(Opcodes/DCONST_0, Opcodes/DCMPG, Opcodes/IFGE))
        ])
    )))
)
)

(java-ns cloiure.lang.IObj

(§ defprotocol IObj #_(§ extends IMeta)
    #_abstract
    (#_"IObj" IObj'''(§ method withMeta) [#_"IObj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.IPending

(§ defprotocol IPending
    #_abstract
    (#_"boolean" IPending'''(§ method isRealized) [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ defprotocol IPersistentCollection #_(§ extends Seqable)
    #_abstract
    (#_"int" IPersistentCollection'''(§ method count) [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''(§ method cons) [#_"IPersistentCollection" this, #_"Object" ___o])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''(§ method empty) [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" IPersistentCollection'''(§ method equiv) [#_"IPersistentCollection" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IPersistentList

(§ defprotocol IPersistentList #_(§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ defprotocol IPersistentMap #_(§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method assoc) [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method assocEx) [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''(§ method without) [#_"IPersistentMap" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentSet

(§ defprotocol IPersistentSet #_(§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" IPersistentSet'''(§ method disjoin) [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" IPersistentSet'''(§ method contains) [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" IPersistentSet'''(§ method get) [#_"IPersistentSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentStack

(§ defprotocol IPersistentStack #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" IPersistentStack'''(§ method peek) [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" IPersistentStack'''(§ method pop) [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(§ defprotocol IPersistentVector #_(§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" IPersistentVector'''(§ method length) [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''(§ method assocN) [#_"IPersistentVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''(§ method cons) [#_"IPersistentVector" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IProxy

(§ defprotocol IProxy
    #_abstract
    (#_"void" IProxy'''(§ method __initCloiureFnMappings) [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"void" IProxy'''(§ method __updateCloiureFnMappings) [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"IPersistentMap" IProxy'''(§ method __getCloiureFnMappings) [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(§ defprotocol IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ defprotocol IReduce #_(§ extends IReduceInit)
    #_abstract
    (#_"Object" IReduce'''(§ method reduce) [#_"IReduce" this, #_"IFn" ___f])
)
)

(java-ns cloiure.lang.IReduceInit

(§ defprotocol IReduceInit
    #_abstract
    (#_"Object" IReduceInit'''(§ method reduce) [#_"IReduceInit" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IRef

(§ defprotocol IRef #_(§ extends IDeref)
    #_abstract
    (#_"void" IRef'''(§ method setValidator) [#_"IRef" this, #_"IFn" ___vf])
    #_abstract
    (#_"IFn" IRef'''(§ method getValidator) [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" IRef'''(§ method getWatches) [#_"IRef" this])
    #_abstract
    (#_"IRef" IRef'''(§ method addWatch) [#_"IRef" this, #_"Object" ___key, #_"IFn" ___callback])
    #_abstract
    (#_"IRef" IRef'''(§ method removeWatch) [#_"IRef" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IReference

(§ defprotocol IReference #_(§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" IReference'''(§ method alterMeta) [#_"IReference" this, #_"IFn" ___alter, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentMap" IReference'''(§ method resetMeta) [#_"IReference" this, #_"IPersistentMap" ___m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ defprotocol ISeq #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" ISeq'''(§ method first) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method next) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method more) [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''(§ method cons) [#_"ISeq" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (defn- #_"Iterate" Iterate'init []
        (hash-map
            #_"IFn" :f nil ;; never nil
            #_"Object" :prevSeed nil
            #_volatile
            #_"Object" :_seed nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Iterate" Iterate'new-3 [#_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed]
        (let [this (merge (ASeq'new) (Iterate'init))]
            (§ ass (:f this) ___f)
            (§ ass (:prevSeed this) ___prevSeed)
            (§ ass (:_seed this) ___seed)
            this
        )
    )

    (defn- #_"Iterate" Iterate'new-5 [#_"IPersistentMap" ___meta, #_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed, #_"ISeq" ___next]
        (let [this (merge (ASeq'new ___meta) (Iterate'init))]
            (§ ass (:f this) ___f)
            (§ ass (:prevSeed this) ___prevSeed)
            (§ ass (:_seed this) ___seed)
            (§ ass (:_next this) ___next)
            this
        )
    )

    (defn #_"ISeq" Iterate'create [#_"IFn" ___f, #_"Object" ___seed]
        (Iterate'new-3 ___f, nil, ___seed)
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"Iterate" this]
        (ß ((:_seed this) != Iterate'UNREALIZED_SEED))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Iterate" this]
        (when (ß (:_seed this) == Iterate'UNREALIZED_SEED)
            (§ ass (:_seed this) (ß (:f this).invoke((:prevSeed this))))
        )
        (:_seed this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Iterate" this]
        (when (nil? (:_next this))
            (§ ass (:_next this) (ß Iterate'new-3((:f this), (first this), Iterate'UNREALIZED_SEED)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Iterate" (§ method withMeta) [#_"Iterate" this, #_"IPersistentMap" ___meta]
        (Iterate'new-5 ___meta, (:f this), (:prevSeed this), (:_seed this), (:_next this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Iterate" this, #_"IFn" ___rf]
        (let [#_"Object" ___first (first this)]
            (let [#_"Object" ___ret ___first]
                (let [#_"Object" ___v (ß (:f this).invoke(___first))]
                    (while true
                        (§ ass ___ret (.invoke ___rf, ___ret, ___v))
                        (when (RT'isReduced ___ret)
                            (§ return (ß (cast' IDeref ___ret).deref()))
                        )
                        (§ ass ___v (ß (:f this).invoke(___v)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Iterate" this, #_"IFn" ___rf, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"Object" ___v (first this)]
                (while true
                    (§ ass ___ret (.invoke ___rf, ___ret, ___v))
                    (when (RT'isReduced ___ret)
                        (§ return (ß (cast' IDeref ___ret).deref()))
                    )
                    (§ ass ___v (ß (:f this).invoke(___v)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeqState
    (defn- #_"IteratorSeqState" IteratorSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"IteratorSeqState" IteratorSeqState'new []
        (IteratorSeqState'init)
    )
)

(class-ns IteratorSeq (§ extends ASeq)
    (defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" ___iter]
        (when (.hasNext ___iter)
            (§ return (IteratorSeq'new-1 ___iter))
        )
        nil
    )

    (defn- #_"IteratorSeq" IteratorSeq'init []
        (hash-map
            #_"Iterator" :iter nil
            #_"IteratorSeqState" :state nil
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-1 [#_"Iterator" ___iter]
        (let [this (merge (ASeq'new) (IteratorSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) (IteratorSeqState'new))
            (§ ass (:val (:state this)) (:state this))
            (§ ass (:_rest (:state this)) (:state this))
            this
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-3 [#_"IPersistentMap" ___meta, #_"Iterator" ___iter, #_"IteratorSeqState" ___state]
        (let [this (merge (ASeq'new ___meta) (IteratorSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"IteratorSeq" this]
        (when (ß (:val (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:val (:state this)) == (:state this))
                    (§ ass (:val (:state this)) (next (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"IteratorSeq" this]
        (when (ß (:_rest (:state this)) == (:state this))
            (§ sync (:state this)
                (when (ß (:_rest (:state this)) == (:state this))
                    (first this)
                    (§ ass (:_rest (:state this)) (IteratorSeq'create (:iter this)))
                )
            )
        )
        (ß (ISeq) (:_rest (:state this)))
    )

    #_method
    (§ defn #_"IteratorSeq" (§ method withMeta) [#_"IteratorSeq" this, #_"IPersistentMap" ___meta]
        (IteratorSeq'new-3 ___meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ defprotocol ITransientAssociative #_(§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" ITransientAssociative'''(§ method assoc) [#_"ITransientAssociative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ defprotocol ITransientAssociative2 #_(§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" ITransientAssociative2'''(§ method containsKey) [#_"ITransientAssociative2" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" ITransientAssociative2'''(§ method entryAt) [#_"ITransientAssociative2" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientCollection

(§ defprotocol ITransientCollection
    #_abstract
    (#_"ITransientCollection" ITransientCollection'''(§ method conj) [#_"ITransientCollection" this, #_"Object" ___val])
    #_abstract
    (#_"IPersistentCollection" ITransientCollection'''(§ method persistent) [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(§ defprotocol ITransientMap #_(§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" ITransientMap'''(§ method assoc) [#_"ITransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"ITransientMap" ITransientMap'''(§ method without) [#_"ITransientMap" this, #_"Object" ___key])
    #_abstract
    (#_"IPersistentMap" ITransientMap'''(§ method persistent) [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(§ defprotocol ITransientSet #_(§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" ITransientSet'''(§ method disjoin) [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" ITransientSet'''(§ method contains) [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ITransientSet'''(§ method get) [#_"ITransientSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientVector

(§ defprotocol ITransientVector #_(§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" ITransientVector'''(§ method assocN) [#_"ITransientVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"ITransientVector" ITransientVector'''(§ method pop) [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(§ defprotocol IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'TABLE (ConcurrentHashMap.))

    (def #_"ReferenceQueue" Keyword'RQ (ReferenceQueue.))

    (defn #_"Keyword" Keyword'intern [#_"Symbol" ___sym]
        (let [#_"Keyword" ___k nil]
            (let [#_"Reference<Keyword>" ___existingRef (ß Keyword'TABLE.get(___sym))]
                (when (nil? ___existingRef)
                    (Util'clearCache Keyword'RQ, Keyword'TABLE)
                    (when (ß (.meta ___sym) != nil)
                        (§ ass ___sym (ß (Symbol) ___sym.withMeta(nil)))
                    )
                    (§ ass ___k (Keyword'new ___sym))
                    (§ ass ___existingRef (ß Keyword'TABLE.putIfAbsent(___sym, new WeakReference<Keyword>(___k, Keyword'RQ))))
                )
                (when (nil? ___existingRef)
                    (§ return ___k)
                )
                (let [#_"Keyword" ___existingk (.get ___existingRef)]
                    (when (some? ___existingk)
                        (§ return ___existingk)
                    )
                    ;; entry died in the interim, do over
                    (ß Keyword'TABLE.remove(___sym, ___existingRef))
                    (Keyword'intern ___sym)
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'intern-2 [#_"String" ___ns, #_"String" ___name]
        (Keyword'intern (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Keyword" Keyword'intern-1 [#_"String" ___nsname]
        (Keyword'intern (Symbol'intern-1 ___nsname))
    )

    (defn- #_"Keyword" Keyword'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"int" :hasheq 0
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Keyword" Keyword'new [#_"Symbol" ___sym]
        (let [this (Keyword'init)]
            (§ ass (:sym this) ___sym)
            (§ ass (:hasheq this) (ß (.hasheq ___sym) + 0x9e3779b9))
            this
        )
    )

    (defn #_"Keyword" Keyword'find [#_"Symbol" ___sym]
        (let [#_"Reference<Keyword>" ___ref (ß Keyword'TABLE.get(___sym))]
            (if (some? ___ref)
                (do
                    (.get ___ref)
                )
                (do
                    nil
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'find-2 [#_"String" ___ns, #_"String" ___name]
        (Keyword'find (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Keyword" Keyword'find-1 [#_"String" ___nsname]
        (Keyword'find (Symbol'intern-1 ___nsname))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Keyword" this]
        (ß (:sym this).hashCode() + 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"Keyword" this]
        (:hasheq this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Keyword" this]
        (when (nil? (:_str this))
            (§ ass (:_str this) (str ":" (:sym this)))
        )
        (:_str this)
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"Keyword" this]
        (throw (IllegalArgumentException. (str "Wrong number of args passed to keyword: " (.toString this))))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Keyword" this]
        (.throwArity this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this]
        (.throwArity this)
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Keyword" this, #_"Object" ___o]
        (ß (:sym this).compareTo((:sym (cast' Keyword ___o))))
    )

    #_method
    (§ defn #_"String" (§ method getNamespace) [#_"Keyword" this]
        (.getNamespace (:sym this))
    )

    #_method
    (§ defn #_"String" (§ method getName) [#_"Keyword" this]
        (.getName (:sym this))
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___obj]
        (when (ß ___obj instanceof ILookup)
            (§ return (ß (cast' ILookup ___obj).valAt(this)))
        )
        (RT'get-2 ___obj, this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___obj, #_"Object" ___notFound]
        (when (ß ___obj instanceof ILookup)
            (§ return (ß (cast' ILookup ___obj).valAt(this, ___notFound)))
        )
        (RT'get-3 ___obj, this, ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (.throwArity this)
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Keyword" this, #_"ISeq" ___arglist]
        (AFn'applyToHelper this, ___arglist)
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (defn- #_"KeywordLookupSite" KeywordLookupSite'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordLookupSite" KeywordLookupSite'new [#_"Keyword" ___k]
        (let [this (KeywordLookupSite'init)]
            (§ ass (:k this) ___k)
            this
        )
    )

    #_method
    (§ defn #_"ILookupThunk" (§ method fault) [#_"KeywordLookupSite" this, #_"Object" ___target]
        (cond (ß ___target instanceof IKeywordLookup)
            (do
                (§ return (.install this, ___target))
            )
            (ß ___target instanceof ILookup)
            (do
                (§ return (ß this.ilookupThunk((.getClass ___target))))
            )
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"KeywordLookupSite" this, #_"Object" ___target]
        (when (ß ___target instanceof IKeywordLookup || ___target instanceof ILookup)
            (§ return this)
        )
        (RT'get-2 ___target, (:k this))
    )

    #_method
    (§ defn- #_"ILookupThunk" (§ method ilookupThunk) [#_"KeywordLookupSite" this, #_"Class" ___c]
        (§ reify ILookupThunk()
            #_method
            (§ defn #_"Object" (§ method get) [#_"ILookupThunk" this, #_"Object" ___target]
                (when (ß ___target != nil && (.getClass ___target) == ___c)
                    (§ return (ß (cast' ILookup ___target).valAt((:k this))))
                )
                this
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" (§ method install) [#_"KeywordLookupSite" this, #_"Object" ___target]
        (let [#_"ILookupThunk" ___t (ß (cast' IKeywordLookup ___target).getLookupThunk((:k this)))]
            (when (some? ___t)
                (§ return ___t)
            )
            (ß this.ilookupThunk((.getClass ___target)))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (defn #_"IPersistentVector" LazilyPersistentVector'createOwning [#_"Object..." ___items]
        (when (ß ___items.length <= 32)
            (§ return (ß PersistentVector'new-4(___items.length, 5, PersistentVector'EMPTY_NODE, ___items)))
        )
        (PersistentVector'create-1a ___items)
    )

    (defn #_"int" LazilyPersistentVector'fcount [#_"Object" ___c]
        (when (ß ___c instanceof Counted)
            (§ return (ß (cast' Counted ___c).count()))
        )
        (ß (cast Collection ___c).size())
    )

    (defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" ___obj]
        (cond (ß ___obj instanceof IReduceInit)
            (do
                (ß PersistentVector'create-1r((cast' IReduceInit ___obj)))
            )
            (ß ___obj instanceof ISeq)
            (do
                (ß PersistentVector'create-1s(RT'seq(___obj)))
            )
            (ß ___obj instanceof Iterable)
            (do
                (ß PersistentVector'create-1i((cast Iterable ___obj)))
            )
            :else
            (do
                (ß createOwning(RT'toArray(___obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (defn- #_"LazySeq" LazySeq'init []
        (hash-map
            #_"IFn" :fn nil
            #_"Object" :sv nil
            #_"ISeq" :s nil
        )
    )

    (defn #_"LazySeq" LazySeq'new-1 [#_"IFn" ___fn]
        (let [this (merge (Obj'new) (LazySeq'init))]
            (§ ass (:fn this) ___fn)
            this
        )
    )

    (defn- #_"LazySeq" LazySeq'new-2 [#_"IPersistentMap" ___meta, #_"ISeq" ___s]
        (let [this (merge (Obj'new ___meta) (LazySeq'init))]
            (§ ass (:fn this) nil)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"LazySeq" this, #_"IPersistentMap" ___meta]
        (ß LazySeq'new-2(___meta, (.seq this)))
    )

    #_method
    (§ defn #_"Object" (§ method sval) [#_"LazySeq" this]
        (§ sync this
            (when (some? (:fn this))
                (§ ass (:sv this) (.invoke (:fn this)))
                (§ ass (:fn this) nil)
            )
            (when (some? (:sv this))
                (§ return (:sv this))
            )
            (:s this)
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"LazySeq" this]
        (§ sync this
            (.sval this)
            (when (some? (:sv this))
                (let [#_"Object" ___ls (:sv this)]
                    (§ ass (:sv this) nil)
                    (while (ß ___ls instanceof LazySeq)
                        (§ ass ___ls (ß (cast' LazySeq ___ls).sval()))
                    )
                    (§ ass (:s this) (RT'seq ___ls))
                )
            )
            (:s this)
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"LazySeq" this]
        (let [#_"int" ___c 0]
            (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                (§ ass ___c (inc ___c))
            )
            ___c
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"LazySeq" this]
        (.seq this)
        (when (nil? (:s this))
            (§ return nil)
        )
        (first (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"LazySeq" this]
        (.seq this)
        (when (nil? (:s this))
            (§ return nil)
        )
        (next (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"LazySeq" this]
        (.seq this)
        (when (nil? (:s this))
            (§ return PersistentList'EMPTY)
        )
        (.more (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method cons) [#_"LazySeq" this, #_"Object" ___o]
        (ß RT'cons(___o, (.seq this)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"LazySeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (.seq this)]
            (if (some? ___s)
                (do
                    (.equiv ___s, ___o)
                )
                (do
                    (ß (___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"LazySeq" this]
        (let [#_"ISeq" ___s (.seq this)]
            (when (nil? ___s)
                (§ return 1)
            )
            (Util'hash ___s)
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"LazySeq" this]
        (Murmur3'hashOrdered this)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (.seq this)]
            (if (some? ___s)
                (do
                    (.equals ___s, ___o)
                )
                (do
                    (ß (___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"LazySeq" this]
        (ß RT'seqToArray((.seq this)))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"LazySeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (not (ß this.contains(___o)))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"LazySeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"LazySeq" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"LazySeq" this]
        (ß ((.seq this) == nil))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"LazySeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"LazySeq" this]
        (ArrayList. this)
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"LazySeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (.reify this).subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"LazySeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this) #_"int" ___i 0] (some? ___s) [(next ___s) (inc ___i)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"LazySeq" this, #_"Object" ___o]
        (ß (.reify this).lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"LazySeq" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"LazySeq" this, #_"int" ___index]
        (ß (.reify this).listIterator(___index))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"LazySeq" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"LazySeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method isRealized) [#_"LazySeq" this]
        (§ sync this
            (ß ((:fn this) == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (def- #_"int" LineNumberingPushbackReader'newline (ß (int) \newline))

    (defn- #_"LineNumberingPushbackReader" LineNumberingPushbackReader'init []
        (hash-map
            #_"boolean" :_atLineStart true
            #_"boolean" :_prev false
            #_"int" :_columnNumber 1
        )
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-1 [#_"Reader" ___r]
        (merge (PushbackReader'new (LineNumberReader. ___r)) (LineNumberingPushbackReader'init))
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-2 [#_"Reader" ___r, #_"int" ___size]
        (merge (PushbackReader'new (LineNumberReader. ___r, ___size)) (LineNumberingPushbackReader'init))
    )

    #_method
    (§ defn #_"int" (§ method getLineNumber) [#_"LineNumberingPushbackReader" this]
        (ß (cast LineNumberReader in).getLineNumber() + 1)
    )

    #_method
    (§ defn #_"void" (§ method setLineNumber) [#_"LineNumberingPushbackReader" this, #_"int" ___line]
        (ß (cast LineNumberReader in).setLineNumber(___line - 1))
        nil
    )

    #_method
    (§ defn #_"int" (§ method getColumnNumber) [#_"LineNumberingPushbackReader" this]
        (:_columnNumber this)
    )

    #_method
    (§ defn #_"int" (§ method read) [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (.read super)]
            (§ ass (:_prev this) (:_atLineStart this))
            (if (ß (___c == LineNumberingPushbackReader'newline) || (___c == -1))
                (do
                    (§ ass (:_atLineStart this) true)
                    (§ ass (:_columnNumber this) 1)
                )
                (do
                    (§ ass (:_atLineStart this) false)
                    (§ ass (:_columnNumber this) (inc (:_columnNumber this)))
                )
            )
            ___c
        )
    )

    #_method
    (§ defn #_"void" (§ method unread) [#_"LineNumberingPushbackReader" this, #_"int" ___c] #_(§ throws IOException)
        (.unread super, ___c)
        (§ ass (:_atLineStart this) (:_prev this))
        (§ ass (:_columnNumber this) (dec (:_columnNumber this)))
        nil
    )

    #_method
    (§ defn #_"String" (§ method readLine) [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (.read this)]
            (§ let [#_"String" ___line]
                (§ switch ___c
                    (§ case -1)
                    (do
                        (§ ass ___line nil)
                        (§ break )
                    )
                    (§ case LineNumberingPushbackReader'newline)
                    (do
                        (§ ass ___line "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" ___first (ß String/valueOf((char) ___c))]
                            (let [#_"String" ___rest (ß (cast LineNumberReader in).readLine())]
                                (§ ass ___line (if (nil? ___rest) ___first (str ___first ___rest)))
                                (§ ass (:_prev this) false)
                                (§ ass (:_atLineStart this) true)
                                (§ ass (:_columnNumber this) 1)
                                (§ break )
                            )
                        )
                    )
                )
                ___line
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method atLineStart) [#_"LineNumberingPushbackReader" this]
        (:_atLineStart this)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(§ defprotocol Resolver
    #_abstract
    (#_"Symbol" Resolver'''(§ method currentNS) [#_"Resolver" this])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveClass) [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveAlias) [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''(§ method resolveVar) [#_"Resolver" this, #_"Symbol" ___sym])
)

(class-ns LispReaderException (§ extends RuntimeException)
    (defn- #_"LispReaderException" LispReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"LispReaderException" LispReaderException'new [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new ___cause) (LispReaderException'init))]
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )
)

#_closure
(class-ns RegexReader (§ extends AFn)
    (defn #_"RegexReader" RegexReader'new []
        (AFn'new)
    )

    (§ def #_"LispStringReader" RegexReader'stringrdr (LispStringReader'new))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RegexReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [#_"int" ___ch (ß LispReader'read1(___r))] (ß ___ch != \") [(ß LispReader'read1(___r))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading regex"))
                    )
                    (ß ___sb.append((char) ___ch))
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß LispReader'read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (Util'runtimeException-1 "EOF while reading regex"))
                        )
                        (ß ___sb.append((char) ___ch))
                    )
                )
                (ß Pattern/compile((.toString ___sb)))
            )
        )
    )
)

#_closure
(class-ns LispStringReader (§ extends AFn)
    (defn #_"LispStringReader" LispStringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [#_"int" ___ch (ß LispReader'read1(___r))] (ß ___ch != \") [(ß LispReader'read1(___r))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading string"))
                    )
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß LispReader'read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (Util'runtimeException-1 "EOF while reading string"))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch \tab)
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch \return)
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch \newline)
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch \backspace)
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch \formfeed)
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (ß LispReader'read1(___r)))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (Util'runtimeException-1 (str "Invalid unicode escape: \\u" (ß (char) ___ch))))
                                )
                                (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (Character/isDigit ___ch)
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 8, 3, false)))
                                        (when (> ___ch 0377)
                                            (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (Util'runtimeException-1 (str "Unsupported escape character: \\" (ß (char) ___ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (.toString ___sb)
            )
        )
    )
)

#_closure
(class-ns LispCommentReader (§ extends AFn)
    (defn #_"LispCommentReader" LispCommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Reader" ___r (ß (Reader) ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (ß LispReader'read1(___r)))
                    (§ recur-if (___ch != -1 && ___ch != \newline && ___ch != \return))
                )
                ___r
            )
        )
    )
)

#_closure
(class-ns LispDiscardReader (§ extends AFn)
    (defn #_"LispDiscardReader" LispDiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))
            ___r
        )
    )
)

;; :a.b{:c 1} => {:a.b/c 1}
;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
#_closure
(class-ns LispNamespaceMapReader (§ extends AFn)
    (defn #_"LispNamespaceMapReader" LispNamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"boolean" ___auto false]
                (let [#_"int" ___autoChar (ß LispReader'read1(___r))]
                    (if (ß ___autoChar == \:)
                        (do
                            (§ ass ___auto true)
                        )
                        (do
                            (LispReader'unread ___r, ___autoChar)
                        )
                    )

                    (let [#_"Object" ___sym nil]
                        (let [#_"int" ___nextChar (ß LispReader'read1(___r))]
                            (cond (ß isWhitespace(___nextChar)) ;; the #:: { } case or an error
                                (do
                                    (if ___auto
                                        (do
                                            (while (ß isWhitespace(___nextChar))
                                                (§ ass ___nextChar (ß LispReader'read1(___r)))
                                            )
                                            (when (ß ___nextChar != \{)
                                                (LispReader'unread ___r, ___nextChar)
                                                (throw (Util'runtimeException-1 "Namespaced map must specify a namespace"))
                                            )
                                        )
                                        (do
                                            (LispReader'unread ___r, ___nextChar)
                                            (throw (Util'runtimeException-1 "Namespaced map must specify a namespace"))
                                        )
                                    )
                                )
                                (ß ___nextChar != \{) ;; #:foo { } or #::foo { }
                                (do
                                    (LispReader'unread ___r, ___nextChar)
                                    (§ ass ___sym (LispReader'read-6 ___r, true, nil, false, ___opts, ___pendingForms))
                                    (§ ass ___nextChar (ß LispReader'read1(___r)))
                                    (while (ß isWhitespace(___nextChar))
                                        (§ ass ___nextChar (ß LispReader'read1(___r)))
                                    )
                                )
                            )
                            (when (ß ___nextChar != \{)
                                (throw (Util'runtimeException-1 "Namespaced map must specify a map"))
                            )

                            ;; Resolve autoresolved ns
                            (§ let [#_"String" ___ns]
                                (cond ___auto
                                    (do
                                        (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                                            (cond (nil? ___sym)
                                                (do
                                                    (if (some? ___resolver)
                                                        (do
                                                            (§ ass ___ns (:name (.currentNS ___resolver)))
                                                        )
                                                        (do
                                                            (§ ass ___ns (ß Compiler'currentNS().getName().getName()))
                                                        )
                                                    )
                                                )
                                                (ß (not (ß ___sym instanceof Symbol)) || (cast' Symbol ___sym).getNamespace() != nil)
                                                (do
                                                    (throw (Util'runtimeException-1 (str "Namespaced map must specify a valid namespace: " ___sym)))
                                                )
                                                :else
                                                (do
                                                    (§ let [#_"Symbol" ___resolvedNS]
                                                        (if (some? ___resolver)
                                                            (do
                                                                (§ ass ___resolvedNS (ß ___resolver.resolveAlias((cast' Symbol ___sym))))
                                                            )
                                                            (do
                                                                (let [#_"Namespace" ___rns (ß Compiler'currentNS().lookupAlias((cast' Symbol ___sym)))]
                                                                    (§ ass ___resolvedNS (when (some? ___rns) (.getName ___rns)))
                                                                )
                                                            )
                                                        )

                                                        (if (nil? ___resolvedNS)
                                                            (do
                                                                (throw (Util'runtimeException-1 (str "Unknown auto-resolved namespace alias: " ___sym)))
                                                            )
                                                            (do
                                                                (§ ass ___ns (.getName ___resolvedNS))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß (not (ß ___sym instanceof Symbol)) || (cast' Symbol ___sym).getNamespace() != nil)
                                    (do
                                        (throw (Util'runtimeException-1 (str "Namespaced map must specify a valid namespace: " ___sym)))
                                    )
                                    :else
                                    (do
                                        (§ ass ___ns (ß (cast' Symbol ___sym).getName()))
                                    )
                                )

                                ;; Read map
                                (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms)))]
                                    (when (ß ((.size ___kvs) & 1) == 1)
                                        (throw (Util'runtimeException-1 "Namespaced map literal must contain an even number of forms"))
                                    )

                                    ;; Construct output map
                                    (let [#_"Object[]" ___a (make-array Object (.size ___kvs))]
                                        (let [#_"Iterator" ___iter (.iterator ___kvs)]
                                            (loop-when-recur [#_"int" ___i 0] (.hasNext ___iter) [(+ ___i 2)]
                                                (let [#_"Object" ___key (next ___iter)]
                                                    (let [#_"Object" ___val (next ___iter)]
                                                        (cond (ß ___key instanceof Keyword)
                                                            (do
                                                                (let [#_"Keyword" ___kw (ß (Keyword) ___key)]
                                                                    (cond (ß (.getNamespace ___kw) == nil)
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern-2(___ns, (.getName ___kw))))
                                                                        )
                                                                        (ß (.getNamespace ___kw).equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern-2(nil, (.getName ___kw))))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (ß ___key instanceof Symbol)
                                                            (do
                                                                (let [#_"Symbol" ___s (ß (Symbol) ___key)]
                                                                    (cond (ß (.getNamespace ___s) == nil)
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern-2(___ns, (.getName ___s))))
                                                                        )
                                                                        (ß (.getNamespace ___s).equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern-2(nil, (.getName ___s))))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (§ ass (ß ___a[___i]) ___key)
                                                        (§ ass (ß ___a[___i + 1]) ___val)
                                                    )
                                                )
                                            )
                                            (RT'map ___a)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispSymbolicValueReader (§ extends AFn)
    (defn #_"LispSymbolicValueReader" LispSymbolicValueReader'new []
        (AFn'new)
    )

    (def #_"IPersistentMap" LispSymbolicValueReader'specials (ß PersistentHashMap'create-1a(
        (object-array [
            (Symbol'intern-1 "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern-1 "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern-1 "NaN")  Double/NaN
        ])
    )))

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                (when (not (ß ___o instanceof Symbol))
                    (throw (Util'runtimeException-1 (str "Invalid token: ##" ___o)))
                )
                (when (not (ß LispSymbolicValueReader'specials.containsKey(___o)))
                    (throw (Util'runtimeException-1 (str "Unknown symbolic value: ##" ___o)))
                )

                (ß LispSymbolicValueReader'specials.valAt(___o))
            )
        )
    )
)

(class-ns WrappingReader (§ extends AFn)
    (defn- #_"WrappingReader" WrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
        )
    )

    (defn #_"WrappingReader" WrappingReader'new [#_"Symbol" ___sym]
        (let [this (merge (AFn'new) (WrappingReader'init))]
            (§ ass (:sym this) ___sym)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"WrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                (RT'list-2 (:sym this), ___o)
            )
        )
    )
)

(class-ns DeprecatedWrappingReader (§ extends AFn)
    (defn- #_"DeprecatedWrappingReader" DeprecatedWrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"String" :macro nil
        )
    )

    (defn #_"DeprecatedWrappingReader" DeprecatedWrappingReader'new [#_"Symbol" ___sym, #_"String" ___macro]
        (let [this (merge (AFn'new) (DeprecatedWrappingReader'init))]
            (§ ass (:sym this) ___sym)
            (§ ass (:macro this) ___macro)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"DeprecatedWrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (System/out.println (str "WARNING: reader macro " (:macro this) " is deprecated; use " (ß (:sym this).getName()) " instead"))
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                (RT'list-2 (:sym this), ___o)
            )
        )
    )
)

#_closure
(class-ns VarReader (§ extends AFn)
    (defn #_"VarReader" VarReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"VarReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                (RT'list-2 LispReader'THE_VAR, ___o)
            )
        )
    )
)

#_closure
(class-ns LispDispatchReader (§ extends AFn)
    (defn #_"LispDispatchReader" LispDispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___ch (ß LispReader'read1((Reader)___reader))]
            (when (ß ___ch == -1)
                (throw (Util'runtimeException-1 "EOF while reading character"))
            )
            (let [#_"IFn" ___fn (ß dispatchMacros[___ch])]
                ;; Try the ctor reader first
                (when (nil? ___fn)
                    (LispReader'unread (cast PushbackReader ___reader), ___ch)
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                    (let [#_"Object" ___result (.invoke ctorReader, ___reader, ___ch, ___opts, ___pendingForms)]
                        (if (some? ___result)
                            (do
                                (§ return ___result)
                            )
                            (do
                                (throw (Util'runtimeException-1 (String/format "No dispatch macro for: %c", (object-array [ (ß (char) ___ch) ]))))
                            )
                        )
                    )
                )
                (.invoke ___fn, ___reader, ___ch, ___opts, ___pendingForms)
            )
        )
    )
)

#_closure
(class-ns FnReader (§ extends AFn)
    (defn #_"FnReader" FnReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"FnReader" this, #_"Object" ___reader, #_"Object" ___lparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (when (ß LispReader'ARG_ENV.deref() != nil)
                (throw (IllegalStateException. "Nested #()s are not allowed"))
            )
            (try
                (ß Var'pushThreadBindings(RT'map(LispReader'ARG_ENV, PersistentTreeMap'EMPTY)))
                (LispReader'unread ___r, \()
                (let [#_"Object" ___form (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                    (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                        (let [#_"PersistentTreeMap" ___argsyms (ß (PersistentTreeMap) LispReader'ARG_ENV.deref())]
                            (let [#_"ISeq" ___rargs (.rseq ___argsyms)]
                                (when (some? ___rargs)
                                    (let [#_"int" ___higharg (ß (Integer) ((Map$Entry) (first ___rargs)).getKey())]
                                        (when (> ___higharg 0)
                                            (loop-when-recur [#_"int" ___i 1] (ß ___i <= ___higharg) [(inc ___i)]
                                                (let [#_"Object" ___sym (.valAt ___argsyms, ___i)]
                                                    (when (nil? ___sym)
                                                        (§ ass ___sym (ß garg(___i)))
                                                    )
                                                    (§ ass ___args (.cons ___args, ___sym))
                                                )
                                            )
                                        )
                                        (let [#_"Object" ___restsym (.valAt ___argsyms, -1)]
                                            (when (some? ___restsym)
                                                (§ ass ___args (ß ___args.cons(Compiler'_AMP_)))
                                                (§ ass ___args (.cons ___args, ___restsym))
                                            )
                                        )
                                    )
                                )
                                (RT'list-3 Compiler'FN, ___args, ___form)
                            )
                        )
                    )
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )
)

#_closure
(class-ns ArgReader (§ extends AFn)
    (defn #_"ArgReader" ArgReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ArgReader" this, #_"Object" ___reader, #_"Object" ___pct, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (when (ß LispReader'ARG_ENV.deref() == nil)
                (§ return (ß interpretToken(readToken(___r, \%), nil)))
            )
            (let [#_"int" ___ch (ß LispReader'read1(___r))]
                (LispReader'unread ___r, ___ch)
                ;; % alone is first arg
                (when (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                    (§ return (ß registerArg(1)))
                )
                (let [#_"Object" ___n (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                    (when (ß ___n.equals(Compiler'_AMP_))
                        (§ return (ß registerArg(-1)))
                    )
                    (when (not (ß ___n instanceof Number))
                        (throw (IllegalStateException. "arg literal must be %, %& or %integer"))
                    )
                    (ß registerArg((cast Number ___n).intValue()))
                )
            )
        )
    )
)

#_closure
(class-ns LispMetaReader (§ extends AFn)
    (defn #_"LispMetaReader" LispMetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß (cast' LineNumberingPushbackReader ___r).getLineNumber()))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                    (let [#_"Object" ___meta (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                        (cond (ß ___meta instanceof Symbol || ___meta instanceof String)
                            (do
                                (§ ass ___meta (RT'map RT'TAG_KEY, ___meta))
                            )
                            (ß ___meta instanceof Keyword)
                            (do
                                (§ ass ___meta (RT'map ___meta, RT'T))
                            )
                            (not (ß ___meta instanceof IPersistentMap))
                            (do
                                (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                            )
                        )

                        (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                            (if (ß ___o instanceof IMeta)
                                (do
                                    (when (ß ___line != -1 && ___o instanceof ISeq)
                                        (§ ass ___meta (ß (cast' IPersistentMap ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (ß ___o instanceof IReference)
                                        (ß (cast' IReference ___o).resetMeta((cast' IPersistentMap ___meta)))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (RT'meta ___o)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'seq ___meta)] (some? ___s) [(next ___s)]
                                            (let [#_"IMapEntry" ___kv (ß (IMapEntry) (first ___s))]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, (.getKey ___kv), (.getValue ___kv))))
                                            )
                                        )
                                        (ß (cast' IObj ___o).withMeta((cast' IPersistentMap ___ometa)))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SyntaxQuoteReader (§ extends AFn)
    (defn #_"SyntaxQuoteReader" SyntaxQuoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"SyntaxQuoteReader" this, #_"Object" ___reader, #_"Object" ___backquote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (try
                (ß Var'pushThreadBindings(RT'map(LispReader'GENSYM_ENV, PersistentHashMap'EMPTY)))

                (let [#_"Object" ___form (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                    (ß syntaxQuote(___form))
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" ___form]
        (§ let [#_"Object" ___ret]
            (cond (Compiler'isSpecial ___form)
                (do
                    (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___form))
                )
                (ß ___form instanceof Symbol)
                (do
                    (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                        (let [#_"Symbol" ___sym (ß (Symbol) ___form)]
                            (cond (ß (:ns ___sym) == nil && (:name ___sym).endsWith("#"))
                                (do
                                    (let [#_"IPersistentMap" ___gmap (ß (IPersistentMap) LispReader'GENSYM_ENV.deref())]
                                        (when (nil? ___gmap)
                                            (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                        )
                                        (let [#_"Symbol" ___gs (ß (Symbol) ___gmap.valAt(___sym))]
                                            (when (nil? ___gs)
                                                (§ ass ___gs (Symbol'intern-2 nil, (str (ß (:name ___sym).substring(0, (:name ___sym).length() - 1)) "__" (RT'nextID) "__auto__")))
                                                (ß LispReader'GENSYM_ENV.set(___gmap.assoc(___sym, ___gs)))
                                            )
                                            (§ ass ___sym ___gs)
                                        )
                                    )
                                )
                                (ß (:ns ___sym) == nil && (:name ___sym).endsWith("."))
                                (do
                                    (let [#_"Symbol" ___csym (ß Symbol'intern-2(nil, (:name ___sym).substring(0, (:name ___sym).length() - 1)))]
                                        (if (some? ___resolver)
                                            (do
                                                (let [#_"Symbol" ___rc (.resolveClass ___resolver, ___csym)]
                                                    (when (some? ___rc)
                                                        (§ ass ___csym ___rc)
                                                    )
                                                )
                                            )
                                            (do
                                                (§ ass ___csym (Compiler'resolveSymbol ___csym))
                                            )
                                        )
                                        (§ ass ___sym (ß Symbol'intern-2(nil, (:name ___csym).concat("."))))
                                    )
                                )
                                (ß (:ns ___sym) == nil && (:name ___sym).startsWith("."))
                                (do
                                    ;; Simply quote method names.
                                )
                                (some? ___resolver)
                                (do
                                    (let [#_"Symbol" ___nsym nil]
                                        (when (ß (:ns ___sym) != nil)
                                            (let [#_"Symbol" ___alias (ß Symbol'intern-2(nil, (:ns ___sym)))]
                                                (§ ass ___nsym (.resolveClass ___resolver, ___alias))
                                                (when (nil? ___nsym)
                                                    (§ ass ___nsym (.resolveAlias ___resolver, ___alias))
                                                )
                                            )
                                        )
                                        (cond (some? ___nsym)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern-2((:name ___nsym), (:name ___sym))))
                                            )
                                            (ß (:ns ___sym) == nil)
                                            (do
                                                (let [#_"Symbol" ___rsym (.resolveClass ___resolver, ___sym)]
                                                    (when (nil? ___rsym)
                                                        (§ ass ___rsym (.resolveVar ___resolver, ___sym))
                                                    )
                                                    (if (some? ___rsym)
                                                        (do
                                                            (§ ass ___sym ___rsym)
                                                        )
                                                        (do
                                                            (§ ass ___sym (ß Symbol'intern-2((:name (.currentNS ___resolver)), (:name ___sym))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        ;; leave alone if qualified
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Object" ___maybeClass nil]
                                        (when (ß (:ns ___sym) != nil)
                                            (§ ass ___maybeClass (ß Compiler'currentNS().getMapping(Symbol'intern-2(nil, (:ns ___sym)))))
                                        )
                                        (if (ß ___maybeClass instanceof Class)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern-2((cast Class ___maybeClass).getName(), (:name ___sym))))
                                            )
                                            (do
                                                (§ ass ___sym (Compiler'resolveSymbol ___sym))
                                            )
                                        )
                                    )
                                )
                            )
                            (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___sym))
                        )
                    )
                )
                (ß isUnquote(___form))
                (do
                    (§ return (RT'second ___form))
                )
                (ß isUnquoteSplicing(___form))
                (do
                    (throw (IllegalStateException. "splice not in list"))
                )
                (ß ___form instanceof IPersistentCollection)
                (do
                    (cond (ß ___form instanceof IRecord)
                        (do
                            (§ ass ___ret ___form)
                        )
                        (ß ___form instanceof IPersistentMap)
                        (do
                            (let [#_"IPersistentVector" ___keyvals (SyntaxQuoteReader'flattenMap ___form)]
                                (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'HASHMAP, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList((.seq ___keyvals)))))))
                            )
                        )
                        (ß ___form instanceof IPersistentVector)
                        (do
                            (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'VECTOR, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList((cast' IPersistentVector ___form).seq()))))))
                        )
                        (ß ___form instanceof IPersistentSet)
                        (do
                            (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'HASHSET, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList((cast' IPersistentSet ___form).seq()))))))
                        )
                        (ß ___form instanceof ISeq || ___form instanceof IPersistentList)
                        (do
                            (let [#_"ISeq" ___seq (RT'seq ___form)]
                                (if (nil? ___seq)
                                    (do
                                        (§ ass ___ret (RT'cons LispReader'LIST, nil))
                                    )
                                    (do
                                        (§ ass ___ret (ß RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList(___seq)))))
                                    )
                                )
                            )
                        )
                        :else
                        (do
                            (throw (UnsupportedOperationException. "Unknown Collection type"))
                        )
                    )
                )
                (ß ___form instanceof Keyword || ___form instanceof Number || ___form instanceof Character || ___form instanceof String)
                (do
                    (§ ass ___ret ___form)
                )
                :else
                (do
                    (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___form))
                )
            )

            (when (ß ___form instanceof IObj && RT'meta(___form) != nil)
                ;; filter line and column numbers
                (let [#_"IPersistentMap" ___newMeta (ß (cast' IObj ___form).meta().without(RT'LINE_KEY).without(RT'COLUMN_KEY))]
                    (when (ß (count ___newMeta) > 0)
                        (§ return (ß RT'list-3(LispReader'WITH_META, ___ret, syntaxQuote((cast' IObj ___form).meta()))))
                    )
                )
            )
            ___ret
        )
    )

    (defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" ___seq]
        (let [#_"PersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [___seq ___seq] (some? ___seq) [(next ___seq)]
                (let [#_"Object" ___item (first ___seq)]
                    (cond (ß isUnquote(___item))
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list-2(LispReader'LIST, RT'second(___item)))))
                        )
                        (ß isUnquoteSplicing(___item))
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'second(___item))))
                        )
                        :else
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list-2(LispReader'LIST, syntaxQuote(___item)))))
                        )
                    )
                )
            )
            (.seq ___ret)
        )
    )

    (defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" ___form]
        (let [#_"IPersistentVector" ___keyvals PersistentVector'EMPTY]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(next ___s)]
                (let [#_"IMapEntry" ___e (ß (IMapEntry) (first ___s))]
                    (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons((.key ___e))))
                    (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons((.val ___e))))
                )
            )
            ___keyvals
        )
    )
)

#_closure
(class-ns UnquoteReader (§ extends AFn)
    (defn #_"UnquoteReader" UnquoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"UnquoteReader" this, #_"Object" ___reader, #_"Object" ___comma, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß LispReader'read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                (if (ß ___ch == \@)
                    (do
                        (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE_SPLICING, ___o)
                        )
                    )
                    (do
                        (LispReader'unread ___r, ___ch)
                        (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE, ___o)
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispCharacterReader (§ extends AFn)
    (defn #_"LispCharacterReader" LispCharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß LispReader'read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                    (cond (ß (.length ___token) == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (.equals ___token, "newline")
                        (do
                            (§ return \newline)
                        )
                        (.equals ___token, "space")
                        (do
                            (§ return \space)
                        )
                        (.equals ___token, "tab")
                        (do
                            (§ return \tab)
                        )
                        (.equals ___token, "backspace")
                        (do
                            (§ return \backspace)
                        )
                        (.equals ___token, "formfeed")
                        (do
                            (§ return \formfeed)
                        )
                        (.equals ___token, "return")
                        (do
                            (§ return \return)
                        )
                        (.startsWith ___token, "u")
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (ß ___c >= (§ char "\ud800") && ___c <= (§ char "\udfff")) ;; surrogate code unit?
                                    (throw (Util'runtimeException-1 (str "Invalid character constant: \\u" (Integer/toString ___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (.startsWith ___token, "o")
                        (do
                            (let [#_"int" ___len (ß (.length ___token) - 1)]
                                (when (> ___len 3)
                                    (throw (Util'runtimeException-1 (str "Invalid octal escape sequence length: " ___len)))
                                )
                                (let [#_"int" ___uc (ß readUnicodeChar(___token, 1, ___len, 8))]
                                    (when (> ___uc 0377)
                                        (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (Util'runtimeException-1 (str "Unsupported character: \\" ___token)))
                )
            )
        )
    )
)

#_closure
(class-ns LispListReader (§ extends AFn)
    (defn #_"LispListReader" LispListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß (cast' LineNumberingPushbackReader ___r).getLineNumber()))
                        (§ ass ___column (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts, ensurePending(___pendingForms)))]
                        (when (.isEmpty ___list)
                            (§ return PersistentList'EMPTY)
                        )
                        (let [#_"IObj" ___s (ß (IObj) PersistentList'create(___list))]
                            (if (ß ___line != -1)
                                (do
                                    (ß ___s.withMeta(RT'map(
                                        (object-array [
                                            RT'LINE_KEY   ___line
                                            RT'COLUMN_KEY ___column
                                        ])
                                    )))
                                )
                                (do
                                    ___s
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EvalReader (§ extends AFn)
    (defn #_"EvalReader" EvalReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"EvalReader" this, #_"Object" ___reader, #_"Object" ___eq, #_"Object" ___opts, #_"Object" ___pendingForms]
        (when (not (ß RT'booleanCast-1o(RT'READEVAL.deref())))
            (throw (Util'runtimeException-1 "EvalReader not allowed when *read-eval* is false."))
        )

        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (LispReader'read-6 ___r, true, nil, true, ___opts, (ß ensurePending(___pendingForms)))]
                (cond (ß ___o instanceof Symbol)
                    (do
                        (ß RT'classForName-1((.toString ___o)))
                    )
                    (ß ___o instanceof IPersistentList)
                    (do
                        (let [#_"Symbol" ___fs (ß (Symbol) RT'first(___o))]
                            (when (ß ___fs.equals(LispReader'THE_VAR))
                                (let [#_"Symbol" ___vs (ß (Symbol) RT'second(___o))]
                                    (§ return (ß RT'var-2((:ns ___vs), (:name ___vs))))
                                )
                            )
                            (when (ß (:name ___fs).endsWith("."))
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeConstructor(RT'classForName-1((:name ___fs).substring(0, (:name ___fs).length() - 1)), ___args)))
                                )
                            )
                            (when (Compiler'namesStaticMember ___fs)
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeStaticMethod-3s((:ns ___fs), (:name ___fs), ___args)))
                                )
                            )
                            (let [#_"Object" ___v (ß Compiler'maybeResolveIn(Compiler'currentNS(), ___fs))]
                                (when (ß ___v instanceof Var)
                                    (§ return (ß (cast' IFn ___v).applyTo(RT'next(___o))))
                                )
                                (throw (Util'runtimeException-1 (str "Can't resolve " ___fs)))
                            )
                        )
                    )
                    :else
                    (do
                        (throw (IllegalArgumentException. "Unsupported #= form"))
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispVectorReader (§ extends AFn)
    (defn #_"LispVectorReader" LispVectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts, ensurePending(___pendingForms))))
        )
    )
)

#_closure
(class-ns LispMapReader (§ extends AFn)
    (defn #_"LispMapReader" LispMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms)).toArray())]
                (when (ß (___a.length & 1) == 1)
                    (throw (Util'runtimeException-1 "Map literal must contain an even number of forms"))
                )
                (RT'map ___a)
            )
        )
    )
)

#_closure
(class-ns LispSetReader (§ extends AFn)
    (defn #_"LispSetReader" LispSetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß PersistentHashSet'createWithCheck-1l(readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms))))
        )
    )
)

#_closure
(class-ns LispUnmatchedDelimiterReader (§ extends AFn)
    (defn #_"LispUnmatchedDelimiterReader" LispUnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (Util'runtimeException-1 (str "Unmatched delimiter: " ___rightdelim)))
    )
)

#_closure
(class-ns LispUnreadableReader (§ extends AFn)
    (defn #_"LispUnreadableReader" LispUnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"LispUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (Util'runtimeException-1 "Unreadable form"))
    )
)

#_closure
(class-ns CtorReader (§ extends AFn)
    (defn #_"CtorReader" CtorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"CtorReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
            (let [#_"Object" ___name (LispReader'read-6 ___r, true, nil, false, ___opts, ___pendingForms)]
                (when (not (ß ___name instanceof Symbol))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (ß (Symbol)___name)]
                    (let [#_"Object" ___form (LispReader'read-6 ___r, true, nil, true, ___opts, ___pendingForms)]
                        (if (ß isPreserveReadCond(___opts) || RT'suppressRead())
                            (do
                                (TaggedLiteral'create ___sym, ___form)
                            )
                            (do
                                (if (ß (.getName ___sym).contains(".")) (.readRecord this, ___form, ___sym, ___opts, ___pendingForms) (.readTagged this, ___form, ___sym, ___opts, ___pendingForms))
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method readTagged) [#_"CtorReader" this, #_"Object" ___o, #_"Symbol" ___tag, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"ILookup" ___data_readers (ß (ILookup)RT'DATA_READERS.deref())]
            (let [#_"IFn" ___data_reader (ß (IFn)RT'get-2(___data_readers, ___tag))]
                (when (nil? ___data_reader)
                    (§ ass ___data_readers (ß (ILookup)RT'DEFAULT_DATA_READERS.deref()))
                    (§ ass ___data_reader (ß (IFn)RT'get-2(___data_readers, ___tag)))
                    (when (nil? ___data_reader)
                        (let [#_"IFn" ___default_reader (ß (IFn)RT'DEFAULT_DATA_READER_FN.deref())]
                            (if (some? ___default_reader)
                                (do
                                    (§ return (.invoke ___default_reader, ___tag, ___o))
                                )
                                (do
                                    (throw (RuntimeException. (str "No reader function for tag " (.toString ___tag))))
                                )
                            )
                        )
                    )
                )

                (.invoke ___data_reader, ___o)
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method readRecord) [#_"CtorReader" this, #_"Object" ___form, #_"Symbol" ___recordName, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"boolean" ___readeval (ß RT'booleanCast-1o(RT'READEVAL.deref()))]
            (when (not ___readeval)
                (throw (Util'runtimeException-1 "Record construction syntax can only be used when *read-eval* == true"))
            )

            (let [#_"Class" ___recordClass (ß RT'classForNameNonLoading((.toString ___recordName)))]
                (let [#_"boolean" ___shortForm true]
                    (cond (ß ___form instanceof IPersistentMap)
                        (do
                            (§ ass ___shortForm false)
                        )
                        (ß ___form instanceof IPersistentVector)
                        (do
                            (§ ass ___shortForm true)
                        )
                        :else
                        (do
                            (throw (Util'runtimeException-1 (str "Unreadable constructor form starting with \"#" ___recordName "\"")))
                        )
                    )

                    (let [#_"Object" ___ret nil]
                        (let [#_"Constructor[]" ___allctors (ß (cast Class ___recordClass).getConstructors())]
                            (if ___shortForm
                                (do
                                    (let [#_"IPersistentVector" ___recordEntries (ß (IPersistentVector)___form)]
                                        (let [#_"boolean" ___ctorFound false]
                                            (doseq [#_"Constructor" ___ctor ___allctors]
                                                (when (ß (.getParameterTypes ___ctor).length == (count ___recordEntries))
                                                    (§ ass ___ctorFound true)
                                                )
                                            )

                                            (when (not ___ctorFound)
                                                (throw (Util'runtimeException-1 (str "Unexpected number of constructor arguments to " (.toString ___recordClass) ": got " (count ___recordEntries))))
                                            )

                                            (§ ass ___ret (ß Reflector'invokeConstructor(___recordClass, RT'toArray(___recordEntries))))
                                        )
                                    )
                                )
                                (do
                                    (let [#_"IPersistentMap" ___vals (ß (IPersistentMap)___form)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'keys ___vals)] (some? ___s) [(next ___s)]
                                            (when (not (ß (first ___s) instanceof Keyword))
                                                (throw (Util'runtimeException-1 (str "Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " (.toString (first ___s)))))
                                            )
                                        )
                                        (§ ass ___ret (ß Reflector'invokeStaticMethod-3c(___recordClass, "create", (object-array [ ___vals ]))))
                                    )
                                )
                            )

                            ___ret
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ConditionalReader (§ extends AFn)
    (defn #_"ConditionalReader" ConditionalReader'new []
        (AFn'new)
    )

    (def- #_"Object" ConditionalReader'READ_STARTED (Object.))
    (§ def #_"Keyword" ConditionalReader'DEFAULT_FEATURE (Keyword'intern-2 nil, "default"))
    (def #_"IPersistentSet" ConditionalReader'RESERVED_FEATURES (ß RT'set(Keyword'intern-2(nil, "else"), Keyword'intern-2(nil, "none"))))

    (defn #_"boolean" ConditionalReader'hasFeature [#_"Object" ___feature, #_"Object" ___opts]
        (when (not (ß ___feature instanceof Keyword))
            (throw (Util'runtimeException-1 (str "Feature should be a keyword: " ___feature)))
        )

        (when (ß ConditionalReader'DEFAULT_FEATURE.equals(___feature))
            (§ return true)
        )

        (let [#_"IPersistentSet" ___custom (ß (IPersistentSet) (cast' IPersistentMap ___opts).valAt(LispReader'OPT_FEATURES))]
            (ß (___custom != nil && ___custom.contains(___feature)))
        )
    )

    (defn #_"Object" ConditionalReader'readCondDelimited [#_"PushbackReader" ___r, #_"boolean" ___splicing, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Object" ___result ConditionalReader'READ_STARTED]
            (§ let [#_"Object" ___form] ;; The most recently ready form
                (let [#_"boolean" ___toplevel (ß ___pendingForms == nil)]
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))

                    (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? (cast' LineNumberingPushbackReader ___r).getLineNumber() :or -1)]
                        (while true
                            (when (ß ___result == ConditionalReader'READ_STARTED)
                                ;; Read the next feature
                                (§ ass ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, nil))

                                (cond (ß ___form == LispReader'READ_EOF)
                                    (do
                                        (if (< ___firstline 0)
                                            (do
                                                (throw (Util'runtimeException-1 "EOF while reading"))
                                            )
                                            (do
                                                (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                            )
                                        )
                                    )
                                    (ß ___form == LispReader'READ_FINISHED)
                                    (do
                                        (§ break ) ;; read-cond form is done
                                    )
                                )

                                (when (ß ConditionalReader'RESERVED_FEATURES.contains(___form))
                                    (throw (Util'runtimeException-1 (str "Feature name " ___form " is reserved.")))
                                )

                                (when (ß hasFeature(___form, ___opts))
                                    ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                    (§ ass ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, (ß (Resolver) RT'READER_RESOLVER.deref())))

                                    (cond (ß ___form == LispReader'READ_EOF)
                                        (do
                                            (if (< ___firstline 0)
                                                (do
                                                    (throw (Util'runtimeException-1 "EOF while reading"))
                                                )
                                                (do
                                                    (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                                )
                                            )
                                        )
                                        (ß ___form == LispReader'READ_FINISHED)
                                        (do
                                            (if (< ___firstline 0)
                                                (do
                                                    (throw (Util'runtimeException-1 "read-cond requires an even number of forms."))
                                                )
                                                (do
                                                    (throw (Util'runtimeException-1 (str "read-cond starting on line " ___firstline " requires an even number of forms")))
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            (§ ass ___result ___form)
                                        )
                                    )
                                )
                            )

                            ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                            (try
                                (ß Var'pushThreadBindings(RT'map(RT'SUPPRESS_READ, RT'T)))
                                (§ ass ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, (ß (Resolver) RT'READER_RESOLVER.deref())))

                                (cond (ß ___form == LispReader'READ_EOF)
                                    (do
                                        (if (< ___firstline 0)
                                            (do
                                                (throw (Util'runtimeException-1 "EOF while reading"))
                                            )
                                            (do
                                                (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                            )
                                        )
                                    )
                                    (ß ___form == LispReader'READ_FINISHED)
                                    (do
                                        (§ break )
                                    )
                                )
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                        )

                        (when (ß ___result == ConditionalReader'READ_STARTED) ;; no features matched
                            (§ return ___r)
                        )

                        (if ___splicing
                            (do
                                (when (not (ß ___result instanceof List))
                                    (throw (Util'runtimeException-1 "Spliced form list in read-cond-splicing must implement java.util.List"))
                                )

                                (when ___toplevel
                                    (throw (Util'runtimeException-1 "Reader conditional splicing not allowed at the top level."))
                                )

                                (ß (cast List ___pendingForms).addAll(0, (List)___result))

                                ___r
                            )
                            (do
                                ___result
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" ConditionalReader'checkConditionalAllowed [#_"Object" ___opts]
        (let [#_"IPersistentMap" ___mopts (ß (IPersistentMap)___opts)]
            (when (not (ß ___opts != nil && (LispReader'COND_ALLOW.equals(___mopts.valAt(LispReader'OPT_READ_COND)) || LispReader'COND_PRESERVE.equals(___mopts.valAt(LispReader'OPT_READ_COND)))))
                (throw (Util'runtimeException-1 "Conditional read not allowed"))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ConditionalReader" this, #_"Object" ___reader, #_"Object" ___mode, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ConditionalReader'checkConditionalAllowed ___opts)

        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß LispReader'read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )

                (let [#_"boolean" ___splicing false]
                    (when (ß ___ch == \@)
                        (§ ass ___splicing true)
                        (§ ass ___ch (ß LispReader'read1(___r)))
                    )

                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß LispReader'read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading character"))
                    )

                    (when (ß ___ch != \()
                        (throw (Util'runtimeException-1 "read-cond body must be a list"))
                    )

                    (try
                        (ß Var'pushThreadBindings(RT'map(LispReader'READ_COND_ENV, RT'T)))

                        (if (ß isPreserveReadCond(___opts))
                            (do
                                (let [#_"IFn" ___listReader (ß getMacro(___ch))] ;; should always be a list
                                    (let [#_"Object" ___form (ß ___listReader.invoke(___r, ___ch, ___opts, ensurePending(___pendingForms)))]
                                        (ReaderConditional'create ___form, ___splicing)
                                    )
                                )
                            )
                            (do
                                (ß readCondDelimited(___r, ___splicing, ___opts, ___pendingForms))
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" LispReader'QUOTE (Symbol'intern-1 "quote"))
    (§ def #_"Symbol" LispReader'THE_VAR (Symbol'intern-1 "var"))

    (§ def #_"Symbol" LispReader'UNQUOTE (Symbol'intern-2 "cloiure.core", "unquote"))
    (§ def #_"Symbol" LispReader'UNQUOTE_SPLICING (Symbol'intern-2 "cloiure.core", "unquote-splicing"))
    (§ def #_"Symbol" LispReader'CONCAT (Symbol'intern-2 "cloiure.core", "concat"))
    (§ def #_"Symbol" LispReader'SEQ (Symbol'intern-2 "cloiure.core", "seq"))
    (§ def #_"Symbol" LispReader'LIST (Symbol'intern-2 "cloiure.core", "list"))
    (§ def #_"Symbol" LispReader'APPLY (Symbol'intern-2 "cloiure.core", "apply"))
    (§ def #_"Symbol" LispReader'HASHMAP (Symbol'intern-2 "cloiure.core", "hash-map"))
    (§ def #_"Symbol" LispReader'HASHSET (Symbol'intern-2 "cloiure.core", "hash-set"))
    (§ def #_"Symbol" LispReader'VECTOR (Symbol'intern-2 "cloiure.core", "vector"))
    (§ def #_"Symbol" LispReader'WITH_META (Symbol'intern-2 "cloiure.core", "with-meta"))
    (§ def #_"Symbol" LispReader'META (Symbol'intern-2 "cloiure.core", "meta"))
    (§ def #_"Symbol" LispReader'DEREF (Symbol'intern-2 "cloiure.core", "deref"))
    (§ def #_"Symbol" LispReader'READ_COND (Symbol'intern-2 "cloiure.core", "read-cond"))
    (§ def #_"Symbol" LispReader'READ_COND_SPLICING (Symbol'intern-2 "cloiure.core", "read-cond-splicing"))
    (§ def #_"Keyword" LispReader'UNKNOWN (Keyword'intern-2 nil, "unknown"))

    (def #_"IFn[]" LispReader'macros (§ typeless make-array IFn 256))
    (def #_"IFn[]" LispReader'dispatchMacros (§ typeless make-array IFn 256))

    (def #_"Pattern" LispReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" LispReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" LispReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" LispReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def #_"Var" LispReader'GENSYM_ENV (ß Var'create-1(nil).setDynamic()))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" LispReader'ARG_ENV (ß Var'create-1(nil).setDynamic()))
    (§ def #_"IFn" LispReader'ctorReader (CtorReader'new))

    ;; Dynamic var set to true in a read-cond context
    (§ def #_"Var" LispReader'READ_COND_ENV (ß Var'create-1(nil).setDynamic()))

    (§ static
        (§ ass (ß macros[\"]) (LispStringReader'new)) ;; oops! "
        (§ ass (ß macros[\;]) (LispCommentReader'new))
        (§ ass (ß macros[\']) (WrappingReader'new LispReader'QUOTE))
        (§ ass (ß macros[\@]) (WrappingReader'new LispReader'DEREF))
        (§ ass (ß macros[\^]) (LispMetaReader'new))
        (§ ass (ß macros[\`]) (SyntaxQuoteReader'new))
        (§ ass (ß macros[\~]) (UnquoteReader'new))
        (§ ass (ß macros[\(]) (LispListReader'new))
        (§ ass (ß macros[\)]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\[]) (LispVectorReader'new))
        (§ ass (ß macros[\]]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\{]) (LispMapReader'new))
        (§ ass (ß macros[\}]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\\]) (LispCharacterReader'new))
        (§ ass (ß macros[\%]) (ArgReader'new))
        (§ ass (ß macros[\#]) (LispDispatchReader'new))

        (§ ass (ß dispatchMacros[\^]) (LispMetaReader'new))
        (§ ass (ß dispatchMacros[\#]) (LispSymbolicValueReader'new))
        (§ ass (ß dispatchMacros[\']) (VarReader'new))
        (§ ass (ß dispatchMacros[\"]) (RegexReader'new)) ;; oops! "
        (§ ass (ß dispatchMacros[\(]) (FnReader'new))
        (§ ass (ß dispatchMacros[\{]) (LispSetReader'new))
        (§ ass (ß dispatchMacros[\=]) (EvalReader'new))
        (§ ass (ß dispatchMacros[\!]) (LispCommentReader'new))
        (§ ass (ß dispatchMacros[\<]) (LispUnreadableReader'new))
        (§ ass (ß dispatchMacros[\_]) (LispDiscardReader'new))
        (§ ass (ß dispatchMacros[\?]) (ConditionalReader'new))
        (§ ass (ß dispatchMacros[\:]) (LispNamespaceMapReader'new))
    )

    (defn #_"boolean" LispReader'isWhitespace [#_"int" ___ch]
        (ß (Character/isWhitespace(___ch) || ___ch == \,))
    )

    (defn #_"void" LispReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (ß ___ch != -1)
            (try
                (.unread ___r, ___ch)
                (catch IOException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
        )
        nil
    )

    (defn #_"int" LispReader'read1 [#_"Reader" ___r]
        (try
            (.read ___r)
            (catch IOException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" LispReader'OPT_EOF (Keyword'intern-2 nil, "eof"))
    (§ def #_"Keyword" LispReader'OPT_FEATURES (Keyword'intern-2 nil, "features"))
    (§ def #_"Keyword" LispReader'OPT_READ_COND (Keyword'intern-2 nil, "read-cond"))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" LispReader'EOFTHROW (Keyword'intern-2 nil, "eofthrow"))

    ;; Platform features - always installed
    (§ def- #_"Keyword" LispReader'PLATFORM_KEY (Keyword'intern-2 nil, "cli"))
    (§ def- #_"Object" LispReader'PLATFORM_FEATURES (PersistentHashSet'create-1a LispReader'PLATFORM_KEY))

    ;; Reader conditional options - use with :read-cond
    (§ def #_"Keyword" LispReader'COND_ALLOW (Keyword'intern-2 nil, "allow"))
    (§ def #_"Keyword" LispReader'COND_PRESERVE (Keyword'intern-2 nil, "preserve"))

    (defn #_"Object" LispReader'read-2 [#_"PushbackReader" ___r, #_"Object" ___opts]
        (let [#_"boolean" ___eofIsError true]
            (let [#_"Object" ___eofValue nil]
                (when (ß ___opts != nil && ___opts instanceof IPersistentMap)
                    (let [#_"Object" ___eof (ß (cast' IPersistentMap ___opts).valAt(LispReader'OPT_EOF, LispReader'EOFTHROW))]
                        (when (not (ß LispReader'EOFTHROW.equals(___eof)))
                            (§ ass ___eofIsError false)
                            (§ ass ___eofValue ___eof)
                        )
                    )
                )
                (LispReader'read-5 ___r, ___eofIsError, ___eofValue, false, ___opts)
            )
        )
    )

    (defn #_"Object" LispReader'read-4 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive]
        (LispReader'read-5 ___r, ___eofIsError, ___eofValue, ___isRecursive, PersistentHashMap'EMPTY)
    )

    (defn #_"Object" LispReader'read-5 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (LispReader'read-9 ___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, nil, (ß (Resolver) RT'READER_RESOLVER.deref()))
    )

    (defn- #_"Object" LispReader'read-6 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (LispReader'read-9 ___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, (ß ensurePending(___pendingForms)), (ß (Resolver) RT'READER_RESOLVER.deref()))
    )

    (defn- #_"Object" LispReader'ensurePending [#_"Object" ___pendingForms]
        (if (nil? ___pendingForms)
            (do
                (LinkedList.)
            )
            (do
                ___pendingForms
            )
        )
    )

    (defn- #_"Object" LispReader'installPlatformFeature [#_"Object" ___opts]
        (if (nil? ___opts)
            (do
                (RT'mapUniqueKeys LispReader'OPT_FEATURES, LispReader'PLATFORM_FEATURES)
            )
            (do
                (let [#_"IPersistentMap" ___mopts (ß (IPersistentMap) ___opts)]
                    (let [#_"Object" ___features (ß ___mopts.valAt(LispReader'OPT_FEATURES))]
                        (if (nil? ___features)
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, LispReader'PLATFORM_FEATURES))
                            )
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, RT'conj((IPersistentSet) ___features, LispReader'PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'read-9 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"Character" ___returnOn, #_"Object" ___returnOnValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms, #_"Resolver" ___resolver]
        (when (ß RT'READEVAL.deref() == LispReader'UNKNOWN)
            (throw (Util'runtimeException-1 "Reading disallowed - *read-eval* bound to :unknown"))
        )

        (§ ass ___opts (ß installPlatformFeature(___opts)))

        (try
            (while true
                (when (ß ___pendingForms instanceof List && (not (ß (cast List ___pendingForms).isEmpty())))
                    (§ return (ß (cast List ___pendingForms).remove(0)))
                )

                (let [#_"int" ___ch (ß LispReader'read1(___r))]
                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß LispReader'read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (when ___eofIsError
                            (throw (Util'runtimeException-1 "EOF while reading"))
                        )
                        (§ return ___eofValue)
                    )

                    (when (ß ___returnOn != nil && ((.charValue ___returnOn) == ___ch))
                        (§ return ___returnOnValue)
                    )

                    (when (Character/isDigit ___ch)
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts, ___pendingForms))]
                                ;; no op macros return the reader
                                (when (ß ___ret == ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (ß ___ch == \+ || ___ch == \-)
                            (let [#_"int" ___ch2 (ß LispReader'read1(___r))]
                                (when (Character/isDigit ___ch2)
                                    (LispReader'unread ___r, ___ch2)
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (§ return ___n)
                                    )
                                )
                                (LispReader'unread ___r, ___ch2)
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                            (§ return (ß interpretToken(___token, ___resolver)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (ß ___isRecursive || (not (ß ___r instanceof LineNumberingPushbackReader)))
                    (throw (Util'sneakyThrow ___e))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (ß (LineNumberingPushbackReader) ___r)]
                    (throw (ß LispReaderException'new((.getLineNumber ___rdr), (.getColumnNumber ___rdr), ___e)))
                )
            )
        )
    )

    (defn- #_"String" LispReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (ß LispReader'read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                        (LispReader'unread ___r, ___ch)
                        (§ return (.toString ___sb))
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (defn- #_"Object" LispReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (.append ___sb, ___initch)

            (while true
                (let [#_"int" ___ch (ß LispReader'read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || LispReader'isMacro(___ch))
                        (LispReader'unread ___r, ___ch)
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (.toString ___sb)]
                (let [#_"Object" ___n (ß matchNumber(___s))]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (str "Invalid number: " ___s)))
                    )
                    ___n
                )
            )
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-4 [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß (.length ___token) != ___offset + ___length)
            (throw (IllegalArgumentException. (str "Invalid unicode character: \\" ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [#_"int" ___i ___offset] (ß ___i < ___offset + ___length) [(inc ___i)]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (ß ___d == -1)
                        (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt ___token, ___i))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-5 [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (Character/digit ___initch, ___base)]
            (when (ß ___uc == -1)
                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___initch))))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [___i ___i] (< ___i ___length) [(inc ___i)]
                    (let [#_"int" ___ch (ß LispReader'read1(___r))]
                        (when (ß ___ch == -1 || isWhitespace(___ch) || LispReader'isMacro(___ch))
                            (LispReader'unread ___r, ___ch)
                            (§ break )
                        )
                        (let [#_"int" ___d (Character/digit ___ch, ___base)]
                            (when (ß ___d == -1)
                                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___ch))))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (ß ___i != ___length && ___exact)
                    (throw (IllegalArgumentException. (str "Invalid character length: " ___i ", should be: " ___length)))
                )
                ___uc
            )
        )
    )

    (defn- #_"Object" LispReader'interpretToken [#_"String" ___s, #_"Resolver" ___resolver]
        (cond (.equals ___s, "nil")
            (do
                (§ return nil)
            )
            (.equals ___s, "true")
            (do
                (§ return RT'T)
            )
            (.equals ___s, "false")
            (do
                (§ return RT'F)
            )
        )
        (let [#_"Object" ___ret nil]
            (§ ass ___ret (ß matchSymbol(___s, ___resolver)))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (Util'runtimeException-1 (str "Invalid token: " ___s)))
        )
    )

    (defn- #_"Object" LispReader'matchSymbol [#_"String" ___s, #_"Resolver" ___resolver]
        (let [#_"Matcher" ___m (.matcher LispReader'symbolPat, ___s)]
            (when (.matches ___m)
                (let [#_"int" ___gc (.groupCount ___m)]
                    (let [#_"String" ___ns (.group ___m, 1)]
                        (let [#_"String" ___name (.group ___m, 2)]
                            (when (ß ___ns != nil && ___ns.endsWith(":/") || ___name.endsWith(":") || ___s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (.startsWith ___s, "::")
                                (let [#_"Symbol" ___ks (ß Symbol'intern-1(___s.substring(2)))]
                                    (if (some? ___resolver)
                                        (do
                                            (§ let [#_"Symbol" ___nsym]
                                                (if (ß (:ns ___ks) != nil)
                                                    (do
                                                        (§ ass ___nsym (ß ___resolver.resolveAlias(Symbol'intern-1((:ns ___ks)))))
                                                    )
                                                    (do
                                                        (§ ass ___nsym (.currentNS ___resolver))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___nsym)
                                                    (do
                                                        (§ return (ß Keyword'intern-2((:name ___nsym), (:name ___ks))))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" ___kns]
                                                (if (ß (:ns ___ks) != nil)
                                                    (do
                                                        (§ ass ___kns (ß Compiler'currentNS().lookupAlias(Symbol'intern-1((:ns ___ks)))))
                                                    )
                                                    (do
                                                        (§ ass ___kns (Compiler'currentNS))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___kns)
                                                    (do
                                                        (§ return (ß Keyword'intern-2((:name (:name ___kns)), (:name ___ks))))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" ___isKeyword (ß (___s.charAt(0) == \:))]
                                (let [#_"Symbol" ___sym (Symbol'intern-1 (.substring ___s, (if ___isKeyword 1 0)))]
                                    (when ___isKeyword
                                        (§ return (Keyword'intern ___sym))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"Object" LispReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (.matcher LispReader'intPat, ___s)]
            (when (.matches ___m)
                (when (ß ___m.group(2) != nil)
                    (when (ß ___m.group(8) != nil)
                        (§ return BigInt'ZERO)
                    )
                    (§ return (Numbers'num-1l 0))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (.group ___m, 3)))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (.group ___m, 4)))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (.group ___m, 5)))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (.group ___m, 7)))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (BigInteger. ___n, ___radix)]
                                (when ___negate
                                    (§ ass ___bn (.negate ___bn))
                                )
                                (when (ß ___m.group(8) != nil)
                                    (§ return (BigInt'fromBigInteger ___bn))
                                )
                                (§ return (if (< (.bitLength ___bn) 64) (Numbers'num-1l (.longValue ___bn)) (BigInt'fromBigInteger ___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (.matcher LispReader'floatPat, ___s))
            (when (.matches ___m)
                (when (ß ___m.group(4) != nil)
                    (§ return (§ unsure BigDecimal. (.group ___m, 1)))
                )
                (§ return (Double/parseDouble ___s))
            )
            (§ ass ___m (.matcher LispReader'ratioPat, ___s))
            (when (.matches ___m)
                (let [#_"String" ___numerator (.group ___m, 1)]
                    (when (.startsWith ___numerator, "+")
                        (§ ass ___numerator (.substring ___numerator, 1))
                    )
                    (§ return (ß Numbers'divide-2oo(Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. ___numerator))), Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. (.group ___m, 2)))))))
                )
            )
            nil
        )
    )

    (defn- #_"IFn" LispReader'getMacro [#_"int" ___ch]
        (when (ß ___ch < macros.length)
            (§ return (ß macros[___ch]))
        )
        nil
    )

    (defn- #_"boolean" LispReader'isMacro [#_"int" ___ch]
        (ß ___ch < macros.length && macros[___ch] != nil)
    )

    (defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ___ch]
        (ß (___ch != \# && ___ch != \' && ___ch != \% && LispReader'isMacro(___ch)))
    )

    (defn #_"Symbol" LispReader'garg [#_"int" ___n]
        (Symbol'intern-2 nil, (str (if (ß ___n == -1) "rest" (str "p" ___n)) "__" (RT'nextID) "#"))
    )

    (defn #_"Symbol" LispReader'registerArg [#_"int" ___n]
        (let [#_"PersistentTreeMap" ___argsyms (ß (PersistentTreeMap) LispReader'ARG_ENV.deref())]
            (when (nil? ___argsyms)
                (throw (IllegalStateException. "arg literal not in #()"))
            )
            (let [#_"Symbol" ___ret (ß (Symbol) ___argsyms.valAt(___n))]
                (when (nil? ___ret)
                    (§ ass ___ret (ß garg(___n)))
                    (ß LispReader'ARG_ENV.set(___argsyms.assoc(___n, ___ret)))
                )
                ___ret
            )
        )
    )

    (defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" ___form]
        (ß ___form instanceof ISeq && Util'equals(RT'first(___form), LispReader'UNQUOTE_SPLICING))
    )

    (defn #_"boolean" LispReader'isUnquote [#_"Object" ___form]
        (ß ___form instanceof ISeq && Util'equals(RT'first(___form), LispReader'UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (def- #_"Object" LispReader'READ_EOF (Object.))
    (def- #_"Object" LispReader'READ_FINISHED (Object.))

    (defn #_"List" LispReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? (cast' LineNumberingPushbackReader ___r).getLineNumber() :or -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                    (while true
                        (let [#_"Object" ___form (LispReader'read-9 ___r, false, LispReader'READ_EOF, ___delim, LispReader'READ_FINISHED, ___isRecursive, ___opts, ___pendingForms, ___resolver)]
                            (cond (ß ___form == LispReader'READ_EOF)
                                (do
                                    (if (< ___firstline 0)
                                        (do
                                            (throw (Util'runtimeException-1 "EOF while reading"))
                                        )
                                        (do
                                            (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                        )
                                    )
                                )
                                (ß ___form == LispReader'READ_FINISHED)
                                (do
                                    (§ return ___a)
                                )
                            )

                            (.add ___a, ___form)
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" LispReader'isPreserveReadCond [#_"Object" ___opts]
        (if (ß RT'booleanCast-1o(LispReader'READ_COND_ENV.deref()) && ___opts instanceof IPersistentMap)
            (do
                (let [#_"Object" ___readCond (ß (cast' IPersistentMap ___opts).valAt(LispReader'OPT_READ_COND))]
                    (ß LispReader'COND_PRESERVE.equals(___readCond))
                )
            )
            (do
                false
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(class-ns RetryEx (§ extends Error)
    (defn #_"RetryEx" RetryEx'new []
        (§ foreign Error'new)
    )
)

(class-ns AbortException (§ extends Exception)
    (defn #_"AbortException" AbortException'new []
        (§ foreign Exception'new)
    )
)

(class-ns LockingTransactionInfo
    (defn- #_"LockingTransactionInfo" LockingTransactionInfo'init []
        (hash-map
            #_"AtomicInteger" :status nil
            #_"long" :startPoint 0
            #_"CountDownLatch" :latch nil
        )
    )

    (defn #_"LockingTransactionInfo" LockingTransactionInfo'new [#_"int" ___status, #_"long" ___startPoint]
        (let [this (LockingTransactionInfo'init)]
            (§ ass (:status this) (AtomicInteger. ___status))
            (§ ass (:startPoint this) ___startPoint)
            (§ ass (:latch this) (CountDownLatch. 1))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method running) [#_"LockingTransactionInfo" this]
        (let [#_"int" ___s (.get (:status this))]
            (ß ___s == LockingTransaction'RUNNING || ___s == LockingTransaction'COMMITTING)
        )
    )
)

(class-ns CFn
    (defn- #_"CFn" CFn'init []
        (hash-map
            #_"IFn" :fn nil
            #_"ISeq" :args nil
        )
    )

    (defn #_"CFn" CFn'new [#_"IFn" ___fn, #_"ISeq" ___args]
        (let [this (CFn'init)]
            (§ ass (:fn this) ___fn)
            (§ ass (:args this) ___args)
            this
        )
    )
)

(class-ns Notify
    (defn- #_"Notify" Notify'init []
        (hash-map
            #_"Ref" :ref nil
            #_"Object" :oldval nil
            #_"Object" :newval nil
        )
    )

    (defn #_"Notify" Notify'new [#_"Ref" ___ref, #_"Object" ___oldval, #_"Object" ___newval]
        (let [this (Notify'init)]
            (§ ass (:ref this) ___ref)
            (§ ass (:oldval this) ___oldval)
            (§ ass (:newval this) ___newval)
            this
        )
    )
)

(class-ns LockingTransaction
    (def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (def #_"long" LockingTransaction'BARGE_WAIT_NANOS (* 10 1000000))

    (def #_"int" LockingTransaction'RUNNING 0)
    (def #_"int" LockingTransaction'COMMITTING 1)
    (def #_"int" LockingTransaction'RETRY 2)
    (def #_"int" LockingTransaction'KILLED 3)
    (def #_"int" LockingTransaction'COMMITTED 4)

    (def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ThreadLocal.))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (defn- #_"LockingTransaction" LockingTransaction'init []
        (hash-map
            #_"LockingTransactionInfo" :info nil
            #_"long" :readPoint 0
            #_"long" :startPoint 0
            #_"long" :startTime 0

            #_"RetryEx" :retryex (RetryEx'new)
            #_"ArrayList<AgentAction>" :actions (ArrayList.)
            #_"HashMap<Ref, Object>" :vals (HashMap.)
            #_"HashSet<Ref>" :sets (HashSet.)
            #_"TreeMap<Ref, ArrayList<CFn>>" :commutes (TreeMap.)

            #_"HashSet<Ref>" :ensures (HashSet.) ;; all hold readLock
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'new []
        (LockingTransaction'init)
    )

    #_method
    (§ defn #_"void" (§ method getReadPoint) [#_"LockingTransaction" this]
        (§ ass (:readPoint this) (.incrementAndGet lastPoint))
        nil
    )

    #_method
    (§ defn #_"long" (§ method getCommitPoint) [#_"LockingTransaction" this]
        (.incrementAndGet lastPoint)
    )

    #_method
    (§ defn #_"void" (§ method stop) [#_"LockingTransaction" this, #_"int" ___status]
        (when (some? (:info this))
            (§ sync (:info this)
                (ß (:status (:info this)).set(___status))
                (ß (:latch (:info this)).countDown())
            )
            (§ ass (:info this) nil)
            (.clear (:vals this))
            (.clear (:sets this))
            (.clear (:commutes this))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method tryWriteLock) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (try
            (when (not (ß (:lock ___ref).writeLock().tryLock(LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS)))
                (throw (:retryex this))
            )
            (catch InterruptedException ___e
                (throw (:retryex this))
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" (§ method lock) [#_"LockingTransaction" this, #_"Ref" ___ref]
        ;; can't upgrade readLock, so release it
        (.releaseIfEnsured this, ___ref)

        (let [#_"boolean" ___unlocked true]
            (try
                (.tryWriteLock this, ___ref)
                (§ ass ___unlocked false)

                (when (ß (:tvals ___ref) != nil && (:point (:tvals ___ref)) > (:readPoint this))
                    (throw (:retryex this))
                )
                (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
                    ;; write lock conflict
                    (when (ß ___refinfo != nil && ___refinfo != (:info this) && (.running ___refinfo))
                        (when (not (ß this.barge(___refinfo)))
                            (ß (:lock ___ref).writeLock().unlock())
                            (§ ass ___unlocked true)
                            (§ return (.blockAndBail this, ___refinfo))
                        )
                    )
                    (§ ass (:tinfo ___ref) (:info this))
                    (when (some? (:tvals ___ref)) (:val (:tvals ___ref)))
                )
                (finally
                    (when (not ___unlocked)
                        (ß (:lock ___ref).writeLock().unlock())
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" (§ method blockAndBail) [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        ;; stop prior to blocking
        (ß this.stop(LockingTransaction'RETRY))
        (try
            (ß (:latch ___refinfo).await(LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
            (catch InterruptedException ___e
                ;; ignore
            )
        )
        (throw (:retryex this))
    )

    #_method
    (§ defn- #_"void" (§ method releaseIfEnsured) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß (:ensures this).contains(___ref))
            (ß (:ensures this).remove(___ref))
            (ß (:lock ___ref).readLock().unlock())
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method abort) [#_"LockingTransaction" this] #_(§ throws AbortException)
        (ß this.stop(LockingTransaction'KILLED))
        (throw (AbortException'new))
    )

    #_method
    (§ defn- #_"boolean" (§ method bargeTimeElapsed) [#_"LockingTransaction" this]
        (ß (System/nanoTime() - (:startTime this) > LockingTransaction'BARGE_WAIT_NANOS))
    )

    #_method
    (§ defn- #_"boolean" (§ method barge) [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        (let [#_"boolean" ___barged false]
            ;; if this transaction is older, try to abort the other
            (when (ß (.bargeTimeElapsed this) && (:startPoint this) < (:startPoint ___refinfo))
                (§ ass ___barged (ß (:status ___refinfo).compareAndSet(LockingTransaction'RUNNING, LockingTransaction'KILLED)))
                (when ___barged
                    (.countDown (:latch ___refinfo))
                )
            )
            ___barged
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" ___t (.get LockingTransaction'transaction)]
            (when (ß ___t == nil || (:info ___t) == nil)
                (throw (IllegalStateException. "No transaction running"))
            )
            ___t
        )
    )

    (defn #_"boolean" LockingTransaction'isRunning []
        (ß (getRunning() != nil))
    )

    (defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" ___t (.get LockingTransaction'transaction)]
            (when (ß ___t == nil || (:info ___t) == nil)
                (§ return nil)
            )
            ___t
        )
    )

    (defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"LockingTransaction" ___t (.get LockingTransaction'transaction)]
            (§ let [#_"Object" ___ret]
                (if (nil? ___t)
                    (do
                        (ß LockingTransaction'transaction.set(§ ass ___t (LockingTransaction'new)))
                        (try
                            (§ ass ___ret (.run ___t, ___fn))
                            (finally
                                (.remove LockingTransaction'transaction)
                            )
                        )
                    )
                    (do
                        (if (ß (:info ___t) != nil)
                            (do
                                (§ ass ___ret (.call ___fn))
                            )
                            (do
                                (§ ass ___ret (.run ___t, ___fn))
                            )
                        )
                    )
                )

                ___ret
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method run) [#_"LockingTransaction" this, #_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"boolean" ___done false]
            (let [#_"Object" ___ret nil]
                (let [#_"ArrayList<Ref>" ___locked (ArrayList.)]
                    (let [#_"ArrayList<Notify>" ___notify (ArrayList.)]
                        (loop-when-recur [#_"int" ___i 0] (ß (not ___done) && ___i < LockingTransaction'RETRY_LIMIT) [(inc ___i)]
                            (try
                                (.getReadPoint this)
                                (when (ß ___i == 0)
                                    (§ ass (:startPoint this) (:readPoint this))
                                    (§ ass (:startTime this) (ß System/nanoTime()))
                                )
                                (§ ass (:info this) (LockingTransactionInfo'new LockingTransaction'RUNNING, (:startPoint this)))
                                (§ ass ___ret (.call ___fn))
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß (:status (:info this)).compareAndSet(LockingTransaction'RUNNING, LockingTransaction'COMMITTING))
                                    (doseq [#_"Map$Entry<Ref, ArrayList<CFn>>" ___e (.entrySet (:commutes this))]
                                        (let [#_"Ref" ___ref (.getKey ___e)]
                                            (when (ß (:sets this).contains(___ref))
                                                (§ continue )
                                            )

                                            (let [#_"boolean" ___wasEnsured (ß (:ensures this).contains(___ref))]
                                                ;; can't upgrade readLock, so release it
                                                (.releaseIfEnsured this, ___ref)
                                                (.tryWriteLock this, ___ref)
                                                (.add ___locked, ___ref)
                                                (when (ß ___wasEnsured && (:tvals ___ref) != nil && (:point (:tvals ___ref)) > (:readPoint this))
                                                    (throw (:retryex this))
                                                )

                                                (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
                                                    (when (ß ___refinfo != nil && ___refinfo != (:info this) && (.running ___refinfo))
                                                        (when (not (ß this.barge(___refinfo)))
                                                            (throw (:retryex this))
                                                        )
                                                    )
                                                    (let [#_"Object" ___val (when (some? (:tvals ___ref)) (:val (:tvals ___ref)))]
                                                        (ß (:vals this).put(___ref, ___val))
                                                        (doseq [#_"CFn" ___f (.getValue ___e)]
                                                            (ß (:vals this).put(___ref, (:fn ___f).applyTo(RT'cons((:vals this).get(___ref), (:args ___f)))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ___ref (:sets this)]
                                        (.tryWriteLock this, ___ref)
                                        (.add ___locked, ___ref)
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map$Entry<Ref, Object>" ___e (.entrySet (:vals this))]
                                        (let [#_"Ref" ___ref (.getKey ___e)]
                                            (ß ___ref.validate((.getValidator ___ref), (.getValue ___e)))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" ___commitPoint (.getCommitPoint this)]
                                        (doseq [#_"Map$Entry<Ref, Object>" ___e (.entrySet (:vals this))]
                                            (let [#_"Ref" ___ref (.getKey ___e)]
                                                (let [#_"Object" ___oldval (when (some? (:tvals ___ref)) (:val (:tvals ___ref)))]
                                                    (let [#_"Object" ___newval (.getValue ___e)]
                                                        (let [#_"int" ___hcount (.histCount ___ref)]
                                                            (cond (ß (:tvals ___ref) == nil)
                                                                (do
                                                                    (§ ass (:tvals ___ref) (RefTVal'new-2 ___newval, ___commitPoint))
                                                                )
                                                                (ß ((:faults ___ref).get() > 0 && ___hcount < (:maxHistory ___ref)) || ___hcount < (:minHistory ___ref))
                                                                (do
                                                                    (§ ass (:tvals ___ref) (ß RefTVal'new-3(___newval, ___commitPoint, (:tvals ___ref))))
                                                                    (ß (:faults ___ref).set(0))
                                                                )
                                                                :else
                                                                (do
                                                                    (§ ass (:tvals ___ref) (:next (:tvals ___ref)))
                                                                    (§ ass (:val (:tvals ___ref)) ___newval)
                                                                    (§ ass (:point (:tvals ___ref)) ___commitPoint)
                                                                )
                                                            )
                                                            (when (ß (.getWatches ___ref).count() > 0)
                                                                (ß ___notify.add(Notify'new(___ref, ___oldval, ___newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (§ ass ___done true)
                                        (ß (:status (:info this)).set(LockingTransaction'COMMITTED))
                                    )
                                )
                                (§ catch RetryEx ___retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [#_"int" ___k (ß (.size ___locked) - 1)] (ß ___k >= 0) [(dec ___k)]
                                        (ß (:lock (.get ___locked, ___k)).writeLock().unlock())
                                    )
                                    (.clear ___locked)
                                    (doseq [#_"Ref" ___r (:ensures this)]
                                        (ß (:lock ___r).readLock().unlock())
                                    )
                                    (.clear (:ensures this))
                                    (.stop this, (if ___done LockingTransaction'COMMITTED LockingTransaction'RETRY))
                                    (try
                                        (when ___done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" ___n ___notify]
                                                (ß (:ref ___n).notifyWatches((:oldval ___n), (:newval ___n)))
                                            )
                                            (doseq [#_"AgentAction" ___action (:actions this)]
                                                (Agent'dispatchAction ___action)
                                            )
                                        )
                                        (finally
                                            (.clear ___notify)
                                            (.clear (:actions this))
                                        )
                                    )
                                )
                            )
                        )
                        (when (not ___done)
                            (throw (Util'runtimeException-1 "Transaction failed after reaching retry limit"))
                        )
                        ___ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method enqueue) [#_"LockingTransaction" this, #_"AgentAction" ___action]
        (ß (:actions this).add(___action))
        nil
    )

    #_method
    (§ defn #_"Object" (§ method doGet) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (not (ß (:info this).running()))
            (throw (:retryex this))
        )
        (when (ß (:vals this).containsKey(___ref))
            (§ return (ß (:vals this).get(___ref)))
        )
        (try
            (ß (:lock ___ref).readLock().lock())
            (when (ß (:tvals ___ref) == nil)
                (throw (IllegalStateException. (str (.toString ___ref) " is unbound.")))
            )
            (let [#_"RefTVal" ___ver (:tvals ___ref)]
                (§ loop
                    (when (ß (:point ___ver) <= (:readPoint this))
                        (§ return (:val ___ver))
                    )
                    (§ recur-if ((§ ass ___ver (:prior ___ver)) != (:tvals ___ref)))
                )
            )
            (finally
                (ß (:lock ___ref).readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (.incrementAndGet (:faults ___ref))
        (throw (:retryex this))
    )

    #_method
    (§ defn #_"Object" (§ method doSet) [#_"LockingTransaction" this, #_"Ref" ___ref, #_"Object" ___val]
        (when (not (ß (:info this).running()))
            (throw (:retryex this))
        )
        (when (ß (:commutes this).containsKey(___ref))
            (throw (IllegalStateException. "Can't set after commute"))
        )
        (when (not (ß (:sets this).contains(___ref)))
            (ß (:sets this).add(___ref))
            (.lock this, ___ref)
        )
        (ß (:vals this).put(___ref, ___val))
        ___val
    )

    #_method
    (§ defn #_"void" (§ method doEnsure) [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (not (ß (:info this).running()))
            (throw (:retryex this))
        )
        (when (ß (:ensures this).contains(___ref))
            (§ return nil)
        )
        (ß (:lock ___ref).readLock().lock())

        ;; someone completed a write after our snapshot
        (when (ß (:tvals ___ref) != nil && (:point (:tvals ___ref)) > (:readPoint this))
            (ß (:lock ___ref).readLock().unlock())
            (throw (:retryex this))
        )

        (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
            ;; writer exists
            (if (ß ___refinfo != nil && (.running ___refinfo))
                (do
                    (ß (:lock ___ref).readLock().unlock())

                    (when (ß ___refinfo != (:info this)) ;; not us, ensure is doomed
                        (.blockAndBail this, ___refinfo)
                    )
                )
                (do
                    (ß (:ensures this).add(___ref))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method doCommute) [#_"LockingTransaction" this, #_"Ref" ___ref, #_"IFn" ___fn, #_"ISeq" ___args]
        (when (not (ß (:info this).running()))
            (throw (:retryex this))
        )
        (when (not (ß (:vals this).containsKey(___ref)))
            (let [#_"Object" ___val nil]
                (try
                    (ß (:lock ___ref).readLock().lock())
                    (§ ass ___val (when (some? (:tvals ___ref)) (:val (:tvals ___ref))))
                    (finally
                        (ß (:lock ___ref).readLock().unlock())
                    )
                )
                (ß (:vals this).put(___ref, ___val))
            )
        )
        (let [#_"ArrayList<CFn>" ___fns (ß (:commutes this).get(___ref))]
            (when (nil? ___fns)
                (ß (:commutes this).put(___ref, (§ ass ___fns (ArrayList.))))
            )
            (ß ___fns.add(CFn'new(___fn, ___args)))
            (let [#_"Object" ___ret (ß ___fn.applyTo(RT'cons((:vals this).get(___ref), ___args)))]
                (ß (:vals this).put(___ref, ___ret))
                ___ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_private
(§ defprotocol LongRangeBoundsCheck
    #_abstract
    (#_"boolean" LongRangeBoundsCheck'''(§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" ___val])
)

#_non-static
(class-ns LongRangeIterator (§ implements Iterator)
    (defn- #_"LongRangeIterator" LongRangeIterator'init []
        (hash-map
            #_"long" :next 0
            #_"boolean" :hasNext false
        )
    )

    (defn #_"LongRangeIterator" LongRangeIterator'new []
        (let [this (LongRangeIterator'init)]
            (§ ass (:next this) (:start this))
            (§ ass (:hasNext this) true)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"LongRangeIterator" this]
        (:hasNext this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"LongRangeIterator" this]
        (if (:hasNext this)
            (do
                (let [#_"long" ___ret (:next this)]
                    (try
                        (§ ass (:next this) (Numbers'add-2ll (:next this), (:step this)))
                        (§ ass (:hasNext this) (not (ß (:boundsCheck this).exceededBounds((:next this)))))
                        (catch ArithmeticException ___e
                            (§ ass (:hasNext this) false)
                        )
                    )
                    ___ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"LongRangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

#_private
(class-ns LongChunk (§ implements IChunk)
    (defn- #_"LongChunk" LongChunk'init []
        (hash-map
            #_"long" :start 0
            #_"long" :step 0
            #_"int" :count 0
        )
    )

    (defn #_"LongChunk" LongChunk'new [#_"long" ___start, #_"long" ___step, #_"int" ___count]
        (let [this (LongChunk'init)]
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:count this) ___count)
            this
        )
    )

    #_method
    (§ defn #_"long" (§ method first) [#_"LongChunk" this]
        (:start this)
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"LongChunk" this, #_"int" ___i]
        (ß (:start this) + (___i * (:step this)))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"LongChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (:count this))
            (§ return (ß (:start this) + (___i * (:step this))))
        )
        ___notFound
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"LongChunk" this]
        (:count this)
    )

    #_method
    (§ defn #_"LongChunk" (§ method dropFirst) [#_"LongChunk" this]
        (when (ß (:count this) <= 1)
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß LongChunk'new((:start this) + (:step this), (:step this), (:count this) - 1))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongChunk" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"long" ___x (:start this)]
            (let [#_"Object" ___ret ___init]
                (loop-when-recur [#_"int" ___i 0] (< ___i (:count this)) [(inc ___i)]
                    (§ ass ___ret (.invoke ___f, ___ret, ___x))
                    (when (RT'isReduced ___ret)
                        (§ return ___ret)
                    )
                    (§ ass ___x (+ ___x (:step this)))
                )
                ___ret
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (def- #_"int" LongRange'CHUNK_SIZE 32)

    (defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (ß ___val >= ___end)
            )
        )
    )

    (defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (ß ___val <= ___end)
            )
        )
    )

    (defn- #_"LongRange" LongRange'init []
        (hash-map
            ;; Invariants guarantee this is never an empty or infinite seq
            #_"long" :start 0
            #_"long" :end 0
            #_"long" :step 0
            #_"LongRangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"LongChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"LongRange" LongRange'new-4 [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-6 [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-7 [#_"IPersistentMap" ___meta, #_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new ___meta) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn #_"ISeq" LongRange'create-1 [#_"long" ___end]
        (when (> ___end 0)
            (§ return (ß LongRange'new-4(0, ___end, 1, positiveStep(___end))))
        )
        PersistentList'EMPTY
    )

    (defn #_"ISeq" LongRange'create-2 [#_"long" ___start, #_"long" ___end]
        (when (ß ___start >= ___end)
            (§ return PersistentList'EMPTY)
        )
        (ß LongRange'new-4(___start, ___end, 1, positiveStep(___end)))
    )

    (defn #_"ISeq" LongRange'create-3 [#_"long" ___start, #_"long" ___end, #_"long" ___step]
        (cond (> ___step 0)
            (do
                (when (ß ___end <= ___start)
                    (§ return PersistentList'EMPTY)
                )
                (ß LongRange'new-4(___start, ___end, ___step, positiveStep(___end)))
            )
            (< ___step 0)
            (do
                (when (ß ___end >= ___start)
                    (§ return PersistentList'EMPTY)
                )
                (ß LongRange'new-4(___start, ___end, ___step, negativeStep(___end)))
            )
            :else
            (do
                (when (ß ___end == ___start)
                    (§ return PersistentList'EMPTY)
                )
                (Repeat'create-1 ___start)
            )
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"LongRange" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (LongRange'new-7 ___meta, (:start this), (:end this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"LongRange" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" (§ method forceChunk) [#_"LongRange" this]
        (when (some? (:_chunk this))
            (§ return nil)
        )

        (§ let [#_"long" ___count]
            (try
                (§ ass ___count (.rangeCount this, (:start this), (:end this), (:step this)))
                (catch ArithmeticException ___e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (§ ass ___count (.steppingCount this, (:start this), (:end this), (:step this)))
                )
            )

            (cond (ß ___count > LongRange'CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" ___nextStart (ß (:start this) + ((:step this) * LongRange'CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass (:_chunkNext this) (LongRange'new-4 ___nextStart, (:end this), (:step this), (:boundsCheck this)))
                        (§ ass (:_chunk this) (LongChunk'new (:start this), (:step this), LongRange'CHUNK_SIZE))
                    )
                )
                :else ;; last chunk
                (do
                    (§ ass (:_chunk this) (ß LongChunk'new((:start this), (:step this), (int) ___count))) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"LongRange" this]
        (when (some? (:_next this))
            (§ return (:_next this))
        )

        (.forceChunk this)
        (when (ß (:_chunk this).count() > 1)
            (let [#_"LongChunk" ___smallerChunk (.dropFirst (:_chunk this))]
                (§ ass (:_next this) (ß LongRange'new-6((first ___smallerChunk), (:end this), (:step this), (:boundsCheck this), ___smallerChunk, (:_chunkNext this))))
                (§ return (:_next this))
            )
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"LongRange" this]
        (.forceChunk this)
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"LongRange" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"LongRange" this]
        (.forceChunk this)
        (when (nil? (:_chunkNext this))
            (§ return PersistentList'EMPTY)
        )
        (:_chunkNext this)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" (§ method steppingCount) [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        (let [#_"long" ___count 1]
            (let [#_"long" ___s ___start]
                (while (ß ___count <= LongRange'CHUNK_SIZE)
                    (try
                        (§ ass ___s (Numbers'add-2ll ___s, ___step))
                        (if (ß (:boundsCheck this).exceededBounds(___s))
                            (do
                                (§ break )
                            )
                            (do
                                (§ ass ___count (inc ___count))
                            )
                        )
                        (catch ArithmeticException ___e
                            (§ break )
                        )
                    )
                )
                ___count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" (§ method rangeCount) [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (/ (Numbers'add-2ll (Numbers'add-2ll (Numbers'minus-2ll ___end, ___start), ___step), (if (pos? (:step this)) -1 1)) ___step)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"LongRange" this]
        (try
            (let [#_"long" ___c (.rangeCount this, (:start this), (:end this), (:step this))]
                (if (ß ___c > Integer/MAX_VALUE)
                    (do
                        (Numbers'throwIntOverflow)
                    )
                    (do
                        (ß (int) ___c)
                    )
                )
            )
            (catch ArithmeticException ___e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" ___iter (.iterator this)]
                    (let [#_"long" ___count 0]
                        (while (.hasNext ___iter)
                            (next ___iter)
                            (§ ass ___count (inc ___count))
                        )

                        (if (ß ___count > Integer/MAX_VALUE)
                            (do
                                (Numbers'throwIntOverflow)
                            )
                            (do
                                (ß (int)___count)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongRange" this, #_"IFn" ___f]
        (let [#_"Object" ___acc (:start this)]
            (let [#_"long" ___i (+ (:start this) (:step this))]
                (while (not (ß (:boundsCheck this).exceededBounds(___i)))
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (ß ___acc instanceof Reduced)
                        (§ return (ß (cast' Reduced ___acc).deref()))
                    )
                    (§ ass ___i (+ ___i (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"LongRange" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"long" ___i (:start this)]
                (§ loop
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (RT'isReduced ___acc)
                        (§ return (ß (cast' Reduced ___acc).deref()))
                    )
                    (§ ass ___i (+ ___i (:step this)))
                    (§ recur-if (!(:boundsCheck this).exceededBounds(___i)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"LongRange" this]
        (LongRangeIterator'new)
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (defn #_"MapEntry" MapEntry'create [#_"Object" ___key, #_"Object" ___val]
        (MapEntry'new ___key, ___val)
    )

    (defn- #_"MapEntry" MapEntry'init []
        (hash-map
            #_"Object" :_key nil
            #_"Object" :_val nil
        )
    )

    (defn #_"MapEntry" MapEntry'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (AMapEntry'new) (MapEntry'init))]
            (§ ass (:_key this) ___key)
            (§ ass (:_val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method key) [#_"MapEntry" this]
        (:_key this)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"MapEntry" this]
        (:_val this)
    )

    #_method
    (§ defn #_"Object" (§ method getKey) [#_"MapEntry" this]
        (.key this)
    )

    #_method
    (§ defn #_"Object" (§ method getValue) [#_"MapEntry" this]
        (.val this)
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ defprotocol MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns Entry
    (defn- #_"Entry" Entry'init []
        (hash-map
            #_"Class" :c nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"Entry" Entry'new [#_"Class" ___c, #_"IFn" ___fn]
        (let [this (Entry'init)]
            (§ ass (:c this) ___c)
            (§ ass (:fn this) ___fn)
            this
        )
    )
)

(class-ns MethodImplCache
    (defn- #_"MethodImplCache" MethodImplCache'init []
        (hash-map
            #_"IPersistentMap" :protocol nil
            #_"Keyword" :methodk nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"Object[]" :table nil ;; [class, entry. class, entry ...]
            #_"Map" :map nil

            #_"Entry" :mre nil
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-2 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk]
        (MethodImplCache'new-5 ___protocol, ___methodk, 0, 0, RT'EMPTY_ARRAY)
    )

    (defn #_"MethodImplCache" MethodImplCache'new-5 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"int" ___shift, #_"int" ___mask, #_"Object[]" ___table]
        (let [this (MethodImplCache'init)]
            (§ ass (:protocol this) ___protocol)
            (§ ass (:methodk this) ___methodk)
            (§ ass (:shift this) ___shift)
            (§ ass (:mask this) ___mask)
            (§ ass (:table this) ___table)
            (§ ass (:map this) nil)
            this
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-3 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"Map" ___map]
        (let [this (MethodImplCache'init)]
            (§ ass (:protocol this) ___protocol)
            (§ ass (:methodk this) ___methodk)
            (§ ass (:shift this) 0)
            (§ ass (:mask this) 0)
            (§ ass (:table this) nil)
            (§ ass (:map this) ___map)
            this
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fnFor) [#_"MethodImplCache" this, #_"Class" ___c]
        (let [#_"Entry" ___last (:mre this)]
            (when (ß ___last != nil && (:c ___last) == ___c)
                (§ return (:fn ___last))
            )
            (.findFnFor this, ___c)
        )
    )

    #_method
    (§ defn #_"IFn" (§ method findFnFor) [#_"MethodImplCache" this, #_"Class" ___c]
        (if (some? (:map this))
            (do
                (let [#_"Entry" ___e (ß (Entry) (:map this).get(___c))]
                    (§ ass (:mre this) ___e)
                    (when (some? ___e) (:fn ___e))
                )
            )
            (do
                (let [#_"int" ___idx (ß ((Util'hash(___c) >> (:shift this)) & (:mask this)) << 1)]
                    (when (ß ___idx < (:table this).length && (:table this)[___idx] == ___c)
                        (let [#_"Entry" ___e (ß ((Entry) (:table this)[___idx + 1]))]
                            (§ ass (:mre this) ___e)
                            (§ return (when (some? ___e) (:fn ___e)))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" MultiFn'assoc (RT'var-2 "cloiure.core", "assoc"))
    (§ def #_"Var" MultiFn'dissoc (RT'var-2 "cloiure.core", "dissoc"))
    (§ def #_"Var" MultiFn'isa (RT'var-2 "cloiure.core", "isa?"))
    (§ def #_"Var" MultiFn'parents (RT'var-2 "cloiure.core", "parents"))

    (defn- #_"MultiFn" MultiFn'init []
        (hash-map
            #_"IFn" :dispatchFn nil
            #_"Object" :defaultDispatchVal nil
            #_"IRef" :hierarchy nil
            #_"String" :name nil
            #_"ReentrantReadWriteLock" :rw nil

            #_volatile
            #_"IPersistentMap" :methodTable nil
            #_volatile
            #_"IPersistentMap" :preferTable nil
            #_volatile
            #_"IPersistentMap" :methodCache nil
            #_volatile
            #_"Object" :cachedHierarchy nil
        )
    )

    (defn #_"MultiFn" MultiFn'new [#_"String" ___name, #_"IFn" ___dispatchFn, #_"Object" ___defaultDispatchVal, #_"IRef" ___hierarchy]
        (let [this (merge (AFn'new) (MultiFn'init))]
            (§ ass (:rw this) (ReentrantReadWriteLock.))
            (§ ass (:name this) ___name)
            (§ ass (:dispatchFn this) ___dispatchFn)
            (§ ass (:defaultDispatchVal this) ___defaultDispatchVal)
            (§ ass (:methodTable this) PersistentHashMap'EMPTY)
            (§ ass (:methodCache this) (.getMethodTable this))
            (§ ass (:preferTable this) PersistentHashMap'EMPTY)
            (§ ass (:hierarchy this) ___hierarchy)
            (§ ass (:cachedHierarchy this) nil)
            this
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method reset) [#_"MultiFn" this]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (§ ass (:methodCache this) (§ ass (:preferTable this) PersistentHashMap'EMPTY)))
            (§ ass (:cachedHierarchy this) nil)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method addMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal, #_"IFn" ___method]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (ß (.getMethodTable this).assoc(___dispatchVal, ___method)))
            (.resetCache this)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method removeMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (ß (.getMethodTable this).without(___dispatchVal)))
            (.resetCache this)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" (§ method preferMethod) [#_"MultiFn" this, #_"Object" ___dispatchValX, #_"Object" ___dispatchValY]
        (ß (:rw this).writeLock().lock())
        (try
            (when (.prefers this, ___dispatchValY, ___dispatchValX)
                (throw (IllegalStateException. (String/format "Preference conflict in multimethod '%s': %s is already preferred to %s", (object-array [ (:name this), ___dispatchValY, ___dispatchValX ]))))
            )
            (§ ass (:preferTable this) (ß (.getPreferTable this).assoc(___dispatchValX, RT'conj((IPersistentCollection) RT'get-3((.getPreferTable this), ___dispatchValX, PersistentHashSet'EMPTY), ___dispatchValY))))
            (.resetCache this)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method prefers) [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (let [#_"IPersistentSet" ___xprefs (ß (IPersistentSet) (.getPreferTable this).valAt(___x))]
            (when (ß ___xprefs != nil && ___xprefs.contains(___y))
                (§ return true)
            )
            (loop-when-recur [#_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___y)))] (some? ___ps) [(next ___ps)]
                (when (ß this.prefers(___x, (first ___ps)))
                    (§ return true)
                )
            )
            (loop-when-recur [#_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___x)))] (some? ___ps) [(next ___ps)]
                (when (ß this.prefers((first ___ps), ___y))
                    (§ return true)
                )
            )
            false
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method isA) [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß RT'booleanCast-1o(isa.invoke((:hierarchy this).deref(), ___x, ___y)))
    )

    #_method
    (§ defn- #_"boolean" (§ method dominates) [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß this.prefers(___x, ___y) || this.isA(___x, ___y))
    )

    #_method
    (§ defn- #_"IPersistentMap" (§ method resetCache) [#_"MultiFn" this]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodCache this) (.getMethodTable this))
            (§ ass (:cachedHierarchy this) (deref (:hierarchy this)))
            (:methodCache this)
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method getMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (when (ß (:cachedHierarchy this) != (:hierarchy this).deref())
            (.resetCache this)
        )
        (let [#_"IFn" ___targetFn (ß (IFn) (:methodCache this).valAt(___dispatchVal))]
            (when (some? ___targetFn)
                (§ return ___targetFn)
            )
            (.findAndCacheBestMethod this, ___dispatchVal)
        )
    )

    #_method
    (§ defn- #_"IFn" (§ method getFn) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (let [#_"IFn" ___targetFn (.getMethod this, ___dispatchVal)]
            (when (nil? ___targetFn)
                (throw (IllegalArgumentException. (String/format "No method in multimethod '%s' for dispatch value: %s", (object-array [ (:name this), ___dispatchVal ]))))
            )
            ___targetFn
        )
    )

    #_method
    (§ defn- #_"IFn" (§ method findAndCacheBestMethod) [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß (:rw this).readLock().lock())
        (§ let [#_"Object" ___bestValue]
            (let [#_"IPersistentMap" ___mt (:methodTable this)]
                (let [#_"IPersistentMap" ___pt (:preferTable this)]
                    (let [#_"Object" ___ch (:cachedHierarchy this)]
                        (try
                            (let [#_"Map$Entry" ___bestEntry nil]
                                (doseq [#_"Object" ___o (.getMethodTable this)]
                                    (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                                        (when (ß this.isA(___dispatchVal, (.getKey ___e)))
                                            (when (ß ___bestEntry == nil || this.dominates((.getKey ___e), (.getKey ___bestEntry)))
                                                (§ ass ___bestEntry ___e)
                                            )
                                            (when (not (ß this.dominates((.getKey ___bestEntry), (.getKey ___e))))
                                                (throw (IllegalArgumentException. (String/format "Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", (object-array [ (:name this), ___dispatchVal, (.getKey ___e), (.getKey ___bestEntry) ]))))
                                            )
                                        )
                                    )
                                )
                                (if (nil? ___bestEntry)
                                    (do
                                        (§ ass ___bestValue (ß (:methodTable this).valAt((:defaultDispatchVal this))))
                                        (when (nil? ___bestValue)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (§ ass ___bestValue (.getValue ___bestEntry))
                                    )
                                )
                            )
                            (finally
                                (ß (:rw this).readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß (:rw this).writeLock().lock())
                        (try
                            (if (ß ___mt == (:methodTable this) && ___pt == (:preferTable this) && ___ch == (:cachedHierarchy this) && (:cachedHierarchy this) == (:hierarchy this).deref())
                                (do
                                    ;; place in cache
                                    (§ ass (:methodCache this) (ß (:methodCache this).assoc(___dispatchVal, ___bestValue)))
                                    (ß (IFn) ___bestValue)
                                )
                                (do
                                    (.resetCache this)
                                    (.findAndCacheBestMethod this, ___dispatchVal)
                                )
                            )
                            (finally
                                (ß (:rw this).writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this]
        (ß this.getFn((:dispatchFn this).invoke()).invoke())
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1]
        (ß this.getFn((:dispatchFn this).invoke(___arg1)).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil)), Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß this.getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß this.getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args)).
            this.invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                    ___args))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getMethodTable) [#_"MultiFn" this]
        (:methodTable this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getPreferTable) [#_"MultiFn" this]
        (:preferTable this)
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (def- #_"int" Murmur3'seed 0)
    (def- #_"int" Murmur3'C1 0xcc9e2d51)
    (def- #_"int" Murmur3'C2 0x1b873593)

    (defn #_"int" Murmur3'hashInt [#_"int" ___input]
        (when (ß ___input == 0)
            (§ return 0)
        )
        (let [#_"int" ___k1 (ß mixK1(___input))]
            (let [#_"int" ___h1 (ß mixH1(Murmur3'seed, ___k1))]
                (Murmur3'fmix ___h1, 4)
            )
        )
    )

    (defn #_"int" Murmur3'hashLong [#_"long" ___input]
        (when (ß ___input == 0)
            (§ return 0)
        )
        (let [#_"int" ___low (ß (int) ___input)]
            (let [#_"int" ___high (ß (int) (___input >>> 32))]
                (let [#_"int" ___k1 (ß mixK1(___low))]
                    (let [#_"int" ___h1 (ß mixH1(Murmur3'seed, ___k1))]
                        (§ ass ___k1 (ß mixK1(___high)))
                        (§ ass ___h1 (ß mixH1(___h1, ___k1)))

                        (Murmur3'fmix ___h1, 8)
                    )
                )
            )
        )
    )

    (defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" ___input]
        (let [#_"int" ___h1 Murmur3'seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [#_"int" ___i 1] (ß ___i < (.length ___input)) [(+ ___i 2)]
                (let [#_"int" ___k1 (ß ___input.charAt(___i - 1) | (___input.charAt(___i) << 16))]
                    (§ ass ___k1 (ß mixK1(___k1)))
                    (§ ass ___h1 (ß mixH1(___h1, ___k1)))
                )
            )

            ;; deal with any remaining characters
            (when (ß ((.length ___input) & 1) == 1)
                (let [#_"int" ___k1 (ß ___input.charAt((.length ___input) - 1))]
                    (§ ass ___k1 (ß mixK1(___k1)))
                    (§ ass ___h1 (ß ___h1 :xor ___k1))
                )
            )

            (ß Murmur3'fmix(___h1, 2 * (.length ___input)))
        )
    )

    (defn #_"int" Murmur3'mixCollHash [#_"int" ___hash, #_"int" ___count]
        (let [#_"int" ___h1 Murmur3'seed]
            (let [#_"int" ___k1 (ß mixK1(___hash))]
                (§ ass ___h1 (ß mixH1(___h1, ___k1)))
                (Murmur3'fmix ___h1, ___count)
            )
        )
    )

    (defn #_"int" Murmur3'hashOrdered [#_"Iterable" ___xs]
        (let [#_"int" ___n 0]
            (let [#_"int" ___hash 1]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß 31 * ___hash + Util'hasheq(___x)))
                    (§ ass ___n (inc ___n))
                )

                (ß mixCollHash(___hash, ___n))
            )
        )
    )

    (defn #_"int" Murmur3'hashUnordered [#_"Iterable" ___xs]
        (let [#_"int" ___hash 0]
            (let [#_"int" ___n 0]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß ___hash + Util'hasheq(___x)))
                    (§ ass ___n (inc ___n))
                )

                (ß mixCollHash(___hash, ___n))
            )
        )
    )

    (defn- #_"int" Murmur3'mixK1 [#_"int" ___k1]
        (§ ass ___k1 (ß ___k1 * Murmur3'C1))
        (§ ass ___k1 (Integer/rotateLeft ___k1, 15))
        (§ ass ___k1 (ß ___k1 * Murmur3'C2))
        ___k1
    )

    (defn- #_"int" Murmur3'mixH1 [#_"int" ___h1, #_"int" ___k1]
        (§ ass ___h1 (ß ___h1 :xor ___k1))
        (§ ass ___h1 (Integer/rotateLeft ___h1, 13))
        (§ ass ___h1 (ß ___h1 * 5 + 0xe6546b64))
        ___h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (defn- #_"int" Murmur3'fmix [#_"int" ___h1, #_"int" ___length]
        (§ ass ___h1 (ß ___h1 :xor ___length))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        (§ ass ___h1 (* ___h1 0x85ebca6b))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 13)))
        (§ ass ___h1 (* ___h1 0xc2b2ae35))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        ___h1
    )
)
)

(java-ns cloiure.lang.Named

(§ defprotocol Named
    #_abstract
    (#_"String" Named'''(§ method getNamespace) [#_"Named" this])
    #_abstract
    (#_"String" Named'''(§ method getName) [#_"Named" this])
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ConcurrentHashMap.))

    (defn- #_"Namespace" Namespace'init []
        (hash-map
            #_"Symbol" :name nil

            #_transient
            #_"AtomicReference<IPersistentMap>" :mappings (AtomicReference.)
            #_transient
            #_"AtomicReference<IPersistentMap>" :aliases (AtomicReference.)
        )
    )

    (defn #_"Namespace" Namespace'new [#_"Symbol" ___name]
        (let [this (merge (AReference'new (.meta ___name)) (Namespace'init))]
            (§ ass (:name this) ___name)
            (ß (:mappings this).set(RT'DEFAULT_IMPORTS))
            (ß (:aliases this).set(RT'map()))
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Namespace" this]
        (.toString (:name this))
    )

    (defn #_"ISeq" Namespace'all []
        (ß RT'seq((.values Namespace'namespaces)))
    )

    #_method
    (§ defn #_"Symbol" (§ method getName) [#_"Namespace" this]
        (:name this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getMappings) [#_"Namespace" this]
        (.get (:mappings this))
    )

    #_method
    (§ defn #_"Var" (§ method intern) [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (§ let [#_"Object" ___o]
                (let [#_"Var" ___v nil]
                    (while (nil? (§ ass ___o (.valAt ___map, ___sym)))
                        (when (nil? ___v)
                            (§ ass ___v (Var'new-2 this, ___sym))
                        )
                        (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___sym, ___v)]
                            (ß (:mappings this).compareAndSet(___map, ___newMap))
                            (§ ass ___map (.getMappings this))
                        )
                    )
                    (when (ß ___o instanceof Var && (:ns (cast' Var ___o)) == this)
                        (§ return (ß (Var) ___o))
                    )

                    (when (nil? ___v)
                        (§ ass ___v (Var'new-2 this, ___sym))
                    )

                    (.warnOrFailOnReplace this, ___sym, ___o, ___v)

                    (while (not (ß (:mappings this).compareAndSet(___map, ___map.assoc(___sym, ___v))))
                        (§ ass ___map (.getMappings this))
                    )

                    ___v
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" (§ method warnOrFailOnReplace) [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___o, #_"Object" ___v]
        (when (ß ___o instanceof Var)
            (let [#_"Namespace" ___ns (:ns (cast' Var ___o))]
                (when (ß ___ns == this || (___v instanceof Var && (:ns (cast' Var ___v)) == RT'CLOIURE_NS))
                    (§ return nil)
                )
                (when (ß ___ns != RT'CLOIURE_NS)
                    (throw (IllegalStateException. (str ___sym " already refers to: " ___o " in namespace: " (:name this))))
                )
            )
        )
        (.println (RT'errPrintWriter), (str "WARNING: " ___sym " already refers to: " ___o " in namespace: " (:name this) ", being replaced by: " ___v))
        nil
    )

    #_method
    (§ defn #_"Object" (§ method reference) [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___val]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (§ let [#_"Object" ___o]
                (while (nil? (§ ass ___o (.valAt ___map, ___sym)))
                    (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___sym, ___val)]
                        (ß (:mappings this).compareAndSet(___map, ___newMap))
                        (§ ass ___map (.getMappings this))
                    )
                )
                (when (ß ___o == ___val)
                    (§ return ___o)
                )

                (.warnOrFailOnReplace this, ___sym, ___o, ___val)

                (while (not (ß (:mappings this).compareAndSet(___map, ___map.assoc(___sym, ___val))))
                    (§ ass ___map (.getMappings this))
                )

                ___val
            )
        )
    )

    (defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" ___cls1, #_"Class" ___cls2]
        (ß (___cls1 != ___cls2) && ((.getName ___cls1).equals((.getName ___cls2))))
    )

    #_method
    (§ defn #_"Class" (§ method referenceClass) [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___val]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (let [#_"Class" ___c (ß (Class) ___map.valAt(___sym))]
                (while (ß (nil? ___c) || (areDifferentInstancesOfSameClassName(___c, ___val)))
                    (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___sym, ___val)]
                        (ß (:mappings this).compareAndSet(___map, ___newMap))
                        (§ ass ___map (.getMappings this))
                        (§ ass ___c (ß (Class) ___map.valAt(___sym)))
                    )
                )
                (when (ß ___c == ___val)
                    (§ return ___c)
                )

                (throw (IllegalStateException. (str ___sym " already refers to: " ___c " in namespace: " (:name this))))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method unmap) [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (.getMappings this)]
            (while (.containsKey ___map, ___sym)
                (let [#_"IPersistentMap" ___newMap (.without ___map, ___sym)]
                    (ß (:mappings this).compareAndSet(___map, ___newMap))
                    (§ ass ___map (.getMappings this))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Class" (§ method importClass) [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___c]
        (.referenceClass this, ___sym, ___c)
    )

    #_method
    (§ defn #_"Class" (§ method importClass) [#_"Namespace" this, #_"Class" ___c]
        (let [#_"String" ___n (.getName ___c)]
            (ß this.importClass(Symbol'intern-1(___n.substring(___n.lastIndexOf(\.) + 1)), ___c))
        )
    )

    #_method
    (§ defn #_"Var" (§ method refer) [#_"Namespace" this, #_"Symbol" ___sym, #_"Var" ___var]
        (ß (Var) this.reference(___sym, ___var))
    )

    (defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" ___name]
        (let [#_"Namespace" ___ns (.get Namespace'namespaces, ___name)]
            (when (some? ___ns)
                (§ return ___ns)
            )
            (let [#_"Namespace" ___newns (Namespace'new ___name)]
                (§ ass ___ns (.putIfAbsent Namespace'namespaces, ___name, ___newns))
                (or ___ns ___newns)
            )
        )
    )

    (defn #_"Namespace" Namespace'remove [#_"Symbol" ___name]
        (when (.equals ___name, (:name RT'CLOIURE_NS))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (.remove Namespace'namespaces, ___name)
    )

    (defn #_"Namespace" Namespace'find [#_"Symbol" ___name]
        (.get Namespace'namespaces, ___name)
    )

    #_method
    (§ defn #_"Object" (§ method getMapping) [#_"Namespace" this, #_"Symbol" ___name]
        (ß (:mappings this).get().valAt(___name))
    )

    #_method
    (§ defn #_"Var" (§ method findInternedVar) [#_"Namespace" this, #_"Symbol" ___symbol]
        (let [#_"Object" ___o (ß (:mappings this).get().valAt(___symbol))]
            (when (ß ___o != nil && ___o instanceof Var && (:ns (cast' Var ___o)) == this)
                (§ return (ß (Var) ___o))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method getAliases) [#_"Namespace" this]
        (.get (:aliases this))
    )

    #_method
    (§ defn #_"Namespace" (§ method lookupAlias) [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (.getAliases this)]
            (ß (Namespace) ___map.valAt(___alias))
        )
    )

    #_method
    (§ defn #_"void" (§ method addAlias) [#_"Namespace" this, #_"Symbol" ___alias, #_"Namespace" ___ns]
        (when (ß ___alias == nil || ___ns == nil)
            (throw (NullPointerException. "Expecting Symbol + Namespace"))
        )
        (let [#_"IPersistentMap" ___map (.getAliases this)]
            (while (not (ß ___map.containsKey(___alias)))
                (let [#_"IPersistentMap" ___newMap (.assoc ___map, ___alias, ___ns)]
                    (ß (:aliases this).compareAndSet(___map, ___newMap))
                    (§ ass ___map (.getAliases this))
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (not (ß ___map.valAt(___alias).equals(___ns)))
                (throw (IllegalStateException. (str "Alias " ___alias " already exists in namespace " (:name this) ", aliasing " (.valAt ___map, ___alias))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" (§ method removeAlias) [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (.getAliases this)]
            (while (.containsKey ___map, ___alias)
                (let [#_"IPersistentMap" ___newMap (.without ___map, ___alias)]
                    (ß (:aliases this).compareAndSet(___map, ___newMap))
                    (§ ass ___map (.getAliases this))
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(§ defprotocol Ops
    #_abstract
    (#_"Ops" Ops'''(§ method combine) [#_"Ops" this, #_"Ops" ___y])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithLong) [#_"Ops" this, #_"LongOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithDouble) [#_"Ops" this, #_"DoubleOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithRatio) [#_"Ops" this, #_"RatioOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithBigInt) [#_"Ops" this, #_"BigIntOps" ___x])
    #_abstract
    (#_"Ops" Ops'''(§ method opsWithBigDecimal) [#_"Ops" this, #_"BigDecimalOps" ___x])
    #_abstract
    (#_"boolean" Ops'''(§ method isZero) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''(§ method isPos) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''(§ method isNeg) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method add) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method addP) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method multiply) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method multiplyP) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method divide) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method quotient) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method remainder) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method equiv) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method lt) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method lte) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''(§ method gte) [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''(§ method negate) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method negateP) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method inc) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method incP) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method dec) [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''(§ method decP) [#_"Ops" this, #_"Number" ___x])
)

#_stateless
#_abstract
(class-ns OpsP (§ implements Ops)
    #_protected
    (defn #_"OpsP" OpsP'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Number" (§ method addP) [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (.add this, ___x, ___y)
    )

    #_method
    (§ defn #_"Number" (§ method multiplyP) [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (.multiply this, ___x, ___y)
    )

    #_method
    (§ defn #_"Number" (§ method negateP) [#_"OpsP" this, #_"Number" ___x]
        (.negate this, ___x)
    )

    #_method
    (§ defn #_"Number" (§ method incP) [#_"OpsP" this, #_"Number" ___x]
        (.inc this, ___x)
    )

    #_method
    (§ defn #_"Number" (§ method decP) [#_"OpsP" this, #_"Number" ___x]
        (.dec this, ___x)
    )
)

(class-ns LongOps (§ implements Ops)
    (defn #_"LongOps" LongOps'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"LongOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"RatioOps" ___x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"BigIntOps" ___x]
        Numbers'BIGINT_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"LongOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"LongOps" this, #_"Number" ___x]
        (ß ((.longValue ___x) == 0))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"LongOps" this, #_"Number" ___x]
        (ß ((.longValue ___x) > 0))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"LongOps" this, #_"Number" ___x]
        (ß ((.longValue ___x) < 0))
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'add-2ll((.longValue ___x), (.longValue ___y))))
    )

    #_method
    (§ defn #_"Number" (§ method addP) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (.longValue ___x) #_"long" ___ly (.longValue ___y)]
            (let [#_"long" ___ret (+ ___lx ___ly)]
                (when (ß (___ret :xor ___lx) < 0 && (___ret :xor ___ly) < 0)
                    (§ return (ß Numbers'BIGINT_OPS.add(___x, ___y)))
                )
                (ß num(___ret))
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'multiply-2ll((.longValue ___x), (.longValue ___y))))
    )

    #_method
    (§ defn #_"Number" (§ method multiplyP) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (.longValue ___x) #_"long" ___ly (.longValue ___y)]
            (when (ß ___lx == Long/MIN_VALUE && ___ly < 0)
                (§ return (ß Numbers'BIGINT_OPS.multiply(___x, ___y)))
            )
            (let [#_"long" ___ret (* ___lx ___ly)]
                (when (ß ___ly != 0 && ___ret / ___ly != ___lx)
                    (§ return (ß Numbers'BIGINT_OPS.multiply(___x, ___y)))
                )
                (ß num(___ret))
            )
        )
    )

    (defn #_"long" LongOps'gcd [#_"long" ___u, #_"long" ___v]
        (while (ß ___v != 0)
            (let [#_"long" ___r (ß ___u % ___v)]
                (§ ass ___u ___v)
                (§ ass ___v ___r)
            )
        )
        ___u
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___n (.longValue ___x)]
            (let [#_"long" ___val (.longValue ___y)]
                (let [#_"long" ___gcd (LongOps'gcd ___n, ___val)]
                    (when (ß ___gcd == 0)
                        (§ return (ß num(0)))
                    )

                    (§ ass ___n (/ ___n ___gcd))
                    (let [#_"long" ___d (/ ___val ___gcd)]
                        (when (ß ___d == 1)
                            (§ return (ß num(___n)))
                        )
                        (when (< ___d 0)
                            (§ ass ___n (- ___n))
                            (§ ass ___d (- ___d))
                        )
                        (ß Ratio'new(BigInteger/valueOf(___n), BigInteger/valueOf(___d)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num((.longValue ___x) / (.longValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num((.longValue ___x) % (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) == (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) < (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) <= (.longValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.longValue ___x) >= (.longValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (ß num(Numbers'minus-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method negateP) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (when (ß ___val > Long/MIN_VALUE)
                (§ return (ß num(-val)))
            )
            (ß BigInt'fromBigInteger(BigInteger/valueOf(___val).negate()))
        )
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (ß num(Numbers'inc-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method incP) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (when (ß ___val < Long/MAX_VALUE)
                (§ return (ß num(___val + 1)))
            )
            (ß Numbers'BIGINT_OPS.inc(___x))
        )
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (ß num(Numbers'dec-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method decP) [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (.longValue ___x)]
            (when (ß ___val > Long/MIN_VALUE)
                (§ return (ß num(___val - 1)))
            )
            (ß Numbers'BIGINT_OPS.dec(___x))
        )
    )
)

(class-ns DoubleOps (§ extends OpsP)
    (defn #_"DoubleOps" DoubleOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"DoubleOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"DoubleOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"DoubleOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"DoubleOps" this, #_"Number" ___x]
        (ß ((.doubleValue ___x) == 0))
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"DoubleOps" this, #_"Number" ___x]
        (ß ((.doubleValue ___x) > 0))
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"DoubleOps" this, #_"Number" ___x]
        (ß ((.doubleValue ___x) < 0))
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf((.doubleValue ___x) + (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf((.doubleValue ___x) * (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf((.doubleValue ___x) / (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'quotient-2dd((.doubleValue ___x), (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'remainder-2dd((.doubleValue ___x), (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) == (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) < (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) <= (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß ((.doubleValue ___x) >= (.doubleValue ___y)))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(-x.doubleValue()))
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf((.doubleValue ___x) + 1))
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf((.doubleValue ___x) - 1))
    )
)

(class-ns RatioOps (§ extends OpsP)
    (defn #_"RatioOps" RatioOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"RatioOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"RatioOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß ((:numerator ___r).signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß ((:numerator ___r).signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß ((:numerator ___r).signum() < 0))
        )
    )

    (defn #_"Number" RatioOps'normalizeRet [#_"Number" ___ret, #_"Number" ___x, #_"Number" ___y]
        ___ret
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß this.divide((:numerator ___ry).multiply((:denominator ___rx)).add((:numerator ___rx).multiply((:denominator ___ry))), (:denominator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß Numbers'divide-2ii((:numerator ___ry).multiply((:numerator ___rx)), (:denominator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß Numbers'divide-2ii((:denominator ___ry).multiply((:numerator ___rx)), (:numerator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"BigInteger" ___q (ß (:numerator ___rx).multiply((:denominator ___ry)).divide((:denominator ___rx).multiply((:numerator ___ry))))]
                    (ß RatioOps'normalizeRet(BigInt'fromBigInteger(___q), ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"BigInteger" ___q (ß (:numerator ___rx).multiply((:denominator ___ry)).divide((:denominator ___rx).multiply((:numerator ___ry))))]
                    (let [#_"Number" ___ret (ß Numbers'minus-2oo(___x, Numbers'multiply-2oo(___q, ___y)))]
                        (RatioOps'normalizeRet ___ret, ___x, ___y)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß ((:numerator ___rx).equals((:numerator ___ry)) && (:denominator ___rx).equals((:denominator ___ry))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'lt-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'lte-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'gte-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß Ratio'new((:numerator ___r).negate(), (:denominator ___r)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"RatioOps" this, #_"Number" ___x]
        (Numbers'add-2ol ___x, 1)
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"RatioOps" this, #_"Number" ___x]
        (Numbers'add-2ol ___x, -1)
    )
)

(class-ns BigIntOps (§ extends OpsP)
    (defn #_"BigIntOps" BigIntOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"BigIntOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"RatioOps" ___x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigIntOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß (:bipart ___bx) == nil)
                (§ return (ß ((:lpart ___bx) == 0)))
            )
            (ß ((:bipart ___bx).signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß (:bipart ___bx) == nil)
                (§ return (ß ((:lpart ___bx) > 0)))
            )
            (ß ((:bipart ___bx).signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß (:bipart ___bx) == nil)
                (§ return (ß ((:lpart ___bx) < 0)))
            )
            (ß ((:bipart ___bx).signum() < 0))
        )
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).add(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).multiply(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'divide-2ii(this.toBigInteger(___x), this.toBigInteger(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).quotient(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).remainder(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).equals(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).lt(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigInteger(___x).compareTo(this.toBigInteger(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigInteger(___x).compareTo(this.toBigInteger(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"BigIntOps" this, #_"Number" ___x]
        (ß BigInt'fromBigInteger(this.toBigInteger(___x).negate()))
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (.toBigInteger this, ___x)]
            (ß BigInt'fromBigInteger(___bx.add(BigInteger/ONE)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (.toBigInteger this, ___x)]
            (ß BigInt'fromBigInteger(___bx.subtract(BigInteger/ONE)))
        )
    )
)

(class-ns BigDecimalOps (§ extends OpsP)
    (§ def #_"Var" BigDecimalOps'MATH_CONTEXT RT'MATH_CONTEXT)

    (defn #_"BigDecimalOps" BigDecimalOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" (§ method combine) [#_"BigDecimalOps" this, #_"Ops" ___y]
        (.opsWith ___y, this)
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" (§ method opsWith) [#_"BigDecimalOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isZero) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß ((.signum ___bx) == 0))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isPos) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß ((.signum ___bx) > 0))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isNeg) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß ((.signum ___bx) < 0))
        )
    )

    #_method
    (§ defn #_"Number" (§ method add) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).add(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).add(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method multiply) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).multiply(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).multiply(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method divide) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).divide(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).divide(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method quotient) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).divideToIntegralValue(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).divideToIntegralValue(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method remainder) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (if (nil? ___mc) (ß this.toBigDecimal(___x).remainder(this.toBigDecimal(___y))) (ß this.toBigDecimal(___x).remainder(this.toBigDecimal(___y), ___mc)))
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y)) == 0))
    )

    #_method
    (§ defn #_"boolean" (§ method lt) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y)) < 0))
    )

    #_method
    (§ defn #_"boolean" (§ method lte) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" (§ method gte) [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (this.toBigDecimal(___x).compareTo(this.toBigDecimal(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" (§ method negate) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (if (nil? ___mc) (ß (cast BigDecimal ___x).negate()) (ß (cast BigDecimal ___x).negate(___mc)))
        )
    )

    #_method
    (§ defn #_"Number" (§ method inc) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                (if (nil? ___mc) (ß ___bx.add(BigDecimal/ONE)) (ß ___bx.add(BigDecimal/ONE, ___mc)))
            )
        )
    )

    #_method
    (§ defn #_"Number" (§ method dec) [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                (if (nil? ___mc) (ß ___bx.subtract(BigDecimal/ONE)) (ß ___bx.subtract(BigDecimal/ONE, ___mc)))
            )
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

#_stateless
(class-ns Numbers
    (defn #_"boolean" Numbers'isZero-1o [#_"Object" ___x]
        (ß ops(___x).isZero((cast Number ___x)))
    )

    (defn #_"boolean" Numbers'isPos-1o [#_"Object" ___x]
        (ß ops(___x).isPos((cast Number ___x)))
    )

    (defn #_"boolean" Numbers'isNeg-1o [#_"Object" ___x]
        (ß ops(___x).isNeg((cast Number ___x)))
    )

    (defn #_"Number" Numbers'minus-1o [#_"Object" ___x]
        (ß ops(___x).negate((cast Number ___x)))
    )

    (defn #_"Number" Numbers'minusP-1o [#_"Object" ___x]
        (ß ops(___x).negateP((Number)___x))
    )

    (defn #_"Number" Numbers'inc-1o [#_"Object" ___x]
        (ß ops(___x).inc((cast Number ___x)))
    )

    (defn #_"Number" Numbers'incP-1o [#_"Object" ___x]
        (ß ops(___x).incP((Number)___x))
    )

    (defn #_"Number" Numbers'dec-1o [#_"Object" ___x]
        (ß ops(___x).dec((cast Number ___x)))
    )

    (defn #_"Number" Numbers'decP-1o [#_"Object" ___x]
        (ß ops(___x).decP((Number)___x))
    )

    (defn #_"Number" Numbers'add-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).add((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'addP-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).addP((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'minus-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (ß ops(___x).combine(___yops).add((Number)___x, ___yops.negate((cast Number ___y))))
        )
    )

    (defn #_"Number" Numbers'minusP-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (let [#_"Number" ___negativeY (ß ___yops.negateP((Number)___y))]
                (let [#_"Ops" ___negativeYOps (ß ops(___negativeY))]
                    (ß ops(___x).combine(___negativeYOps).addP((Number)___x, ___negativeY))
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiply-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).multiply((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'multiplyP-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).multiplyP((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'divide-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return (ß (Number)___x))
            )
            (ß isNaN(___y))
            (do
                (§ return (ß (Number)___y))
            )
        )
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((cast Number ___y)))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).divide((Number)___x, (Number)___y))
        )
    )

    (defn #_"Number" Numbers'quotient-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((cast Number ___y)))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).quotient((Number)___x, (Number)___y))
        )
    )

    (defn #_"Number" Numbers'remainder-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((cast Number ___y)))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).remainder((Number)___x, (Number)___y))
        )
    )

    (defn #_"double" Numbers'quotient-2dd [#_"double" ___n, #_"double" ___d]
        (when (ß ___d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (/ ___n ___d)]
            (cond (ß ___q <= Long/MAX_VALUE && ___q >= Long/MIN_VALUE)
                (do
                    (ß (double)(long) ___q)
                )
                :else ;; bigint quotient
                (do
                    (ß (BigDecimal. ___q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (defn #_"double" Numbers'remainder-2dd [#_"double" ___n, #_"double" ___d]
        (when (ß ___d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (/ ___n ___d)]
            (cond (ß ___q <= Long/MAX_VALUE && ___q >= Long/MIN_VALUE)
                (do
                    (ß (___n - ((long) ___q) * ___d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" ___bq (ß (BigDecimal. ___q).toBigInteger())]
                        (ß (___n - (.doubleValue ___bq) * ___d))
                    )
                )
            )
        )
    )

    (defn #_"boolean" Numbers'equiv-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'equiv-2nn (cast Number ___x), (cast Number ___y))
    )

    (defn #_"boolean" Numbers'equiv-2nn [#_"Number" ___x, #_"Number" ___y]
        (ß ops(___x).combine(ops(___y)).equiv(___x, ___y))
    )

    (defn #_"boolean" Numbers'equal [#_"Number" ___x, #_"Number" ___y]
        (ß (category(___x) == category(___y) && ops(___x).combine(ops(___y)).equiv(___x, ___y)))
    )

    (defn #_"boolean" Numbers'lt-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lt((Number)___x, (Number)___y))
    )

    (defn #_"boolean" Numbers'lte-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lte((Number)___x, (Number)___y))
    )

    (defn #_"boolean" Numbers'gt-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lt((Number)___y, (Number)___x))
    )

    (defn #_"boolean" Numbers'gte-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).gte((Number)___x, (Number)___y))
    )

    (defn #_"int" Numbers'compare [#_"Number" ___x, #_"Number" ___y]
        (let [#_"Ops" ___ops (ß ops(___x).combine(ops(___y)))]
            (cond (.lt ___ops, ___x, ___y)
                (do
                    (§ return -1)
                )
                (.lt ___ops, ___y, ___x)
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (defn #_"BigInt" Numbers'toBigInt [#_"Object" ___x]
        (when (ß ___x instanceof BigInt)
            (§ return (ß (BigInt) ___x))
        )
        (if (ß ___x instanceof BigInteger)
            (do
                (ß BigInt'fromBigInteger((cast BigInteger ___x)))
            )
            (do
                (ß BigInt'fromLong((cast Number ___x).longValue()))
            )
        )
    )

    (defn #_"BigInteger" Numbers'toBigInteger [#_"Object" ___x]
        (cond (ß ___x instanceof BigInteger)
            (do
                (ß (BigInteger) ___x)
            )
            (ß ___x instanceof BigInt)
            (do
                (ß (cast' BigInt ___x).toBigInteger())
            )
            :else
            (do
                (ß BigInteger/valueOf((cast Number ___x).longValue()))
            )
        )
    )

    (defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" ___x]
        (cond (ß ___x instanceof BigDecimal)
            (do
                (ß (BigDecimal) ___x)
            )
            (ß ___x instanceof BigInt)
            (do
                (let [#_"BigInt" ___bi (ß (BigInt) ___x)]
                    (if (ß (:bipart ___bi) == nil)
                        (do
                            (ß BigDecimal/valueOf((:lpart ___bi)))
                        )
                        (do
                            (§ unsure BigDecimal. (:bipart ___bi))
                        )
                    )
                )
            )
            (ß ___x instanceof BigInteger)
            (do
                (§ unsure BigDecimal. (ß (BigInteger) ___x))
            )
            (ß ___x instanceof Double)
            (do
                (§ unsure BigDecimal. (ß (cast Number ___x).doubleValue()))
            )
            (ß ___x instanceof Float)
            (do
                (§ unsure BigDecimal. (ß (cast Number ___x).doubleValue()))
            )
            (ß ___x instanceof Ratio)
            (do
                (let [#_"Ratio" ___r (ß (Ratio)___x)]
                    (cast BigDecimal (Numbers'divide-2oo (§ unsure BigDecimal. (:numerator ___r)), (:denominator ___r)))
                )
            )
            :else
            (do
                (BigDecimal/valueOf (ß (cast Number ___x).longValue()))
            )
        )
    )

    (defn #_"Ratio" Numbers'toRatio [#_"Object" ___x]
        (cond (ß ___x instanceof Ratio)
            (do
                (§ return (ß (Ratio) ___x))
            )
            (ß ___x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                    (let [#_"BigInteger" ___bv (.unscaledValue ___bx)]
                        (let [#_"int" ___scale (.scale ___bx)]
                            (if (< ___scale 0)
                                (do
                                    (§ return (ß Ratio'new(___bv.multiply(BigInteger/TEN.pow(-scale)), BigInteger/ONE)))
                                )
                                (do
                                    (§ return (ß Ratio'new(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (Ratio'new (Numbers'toBigInteger ___x), BigInteger/ONE)
    )

    (defn #_"Number" Numbers'rationalize [#_"Number" ___x]
        (cond (ß ___x instanceof Float || ___x instanceof Double)
            (do
                (§ return (ß rationalize(BigDecimal/valueOf((.doubleValue ___x)))))
            )
            (ß ___x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                    (let [#_"BigInteger" ___bv (.unscaledValue ___bx)]
                        (let [#_"int" ___scale (.scale ___bx)]
                            (if (< ___scale 0)
                                (do
                                    (§ return (ß BigInt'fromBigInteger(___bv.multiply(BigInteger/TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß Numbers'divide-ii(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        ___x
    )

    (defn #_"Number" Numbers'reduceBigInt [#_"BigInt" ___val]
        (if (ß (:bipart ___val) == nil)
            (do
                (ß num((:lpart ___val)))
            )
            (do
                (:bipart ___val)
            )
        )
    )

    (defn #_"Number" Numbers'divide-2ii [#_"BigInteger" ___n, #_"BigInteger" ___d]
        (when (ß ___d.equals(BigInteger/ZERO))
            (throw (ArithmeticException. "Divide by zero"))
        )
        (let [#_"BigInteger" ___gcd (.gcd ___n, ___d)]
            (when (ß ___gcd.equals(BigInteger/ZERO))
                (§ return BigInt'ZERO)
            )
            (§ ass ___n (.divide ___n, ___gcd))
            (§ ass ___d (.divide ___d, ___gcd))
            (cond (ß ___d.equals(BigInteger/ONE))
                (do
                    (§ return (BigInt'fromBigInteger ___n))
                )
                (ß ___d.equals(BigInteger/ONE.negate()))
                (do
                    (§ return (ß BigInt'fromBigInteger((.negate ___n))))
                )
            )
            (Ratio'new (if (neg? (.signum ___d)) (.negate ___n) ___n), (if (neg? (.signum ___d)) (.negate ___d) ___d))
        )
    )

    (defn #_"int" Numbers'shiftLeftInt [#_"int" ___x, #_"int" ___n]
        (<< ___x ___n)
    )

    (defn #_"long" Numbers'shiftLeft-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß shiftLeft(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftLeft-2ol [#_"Object" ___x, #_"long" ___y]
        (ß shiftLeft(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'shiftLeft-2lo [#_"long" ___x, #_"Object" ___y]
        (ß shiftLeft(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftLeft-2ll [#_"long" ___x, #_"long" ___n]
        (<< ___x ___n)
    )

    (defn #_"int" Numbers'shiftRightInt [#_"int" ___x, #_"int" ___n]
        (>> ___x ___n)
    )

    (defn #_"long" Numbers'shiftRight-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß shiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftRight-2ol [#_"Object" ___x, #_"long" ___y]
        (ß shiftRight(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'shiftRight-2lo [#_"long" ___x, #_"Object" ___y]
        (ß shiftRight(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftRight-2ll [#_"long" ___x, #_"long" ___n]
        (>> ___x ___n)
    )

    (defn #_"int" Numbers'unsignedShiftRightInt [#_"int" ___x, #_"int" ___n]
        (>>> ___x ___n)
    )

    (defn #_"long" Numbers'unsignedShiftRight-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ol [#_"Object" ___x, #_"long" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2lo [#_"long" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ll [#_"long" ___x, #_"long" ___n]
        (>>> ___x ___n)
    )

    (§ def #_"LongOps" Numbers'LONG_OPS (LongOps'new))
    (§ def #_"DoubleOps" Numbers'DOUBLE_OPS (DoubleOps'new))
    (§ def #_"RatioOps" Numbers'RATIO_OPS (RatioOps'new))
    (§ def #_"BigIntOps" Numbers'BIGINT_OPS (BigIntOps'new))
    (§ def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps'new))

    (defn #_"Ops" Numbers'ops [#_"Object" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (cond (ß ___xc == (§ class Long))
                (do
                    Numbers'LONG_OPS
                )
                (ß ___xc == (§ class Double))
                (do
                    Numbers'DOUBLE_OPS
                )
                (ß ___xc == (§ class Integer))
                (do
                    Numbers'LONG_OPS
                )
                (ß ___xc == (§ class Float))
                (do
                    Numbers'DOUBLE_OPS
                )
                (ß ___xc == (§ class BigInt))
                (do
                    Numbers'BIGINT_OPS
                )
                (ß ___xc == (§ class BigInteger))
                (do
                    Numbers'BIGINT_OPS
                )
                (ß ___xc == (§ class Ratio))
                (do
                    Numbers'RATIO_OPS
                )
                (ß ___xc == (§ class BigDecimal))
                (do
                    Numbers'BIGDECIMAL_OPS
                )
                :else
                (do
                    Numbers'LONG_OPS
                )
            )
        )
    )

    (defn #_"int" Numbers'hasheqFrom [#_"Number" ___x, #_"Class" ___xc]
        (when (ß ___xc == (§ class Integer) || ___xc == (§ class Short) || ___xc == (§ class Byte) || (___xc == (§ class BigInteger) && Numbers'lte-2ol(___x, Long/MAX_VALUE) && Numbers'gte-2ol(___x, Long/MIN_VALUE)))
            (let [#_"long" ___lpart (.longValue ___x)]
                (§ return (Murmur3'hashLong ___lpart))
            )
        )
        (when (ß ___xc == (§ class BigDecimal))
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode. Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (Numbers'isZero-1o ___x)
                (do
                    (§ return (ß BigDecimal/ZERO.hashCode()))
                )
                (do
                    (§ return (ß (cast BigDecimal ___x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (ß ___xc == (§ class Float) && ___x.equals((float) -0.0))
            (§ return 0) ;; match 0.0f
        )
        (.hashCode ___x)
    )

    (defn #_"int" Numbers'hasheq [#_"Number" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (when (ß ___xc == (§ class Long))
                (let [#_"long" ___lpart (.longValue ___x)]
                    (§ return (Murmur3'hashLong ___lpart))
                )
            )
            (when (ß ___xc == (§ class Double))
                (when (.equals ___x, -0.0)
                    (§ return 0) ;; match 0.0
                )
                (§ return (.hashCode ___x))
            )
            (ß hasheqFrom(___x, ___xc))
        )
    )

    (defn #_"Category" Numbers'category [#_"Object" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (cond (ß ___xc == (§ class Integer))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Double))
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class Long))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Float))
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class BigInt))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Ratio))
                (do
                    (ß :Category'RATIO)
                )
                (ß ___xc == (§ class BigDecimal))
                (do
                    (ß :Category'DECIMAL)
                )
                :else
                (do
                    (ß :Category'INTEGER)
                )
            )
        )
    )

    (defn #_"long" Numbers'bitOpsCast [#_"Object" ___x]
        (let [#_"Class" ___xc (.getClass ___x)]
            (when (ß ___xc == (§ class Long) || ___xc == (§ class Integer) || ___xc == (§ class Short) || ___xc == (§ class Byte))
                (§ return (RT'longCast-1o ___x))
            )
            ;; no bignums, no decimals
            (throw (IllegalArgumentException. (str "bit operation not supported for: " ___xc)))
        )
    )

    (defn #_"float[]" Numbers'float_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"float[]" ___ret (.float-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"float" ___f (ß (cast Number ___init).floatValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).floatValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"float[]" Numbers'float_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.float-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"float[]" ___ret (.float-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).floatValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"double[]" Numbers'double_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"double[]" ___ret (.double-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"double" ___f (ß (cast Number ___init).doubleValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).doubleValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"double[]" Numbers'double_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.double-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"double[]" ___ret (.double-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).doubleValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"int[]" Numbers'int_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"int[]" ___ret (.int-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"int" ___f (ß (cast Number ___init).intValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).intValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"int[]" Numbers'int_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.int-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"int[]" ___ret (.int-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).intValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"long[]" Numbers'long_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"long[]" ___ret (.long-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"long" ___f (ß (cast Number ___init).longValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).longValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"long[]" Numbers'long_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.long-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"long[]" ___ret (.long-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).longValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"short[]" Numbers'short_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"short[]" ___ret (.short-array ___size)]
            (if (ß ___init instanceof Short)
                (do
                    (let [#_"short" ___s (ß (Short) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).shortValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"short[]" Numbers'short_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.short-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"short[]" ___ret (.short-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).shortValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"char[]" Numbers'char_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"char[]" ___ret (.char-array ___size)]
            (if (ß ___init instanceof Character)
                (do
                    (let [#_"char" ___c (ß (Character) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß (Character) (first ___s)))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"char[]" Numbers'char_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.char-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"char[]" ___ret (.char-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß (Character) (first ___s)))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"byte[]" Numbers'byte_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"byte[]" ___ret (.byte-array ___size)]
            (if (ß ___init instanceof Byte)
                (do
                    (let [#_"byte" ___b (ß (Byte) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).byteValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"byte[]" Numbers'byte_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.byte-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"byte[]" ___ret (.byte-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß ((Number) (first ___s)).byteValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"boolean[]" ___ret (.boolean-array ___size)]
            (if (ß ___init instanceof Boolean)
                (do
                    (let [#_"boolean" ___b (ß (Boolean) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (ß (Boolean)___s.first()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (.boolean-array (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"boolean[]" ___ret (.boolean-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (ß (Boolean)___s.first()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'booleans [#_"Object" ___array]
        (.booleans ___array)
    )

    (defn #_"byte[]" Numbers'bytes [#_"Object" ___array]
        (.bytes ___array)
    )

    (defn #_"char[]" Numbers'chars [#_"Object" ___array]
        (.chars ___array)
    )

    (defn #_"short[]" Numbers'shorts [#_"Object" ___array]
        (.shorts ___array)
    )

    (defn #_"float[]" Numbers'floats [#_"Object" ___array]
        (.floats ___array)
    )

    (defn #_"double[]" Numbers'doubles [#_"Object" ___array]
        (.doubles ___array)
    )

    (defn #_"int[]" Numbers'ints [#_"Object" ___array]
        (.ints ___array)
    )

    (defn #_"long[]" Numbers'longs [#_"Object" ___array]
        (.longs ___array)
    )

    (defn #_"Number" Numbers'num-1o [#_"Object" ___x]
        (cast Number ___x)
    )

    (defn #_"Number" Numbers'num-1f [#_"float" ___x]
        (Float/valueOf ___x)
    )

    (defn #_"Number" Numbers'num-1d [#_"double" ___x]
        (Double/valueOf ___x)
    )

    (defn #_"double" Numbers'add-2dd [#_"double" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2dd [#_"double" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'minus-2dd [#_"double" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2dd [#_"double" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minus-1d [#_"double" ___x]
        (- ___x)
    )

    (defn #_"double" Numbers'minusP-1d [#_"double" ___x]
        (- ___x)
    )

    (defn #_"double" Numbers'inc-1d [#_"double" ___x]
        (+ ___x 1)
    )

    (defn #_"double" Numbers'incP-1d [#_"double" ___x]
        (+ ___x 1)
    )

    (defn #_"double" Numbers'dec-1d [#_"double" ___x]
        (- ___x 1)
    )

    (defn #_"double" Numbers'decP-1d [#_"double" ___x]
        (- ___x 1)
    )

    (defn #_"double" Numbers'multiply-2dd [#_"double" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2dd [#_"double" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'divide-2dd [#_"double" ___x, #_"double" ___y]
        (/ ___x ___y)
    )

    (defn #_"boolean" Numbers'equiv-2dd [#_"double" ___x, #_"double" ___y]
        (ß ___x == ___y)
    )

    (defn #_"boolean" Numbers'lt-2dd [#_"double" ___x, #_"double" ___y]
        (ß ___x < ___y)
    )

    (defn #_"boolean" Numbers'lte-2dd [#_"double" ___x, #_"double" ___y]
        (ß ___x <= ___y)
    )

    (defn #_"boolean" Numbers'gt-2dd [#_"double" ___x, #_"double" ___y]
        (ß ___x > ___y)
    )

    (defn #_"boolean" Numbers'gte-2dd [#_"double" ___x, #_"double" ___y]
        (ß ___x >= ___y)
    )

    (defn #_"boolean" Numbers'isPos-1d [#_"double" ___x]
        (ß ___x > 0)
    )

    (defn #_"boolean" Numbers'isNeg-1d [#_"double" ___x]
        (ß ___x < 0)
    )

    (defn #_"boolean" Numbers'isZero-1d [#_"double" ___x]
        (ß ___x == 0)
    )

    (defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (defn #_"int" Numbers'unchecked_int_add [#_"int" ___x, #_"int" ___y]
        (+ ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_subtract [#_"int" ___x, #_"int" ___y]
        (- ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_negate [#_"int" ___x]
        (- ___x)
    )

    (defn #_"int" Numbers'unchecked_int_inc [#_"int" ___x]
        (+ ___x 1)
    )

    (defn #_"int" Numbers'unchecked_int_dec [#_"int" ___x]
        (- ___x 1)
    )

    (defn #_"int" Numbers'unchecked_int_multiply [#_"int" ___x, #_"int" ___y]
        (* ___x ___y)
    )

    (defn #_"long" Numbers'not-1o [#_"Object" ___x]
        (ß not(bitOpsCast(___x)))
    )

    (defn #_"long" Numbers'not-1l [#_"long" ___x]
        (ß ~___x)
    )

    (defn #_"long" Numbers'and-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß and(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'and-2ol [#_"Object" ___x, #_"long" ___y]
        (ß and(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'and-2lo [#_"long" ___x, #_"Object" ___y]
        (ß and(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'and-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x & ___y)
    )

    (defn #_"long" Numbers'or-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß or(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'or-2ol [#_"Object" ___x, #_"long" ___y]
        (ß or(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'or-2lo [#_"long" ___x, #_"Object" ___y]
        (ß or(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'or-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x | ___y)
    )

    (defn #_"long" Numbers'xor-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß xor(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'xor-2ol [#_"Object" ___x, #_"long" ___y]
        (ß xor(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'xor-2lo [#_"long" ___x, #_"Object" ___y]
        (ß xor(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'xor-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x :xor ___y)
    )

    (defn #_"long" Numbers'andNot-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß andNot(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'andNot-2ol [#_"Object" ___x, #_"long" ___y]
        (ß andNot(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'andNot-2lo [#_"long" ___x, #_"Object" ___y]
        (ß andNot(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'andNot-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x & ~___y)
    )

    (defn #_"long" Numbers'clearBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß clearBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'clearBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß clearBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'clearBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß clearBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'clearBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x & ~(1 << ___n))
    )

    (defn #_"long" Numbers'setBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß setBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'setBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß setBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'setBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß setBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'setBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x | (1 << ___n))
    )

    (defn #_"long" Numbers'flipBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß flipBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'flipBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß flipBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'flipBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß flipBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'flipBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x :xor (1 << ___n))
    )

    (defn #_"boolean" Numbers'testBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß testBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"boolean" Numbers'testBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß testBit(bitOpsCast(___x), ___y))
    )

    (defn #_"boolean" Numbers'testBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß testBit(___x, bitOpsCast(___y)))
    )

    (defn #_"boolean" Numbers'testBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ((___x & (1 << ___n)) != 0))
    )

    (defn #_"int" Numbers'unchecked_int_divide [#_"int" ___x, #_"int" ___y]
        (/ ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_remainder [#_"int" ___x, #_"int" ___y]
        (ß ___x % ___y)
    )

    (defn #_"Number" Numbers'num-1l [#_"long" ___x]
        (Long/valueOf ___x)
    )

    (defn #_"long" Numbers'unchecked_add-2ll [#_"long" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_minus-2ll [#_"long" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_multiply-2ll [#_"long" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_minus-1l [#_"long" ___x]
        (- ___x)
    )

    (defn #_"long" Numbers'unchecked_inc-1l [#_"long" ___x]
        (+ ___x 1)
    )

    (defn #_"long" Numbers'unchecked_dec-1l [#_"long" ___x]
        (- ___x 1)
    )

    (defn #_"Number" Numbers'unchecked_add-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'add-2oo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'minus-2oo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2oo [#_"Object" ___x, #_"Object" ___y]
        (Numbers'multiply-2oo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-1o [#_"Object" ___x]
        (Numbers'minus-1o ___x)
    )

    (defn #_"Number" Numbers'unchecked_inc-1o [#_"Object" ___x]
        (Numbers'inc-1o ___x)
    )

    (defn #_"Number" Numbers'unchecked_dec-1o [#_"Object" ___x]
        (Numbers'dec-1o ___x)
    )

    (defn #_"double" Numbers'unchecked_add-2dd [#_"double" ___x, #_"double" ___y]
        (Numbers'add-2dd ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dd [#_"double" ___x, #_"double" ___y]
        (Numbers'minus-2dd ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dd [#_"double" ___x, #_"double" ___y]
        (Numbers'multiply-2dd ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-1d [#_"double" ___x]
        (Numbers'minus-1d ___x)
    )

    (defn #_"double" Numbers'unchecked_inc-1d [#_"double" ___x]
        (Numbers'inc-1d ___x)
    )

    (defn #_"double" Numbers'unchecked_dec-1d [#_"double" ___x]
        (Numbers'dec-1d ___x)
    )

    (defn #_"double" Numbers'unchecked_add-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'add-2do ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'minus-2do ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'multiply-2do ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_add-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'add-2od ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'minus-2od ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'multiply-2od ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_add-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'add-2dl ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'minus-2dl ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'multiply-2dl ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_add-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'add-2ld ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_minus-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'minus-2ld ___x, ___y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'multiply-2ld ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_add-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'add-2lo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'minus-2lo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'multiply-2lo ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_add-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'add-2ol ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'minus-2ol ___x, ___y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'multiply-2ol ___x, ___y)
    )

    (defn #_"Number" Numbers'quotient-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'quotient-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'quotient-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'quotient-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'quotient-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'quotient-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'quotient-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'quotient-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'quotient-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'quotient-2dd ___x, (double ___y))
    )

    (defn #_"double" Numbers'quotient-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'quotient-2dd (double ___x), ___y)
    )

    (defn #_"Number" Numbers'remainder-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'remainder-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'remainder-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'remainder-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'remainder-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'remainder-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'remainder-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'remainder-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'remainder-2dl [#_"double" ___x, #_"long" ___y]
        (Numbers'remainder-2dd ___x, (double ___y))
    )

    (defn #_"double" Numbers'remainder-2ld [#_"long" ___x, #_"double" ___y]
        (Numbers'remainder-2dd (double ___x), ___y)
    )

    (defn #_"long" Numbers'add-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (+ ___x ___y)]
            (when (ß (___ret :xor ___x) < 0 && (___ret :xor ___y) < 0)
                (§ return (ß throwIntOverflow()))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'addP-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (+ ___x ___y)]
            (when (ß (___ret :xor ___x) < 0 && (___ret :xor ___y) < 0)
                (§ return (Numbers'addP-2oo (cast Number ___x), (cast Number ___y)))
            )
            (ß num(___ret))
        )
    )

    (defn #_"long" Numbers'minus-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (- ___x ___y)]
            (when (ß ((___ret :xor ___x) < 0 && (___ret :xor ~___y) < 0))
                (§ return (ß throwIntOverflow()))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'minusP-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (- ___x ___y)]
            (when (ß ((___ret :xor ___x) < 0 && (___ret :xor ~___y) < 0))
                (§ return (ß minusP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (defn #_"long" Numbers'minus-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (- ___x)
    )

    (defn #_"Number" Numbers'minusP-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß BigInt'fromBigInteger(BigInteger/valueOf(___x).negate())))
        )
        (ß num(-x))
    )

    (defn #_"long" Numbers'inc-1l [#_"long" ___x]
        (when (ß ___x == Long/MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (inc ___x)
    )

    (defn #_"Number" Numbers'incP-1l [#_"long" ___x]
        (when (ß ___x == Long/MAX_VALUE)
            (§ return (ß Numbers'BIGINT_OPS.inc(___x)))
        )
        (ß num(___x + 1))
    )

    (defn #_"long" Numbers'dec-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (dec ___x)
    )

    (defn #_"Number" Numbers'decP-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß Numbers'BIGINT_OPS.dec(___x)))
        )
        (ß num(___x - 1))
    )

    (defn #_"long" Numbers'multiply-2ll [#_"long" ___x, #_"long" ___y]
        (when (ß ___x == Long/MIN_VALUE && ___y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (let [#_"long" ___ret (* ___x ___y)]
            (when (ß ___y != 0 && ___ret / ___y != ___x)
                (§ return (ß throwIntOverflow()))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'multiplyP-2ll [#_"long" ___x, #_"long" ___y]
        (when (ß ___x == Long/MIN_VALUE && ___y < 0)
            (§ return (Numbers'multiplyP (cast Number ___x), (cast Number ___y)))
        )
        (let [#_"long" ___ret (* ___x ___y)]
            (when (ß ___y != 0 && ___ret / ___y != ___x)
                (§ return (Numbers'multiplyP (cast Number ___x), (cast Number ___y)))
            )
            (ß num(___ret))
        )
    )

    (defn #_"long" Numbers'quotient-2ll [#_"long" ___x, #_"long" ___y]
        (/ ___x ___y)
    )

    (defn #_"long" Numbers'remainder-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x % ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x == ___y)
    )

    (defn #_"boolean" Numbers'lt-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x < ___y)
    )

    (defn #_"boolean" Numbers'lte-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x <= ___y)
    )

    (defn #_"boolean" Numbers'gt-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x > ___y)
    )

    (defn #_"boolean" Numbers'gte-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x >= ___y)
    )

    (defn #_"boolean" Numbers'isPos-1l [#_"long" ___x]
        (ß ___x > 0)
    )

    (defn #_"boolean" Numbers'isNeg-1l [#_"long" ___x]
        (ß ___x < 0)
    )

    (defn #_"boolean" Numbers'isZero-1l [#_"long" ___x]
        (ß ___x == 0)
    )

    ;; overload resolution

    (defn #_"Number" Numbers'add-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'add-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'add-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'add-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'addP-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'addP-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'addP-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'addP-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'add-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'add-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'add-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'add-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'add-2dl [#_"double" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'add-2ld [#_"long" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'addP-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'addP-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'addP-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'addP-2dl [#_"double" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2ld [#_"long" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"Number" Numbers'minus-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'minus-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'minus-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'minus-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'minusP-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'minusP-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'minusP-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'minusP-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'minus-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'minus-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'minus-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'minus-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'minus-2dl [#_"double" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minus-2ld [#_"long" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'minus-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'minusP-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'minus-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'minusP-2dl [#_"double" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2ld [#_"long" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"Number" Numbers'multiply-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'multiply-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'multiply-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'multiply-2oo ___x, (cast Object ___y))
    )

    (defn #_"Number" Numbers'multiplyP-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'multiplyP-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'multiplyP-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'multiplyP-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'multiply-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'multiply-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'multiply-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'multiply-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'multiply-2dl [#_"double" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiply-2ld [#_"long" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2do [#_"double" ___x, #_"Object" ___y]
        (Numbers'multiplyP-2dd ___x, (.doubleValue (cast Number ___y)))
    )

    (defn #_"double" Numbers'multiplyP-2od [#_"Object" ___x, #_"double" ___y]
        (Numbers'multiplyP-2dd (.doubleValue (cast Number ___x)), ___y)
    )

    (defn #_"double" Numbers'multiplyP-2dl [#_"double" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2ld [#_"long" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"Number" Numbers'divide-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'divide-2oo (cast Object ___x), ___y)
    )

    (defn #_"Number" Numbers'divide-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'divide-2oo ___x, (cast Object ___y))
    )

    (defn #_"double" Numbers'divide-2do [#_"double" ___x, #_"Object" ___y]
        (ß ___x / (cast Number ___y).doubleValue())
    )

    (defn #_"double" Numbers'divide-2od [#_"Object" ___x, #_"double" ___y]
        (ß (cast Number ___x).doubleValue() / ___y)
    )

    (defn #_"double" Numbers'divide-2dl [#_"double" ___x, #_"long" ___y]
        (/ ___x ___y)
    )

    (defn #_"double" Numbers'divide-2ld [#_"long" ___x, #_"double" ___y]
        (/ ___x ___y)
    )

    (defn #_"Number" Numbers'divide-2ll [#_"long" ___x, #_"long" ___y]
        (Numbers'divide-2oo (cast Number ___x), (cast Number ___y))
    )

    (defn #_"boolean" Numbers'lt-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'lt-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'lt-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'lt-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'lt-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x < (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'lt-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() < ___y))
    )

    (defn #_"boolean" Numbers'lt-2dl [#_"double" ___x, #_"long" ___y]
        (ß ___x < ___y)
    )

    (defn #_"boolean" Numbers'lt-2ld [#_"long" ___x, #_"double" ___y]
        (ß ___x < ___y)
    )

    (defn #_"boolean" Numbers'lte-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'lte-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'lte-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'lte-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'lte-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x <= (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'lte-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() <= ___y))
    )

    (defn #_"boolean" Numbers'lte-2dl [#_"double" ___x, #_"long" ___y]
        (ß ___x <= ___y)
    )

    (defn #_"boolean" Numbers'lte-2ld [#_"long" ___x, #_"double" ___y]
        (ß ___x <= ___y)
    )

    (defn #_"boolean" Numbers'gt-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'gt-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'gt-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'gt-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'gt-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x > (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'gt-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() > ___y))
    )

    (defn #_"boolean" Numbers'gt-2dl [#_"double" ___x, #_"long" ___y]
        (ß ___x > ___y)
    )

    (defn #_"boolean" Numbers'gt-2ld [#_"long" ___x, #_"double" ___y]
        (ß ___x > ___y)
    )

    (defn #_"boolean" Numbers'gte-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'gte-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'gte-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'gte-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'gte-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x >= (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'gte-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() >= ___y))
    )

    (defn #_"boolean" Numbers'gte-2dl [#_"double" ___x, #_"long" ___y]
        (ß ___x >= ___y)
    )

    (defn #_"boolean" Numbers'gte-2ld [#_"long" ___x, #_"double" ___y]
        (ß ___x >= ___y)
    )

    (defn #_"boolean" Numbers'equiv-2lo [#_"long" ___x, #_"Object" ___y]
        (Numbers'equiv-2oo (cast Object ___x), ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ol [#_"Object" ___x, #_"long" ___y]
        (Numbers'equiv-2oo ___x, (cast Object ___y))
    )

    (defn #_"boolean" Numbers'equiv-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x == (cast Number ___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'equiv-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((cast Number ___x).doubleValue() == ___y))
    )

    (defn #_"boolean" Numbers'equiv-2dl [#_"double" ___x, #_"long" ___y]
        (ß ___x == ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ld [#_"long" ___x, #_"double" ___y]
        (ß ___x == ___y)
    )

    (defn #_"boolean" Numbers'isNaN [#_"Object" ___x]
        (ß (___x instanceof Double) && (cast Double ___x).isNaN() || (___x instanceof Float) && (cast Float ___x).isNaN())
    )

    (defn #_"double" Numbers'max-2dd [#_"double" ___x, #_"double" ___y]
        (Math/max ___x, ___y)
    )

    (defn #_"Object" Numbers'max-2dl [#_"double" ___x, #_"long" ___y]
        (when (Double/isNaN ___x)
            (§ return ___x)
        )
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2do [#_"double" ___x, #_"Object" ___y]
        (cond (Double/isNaN ___x)
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x > (cast Number ___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2ld [#_"long" ___x, #_"double" ___y]
        (when (Double/isNaN ___y)
            (§ return ___y)
        )
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"long" Numbers'max-2ll [#_"long" ___x, #_"long" ___y]
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2lo [#_"long" ___x, #_"Object" ___y]
        (when (ß isNaN(___y))
            (§ return ___y)
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2ol [#_"Object" ___x, #_"long" ___y]
        (when (ß isNaN(___x))
            (§ return ___x)
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2od [#_"Object" ___x, #_"double" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (Double/isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß (cast Number ___x).doubleValue() > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"double" Numbers'min-2dd [#_"double" ___x, #_"double" ___y]
        (Math/min ___x, ___y)
    )

    (defn #_"Object" Numbers'min-2dl [#_"double" ___x, #_"long" ___y]
        (when (Double/isNaN ___x)
            (§ return ___x)
        )
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2do [#_"double" ___x, #_"Object" ___y]
        (cond (Double/isNaN ___x)
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x < (cast Number ___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2ld [#_"long" ___x, #_"double" ___y]
        (when (Double/isNaN ___y)
            (§ return ___y)
        )
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"long" Numbers'min-2ll [#_"long" ___x, #_"long" ___y]
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2lo [#_"long" ___x, #_"Object" ___y]
        (when (ß isNaN(___y))
            (§ return ___y)
        )
        (if (Numbers'lt-2lo ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2ol [#_"Object" ___x, #_"long" ___y]
        (when (ß isNaN(___x))
            (§ return ___x)
        )
        (if (Numbers'lt-2ol ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2od [#_"Object" ___x, #_"double" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (Double/isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß (cast Number ___x).doubleValue() < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (Numbers'lt-2oo ___x, ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (defn- #_"Obj" Obj'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"Obj" Obj'new-1 [#_"IPersistentMap" ___meta]
        (let [this (Obj'init)]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    (defn #_"Obj" Obj'new-0 []
        (let [this (Obj'init)]
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Obj" this]
        (:_meta this)
    )

    #_abstract
    (§ defn #_"Obj" (§ method withMeta) [#_"Obj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

(class-ns MSeq (§ extends ASeq) (§ implements Counted)
    (defn- #_"MSeq" MSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"MSeq" MSeq'new-2 [#_"Object[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new) (MSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"MSeq" MSeq'new-3 [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (MSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"MSeq" this]
        (ß MapEntry'create((:array this)[(:i this)], (:array this)[(:i this) + 1]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"MSeq" this]
        (when (ß (:i this) + 2 < (:array this).length)
            (§ return (ß MSeq'new-2((:array this), (:i this) + 2)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"MSeq" this]
        (ß ((:array this).length - (:i this)) / 2)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"MSeq" this, #_"IPersistentMap" ___meta]
        (MSeq'new-3 ___meta, (:array this), (:i this))
    )
)

(class-ns MIter (§ implements Iterator)
    (defn- #_"MIter" MIter'init []
        (hash-map
            #_"IFn" :f nil
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    ;; for iterator
    (defn #_"MIter" MIter'new-2 [#_"Object[]" ___array, #_"IFn" ___f]
        (MIter'new-3 ___array, -2, ___f)
    )

    ;; for entryAt
    (defn #_"MIter" MIter'new-3 [#_"Object[]" ___array, #_"int" ___i, #_"IFn" ___f]
        (let [this (MIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"MIter" this]
        (ß ((:i this) < (:array this).length - 2))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"MIter" this]
        (try
            (§ ass (:i this) (+ (:i this) 2))
            (ß (:f this).invoke((:array this)[(:i this)], (:array this)[(:i this) + 1]))
            (catch IndexOutOfBoundsException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"MIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransientArrayMap (§ extends ATransientMap)
    (defn- #_"TransientArrayMap" TransientArrayMap'init []
        (hash-map
            #_volatile
            #_"int" :len 0
            #_"Object[]" :array nil
            #_volatile
            #_"Thread" :owner nil
        )
    )

    (defn #_"TransientArrayMap" TransientArrayMap'new [#_"Object[]" ___array]
        (let [this (merge (ATransientMap'new) (TransientArrayMap'init))]
            (§ ass (:owner this) (ß Thread/currentThread()))
            (§ ass (:array this) (make-array Object (ß Math/max(PersistentArrayMap'HASHTABLE_THRESHOLD, ___array.length))))
            (ß System/arraycopy(___array, 0, (:array this), 0, ___array.length))
            (§ ass (:len this) (ß ___array.length))
            this
        )
    )

    #_method
    (§ defn- #_"int" (§ method indexOf) [#_"TransientArrayMap" this, #_"Object" ___key]
        (loop-when-recur [#_"int" ___i 0] (< ___i (:len this)) [(+ ___i 2)]
            (when (ß equalKey((:array this)[___i], ___key))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (cond (ß ___i >= 0) ;; already have key,
                (do
                    (when (ß (:array this)[___i + 1] != ___val) ;; no change, no op
                        (§ ass (ß (:array this)[___i + 1]) ___val)
                    )
                )
                :else ;; didn't have key, grow
                (do
                    (when (ß (:len this) >= (:array this).length)
                        (§ return (ß PersistentHashMap'create-1a((:array this)).asTransient().assoc(___key, ___val)))
                    )
                    (§ ass (ß (:array this)[(:len this)]) ___key)
                    (§ ass (:len this) (+ (:len this) 1))
                    (§ ass (ß (:array this)[(:len this)]) ___val)
                    (§ ass (:len this) (+ (:len this) 1))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"TransientArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (ß ___i >= 0) ;; have key, will remove
                (when (ß (:len this) >= 2)
                    (§ ass (ß (:array this)[___i]) (ß (:array this)[(:len this) - 2]))
                    (§ ass (ß (:array this)[___i + 1]) (ß (:array this)[(:len this) - 1]))
                )
                (§ ass (:len this) (- (:len this) 2))
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method doValAt) [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (ß ___i >= 0)
                (§ return (ß (:array this)[___i + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"int" (§ method doCount) [#_"TransientArrayMap" this]
        (/ (:len this) 2)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"TransientArrayMap" this]
        (.ensureEditable this)
        (§ ass (:owner this) nil)
        (let [#_"Object[]" ___a (make-array Object (:len this))]
            (System/arraycopy (:array this), 0, ___a, 0, (:len this))
            (PersistentArrayMap'new-1 ___a)
        )
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientArrayMap" this]
        (when (nil? (:owner this))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap'new-0))
    (def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentArrayMap'EMPTY)]
            (doseq [#_"Object" ___o (.entrySet ___other)]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (.persistent ___ret)
        )
    )

    (defn- #_"PersistentArrayMap" PersistentArrayMap'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IPersistentMap" :_meta nil
        )
    )

    #_protected
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-0 []
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:array this) (make-array Object 0))
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"PersistentArrayMap" (§ method withMeta) [#_"PersistentArrayMap" this, #_"IPersistentMap" ___meta]
        (PersistentArrayMap'new-2 ___meta, (:array this))
    )

    #_method
    (§ defn #_"PersistentArrayMap" (§ method create) [#_"PersistentArrayMap" this, #_"Object..." ___init]
        (ß PersistentArrayMap'new-2((.meta this), ___init))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method createHT) [#_"PersistentArrayMap" this, #_"Object[]" ___init]
        (ß PersistentHashMap'create-2((.meta this), ___init))
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
            (loop-when-recur [#_"int" ___j (+ ___i 2)] (ß ___j < ___init.length) [(+ ___j 2)]
                (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___init[___i]))))
                )
            )
        )
        (PersistentArrayMap'new-1 ___init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" ___init]
        (when (ß (___init.length & 1) == 1)
            (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (ß ___init[___init.length - 1]) ]))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" ___n 0]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                (let [#_"boolean" ___duplicateKey false]
                    (loop-when-recur [#_"int" ___j 0] (< ___j ___i) [(+ ___j 2)]
                        (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                            (§ ass ___duplicateKey true)
                            (§ break )
                        )
                    )
                    (when (not ___duplicateKey)
                        (§ ass ___n (+ ___n 2))
                    )
                )
            )
            (when (ß ___n < ___init.length)
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key. To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" ___nodups (make-array Object ___n)]
                    (let [#_"int" ___m 0]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                            (let [#_"boolean" ___duplicateKey false]
                                (loop-when-recur [#_"int" ___j 0] (< ___j ___m) [(+ ___j 2)]
                                    (when (ß PersistentArrayMap'equalKey(___init[___i], ___nodups[___j]))
                                        (§ ass ___duplicateKey true)
                                        (§ break )
                                    )
                                )
                                (when (not ___duplicateKey)
                                    (§ let [#_"int" ___j]
                                        (loop-when-recur [___j (ß ___init.length - 2)] (ß ___j >= ___i) [(- ___j 2)]
                                            (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                                                (§ break )
                                            )
                                        )
                                        (§ ass (ß ___nodups[___m]) (ß ___init[___i]))
                                        (§ ass (ß ___nodups[___m + 1]) (ß ___init[___j + 1]))
                                        (§ ass ___m (+ ___m 2))
                                    )
                                )
                            )
                        )
                        (when (ß ___m != ___n)
                            (throw (IllegalArgumentException. (str "Internal error: m=" ___m)))
                        )
                        (§ ass ___init ___nodups)
                    )
                )
            )
            (PersistentArrayMap'new-1 ___init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-1 [#_"Object[]" ___init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:array this) ___init)
            (§ ass (:_meta this) nil)
            this
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-2 [#_"IPersistentMap" ___meta, #_"Object[]" ___init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:array this) ___init)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentArrayMap" this]
        (ß (:array this).length / 2)
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (ß (this.indexOf(___key) >= 0))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (ß ___i >= 0)
                (§ return (ß (IMapEntry) MapEntry'create((:array this)[___i], (:array this)[___i + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assocEx) [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (§ let [#_"Object[]" ___newArray]
                (cond (ß ___i >= 0)
                    (do
                        (throw (Util'runtimeException-1 "Key already present"))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß (:array this).length > PersistentArrayMap'HASHTABLE_THRESHOLD)
                            (§ return (ß this.createHT((:array this)).assocEx(___key, ___val)))
                        )
                        (§ ass ___newArray (make-array Object (ß (:array this).length + 2)))
                        (when (ß (:array this).length > 0)
                            (ß System/arraycopy((:array this), 0, ___newArray, 2, (:array this).length))
                        )
                        (§ ass (ß ___newArray[0]) ___key)
                        (§ ass (ß ___newArray[1]) ___val)
                    )
                )
                (.create this, ___newArray)
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assoc) [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (§ let [#_"Object[]" ___newArray]
                (cond (ß ___i >= 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß (:array this)[___i + 1] == ___val) ;; no change, no op
                            (§ return this)
                        )
                        (§ ass ___newArray (.clone (:array this)))
                        (§ ass (ß ___newArray[___i + 1]) ___val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß (:array this).length > PersistentArrayMap'HASHTABLE_THRESHOLD)
                            (§ return (ß this.createHT((:array this)).assoc(___key, ___val)))
                        )
                        (§ ass ___newArray (make-array Object (ß (:array this).length + 2)))
                        (when (ß (:array this).length > 0)
                            (ß System/arraycopy((:array this), 0, ___newArray, 0, (:array this).length))
                        )
                        (§ ass (ß ___newArray[___newArray.length - 2]) ___key)
                        (§ ass (ß ___newArray[___newArray.length - 1]) ___val)
                    )
                )
                (.create this, ___newArray)
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method without) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (ß ___i >= 0) ;; have key, will remove
                (let [#_"int" ___newlen (ß (:array this).length - 2)]
                    (when (ß ___newlen == 0)
                        (§ return (.empty this))
                    )
                    (let [#_"Object[]" ___newArray (make-array Object ___newlen)]
                        (System/arraycopy (:array this), 0, ___newArray, 0, ___i)
                        (ß System/arraycopy((:array this), ___i + 2, ___newArray, ___i, ___newlen - ___i))
                        (§ return (.create this, ___newArray))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method empty) [#_"PersistentArrayMap" this]
        (ß (IPersistentMap) PersistentArrayMap'EMPTY.withMeta((.meta this)))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (.indexOf this, ___key)]
            (when (ß ___i >= 0)
                (§ return (ß (:array this)[___i + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"int" (§ method capacity) [#_"PersistentArrayMap" this]
        (count this)
    )

    #_method
    (§ defn- #_"int" (§ method indexOfObject) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"EquivPred" ___ep (Util'equivPred ___key)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:array this).length) [(+ ___i 2)]
                (when (ß ___ep.equiv(___key, (:array this)[___i]))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn- #_"int" (§ method indexOf) [#_"PersistentArrayMap" this, #_"Object" ___key]
        (if (ß ___key instanceof Keyword)
            (do
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:array this).length) [(+ ___i 2)]
                    (when (ß ___key == (:array this)[___i])
                        (§ return ___i)
                    )
                )
                -1
            )
            (do
                (.indexOfObject this, ___key)
            )
        )
    )

    (defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 instanceof Keyword)
            (§ return (ß ___k1 == ___k2))
        )
        (Util'equiv-2oo ___k1, ___k2)
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_ENTRY)
    )

    #_method
    (§ defn #_"Iterator" (§ method keyIterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_KEY)
    )

    #_method
    (§ defn #_"Iterator" (§ method valIterator) [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_VAL)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentArrayMap" this]
        (when (ß (:array this).length > 0)
            (§ return (MSeq'new-2 (:array this), 0))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentArrayMap" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentArrayMap" this, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:array this).length) [(+ ___i 2)]
            (§ ass ___init (ß ___f.invoke(___init, (:array this)[___i], (:array this)[___i + 1])))
            (when (RT'isReduced ___init)
                (§ return (ß (cast' IDeref ___init).deref()))
            )
        )
        ___init
    )

    #_method
    (§ defn #_"ITransientMap" (§ method asTransient) [#_"PersistentArrayMap" this]
        (TransientArrayMap'new (:array this))
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns TransientHashMap (§ extends ATransientMap)
    (defn- #_"TransientHashMap" TransientHashMap'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_volatile
            #_"INode" :root nil
            #_volatile
            #_"int" :count 0
            #_volatile
            #_"boolean" :hasNull false
            #_volatile
            #_"Object" :nullValue nil
            #_"Box" :leafFlag (Box'new nil)
        )
    )

    (defn #_"TransientHashMap" TransientHashMap'new-1 [#_"PersistentHashMap" ___m]
        (TransientHashMap'new-5 (AtomicReference. (Thread/currentThread)), (:root ___m), (:count ___m), (:hasNull ___m), (:nullValue ___m))
    )

    (defn #_"TransientHashMap" TransientHashMap'new-5 [#_"AtomicReference<Thread>" ___edit, #_"INode" ___root, #_"int" ___count, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (ATransientMap'new) (TransientHashMap'init))]
            (§ ass (:edit this) ___edit)
            (§ ass (:root this) ___root)
            (§ ass (:count this) ___count)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doAssoc) [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß (:nullValue this) != ___val)
                (§ ass (:nullValue this) ___val)
            )
            (when (not (:hasNull this))
                (§ ass (:count this) (ß (:count this) + 1))
                (§ ass (:hasNull this) true)
            )
            (§ return this)
        )
        (§ ass (:val (:leafFlag this)) nil)
        (let [#_"INode" ___n (ß (((:root this) == nil) ? BitmapIndexedNode'EMPTY :or (:root this)).assoc((:edit this), 0, hash(___key), ___key, ___val, (:leafFlag this)))]
            (when (ß ___n != (:root this))
                (§ ass (:root this) ___n)
            )
            (when (ß (:val (:leafFlag this)) != nil)
                (§ ass (:count this) (ß (:count this) + 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" (§ method doWithout) [#_"TransientHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (when (not (:hasNull this))
                (§ return this)
            )
            (§ ass (:hasNull this) false)
            (§ ass (:nullValue this) nil)
            (§ ass (:count this) (ß (:count this) - 1))
            (§ return this)
        )
        (when (nil? (:root this))
            (§ return this)
        )
        (§ ass (:val (:leafFlag this)) nil)
        (let [#_"INode" ___n (ß (:root this).without((:edit this), 0, hash(___key), ___key, (:leafFlag this)))]
            (when (ß ___n != (:root this))
                (§ ass (:root this) ___n)
            )
            (when (ß (:val (:leafFlag this)) != nil)
                (§ ass (:count this) (ß (:count this) - 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method doPersistent) [#_"TransientHashMap" this]
        (ß (:edit this).set(nil))
        (PersistentHashMap'new-4 (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"Object" (§ method doValAt) [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (if (:hasNull this)
                (do
                    (§ return (:nullValue this))
                )
                (do
                    (§ return ___notFound)
                )
            )
        )
        (when (nil? (:root this))
            (§ return ___notFound)
        )
        (ß (:root this).find(0, hash(___key), ___key, ___notFound))
    )

    #_method
    (§ defn #_"int" (§ method doCount) [#_"TransientHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientHashMap" this]
        (when (ß (:edit this).get() == nil)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(§ defprotocol INode
    #_abstract
    (#_"INode" INode'''(§ method assoc-6) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''(§ method without-4) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" INode'''(§ method find-4) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"Object" INode'''(§ method find-5) [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (#_"ISeq" INode'''(§ method nodeSeq) [#_"INode" this])
    #_abstract
    (#_"INode" INode'''(§ method assoc-7) [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''(§ method without-6) [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf])
    #_abstract
    (#_"Object" INode'''(§ method kvreduce) [#_"INode" this, #_"IFn" ___f, #_"Object" ___init])
    #_abstract
    (#_"Object" INode'''(§ method fold) [#_"INode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin])
    ;; returns the result of (f [k v]) for each iterated element
    #_abstract
    (#_"Iterator" INode'''(§ method iterator) [#_"INode" this, #_"IFn" ___f])
)

(class-ns HSeq (§ extends ASeq)
    (defn #_"ISeq" HSeq'create-1 [#_"INode[]" ___nodes]
        (HSeq'create-4 nil, ___nodes, 0, nil)
    )

    (defn- #_"ISeq" HSeq'create-4 [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (HSeq'new ___meta, ___nodes, ___i, ___s))
        )
        (loop-when-recur [#_"int" ___j ___i] (ß ___j < ___nodes.length) [(inc ___j)]
            (when (ß ___nodes[___j] != nil)
                (let [#_"ISeq" ___ns (ß ___nodes[___j].nodeSeq())]
                    (when (some? ___ns)
                        (§ return (ß HSeq'new(___meta, ___nodes, ___j + 1, ___ns)))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"HSeq" HSeq'init []
        (hash-map
            #_"INode[]" :nodes nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn- #_"HSeq" HSeq'new [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (let [this (merge (ASeq'new ___meta) (HSeq'init))]
            (§ ass (:nodes this) ___nodes)
            (§ ass (:i this) ___i)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"HSeq" this, #_"IPersistentMap" ___meta]
        (HSeq'new ___meta, (:nodes this), (:i this), (:s this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"HSeq" this]
        (first (:s this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"HSeq" this]
        (ß HSeq'create-4(nil, (:nodes this), (:i this), (:s this).next()))
    )
)

(class-ns HIter (§ implements Iterator)
    (defn- #_"HIter" HIter'init []
        (hash-map
            #_"INode[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Iterator" :nestedIter nil
        )
    )

    (defn- #_"HIter" HIter'new [#_"INode[]" ___array, #_"IFn" ___f]
        (let [this (HIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"HIter" this]
        (while true
            (when (some? (:nestedIter this))
                (if (.hasNext (:nestedIter this))
                    (do
                        (§ return true)
                    )
                    (do
                        (§ ass (:nestedIter this) nil)
                    )
                )
            )

            (if (ß (:i this) < (:array this).length)
                (do
                    (let [#_"INode" ___node (ß (:array this)[(:i this)])]
                        (§ ass (:i this) (+ (:i this) 1))
                        (when (some? ___node)
                            (§ ass (:nestedIter this) (.iterator ___node, (:f this)))
                        )
                    )
                )
                (do
                    (§ return false)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"HIter" this]
        (if (.hasNext this)
            (do
                (next (:nestedIter this))
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"HIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ArrayNode (§ implements INode)
    (defn- #_"ArrayNode" ArrayNode'init []
        (hash-map
            #_"int" :count 0
            #_"INode[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"ArrayNode" ArrayNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"INode[]" ___array]
        (let [this (ArrayNode'init)]
            (§ ass (:array this) ___array)
            (§ ass (:edit this) ___edit)
            (§ ass (:count this) ___count)
            this
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return (ß ArrayNode'new(nil, (:count this) + 1, cloneAndSet((:array this), ___idx, BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))))
                )
                (let [#_"INode" ___n (ß ___node.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (ß ArrayNode'new(nil, (:count this), cloneAndSet((:array this), ___idx, ___n)))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___shift + 5, ___hash, ___key))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (if (nil? ___n)
                        (do
                            (when (ß (:count this) <= 8) ;; shrink
                                (§ return (.pack this, nil, ___idx))
                            )
                            (ß ArrayNode'new(nil, (:count this) - 1, cloneAndSet((:array this), ___idx, ___n)))
                        )
                        (do
                            (ß ArrayNode'new(nil, (:count this), cloneAndSet((:array this), ___idx, ___n)))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return nil)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return ___notFound)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key, ___notFound))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"ArrayNode" this]
        (HSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"ArrayNode" this, #_"IFn" ___f]
        (HIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"ArrayNode" this, #_"IFn" ___f, #_"Object" ___init]
        (doseq [#_"INode" ___node (:array this)]
            (when (some? ___node)
                (§ ass ___init (.kvreduce ___node, ___f, ___init))
                (when (RT'isReduced ___init)
                    (§ return ___init)
                )
            )
        )
        ___init
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"ArrayNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (let [#_"List<Callable>" ___tasks (ArrayList.)]
            (doseq [#_"INode" ___node (:array this)]
                (when (some? ___node)
                    (ß ___tasks.add(
                            (§ reify Callable()
                                #_method
                                (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                                    (.fold ___node, ___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin)
                                )
                            )
                        )
                    )
                )
            )

            (ArrayNode'foldTasks ___tasks, ___combinef, ___fjtask, ___fjfork, ___fjjoin)
        )
    )

    (defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" ___tasks, #_"IFn" ___combinef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (when (.isEmpty ___tasks)
            (§ return (.invoke ___combinef))
        )

        (when (ß (.size ___tasks) == 1)
            (let [#_"Object" ___ret nil]
                (try
                    (§ return (ß ___tasks.get(0).call()))
                    (catch Exception ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
        )

        (let [#_"List<Callable>" ___t1 (ß ___tasks.subList(0, (.size ___tasks) / 2))]
            (let [#_"List<Callable>" ___t2 (ß ___tasks.subList((.size ___tasks) / 2, (.size ___tasks)))]
                (let [#_"Object" ___forked
                        (ß ___fjfork.invoke(___fjtask.invoke(
                                (§ reify Callable()
                                    #_method
                                    (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                                        (ArrayNode'foldTasks ___t2, ___combinef, ___fjtask, ___fjfork, ___fjjoin)
                                    )
                                )
                            ))
                        )]
                    (ß ___combinef.invoke(ArrayNode'foldTasks(___t1, ___combinef, ___fjtask, ___fjfork, ___fjjoin), ___fjjoin.invoke(___forked)))
                )
            )
        )
    )

    #_method
    (§ defn- #_"ArrayNode" (§ method ensureEditable) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (ß ArrayNode'new(___edit, (:count this), (:array this).clone()))
    )

    #_method
    (§ defn- #_"ArrayNode" (§ method editAndSet) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"INode" ___n]
        (let [#_"ArrayNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (ß (:array ___editable)[___i]) ___n)
            ___editable
        )
    )

    #_method
    (§ defn- #_"INode" (§ method pack) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___idx]
        (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) - 1)))]
            (let [#_"int" ___j 1]
                (let [#_"int" ___bitmap 0]
                    (loop-when-recur [#_"int" ___i 0] (< ___i ___idx) [(inc ___i)]
                        (when (ß (:array this)[___i] != nil)
                            (§ ass (ß ___newArray[___j]) (ß (:array this)[___i]))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (+ ___j 2))
                        )
                    )
                    (loop-when-recur [#_"int" ___i (inc ___idx)] (ß ___i < (:array this).length) [(inc ___i)]
                        (when (ß (:array this)[___i] != nil)
                            (§ ass (ß ___newArray[___j]) (ß (:array this)[___i]))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (+ ___j 2))
                        )
                    )
                    (BitmapIndexedNode'new ___edit, ___bitmap, ___newArray)
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (let [#_"ArrayNode" ___editable (ß this.editAndSet(___edit, ___idx, BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))]
                        (§ ass (:count ___editable) (ß (:count ___editable) + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"INode" ___n (ß ___node.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (.editAndSet this, ___edit, ___idx, ___n)
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (when (nil? ___n)
                        (when (ß (:count this) <= 8) ;; shrink
                            (§ return (.pack this, ___edit, ___idx))
                        )
                        (let [#_"ArrayNode" ___editable (.editAndSet this, ___edit, ___idx, ___n)]
                            (§ ass (:count ___editable) (ß (:count ___editable) - 1))
                            (§ return ___editable)
                        )
                    )
                    (.editAndSet this, ___edit, ___idx, ___n)
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode (§ implements INode)
    (def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (ß BitmapIndexedNode'new(nil, 0, new Object[0])))

    (defn- #_"BitmapIndexedNode" BitmapIndexedNode'init []
        (hash-map
            #_"int" :bitmap 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"BitmapIndexedNode" BitmapIndexedNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___bitmap, #_"Object[]" ___array]
        (let [this (BitmapIndexedNode'init)]
            (§ ass (:bitmap this) ___bitmap)
            (§ ass (:array this) ___array)
            (§ ass (:edit this) ___edit)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"BitmapIndexedNode" this, #_"int" ___bit]
        (ß Integer/bitCount((:bitmap this) & (___bit - 1)))
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (let [#_"int" ___idx (.index this, ___bit)]
                (if (ß ((:bitmap this) & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                            (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß (cast' INode ___valOrNode).assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (ß ___n == ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___n))))
                                    )
                                )
                                (when (Util'equiv-2oo ___key, ___keyOrNull)
                                    (when (ß ___val == ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___val))))
                                )
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx, nil, 2 * ___idx + 1, createNode(___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val))))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
                            (if (ß ___n >= 16)
                                (do
                                    (let [#_"INode[]" ___nodes (§ typeless make-array INode 32)]
                                        (let [#_"int" ___jdx (ß mask(___hash, ___shift))]
                                            (§ ass (ß ___nodes[___jdx]) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [#_"int" ___i 0] (< ___i 32) [(inc ___i)]
                                                    (when (ß (((:bitmap this) >>> ___i) & 1) != 0)
                                                        (if (ß (:array this)[___j] == nil)
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß (INode) (:array this)[___j + 1]))
                                                            )
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, hash((:array this)[___j]), (:array this)[___j], (:array this)[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (+ ___j 2))
                                                    )
                                                )
                                                (ß ArrayNode'new(nil, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (make-array Object (ß 2 * (___n + 1)))]
                                        (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (ß ___newArray[2 * ___idx]) ___key)
                                        (§ ass (:val ___addedLeaf) ___addedLeaf)
                                        (§ ass (ß ___newArray[2 * ___idx + 1]) ___val)
                                        (ß System/arraycopy((:array this), 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (ß BitmapIndexedNode'new(nil, (:bitmap this) | ___bit, ___newArray))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return this)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß (cast' INode ___valOrNode).without(___shift + 5, ___hash, ___key))]
                                (when (ß ___n == ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___n))))
                                )
                                (when (ß (:bitmap this) == ___bit)
                                    (§ return nil)
                                )
                                (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this) :xor ___bit, removePair((:array this), ___idx))))
                            )
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            ;; TODO: collapse
                            (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this) :xor ___bit, removePair((:array this), ___idx))))
                        )
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return nil)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (§ return (ß (cast' INode ___valOrNode).find(___shift + 5, ___hash, ___key)))
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ return (ß (IMapEntry) MapEntry'create(___keyOrNull, ___valOrNode)))
                        )
                        nil
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return ___notFound)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (§ return (ß (cast' INode ___valOrNode).find(___shift + 5, ___hash, ___key, ___notFound)))
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ return ___valOrNode)
                        )
                        ___notFound
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"BitmapIndexedNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"BitmapIndexedNode" this, #_"IFn" ___f]
        (NodeIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"BitmapIndexedNode" this, #_"IFn" ___f, #_"Object" ___init]
        (NodeSeq'kvreduce (:array this), ___f, ___init)
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"BitmapIndexedNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce((:array this), ___reducef, (.invoke ___combinef)))
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method ensureEditable) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
            (let [#_"Object[]" ___newArray (make-array Object (if (<= 0 ___n) (* 2 (+ ___n 1)) 4))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, ___newArray, 0, (* 2 ___n))
                (BitmapIndexedNode'new ___edit, (:bitmap this), ___newArray)
            )
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndSet) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            ___editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndSet) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            (§ ass (ß (:array ___editable)[___j]) ___b)
            ___editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" (§ method editAndRemovePair) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___bit, #_"int" ___i]
        (when (ß (:bitmap this) == ___bit)
            (§ return nil)
        )
        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) :xor ___bit))
            (ß System/arraycopy((:array ___editable), 2 * (___i + 1), (:array ___editable), 2 * ___i, (:array ___editable).length - 2 * (___i + 1)))
            (§ ass (ß (:array ___editable)[(:array ___editable).length - 2]) nil)
            (§ ass (ß (:array ___editable)[(:array ___editable).length - 1]) nil)
            ___editable
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (let [#_"int" ___idx (.index this, ___bit)]
                (if (ß ((:bitmap this) & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                            (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß (cast' INode ___valOrNode).assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (ß ___n == ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß this.editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                    )
                                )
                                (when (Util'equiv-2oo ___key, ___keyOrNull)
                                    (when (ß ___val == ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß this.editAndSet(___edit, 2 * ___idx + 1, ___val)))
                                )
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (ß this.editAndSet(___edit, 2 * ___idx, nil, 2 * ___idx + 1, createNode(___edit, ___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val)))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
                            (when (ß ___n * 2 < (:array this).length)
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
                                    (ß System/arraycopy((:array ___editable), 2 * ___idx, (:array ___editable), 2 * (___idx + 1), 2 * (___n - ___idx)))
                                    (§ ass (ß (:array ___editable)[2 * ___idx]) ___key)
                                    (§ ass (ß (:array ___editable)[2 * ___idx + 1]) ___val)
                                    (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) | ___bit))
                                    (§ return ___editable)
                                )
                            )
                            (if (ß ___n >= 16)
                                (do
                                    (let [#_"INode[]" ___nodes (§ typeless make-array INode 32)]
                                        (let [#_"int" ___jdx (ß mask(___hash, ___shift))]
                                            (§ ass (ß ___nodes[___jdx]) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [#_"int" ___i 0] (< ___i 32) [(inc ___i)]
                                                    (when (ß (((:bitmap this) >>> ___i) & 1) != 0)
                                                        (if (ß (:array this)[___j] == nil)
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß (INode) (:array this)[___j + 1]))
                                                            )
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, hash((:array this)[___j]), (:array this)[___j], (:array this)[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (+ ___j 2))
                                                    )
                                                )
                                                (ß ArrayNode'new(___edit, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (make-array Object (ß 2 * (___n + 4)))]
                                        (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (ß ___newArray[2 * ___idx]) ___key)
                                        (§ ass (:val ___addedLeaf) ___addedLeaf)
                                        (§ ass (ß ___newArray[2 * ___idx + 1]) ___val)
                                        (ß System/arraycopy((:array this), 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (let [#_"BitmapIndexedNode" ___editable (.ensureEditable this, ___edit)]
                                            (§ ass (:array ___editable) ___newArray)
                                            (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) | ___bit))
                                            ___editable
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return this)
            )
            (let [#_"int" ___idx (.index this, ___bit)]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß (cast' INode ___valOrNode).without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                                (when (ß ___n == ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß this.editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                )
                                (when (ß (:bitmap this) == ___bit)
                                    (§ return nil)
                                )
                                (§ return (.editAndRemovePair this, ___edit, ___bit, ___idx))
                            )
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ ass (:val ___removedLeaf) ___removedLeaf)
                            ;; TODO: collapse
                            (§ return (.editAndRemovePair this, ___edit, ___bit, ___idx))
                        )
                        this
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode (§ implements INode)
    (defn- #_"HashCollisionNode" HashCollisionNode'init []
        (hash-map
            #_"int" :hash 0
            #_"int" :count 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"HashCollisionNode" HashCollisionNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___hash, #_"int" ___count, #_"Object..." ___array]
        (let [this (HashCollisionNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:hash this) ___hash)
            (§ ass (:count this) ___count)
            (§ ass (:array this) ___array)
            this
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == (:hash this))
            (let [#_"int" ___idx (.findIndex this, ___key)]
                (when (ß ___idx != -1)
                    (when (ß (:array this)[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß HashCollisionNode'new(nil, ___hash, (:count this), cloneAndSet((:array this), ___idx + 1, ___val))))
                )
                (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) + 1)))]
                    (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * (:count this)))
                    (§ ass (ß ___newArray[2 * (:count this)]) ___key)
                    (§ ass (ß ___newArray[2 * (:count this) + 1]) ___val)
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (§ return (ß HashCollisionNode'new((:edit this), ___hash, (:count this) + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß BitmapIndexedNode'new(nil, bitpos((:hash this), ___shift), (object-array [ nil, this ])).assoc(___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (ß ___idx == -1)
                (§ return this)
            )
            (when (ß (:count this) == 1)
                (§ return nil)
            )
            (ß HashCollisionNode'new(nil, ___hash, (:count this) - 1, removePair((:array this), ___idx / 2)))
        )
    )

    #_method
    (§ defn #_"IMapEntry" (§ method find) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (< ___idx 0)
                (§ return nil)
            )
            (when (ß Util'equiv-2oo(___key, (:array this)[___idx]))
                (§ return (ß (IMapEntry) MapEntry'create((:array this)[___idx], (:array this)[___idx + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method find) [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (< ___idx 0)
                (§ return ___notFound)
            )
            (when (ß Util'equiv-2oo(___key, (:array this)[___idx]))
                (§ return (ß (:array this)[___idx + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method nodeSeq) [#_"HashCollisionNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"HashCollisionNode" this, #_"IFn" ___f]
        (NodeIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"HashCollisionNode" this, #_"IFn" ___f, #_"Object" ___init]
        (NodeSeq'kvreduce (:array this), ___f, ___init)
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"HashCollisionNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce((:array this), ___reducef, (.invoke ___combinef)))
    )

    #_method
    (§ defn #_"int" (§ method findIndex) [#_"HashCollisionNode" this, #_"Object" ___key]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < 2 * (:count this)) [(+ ___i 2)]
            (when (ß Util'equiv-2oo(___key, (:array this)[___i]))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method ensureEditable) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) + 1)))] ;; make room for next assoc
            (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * (:count this)))
            (HashCollisionNode'new ___edit, (:hash this), (:count this), ___newArray)
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method ensureEditable) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"Object[]" ___array]
        (when (ß (:edit this) == ___edit)
            (§ ass (:array this) ___array)
            (§ ass (:count this) ___count)
            (§ return this)
        )
        (HashCollisionNode'new ___edit, (:hash this), ___count, ___array)
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method editAndSet) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"HashCollisionNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            ___editable
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" (§ method editAndSet) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"HashCollisionNode" ___editable (.ensureEditable this, ___edit)]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            (§ ass (ß (:array ___editable)[___j]) ___b)
            ___editable
        )
    )

    #_method
    (§ defn #_"INode" (§ method assoc) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == (:hash this))
            (let [#_"int" ___idx (.findIndex this, ___key)]
                (when (ß ___idx != -1)
                    (when (ß (:array this)[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß this.editAndSet(___edit, ___idx + 1, ___val)))
                )
                (when (ß (:array this).length > 2 * (:count this))
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (let [#_"HashCollisionNode" ___editable (ß this.editAndSet(___edit, 2 * (:count this), ___key, 2 * (:count this) + 1, ___val))]
                        (§ ass (:count ___editable) (ß (:count ___editable) + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"Object[]" ___newArray (make-array Object (ß (:array this).length + 2))]
                    (ß System/arraycopy((:array this), 0, ___newArray, 0, (:array this).length))
                    (§ ass (ß ___newArray[(:array this).length]) ___key)
                    (§ ass (ß ___newArray[(:array this).length + 1]) ___val)
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (§ return (ß this.ensureEditable(___edit, (:count this) + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß BitmapIndexedNode'new(___edit, bitpos((:hash this), ___shift), (object-array [ nil, this, nil, nil ])).assoc(___edit, ___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" (§ method without) [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (.findIndex this, ___key)]
            (when (ß ___idx == -1)
                (§ return this)
            )
            (§ ass (:val ___removedLeaf) ___removedLeaf)
            (when (ß (:count this) == 1)
                (§ return nil)
            )
            (let [#_"HashCollisionNode" ___editable (.ensureEditable this, ___edit)]
                (§ ass (ß (:array ___editable)[___idx]) (ß (:array ___editable)[2 * (:count this) - 2]))
                (§ ass (ß (:array ___editable)[___idx + 1]) (ß (:array ___editable)[2 * (:count this) - 1]))
                (§ ass (ß (:array ___editable)[2 * (:count this) - 2]) (§ ass (ß (:array ___editable)[2 * (:count this) - 1]) nil))
                (§ ass (:count ___editable) (ß (:count ___editable) - 1))
                ___editable
            )
        )
    )
)

(class-ns NodeIter (§ implements Iterator)
    (def- #_"Object" NodeIter'NULL (Object.))

    (defn- #_"NodeIter" NodeIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Object" :nextEntry NodeIter'NULL
            #_"Iterator" :nextIter nil
        )
    )

    (defn #_"NodeIter" NodeIter'new [#_"Object[]" ___array, #_"IFn" ___f]
        (let [this (NodeIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method advance) [#_"NodeIter" this]
        (while (ß (:i this) < (:array this).length)
            (let [#_"Object" ___key (ß (:array this)[(:i this)])]
                (let [#_"Object" ___nodeOrVal (ß (:array this)[(:i this) + 1])]
                    (§ ass (:i this) (+ (:i this) 2))
                    (cond (some? ___key)
                        (do
                            (§ ass (:nextEntry this) (ß (:f this).invoke(___key, ___nodeOrVal)))
                            (§ return true)
                        )
                        (some? ___nodeOrVal)
                        (do
                            (let [#_"Iterator" ___iter (ß (cast' INode ___nodeOrVal).iterator((:f this)))]
                                (when (ß ___iter != nil && (.hasNext ___iter))
                                    (§ ass (:nextIter this) ___iter)
                                    (§ return true)
                                )
                            )
                        )
                    )
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"NodeIter" this]
        (when (ß (:nextEntry this) != NodeIter'NULL || (:nextIter this) != nil)
            (§ return true)
        )
        (.advance this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"NodeIter" this]
        (let [#_"Object" ___ret (:nextEntry this)]
            (cond (ß ___ret != NodeIter'NULL)
                (do
                    (§ ass (:nextEntry this) NodeIter'NULL)
                    (§ return ___ret)
                )
                (some? (:nextIter this))
                (do
                    (§ ass ___ret (next (:nextIter this)))
                    (when (not (ß (:nextIter this).hasNext()))
                        (§ ass (:nextIter this) nil)
                    )
                    (§ return ___ret)
                )
                (.advance this)
                (do
                    (§ return (next this))
                )
            )
            (throw (NoSuchElementException.))
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"NodeIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns NodeSeq (§ extends ASeq)
    (defn- #_"NodeSeq" NodeSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-2 [#_"Object[]" ___array, #_"int" ___i]
        (NodeSeq'new-4 nil, ___array, ___i, nil)
    )

    (defn #_"ISeq" NodeSeq'create-1 [#_"Object[]" ___array]
        (NodeSeq'create-3 ___array, 0, nil)
    )

    (defn #_"Object" NodeSeq'kvreduce [#_"Object[]" ___array, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___array.length) [(+ ___i 2)]
            (if (ß ___array[___i] != nil)
                (do
                    (§ ass ___init (ß ___f.invoke(___init, ___array[___i], ___array[___i + 1])))
                )
                (do
                    (let [#_"INode" ___node (ß (INode) ___array[___i + 1])]
                        (when (some? ___node)
                            (§ ass ___init (.kvreduce ___node, ___f, ___init))
                        )
                    )
                )
            )
            (when (RT'isReduced ___init)
                (§ return ___init)
            )
        )
        ___init
    )

    (defn- #_"ISeq" NodeSeq'create-3 [#_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (NodeSeq'new-4 nil, ___array, ___i, ___s))
        )
        (loop-when-recur [#_"int" ___j ___i] (ß ___j < ___array.length) [(+ ___j 2)]
            (when (ß ___array[___j] != nil)
                (§ return (NodeSeq'new-4 nil, ___array, ___j, nil))
            )
            (let [#_"INode" ___node (ß (INode) ___array[___j + 1])]
                (when (some? ___node)
                    (let [#_"ISeq" ___nodeSeq (.nodeSeq ___node)]
                        (when (some? ___nodeSeq)
                            (§ return (ß NodeSeq'new-4(nil, ___array, ___j + 2, ___nodeSeq)))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"NodeSeq" NodeSeq'new-4 [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (let [this (merge (ASeq'new ___meta) (NodeSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"NodeSeq" this, #_"IPersistentMap" ___meta]
        (NodeSeq'new-4 ___meta, (:array this), (:i this), (:s this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"NodeSeq" this]
        (when (some? (:s this))
            (§ return (first (:s this)))
        )
        (ß MapEntry'create((:array this)[(:i this)], (:array this)[(:i this) + 1]))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"NodeSeq" this]
        (when (some? (:s this))
            (§ return (ß NodeSeq'create-3((:array this), (:i this), (:s this).next())))
        )
        (ß NodeSeq'create-3((:array this), (:i this) + 2, nil))
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" PersistentHashMap'EMPTY (PersistentHashMap'new-4 0, nil, false, nil))
    (def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (defn #_"IPersistentMap" PersistentHashMap'create-1m [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (doseq [#_"Object" ___o (.entrySet ___other)]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            (.persistent ___ret)
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-1a [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
            )
            (ß (PersistentHashMap) (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1a [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
                (when (ß (count ___ret) != ___i / 2 + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___init[___i]))))
                )
            )
            (ß (PersistentHashMap) (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1s [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [___items ___items] (some? ___items) [(next (next ___items))]
                (when (ß (next ___items) == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
            )
            (ß (PersistentHashMap) (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1s [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (.asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [___items ___items #_"int" ___i 0] (some? ___items) [(next (next ___items)) (inc ___i)]
                (when (ß (next ___items) == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
                (when (ß (count ___ret) != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (first ___items))))
                )
            )
            (ß (PersistentHashMap) (.persistent ___ret))
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-2 [#_"IPersistentMap" ___meta, #_"Object..." ___init]
        (ß this.create(___init).withMeta(___meta))
    )

    (defn- #_"PersistentHashMap" PersistentHashMap'init []
        (hash-map
            #_"int" :count 0
            #_"INode" :root nil
            #_"boolean" :hasNull false
            #_"Object" :nullValue nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-4 [#_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass (:count this) ___count)
            (§ ass (:root this) ___root)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            (§ ass (:_meta this) nil)
            this
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-5 [#_"IPersistentMap" ___meta, #_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:count this) ___count)
            (§ ass (:root this) ___root)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            this
        )
    )

    (defn #_"int" PersistentHashMap'hash [#_"Object" ___k]
        (Util'hasheq ___k)
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (:hasNull this))
        )
        (and (some? (:root this)) (ß (ß (:root this).find(0, hash(___key), ___key, PersistentHashMap'NOT_FOUND)) != PersistentHashMap'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (when (:hasNull this) (cast' IMapEntry (MapEntry'create nil, (:nullValue this)))))
        )
        (when (some? (:root this)) (ß (:root this).find(0, hash(___key), ___key)))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assoc) [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß (:hasNull this) && ___val == (:nullValue this))
                (§ return this)
            )
            (§ return (PersistentHashMap'new-5 (.meta this), (if (:hasNull this) (:count this) (inc (:count this))), (:root this), true, ___val))
        )
        (let [#_"Box" ___addedLeaf (Box'new nil)]
            (let [#_"INode" ___newroot (.assoc (or (:root this) BitmapIndexedNode'EMPTY), 0, (ß hash(___key)), ___key, ___val, ___addedLeaf)]
                (when (ß ___newroot == (:root this))
                    (§ return this)
                )
                (PersistentHashMap'new-5 (.meta this), (if (nil? (:val ___addedLeaf)) (:count this) (inc (:count this))), ___newroot, (:hasNull this), (:nullValue this))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (§ return (if (:hasNull this) (:nullValue this) ___notFound))
        )
        (if (some? (:root this)) (ß (:root this).find(0, hash(___key), ___key, ___notFound)) ___notFound)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentHashMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method assocEx) [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (.containsKey this, ___key)
            (throw (Util'runtimeException-1 "Key already present"))
        )
        (.assoc this, ___key, ___val)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method without) [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (if (:hasNull this) (PersistentHashMap'new-5 (.meta this), (dec (:count this)), (:root this), false, nil) this))
        )
        (when (nil? (:root this))
            (§ return this)
        )
        (let [#_"INode" ___newroot (ß (:root this).without(0, hash(___key), ___key))]
            (when (ß ___newroot == (:root this))
                (§ return this)
            )
            (ß PersistentHashMap'new-5((.meta this), (:count this) - 1, ___newroot, (:hasNull this), (:nullValue this)))
        )
    )

    (def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn- #_"Iterator" (§ method iterator) [#_"PersistentHashMap" this, #_"IFn" ___f]
        (let [#_"Iterator" ___rootIter (if (nil? (:root this)) PersistentHashMap'EMPTY_ITER (ß (:root this).iterator(___f)))]
            (if (:hasNull this)
                (do
                    (§ reify Iterator()
                        (§ init
                            (hash-map
                                #_"boolean" :seen false
                            )
                        )

                        #_method
                        (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                            (if (not (:seen this))
                                (do
                                    true
                                )
                                (do
                                    (.hasNext ___rootIter)
                                )
                            )
                        )

                        #_method
                        (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                            (if (not (:seen this))
                                (do
                                    (§ ass (:seen this) true)
                                    (.invoke ___f, nil, (:nullValue this))
                                )
                                (do
                                    (next ___rootIter)
                                )
                            )
                        )

                        #_method
                        (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
                (do
                    ___rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentHashMap" this]
        (ß this.iterator(APersistentMap'MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" (§ method keyIterator) [#_"PersistentHashMap" this]
        (ß this.iterator(APersistentMap'MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" (§ method valIterator) [#_"PersistentHashMap" this]
        (ß this.iterator(APersistentMap'MAKE_VAL))
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentHashMap" this, #_"IFn" ___f, #_"Object" ___init]
        (§ ass ___init (if (:hasNull this) (.invoke ___f, ___init, nil, (:nullValue this)) ___init))
        (when (RT'isReduced ___init)
            (§ return (ß (cast' IDeref ___init).deref()))
        )
        (when (some? (:root this))
            (§ ass ___init (ß (:root this).kvreduce(___f, ___init)))
            (if (RT'isReduced ___init)
                (do
                    (§ return (ß (cast' IDeref ___init).deref()))
                )
                (do
                    (§ return ___init)
                )
            )
        )
        ___init
    )

    #_method
    (§ defn #_"Object" (§ method fold) [#_"PersistentHashMap" this, #_"long" ___n, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjinvoke, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" ___top
                (§ reify Callable()
                    #_method
                    (§ defn #_"Object" (§ method call) [#_"Callable" this] #_(§ throws Exception)
                        (let [#_"Object" ___ret (.invoke ___combinef)]
                            (when (some? (:root this))
                                (§ ass ___ret (ß ___combinef.invoke(___ret, (:root this).fold(___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin))))
                            )
                            (if (:hasNull this) (ß ___combinef.invoke(___ret, ___reducef.invoke((.invoke ___combinef), nil, (:nullValue this)))) ___ret)
                        )
                    )
                )]
            (.invoke ___fjinvoke, ___top)
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentHashMap" this]
        (let [#_"ISeq" ___s (when (some? (:root this)) (ß (:root this).nodeSeq()))]
            (if (:hasNull this) (Cons'new-2 (MapEntry'create nil, (:nullValue this)), ___s) ___s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentHashMap" this]
        (ß PersistentHashMap'EMPTY.withMeta((.meta this)))
    )

    (defn #_"int" PersistentHashMap'mask [#_"int" ___hash, #_"int" ___shift]
        (ß (___hash >>> ___shift) & 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" (§ method withMeta) [#_"PersistentHashMap" this, #_"IPersistentMap" ___meta]
        (PersistentHashMap'new-5 ___meta, (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"TransientHashMap" (§ method asTransient) [#_"PersistentHashMap" this]
        (TransientHashMap'new-1 this)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentHashMap" this]
        (:_meta this)
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-3 [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a]
        (let [#_"Object[]" ___clone (.clone ___array)]
            (§ ass (ß ___clone[___i]) ___a)
            ___clone
        )
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-5 [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"Object[]" ___clone (.clone ___array)]
            (§ ass (ß ___clone[___i]) ___a)
            (§ ass (ß ___clone[___j]) ___b)
            ___clone
        )
    )

    (defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" ___array, #_"int" ___i]
        (let [#_"Object[]" ___newArray (make-array Object (ß ___array.length - 2))]
            (ß System/arraycopy(___array, 0, ___newArray, 0, 2 * ___i))
            (ß System/arraycopy(___array, 2 * (___i + 1), ___newArray, 2 * ___i, ___newArray.length - 2 * ___i))
            ___newArray
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-6 [#_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (ß hash(___key1))]
            (when (ß ___key1hash == ___key2hash)
                (§ return (ß HashCollisionNode'new(nil, ___key1hash, 2, (object-array [ ___key1, ___val1, ___key2, ___val2 ]))))
            )
            (let [#_"Box" ___addedLeaf (Box'new nil)]
                (let [#_"AtomicReference<Thread>" ___edit (AtomicReference.)]
                    (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
                )
            )
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-7 [#_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (ß hash(___key1))]
            (when (ß ___key1hash == ___key2hash)
                (§ return (ß HashCollisionNode'new(nil, ___key1hash, 2, (object-array [ ___key1, ___val1, ___key2, ___val2 ]))))
            )
            (let [#_"Box" ___addedLeaf (Box'new nil)]
                (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
            )
        )
    )

    (defn- #_"int" PersistentHashMap'bitpos [#_"int" ___hash, #_"int" ___shift]
        (ß 1 << mask(___hash, ___shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_stateless
(class-ns TransientHashSet (§ extends ATransientSet)
    (defn #_"TransientHashSet" TransientHashSet'new [#_"ITransientMap" ___impl]
        (ATransientSet'new ___impl)
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method persistent) [#_"TransientHashSet" this]
        (ß PersistentHashSet'new(nil, (:impl this).persistent()))
    )
)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" PersistentHashSet'EMPTY (PersistentHashSet'new nil, PersistentHashMap'EMPTY))

    (defn #_"PersistentHashSet" PersistentHashSet'create-1a [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(inc ___i)]
                (§ ass ___ret (ß (ITransientSet)___ret.conj(___init[___i])))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1l [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (doseq [#_"Object" ___key ___init]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___key)))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1s [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj((first ___items))))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1a [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(inc ___i)]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___init[___i])))
                (when (ß (count ___ret) != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___init[___i]))))
                )
            )
            (ß (PersistentHashSet) (.persistent ___ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1l [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (let [#_"int" ___i 0]
                (doseq [#_"Object" ___key ___init]
                    (§ ass ___ret (ß (ITransientSet) ___ret.conj(___key)))
                    (when (ß (count ___ret) != ___i + 1)
                        (throw (IllegalArgumentException. (str "Duplicate key: " ___key)))
                    )
                    (§ ass ___i (inc ___i))
                )
                (ß (PersistentHashSet) (.persistent ___ret))
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1s [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [___items ___items #_"int" ___i 0] (some? ___items) [(next ___items) (inc ___i)]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj((first ___items))))
                (when (ß (count ___ret) != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (first ___items))))
                )
            )
            (ß (PersistentHashSet) (.persistent ___ret))
        )
    )

    (defn- #_"PersistentHashSet" PersistentHashSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'new [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (merge (APersistentSet'new ___impl) (PersistentHashSet'init))]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method disjoin) [#_"PersistentHashSet" this, #_"Object" ___key]
        (when (.contains this, ___key)
            (§ return (ß PersistentHashSet'new((.meta this), (:impl this).without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method cons) [#_"PersistentHashSet" this, #_"Object" ___o]
        (when (.contains this, ___o)
            (§ return this)
        )
        (ß PersistentHashSet'new((.meta this), (:impl this).assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentHashSet" this]
        (ß PersistentHashSet'EMPTY.withMeta((.meta this)))
    )

    #_method
    (§ defn #_"PersistentHashSet" (§ method withMeta) [#_"PersistentHashSet" this, #_"IPersistentMap" ___meta]
        (PersistentHashSet'new ___meta, (:impl this))
    )

    #_method
    (§ defn #_"ITransientCollection" (§ method asTransient) [#_"PersistentHashSet" this]
        (ß TransientHashSet'new(((PersistentHashMap) (:impl this)).asTransient()))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentHashSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns Primordial (§ extends RestFn)
    (defn #_"Primordial" Primordial'new []
        (RestFn'new)
    )

    #_method
    (§ defn #_"int" (§ method getRequiredArity) [#_"Primordial" this]
        0
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"Primordial" this, #_"Object" ___args]
        (when (ß ___args instanceof ArraySeq)
            (let [#_"Object[]" ___argsarray (:array (cast' ArraySeq ___args))]
                (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
                    (loop-when-recur [#_"int" ___i (ß ___argsarray.length - 1)] (ß ___i >= (:i (cast' ArraySeq ___args))) [(dec ___i)]
                        (§ ass ___ret (ß (IPersistentList) ___ret.cons(___argsarray[___i])))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(next ___s)]
                (ß ___list.add((first ___s)))
            )
            (PersistentList'create ___list)
        )
    )

    (defn #_"Object" Primordial'invokeStatic [#_"ISeq" ___args]
        (when (ß ___args instanceof ArraySeq)
            (let [#_"Object[]" ___argsarray (:array (cast' ArraySeq ___args))]
                (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
                    (loop-when-recur [#_"int" ___i (ß ___argsarray.length - 1)] (ß ___i >= 0) [(dec ___i)]
                        (§ ass ___ret (ß (IPersistentList) ___ret.cons(___argsarray[___i])))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(next ___s)]
                (ß ___list.add((first ___s)))
            )
            (PersistentList'create ___list)
        )
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"Primordial" this, #_"IPersistentMap" ___meta]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Primordial" this]
        nil
    )
)

#_stateless
(class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
    (§ def #_"int" EmptyList'HASHEQ (Murmur3'hashOrdered Collections/EMPTY_LIST))

    (defn #_"EmptyList" EmptyList'new [#_"IPersistentMap" ___meta]
        (Obj'new ___meta)
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"EmptyList" this]
        1
    )

    #_method
    (defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'HASHEQ
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"EmptyList" this]
        "()"
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"EmptyList" this, #_"Object" ___o]
        (ß ((___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil))
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"EmptyList" this, #_"Object" ___o]
        (.equals this, ___o)
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method more) [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"PersistentList" (§ method cons) [#_"EmptyList" this, #_"Object" ___o]
        (ß PersistentList'new-4((.meta this), ___o, nil, 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"EmptyList" (§ method withMeta) [#_"EmptyList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (.meta this))
            (§ return (EmptyList'new ___meta))
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentList" (§ method pop) [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"EmptyList" this]
        true
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"EmptyList" this, #_"Object" ___o]
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"EmptyList" this]
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"EmptyList" this]
        RT'EMPTY_ARRAY
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"EmptyList" this, #_"Collection" ___collection]
        (.isEmpty ___collection)
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"EmptyList" this, #_"Object[]" ___objects]
        (when (ß ___objects.length > 0)
            (§ ass (ß ___objects[0]) nil)
        )
        ___objects
    )

    #_method
    (§ defn- #_"List" (§ method reify) [#_"EmptyList" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" (§ method subList) [#_"EmptyList" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (.reify this).subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"EmptyList" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" (§ method indexOf) [#_"EmptyList" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this) #_"int" ___i 0] (some? ___s) [(next ___s) (inc ___i)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" (§ method lastIndexOf) [#_"EmptyList" this, #_"Object" ___o]
        (ß (.reify this).lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"EmptyList" this]
        (.listIterator (.reify this))
    )

    #_method
    (§ defn #_"ListIterator" (§ method listIterator) [#_"EmptyList" this, #_"int" ___index]
        (ß (.reify this).listIterator(___index))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"EmptyList" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" (§ method add) [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"EmptyList" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ def #_"IFn" PersistentList'creator (Primordial'new))

    (§ def #_"EmptyList" PersistentList'EMPTY (EmptyList'new nil))

    (defn- #_"PersistentList" PersistentList'init []
        (hash-map
            #_"Object" :_first nil
            #_"IPersistentList" :_rest nil
            #_"int" :_count 0
        )
    )

    (defn #_"PersistentList" PersistentList'new-1 [#_"Object" ___first]
        (let [this (merge (ASeq'new) (PersistentList'init))]
            (§ ass (:_first this) ___first)
            (§ ass (:_rest this) nil)

            (§ ass (:_count this) 1)
            this
        )
    )

    (defn #_"PersistentList" PersistentList'new-4 [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"IPersistentList" ____rest, #_"int" ____count]
        (let [this (merge (ASeq'new ___meta) (PersistentList'init))]
            (§ ass (:_first this) ____first)
            (§ ass (:_rest this) ____rest)
            (§ ass (:_count this) ____count)
            this
        )
    )

    (defn #_"IPersistentList" PersistentList'create [#_"List" ___init]
        (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
            (loop-when-recur [#_"ListIterator" ___i (ß ___init.listIterator((.size ___init)))] (.hasPrevious ___i) [___i]
                (§ ass ___ret (ß (IPersistentList) ___ret.cons((.previous ___i))))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"PersistentList" this]
        (:_first this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"PersistentList" this]
        (when (ß (:_count this) == 1)
            (§ return nil)
        )
        (ß (ISeq) (:_rest this))
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"PersistentList" this]
        (first this)
    )

    #_method
    (§ defn #_"IPersistentList" (§ method pop) [#_"PersistentList" this]
        (when (nil? (:_rest this))
            (§ return (ß PersistentList'EMPTY.withMeta((:_meta this))))
        )
        (:_rest this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentList" this]
        (:_count this)
    )

    #_method
    (§ defn #_"PersistentList" (§ method cons) [#_"PersistentList" this, #_"Object" ___o]
        (ß PersistentList'new-4((.meta this), ___o, this, (:_count this) + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentList" this]
        (ß PersistentList'EMPTY.withMeta((.meta this)))
    )

    #_method
    (§ defn #_"PersistentList" (§ method withMeta) [#_"PersistentList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (:_meta this))
            (§ return (PersistentList'new-4 ___meta, (:_first this), (:_rest this), (:_count this)))
        )
        this
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentList" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (first this)]
            (loop-when-recur [#_"ISeq" ___s (next this)] (some? ___s) [(next ___s)]
                (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentList" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (first this)))]
            (loop-when-recur [#_"ISeq" ___s (next this)] (some? ___s) [(next ___s)]
                (when (RT'isReduced ___ret)
                    (§ return (ß (cast' IDeref ___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (first ___s))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß (cast' IDeref ___ret).deref()))
            )
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns QSeq (§ extends ASeq)
    (defn- #_"QSeq" QSeq'init []
        (hash-map
            #_"ISeq" :f nil
            #_"ISeq" :rseq nil
        )
    )

    (defn #_"QSeq" QSeq'new-2 [#_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (merge (ASeq'new) (QSeq'init))]
            (§ ass (:f this) ___f)
            (§ ass (:rseq this) ___rseq)
            this
        )
    )

    (defn #_"QSeq" QSeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (merge (ASeq'new ___meta) (QSeq'init))]
            (§ ass (:f this) ___f)
            (§ ass (:rseq this) ___rseq)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"QSeq" this]
        (first (:f this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"QSeq" this]
        (let [#_"ISeq" ___f1 (next (:f this))]
            (let [#_"ISeq" ___r1 (:rseq this)]
                (when (nil? ___f1)
                    (when (nil? (:rseq this))
                        (§ return nil)
                    )
                    (§ ass ___f1 (:rseq this))
                    (§ ass ___r1 nil)
                )
                (QSeq'new-2 ___f1, ___r1)
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"QSeq" this]
        (ß RT'count((:f this)) + RT'count((:rseq this)))
    )

    #_method
    (§ defn #_"QSeq" (§ method withMeta) [#_"QSeq" this, #_"IPersistentMap" ___meta]
        (QSeq'new-3 ___meta, (:f this), (:rseq this))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" PersistentQueue'EMPTY (PersistentQueue'new nil, 0, nil, nil))

    (defn- #_"PersistentQueue" PersistentQueue'init []
        (hash-map
            #_"int" :cnt 0
            #_"ISeq" :f nil
            #_"PersistentVector" :r nil
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"PersistentQueue" PersistentQueue'new [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"ISeq" ___f, #_"PersistentVector" ___r]
        (let [this (merge (Obj'new ___meta) (PersistentQueue'init))]
            (§ ass (:cnt this) ___cnt)
            (§ ass (:f this) ___f)
            (§ ass (:r this) ___r)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (not (ß ___obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (ß ___ms == nil || (not (ß Util'equiv-2oo((first ___s), (first ___ms)))))
                    (§ return false)
                )
            )
            (ß ___ms == nil)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (not (ß ___obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (.seq this) ___ms ___ms] (some? ___s) [(next ___s) (next ___ms)]
                (when (ß ___ms == nil || (not (ß Util'equals((first ___s), (first ___ms)))))
                    (§ return false)
                )
            )
            (ß ___ms == nil)
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"PersistentQueue" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (ß ___hash == 0)
                (§ ass ___hash 1)
                (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
                    (§ ass ___hash (+ (* 31 ___hash) (if (nil? (first ___s)) 0 (ß (first ___s).hashCode()))))
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"PersistentQueue" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (ß ___cached == 0)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashOrdered this)))
            )
            ___cached
        )
    )

    #_method
    (§ defn #_"Object" (§ method peek) [#_"PersistentQueue" this]
        (RT'first (:f this))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method pop) [#_"PersistentQueue" this]
        (when (nil? (:f this)) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" ___f1 (next (:f this))]
            (let [#_"PersistentVector" ___r1 (:r this)]
                (when (nil? ___f1)
                    (§ ass ___f1 (RT'seq (:r this)))
                    (§ ass ___r1 nil)
                )
                (ß PersistentQueue'new((.meta this), (:cnt this) - 1, ___f1, ___r1))
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentQueue" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentQueue" this]
        (when (nil? (:f this))
            (§ return nil)
        )
        (ß QSeq'new-2((:f this), RT'seq((:r this))))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method cons) [#_"PersistentQueue" this, #_"Object" ___o]
        (if (nil? (:f this)) ;; empty
            (do
                (ß PersistentQueue'new((.meta this), (:cnt this) + 1, RT'list-1(___o), nil))
            )
            (do
                (ß PersistentQueue'new((.meta this), (:cnt this) + 1, (:f this), (((:r this) != nil) ? (:r this) :or PersistentVector'EMPTY).cons(___o)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentQueue" this]
        (ß PersistentQueue'EMPTY.withMeta((.meta this)))
    )

    #_method
    (§ defn #_"PersistentQueue" (§ method withMeta) [#_"PersistentQueue" this, #_"IPersistentMap" ___meta]
        (PersistentQueue'new ___meta, (:cnt this), (:f this), (:r this))
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"PersistentQueue" this]
        (ß RT'seqToArray((.seq this)))
    )

    #_method
    (§ defn #_"boolean" (§ method add) [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method addAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method retainAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method removeAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" (§ method containsAll) [#_"PersistentQueue" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (.contains this, ___o)
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" (§ method toArray) [#_"PersistentQueue" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray((.seq this), ___a))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"PersistentQueue" this]
        (count this)
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"PersistentQueue" this]
        (ß ((count this) == 0))
    )

    #_method
    (§ defn #_"boolean" (§ method contains) [#_"PersistentQueue" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (.seq this)] (some? ___s) [(next ___s)]
            (when (ß Util'equiv-2oo((first ___s), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"ISeq" :fseq (:f this)
                    #_"Iterator" :riter (when (some? (:r this)) (ß (:r this).iterator()))
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (ß (((:fseq this) != nil && (:fseq this).seq() != nil) || ((:riter this) != nil && (:riter this).hasNext())))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (cond (some? (:fseq this))
                    (do
                        (let [#_"Object" ___ret (first (:fseq this))]
                            (§ ass (:fseq this) (next (:fseq this)))
                            ___ret
                        )
                    )
                    (ß (:riter this) != nil && (:riter this).hasNext())
                    (do
                        (next (:riter this))
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

#_abstract
(class-ns TNode (§ extends AMapEntry)
    (defn- #_"TNode" TNode'init []
        (hash-map
            #_"Object" :key nil
        )
    )

    (defn #_"TNode" TNode'new [#_"Object" ___key]
        (let [this (merge (AMapEntry'new) (TNode'init))]
            (§ ass (:key this) ___key)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method key) [#_"TNode" this]
        (:key this)
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method getKey) [#_"TNode" this]
        (.key this)
    )

    #_method
    (§ defn #_"Object" (§ method getValue) [#_"TNode" this]
        (.val this)
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"TNode" this]
        nil
    )

    #_abstract
    (§ defn #_"TNode" (§ method addLeft) [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" (§ method addRight) [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" (§ method removeLeft) [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" (§ method removeRight) [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" (§ method blacken) [#_"TNode" this])
    #_abstract
    (§ defn #_"TNode" (§ method redden) [#_"TNode" this])

    #_method
    (§ defn #_"TNode" (§ method balanceLeft) [#_"TNode" this, #_"TNode" ___parent]
        (ß black((:key ___parent), (.val ___parent), this, (.right ___parent)))
    )

    #_method
    (§ defn #_"TNode" (§ method balanceRight) [#_"TNode" this, #_"TNode" ___parent]
        (ß black((:key ___parent), (.val ___parent), (.left ___parent), this))
    )

    #_abstract
    (§ defn #_"TNode" (§ method replace) [#_"TNode" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right])

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"TNode" this, #_"IFn" ___f, #_"Object" ___init]
        (when (ß (.left this) != nil)
            (§ ass ___init (ß (.left this).kvreduce(___f, ___init)))
            (when (RT'isReduced ___init)
                (§ return ___init)
            )
        )
        (§ ass ___init (ß ___f.invoke(___init, (.key this), (.val this))))
        (when (RT'isReduced ___init)
            (§ return ___init)
        )

        (when (ß (.right this) != nil)
            (§ ass ___init (ß (.right this).kvreduce(___f, ___init)))
        )
        ___init
    )
)

#_stateless
(class-ns Black (§ extends TNode)
    (defn #_"Black" Black'new [#_"Object" ___key]
        (TNode'new ___key)
    )

    #_method
    (§ defn #_"TNode" (§ method addLeft) [#_"Black" this, #_"TNode" ___ins]
        (.balanceLeft ___ins, this)
    )

    #_method
    (§ defn #_"TNode" (§ method addRight) [#_"Black" this, #_"TNode" ___ins]
        (.balanceRight ___ins, this)
    )

    #_method
    (§ defn #_"TNode" (§ method removeLeft) [#_"Black" this, #_"TNode" ___del]
        (ß balanceLeftDel((:key this), (.val this), ___del, (.right this)))
    )

    #_method
    (§ defn #_"TNode" (§ method removeRight) [#_"Black" this, #_"TNode" ___del]
        (ß balanceRightDel((:key this), (.val this), (.left this), ___del))
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"Black" this]
        this
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"Black" this]
        (Red'new (:key this))
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"Black" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (ß black(___key, ___val, ___left, ___right))
    )
)

(class-ns BlackVal (§ extends Black)
    (defn- #_"BlackVal" BlackVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackVal" BlackVal'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (Black'new ___key) (BlackVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BlackVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackVal" this]
        (RedVal'new (:key this), (:val this))
    )
)

(class-ns BlackBranch (§ extends Black)
    (defn- #_"BlackBranch" BlackBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"BlackBranch" BlackBranch'new [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (Black'new ___key) (BlackBranch'init))]
            (§ ass (:left this) ___left)
            (§ ass (:right this) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"BlackBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"BlackBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackBranch" this]
        (RedBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns BlackBranchVal (§ extends BlackBranch)
    (defn- #_"BlackBranchVal" BlackBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackBranchVal" BlackBranchVal'new [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (BlackBranch'new ___key, ___left, ___right) (BlackBranchVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"BlackBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"BlackBranchVal" this]
        (RedBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

#_stateless
(class-ns Red (§ extends TNode)
    (defn #_"Red" Red'new [#_"Object" ___key]
        (TNode'new ___key)
    )

    #_method
    (§ defn #_"TNode" (§ method addLeft) [#_"Red" this, #_"TNode" ___ins]
        (ß red((:key this), (.val this), ___ins, (.right this)))
    )

    #_method
    (§ defn #_"TNode" (§ method addRight) [#_"Red" this, #_"TNode" ___ins]
        (ß red((:key this), (.val this), (.left this), ___ins))
    )

    #_method
    (§ defn #_"TNode" (§ method removeLeft) [#_"Red" this, #_"TNode" ___del]
        (ß red((:key this), (.val this), ___del, (.right this)))
    )

    #_method
    (§ defn #_"TNode" (§ method removeRight) [#_"Red" this, #_"TNode" ___del]
        (ß red((:key this), (.val this), (.left this), ___del))
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"Red" this]
        (Black'new (:key this))
    )

    #_method
    (§ defn #_"TNode" (§ method redden) [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"Red" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (ß red(___key, ___val, ___left, ___right))
    )
)

(class-ns RedVal (§ extends Red)
    (defn- #_"RedVal" RedVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedVal" RedVal'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (Red'new ___key) (RedVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"RedVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedVal" this]
        (BlackVal'new (:key this), (:val this))
    )
)

(class-ns RedBranch (§ extends Red)
    (defn- #_"RedBranch" RedBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"RedBranch" RedBranch'new [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (Red'new ___key) (RedBranch'init))]
            (§ ass (:left this) ___left)
            (§ ass (:right this) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" (§ method left) [#_"RedBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" (§ method right) [#_"RedBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" (§ method balanceLeft) [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (ß (:left this) instanceof Red)
            (do
                (ß red((:key this), (.val this), (:left this).blacken(), black((:key ___parent), (.val ___parent), (:right this), (.right ___parent))))
            )
            (ß (:right this) instanceof Red)
            (do
                (ß red((:key (:right this)), (:right this).val(), black((:key this), (.val this), (:left this), (:right this).left()), black((:key ___parent), (.val ___parent), (:right this).right(), (.right ___parent))))
            )
            :else
            (do
                (.balanceLeft super, ___parent)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method balanceRight) [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (ß (:right this) instanceof Red)
            (do
                (ß red((:key this), (.val this), black((:key ___parent), (.val ___parent), (.left ___parent), (:left this)), (:right this).blacken()))
            )
            (ß (:left this) instanceof Red)
            (do
                (ß red((:key (:left this)), (:left this).val(), black((:key ___parent), (.val ___parent), (.left ___parent), (:left this).left()), black((:key this), (.val this), (:left this).right(), (:right this))))
            )
            :else
            (do
                (.balanceRight super, ___parent)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedBranch" this]
        (BlackBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns RedBranchVal (§ extends RedBranch)
    (defn- #_"RedBranchVal" RedBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedBranchVal" RedBranchVal'new [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (RedBranch'new ___key, ___left, ___right) (RedBranchVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method val) [#_"RedBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" (§ method blacken) [#_"RedBranchVal" this]
        (BlackBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns TSeq (§ extends ASeq)
    (defn- #_"TSeq" TSeq'init []
        (hash-map
            #_"ISeq" :stack nil
            #_"boolean" :asc false
            #_"int" :cnt 0
        )
    )

    (defn #_"TSeq" TSeq'new-2 [#_"ISeq" ___stack, #_"boolean" ___asc]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) -1)
            this
        )
    )

    (defn #_"TSeq" TSeq'new-3 [#_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) ___cnt)
            this
        )
    )

    (defn #_"TSeq" TSeq'new-4 [#_"IPersistentMap" ___meta, #_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (merge (ASeq'new ___meta) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) ___cnt)
            this
        )
    )

    (defn #_"TSeq" TSeq'create [#_"TNode" ___t, #_"boolean" ___asc, #_"int" ___cnt]
        (ß TSeq'new-3(TSeq'push(___t, nil, ___asc), ___asc, ___cnt))
    )

    (defn #_"ISeq" TSeq'push [#_"TNode" ___t, #_"ISeq" ___stack, #_"boolean" ___asc]
        (while (some? ___t)
            (§ ass ___stack (RT'cons ___t, ___stack))
            (§ ass ___t (if ___asc (.left ___t) (.right ___t)))
        )
        ___stack
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"TSeq" this]
        (first (:stack this))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"TSeq" this]
        (let [#_"TNode" ___t (ß (TNode) (:stack this).first())]
            (let [#_"ISeq" ___nextstack (TSeq'push (if (:asc this) (.right ___t) (.left ___t)), (.next (:stack this)), (:asc this))]
                (when (some? ___nextstack)
                    (§ return (ß TSeq'new-3(___nextstack, (:asc this), (:cnt this) - 1)))
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"TSeq" this]
        (when (< (:cnt this) 0)
            (§ return (count super))
        )
        (:cnt this)
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"TSeq" this, #_"IPersistentMap" ___meta]
        (TSeq'new-4 ___meta, (:stack this), (:asc this), (:cnt this))
    )
)

(class-ns NodeIterator (§ implements Iterator)
    (defn- #_"NodeIterator" NodeIterator'init []
        (hash-map
            #_"Stack" :stack (Stack.)
            #_"boolean" :asc false
        )
    )

    (defn #_"NodeIterator" NodeIterator'new [#_"TNode" ___t, #_"boolean" ___asc]
        (let [this (NodeIterator'init)]
            (§ ass (:asc this) ___asc)
            (.push this, ___t)
            this
        )
    )

    #_method
    (§ defn #_"void" (§ method push) [#_"NodeIterator" this, #_"TNode" ___t]
        (while (some? ___t)
            (ß (:stack this).push(___t))
            (§ ass ___t (if (:asc this) (.left ___t) (.right ___t)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"NodeIterator" this]
        (not (ß (:stack this).isEmpty()))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"NodeIterator" this]
        (try
            (let [#_"TNode" ___t (ß (TNode) (:stack this).pop())]
                (.push this, (if (:asc this) (.right ___t) (.left ___t)))
                ___t
            )
            (catch EmptyStackException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"NodeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns KeyIterator (§ implements Iterator)
    (defn- #_"KeyIterator" KeyIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"KeyIterator" KeyIterator'new [#_"NodeIterator" ___it]
        (let [this (KeyIterator'init)]
            (§ ass (:it this) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"KeyIterator" this]
        (.hasNext (:it this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"KeyIterator" this]
        (:key (cast' TNode (next (:it this))))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"KeyIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ValIterator (§ implements Iterator)
    (defn- #_"ValIterator" ValIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"ValIterator" ValIterator'new [#_"NodeIterator" ___it]
        (let [this (ValIterator'init)]
            (§ ass (:it this) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"ValIterator" this]
        (.hasNext (:it this))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"ValIterator" this]
        (ß ((TNode) (:it this).next()).val())
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"ValIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap'new-0))

    (defn #_"IPersistentMap" PersistentTreeMap'create-1m [#_"Map" ___other]
        (let [#_"IPersistentMap" ___ret PersistentTreeMap'EMPTY]
            (doseq [#_"Object" ___o (.entrySet ___other)]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc((.getKey ___e), (.getValue ___e))))
                )
            )
            ___ret
        )
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'init []
        (hash-map
            #_"Comparator" :comp nil
            #_"TNode" :tree nil
            #_"int" :_count 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-0 []
        (PersistentTreeMap'new-1 RT'DEFAULT_COMPARATOR)
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'new-1 [#_"Comparator" ___comp]
        (PersistentTreeMap'new-2 nil, ___comp)
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-2 [#_"IPersistentMap" ___meta, #_"Comparator" ___comp]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:comp this) ___comp)
            (§ ass (:_meta this) ___meta)
            (§ ass (:tree this) nil)
            (§ ass (:_count this) 0)
            this
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4m [#_"IPersistentMap" ___meta, #_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ____count]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:comp this) ___comp)
            (§ ass (:tree this) ___tree)
            (§ ass (:_count this) ____count)
            this
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method withMeta) [#_"PersistentTreeMap" this, #_"IPersistentMap" ___meta]
        (PersistentTreeMap'new-4m ___meta, (:comp this), (:tree this), (:_count this))
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-1s [#_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret PersistentTreeMap'EMPTY]
            (loop-when-recur [___items ___items] (some? ___items) [(next (next ___items))]
                (when (ß (next ___items) == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
            )
            (ß (PersistentTreeMap) ___ret)
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-2 [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret (PersistentTreeMap'new-1 ___comp)]
            (loop-when-recur [___items ___items] (some? ___items) [(next (next ___items))]
                (when (ß (next ___items) == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (object-array [ (first ___items) ]))))
                )
                (§ ass ___ret (ß ___ret.assoc((first ___items), RT'second(___items))))
            )
            (ß (PersistentTreeMap) ___ret)
        )
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (ß (this.entryAt(___key) != nil))
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (.equals super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (.equiv super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method assocEx) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (.add this, (:tree this), ___key, ___val, ___found)]
                (when (nil? ___t) ;; nil == already contains key
                    (throw (Util'runtimeException-1 "Key already present"))
                )
                (ß PersistentTreeMap'new-4c((:comp this), (.blacken ___t), (:_count this) + 1, (.meta this)))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method assoc) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (.add this, (:tree this), ___key, ___val, ___found)]
                (when (nil? ___t) ;; nil == already contains key
                    (let [#_"TNode" ___foundNode (ß (TNode) (:val ___found))]
                        (when (ß (.val ___foundNode) == ___val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß PersistentTreeMap'new-4c((:comp this), this.replace((:tree this), ___key, ___val), (:_count this), (.meta this))))
                    )
                )
                (ß PersistentTreeMap'new-4c((:comp this), (.blacken ___t), (:_count this) + 1, (.meta this)))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" (§ method without) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (.remove this, (:tree this), ___key, ___found)]
                (when (nil? ___t)
                    (when (ß (:val ___found) == nil) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß PersistentTreeMap'new-2((.meta this), (:comp this))))
                )
                (ß PersistentTreeMap'new-4c((:comp this), (.blacken ___t), (:_count this) - 1, (.meta this)))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeMap" this]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), true, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentTreeMap" this]
        (ß PersistentTreeMap'new-2((.meta this), (:comp this)))
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"PersistentTreeMap" this]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), false, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"Comparator" (§ method comparator) [#_"PersistentTreeMap" this]
        (:comp this)
    )

    #_method
    (§ defn #_"Object" (§ method entryKey) [#_"PersistentTreeMap" this, #_"Object" ___entry]
        (ß (cast' IMapEntry ___entry).key())
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeMap" this, #_"boolean" ___ascending]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), ___ascending, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method seqFrom) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"boolean" ___ascending]
        (when (> (:_count this) 0)
            (let [#_"ISeq" ___stack nil]
                (let [#_"TNode" ___t (:tree this)]
                    (while (some? ___t)
                        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
                            (cond (ß ___c == 0)
                                (do
                                    (§ ass ___stack (RT'cons ___t, ___stack))
                                    (§ return (TSeq'new-2 ___stack, ___ascending))
                                )
                                ___ascending
                                (do
                                    (if (< ___c 0)
                                        (do
                                            (§ ass ___stack (RT'cons ___t, ___stack))
                                            (§ ass ___t (.left ___t))
                                        )
                                        (do
                                            (§ ass ___t (.right ___t))
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (> ___c 0)
                                        (do
                                            (§ ass ___stack (RT'cons ___t, ___stack))
                                            (§ ass ___t (.right ___t))
                                        )
                                        (do
                                            (§ ass ___t (.left ___t))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (some? ___stack)
                        (§ return (TSeq'new-2 ___stack, ___ascending))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"NodeIterator" (§ method iterator) [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), true)
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentTreeMap" this, #_"IFn" ___f, #_"Object" ___init]
        (when (some? (:tree this))
            (§ ass ___init (ß (:tree this).kvreduce(___f, ___init)))
        )
        (when (RT'isReduced ___init)
            (§ ass ___init (ß (cast' IDeref ___init).deref()))
        )
        ___init
    )

    #_method
    (§ defn #_"NodeIterator" (§ method reverseIterator) [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), false)
    )

    #_method
    (§ defn #_"Iterator" (§ method keys) [#_"PersistentTreeMap" this]
        (ß this.keys((.iterator this)))
    )

    #_method
    (§ defn #_"Iterator" (§ method vals) [#_"PersistentTreeMap" this]
        (ß this.vals((.iterator this)))
    )

    #_method
    (§ defn #_"Iterator" (§ method keys) [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (KeyIterator'new ___it)
    )

    #_method
    (§ defn #_"Iterator" (§ method vals) [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (ValIterator'new ___it)
    )

    #_method
    (§ defn #_"Object" (§ method minKey) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (.min this)]
            (when (some? ___t) (:key ___t))
        )
    )

    #_method
    (§ defn #_"TNode" (§ method min) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (:tree this)]
            (when (some? ___t)
                (while (ß (.left ___t) != nil)
                    (§ ass ___t (.left ___t))
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"Object" (§ method maxKey) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (.max this)]
            (when (some? ___t) (:key ___t))
        )
    )

    #_method
    (§ defn #_"TNode" (§ method max) [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (:tree this)]
            (when (some? ___t)
                (while (ß (.right ___t) != nil)
                    (§ ass ___t (.right ___t))
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"int" (§ method depth) [#_"PersistentTreeMap" this]
        (.depth this, (:tree this))
    )

    #_method
    (§ defn #_"int" (§ method depth) [#_"PersistentTreeMap" this, #_"TNode" ___t]
        (when (nil? ___t)
            (§ return 0)
        )
        (ß 1 + Math/max(this.depth((.left ___t)), this.depth((.right ___t))))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"TNode" ___n (.entryAt this, ___key)]
            (if (some? ___n) (.val ___n) ___notFound)
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"int" (§ method capacity) [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"TNode" (§ method entryAt) [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"TNode" ___t (:tree this)]
            (while (some? ___t)
                (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
                    (cond (ß ___c == 0)
                        (do
                            (§ return ___t)
                        )
                        (< ___c 0)
                        (do
                            (§ ass ___t (.left ___t))
                        )
                        :else
                        (do
                            (§ ass ___t (.right ___t))
                        )
                    )
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"int" (§ method doCompare) [#_"PersistentTreeMap" this, #_"Object" ___k1, #_"Object" ___k2]
        (ß (:comp this).compare(___k1, ___k2))
    )

    #_method
    (§ defn #_"TNode" (§ method add) [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val, #_"Box" ___found]
        (when (nil? ___t)
            (when (nil? ___val)
                (§ return (Red'new ___key))
            )
            (§ return (RedVal'new ___key, ___val))
        )
        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
            (when (ß ___c == 0)
                (§ ass (:val ___found) ___t)
                (§ return nil)
            )
            (let [#_"TNode" ___ins (ß (___c < 0) ? (ß this.add((.left ___t), ___key, ___val, ___found)) :or (ß this.add((.right ___t), ___key, ___val, ___found)))]
                (when (nil? ___ins) ;; found below
                    (§ return nil)
                )
                (when (< ___c 0)
                    (§ return (.addLeft ___t, ___ins))
                )
                (.addRight ___t, ___ins)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method remove) [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Box" ___found]
        (when (nil? ___t)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
            (when (ß ___c == 0)
                (§ ass (:val ___found) ___t)
                (§ return (ß append((.left ___t), (.right ___t))))
            )
            (let [#_"TNode" ___del (ß (___c < 0) ? (ß this.remove((.left ___t), ___key, ___found)) :or (ß this.remove((.right ___t), ___key, ___found)))]
                (when (ß ___del == nil && (:val ___found) == nil) ;; not found below
                    (§ return nil)
                )
                (when (< ___c 0)
                    (if (ß (.left ___t) instanceof Black)
                        (do
                            (§ return (ß balanceLeftDel((:key ___t), (.val ___t), ___del, (.right ___t))))
                        )
                        (do
                            (§ return (ß red((:key ___t), (.val ___t), ___del, (.right ___t))))
                        )
                    )
                )
                (when (ß (.right ___t) instanceof Black)
                    (§ return (ß balanceRightDel((:key ___t), (.val ___t), (.left ___t), ___del)))
                )
                (ß red((:key ___t), (.val ___t), (.left ___t), ___del))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'append [#_"TNode" ___left, #_"TNode" ___right]
        (cond (nil? ___left)
            (do
                ___right
            )
            (nil? ___right)
            (do
                ___left
            )
            (ß ___left instanceof Red)
            (do
                (if (ß ___right instanceof Red)
                    (do
                        (let [#_"TNode" ___app (ß append((.right ___left), (.left ___right)))]
                            (if (ß ___app instanceof Red)
                                (do
                                    (ß red((:key ___app), (.val ___app), red((:key ___left), (.val ___left), (.left ___left), (.left ___app)), red((:key ___right), (.val ___right), (.right ___app), (.right ___right))))
                                )
                                (do
                                    (ß red((:key ___left), (.val ___left), (.left ___left), red((:key ___right), (.val ___right), ___app, (.right ___right))))
                                )
                            )
                        )
                    )
                    (do
                        (ß red((:key ___left), (.val ___left), (.left ___left), append((.right ___left), ___right)))
                    )
                )
            )
            (ß ___right instanceof Red)
            (do
                (ß red((:key ___right), (.val ___right), append(___left, (.left ___right)), (.right ___right)))
            )
            :else ;; black/black
            (do
                (let [#_"TNode" ___app (ß append((.right ___left), (.left ___right)))]
                    (if (ß ___app instanceof Red)
                        (do
                            (ß red((:key ___app), (.val ___app), PersistentTreeMap'black((:key ___left), (.val ___left), (.left ___left), (.left ___app)), PersistentTreeMap'black((:key ___right), (.val ___right), (.right ___app), (.right ___right))))
                        )
                        (do
                            (ß balanceLeftDel((:key ___left), (.val ___left), (.left ___left), PersistentTreeMap'black((:key ___right), (.val ___right), ___app, (.right ___right))))
                        )
                    )
                )
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___del, #_"TNode" ___right]
        (cond (ß ___del instanceof Red)
            (do
                (ß red(___key, ___val, (.blacken ___del), ___right))
            )
            (ß ___right instanceof Black)
            (do
                (ß rightBalance(___key, ___val, ___del, (.redden ___right)))
            )
            (ß ___right instanceof Red && (.left ___right) instanceof Black)
            (do
                (ß red((:key (.left ___right)), (.left ___right).val(), PersistentTreeMap'black(___key, ___val, ___del, (.left ___right).left()), rightBalance((:key ___right), (.val ___right), (.left ___right).right(), (.right ___right).redden())))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___del]
        (cond (ß ___del instanceof Red)
            (do
                (ß red(___key, ___val, ___left, (.blacken ___del)))
            )
            (ß ___left instanceof Black)
            (do
                (ß leftBalance(___key, ___val, (.redden ___left), ___del))
            )
            (ß ___left instanceof Red && (.right ___left) instanceof Black)
            (do
                (ß red((:key (.right ___left)), (.right ___left).val(), leftBalance((:key ___left), (.val ___left), (.left ___left).redden(), (.right ___left).left()), PersistentTreeMap'black(___key, ___val, (.right ___left).right(), ___del)))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___ins, #_"TNode" ___right]
        (cond (ß ___ins instanceof Red && (.left ___ins) instanceof Red)
            (do
                (ß red((:key ___ins), (.val ___ins), (.left ___ins).blacken(), PersistentTreeMap'black(___key, ___val, (.right ___ins), ___right)))
            )
            (ß ___ins instanceof Red && (.right ___ins) instanceof Red)
            (do
                (ß red((:key (.right ___ins)), (.right ___ins).val(), PersistentTreeMap'black((:key ___ins), (.val ___ins), (.left ___ins), (.right ___ins).left()), PersistentTreeMap'black(___key, ___val, (.right ___ins).right(), ___right)))
            )
            :else
            (do
                (PersistentTreeMap'black ___key, ___val, ___ins, ___right)
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___ins]
        (cond (ß ___ins instanceof Red && (.right ___ins) instanceof Red)
            (do
                (ß red((:key ___ins), (.val ___ins), PersistentTreeMap'black(___key, ___val, ___left, (.left ___ins)), (.right ___ins).blacken()))
            )
            (ß ___ins instanceof Red && (.left ___ins) instanceof Red)
            (do
                (ß red((:key (.left ___ins)), (.left ___ins).val(), PersistentTreeMap'black(___key, ___val, ___left, (.left ___ins).left()), PersistentTreeMap'black((:key ___ins), (.val ___ins), (.left ___ins).right(), (.right ___ins))))
            )
            :else
            (do
                (PersistentTreeMap'black ___key, ___val, ___left, ___ins)
            )
        )
    )

    #_method
    (§ defn #_"TNode" (§ method replace) [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___c (.doCompare this, ___key, (:key ___t))]
            (ß ___t.replace((:key ___t), (___c == 0) ? ___val :or (.val ___t), (___c < 0) ? (ß this.replace((.left ___t), ___key, ___val)) :or (.left ___t), (___c > 0) ? (ß this.replace((.right ___t), ___key, ___val)) :or (.right ___t)))
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4c [#_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ___count, #_"IPersistentMap" ___meta]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:comp this) ___comp)
            (§ ass (:tree this) ___tree)
            (§ ass (:_count this) ___count)
            this
        )
    )

    (defn #_"Red" PersistentTreeMap'red [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (ß ___left == nil && ___right == nil)
            (when (nil? ___val)
                (§ return (Red'new ___key))
            )
            (§ return (RedVal'new ___key, ___val))
        )
        (when (nil? ___val)
            (§ return (RedBranch'new ___key, ___left, ___right))
        )
        (RedBranchVal'new ___key, ___val, ___left, ___right)
    )

    (defn #_"Black" PersistentTreeMap'black [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (ß ___left == nil && ___right == nil)
            (when (nil? ___val)
                (§ return (Black'new ___key))
            )
            (§ return (BlackVal'new ___key, ___val))
        )
        (when (nil? ___val)
            (§ return (BlackBranch'new ___key, ___left, ___right))
        )
        (BlackBranchVal'new ___key, ___val, ___left, ___right)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentTreeMap" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (PersistentTreeSet'new nil, PersistentTreeMap'EMPTY))

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-1 [#_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret PersistentTreeSet'EMPTY]
            (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                (§ ass ___ret (ß (PersistentTreeSet) ___ret.cons((first ___items))))
            )
            ___ret
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-2 [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret (ß PersistentTreeSet'new(nil, PersistentTreeMap'new-2(nil, ___comp)))]
            (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                (§ ass ___ret (ß (PersistentTreeSet) ___ret.cons((first ___items))))
            )
            ___ret
        )
    )

    (defn- #_"PersistentTreeSet" PersistentTreeSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'new [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (merge (APersistentSet'new ___impl) (PersistentTreeSet'init))]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (.equals super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equiv) [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (.equiv super, ___obj)
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method disjoin) [#_"PersistentTreeSet" this, #_"Object" ___key]
        (when (.contains this, ___key)
            (§ return (ß PersistentTreeSet'new((.meta this), (:impl this).without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" (§ method cons) [#_"PersistentTreeSet" this, #_"Object" ___o]
        (when (.contains this, ___o)
            (§ return this)
        )
        (ß PersistentTreeSet'new((.meta this), (:impl this).assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentTreeSet" this]
        (ß PersistentTreeSet'new((.meta this), (PersistentTreeMap)(:impl this).empty()))
    )

    #_method
    (§ defn #_"ISeq" (§ method rseq) [#_"PersistentTreeSet" this]
        (ß KeySeq'create(((Reversible) (:impl this)).rseq()))
    )

    #_method
    (§ defn #_"PersistentTreeSet" (§ method withMeta) [#_"PersistentTreeSet" this, #_"IPersistentMap" ___meta]
        (PersistentTreeSet'new ___meta, (:impl this))
    )

    #_method
    (§ defn #_"Comparator" (§ method comparator) [#_"PersistentTreeSet" this]
        (ß ((Sorted)(:impl this)).comparator())
    )

    #_method
    (§ defn #_"Object" (§ method entryKey) [#_"PersistentTreeSet" this, #_"Object" ___entry]
        ___entry
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentTreeSet" this, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (ß (PersistentTreeMap) (:impl this))]
            (ß RT'keys(___m.seq(___ascending)))
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method seqFrom) [#_"PersistentTreeSet" this, #_"Object" ___key, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (ß (PersistentTreeMap) (:impl this))]
            (ß RT'keys(___m.seqFrom(___key, ___ascending)))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentTreeSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns VNode
    (defn- #_"VNode" VNode'init []
        (hash-map
            #_transient
            #_"AtomicReference<Thread>" :edit nil
            #_"Object[]" :array nil
        )
    )

    (defn #_"VNode" VNode'new-2 [#_"AtomicReference<Thread>" ___edit, #_"Object[]" ___array]
        (let [this (VNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:array this) ___array)
            this
        )
    )

    (defn #_"VNode" VNode'new-1 [#_"AtomicReference<Thread>" ___edit]
        (let [this (VNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:array this) (make-array Object 32))
            this
        )
    )
)

(class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
    (defn- #_"ChunkedSeq" ChunkedSeq'init []
        (hash-map
            #_"PersistentVector" :vec nil
            #_"Object[]" :node nil
            #_"int" :i 0
            #_"int" :offset 0
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-3 [#_"PersistentVector" ___vec, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            (§ ass (:node this) (.arrayFor ___vec, ___i))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-5 [#_"IPersistentMap" ___meta, #_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new ___meta) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:node this) ___node)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-4 [#_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:node this) ___node)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            this
        )
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"ChunkedSeq" this]
        (ArrayChunk'new-2 (:node this), (:offset this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"ChunkedSeq" this]
        (when (ß (:i this) + (:node this).length < (:cnt (:vec this)))
            (§ return (ß ChunkedSeq'new-3((:vec this), (:i this) + (:node this).length, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"ChunkedSeq" this]
        (let [#_"ISeq" ___s (.chunkedNext this)]
            (when (nil? ___s)
                (§ return PersistentList'EMPTY)
            )
            ___s
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"ChunkedSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (ChunkedSeq'new-5 ___meta, (:vec this), (:node this), (:i this), (:offset this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"ChunkedSeq" this]
        (ß (:node this)[(:offset this)])
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"ChunkedSeq" this]
        (when (ß (:offset this) + 1 < (:node this).length)
            (§ return (ß ChunkedSeq'new-4((:vec this), (:node this), (:i this), (:offset this) + 1)))
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"ChunkedSeq" this]
        (ß (:cnt (:vec this)) - ((:i this) + (:offset this)))
    )
)

(class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
    (defn- #_"TransientVector" TransientVector'init []
        (hash-map
            #_volatile
            #_"int" :cnt 0
            #_volatile
            #_"int" :shift 0
            #_volatile
            #_"VNode" :root nil
            #_volatile
            #_"Object[]" :tail nil
        )
    )

    (defn #_"TransientVector" TransientVector'new-4 [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (AFn'new) (TransientVector'init))]
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    (defn #_"TransientVector" TransientVector'new-1 [#_"PersistentVector" ___v]
        (TransientVector'new-4 (:cnt ___v), (:shift ___v), (.editableRoot (:root ___v)), (.editableTail (:tail ___v)))
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"TransientVector" this]
        (.ensureEditable this)
        (:cnt this)
    )

    #_method
    (§ defn #_"VNode" (§ method ensureEditable) [#_"TransientVector" this, #_"VNode" ___node]
        (when (ß (:edit ___node) == (:edit (:root this)))
            (§ return ___node)
        )
        (ß VNode'new-2((:edit (:root this)), (:array ___node).clone()))
    )

    #_method
    (§ defn #_"void" (§ method ensureEditable) [#_"TransientVector" this]
        (when (ß (:edit (:root this)).get() == nil)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (defn #_"VNode" TransientVector'editableRoot [#_"VNode" ___node]
        (ß VNode'new-2(.new AtomicReference<Thread>(Thread/currentThread()), (:array ___node).clone()))
    )

    #_method
    (§ defn #_"PersistentVector" (§ method persistent) [#_"TransientVector" this]
        (.ensureEditable this)
        (ß (:edit (:root this)).set(nil))
        (let [#_"Object[]" ___trimmedTail (make-array Object (ß (:cnt this) - (.tailoff this)))]
            (ß System/arraycopy((:tail this), 0, ___trimmedTail, 0, ___trimmedTail.length))
            (PersistentVector'new-4 (:cnt this), (:shift this), (:root this), ___trimmedTail)
        )
    )

    (defn #_"Object[]" TransientVector'editableTail [#_"Object[]" ___tl]
        (let [#_"Object[]" ___ret (make-array Object 32)]
            (ß System/arraycopy(___tl, 0, ___ret, 0, ___tl.length))
            ___ret
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method conj) [#_"TransientVector" this, #_"Object" ___val]
        (.ensureEditable this)
        (let [#_"int" ___i (:cnt this)]
            ;; room in tail?
            (when (ß ___i - (.tailoff this) < 32)
                (§ ass (ß (:tail this)[___i & 0x01f]) ___val)
                (§ ass (:cnt this) (+ (:cnt this) 1))
                (§ return this)
            )
            ;; full tail, push into tree
            (§ let [#_"VNode" ___newroot]
                (let [#_"VNode" ___tailnode (ß VNode'new-2((:edit (:root this)), (:tail this)))]
                    (§ ass (:tail this) (make-array Object 32))
                    (§ ass (ß (:tail this)[0]) ___val)
                    (let [#_"int" ___newshift (:shift this)]
                        ;; overflow root?
                        (if (ß ((:cnt this) >>> 5) > (1 << (:shift this)))
                            (do
                                (§ ass ___newroot (VNode'new-1 (:edit (:root this))))
                                (§ ass (ß (:array ___newroot)[0]) (:root this))
                                (§ ass (ß (:array ___newroot)[1]) (ß newPath((:edit (:root this)), (:shift this), ___tailnode)))
                                (§ ass ___newshift (+ ___newshift 5))
                            )
                            (do
                                (§ ass ___newroot (.pushTail this, (:shift this), (:root this), ___tailnode))
                            )
                        )
                        (§ ass (:root this) ___newroot)
                        (§ ass (:shift this) ___newshift)
                        (§ ass (:cnt this) (+ (:cnt this) 1))
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method pushTail) [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (§ ass ___parent (.ensureEditable this, ___parent))
        (let [#_"int" ___subidx (ß (((:cnt this) - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret ___parent]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (ß ___level == 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (ß (VNode) (:array ___parent)[___subidx])]
                                (§ ass ___nodeToInsert (ß (some? ___child) ? (ß this.pushTail(___level - 5, ___child, ___tailnode)) :or newPath((:edit (:root this)), ___level - 5, ___tailnode)))
                            )
                        )
                    )
                    (§ ass (ß (:array ___ret)[___subidx]) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn- #_"int" (§ method tailoff) [#_"TransientVector" this]
        (when (< (:cnt this) 32)
            (§ return 0)
        )
        (ß (((:cnt this) - 1) >>> 5) << 5)
    )

    #_method
    (§ defn- #_"Object[]" (§ method arrayFor) [#_"TransientVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= (.tailoff this))
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß (VNode) (:array ___node)[(___i >>> ___level) & 0x01f]))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn- #_"Object[]" (§ method editableArrayFor) [#_"TransientVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= (.tailoff this))
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß this.ensureEditable((VNode) (:array ___node)[(___i >>> ___level) & 0x01f])))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TransientVector" this, #_"Object" ___key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (.ensureEditable this)
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß (cast Number ___key).intValue())]
                (when (ß ___i >= 0 && ___i < (:cnt this))
                    (§ return (.nth this, ___i))
                )
            )
        )
        ___notFound
    )

    (def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"TransientVector" this, #_"Object" ___key]
        (ß (this.valAt(___key, TransientVector'NOT_FOUND) != TransientVector'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" (§ method entryAt) [#_"TransientVector" this, #_"Object" ___key]
        (let [#_"Object" ___v (ß this.valAt(___key, TransientVector'NOT_FOUND))]
            (when (ß ___v != TransientVector'NOT_FOUND)
                (§ return (MapEntry'create ___key, ___v))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"TransientVector" this, #_"Object" ___arg1]
        ;; note - relies on ensureEditable in nth
        (when (Util'isInteger ___arg1)
            (§ return (ß this.nth((cast Number ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"TransientVector" this, #_"int" ___i]
        (.ensureEditable this)
        (let [#_"Object[]" ___node (.arrayFor this, ___i)]
            (ß ___node[___i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"TransientVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (count this))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"TransientVector" (§ method assocN) [#_"TransientVector" this, #_"int" ___i, #_"Object" ___val]
        (.ensureEditable this)
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= (.tailoff this))
                (§ ass (ß (:tail this)[___i & 0x01f]) ___val)
                (§ return this)
            )

            (§ ass (:root this) (.doAssoc this, (:shift this), (:root this), ___i, ___val))
            (§ return this)
        )
        (when (ß ___i == (:cnt this))
            (§ return (.conj this, ___val))
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"TransientVector" (§ method assoc) [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___val]
        ;; note - relies on ensureEditable in assocN
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß (cast Number ___key).intValue())]
                (§ return (.assocN this, ___i, ___val))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn- #_"VNode" (§ method doAssoc) [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (§ ass ___node (.ensureEditable this, ___node))
        (let [#_"VNode" ___ret ___node]
            (if (ß ___level == 0)
                (do
                    (§ ass (ß (:array ___ret)[___i & 0x01f]) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (ß (:array ___ret)[___subidx]) (ß this.doAssoc(___level - 5, (VNode) (:array ___node)[___subidx], ___i, ___val)))
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method pop) [#_"TransientVector" this]
        (.ensureEditable this)
        (when (ß (:cnt this) == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß (:cnt this) == 1)
            (§ ass (:cnt this) 0)
            (§ return this)
        )
        (let [#_"int" ___i (- (:cnt this) 1)]
            ;; pop in tail?
            (when (ß (___i & 0x01f) > 0)
                (§ ass (:cnt this) (- (:cnt this) 1))
                (§ return this)
            )

            (let [#_"Object[]" ___newtail (ß this.editableArrayFor((:cnt this) - 2))]
                (let [#_"VNode" ___newroot (.popTail this, (:shift this), (:root this))]
                    (let [#_"int" ___newshift (:shift this)]
                        (when (nil? ___newroot)
                            (§ ass ___newroot (VNode'new-1 (:edit (:root this))))
                        )
                        (when (ß (:shift this) > 5 && (:array ___newroot)[1] == nil)
                            (§ ass ___newroot (ß this.ensureEditable((VNode) (:array ___newroot)[0])))
                            (§ ass ___newshift (- ___newshift 5))
                        )
                        (§ ass (:root this) ___newroot)
                        (§ ass (:shift this) ___newshift)
                        (§ ass (:cnt this) (- (:cnt this) 1))
                        (§ ass (:tail this) ___newtail)
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method popTail) [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node]
        (§ ass ___node (.ensureEditable this, ___node))
        (let [#_"int" ___subidx (ß (((:cnt this) - 2) >>> ___level) & 0x01f)]
            (cond (> ___level 5)
                (do
                    (let [#_"VNode" ___newchild (ß this.popTail(___level - 5, (VNode) (:array ___node)[___subidx]))]
                        (if (ß ___newchild == nil && ___subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret ___node]
                                    (§ ass (ß (:array ___ret)[___subidx]) ___newchild)
                                    ___ret
                                )
                            )
                        )
                    )
                )
                (ß ___subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret ___node]
                        (§ ass (ß (:array ___ret)[___subidx]) nil)
                        ___ret
                    )
                )
            )
        )
    )
)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (AtomicReference. nil))
    (def #_"VNode" PersistentVector'EMPTY_NODE (ß VNode'new-2(PersistentVector'NOEDIT, new Object[32])))

    (def #_"PersistentVector" PersistentVector'EMPTY (ß PersistentVector'new-4(0, 5, PersistentVector'EMPTY_NODE, (object-array 0))))

    (def- #_"IFn" PersistentVector'TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___coll, #_"Object" ___val]
                (ß (cast' ITransientVector ___coll).conj(___val))
            )
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___coll]
                ___coll
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" ___items]
        (ß PersistentVector'new-4(___items.length, 5, PersistentVector'EMPTY_NODE, ___items))
    )

    (defn #_"PersistentVector" PersistentVector'create-1r [#_"IReduceInit" ___items]
        (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
            (ß ___items.reduce(PersistentVector'TRANSIENT_VECTOR_CONJ, ___ret))
            (.persistent ___ret)
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1s [#_"ISeq" ___items]
        (let [#_"Object[]" ___arr (make-array Object 32)]
            (let [#_"int" ___i 0]
                (loop-when-recur [___items ___items] (ß ___items != nil && ___i < 32) [(next ___items)]
                    (§ ass (ß ___arr[___i]) (first ___items))
                    (§ ass ___i (inc ___i))
                )

                (cond (some? ___items) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" ___start (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, ___arr)]
                            (let [#_"TransientVector" ___ret (.asTransient ___start)]
                                (loop-when-recur [___items ___items] (some? ___items) [(next ___items)]
                                    (§ ass ___ret (ß ___ret.conj((first ___items))))
                                )
                                (.persistent ___ret)
                            )
                        )
                    )
                    (ß ___i == 32) ;; exactly 32, skip copy
                    (do
                        (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, ___arr)
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" ___arr2 (make-array Object ___i)]
                            (System/arraycopy ___arr, 0, ___arr2, 0, ___i)
                            (PersistentVector'new-4 ___i, 5, PersistentVector'EMPTY_NODE, ___arr2)
                        )
                    )
                )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1l [#_"List" ___list]
        (let [#_"int" ___size (.size ___list)]
            (when (ß ___size <= 32)
                (§ return (ß PersistentVector'new-4(___size, 5, PersistentVector'EMPTY_NODE, (.toArray ___list))))
            )

            (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
                (loop-when-recur [#_"int" ___i 0] (< ___i ___size) [(inc ___i)]
                    (§ ass ___ret (ß ___ret.conj(___list.get(___i))))
                )
                (.persistent ___ret)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1i [#_"Iterable" ___items]
        ;; optimize common case
        (when (ß ___items instanceof ArrayList)
            (§ return (ß this.create((cast ArrayList ___items))))
        )

        (let [#_"Iterator" ___iter (.iterator ___items)]
            (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
                (while (.hasNext ___iter)
                    (§ ass ___ret (ß ___ret.conj((next ___iter))))
                )
                (.persistent ___ret)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1a [#_"Object..." ___items]
        (let [#_"TransientVector" ___ret (.asTransient PersistentVector'EMPTY)]
            (doseq [#_"Object" ___item ___items]
                (§ ass ___ret (.conj ___ret, ___item))
            )
            (.persistent ___ret)
        )
    )

    (defn- #_"PersistentVector" PersistentVector'init []
        (hash-map
            #_"int" :cnt 0
            #_"int" :shift 0
            #_"VNode" :root nil
            #_"Object[]" :tail nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-4 [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass (:_meta this) nil)
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-5 [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    #_method
    (§ defn #_"TransientVector" (§ method asTransient) [#_"PersistentVector" this]
        (TransientVector'new-1 this)
    )

    #_method
    (§ defn #_"int" (§ method tailoff) [#_"PersistentVector" this]
        (when (< (:cnt this) 32)
            (§ return 0)
        )
        (ß (((:cnt this) - 1) >>> 5) << 5)
    )

    #_method
    (§ defn #_"Object[]" (§ method arrayFor) [#_"PersistentVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= (.tailoff this))
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß (VNode) (:array ___node)[(___i >>> ___level) & 0x01f]))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"PersistentVector" this, #_"int" ___i]
        (let [#_"Object[]" ___node (.arrayFor this, ___i)]
            (ß ___node[___i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" (§ method nth) [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (§ return (.nth this, ___i))
        )
        ___notFound
    )

    #_method
    (§ defn #_"PersistentVector" (§ method assocN) [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___val]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= (.tailoff this))
                (let [#_"Object[]" ___newTail (make-array Object (ß (:tail this).length))]
                    (ß System/arraycopy((:tail this), 0, ___newTail, 0, (:tail this).length))
                    (§ ass (ß ___newTail[___i & 0x01f]) ___val)

                    (§ return (ß PersistentVector'new-5((.meta this), (:cnt this), (:shift this), (:root this), ___newTail)))
                )
            )

            (§ return (ß PersistentVector'new-5((.meta this), (:cnt this), (:shift this), this.doAssoc((:shift this), (:root this), ___i, ___val), (:tail this))))
        )
        (when (ß ___i == (:cnt this))
            (§ return (.cons this, ___val))
        )
        (throw (IndexOutOfBoundsException.))
    )

    (defn- #_"VNode" PersistentVector'doAssoc [#_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (let [#_"VNode" ___ret (ß VNode'new-2((:edit ___node), (:array ___node).clone()))]
            (if (ß ___level == 0)
                (do
                    (§ ass (ß (:array ___ret)[___i & 0x01f]) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (ß (:array ___ret)[___subidx]) (ß this.doAssoc(___level - 5, (VNode) (:array ___node)[___subidx], ___i, ___val)))
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"PersistentVector" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method withMeta) [#_"PersistentVector" this, #_"IPersistentMap" ___meta]
        (PersistentVector'new-5 ___meta, (:cnt this), (:shift this), (:root this), (:tail this))
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"PersistentVector" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"PersistentVector" (§ method cons) [#_"PersistentVector" this, #_"Object" ___val]
        ;; room in tail?
        (when (ß (:cnt this) - (.tailoff this) < 32)
            (let [#_"Object[]" ___newTail (make-array Object (ß (:tail this).length + 1))]
                (ß System/arraycopy((:tail this), 0, ___newTail, 0, (:tail this).length))
                (§ ass (ß ___newTail[(:tail this).length]) ___val)
                (§ return (ß PersistentVector'new-5((.meta this), (:cnt this) + 1, (:shift this), (:root this), ___newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"VNode" ___newroot]
            (let [#_"VNode" ___tailnode (ß VNode'new-2((:edit (:root this)), (:tail this)))]
                (let [#_"int" ___newshift (:shift this)]
                    ;; overflow root?
                    (if (ß ((:cnt this) >>> 5) > (1 << (:shift this)))
                        (do
                            (§ ass ___newroot (VNode'new-1 (:edit (:root this))))
                            (§ ass (ß (:array ___newroot)[0]) (:root this))
                            (§ ass (ß (:array ___newroot)[1]) (ß PersistentVector'newPath((:edit (:root this)), (:shift this), ___tailnode)))
                            (§ ass ___newshift (+ ___newshift 5))
                        )
                        (do
                            (§ ass ___newroot (.pushTail this, (:shift this), (:root this), ___tailnode))
                        )
                    )
                    (ß PersistentVector'new-5((.meta this), (:cnt this) + 1, ___newshift, ___newroot, (object-array [ ___val ])))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method pushTail) [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" ___subidx (ß (((:cnt this) - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret (ß VNode'new-2((:edit ___parent), (:array ___parent).clone()))]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (ß ___level == 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (ß (VNode) (:array ___parent)[___subidx])]
                                (§ ass ___nodeToInsert (ß (some? ___child) ? (ß this.pushTail(___level - 5, ___child, ___tailnode)) :or PersistentVector'newPath((:edit (:root this)), ___level - 5, ___tailnode)))
                            )
                        )
                    )
                    (§ ass (ß (:array ___ret)[___subidx]) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    (defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" ___edit, #_"int" ___level, #_"VNode" ___node]
        (when (ß ___level == 0)
            (§ return ___node)
        )
        (let [#_"VNode" ___ret (VNode'new-1 ___edit)]
            (§ ass (ß (:array ___ret)[0]) (ß PersistentVector'newPath(___edit, ___level - 5, ___node)))
            ___ret
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" (§ method chunkedSeq) [#_"PersistentVector" this]
        (when (ß (count this) == 0)
            (§ return nil)
        )
        (ChunkedSeq'new-3 this, 0, 0)
    )

    #_method
    (§ defn #_"ISeq" (§ method seq) [#_"PersistentVector" this]
        (.chunkedSeq this)
    )

    #_override
    #_method
    (§ defn #_"Iterator" (§ method rangedIterator) [#_"PersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i ___start
                    #_"int" :base (- (:i this) (% (:i this) 32))
                    #_"Object[]" :array (ß (___start < (count this)) ? (ß this.arrayFor((:i this))) :or nil)
                )
            )

            #_method
            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                (ß ((:i this) < ___end))
            )

            #_method
            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                (if (< (:i this) ___end)
                    (do
                        (when (ß (:i this) - (:base this) == 32)
                            (§ ass (:array this) (.arrayFor this, (:i this)))
                            (§ ass (:base this) (+ (:base this) 32))
                        )
                        (let [_ (ß (:array this)[(:i this) & 0x01f])]
                            (§ ass (:i this) (+ (:i this) 1))
                            _
                        )
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"PersistentVector" this]
        (ß this.rangedIterator(0, (count this)))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentVector" this, #_"IFn" ___f]
        (§ let [#_"Object" ___init]
            (if (> (:cnt this) 0)
                (do
                    (§ ass ___init (ß this.arrayFor(0)[0]))
                )
                (do
                    (§ return (.invoke ___f))
                )
            )
            (let [#_"int" ___step 0]
                (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                    (let [#_"Object[]" ___array (.arrayFor this, ___i)]
                        (loop-when-recur [#_"int" ___j (if (zero? ___i) 1 0)] (ß ___j < ___array.length) [(inc ___j)]
                            (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                            (when (RT'isReduced ___init)
                                (§ return (ß (cast' IDeref ___init).deref()))
                            )
                        )
                        (§ ass ___step (ß ___array.length))
                    )
                )
                ___init
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                (let [#_"Object[]" ___array (.arrayFor this, ___i)]
                    (loop-when-recur [#_"int" ___j 0] (ß ___j < ___array.length) [(inc ___j)]
                        (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                        (when (RT'isReduced ___init)
                            (§ return (ß (cast' IDeref ___init).deref()))
                        )
                    )
                    (§ ass ___step (ß ___array.length))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"Object" (§ method kvreduce) [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                (let [#_"Object[]" ___array (.arrayFor this, ___i)]
                    (loop-when-recur [#_"int" ___j 0] (ß ___j < ___array.length) [(inc ___j)]
                        (§ ass ___init (ß ___f.invoke(___init, ___j + ___i, ___array[___j])))
                        (when (RT'isReduced ___init)
                            (§ return (ß (cast' IDeref ___init).deref()))
                        )
                    )
                    (§ ass ___step (ß ___array.length))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" (§ method empty) [#_"PersistentVector" this]
        (ß PersistentVector'EMPTY.withMeta((.meta this)))
    )

    #_method
    (§ defn #_"PersistentVector" (§ method pop) [#_"PersistentVector" this]
        (when (ß (:cnt this) == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß (:cnt this) == 1)
            (§ return (ß PersistentVector'EMPTY.withMeta((.meta this))))
        )
        (when (ß (:cnt this) - (.tailoff this) > 1)
            (let [#_"Object[]" ___newTail (make-array Object (ß (:tail this).length - 1))]
                (ß System/arraycopy((:tail this), 0, ___newTail, 0, ___newTail.length))
                (§ return (ß PersistentVector'new-5((.meta this), (:cnt this) - 1, (:shift this), (:root this), ___newTail)))
            )
        )
        (let [#_"Object[]" ___newtail (ß this.arrayFor((:cnt this) - 2))]
            (let [#_"VNode" ___newroot (.popTail this, (:shift this), (:root this))]
                (let [#_"int" ___newshift (:shift this)]
                    (when (nil? ___newroot)
                        (§ ass ___newroot PersistentVector'EMPTY_NODE)
                    )
                    (when (ß (:shift this) > 5 && (:array ___newroot)[1] == nil)
                        (§ ass ___newroot (ß (VNode) (:array ___newroot)[0]))
                        (§ ass ___newshift (- ___newshift 5))
                    )
                    (ß PersistentVector'new-5((.meta this), (:cnt this) - 1, ___newshift, ___newroot, ___newtail))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" (§ method popTail) [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___node]
        (let [#_"int" ___subidx (ß (((:cnt this) - 2) >>> ___level) & 0x01f)]
            (cond (> ___level 5)
                (do
                    (let [#_"VNode" ___newchild (ß this.popTail(___level - 5, (VNode) (:array ___node)[___subidx]))]
                        (if (ß ___newchild == nil && ___subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret (ß VNode'new-2((:edit (:root this)), (:array ___node).clone()))]
                                    (§ ass (ß (:array ___ret)[___subidx]) ___newchild)
                                    ___ret
                                )
                            )
                        )
                    )
                )
                (ß ___subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret (ß VNode'new-2((:edit (:root this)), (:array ___node).clone()))]
                        (§ ass (ß (:array ___ret)[___subidx]) nil)
                        ___ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (defn- #_"ProxyHandler" ProxyHandler'init []
        (hash-map
            ;; method-name-string->fn
            #_"IPersistentMap" :fns nil
        )
    )

    (defn #_"ProxyHandler" ProxyHandler'new [#_"IPersistentMap" ___fns]
        (let [this (ProxyHandler'init)]
            (§ ass (:fns this) ___fns)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"ProxyHandler" this, #_"Object" ___proxy, #_"java.lang.reflect.Method" ___method, #_"Object[]" ___args] #_(§ throws Throwable)
        (let [#_"Class" ___rt (.getReturnType ___method)]
            (let [#_"IFn" ___fn (ß (IFn) (:fns this).valAt((.getName ___method)))]
                (when (nil? ___fn)
                    (cond (ß ___rt == Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß (.getName ___method).equals("equals"))
                        (do
                            (§ return (ß ___proxy == ___args[0]))
                        )
                        (ß (.getName ___method).equals("hashCode"))
                        (do
                            (§ return (System/identityHashCode ___proxy))
                        )
                        (ß (.getName ___method).equals("toString"))
                        (do
                            (§ return (str "Proxy: " (System/identityHashCode ___proxy)))
                        )
                    )
                    (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ___ret (ß ___fn.applyTo(ArraySeq'create-1(___args)))]
                    (cond (ß ___rt == Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (.isPrimitive ___rt)
                        (do
                            (cond (ß ___rt == Character/TYPE)
                                (do
                                    (§ return ___ret)
                                )
                                (ß ___rt == Integer/TYPE)
                                (do
                                    (§ return (ß (cast Number ___ret).intValue()))
                                )
                                (ß ___rt == Long/TYPE)
                                (do
                                    (§ return (ß (cast Number ___ret).longValue()))
                                )
                                (ß ___rt == Float/TYPE)
                                (do
                                    (§ return (ß (cast Number ___ret).floatValue()))
                                )
                                (ß ___rt == Double/TYPE)
                                (do
                                    (§ return (ß (cast Number ___ret).doubleValue()))
                                )
                                (ß ___rt == Boolean/TYPE && (not (ß ___ret instanceof Boolean)))
                                (do
                                    (§ return (if (nil? ___ret) Boolean/FALSE Boolean/TRUE))
                                )
                                (ß ___rt == Byte/TYPE)
                                (do
                                    (§ return (ß (byte) (cast Number ___ret).intValue()))
                                )
                                (ß ___rt == Short/TYPE)
                                (do
                                    (§ return (ß (short) (cast Number ___ret).intValue()))
                                )
                            )
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

#_private
(§ defprotocol RangeBoundsCheck
    #_abstract
    (#_"boolean" RangeBoundsCheck'''(§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" ___val])
)

#_private
#_non-static
(class-ns RangeIterator (§ implements Iterator)
    (defn- #_"RangeIterator" RangeIterator'init []
        (hash-map
            #_"Object" :next nil
        )
    )

    (defn #_"RangeIterator" RangeIterator'new []
        (let [this (RangeIterator'init)]
            (§ ass (:next this) (:start this))
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"RangeIterator" this]
        (ß (!(:boundsCheck this).exceededBounds((:next this))))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"RangeIterator" this]
        (if (.hasNext this)
            (do
                (let [#_"Object" ___ret (:next this)]
                    (§ ass (:next this) (Numbers'addP-2oo (:next this), (:step this)))
                    ___ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"RangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (def- #_"int" Range'CHUNK_SIZE 32)

    (defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (Numbers'gte-2oo ___val, ___end)
            )
        )
    )

    (defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" (§ method exceededBounds) [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (Numbers'lte-2oo ___val, ___end)
            )
        )
    )

    (defn- #_"Range" Range'init []
        (hash-map
            ;; Invariants guarantee this is never an "empty" seq
            #_"Object" :end nil
            #_"Object" :start nil
            #_"Object" :step nil
            #_"RangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"IChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Range" Range'new-4 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            this
        )
    )

    (defn- #_"Range" Range'new-6 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn- #_"Range" Range'new-7 [#_"IPersistentMap" ___meta, #_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new ___meta) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn #_"ISeq" Range'create-1 [#_"Object" ___end]
        (when (Numbers'isPos-1o ___end)
            (§ return (ß Range'new-4(0, ___end, 1, positiveStep(___end))))
        )
        PersistentList'EMPTY
    )

    (defn #_"ISeq" Range'create-2 [#_"Object" ___start, #_"Object" ___end]
        (Range'create-3 ___start, ___end, 1)
    )

    (defn #_"ISeq" Range'create-3 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step]
        (when (ß (Numbers'isPos-1o(___step) && Numbers'gt-2oo(___start, ___end)) || (Numbers'isNeg-1o(___step) && Numbers'gt-2oo(___end, ___start)) || Numbers'equiv-2oo(___start, ___end))
            (§ return PersistentList'EMPTY)
        )
        (when (Numbers'isZero-1o ___step)
            (§ return (Repeat'create-1 ___start))
        )
        (ß Range'new-4(___start, ___end, ___step, Numbers'isPos-1o(___step) ? positiveStep(___end) :or negativeStep(___end)))
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"Range" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (Range'new-7 ___meta, (:end this), (:start this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Range" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" (§ method forceChunk) [#_"Range" this]
        (when (some? (:_chunk this))
            (§ return nil)
        )

        (let [#_"Object[]" ___arr (make-array Object Range'CHUNK_SIZE)]
            (let [#_"int" ___n 0]
                (let [#_"Object" ___val (:start this)]
                    (while (ß ___n < Range'CHUNK_SIZE)
                        (§ ass (ß ___arr[___n]) ___val)
                        (§ ass ___n (inc ___n))
                        (§ ass ___val (Numbers'addP-2oo ___val, (:step this)))
                        (when (ß (:boundsCheck this).exceededBounds(___val))
                            ;; partial last chunk
                            (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, ___n))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (ß (:boundsCheck this).exceededBounds(___val))
                        (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, Range'CHUNK_SIZE))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, Range'CHUNK_SIZE))
                    (§ ass (:_chunkNext this) (Range'new-4 ___val, (:end this), (:step this), (:boundsCheck this)))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Range" this]
        (when (some? (:_next this))
            (§ return (:_next this))
        )

        (.forceChunk this)
        (when (ß (:_chunk this).count() > 1)
            (let [#_"IChunk" ___smallerChunk (.dropFirst (:_chunk this))]
                (§ ass (:_next this) (ß Range'new-6(___smallerChunk.nth(0), (:end this), (:step this), (:boundsCheck this), ___smallerChunk, (:_chunkNext this))))
                (§ return (:_next this))
            )
        )
        (.chunkedNext this)
    )

    #_method
    (§ defn #_"IChunk" (§ method chunkedFirst) [#_"Range" this]
        (.forceChunk this)
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedNext) [#_"Range" this]
        (.seq (.chunkedMore this))
    )

    #_method
    (§ defn #_"ISeq" (§ method chunkedMore) [#_"Range" this]
        (.forceChunk this)
        (when (nil? (:_chunkNext this))
            (§ return PersistentList'EMPTY)
        )
        (:_chunkNext this)
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Range" this, #_"IFn" ___f]
        (let [#_"Object" ___acc (:start this)]
            (let [#_"Number" ___i (Numbers'addP-2oo (:start this), (:step this))]
                (while (not (ß (:boundsCheck this).exceededBounds(___i)))
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (RT'isReduced ___acc)
                        (§ return (ß (cast' Reduced ___acc).deref()))
                    )
                    (§ ass ___i (Numbers'addP-2oo ___i, (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Range" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"Object" ___i (:start this)]
                (while (not (ß (:boundsCheck this).exceededBounds(___i)))
                    (§ ass ___acc (.invoke ___f, ___acc, ___i))
                    (when (RT'isReduced ___acc)
                        (§ return (ß (cast' Reduced ___acc).deref()))
                    )
                    (§ ass ___i (Numbers'addP-2oo ___i, (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" (§ method iterator) [#_"Range" this]
        (RangeIterator'new)
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (defn- #_"Ratio" Ratio'init []
        (hash-map
            #_"BigInteger" :numerator nil
            #_"BigInteger" :denominator nil
        )
    )

    (defn #_"Ratio" Ratio'new [#_"BigInteger" ___numerator, #_"BigInteger" ___denominator]
        (let [this (merge (Number'new) (Ratio'init))]
            (§ ass (:numerator this) ___numerator)
            (§ ass (:denominator this) ___denominator)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"Ratio" this, #_"Object" ___arg0]
        (ß (___arg0 != nil && ___arg0 instanceof Ratio && (:numerator (cast' Ratio ___arg0)).equals((:numerator this)) && (:denominator (cast' Ratio ___arg0)).equals((:denominator this))))
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Ratio" this]
        (ß (:numerator this).hashCode() :xor (:denominator this).hashCode())
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Ratio" this]
        (str (ß (:numerator this).toString()) "/" (ß (:denominator this).toString()))
    )

    #_method
    (§ defn #_"int" (§ method intValue) [#_"Ratio" this]
        (ß (int) (.doubleValue this))
    )

    #_method
    (§ defn #_"long" (§ method longValue) [#_"Ratio" this]
        (.longValue (.bigIntegerValue this))
    )

    #_method
    (§ defn #_"float" (§ method floatValue) [#_"Ratio" this]
        (ß (float)this.doubleValue())
    )

    #_method
    (§ defn #_"double" (§ method doubleValue) [#_"Ratio" this]
        (ß this.decimalValue(MathContext/DECIMAL64).doubleValue())
    )

    #_method
    (§ defn #_"BigDecimal" (§ method decimalValue) [#_"Ratio" this]
        (ß this.decimalValue(MathContext/UNLIMITED))
    )

    #_method
    (§ defn #_"BigDecimal" (§ method decimalValue) [#_"Ratio" this, #_"MathContext" ___mc]
        (let [#_"BigDecimal" ___numerator (§ unsure BigDecimal. (:numerator this))]
            (let [#_"BigDecimal" ___denominator (§ unsure BigDecimal. (:denominator this))]
                (.divide ___numerator, ___denominator, ___mc)
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" (§ method bigIntegerValue) [#_"Ratio" this]
        (ß (:numerator this).divide((:denominator this)))
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Ratio" this, #_"Object" ___o]
        (let [#_"Number" ___other (ß (Number)___o)]
            (Numbers'compare this, ___other)
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def #_"Keyword" ReaderConditional'FORM_KW (Keyword'intern-1 "form"))
    (§ def #_"Keyword" ReaderConditional'SPLICING_KW (Keyword'intern-1 "splicing?"))

    (defn #_"ReaderConditional" ReaderConditional'create [#_"Object" ___form, #_"boolean" ___splicing]
        (ReaderConditional'new ___form, ___splicing)
    )

    (defn- #_"ReaderConditional" ReaderConditional'init []
        (hash-map
            #_"Object" :form nil
            #_"Boolean" :splicing nil
        )
    )

    (defn- #_"ReaderConditional" ReaderConditional'new [#_"Object" ___form, #_"boolean" ___splicing]
        (let [this (ReaderConditional'init)]
            (§ ass (:form this) ___form)
            (§ ass (:splicing this) ___splicing)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ReaderConditional" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"ReaderConditional" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (ß ReaderConditional'FORM_KW.equals(___key))
            (do
                (:form this)
            )
            (ß ReaderConditional'SPLICING_KW.equals(___key))
            (do
                (:splicing this)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" (§ method equals) [#_"ReaderConditional" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß ___o == nil || getClass() != (.getClass ___o))
            (§ return false)
        )

        (let [#_"ReaderConditional" ___that (ß (ReaderConditional) ___o)]
            (when (ß ((:form this) != nil) ? (not (ß (:form this).equals((:form ___that)))) :or (:form ___that) != nil)
                (§ return false)
            )
            (when (ß ((:splicing this) != nil) ? (not (ß (:splicing this).equals((:splicing ___that)))) :or (:splicing ___that) != nil)
                (§ return false)
            )
            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"ReaderConditional" this]
        (let [#_"int" ___result (Util'hash (:form this))]
            (§ ass ___result (ß 31 * ___result + Util'hash((:splicing this))))
            ___result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (defn- #_"RecordIterator" RecordIterator'init []
        (hash-map
            #_"int" :i 0
            #_"int" :basecnt 0
            #_"ILookup" :rec nil
            #_"IPersistentVector" :basefields nil
            #_"Iterator" :extmap nil
        )
    )

    (defn #_"RecordIterator" RecordIterator'new [#_"ILookup" ___rec, #_"IPersistentVector" ___basefields, #_"Iterator" ___extmap]
        (let [this (RecordIterator'init)]
            (§ ass (:rec this) ___rec)
            (§ ass (:basefields this) ___basefields)
            (§ ass (:basecnt this) (count ___basefields))
            (§ ass (:extmap this) ___extmap)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                true
            )
            (do
                (.hasNext (:extmap this))
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                (let [#_"Object" ___k (ß (:basefields this).nth((:i this)))]
                    (§ ass (:i this) (+ (:i this) 1))
                    (ß MapEntry'create(___k, (:rec this).valAt(___k)))
                )
            )
            (do
                (next (:extmap this))
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (defn- #_"Reduced" Reduced'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Reduced" Reduced'new [#_"Object" ___val]
        (let [this (Reduced'init)]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Reduced" this]
        (:val this)
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns RefTVal
    (defn- #_"RefTVal" RefTVal'init []
        (hash-map
            #_"Object" :val nil
            #_"long" :point 0
            #_"RefTVal" :prior nil
            #_"RefTVal" :next nil
        )
    )

    (defn #_"RefTVal" RefTVal'new-3 [#_"Object" ___val, #_"long" ___point, #_"RefTVal" ___prior]
        (let [this (RefTVal'init)]
            (§ ass (:val this) ___val)
            (§ ass (:point this) ___point)
            (§ ass (:prior this) ___prior)
            (§ ass (:next this) (:next ___prior))
            (§ ass (:next (:prior this)) this)
            (§ ass (:prior (:next this)) this)
            this
        )
    )

    (defn #_"RefTVal" RefTVal'new-2 [#_"Object" ___val, #_"long" ___point]
        (let [this (RefTVal'init)]
            (§ ass (:val this) ___val)
            (§ ass (:point this) ___point)
            (§ ass (:next this) this)
            (§ ass (:prior this) this)
            this
        )
    )
)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (def #_"AtomicLong" Ref'ids (AtomicLong.))

    (defn- #_"Ref" Ref'init []
        (hash-map
            #_"RefTVal" :tvals nil
            #_"AtomicInteger" :faults nil
            #_"ReentrantReadWriteLock" :lock nil
            #_"LockingTransactionInfo" :tinfo nil
            #_"long" :id 0

            #_volatile
            #_"int" :minHistory 0
            #_volatile
            #_"int" :maxHistory 10
        )
    )

    (defn #_"Ref" Ref'new-1 [#_"Object" ___initVal]
        (Ref'new-2 ___initVal, nil)
    )

    (defn #_"Ref" Ref'new-2 [#_"Object" ___initVal, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Ref'init))]
            (§ ass (:id this) (.getAndIncrement Ref'ids))
            (§ ass (:faults this) (AtomicInteger.))
            (§ ass (:lock this) (ReentrantReadWriteLock.))
            (§ ass (:tvals this) (RefTVal'new-2 ___initVal, 0))
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Ref" this, #_"Ref" ___ref]
        (cond (ß (:id this) == (:id ___ref))
            (do
                0
            )
            (ß (:id this) < (:id ___ref))
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method getMinHistory) [#_"Ref" this]
        (:minHistory this)
    )

    #_method
    (§ defn #_"Ref" (§ method setMinHistory) [#_"Ref" this, #_"int" ___minHistory]
        (§ ass (:minHistory this) ___minHistory)
        this
    )

    #_method
    (§ defn #_"int" (§ method getMaxHistory) [#_"Ref" this]
        (:maxHistory this)
    )

    #_method
    (§ defn #_"Ref" (§ method setMaxHistory) [#_"Ref" this, #_"int" ___maxHistory]
        (§ ass (:maxHistory this) ___maxHistory)
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" (§ method currentVal) [#_"Ref" this]
        (try
            (ß (:lock this).readLock().lock())
            (when (some? (:tvals this))
                (§ return (:val (:tvals this)))
            )
            (throw (IllegalStateException. (str (.toString this) " is unbound.")))
            (finally
                (ß (:lock this).readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Ref" this]
        (let [#_"LockingTransaction" ___t (LockingTransaction'getRunning)]
            (when (nil? ___t)
                (§ return (.currentVal this))
            )
            (.doGet ___t, this)
        )
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"Ref" this, #_"Object" ___val]
        (ß LockingTransaction'getEx().doSet(this, ___val))
    )

    #_method
    (§ defn #_"Object" (§ method commute) [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß LockingTransaction'getEx().doCommute(this, ___fn, ___args))
    )

    #_method
    (§ defn #_"Object" (§ method alter) [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (let [#_"LockingTransaction" ___t (LockingTransaction'getEx)]
            (ß ___t.doSet(this, ___fn.applyTo(RT'cons(___t.doGet(this), ___args))))
        )
    )

    #_method
    (§ defn #_"void" (§ method touch) [#_"Ref" this]
        (ß LockingTransaction'getEx().doEnsure(this))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isBound) [#_"Ref" this]
        (try
            (ß (:lock this).readLock().lock())
            (ß ((:tvals this) != nil))
            (finally
                (ß (:lock this).readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method trimHistory) [#_"Ref" this]
        (try
            (ß (:lock this).writeLock().lock())
            (when (some? (:tvals this))
                (§ ass (:next (:tvals this)) (:tvals this))
                (§ ass (:prior (:tvals this)) (:tvals this))
            )
            (finally
                (ß (:lock this).writeLock().unlock())
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method getHistoryCount) [#_"Ref" this]
        (try
            (ß (:lock this).writeLock().lock())
            (.histCount this)
            (finally
                (ß (:lock this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"int" (§ method histCount) [#_"Ref" this]
        (if (nil? (:tvals this))
            (do
                0
            )
            (do
                (let [#_"int" ___count 0]
                    (loop-when-recur [#_"RefTVal" ___tv (:next (:tvals this))] (ß ___tv != (:tvals this)) [(:next ___tv)]
                        (§ ass ___count (inc ___count))
                    )
                    ___count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" (§ method fn) [#_"Ref" this]
        (ß (IFn) (deref this))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Ref" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Ref" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this]
        (.invoke (.fn this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1]
        (ß (.fn this).invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß (.fn this).invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß (.fn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args))
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Ref" this, #_"ISeq" ___arglist]
        (AFn'applyToHelper this, ___arglist)
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" ___target, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"List" ___methods (ß getMethods(___c, ___args.length, ___methodName, false))]
                (ß invokeMatchingMethod(___methodName, ___methods, ___target, ___args))
            )
        )
    )

    (defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" ___e]
        (when (ß (.getCause ___e) != nil)
            (§ return (.getCause ___e))
        )
        ___e
    )

    (defn- #_"RuntimeException" Reflector'throwCauseOrElseException [#_"Exception" ___e]
        (when (ß (.getCause ___e) != nil)
            (throw (ß Util'sneakyThrow((.getCause ___e))))
        )
        (throw (Util'sneakyThrow ___e))
    )

    (defn- #_"String" Reflector'noMethodReport [#_"String" ___methodName, #_"Object" ___target]
        (str "No matching method found: " ___methodName (if (nil? ___target) "" (str " for " (.getClass ___target))))
    )

    (defn #_"Object" Reflector'invokeMatchingMethod [#_"String" ___methodName, #_"List" ___methods, #_"Object" ___target, #_"Object[]" ___args]
        (let [#_"java.lang.reflect.Method" ___m nil]
            (let [#_"Object[]" ___boxedArgs nil]
                (cond (.isEmpty ___methods)
                    (do
                        (throw (§ unsure IllegalArgumentException. (ß noMethodReport(___methodName, ___target))))
                    )
                    (ß (.size ___methods) == 1)
                    (do
                        (§ ass ___m (ß (java.lang.reflect.Method) ___methods.get(0)))
                        (§ ass ___boxedArgs (ß boxArgs((.getParameterTypes ___m), ___args)))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"java.lang.reflect.Method" ___foundm nil]
                            (loop-when-recur [#_"Iterator" ___i (.iterator ___methods)] (.hasNext ___i) [___i]
                                (§ ass ___m (ß (java.lang.reflect.Method) (next ___i)))

                                (let [#_"Class[]" ___params (.getParameterTypes ___m)]
                                    (when (ß isCongruent(___params, ___args))
                                        (when (ß ___foundm == nil || Compiler'subsumes(___params, (.getParameterTypes ___foundm)))
                                            (§ ass ___foundm ___m)
                                            (§ ass ___boxedArgs (ß boxArgs(___params, ___args)))
                                        )
                                    )
                                )
                            )
                            (§ ass ___m ___foundm)
                        )
                    )
                )
                (when (nil? ___m)
                    (throw (§ unsure IllegalArgumentException. (ß noMethodReport(___methodName, ___target))))
                )

                (when (not (Modifier/isPublic (ß (.getDeclaringClass ___m).getModifiers())))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"java.lang.reflect.Method" ___oldm ___m]
                        (§ ass ___m (ß getAsMethodOfPublicBase((.getClass ___target), ___m)))
                        (when (nil? ___m)
                            (throw (IllegalArgumentException. (str "Can't call public method of non-public class: " (.toString ___oldm))))
                        )
                    )
                )
                (try
                    (ß Reflector'prepRet((.getReturnType ___m), ___m.invoke(___target, ___boxedArgs)))
                    (catch Exception ___e
                        (throw (ß Util'sneakyThrow(getCauseOrElse(___e))))
                    )
                )
            )
        )
    )

    (defn #_"java.lang.reflect.Method" Reflector'getAsMethodOfPublicBase [#_"Class" ___c, #_"java.lang.reflect.Method" ___m]
        (doseq [#_"Class" ___iface (.getInterfaces ___c)]
            (doseq [#_"java.lang.reflect.Method" ___im (.getMethods ___iface)]
                (when (ß isMatch(___im, ___m))
                    (§ return ___im)
                )
            )
        )
        (let [#_"Class" ___sc (.getSuperclass ___c)]
            (when (nil? ___sc)
                (§ return nil)
            )
            (doseq [#_"java.lang.reflect.Method" ___scm (.getMethods ___sc)]
                (when (ß isMatch(___scm, ___m))
                    (§ return ___scm)
                )
            )
            (ß getAsMethodOfPublicBase(___sc, ___m))
        )
    )

    (defn #_"boolean" Reflector'isMatch [#_"java.lang.reflect.Method" ___lhs, #_"java.lang.reflect.Method" ___rhs]
        (when (ß (not (ß ___lhs.getName().equals((.getName ___rhs)))) || (not (Modifier/isPublic (ß (.getDeclaringClass ___lhs).getModifiers()))))
            (§ return false)
        )

        (let [#_"Class[]" ___types1 (.getParameterTypes ___lhs)]
            (let [#_"Class[]" ___types2 (.getParameterTypes ___rhs)]
                (when (ß ___types1.length != ___types2.length)
                    (§ return false)
                )

                (let [#_"boolean" ___match true]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___types1.length) [(inc ___i)]
                        (when (not (ß ___types1[___i].isAssignableFrom(___types2[___i])))
                            (§ ass ___match false)
                            (§ break )
                        )
                    )
                    ___match
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeConstructor [#_"Class" ___c, #_"Object[]" ___args]
        (try
            (let [#_"Constructor[]" ___allctors (.getConstructors ___c)]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allctors.length) [(inc ___i)]
                        (let [#_"Constructor" ___ctor (ß ___allctors[___i])]
                            (when (ß (.getParameterTypes ___ctor).length == ___args.length)
                                (.add ___ctors, ___ctor)
                            )
                        )
                    )
                    (cond (.isEmpty ___ctors)
                        (do
                            (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                        )
                        (ß (.size ___ctors) == 1)
                        (do
                            (let [#_"Constructor" ___ctor (ß (Constructor) ___ctors.get(0))]
                                (ß ___ctor.newInstance(boxArgs((.getParameterTypes ___ctor), ___args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [#_"Iterator" ___iterator (.iterator ___ctors)] (.hasNext ___iterator) [___iterator]
                                (let [#_"Constructor" ___ctor (ß (Constructor) (next ___iterator))]
                                    (let [#_"Class[]" ___params (.getParameterTypes ___ctor)]
                                        (when (ß isCongruent(___params, ___args))
                                            (let [#_"Object[]" ___boxedArgs (ß boxArgs(___params, ___args))]
                                                (§ return (.newInstance ___ctor, ___boxedArgs))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (throw (ß Util'sneakyThrow(getCauseOrElse(___e))))
            )
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" ___className, #_"String" ___methodName, #_"Object..." ___args]
        (ß invokeStaticMethod(___className, ___methodName, ___args))
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3s [#_"String" ___className, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (ß invokeStaticMethod(___c, ___methodName, ___args))
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3c [#_"Class" ___c, #_"String" ___methodName, #_"Object[]" ___args]
        (when (.equals ___methodName, "new")
            (§ return (ß invokeConstructor(___c, ___args)))
        )
        (let [#_"List" ___methods (ß getMethods(___c, ___args.length, ___methodName, true))]
            (ß invokeMatchingMethod(___methodName, ___methods, nil, ___args))
        )
    )

    (defn #_"Object" Reflector'getStaticField-2s [#_"String" ___className, #_"String" ___fieldName]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (ß getStaticField(___c, ___fieldName))
        )
    )

    (defn #_"Object" Reflector'getStaticField-2c [#_"Class" ___c, #_"String" ___fieldName]
        (let [#_"Field" ___f (ß getField(___c, ___fieldName, true))]
            (when (some? ___f)
                (try
                    (§ return (ß Reflector'prepRet((.getType ___f), ___f.get(nil))))
                    (catch IllegalAccessException ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
            (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " ___c)))
        )
    )

    (defn #_"Object" Reflector'setStaticField-3s [#_"String" ___className, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (ß setStaticField(___c, ___fieldName, ___val))
        )
    )

    (defn #_"Object" Reflector'setStaticField-3c [#_"Class" ___c, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Field" ___f (ß getField(___c, ___fieldName, true))]
            (when (some? ___f)
                (try
                    (ß ___f.set(nil, boxArg((.getType ___f), ___val)))
                    (catch IllegalAccessException ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
                (§ return ___val)
            )
            (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " ___c)))
        )
    )

    (defn #_"Object" Reflector'getInstanceField [#_"Object" ___target, #_"String" ___fieldName]
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (ß getField(___c, ___fieldName, false))]
                (when (some? ___f)
                    (try
                        (§ return (ß Reflector'prepRet((.getType ___f), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                )
                (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " (.getClass ___target))))
            )
        )
    )

    (defn #_"Object" Reflector'setInstanceField [#_"Object" ___target, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (ß getField(___c, ___fieldName, false))]
                (when (some? ___f)
                    (try
                        (ß ___f.set(___target, boxArg((.getType ___f), ___val)))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                    (§ return ___val)
                )
                (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " (.getClass ___target))))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (defn #_"Object" Reflector'invokeNoArgInstanceMember-2 [#_"Object" ___target, #_"String" ___name]
        (ß invokeNoArgInstanceMember(___target, ___name, false))
    )

    (defn #_"Object" Reflector'invokeNoArgInstanceMember-3 [#_"Object" ___target, #_"String" ___name, #_"boolean" ___requireField]
        (let [#_"Class" ___c (.getClass ___target)]
            (if ___requireField
                (do
                    (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                        (if (some? ___f)
                            (do
                                (ß getInstanceField(___target, ___name))
                            )
                            (do
                                (throw (IllegalArgumentException. (str "No matching field found: " ___name " for " (.getClass ___target))))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" ___meths (ß getMethods(___c, 0, ___name, false))]
                        (if (ß (.size ___meths) > 0)
                            (do
                                (ß invokeMatchingMethod(___name, ___meths, ___target, RT'EMPTY_ARRAY))
                            )
                            (do
                                (ß getInstanceField(___target, ___name))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-2 [#_"Object" ___target, #_"String" ___name]
        ;; check for field first
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                (when (some? ___f) ;; field get
                    (try
                        (§ return (ß Reflector'prepRet((.getType ___f), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                )
                (ß invokeInstanceMethod(___target, ___name, RT'EMPTY_ARRAY))
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3o [#_"String" ___name, #_"Object" ___target, #_"Object" ___arg1]
        ;; check for field first
        (let [#_"Class" ___c (.getClass ___target)]
            (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                (when (some? ___f) ;; field set
                    (try
                        (ß ___f.set(___target, boxArg((.getType ___f), ___arg1)))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                    (§ return ___arg1)
                )
                (ß invokeInstanceMethod(___target, ___name, (object-array [ ___arg1 ])))
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3a [#_"String" ___name, #_"Object" ___target, #_"Object..." ___args]
        (ß invokeInstanceMethod(___target, ___name, ___args))
    )

    (defn #_"Field" Reflector'getField [#_"Class" ___c, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"Field[]" ___allfields (.getFields ___c)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allfields.length) [(inc ___i)]
                (when (ß ___name.equals(___allfields[___i].getName()) && Modifier/isStatic(___allfields[___i].getModifiers()) == ___getStatics)
                    (§ return (ß ___allfields[___i]))
                )
            )
            nil
        )
    )

    (defn #_"List" Reflector'getMethods [#_"Class" ___c, #_"int" ___arity, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"java.lang.reflect.Method[]" ___allmethods (.getMethods ___c)]
            (let [#_"ArrayList" ___methods (ArrayList.)]
                (let [#_"ArrayList" ___bridgeMethods (ArrayList.)]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allmethods.length) [(inc ___i)]
                        (let [#_"java.lang.reflect.Method" ___method (ß ___allmethods[___i])]
                            (when (ß ___name.equals((.getName ___method)) && Modifier/isStatic((.getModifiers ___method)) == ___getStatics && (.getParameterTypes ___method).length == ___arity)
                                (try
                                    (if (ß (.isBridge ___method) && ___c.getMethod((.getName ___method), (.getParameterTypes ___method)).equals(___method))
                                        (do
                                            (.add ___bridgeMethods, ___method)
                                        )
                                        (do
                                            (.add ___methods, ___method)
                                        )
                                    )
                                    (catch NoSuchMethodException ___e
                                    )
                                )
                            )
                        )
                    )

                    (when (.isEmpty ___methods)
                        (.addAll ___methods, ___bridgeMethods)
                    )
                    (when (and (not ___getStatics) (.isInterface ___c))
                        (§ ass ___allmethods (ß (§ class Object).getMethods()))
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allmethods.length) [(inc ___i)]
                            (when (ß ___name.equals(___allmethods[___i].getName()) && Modifier/isStatic(___allmethods[___i].getModifiers()) == ___getStatics && ___allmethods[___i].getParameterTypes().length == ___arity)
                                (ß ___methods.add(___allmethods[___i]))
                            )
                        )
                    )
                    ___methods
                )
            )
        )
    )

    (defn #_"Object" Reflector'boxArg [#_"Class" ___paramType, #_"Object" ___arg]
        (cond (not (ß ___paramType.isPrimitive()))
            (do
                (§ return (.cast ___paramType, ___arg))
            )
            (ß ___paramType == (§ class boolean))
            (do
                (§ return (ß (§ class Boolean).cast(___arg)))
            )
            (ß ___paramType == (§ class char))
            (do
                (§ return (ß (§ class Character).cast(___arg)))
            )
            (ß ___arg instanceof Number)
            (do
                (let [#_"Number" ___n (ß (Number) ___arg)]
                    (cond (ß ___paramType == (§ class int))
                        (do
                            (§ return (.intValue ___n))
                        )
                        (ß ___paramType == (§ class float))
                        (do
                            (§ return (.floatValue ___n))
                        )
                        (ß ___paramType == (§ class double))
                        (do
                            (§ return (.doubleValue ___n))
                        )
                        (ß ___paramType == (§ class long))
                        (do
                            (§ return (.longValue ___n))
                        )
                        (ß ___paramType == (§ class short))
                        (do
                            (§ return (.shortValue ___n))
                        )
                        (ß ___paramType == (§ class byte))
                        (do
                            (§ return (.byteValue ___n))
                        )
                    )
                )
            )
        )
        (throw (IllegalArgumentException. (str "Unexpected param type, expected: " ___paramType ", given: " (.getName (.getClass ___arg)))))
    )

    (defn #_"Object[]" Reflector'boxArgs [#_"Class[]" ___params, #_"Object[]" ___args]
        (when (ß ___params.length == 0)
            (§ return nil)
        )
        (let [#_"Object[]" ___ret (make-array Object (ß ___params.length))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___params.length) [(inc ___i)]
                (let [#_"Object" ___arg (ß ___args[___i])]
                    (let [#_"Class" ___paramType (ß ___params[___i])]
                        (§ ass (ß ___ret[___i]) (ß boxArg(___paramType, ___arg)))
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" ___paramType, #_"Class" ___argType]
        (when (nil? ___argType)
            (§ return (not (ß ___paramType.isPrimitive())))
        )
        (when (ß ___paramType == ___argType || ___paramType.isAssignableFrom(___argType))
            (§ return true)
        )
        (cond (ß ___paramType == (§ class int))
            (do
                (§ return (ß ___argType == (§ class Integer)
                    || ___argType == (§ class long)
                    || ___argType == (§ class Long)
                    || ___argType == (§ class short)
                    || ___argType == (§ class byte)))
            )
            (ß ___paramType == (§ class float))
            (do
                (§ return (ß ___argType == (§ class Float)
                    || ___argType == (§ class double)))
            )
            (ß ___paramType == (§ class double))
            (do
                (§ return (ß ___argType == (§ class Double)
                    || ___argType == (§ class float)))
            )
            (ß ___paramType == (§ class long))
            (do
                (§ return (ß ___argType == (§ class Long)
                    || ___argType == (§ class int)
                    || ___argType == (§ class short)
                    || ___argType == (§ class byte)))
            )
            (ß ___paramType == (§ class char))
            (do
                (§ return (ß ___argType == (§ class Character)))
            )
            (ß ___paramType == (§ class short))
            (do
                (§ return (ß ___argType == (§ class Short)))
            )
            (ß ___paramType == (§ class byte))
            (do
                (§ return (ß ___argType == (§ class Byte)))
            )
            (ß ___paramType == (§ class boolean))
            (do
                (§ return (ß ___argType == (§ class Boolean)))
            )
        )
        false
    )

    (defn #_"boolean" Reflector'isCongruent [#_"Class[]" ___params, #_"Object[]" ___args]
        (let [#_"boolean" ___ret false]
            (when (nil? ___args)
                (§ return (ß ___params.length == 0))
            )
            (when (ß ___params.length == ___args.length)
                (§ ass ___ret true)
                (loop-when-recur [#_"int" ___i 0] (ß ___ret && ___i < ___params.length) [(inc ___i)]
                    (let [#_"Object" ___arg (ß ___args[___i])]
                        (let [#_"Class" ___argType (ß (nil? ___arg) ? nil :or (.getClass ___arg))]
                            (let [#_"Class" ___paramType (ß ___params[___i])]
                                (§ ass ___ret (ß paramArgTypeMatch(___paramType, ___argType)))
                            )
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"Object" Reflector'prepRet [#_"Class" ___c, #_"Object" ___x]
        (when (not (ß (.isPrimitive ___c) || ___c == (§ class Boolean)))
            (§ return ___x)
        )
        (when (ß ___x instanceof Boolean)
            (§ return (if (cast Boolean ___x) Boolean/TRUE Boolean/FALSE))
        )
        ___x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (def- #_"long" Repeat'INFINITE -1)

    (defn- #_"Repeat" Repeat'init []
        (hash-map
            #_"long" :count 0 ;; always INFINITE or >0
            #_"Object" :val nil
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Repeat" Repeat'new-2 [#_"long" ___count, #_"Object" ___val]
        (let [this (merge (ASeq'new) (Repeat'init))]
            (§ ass (:count this) ___count)
            (§ ass (:val this) ___val)
            this
        )
    )

    (defn- #_"Repeat" Repeat'new-3 [#_"IPersistentMap" ___meta, #_"long" ___count, #_"Object" ___val]
        (let [this (merge (ASeq'new ___meta) (Repeat'init))]
            (§ ass (:count this) ___count)
            (§ ass (:val this) ___val)
            this
        )
    )

    (defn #_"Repeat" Repeat'create-1 [#_"Object" ___val]
        (Repeat'new-2 Repeat'INFINITE, ___val)
    )

    (defn #_"ISeq" Repeat'create-2 [#_"long" ___count, #_"Object" ___val]
        (when (ß ___count <= 0)
            (§ return PersistentList'EMPTY)
        )
        (Repeat'new-2 ___count, ___val)
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"Repeat" this]
        (:val this)
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"Repeat" this]
        (when (nil? (:_next this))
            (cond (> (:count this) 1)
                (do
                    (§ ass (:_next this) (ß Repeat'new-2((:count this) - 1, (:val this))))
                )
                (ß (:count this) == Repeat'INFINITE)
                (do
                    (§ ass (:_next this) this)
                )
            )
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Repeat" (§ method withMeta) [#_"Repeat" this, #_"IPersistentMap" ___meta]
        (Repeat'new-3 ___meta, (:count this), (:val this))
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Repeat" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (:val this)]
            (if (ß (:count this) == Repeat'INFINITE)
                (do
                    (while true
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (ß (cast' IDeref ___ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"long" ___i 1] (< ___i (:count this)) [(inc ___i)]
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (ß (cast' IDeref ___ret).deref()))
                        )
                    )
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method reduce) [#_"Repeat" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (if (ß (:count this) == Repeat'INFINITE)
                (do
                    (while true
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (ß (cast' IDeref ___ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"long" ___i 0] (< ___i (:count this)) [(inc ___i)]
                        (§ ass ___ret (.invoke ___f, ___ret, (:val this)))
                        (when (RT'isReduced ___ret)
                            (§ return (ß (cast' IDeref ___ret).deref()))
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_protected
    (defn #_"RestFn" RestFn'new []
        (AFunction'new)
    )

    #_abstract
    (§ defn #_"int" (§ method getRequiredArity) [#_"RestFn" this])

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method doInvoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object" ___args]
        nil
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"RestFn" this, #_"ISeq" ___args]
        (when (ß RT'boundedLength(___args, (.getRequiredArity this)) <= (.getRequiredArity this))
            (§ return (ß AFn'applyToHelper(this, Util'ret1(___args, (§ ass ___args nil)))))
        )
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (§ return (ß this.doInvoke(Util'ret1(___args, (§ ass ___args nil)))))
            )
            (§ case 1)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 2)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 3)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 4)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 5)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 6)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 7)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 8)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 9)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 10)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 11)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 12)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 13)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 14)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 15)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 16)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 17)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 18)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 19)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
            (§ case 20)
            (do
                (§ return (ß this.doInvoke((first ___args),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        (§ ass ___args (next ___args)).first(),
                        Util'ret1((next ___args), (§ ass ___args nil)))))
            )
        )
        (.throwArity this, -1)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (.doInvoke this, nil)
            )
            (§ default )
            (do
                (.throwArity this, 0)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(ArraySeq'create-1(Util'ret1(___arg1, (§ ass ___arg1 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 1)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 2)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 3)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 4)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 5)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 6)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 7)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 8)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 9)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 10)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 11)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 12)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 13)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 14)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 15)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 16)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 17)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 18)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 19)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 19)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)), nil))
            )
            (§ default )
            (do
                (.throwArity this, 20)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (§ switch (.getRequiredArity this)
            (§ case 0)
            (do
                (ß this.doInvoke(
                    ontoArrayPrepend(___args,
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß this.doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                        ArraySeq'create-1(___args)))
            )
            (§ default )
            (do
                (.throwArity this, 21)
            )
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" ___array, #_"Object..." ___args]
        (let [#_"ISeq" ___ret (ArraySeq'create-1 ___array)]
            (loop-when-recur [#_"int" ___i (ß ___args.length - 1)] (ß ___i >= 0) [(dec ___i)]
                (§ ass ___ret (ß RT'cons(___args[___i], ___ret)))
            )
            ___ret
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'findKey [#_"Object" ___key, #_"ISeq" ___args]
        (while (some? ___args)
            (when (ß ___key == (first ___args))
                (§ return (next ___args))
            )
            (§ ass ___args (RT'next ___args))
            (§ ass ___args (RT'next ___args))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(§ defprotocol Reversible
    #_abstract
    (#_"ISeq" Reversible'''(§ method rseq) [#_"Reversible" this])
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_private
#_closure
(class-ns DefaultComparator (§ implements Comparator)
    (defn #_"DefaultComparator" DefaultComparator'new []
        (hash-map)
    )

    #_method
    (§ defn #_"int" (§ method compare) [#_"DefaultComparator" this, #_"Object" ___o1, #_"Object" ___o2]
        (Util'compare ___o1, ___o2)
    )
)

#_stateless
(class-ns RT
    (def #_"Boolean" RT'T Boolean/TRUE)
    (def #_"Boolean" RT'F Boolean/FALSE)
    (def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (def #_"IPersistentMap" RT'DEFAULT_IMPORTS (ß map(
        (object-array [
            (Symbol'intern-1 "Boolean")                         (§ class Boolean)
            (Symbol'intern-1 "Byte")                            (§ class Byte)
            (Symbol'intern-1 "Character")                       (§ class Character)
            (Symbol'intern-1 "Class")                           (§ class Class)
            (Symbol'intern-1 "ClassLoader")                     (§ class ClassLoader)
            (Symbol'intern-1 "Compiler")                        (§ class Compiler)
            (Symbol'intern-1 "Double")                          (§ class Double)
            (Symbol'intern-1 "Enum")                            (§ class Enum)
            (Symbol'intern-1 "Float")                           (§ class Float)
            (Symbol'intern-1 "InheritableThreadLocal")          (§ class InheritableThreadLocal)
            (Symbol'intern-1 "Integer")                         (§ class Integer)
            (Symbol'intern-1 "Long")                            (§ class Long)
            (Symbol'intern-1 "Math")                            (§ class Math)
            (Symbol'intern-1 "Number")                          (§ class Number)
            (Symbol'intern-1 "Object")                          (§ class Object)
            (Symbol'intern-1 "Package")                         (§ class Package)
            (Symbol'intern-1 "Process")                         (§ class Process)
            (Symbol'intern-1 "ProcessBuilder")                  (§ class ProcessBuilder)
            (Symbol'intern-1 "Runtime")                         (§ class Runtime)
            (Symbol'intern-1 "RuntimePermission")               (§ class RuntimePermission)
            (Symbol'intern-1 "SecurityManager")                 (§ class SecurityManager)
            (Symbol'intern-1 "Short")                           (§ class Short)
            (Symbol'intern-1 "StackTraceElement")               (§ class StackTraceElement)
            (Symbol'intern-1 "StrictMath")                      (§ class StrictMath)
            (Symbol'intern-1 "String")                          (§ class String)
            (Symbol'intern-1 "StringBuffer")                    (§ class StringBuffer)
            (Symbol'intern-1 "StringBuilder")                   (§ class StringBuilder)
            (Symbol'intern-1 "System")                          (§ class System)
            (Symbol'intern-1 "Thread")                          (§ class Thread)
            (Symbol'intern-1 "ThreadGroup")                     (§ class ThreadGroup)
            (Symbol'intern-1 "ThreadLocal")                     (§ class ThreadLocal)
            (Symbol'intern-1 "Throwable")                       (§ class Throwable)
            (Symbol'intern-1 "Void")                            (§ class Void)
            (Symbol'intern-1 "Appendable")                      (§ class Appendable)
            (Symbol'intern-1 "CharSequence")                    (§ class CharSequence)
            (Symbol'intern-1 "Cloneable")                       (§ class Cloneable)
            (Symbol'intern-1 "Comparable")                      (§ class Comparable)
            (Symbol'intern-1 "Iterable")                        (§ class Iterable)
            (Symbol'intern-1 "Readable")                        (§ class Readable)
            (Symbol'intern-1 "Runnable")                        (§ class Runnable)
            (Symbol'intern-1 "Callable")                        (§ class Callable)
            (Symbol'intern-1 "BigInteger")                      (§ class BigInteger)
            (Symbol'intern-1 "BigDecimal")                      (§ class BigDecimal)
            (Symbol'intern-1 "ArithmeticException")             (§ class ArithmeticException)
            (Symbol'intern-1 "ArrayIndexOutOfBoundsException")  (§ class ArrayIndexOutOfBoundsException)
            (Symbol'intern-1 "ArrayStoreException")             (§ class ArrayStoreException)
            (Symbol'intern-1 "ClassCastException")              (§ class ClassCastException)
            (Symbol'intern-1 "ClassNotFoundException")          (§ class ClassNotFoundException)
            (Symbol'intern-1 "CloneNotSupportedException")      (§ class CloneNotSupportedException)
            (Symbol'intern-1 "EnumConstantNotPresentException") (§ class EnumConstantNotPresentException)
            (Symbol'intern-1 "Exception")                       (§ class Exception)
            (Symbol'intern-1 "IllegalAccessException")          (§ class IllegalAccessException)
            (Symbol'intern-1 "IllegalArgumentException")        (§ class IllegalArgumentException)
            (Symbol'intern-1 "IllegalMonitorStateException")    (§ class IllegalMonitorStateException)
            (Symbol'intern-1 "IllegalStateException")           (§ class IllegalStateException)
            (Symbol'intern-1 "IllegalThreadStateException")     (§ class IllegalThreadStateException)
            (Symbol'intern-1 "IndexOutOfBoundsException")       (§ class IndexOutOfBoundsException)
            (Symbol'intern-1 "InstantiationException")          (§ class InstantiationException)
            (Symbol'intern-1 "InterruptedException")            (§ class InterruptedException)
            (Symbol'intern-1 "NegativeArraySizeException")      (§ class NegativeArraySizeException)
            (Symbol'intern-1 "NoSuchFieldException")            (§ class NoSuchFieldException)
            (Symbol'intern-1 "NoSuchMethodException")           (§ class NoSuchMethodException)
            (Symbol'intern-1 "NullPointerException")            (§ class NullPointerException)
            (Symbol'intern-1 "NumberFormatException")           (§ class NumberFormatException)
            (Symbol'intern-1 "RuntimeException")                (§ class RuntimeException)
            (Symbol'intern-1 "SecurityException")               (§ class SecurityException)
            (Symbol'intern-1 "StringIndexOutOfBoundsException") (§ class StringIndexOutOfBoundsException)
            (Symbol'intern-1 "TypeNotPresentException")         (§ class TypeNotPresentException)
            (Symbol'intern-1 "UnsupportedOperationException")   (§ class UnsupportedOperationException)
            (Symbol'intern-1 "AbstractMethodError")             (§ class AbstractMethodError)
            (Symbol'intern-1 "AssertionError")                  (§ class AssertionError)
            (Symbol'intern-1 "ClassCircularityError")           (§ class ClassCircularityError)
            (Symbol'intern-1 "ClassFormatError")                (§ class ClassFormatError)
            (Symbol'intern-1 "Error")                           (§ class Error)
            (Symbol'intern-1 "ExceptionInInitializerError")     (§ class ExceptionInInitializerError)
            (Symbol'intern-1 "IllegalAccessError")              (§ class IllegalAccessError)
            (Symbol'intern-1 "IncompatibleClassChangeError")    (§ class IncompatibleClassChangeError)
            (Symbol'intern-1 "InstantiationError")              (§ class InstantiationError)
            (Symbol'intern-1 "InternalError")                   (§ class InternalError)
            (Symbol'intern-1 "LinkageError")                    (§ class LinkageError)
            (Symbol'intern-1 "NoClassDefFoundError")            (§ class NoClassDefFoundError)
            (Symbol'intern-1 "NoSuchFieldError")                (§ class NoSuchFieldError)
            (Symbol'intern-1 "NoSuchMethodError")               (§ class NoSuchMethodError)
            (Symbol'intern-1 "OutOfMemoryError")                (§ class OutOfMemoryError)
            (Symbol'intern-1 "StackOverflowError")              (§ class StackOverflowError)
            (Symbol'intern-1 "ThreadDeath")                     (§ class ThreadDeath)
            (Symbol'intern-1 "UnknownError")                    (§ class UnknownError)
            (Symbol'intern-1 "UnsatisfiedLinkError")            (§ class UnsatisfiedLinkError)
            (Symbol'intern-1 "UnsupportedClassVersionError")    (§ class UnsupportedClassVersionError)
            (Symbol'intern-1 "VerifyError")                     (§ class VerifyError)
            (Symbol'intern-1 "VirtualMachineError")             (§ class VirtualMachineError)
            (Symbol'intern-1 "Thread$UncaughtExceptionHandler") (§ class Thread$UncaughtExceptionHandler)
            (Symbol'intern-1 "Thread$State")                    (§ class Thread$State)
            (Symbol'intern-1 "Deprecated")                      (§ class Deprecated)
            (Symbol'intern-1 "Override")                        (§ class Override)
            (Symbol'intern-1 "SuppressWarnings")                (§ class SuppressWarnings)
        ])
    )))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (def #_"Charset" RT'UTF8 (Charset/forName "UTF-8"))

    (defn #_"Object" RT'readTrueFalseUnknown [#_"String" ___s]
        (cond (.equals ___s, "true")
            (do
                (§ return Boolean/TRUE)
            )
            (.equals ___s, "false")
            (do
                (§ return Boolean/FALSE)
            )
        )
        (Keyword'intern-2 nil, "unknown")
    )

    (def #_"Namespace" RT'CLOIURE_NS (ß Namespace'findOrCreate(Symbol'intern-1("cloiure.core"))))
    (def #_"Var" RT'OUT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*out*"), (OutputStreamWriter. System/out)).setDynamic()))
    (def #_"Var" RT'IN (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*in*"), LineNumberingPushbackReader'new-1((InputStreamReader. System/in))).setDynamic()))
    (def #_"Var" RT'ERR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*err*"), (PrintWriter. (OutputStreamWriter. System/err), true)).setDynamic()))
    (§ def #_"Keyword" RT'TAG_KEY (Keyword'intern-2 nil, "tag"))
    (§ def #_"Keyword" RT'CONST_KEY (Keyword'intern-2 nil, "const"))
    (def #_"Var" RT'AGENT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*agent*"), nil).setDynamic()))
    (def #_"Object" RT'readeval (ß readTrueFalseUnknown(System/getProperty("cloiure.read.eval", "true"))))
    (def #_"Var" RT'READEVAL (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*read-eval*"), readeval).setDynamic()))
    (def #_"Var" RT'DATA_READERS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*data-readers*"), RT'map()).setDynamic()))
    (def #_"Var" RT'DEFAULT_DATA_READER_FN (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*default-data-reader-fn*"), RT'map()).setDynamic()))
    (def #_"Var" RT'DEFAULT_DATA_READERS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("default-data-readers"), RT'map())))
    (def #_"Var" RT'SUPPRESS_READ (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*suppress-read*"), nil).setDynamic()))
    (def #_"Var" RT'ASSERT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*assert*"), RT'T).setDynamic()))
    (def #_"Var" RT'MATH_CONTEXT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*math-context*"), nil).setDynamic()))
    (§ def #_"Keyword" RT'LINE_KEY (Keyword'intern-2 nil, "line"))
    (§ def #_"Keyword" RT'COLUMN_KEY (Keyword'intern-2 nil, "column"))
    (§ def #_"Keyword" RT'FILE_KEY (Keyword'intern-2 nil, "file"))
    (§ def #_"Keyword" RT'DECLARED_KEY (Keyword'intern-2 nil, "declared"))
    (§ def #_"Keyword" RT'DOC_KEY (Keyword'intern-2 nil, "doc"))
    (def #_"Var" RT'USE_CONTEXT_CLASSLOADER (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*use-context-classloader*"), RT'T).setDynamic()))
    ;; boolean
    (def #_"Var" RT'UNCHECKED_MATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*unchecked-math*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Symbol" RT'LOAD_FILE (Symbol'intern-1 "load-file"))
    (§ def #_"Symbol" RT'IN_NAMESPACE (Symbol'intern-1 "in-ns"))
    (§ def #_"Symbol" RT'NAMESPACE (Symbol'intern-1 "ns"))
    (§ def #_"Symbol" RT'IDENTICAL (Symbol'intern-1 "identical?"))
    (def #_"Var" RT'CMD_LINE_ARGS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*command-line-args*"), nil).setDynamic()))
    ;; symbol
    (def #_"Var" RT'CURRENT_NS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*ns*"), RT'CLOIURE_NS).setDynamic()))

    (def #_"Var" RT'FLUSH_ON_NEWLINE (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*flush-on-newline*"), RT'T).setDynamic()))
    (def #_"Var" RT'PRINT_META (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-meta*"), RT'F).setDynamic()))
    (def #_"Var" RT'PRINT_READABLY (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-readably*"), RT'T).setDynamic()))
    (def #_"Var" RT'PRINT_DUP (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-dup*"), RT'F).setDynamic()))
    (def #_"Var" RT'WARN_ON_REFLECTION (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*warn-on-reflection*"), RT'F).setDynamic()))
    (def #_"Var" RT'ALLOW_UNRESOLVED_VARS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*allow-unresolved-vars*"), RT'F).setDynamic()))
    (def #_"Var" RT'READER_RESOLVER (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*reader-resolver*"), nil).setDynamic()))

    (def #_"Var" RT'IN_NS_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("in-ns"), RT'F)))
    (def #_"Var" RT'NS_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("ns"), RT'F)))
    (def #_"Var" RT'FN_LOADER_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*fn-loader*"), nil).setDynamic()))
    (def #_"Var" RT'PRINT_INITIALIZED (ß Var'intern-2n(RT'CLOIURE_NS, Symbol'intern-1("print-initialized"))))
    (def #_"Var" RT'PR_ON (ß Var'intern-2n(RT'CLOIURE_NS, Symbol'intern-1("pr-on"))))

    (def #_"IFn" RT'inNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (ß (Symbol) ___arg1)]
                    (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsname)]
                        (ß RT'CURRENT_NS.set(___ns))
                        ___ns
                    )
                )
            )
        )
    )

    (def #_"IFn" RT'bootNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" _____form, #_"Object" _____env, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (ß (Symbol) ___arg1)]
                    (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsname)]
                        (ß RT'CURRENT_NS.set(___ns))
                        ___ns
                    )
                )
            )
        )
    )

    (defn #_"List<String>" RT'processCommandLine [#_"String[]" ___args]
        (let [#_"List<String>" ___arglist (Arrays/asList ___args)]
            (let [#_"int" ___split (.indexOf ___arglist, "--")]
                (when (ß ___split >= 0)
                    (ß RT'CMD_LINE_ARGS.bindRoot(RT'seq(___arglist.subList(___split + 1, ___args.length))))
                    (§ return (.subList ___arglist, 0, ___split))
                )
                ___arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" ___w (ß (Writer) RT'ERR.deref())]
            (if (ß ___w instanceof PrintWriter)
                (do
                    (ß (PrintWriter) ___w)
                )
                (do
                    (§ unsure PrintWriter. ___w)
                )
            )
        )
    )

    (def #_"Object[]" RT'EMPTY_ARRAY (make-array Object 0))
    (§ def #_"Comparator" RT'DEFAULT_COMPARATOR (DefaultComparator'new))

    (def #_"AtomicInteger" RT'ID (AtomicInteger. 1))

    (defn #_"void" RT'addURL [#_"Object" ___url] #_(§ throws MalformedURLException)
        (let [#_"URL" ___u (ß (___url instanceof String) ? (URL. (cast String ___url)) :or (cast URL ___url))]
            (let [#_"ClassLoader" ___ccl (ß Thread/currentThread().getContextClassLoader())]
                (if (ß ___ccl instanceof DynamicClassLoader)
                    (do
                        (ß (cast' DynamicClassLoader ___ccl).addURL(___u))
                    )
                    (do
                        (throw (IllegalAccessError. "Context classloader is not a DynamicClassLoader"))
                    )
                )
                nil
            )
        )
    )

    (def #_"boolean" RT'CHECK_SPEC_ASSERTS false #_"cloiure.spec.check-asserts")
    (def #_"boolean" RT'INSTRUMENT_MACROS true #_"cloiure.spec.skip-macros")
    #_volatile
    (def #_"boolean" RT'CHECK_SPECS false)

    (§ static
        (let [#_"Keyword" ___arglistskw (Keyword'intern-2 nil, "arglists")]
            (let [#_"Symbol" ___namesym (Symbol'intern-1 "name")]
                (ß RT'OUT.setTag(Symbol'intern-1("java.io.Writer")))
                (ß RT'CURRENT_NS.setTag(Symbol'intern-1("cloiure.lang.Namespace")))
                (ß RT'AGENT.setMeta(map(RT'DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß RT'AGENT.setTag(Symbol'intern-1("cloiure.lang.Agent")))
                (ß RT'MATH_CONTEXT.setTag(Symbol'intern-1("java.math.MathContext")))
                (let [#_"Var" ___nv (Var'intern-3 RT'CLOIURE_NS, RT'NAMESPACE, bootNamespace)]
                    (.setMacro ___nv)
                    (§ let [#_"Var" ___v]
                        (§ ass ___v (Var'intern-3 RT'CLOIURE_NS, RT'IN_NAMESPACE, inNamespace))
                        (ß ___v.setMeta(map(RT'DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", ___arglistskw, list(vector(___namesym)))))
                        (§ ass ___v (ß Var'intern-3(RT'CLOIURE_NS, RT'LOAD_FILE,
                                (§ reify AFn()
                                    #_method
                                    (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___arg1]
                                        (try
                                            (ß Compiler'loadFile((cast String ___arg1)))
                                            (catch IOException ___e
                                                (throw (Util'sneakyThrow ___e))
                                            )
                                        )
                                    )
                                )
                            ))
                        )
                        (ß ___v.setMeta(map(RT'DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", ___arglistskw, list(vector(___namesym)))))
                        (try
                            (ß doInit())
                            (catch Exception ___e
                                (throw (Util'sneakyThrow ___e))
                            )
                        )

                        (§ ass RT'CHECK_SPECS RT'INSTRUMENT_MACROS)
                    )
                )
            )
        )
    )

    (defn #_"Keyword" RT'keyword [#_"String" ___ns, #_"String" ___name]
        (Keyword'intern (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Var" RT'var-2 [#_"String" ___ns, #_"String" ___name]
        (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-2(nil, ___ns)), Symbol'intern-2(nil, ___name)))
    )

    (defn #_"Var" RT'var-3 [#_"String" ___ns, #_"String" ___name, #_"Object" ___init]
        (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-2(nil, ___ns)), Symbol'intern-2(nil, ___name), ___init))
    )

    (defn #_"void" RT'loadResourceScript-1 [#_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___name, true))
        nil
    )

    (defn #_"void" RT'maybeLoadResourceScript [#_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___name, false))
        nil
    )

    (defn #_"void" RT'loadResourceScript-2s [#_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (ß loadResourceScript((§ class RT), ___name, ___failIfNotFound))
        nil
    )

    (defn #_"void" RT'loadResourceScript-2c [#_"Class" ___c, #_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___c, ___name, true))
        nil
    )

    (defn #_"void" RT'loadResourceScript-3 [#_"Class" ___c, #_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (let [#_"int" ___slash (ß ___name.lastIndexOf(\/))]
            (let [#_"String" ___file (ß (___slash >= 0) ? (ß ___name.substring(___slash + 1)) :or ___name)]
                (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___name))]
                    (cond (some? ___ins)
                        (do
                            (try
                                (Compiler'load-3 (InputStreamReader. ___ins, RT'UTF8), ___name, ___file)
                                (finally
                                    (.close ___ins)
                                )
                            )
                        )
                        ___failIfNotFound
                        (do
                            (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " ___name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (defn #_"long" RT'lastModified [#_"URL" ___url, #_"String" ___libfile] #_(§ throws IOException)
        (let [#_"URLConnection" ___connection (.openConnection ___url)]
            (try
                (if (ß (.getProtocol ___url).equals("jar"))
                    (do
                        (ß (cast JarURLConnection ___connection).getJarFile().getEntry(___libfile).getTime())
                    )
                    (do
                        (.getLastModified ___connection)
                    )
                )
                (finally
                    (let [#_"InputStream" ___ins (.getInputStream ___connection)]
                        (when (some? ___ins)
                            (.close ___ins)
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'compile [#_"String" ___cljfile] #_(§ throws IOException)
        (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___cljfile))]
            (if (some? ___ins)
                (do
                    (try
                        (ß Compiler'compile((InputStreamReader. ___ins, RT'UTF8), ___cljfile, ___cljfile.substring(1 + ___cljfile.lastIndexOf("/"))))
                        (finally
                            (.close ___ins)
                        )
                    )
                )
                (do
                    (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " ___cljfile)))
                )
            )
            nil
        )
    )

    (defn #_"void" RT'load-1 [#_"String" ___scriptbase] #_(§ throws IOException, ClassNotFoundException)
        (RT'load-2 ___scriptbase, true)
        nil
    )

    (defn #_"void" RT'load-2 [#_"String" ___scriptbase, #_"boolean" ___failIfNotFound] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"String" ___classfile (str ___scriptbase RT'LOADER_SUFFIX ".class")]
            (let [#_"String" ___cljfile (str ___scriptbase ".cli")]
                (let [#_"String" ___scriptfile ___cljfile]
                    (let [#_"URL" ___classURL (ß getResource(baseLoader(), ___classfile))]
                        (let [#_"URL" ___cljURL (ß getResource(baseLoader(), ___scriptfile))]
                            (when (nil? ___cljURL)
                                (§ ass ___scriptfile (str ___scriptbase ".clic"))
                                (§ ass ___cljURL (ß getResource(baseLoader(), ___scriptfile)))
                            )
                            (let [#_"boolean" ___loaded false]
                                (when (ß (___classURL != nil && (___cljURL == nil || lastModified(___classURL, ___classfile) > lastModified(___cljURL, ___scriptfile))) || ___classURL == nil)
                                    (try
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (object-array [
                                                RT'CURRENT_NS         (deref RT'CURRENT_NS)
                                                RT'WARN_ON_REFLECTION (deref RT'WARN_ON_REFLECTION)
                                                RT'UNCHECKED_MATH  (deref RT'UNCHECKED_MATH)
                                            ])
                                        )))
                                        (§ ass ___loaded (ß (loadClassForName(___scriptbase.replace(\/, \.) + RT'LOADER_SUFFIX) != nil)))
                                        (finally
                                            (Var'popThreadBindings)
                                        )
                                    )
                                )
                                (cond (and (not ___loaded) (some? ___cljURL))
                                    (do
                                        (if (ß booleanCast(Compiler'COMPILE_FILES.deref()))
                                            (do
                                                (RT'compile ___scriptfile)
                                            )
                                            (do
                                                (ß loadResourceScript((§ class RT), ___scriptfile))
                                            )
                                        )
                                    )
                                    (and (not ___loaded) ___failIfNotFound)
                                    (do
                                        (throw (FileNotFoundException. (String/format "Could not locate %s or %s on classpath.%s", (object-array [ ___classfile, ___cljfile, (if (.contains ___scriptbase, "_") " Please check that namespaces with dashes use underscores in the Cloiure file name." "") ]))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'doInit [] #_(§ throws ClassNotFoundException, IOException)
        (RT'load-1 "cloiure/core")

        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
            (object-array [
                RT'CURRENT_NS         (deref RT'CURRENT_NS)
                RT'WARN_ON_REFLECTION (deref RT'WARN_ON_REFLECTION)
                RT'UNCHECKED_MATH  (deref RT'UNCHECKED_MATH)
            ])
        )))
        (try
            (let [#_"Symbol" ___USER (Symbol'intern-1 "user")]
                (let [#_"Symbol" ___CLOIURE (Symbol'intern-1 "cloiure.core")]
                    (let [#_"Var" ___in_ns (ß var("cloiure.core", "in-ns"))]
                        (let [#_"Var" ___refer (ß var("cloiure.core", "refer"))]
                            (.invoke ___in_ns, ___USER)
                            (.invoke ___refer, ___CLOIURE)
                            (ß maybeLoadResourceScript("user.cli"))

                            ;; start socket servers
                            (let [#_"Var" ___require (ß var("cloiure.core", "require"))]
                                (let [#_"Symbol" ___SERVER (Symbol'intern-1 "cloiure.core.server")]
                                    (.invoke ___require, ___SERVER)
                                    (let [#_"Var" ___start_servers (ß var("cloiure.core.server", "start-servers"))]
                                        (ß ___start_servers.invoke(System/getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
        nil
    )

    (defn #_"int" RT'nextID []
        (.getAndIncrement RT'ID)
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (defn #_"void" RT'loadLibrary [#_"String" ___libname]
        (System/loadLibrary ___libname)
        nil
    )

    (def- #_"int" RT'CHUNK_SIZE 32)

    (defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" ___iter]
        (when (.hasNext ___iter)
            (§ return (ß LazySeq'new-1(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
                            (let [#_"Object[]" ___arr (make-array Object RT'CHUNK_SIZE)]
                                (let [#_"int" ___n 0]
                                    (while (ß (.hasNext ___iter) && ___n < RT'CHUNK_SIZE)
                                        (§ ass (ß ___arr[___n]) (next ___iter))
                                        (§ ass ___n (inc ___n))
                                    )
                                    (ß ChunkedCons'new-2(ArrayChunk'new-3(___arr, 0, ___n), chunkIteratorSeq(___iter)))
                                )
                            )
                        )
                    )
                ))
            )
        )
        nil
    )

    (defn #_"ISeq" RT'seq [#_"Object" ___coll]
        (cond (ß ___coll instanceof ASeq)
            (do
                (ß (ASeq) ___coll)
            )
            (ß ___coll instanceof LazySeq)
            (do
                (ß (cast' LazySeq ___coll).seq())
            )
            :else
            (do
                (RT'seqFrom ___coll)
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (defn #_"ISeq" RT'seqFrom [#_"Object" ___coll]
        (cond (ß ___coll instanceof Seqable)
            (do
                (ß (cast' Seqable ___coll).seq())
            )
            (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof Iterable)
            (do
                (ß chunkIteratorSeq((cast Iterable ___coll).iterator()))
            )
            (.isArray (.getClass ___coll))
            (do
                (ArraySeq'createFromObject ___coll)
            )
            (ß ___coll instanceof CharSequence)
            (do
                (ß StringSeq'create((cast CharSequence ___coll)))
            )
            (ß ___coll instanceof Map)
            (do
                (RT'seq (.entrySet (cast Map ___coll)))
            )
            :else
            (do
                (throw (IllegalArgumentException. (str "Don't know how to create ISeq from: " (.getName (.getClass ___coll)))))
            )
        )
    )

    (defn #_"boolean" RT'canSeq [#_"Object" ___coll]
        (ß ___coll instanceof ISeq
            || ___coll instanceof Seqable
            || ___coll == nil
            || ___coll instanceof Iterable
            || (.getClass ___coll).isArray()
            || ___coll instanceof CharSequence
            || ___coll instanceof Map)
    )

    (defn #_"Iterator" RT'iter [#_"Object" ___coll]
        (cond (ß ___coll instanceof Iterable)
            (do
                (ß (cast Iterable ___coll).iterator())
            )
            (nil? ___coll)
            (do
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_method
                    (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
            (ß ___coll instanceof Map)
            (do
                (ß (cast Map ___coll).entrySet().iterator())
            )
            (ß ___coll instanceof String)
            (do
                (let [#_"String" ___s (ß (String) ___coll)]
                    (§ reify Iterator()
                        (let [#_"int" ___i 0]
                            #_method
                            (§ defn #_"boolean" (§ method hasNext) [#_"Iterator" this]
                                (ß (___i < (.length ___s)))
                            )

                            #_method
                            (§ defn #_"Object" (§ method next) [#_"Iterator" this]
                                (let [_ (.charAt ___s, ___i)]
                                    (§ ass ___i (inc ___i))
                                    _
                                )
                            )

                            #_method
                            (§ defn #_"void" (§ method remove) [#_"Iterator" this]
                                (throw (UnsupportedOperationException.))
                            )
                        )
                    )
                )
            )
            (.isArray (.getClass ___coll))
            (do
                (ArrayIter'createFromObject ___coll)
            )
            :else
            (do
                (ß iter((RT'seq ___coll)))
            )
        )
    )

    (defn #_"Object" RT'seqOrElse [#_"Object" ___o]
        (ß ((RT'seq ___o) == nil) ? nil :or ___o)
    )

    (defn #_"ISeq" RT'keys [#_"Object" ___coll]
        (if (ß ___coll instanceof IPersistentMap)
            (do
                (ß KeySeq'createFromMap((cast' IPersistentMap ___coll)))
            )
            (do
                (ß KeySeq'create((RT'seq ___coll)))
            )
        )
    )

    (defn #_"ISeq" RT'vals [#_"Object" ___coll]
        (if (ß ___coll instanceof IPersistentMap)
            (do
                (ß ValSeq'createFromMap((cast' IPersistentMap ___coll)))
            )
            (do
                (ß ValSeq'create((RT'seq ___coll)))
            )
        )
    )

    (defn #_"IPersistentMap" RT'meta [#_"Object" ___x]
        (when (ß ___x instanceof IMeta)
            (§ return (ß (cast' IMeta ___x).meta()))
        )
        nil
    )

    (defn #_"int" RT'count [#_"Object" ___o]
        (when (ß ___o instanceof Counted)
            (§ return (ß (cast' Counted ___o).count()))
        )
        (ß countFrom(Util'ret1(___o, (§ ass ___o nil))))
    )

    (defn #_"int" RT'countFrom [#_"Object" ___o]
        (cond (nil? ___o)
            (do
                (§ return 0)
            )
            (ß ___o instanceof IPersistentCollection)
            (do
                (let [#_"ISeq" ___s (RT'seq ___o)]
                    (§ ass ___o nil)
                    (let [#_"int" ___i 0]
                        (loop-when-recur [___s ___s] (some? ___s) [(next ___s)]
                            (when (ß ___s instanceof Counted)
                                (§ return (ß ___i + (count ___s)))
                            )
                            (§ ass ___i (inc ___i))
                        )
                        (§ return ___i)
                    )
                )
            )
            (ß ___o instanceof CharSequence)
            (do
                (§ return (ß (cast CharSequence ___o).length()))
            )
            (ß ___o instanceof Collection)
            (do
                (§ return (ß (cast Collection ___o).size()))
            )
            (ß ___o instanceof Map)
            (do
                (§ return (ß (cast Map ___o).size()))
            )
            (ß ___o instanceof Map$Entry)
            (do
                (§ return 2)
            )
            (.isArray (.getClass ___o))
            (do
                (§ return (Array/getLength ___o))
            )
        )

        (throw (UnsupportedOperationException. (str "count not supported on this type: " (.getSimpleName (.getClass ___o)))))
    )

    (defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" ___coll, #_"Object" ___x]
        (when (nil? ___coll)
            (§ return (PersistentList'new-1 ___x))
        )
        (.cons ___coll, ___x)
    )

    (defn #_"ISeq" RT'cons [#_"Object" ___x, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                (PersistentList'new-1 ___x)
            )
            (ß ___coll instanceof ISeq)
            (do
                (ß Cons'new-2(___x, (ISeq) ___coll))
            )
            :else
            (do
                (ß Cons'new-2(___x, (RT'seq ___coll)))
            )
        )
    )

    (defn #_"Object" RT'first [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß (cast' ISeq ___x).first()))
        )
        (let [#_"ISeq" ___seq (RT'seq ___x)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (first ___seq)
        )
    )

    (defn #_"Object" RT'second [#_"Object" ___x]
        (RT'first (RT'next ___x))
    )

    (defn #_"Object" RT'third [#_"Object" ___x]
        (RT'first (RT'next (RT'next ___x)))
    )

    (defn #_"Object" RT'fourth [#_"Object" ___x]
        (RT'first (RT'next (RT'next (RT'next ___x))))
    )

    (defn #_"ISeq" RT'next [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß (cast' ISeq ___x).next()))
        )
        (let [#_"ISeq" ___seq (RT'seq ___x)]
            (when (nil? ___seq)
                (§ return nil)
            )
            (next ___seq)
        )
    )

    (defn #_"ISeq" RT'more [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß (cast' ISeq ___x).more()))
        )
        (let [#_"ISeq" ___seq (RT'seq ___x)]
            (when (nil? ___seq)
                (§ return PersistentList'EMPTY)
            )
            (.more ___seq)
        )
    )

    (defn #_"Object" RT'peek [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (ß (cast' IPersistentStack ___x).peek())
    )

    (defn #_"Object" RT'pop [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (ß (cast' IPersistentStack ___x).pop())
    )

    (defn #_"Object" RT'get-2 [#_"Object" ___coll, #_"Object" ___key]
        (when (ß ___coll instanceof ILookup)
            (§ return (ß (cast' ILookup ___coll).valAt(___key)))
        )
        (ß getFrom(___coll, ___key))
    )

    (defn #_"Object" RT'getFrom-2 [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (§ return (.get ___m, ___key))
                )
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" ___set (ß (IPersistentSet) ___coll)]
                    (§ return (.get ___set, ___key))
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || (.getClass ___coll).isArray()))
            (do
                (let [#_"int" ___n (ß (cast Number ___key).intValue())]
                    (when (ß ___n >= 0 && ___n < RT'count(___coll))
                        (§ return (RT'nth ___coll, ___n))
                    )
                    (§ return nil)
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" ___set (ß (ITransientSet) ___coll)]
                    (§ return (.get ___set, ___key))
                )
            )
        )

        nil
    )

    (defn #_"Object" RT'get-3 [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (when (ß ___coll instanceof ILookup)
            (§ return (ß (cast' ILookup ___coll).valAt(___key, ___notFound)))
        )
        (ß getFrom(___coll, ___key, ___notFound))
    )

    (defn #_"Object" RT'getFrom-3 [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                (§ return ___notFound)
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (when (.containsKey ___m, ___key)
                        (§ return (.get ___m, ___key))
                    )
                    (§ return ___notFound)
                )
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" ___set (ß (IPersistentSet) ___coll)]
                    (when (.contains ___set, ___key)
                        (§ return (.get ___set, ___key))
                    )
                    (§ return ___notFound)
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || (.getClass ___coll).isArray()))
            (do
                (let [#_"int" ___n (ß (cast Number ___key).intValue())]
                    (§ return (ß (___n >= 0 && ___n < RT'count(___coll)) ? RT'nth(___coll, ___n) :or ___notFound))
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" ___set (ß (ITransientSet) ___coll)]
                    (when (.contains ___set, ___key)
                        (§ return (.get ___set, ___key))
                    )
                    (§ return ___notFound)
                )
            )
        )
        ___notFound
    )

    (defn #_"Associative" RT'assoc [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___coll)
            (§ return (PersistentArrayMap'new-1 (object-array [ ___key, ___val ])))
        )
        (ß (cast' Associative ___coll).assoc(___key, ___val))
    )

    (defn #_"Object" RT'contains [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return RT'F)
            )
            (ß ___coll instanceof Associative)
            (do
                (§ return (ß (cast' Associative ___coll).containsKey(___key) ? RT'T :or RT'F))
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (§ return (ß (cast' IPersistentSet ___coll).contains(___key) ? RT'T :or RT'F))
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (§ return (ß ___m.containsKey(___key) ? RT'T :or RT'F))
                )
            )
            (ß ___coll instanceof Set)
            (do
                (let [#_"Set" ___s (ß (Set) ___coll)]
                    (§ return (ß ___s.contains(___key) ? RT'T :or RT'F))
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || (.getClass ___coll).isArray()))
            (do
                (let [#_"int" ___n (ß (cast Number ___key).intValue())]
                    (§ return (ß (___n >= 0 && ___n < RT'count(___coll)) ? RT'T :or RT'F))
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (§ return (ß (cast' ITransientSet ___coll).contains(___key) ? RT'T :or RT'F))
            )
            (ß ___coll instanceof ITransientAssociative2)
            (do
                (§ return (ß ((cast' ITransientAssociative2 ___coll).containsKey(___key)) ? RT'T :or RT'F))
            )
        )
        (throw (IllegalArgumentException. (str "contains? not supported on type: " (.getName (.getClass ___coll)))))
    )

    (defn #_"Object" RT'find [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (ß ___coll instanceof Associative)
            (do
                (§ return (ß (cast' Associative ___coll).entryAt(___key)))
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (when (.containsKey ___m, ___key)
                        (§ return (ß MapEntry'create(___key, ___m.get(___key))))
                    )
                    (§ return nil)
                )
            )
            (ß ___coll instanceof ITransientAssociative2)
            (do
                (§ return (ß (cast' ITransientAssociative2 ___coll).entryAt(___key)))
            )
        )
        (throw (IllegalArgumentException. (str "find not supported on type: " (.getName (.getClass ___coll)))))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (defn #_"ISeq" RT'findKey [#_"Keyword" ___key, #_"ISeq" ___keyvals]
        (while (some? ___keyvals)
            (let [#_"ISeq" ___r (next ___keyvals)]
                (when (nil? ___r)
                    (throw (Util'runtimeException-1 "Malformed keyword argslist"))
                )
                (when (ß (first ___keyvals) == ___key)
                    (§ return ___r)
                )
                (§ ass ___keyvals (next ___r))
            )
        )
        nil
    )

    (defn #_"Object" RT'dissoc [#_"Object" ___coll, #_"Object" ___key]
        (when (nil? ___coll)
            (§ return nil)
        )
        (ß (cast' IPersistentMap ___coll).without(___key))
    )

    (defn #_"Object" RT'nth-2 [#_"Object" ___coll, #_"int" ___n]
        (when (ß ___coll instanceof Indexed)
            (§ return (ß (cast' Indexed ___coll).nth(___n)))
        )
        (ß nthFrom(Util'ret1(___coll, (§ ass ___coll nil)), ___n))
    )

    (defn #_"Object" RT'nthFrom-2 [#_"Object" ___coll, #_"int" ___n]
        (cond (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof CharSequence)
            (do
                (ß Character/valueOf((cast CharSequence ___coll).charAt(___n)))
            )
            (.isArray (.getClass ___coll))
            (do
                (ß Reflector'prepRet((.getClass ___coll).getComponentType(), Array/get(___coll, ___n)))
            )
            (ß ___coll instanceof RandomAccess)
            (do
                (ß (cast List ___coll).get(___n))
            )
            (ß ___coll instanceof Matcher)
            (do
                (ß (cast Matcher ___coll).group(___n))
            )
            (ß ___coll instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___coll)]
                    (cond (ß ___n == 0)
                        (do
                            (§ return (.getKey ___e))
                        )
                        (ß ___n == 1)
                        (do
                            (§ return (.getValue ___e))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            (ß ___coll instanceof Sequential)
            (do
                (let [#_"ISeq" ___seq (RT'seq ___coll)]
                    (§ ass ___coll nil)
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (ß ___i <= ___n && ___seq != nil) [(inc ___i) (next ___seq)]
                        (when (ß ___i == ___n)
                            (§ return (first ___seq))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            :else
            (do
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass ___coll)))))
            )
        )
    )

    (defn #_"Object" RT'nth-3 [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (when (ß ___coll instanceof Indexed)
            (let [#_"Indexed" ___v (ß (Indexed) ___coll)]
                (§ return (.nth ___v, ___n, ___notFound))
            )
        )
        (ß nthFrom(___coll, ___n, ___notFound))
    )

    (defn #_"Object" RT'nthFrom-3 [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                ___notFound
            )
            (< ___n 0)
            (do
                ___notFound
            )
            (ß ___coll instanceof CharSequence)
            (do
                (let [#_"CharSequence" ___s (ß (CharSequence) ___coll)]
                    (when (ß ___n < (.length ___s))
                        (§ return (ß Character/valueOf(___s.charAt(___n))))
                    )
                    ___notFound
                )
            )
            (.isArray (.getClass ___coll))
            (do
                (when (ß ___n < Array/getLength(___coll))
                    (§ return (ß Reflector'prepRet((.getClass ___coll).getComponentType(), Array/get(___coll, ___n))))
                )
                ___notFound
            )
            (ß ___coll instanceof RandomAccess)
            (do
                (let [#_"List" ___list (ß (List) ___coll)]
                    (when (ß ___n < (.size ___list))
                        (§ return (.get ___list, ___n))
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Matcher)
            (do
                (let [#_"Matcher" ___m (ß (Matcher) ___coll)]
                    (when (ß ___n < (.groupCount ___m))
                        (§ return (.group ___m, ___n))
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___coll)]
                    (cond (ß ___n == 0)
                        (do
                            (§ return (.getKey ___e))
                        )
                        (ß ___n == 1)
                        (do
                            (§ return (.getValue ___e))
                        )
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Sequential)
            (do
                (let [#_"ISeq" ___seq (RT'seq ___coll)]
                    (§ ass ___coll nil)
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (ß ___i <= ___n && ___seq != nil) [(inc ___i) (next ___seq)]
                        (when (ß ___i == ___n)
                            (§ return (first ___seq))
                        )
                    )
                    ___notFound
                )
            )
            :else
            (do
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass ___coll)))))
            )
        )
    )

    (defn #_"Object" RT'assocN [#_"int" ___n, #_"Object" ___val, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof IPersistentVector)
            (do
                (ß (cast' IPersistentVector ___coll).assocN(___n, ___val))
            )
            (ß ___coll instanceof Object[])
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" ___array (ß ((Object[]) ___coll))]
                    (§ ass (ß ___array[___n]) ___val)
                    ___array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (defn #_"boolean" RT'hasTag [#_"Object" ___o, #_"Object" ___tag]
        (ß Util'equals(___tag, RT'get-2(RT'meta(___o), RT'TAG_KEY)))
    )

    (defn #_"Object" RT'box-1o [#_"Object" ___x]
        ___x
    )

    (defn #_"Character" RT'box-1c [#_"char" ___x]
        (Character/valueOf ___x)
    )

    (defn #_"Object" RT'box-1z [#_"boolean" ___x]
        (if ___x RT'T RT'F)
    )

    (defn #_"Object" RT'box-1Z [#_"Boolean" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1s [#_"short" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1i [#_"int" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1l [#_"long" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1f [#_"float" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1d [#_"double" ___x]
        ___x
    )

    (defn #_"char" RT'charCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Character)
            (§ return (ß (cast Character ___x).charValue()))
        )
        (let [#_"long" ___n (ß (cast Number ___x).longValue())]
            (when (ß ___n < Character/MIN_VALUE || ___n > Character/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            (ß (char) ___n)
        )
    )

    (defn #_"char" RT'charCast-1b [#_"byte" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1s [#_"short" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"char" RT'charCast-1i [#_"int" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1l [#_"long" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1f [#_"float" ___x]
        (when (ß ___x >= Character/MIN_VALUE && ___x <= Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
    )

    (defn #_"char" RT'charCast-1d [#_"double" ___x]
        (when (ß ___x >= Character/MIN_VALUE && ___x <= Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
    )

    (defn #_"boolean" RT'booleanCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Boolean)
            (§ return (ß (cast Boolean ___x).booleanValue()))
        )
        (ß ___x != nil)
    )

    (defn #_"boolean" RT'booleanCast-1b [#_"boolean" ___x]
        ___x
    )

    (defn #_"byte" RT'byteCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Byte)
            (§ return (ß (cast Byte ___x).byteValue()))
        )
        (let [#_"long" ___n (ß longCast(___x))]
            (when (ß ___n < Byte/MIN_VALUE || ___n > Byte/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            (ß (byte) ___n)
        )
    )

    (defn #_"byte" RT'byteCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"byte" RT'byteCast-1s [#_"short" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1i [#_"int" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1l [#_"long" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1f [#_"float" ___x]
        (when (ß ___x >= Byte/MIN_VALUE && ___x <= Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
    )

    (defn #_"byte" RT'byteCast-1d [#_"double" ___x]
        (when (ß ___x >= Byte/MIN_VALUE && ___x <= Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
    )

    (defn #_"short" RT'shortCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Short)
            (§ return (ß (cast Short ___x).shortValue()))
        )
        (let [#_"long" ___n (ß longCast(___x))]
            (when (ß ___n < Short/MIN_VALUE || ___n > Short/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            (ß (short) ___n)
        )
    )

    (defn #_"short" RT'shortCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"short" RT'shortCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"short" RT'shortCast-1i [#_"int" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            ___i
        )
    )

    (defn #_"short" RT'shortCast-1l [#_"long" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            ___i
        )
    )

    (defn #_"short" RT'shortCast-1f [#_"float" ___x]
        (when (ß ___x >= Short/MIN_VALUE && ___x <= Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
    )

    (defn #_"short" RT'shortCast-1d [#_"double" ___x]
        (when (ß ___x >= Short/MIN_VALUE && ___x <= Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
    )

    (defn #_"int" RT'intCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Integer)
            (§ return (ß (cast Integer ___x).intValue()))
        )
        (when (ß ___x instanceof Number)
            (let [#_"long" ___n (ß longCast(___x))]
                (§ return (ß intCast(___n)))
            )
        )
        (ß (cast Character ___x).charValue())
    )

    (defn #_"int" RT'intCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1f [#_"float" ___x]
        (when (ß ___x < Integer/MIN_VALUE || ___x > Integer/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
        )
        (ß (int) ___x)
    )

    (defn #_"int" RT'intCast-1l [#_"long" ___x]
        (let [#_"int" ___i (ß (int) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
            )
            ___i
        )
    )

    (defn #_"int" RT'intCast-1d [#_"double" ___x]
        (when (ß ___x < Integer/MIN_VALUE || ___x > Integer/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
        )
        (ß (int) ___x)
    )

    (defn #_"long" RT'longCast-1o [#_"Object" ___x]
        (cond (ß ___x instanceof Integer || ___x instanceof Long)
            (do
                (ß (cast Number ___x).longValue())
            )
            (ß ___x instanceof BigInt)
            (do
                (let [#_"BigInt" ___bi (ß (BigInt) ___x)]
                    (if (ß (:bipart ___bi) == nil)
                        (do
                            (:lpart ___bi)
                        )
                        (do
                            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
                        )
                    )
                )
            )
            (ß ___x instanceof BigInteger)
            (do
                (let [#_"BigInteger" ___bi (ß (BigInteger) ___x)]
                    (if (ß (.bitLength ___bi) < 64)
                        (do
                            (.longValue ___bi)
                        )
                        (do
                            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
                        )
                    )
                )
            )
            (ß ___x instanceof Byte || ___x instanceof Short)
            (do
                (ß (cast Number ___x).longValue())
            )
            (ß ___x instanceof Ratio)
            (do
                (ß longCast((cast' Ratio ___x).bigIntegerValue()))
            )
            (ß ___x instanceof Character)
            (do
                (ß longCast((cast Character ___x).charValue()))
            )
            :else
            (do
                (ß longCast((cast Number ___x).doubleValue()))
            )
        )
    )

    (defn #_"long" RT'longCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1f [#_"float" ___x]
        (when (ß ___x < Long/MIN_VALUE || ___x > Long/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
        )
        (ß (long) ___x)
    )

    (defn #_"long" RT'longCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1d [#_"double" ___x]
        (when (ß ___x < Long/MIN_VALUE || ___x > Long/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
        )
        (ß (long) ___x)
    )

    (defn #_"float" RT'floatCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Float)
            (§ return (ß (cast Float ___x).floatValue()))
        )
        (let [#_"double" ___n (ß (cast Number ___x).doubleValue())]
            (when (ß ___n < -Float/MAX_VALUE || ___n > Float/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for float: " ___x)))
            )
            (ß (float) ___n)
        )
    )

    (defn #_"float" RT'floatCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1d [#_"double" ___x]
        (when (ß ___x < -Float/MAX_VALUE || ___x > Float/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for float: " ___x)))
        )
        (ß (float) ___x)
    )

    (defn #_"double" RT'doubleCast-1o [#_"Object" ___x]
        (ß (cast Number ___x).doubleValue())
    )

    (defn #_"double" RT'doubleCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1d [#_"double" ___x]
        ___x
    )

    (defn #_"byte" RT'uncheckedByteCast-1o [#_"Object" ___x]
        (ß (cast Number ___x).byteValue())
    )

    (defn #_"byte" RT'uncheckedByteCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"byte" RT'uncheckedByteCast-1s [#_"short" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1i [#_"int" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1l [#_"long" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1f [#_"float" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1d [#_"double" ___x]
        (ß (byte) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1o [#_"Object" ___x]
        (ß (cast Number ___x).shortValue())
    )

    (defn #_"short" RT'uncheckedShortCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"short" RT'uncheckedShortCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"short" RT'uncheckedShortCast-1i [#_"int" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1l [#_"long" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1f [#_"float" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1d [#_"double" ___x]
        (ß (short) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Character)
            (§ return (ß (cast Character ___x).charValue()))
        )
        (ß (char) (cast Number ___x).longValue())
    )

    (defn #_"char" RT'uncheckedCharCast-1b [#_"byte" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1s [#_"short" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"char" RT'uncheckedCharCast-1i [#_"int" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1l [#_"long" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1f [#_"float" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1d [#_"double" ___x]
        (ß (char) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Number)
            (§ return (ß (cast Number ___x).intValue()))
        )
        (ß (cast Character ___x).charValue())
    )

    (defn #_"int" RT'uncheckedIntCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1l [#_"long" ___x]
        (ß (int) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1f [#_"float" ___x]
        (ß (int) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1d [#_"double" ___x]
        (ß (int) ___x)
    )

    (defn #_"long" RT'uncheckedLongCast-1o [#_"Object" ___x]
        (ß (cast Number ___x).longValue())
    )

    (defn #_"long" RT'uncheckedLongCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1f [#_"float" ___x]
        (ß (long) ___x)
    )

    (defn #_"long" RT'uncheckedLongCast-1d [#_"double" ___x]
        (ß (long) ___x)
    )

    (defn #_"float" RT'uncheckedFloatCast-1o [#_"Object" ___x]
        (ß (cast Number ___x).floatValue())
    )

    (defn #_"float" RT'uncheckedFloatCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1d [#_"double" ___x]
        (ß (float) ___x)
    )

    (defn #_"double" RT'uncheckedDoubleCast-1o [#_"Object" ___x]
        (ß (cast Number ___x).doubleValue())
    )

    (defn #_"double" RT'uncheckedDoubleCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1d [#_"double" ___x]
        ___x
    )

    (defn #_"IPersistentMap" RT'map [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return PersistentArrayMap'EMPTY)
            )
            (ß ___init.length <= PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap'createWithCheck ___init))
            )
        )
        (PersistentHashMap'createWithCheck-1a ___init)
    )

    (defn #_"IPersistentMap" RT'mapUniqueKeys [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return PersistentArrayMap'EMPTY)
            )
            (ß ___init.length <= PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap'new-1 ___init))
            )
        )
        (PersistentHashMap'create-1a ___init)
    )

    (defn #_"IPersistentSet" RT'set [#_"Object..." ___init]
        (PersistentHashSet'createWithCheck-1a ___init)
    )

    (defn #_"IPersistentVector" RT'vector [#_"Object..." ___init]
        (LazilyPersistentVector'createOwning ___init)
    )

    (defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (when (ß ___end < ___start || ___start < 0 || ___end > (count ___v))
            (throw (IndexOutOfBoundsException.))
        )
        (when (ß ___start == ___end)
            (§ return PersistentVector'EMPTY)
        )
        (SubVector'new nil, ___v, ___start, ___end)
    )

    (defn #_"ISeq" RT'list-0 []
        nil
    )

    (defn #_"ISeq" RT'list-1 [#_"Object" ___arg1]
        (PersistentList'new-1 ___arg1)
    )

    (defn #_"ISeq" RT'list-2 [#_"Object" ___arg1, #_"Object" ___arg2]
        (ß listStar(___arg1, ___arg2, nil))
    )

    (defn #_"ISeq" RT'list-3 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß listStar(___arg1, ___arg2, ___arg3, nil))
    )

    (defn #_"ISeq" RT'list-4 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß listStar(___arg1, ___arg2, ___arg3, ___arg4, nil))
    )

    (defn #_"ISeq" RT'list-5 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß listStar(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, nil))
    )

    (defn #_"ISeq" RT'listStar-2 [#_"Object" ___arg1, #_"ISeq" ___rest]
        (ß (ISeq) RT'cons(___arg1, ___rest))
    )

    (defn #_"ISeq" RT'listStar-3 [#_"Object" ___arg1, #_"Object" ___arg2, #_"ISeq" ___rest]
        (ß (ISeq) RT'cons(___arg1, RT'cons(___arg2, ___rest)))
    )

    (defn #_"ISeq" RT'listStar-4 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"ISeq" ___rest]
        (ß (ISeq) RT'cons(___arg1, RT'cons(___arg2, RT'cons(___arg3, ___rest))))
    )

    (defn #_"ISeq" RT'listStar-5 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"ISeq" ___rest]
        (ß (ISeq) RT'cons(___arg1, RT'cons(___arg2, RT'cons(___arg3, RT'cons(___arg4, ___rest)))))
    )

    (defn #_"ISeq" RT'listStar-6 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"ISeq" ___rest]
        (ß (ISeq) RT'cons(___arg1, RT'cons(___arg2, RT'cons(___arg3, RT'cons(___arg4, RT'cons(___arg5, ___rest))))))
    )

    (defn #_"ISeq" RT'arrayToList [#_"Object[]" ___a]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [#_"int" ___i (ß ___a.length - 1)] (ß ___i >= 0) [(dec ___i)]
                (§ ass ___ret (ß (ISeq) RT'cons(___a[___i], ___ret)))
            )
            ___ret
        )
    )

    (defn #_"Object[]" RT'object_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (make-array Object (ß (cast Number ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"Object[]" ___ret (make-array Object ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (next ___s)]
                                (§ ass (ß ___ret[___i]) (first ___s))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object[]" RT'toArray [#_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                RT'EMPTY_ARRAY
            )
            (ß ___coll instanceof Object[])
            (do
                (ß (Object[]) ___coll)
            )
            (ß ___coll instanceof Collection)
            (do
                (ß (cast Collection ___coll).toArray())
            )
            (ß ___coll instanceof Iterable)
            (do
                (let [#_"ArrayList" ___ret (ArrayList.)]
                    (doseq [#_"Object" ___o (ß (Iterable)___coll)]
                        (.add ___ret, ___o)
                    )
                    (.toArray ___ret)
                )
            )
            (ß ___coll instanceof Map)
            (do
                (ß (cast Map ___coll).entrySet().toArray())
            )
            (ß ___coll instanceof String)
            (do
                (let [#_"char[]" ___chars (ß (cast String ___coll).toCharArray())]
                    (let [#_"Object[]" ___ret (make-array Object (ß ___chars.length))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___chars.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) (ß ___chars[___i]))
                        )
                        ___ret
                    )
                )
            )
            (.isArray (.getClass ___coll))
            (do
                (let [#_"ISeq" ___s (RT'seq ___coll)]
                    (let [#_"Object[]" ___ret (make-array Object (RT'count ___s))]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___ret.length) [(inc ___i) (next ___s)]
                            (§ ass (ß ___ret[___i]) (first ___s))
                        )
                        ___ret
                    )
                )
            )
            :else
            (do
                (throw (Util'runtimeException-1 (str "Unable to convert: " (.getClass ___coll) " to Object[]")))
            )
        )
    )

    (defn #_"Object[]" RT'seqToArray [#_"ISeq" ___seq]
        (let [#_"int" ___len (RT'length ___seq)]
            (let [#_"Object[]" ___ret (make-array Object ___len)]
                (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                    (§ ass (ß ___ret[___i]) (first ___seq))
                )
                ___ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" ___seq, #_"Object[]" ___passed]
        (let [#_"Object[]" ___dest ___passed]
            (let [#_"int" ___len (RT'count ___seq)]
                (when (ß ___len > ___dest.length)
                    (§ ass ___dest (ß (Object[]) Array/newInstance((.getClass ___passed).getComponentType(), ___len)))
                )
                (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                    (§ ass (ß ___dest[___i]) (first ___seq))
                )
                (when (ß ___len < ___passed.length)
                    (§ ass (ß ___dest[___len]) nil)
                )
                ___dest
            )
        )
    )

    (defn #_"Object" RT'seqToTypedArray-1 [#_"ISeq" ___seq]
        (let [#_"Class" ___type (ß (___seq != nil && (first ___seq) != nil) ? (first ___seq).getClass() :or (§ class Object))]
            (ß seqToTypedArray(___type, ___seq))
        )
    )

    (defn #_"Object" RT'seqToTypedArray-2 [#_"Class" ___type, #_"ISeq" ___seq]
        (let [#_"Object" ___ret (ß Array/newInstance(___type, RT'length(___seq)))]
            (cond (ß ___type == Integer/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, intCast((first ___seq))))
                    )
                )
                (ß ___type == Byte/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, byteCast((first ___seq))))
                    )
                )
                (ß ___type == Float/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, floatCast((first ___seq))))
                    )
                )
                (ß ___type == Short/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, shortCast((first ___seq))))
                    )
                )
                (ß ___type == Character/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, charCast((first ___seq))))
                    )
                )
                :else
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (next ___seq)]
                        (ß Array/set(___ret, ___i, (first ___seq)))
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"int" RT'length [#_"ISeq" ___list]
        (let [#_"int" ___i 0]
            (loop-when-recur [#_"ISeq" ___c ___list] (some? ___c) [(next ___c)]
                (§ ass ___i (inc ___i))
            )
            ___i
        )
    )

    (defn #_"int" RT'boundedLength [#_"ISeq" ___list, #_"int" ___limit]
        (let [#_"int" ___i 0]
            (loop-when-recur [#_"ISeq" ___c ___list] (ß ___c != nil && ___i <= ___limit) [(next ___c)]
                (§ ass ___i (inc ___i))
            )
            ___i
        )
    )

    (defn #_"Character" RT'readRet [#_"int" ___ret]
        (when (ß ___ret == -1)
            (§ return nil)
        )
        (ß box((char) ___ret))
    )

    (defn #_"Character" RT'readChar [#_"Reader" ___r] #_(§ throws IOException)
        (let [#_"int" ___ret (.read ___r)]
            (ß readRet(___ret))
        )
    )

    (defn #_"Character" RT'peekChar [#_"Reader" ___r] #_(§ throws IOException)
        (§ let [#_"int" ___ret]
            (if (ß ___r instanceof PushbackReader)
                (do
                    (§ ass ___ret (.read ___r))
                    (ß (cast PushbackReader ___r).unread(___ret))
                )
                (do
                    (.mark ___r, 1)
                    (§ ass ___ret (.read ___r))
                    (.reset ___r)
                )
            )

            (ß readRet(___ret))
        )
    )

    (defn #_"int" RT'getLineNumber [#_"Reader" ___r]
        (when (ß ___r instanceof LineNumberingPushbackReader)
            (§ return (ß (cast' LineNumberingPushbackReader ___r).getLineNumber()))
        )
        0
    )

    (defn #_"int" RT'getColumnNumber [#_"Reader" ___r]
        (when (ß ___r instanceof LineNumberingPushbackReader)
            (§ return (ß (cast' LineNumberingPushbackReader ___r).getColumnNumber()))
        )
        0
    )

    (defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" ___r]
        (when (ß isLineNumberingReader(___r))
            (§ return (ß (LineNumberingPushbackReader) ___r))
        )
        (LineNumberingPushbackReader'new-1 ___r)
    )

    (defn #_"boolean" RT'isLineNumberingReader [#_"Reader" ___r]
        (ß ___r instanceof LineNumberingPushbackReader)
    )

    (defn #_"boolean" RT'isReduced [#_"Object" ___r]
        (ß ___r instanceof Reduced)
    )

    (defn #_"String" RT'resolveClassNameInContext [#_"String" ___className]
        ;; todo - look up in context var
        ___className
    )

    (defn #_"boolean" RT'suppressRead []
        (ß booleanCast(RT'SUPPRESS_READ.deref()))
    )

    (defn #_"String" RT'printString [#_"Object" ___x]
        (try
            (let [#_"StringWriter" ___sw (StringWriter.)]
                (ß print(___x, ___sw))
                (.toString ___sw)
            )
            (catch Exception ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (defn #_"Object" RT'readString-1 [#_"String" ___s]
        (ß readString(___s, nil))
    )

    (defn #_"Object" RT'readString-2 [#_"String" ___s, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (PushbackReader. (StringReader. ___s))]
            (LispReader'read-2 ___r, ___opts)
        )
    )

    (defn #_"void" RT'print [#_"Object" ___x, #_"Writer" ___w] #_(§ throws IOException)
        ;; call multimethod
        (if (ß RT'PRINT_INITIALIZED.isBound() && RT'booleanCast-1o(RT'PRINT_INITIALIZED.deref()))
            (do
                (ß RT'PR_ON.invoke(___x, ___w))
            )
            (do
                (let [#_"boolean" ___readably (ß booleanCast(RT'PRINT_READABLY.deref()))]
                    (when (ß ___x instanceof Obj)
                        (let [#_"Obj" ___o (ß (Obj) ___x)]
                            (when (ß RT'count((.meta ___o)) > 0 && ((___readably && booleanCast(RT'PRINT_META.deref())) || booleanCast(RT'PRINT_DUP.deref())))
                                (let [#_"IPersistentMap" ___meta (.meta ___o)]
                                    (.write ___w, "#^")
                                    (if (ß (count ___meta) == 1 && ___meta.containsKey(RT'TAG_KEY))
                                        (do
                                            (ß print(___meta.valAt(RT'TAG_KEY), ___w))
                                        )
                                        (do
                                            (ß print(___meta, ___w))
                                        )
                                    )
                                    (ß ___w.write(\space))
                                )
                            )
                        )
                    )
                    (cond (nil? ___x)
                        (do
                            (.write ___w, "nil")
                        )
                        (ß ___x instanceof ISeq || ___x instanceof IPersistentList)
                        (do
                            (ß ___w.write(\())
                            (ß printInnerSeq(RT'seq(___x), ___w))
                            (.write ___w, \))
                        )
                        (ß ___x instanceof String)
                        (do
                            (let [#_"String" ___s (ß (String) ___x)]
                                (if (not ___readably)
                                    (do
                                        (.write ___w, ___s)
                                    )
                                    (do
                                        (ß ___w.write(\")) ;; oops! "
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (.length ___s)) [(inc ___i)]
                                            (let [#_"char" ___c (.charAt ___s, ___i)]
                                                (§ switch ___c
                                                    (§ case \newline)
                                                    (do
                                                        (.write ___w, "\\n")
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (.write ___w, "\\t")
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (.write ___w, "\\r")
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß ___w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (.write ___w, "\\\\")
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (.write ___w, "\\f")
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (.write ___w, "\\b")
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (.write ___w, ___c)
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß ___w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (ß ___x instanceof IPersistentMap)
                        (do
                            (ß ___w.write(\{))
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___x)] (some? ___s) [(next ___s)]
                                (let [#_"IMapEntry" ___e (ß (IMapEntry) (first ___s))]
                                    (ß print((.key ___e), ___w))
                                    (ß ___w.write(\space))
                                    (ß print((.val ___e), ___w))
                                    (when (ß (next ___s) != nil)
                                        (.write ___w, ", ")
                                    )
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (ß ___x instanceof IPersistentVector)
                        (do
                            (let [#_"IPersistentVector" ___a (ß (IPersistentVector) ___x)]
                                (ß ___w.write(\[))
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (count ___a)) [(inc ___i)]
                                    (ß print(___a.nth(___i), ___w))
                                    (when (ß ___i < (count ___a) - 1)
                                        (ß ___w.write(\space))
                                    )
                                )
                                (ß ___w.write(\]))
                            )
                        )
                        (ß ___x instanceof IPersistentSet)
                        (do
                            (.write ___w, "#{")
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___x)] (some? ___s) [(next ___s)]
                                (ß print((first ___s), ___w))
                                (when (ß (next ___s) != nil)
                                    (.write ___w, " ")
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (ß ___x instanceof Character)
                        (do
                            (let [#_"char" ___c (ß (cast Character ___x).charValue())]
                                (if (not ___readably)
                                    (do
                                        (.write ___w, ___c)
                                    )
                                    (do
                                        (.write ___w, \\)
                                        (§ switch ___c
                                            (§ case \newline)
                                            (do
                                                (.write ___w, "newline")
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (.write ___w, "tab")
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (.write ___w, "space")
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (.write ___w, "backspace")
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (.write ___w, "formfeed")
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (.write ___w, "return")
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (.write ___w, ___c)
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß ___x instanceof Class)
                        (do
                            (.write ___w, "#=")
                            (ß ___w.write((cast Class ___x).getName()))
                        )
                        (ß ___x instanceof BigDecimal && ___readably)
                        (do
                            (ß ___w.write((.toString ___x)))
                            (ß ___w.write(\M))
                        )
                        (ß ___x instanceof BigInt && ___readably)
                        (do
                            (ß ___w.write((.toString ___x)))
                            (ß ___w.write(\N))
                        )
                        (ß ___x instanceof BigInteger && ___readably)
                        (do
                            (ß ___w.write((.toString ___x)))
                            (.write ___w, "BIGINT")
                        )
                        (ß ___x instanceof Var)
                        (do
                            (let [#_"Var" ___v (ß (Var) ___x)]
                                (.write ___w, (str "#=(var " (:name (:ns ___v)) "/" (:sym ___v) ")"))
                            )
                        )
                        (ß ___x instanceof Pattern)
                        (do
                            (let [#_"Pattern" ___p (ß (Pattern) ___x)]
                                (.write ___w, (str "#\"" (.pattern ___p) "\""))
                            )
                        )
                        :else
                        (do
                            (ß ___w.write((.toString ___x)))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" RT'printInnerSeq [#_"ISeq" ___x, #_"Writer" ___w] #_(§ throws IOException)
        (loop-when-recur [#_"ISeq" ___s ___x] (some? ___s) [(next ___s)]
            (ß print((first ___s), ___w))
            (when (ß (next ___s) != nil)
                (ß ___w.write(\space))
            )
        )
        nil
    )

    (defn #_"void" RT'formatAesthetic [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (if (nil? ___obj)
            (do
                (.write ___w, "nil")
            )
            (do
                (ß ___w.write((.toString ___obj)))
            )
        )
        nil
    )

    (defn #_"void" RT'formatStandard [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (cond (nil? ___obj)
            (do
                (.write ___w, "nil")
            )
            (ß ___obj instanceof String)
            (do
                (ß ___w.write(\")) ;; oops! "
                (ß ___w.write((cast String ___obj)))
                (ß ___w.write(\")) ;; oops! "
            )
            (ß ___obj instanceof Character)
            (do
                (.write ___w, \\)
                (let [#_"char" ___c (ß (cast Character ___obj).charValue())]
                    (§ switch ___c
                        (§ case \newline)
                        (do
                            (.write ___w, "newline")
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (.write ___w, "tab")
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (.write ___w, "space")
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (.write ___w, "backspace")
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (.write ___w, "formfeed")
                            (§ break )
                        )
                        (§ default )
                        (do
                            (.write ___w, ___c)
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (ß ___w.write((.toString ___obj)))
            )
        )
        nil
    )

    (defn #_"Object" RT'format [#_"Object" ___o, #_"String" ___s, #_"Object..." ___args] #_(§ throws IOException)
        (§ let [#_"Writer" ___w]
            (cond (nil? ___o)
                (do
                    (§ ass ___w (StringWriter.))
                )
                (Util'equals ___o, RT'T)
                (do
                    (§ ass ___w (ß (Writer) RT'OUT.deref()))
                )
                :else
                (do
                    (§ ass ___w (ß (Writer) ___o))
                )
            )
            (ß doFormat(___w, ___s, ArraySeq'create-1(___args)))
            (when (nil? ___o)
                (§ return (.toString ___w))
            )
            nil
        )
    )

    (defn #_"ISeq" RT'doFormat [#_"Writer" ___w, #_"String" ___s, #_"ISeq" ___args] #_(§ throws IOException)
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (.length ___s)) [___i]
            (let [#_"char" ___c (.charAt ___s, ___i)]
                (§ ass ___i (inc ___i))
                (§ switch (Character/toLowerCase ___c)
                    (§ case \~)
                    (do
                        (let [#_"char" ___d (.charAt ___s, ___i)]
                            (§ ass ___i (inc ___i))
                            (§ switch (Character/toLowerCase ___d)
                                (§ case \%)
                                (do
                                    (ß ___w.write(\newline))
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (ß ___w.write(\tab))
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatAesthetic(___w, RT'first(___args)))
                                    (§ ass ___args (RT'next ___args))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatStandard(___w, RT'first(___args)))
                                    (§ ass ___args (RT'next ___args))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" ___j (.indexOf ___s, "~}", ___i)] ;; note - does not nest
                                        (when (ß ___j == -1)
                                            (throw (IllegalArgumentException. "Missing ~}"))
                                        )
                                        (let [#_"String" ___subs (.substring ___s, ___i, ___j)]
                                            (loop-when-recur [#_"ISeq" ___sargs (ß RT'seq(RT'first(___args)))] (some? ___sargs) [___sargs]
                                                (§ ass ___sargs (ß doFormat(___w, ___subs, ___sargs)))
                                            )
                                            (§ ass ___args (RT'next ___args))
                                            (§ ass ___i (+ ___j 2)) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (nil? ___args)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß ___w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (IllegalArgumentException. (str "Unsupported ~ directive: " ___d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (.write ___w, ___c)
                        (§ break )
                    )
                )
            )
        )
        ___args
    )

    (defn #_"Object[]" RT'setValues [#_"Object..." ___vals]
        (when (ß ___vals.length > 0)
            (§ return ___vals)
        )
        nil
    )

    (defn #_"ClassLoader" RT'makeClassLoader []
        (ß (ClassLoader) AccessController/doPrivileged(
                (§ reify PrivilegedAction()
                    #_method
                    (§ defn #_"Object" (§ method run) [#_"PrivilegedAction" this]
                        (try
                            (ß Var'pushThreadBindings(RT'map(RT'USE_CONTEXT_CLASSLOADER, RT'T)))
                            (ß DynamicClassLoader'new-1(baseLoader()))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"ClassLoader" RT'baseLoader []
        (cond (.isBound Compiler'LOADER)
            (do
                (§ return (ß (ClassLoader) Compiler'LOADER.deref()))
            )
            (ß booleanCast(RT'USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread/currentThread().getContextClassLoader()))
            )
        )
        (ß (§ class Compiler).getClassLoader())
    )

    (defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ClassLoader/getSystemResourceAsStream ___name)
            )
            (do
                (.getResourceAsStream ___loader, ___name)
            )
        )
    )

    (defn #_"URL" RT'getResource [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ClassLoader/getSystemResource ___name)
            )
            (do
                (.getResource ___loader, ___name)
            )
        )
    )

    (defn #_"Class" RT'classForName-3 [#_"String" ___name, #_"boolean" ___load, #_"ClassLoader" ___loader]
        (try
            (let [#_"Class" ___c nil]
                (when (not (ß ___loader instanceof DynamicClassLoader))
                    (§ ass ___c (DynamicClassLoader'findInMemoryClass ___name))
                )
                (when (some? ___c)
                    (§ return ___c)
                )
                (Class/forName ___name, ___load, ___loader)
            )
            (catch ClassNotFoundException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (defn #_"Class" RT'classForName-1 [#_"String" ___name]
        (ß classForName(___name, true, baseLoader()))
    )

    (defn #_"Class" RT'classForNameNonLoading [#_"String" ___name]
        (ß classForName(___name, false, baseLoader()))
    )

    (defn #_"Class" RT'loadClassForName [#_"String" ___name]
        (try
            (ß classForNameNonLoading(___name))
            (catch Exception ___e
                (if (ß ___e instanceof ClassNotFoundException)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
        )
        (ß classForName(___name))
    )

    (defn #_"float" RT'aget-2f [#_"float[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"float" RT'aset-3f [#_"float[]" ___xs, #_"int" ___i, #_"float" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1f [#_"float[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"float[]" RT'aclone-1f [#_"float[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"double" RT'aget-2d [#_"double[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"double" RT'aset-3d [#_"double[]" ___xs, #_"int" ___i, #_"double" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1d [#_"double[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"double[]" RT'aclone-1d [#_"double[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"int" RT'aget-2i [#_"int[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"int" RT'aset-3i [#_"int[]" ___xs, #_"int" ___i, #_"int" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1i [#_"int[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"int[]" RT'aclone-1i [#_"int[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"long" RT'aget-2l [#_"long[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"long" RT'aset-3l [#_"long[]" ___xs, #_"int" ___i, #_"long" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1l [#_"long[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"long[]" RT'aclone-1l [#_"long[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"char" RT'aget-2c [#_"char[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"char" RT'aset-3c [#_"char[]" ___xs, #_"int" ___i, #_"char" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1c [#_"char[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"char[]" RT'aclone-1c [#_"char[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"byte" RT'aget-2b [#_"byte[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"byte" RT'aset-3b [#_"byte[]" ___xs, #_"int" ___i, #_"byte" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1b [#_"byte[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"byte[]" RT'aclone-1b [#_"byte[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"short" RT'aget-2s [#_"short[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"short" RT'aset-3s [#_"short[]" ___xs, #_"int" ___i, #_"short" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1s [#_"short[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"short[]" RT'aclone-1s [#_"short[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"boolean" RT'aget-2z [#_"boolean[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"boolean" RT'aset-3z [#_"boolean[]" ___xs, #_"int" ___i, #_"boolean" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1z [#_"boolean[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"boolean[]" RT'aclone-1z [#_"boolean[]" ___xs]
        (.clone ___xs)
    )

    (defn #_"Object" RT'aget-2o [#_"Object[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"Object" RT'aset-3o [#_"Object[]" ___xs, #_"int" ___i, #_"Object" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1o [#_"Object[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"Object[]" RT'aclone-1o [#_"Object[]" ___xs]
        (.clone ___xs)
    )
)
)

(java-ns cloiure.lang.Seqable

(§ defprotocol Seqable
    #_abstract
    (#_"ISeq" Seqable'''(§ method seq) [#_"Seqable" this])
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (defn- #_"SeqEnumeration" SeqEnumeration'init []
        (hash-map
            #_"ISeq" :seq nil
        )
    )

    (defn #_"SeqEnumeration" SeqEnumeration'new [#_"ISeq" ___seq]
        (let [this (SeqEnumeration'init)]
            (§ ass (:seq this) ___seq)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasMoreElements) [#_"SeqEnumeration" this]
        (ß ((:seq this) != nil))
    )

    #_method
    (§ defn #_"Object" (§ method nextElement) [#_"SeqEnumeration" this]
        (let [#_"Object" ___ret (RT'first (:seq this))]
            (§ ass (:seq this) (RT'next (:seq this)))
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (def #_"Object" SeqIterator'START (Object.))

    (defn- #_"SeqIterator" SeqIterator'init []
        (hash-map
            #_"Object" :seq nil
            #_"Object" :next nil
        )
    )

    (defn #_"SeqIterator" SeqIterator'new [#_"Object" ___o]
        (let [this (SeqIterator'init)]
            (§ ass (:seq this) SeqIterator'START)
            (§ ass (:next this) ___o)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"SeqIterator" this]
        (cond (ß (:seq this) == SeqIterator'START)
            (do
                (§ ass (:seq this) nil)
                (§ ass (:next this) (RT'seq (:next this)))
            )
            (ß (:seq this) == (:next this))
            (do
                (§ ass (:next this) (RT'next (:seq this)))
            )
        )
        (ß ((:next this) != nil))
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"SeqIterator" this] #_(§ throws NoSuchElementException)
        (when (not (ß this.hasNext()))
            (throw (NoSuchElementException.))
        )
        (§ ass (:seq this) (:next this))
        (RT'first (:next this))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Sequential

(§ defprotocol Sequential
)
)

(java-ns cloiure.lang.Settable

(§ defprotocol Settable
    #_abstract
    (#_"Object" Settable'''(§ method doSet) [#_"Settable" this, #_"Object" ___val])
    #_abstract
    (#_"Object" Settable'''(§ method doReset) [#_"Settable" this, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ defprotocol Sorted
    #_abstract
    (#_"Comparator" Sorted'''(§ method comparator) [#_"Sorted" this])
    #_abstract
    (#_"Object" Sorted'''(§ method entryKey) [#_"Sorted" this, #_"Object" ___entry])
    #_abstract
    (#_"ISeq" Sorted'''(§ method seq) [#_"Sorted" this, #_"boolean" ___ascending])
    #_abstract
    (#_"ISeq" Sorted'''(§ method seqFrom) [#_"Sorted" this, #_"Object" ___key, #_"boolean" ___ascending])
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (defn #_"StringSeq" StringSeq'create [#_"CharSequence" ___s]
        (when (ß (.length ___s) == 0)
            (§ return nil)
        )
        (StringSeq'new nil, ___s, 0)
    )

    (defn- #_"StringSeq" StringSeq'init []
        (hash-map
            #_"CharSequence" :s nil
            #_"int" :i 0
        )
    )

    (defn #_"StringSeq" StringSeq'new [#_"IPersistentMap" ___meta, #_"CharSequence" ___s, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (StringSeq'init))]
            (§ ass (:s this) ___s)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Obj" (§ method withMeta) [#_"StringSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (.meta this))
            (§ return this)
        )
        (StringSeq'new ___meta, (:s this), (:i this))
    )

    #_method
    (§ defn #_"Object" (§ method first) [#_"StringSeq" this]
        (ß Character/valueOf((:s this).charAt((:i this))))
    )

    #_method
    (§ defn #_"ISeq" (§ method next) [#_"StringSeq" this]
        (when (ß (:i this) + 1 < (:s this).length())
            (§ return (ß StringSeq'new((:_meta this), (:s this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" (§ method index) [#_"StringSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" (§ method count) [#_"StringSeq" this]
        (ß (:s this).length() - (:i this))
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (defn #_"Symbol" Symbol'create-2 [#_"String" ___ns, #_"String" ___name]
        (Symbol'intern-2 ___ns, ___name)
    )

    (defn #_"Symbol" Symbol'create-1 [#_"String" ___nsname]
        (Symbol'intern-1 ___nsname)
    )

    (defn #_"Symbol" Symbol'intern-2 [#_"String" ___ns, #_"String" ___name]
        (Symbol'new-2 ___ns, ___name)
    )

    (defn #_"Symbol" Symbol'intern-1 [#_"String" ___nsname]
        (let [#_"int" ___i (ß ___nsname.indexOf(\/))]
            (if (ß ___i == -1 || ___nsname.equals("/"))
                (do
                    (Symbol'new-2 nil, ___nsname)
                )
                (do
                    (ß Symbol'new-2(___nsname.substring(0, ___i), ___nsname.substring(___i + 1)))
                )
            )
        )
    )

    (defn- #_"Symbol" Symbol'init []
        (hash-map
            #_"String" :ns nil
            #_"String" :name nil
            #_"int" :_hasheq 0
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Symbol" Symbol'new-2 [#_"String" ___ns_interned, #_"String" ___name_interned]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass (:name this) ___name_interned)
            (§ ass (:ns this) ___ns_interned)
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Symbol" this]
        (when (nil? (:_str this))
            (if (some? (:ns this))
                (do
                    (§ ass (:_str this) (str (:ns this) "/" (:name this)))
                )
                (do
                    (§ ass (:_str this) (:name this))
                )
            )
        )
        (:_str this)
    )

    #_method
    (§ defn #_"String" (§ method getNamespace) [#_"Symbol" this]
        (:ns this)
    )

    #_method
    (§ defn #_"String" (§ method getName) [#_"Symbol" this]
        (:name this)
    )

    #_method
    (§ defn #_"boolean" (§ method equals) [#_"Symbol" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (not (ß ___o instanceof Symbol))
            (§ return false)
        )

        (let [#_"Symbol" ___symbol (ß (Symbol) ___o)]
            (ß Util'equals((:ns this), (:ns ___symbol)) && (:name this).equals((:name ___symbol)))
        )
    )

    #_method
    (§ defn #_"int" (§ method hashCode) [#_"Symbol" this]
        (ß Util'hashCombine((:name this).hashCode(), Util'hash((:ns this))))
    )

    #_method
    (§ defn #_"int" (§ method hasheq) [#_"Symbol" this]
        (when (ß (:_hasheq this) == 0)
            (§ ass (:_hasheq this) (ß Util'hashCombine(Murmur3'hashUnencodedChars((:name this)), Util'hash((:ns this)))))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"IObj" (§ method withMeta) [#_"Symbol" this, #_"IPersistentMap" ___meta]
        (Symbol'new-3 ___meta, (:ns this), (:name this))
    )

    (defn- #_"Symbol" Symbol'new-3 [#_"IPersistentMap" ___meta, #_"String" ___ns, #_"String" ___name]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass (:name this) ___name)
            (§ ass (:ns this) ___ns)
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"int" (§ method compareTo) [#_"Symbol" this, #_"Object" ___o]
        (let [#_"Symbol" ___s (ß (Symbol) ___o)]
            (when (.equals this, ___o)
                (§ return 0)
            )
            (when (ß (:ns this) == nil && (:ns ___s) != nil)
                (§ return -1)
            )
            (when (ß (:ns this) != nil)
                (when (ß (:ns ___s) == nil)
                    (§ return 1)
                )
                (let [#_"int" ___nsc (ß (:ns this).compareTo((:ns ___s)))]
                    (when (ß ___nsc != 0)
                        (§ return ___nsc)
                    )
                )
            )
            (ß (:name this).compareTo((:name ___s)))
        )
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Symbol" this, #_"Object" ___obj]
        (RT'get-2 ___obj, this)
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Symbol" this, #_"Object" ___obj, #_"Object" ___notFound]
        (RT'get-3 ___obj, this, ___notFound)
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method meta) [#_"Symbol" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def #_"Keyword" TaggedLiteral'TAG_KW (Keyword'intern-1 "tag"))
    (§ def #_"Keyword" TaggedLiteral'FORM_KW (Keyword'intern-1 "form"))

    (defn #_"TaggedLiteral" TaggedLiteral'create [#_"Symbol" ___tag, #_"Object" ___form]
        (TaggedLiteral'new ___tag, ___form)
    )

    (defn- #_"TaggedLiteral" TaggedLiteral'init []
        (hash-map
            #_"Symbol" :tag nil
            #_"Object" :form nil
        )
    )

    (defn- #_"TaggedLiteral" TaggedLiteral'new [#_"Symbol" ___tag, #_"Object" ___form]
        (let [this (TaggedLiteral'init)]
            (§ ass (:tag this) ___tag)
            (§ ass (:form this) ___form)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TaggedLiteral" this, #_"Object" ___key]
        (.valAt this, ___key, nil)
    )

    #_method
    (§ defn #_"Object" (§ method valAt) [#_"TaggedLiteral" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (ß TaggedLiteral'FORM_KW.equals(___key))
            (do
                (:form this)
            )
            (ß TaggedLiteral'TAG_KW.equals(___key))
            (do
                (:tag this)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" (§ method equals) [#_"TaggedLiteral" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß ___o == nil || getClass() != (.getClass ___o))
            (§ return false)
        )

        (let [#_"TaggedLiteral" ___that (ß (TaggedLiteral) ___o)]
            (when (ß ((:form this) != nil) ? (not (ß (:form this).equals((:form ___that)))) :or (:form ___that) != nil)
                (§ return false)
            )
            (when (ß ((:tag this) != nil) ? (not (ß (:tag this).equals((:tag ___that)))) :or (:tag ___that) != nil)
                (§ return false)
            )

            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" (§ method hashCode) [#_"TaggedLiteral" this]
        (let [#_"int" ___result (Util'hash (:tag this))]
            (§ ass ___result (ß 31 * ___result + Util'hash((:form this))))
            ___result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (defn- #_"TransactionalHashMap" TransactionalHashMap'init []
        (hash-map
            #_"Ref[]" :bins nil
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-0 []
        (TransactionalHashMap'new-1i 421)
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1i [#_"int" ___nBins]
        (let [this (merge (AbstractMap'new) (TransactionalHashMap'init))]
            (§ ass (:bins this) (§ typeless make-array Ref ___nBins))
            (loop-when-recur [#_"int" ___i 0] (< ___i ___nBins) [(inc ___i)]
                (§ ass (ß (:bins this)[___i]) (Ref'new-1 PersistentHashMap'EMPTY))
            )
            this
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1m [#_"Map<? extends K, ? extends V>" ___m]
        (let [this (TransactionalHashMap'new-1i (.size ___m))]
            (.putAll this, ___m)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" (§ method mapAt) [#_"TransactionalHashMap" this, #_"int" ___bin]
        (ß (IPersistentMap) (:bins this)[___bin].deref())
    )

    #_method
    (§ defn #_"int" (§ method binFor) [#_"TransactionalHashMap" this, #_"Object" ___k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" ___h (.hashCode ___k)]
            (§ ass ___h (ß ___h :xor ((___h >>> 20) :xor (___h >>> 12))))
            (§ ass ___h (ß ___h :xor ((___h >>> 7) :xor (___h >>> 4))))
            (ß ___h % (:bins this).length)
        )
    )

    #_method
    (§ defn #_"Entry" (§ method entryAt) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß this.mapAt(this.binFor(___k)).entryAt(___k))
    )

    #_method
    (§ defn #_"int" (§ method size) [#_"TransactionalHashMap" this]
        (let [#_"int" ___n 0]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bins this).length) [(inc ___i)]
                (§ ass ___n (ß ___n + this.mapAt(___i).count()))
            )
            ___n
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"TransactionalHashMap" this]
        (ß ((.size this) == 0))
    )

    #_method
    (§ defn #_"boolean" (§ method containsKey) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß (this.entryAt(___k) != nil))
    )

    #_method
    (§ defn #_"V" (§ method get) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Entry" ___e (.entryAt this, ___k)]
            (when (some? ___e)
                (§ return (ß (V) (.getValue ___e)))
            )
            nil
        )
    )

    #_method
    (§ defn #_"V" (§ method put) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[this.binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                (let [#_"Object" ___ret (.valAt ___map, ___k)]
                    (ß ___r.set(___map.assoc(___k, ___v)))
                    (ß (V) ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method remove) [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Ref" ___r (ß (:bins this)[this.binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                (let [#_"Object" ___ret (.valAt ___map, ___k)]
                    (ß ___r.set(___map.without(___k)))
                    (ß (V) ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" (§ method putAll) [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" ___map]
        (loop-when-recur [#_"Iterator" ___i (.iterator (.entrySet ___map))] (.hasNext ___i) [___i]
            (let [#_"Entry<K, V>" ___e (ß (Entry) (next ___i))]
                (ß this.put((.getKey ___e), (.getValue ___e)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method clear) [#_"TransactionalHashMap" this]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bins this).length) [(inc ___i)]
            (let [#_"Ref" ___r (ß (:bins this)[___i])]
                (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                    (when (ß (count ___map) > 0)
                        (ß ___r.set(PersistentHashMap'EMPTY))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" (§ method entrySet) [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map$Entry<K, V>>" ___entries (ArrayList. (ß (:bins this).length))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bins this).length) [(inc ___i)]
                (let [#_"IPersistentMap" ___map (.mapAt this, ___i)]
                    (when (ß (count ___map) > 0)
                        (ß ___entries.addAll((Collection) RT'seq(___map)))
                    )
                )
            )
            (§ reify AbstractSet<Entry<K, V>>()
                #_method
                (§ defn #_"Iterator" (§ method iterator) [#_"AbstractSet<Entry<K, V>>" this]
                    (ß Collections/unmodifiableList(___entries).iterator())
                )

                #_method
                (§ defn #_"int" (§ method size) [#_"AbstractSet<Entry<K, V>>" this]
                    (.size ___entries)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method putIfAbsent) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[this.binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (if (nil? ___e)
                        (do
                            (ß ___r.set(___map.assoc(___k, ___v)))
                            nil
                        )
                        (do
                            (ß (V) (.getValue ___e))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method remove) [#_"TransactionalHashMap" this, #_"Object" ___k, #_"Object" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[this.binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (when (ß ___e != nil && (.getValue ___e).equals(___v))
                        (ß ___r.set(___map.without(___k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" (§ method replace) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___oldv, #_"V" ___newv]
        (let [#_"Ref" ___r (ß (:bins this)[this.binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (when (ß ___e != nil && (.getValue ___e).equals(___oldv))
                        (ß ___r.set(___map.assoc(___k, ___newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"V" (§ method replace) [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[this.binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) (deref ___r))]
                (let [#_"Entry" ___e (.entryAt ___map, ___k)]
                    (when (some? ___e)
                        (ß ___r.set(___map.assoc(___k, ___v)))
                        (§ return (ß (V) (.getValue ___e)))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_private
(§ defprotocol Buffer
    #_abstract
    (#_"Buffer" Buffer'''(§ method add) [#_"Buffer" this, #_"Object" ___o])
    #_abstract
    (#_"Object" Buffer'''(§ method remove) [#_"Buffer" this])
    #_abstract
    (#_"boolean" Buffer'''(§ method isEmpty) [#_"Buffer" this])
)

#_private
(class-ns EmptyBuffer (§ implements Buffer)
    (defn #_"EmptyBuffer" EmptyBuffer'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"EmptyBuffer" this, #_"Object" ___o]
        (SingleBuffer'new ___o)
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"EmptyBuffer" this]
        (throw (IllegalStateException. "Removing object from empty buffer"))
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"EmptyBuffer" this]
        true
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"EmptyBuffer" this]
        "EmptyBuffer"
    )
)

#_private
(class-ns SingleBuffer (§ implements Buffer)
    (defn- #_"SingleBuffer" SingleBuffer'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"SingleBuffer" SingleBuffer'new [#_"Object" ___o]
        (let [this (SingleBuffer'init)]
            (§ ass (:val this) ___o)
            this
        )
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"SingleBuffer" this, #_"Object" ___o]
        (if (ß (:val this) == TransformerIterator'NONE)
            (do
                (§ ass (:val this) ___o)
                this
            )
            (do
                (ManyBuffer'new (:val this), ___o)
            )
        )
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"SingleBuffer" this]
        (when (ß (:val this) == TransformerIterator'NONE)
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )
        (let [#_"Object" ___ret (:val this)]
            (§ ass (:val this) TransformerIterator'NONE)
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"SingleBuffer" this]
        (ß ((:val this) == TransformerIterator'NONE))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"SingleBuffer" this]
        (str "SingleBuffer: " (:val this))
    )
)

#_private
(class-ns ManyBuffer (§ implements Buffer)
    (defn- #_"ManyBuffer" ManyBuffer'init []
        (hash-map
            #_"Queue" :vals (LinkedList.)
        )
    )

    (defn #_"ManyBuffer" ManyBuffer'new [#_"Object" ___o1, #_"Object" ___o2]
        (let [this (ManyBuffer'init)]
            (ß (:vals this).add(___o1))
            (ß (:vals this).add(___o2))
            this
        )
    )

    #_method
    (§ defn #_"Buffer" (§ method add) [#_"ManyBuffer" this, #_"Object" ___o]
        (ß (:vals this).add(___o))
        this
    )

    #_method
    (§ defn #_"Object" (§ method remove) [#_"ManyBuffer" this]
        (.remove (:vals this))
    )

    #_method
    (§ defn #_"boolean" (§ method isEmpty) [#_"ManyBuffer" this]
        (.isEmpty (:vals this))
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"ManyBuffer" this]
        (str "ManyBuffer: " (ß (:vals this).toString()))
    )
)

#_private
(class-ns MultiIterator (§ implements Iterator)
    (defn- #_"MultiIterator" MultiIterator'init []
        (hash-map
            #_"Iterator[]" :iters nil
        )
    )

    (defn #_"MultiIterator" MultiIterator'new [#_"Iterator[]" ___iters]
        (let [this (MultiIterator'init)]
            (§ ass (:iters this) ___iters)
            this
        )
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"MultiIterator" this]
        (doseq [#_"Iterator" ___iter (:iters this)]
            (when (not (ß ___iter.hasNext()))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"MultiIterator" this]
        (let [#_"Object[]" ___nexts (make-array Object (ß (:iters this).length))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:iters this).length) [(inc ___i)]
                (§ ass (ß ___nexts[___i]) (ß (:iters this)[___i].next()))
            )
            (ArraySeq'new-2 ___nexts, 0)
        )
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"MultiIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransformerIterator (§ implements Iterator)
    (def- #_"Buffer" TransformerIterator'EMPTY (EmptyBuffer'new))
    (def- #_"Object" TransformerIterator'NONE (Object.))

    (defn- #_"TransformerIterator" TransformerIterator'init []
        (hash-map
            ;; Source
            #_"Iterator" :sourceIter nil
            #_"IFn" :xf nil
            #_"boolean" :multi false

            ;; Iteration state
            #_volatile
            #_"Buffer" :buffer TransformerIterator'EMPTY
            #_volatile
            #_"Object" :next TransformerIterator'NONE
            #_volatile
            #_"boolean" :completed false
        )
    )

    (defn- #_"TransformerIterator" TransformerIterator'new [#_"IFn" ___xform, #_"Iterator" ___sourceIter, #_"boolean" ___multi]
        (let [this (TransformerIterator'init)]
            (§ ass (:sourceIter this) ___sourceIter)
            (§ ass (:xf this) (ß (IFn) ___xform.invoke(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" (§ method invoke) [#_"AFn" this]
                            nil
                        )

                        #_method
                        (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___acc]
                            ___acc
                        )

                        #_method
                        (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___acc, #_"Object" ___o]
                            (§ ass (:buffer this) (ß (:buffer this).add(___o)))
                            ___acc
                        )
                    )
                )
            ))
            (§ ass (:multi this) ___multi)
            this
        )
    )

    (defn #_"Iterator" TransformerIterator'create [#_"IFn" ___xform, #_"Iterator" ___source]
        (TransformerIterator'new ___xform, ___source, false)
    )

    (defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" ___xform, #_"List" ___sources]
        (let [#_"Iterator[]" ___iters (make-array Iterator (.size ___sources))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (.size ___sources)) [(inc ___i)]
                (§ ass (ß ___iters[___i]) (ß (Iterator)___sources.get(___i)))
            )
            (ß TransformerIterator'new(___xform, MultiIterator'new(___iters), true))
        )
    )

    #_method
    (§ defn- #_"boolean" (§ method step) [#_"TransformerIterator" this]
        (when (ß (:next this) != TransformerIterator'NONE)
            (§ return true)
        )

        (while (ß (:next this) == TransformerIterator'NONE)
            (if (.isEmpty (:buffer this))
                (do
                    (cond (:completed this)
                        (do
                            (§ return false)
                        )
                        (.hasNext (:sourceIter this))
                        (do
                            (let [#_"Object" ___iter nil]
                                (if (:multi this)
                                    (do
                                        (§ ass ___iter (ß (:xf this).applyTo(RT'cons(nil, (:sourceIter this).next()))))
                                    )
                                    (do
                                        (§ ass ___iter (ß (:xf this).invoke(nil, (:sourceIter this).next())))
                                    )
                                )

                                (when (RT'isReduced ___iter)
                                    (ß (:xf this).invoke(nil))
                                    (§ ass (:completed this) true)
                                )
                            )
                        )
                        :else
                        (do
                            (ß (:xf this).invoke(nil))
                            (§ ass (:completed this) true)
                        )
                    )
                )
                (do
                    (§ ass (:next this) (.remove (:buffer this)))
                )
            )
        )
        true
    )

    #_method
    (§ defn #_"boolean" (§ method hasNext) [#_"TransformerIterator" this]
        (.step this)
    )

    #_method
    (§ defn #_"Object" (§ method next) [#_"TransformerIterator" this]
        (when (.hasNext this)
            (let [#_"Object" ___ret (:next this)]
                (§ ass (:next this) TransformerIterator'NONE)
                (§ return ___ret)
            )
        )
        (throw (NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" (§ method remove) [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns Tuple
    (def #_"int" Tuple'MAX_SIZE 6)

    (defn #_"IPersistentVector" Tuple'create-0 []
        PersistentVector'EMPTY
    )

    (defn #_"IPersistentVector" Tuple'create-1 [#_"Object" ___v0]
        (RT'vector ___v0)
    )

    (defn #_"IPersistentVector" Tuple'create-2 [#_"Object" ___v0, #_"Object" ___v1]
        (RT'vector ___v0, ___v1)
    )

    (defn #_"IPersistentVector" Tuple'create-3 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2]
        (RT'vector ___v0, ___v1, ___v2)
    )

    (defn #_"IPersistentVector" Tuple'create-4 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3]
        (RT'vector ___v0, ___v1, ___v2, ___v3)
    )

    (defn #_"IPersistentVector" Tuple'create-5 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4]
        (RT'vector ___v0, ___v1, ___v2, ___v3, ___v4)
    )

    (defn #_"IPersistentVector" Tuple'create-6 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4, #_"Object" ___v5]
        (RT'vector ___v0, ___v1, ___v2, ___v3, ___v4, ___v5)
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(§ defprotocol EquivPred
    #_abstract
    (#_"boolean" EquivPred'''(§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2])
)

#_stateless
(class-ns Util
    (defn #_"boolean" Util'equiv-2oo [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return true)
        )
        (when (some? ___k1)
            (cond (ß ___k1 instanceof Number && ___k2 instanceof Number)
                (do
                    (§ return (ß Numbers'equal((Number)___k1, (Number)___k2)))
                )
                (ß ___k1 instanceof IPersistentCollection || ___k2 instanceof IPersistentCollection)
                (do
                    (§ return (ß pcequiv(___k1, ___k2)))
                )
            )
            (§ return (.equals ___k1, ___k2))
        )
        false
    )

    (def #_"EquivPred" Util'equivNull
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (ß ___k2 == nil)
            )
        )
    )

    (def #_"EquivPred" Util'equivEquals
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (.equals ___k1, ___k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivNumber
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (ß ___k2 instanceof Number)
                    (§ return (ß Numbers'equal((Number) ___k1, (Number) ___k2)))
                )
                false
            )
        )
    )

    (def #_"EquivPred" Util'equivColl
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" (§ method equiv) [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (ß ___k1 instanceof IPersistentCollection || ___k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(___k1, ___k2)))
                )
                (.equals ___k1, ___k2)
            )
        )
    )

    (defn #_"EquivPred" Util'equivPred [#_"Object" ___k1]
        (cond (nil? ___k1)
            (do
                (§ return Util'equivNull)
            )
            (ß ___k1 instanceof Number)
            (do
                (§ return Util'equivNumber)
            )
            (ß ___k1 instanceof String || ___k1 instanceof Symbol)
            (do
                (§ return Util'equivEquals)
            )
            (ß ___k1 instanceof Collection || ___k1 instanceof Map)
            (do
                (§ return Util'equivColl)
            )
        )
        Util'equivEquals
    )

    (defn #_"boolean" Util'equiv-2ll [#_"long" ___k1, #_"long" ___k2]
        (ß ___k1 == ___k2)
    )

    (defn #_"boolean" Util'equiv-2ol [#_"Object" ___k1, #_"long" ___k2]
        (ß this.equiv(___k1, (Object)___k2))
    )

    (defn #_"boolean" Util'equiv-2lo [#_"long" ___k1, #_"Object" ___k2]
        (ß this.equiv((Object)___k1, ___k2))
    )

    (defn #_"boolean" Util'equiv-2dd [#_"double" ___k1, #_"double" ___k2]
        (ß ___k1 == ___k2)
    )

    (defn #_"boolean" Util'equiv-2od [#_"Object" ___k1, #_"double" ___k2]
        (ß this.equiv(___k1, (Object)___k2))
    )

    (defn #_"boolean" Util'equiv-2do [#_"double" ___k1, #_"Object" ___k2]
        (ß this.equiv((Object)___k1, ___k2))
    )

    (defn #_"boolean" Util'equiv-2bb [#_"boolean" ___k1, #_"boolean" ___k2]
        (ß ___k1 == ___k2)
    )

    (defn #_"boolean" Util'equiv-2ob [#_"Object" ___k1, #_"boolean" ___k2]
        (ß this.equiv(___k1, (Object)___k2))
    )

    (defn #_"boolean" Util'equiv-2bo [#_"boolean" ___k1, #_"Object" ___k2]
        (ß this.equiv((Object)___k1, ___k2))
    )

    (defn #_"boolean" Util'equiv-2cc [#_"char" ___c1, #_"char" ___c2]
        (ß ___c1 == ___c2)
    )

    (defn #_"boolean" Util'pcequiv [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 instanceof IPersistentCollection)
            (§ return (ß (cast' IPersistentCollection ___k1).equiv(___k2)))
        )
        (ß (cast' IPersistentCollection ___k2).equiv(___k1))
    )

    (defn #_"boolean" Util'equals [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return true)
        )
        (ß (___k1 != nil && ___k1.equals(___k2)))
    )

    (defn #_"boolean" Util'identical [#_"Object" ___k1, #_"Object" ___k2]
        (ß ___k1 == ___k2)
    )

    (defn #_"Class" Util'classOf [#_"Object" ___x]
        (when (some? ___x)
            (§ return (.getClass ___x))
        )
        nil
    )

    (defn #_"int" Util'compare [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return 0)
        )
        (when (some? ___k1)
            (when (nil? ___k2)
                (§ return 1)
            )
            (when (ß ___k1 instanceof Number)
                (§ return (ß Numbers'compare((Number) ___k1, (Number) ___k2)))
            )
            (§ return (ß (cast Comparable ___k1).compareTo(___k2)))
        )
        -1
    )

    (defn #_"int" Util'hash [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (.hashCode ___o)
    )

    (defn #_"int" Util'hasheq [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (when (ß ___o instanceof IHashEq)
            (§ return (ß dohasheq((cast' IHashEq ___o))))
        )
        (when (ß ___o instanceof Number)
            (§ return (ß Numbers'hasheq((cast Number ___o))))
        )
        (when (ß ___o instanceof String)
            (§ return (ß Murmur3'hashInt((.hashCode ___o))))
        )
        (.hashCode ___o)
    )

    (defn- #_"int" Util'dohasheq [#_"IHashEq" ___o]
        (.hasheq ___o)
    )

    (defn #_"int" Util'hashCombine [#_"int" ___seed, #_"int" ___hash]
        ;; a la boost
        (§ ass ___seed (ß ___seed :xor (___hash + 0x9e3779b9 + (___seed << 6) + (___seed >> 2))))
        ___seed
    )

    (defn #_"boolean" Util'isPrimitive [#_"Class" ___c]
        (ß (___c != nil && (.isPrimitive ___c) && (not (ß ___c == Void/TYPE))))
    )

    (defn #_"boolean" Util'isInteger [#_"Object" ___x]
        (ß ___x instanceof Integer || ___x instanceof Long || ___x instanceof BigInt || ___x instanceof BigInteger)
    )

    (defn #_"Object" Util'ret1 [#_"Object" ___ret, #_"Object" ___nil]
        ___ret
    )

    (defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" ___rq, #_"ConcurrentHashMap<K, Reference<V>>" ___cache]
        ;; cleanup any dead entries
        (when (ß (.poll ___rq) != nil)
            (while (ß (.poll ___rq) != nil)
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" ___e (.entrySet ___cache)]
                (let [#_"Reference<V>" ___val (.getValue ___e)]
                    (when (ß ___val != nil && (.get ___val) == nil)
                        (ß ___cache.remove((.getKey ___e), ___val))
                    )
                )
            )
        )
        nil
    )

    (defn #_"RuntimeException" Util'runtimeException-1 [#_"String" ___s]
        (RuntimeException. ___s)
    )

    (defn #_"RuntimeException" Util'runtimeException-2 [#_"String" ___s, #_"Throwable" ___e]
        (RuntimeException. ___s, ___e)
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (defn #_"RuntimeException" Util'sneakyThrow [#_"Throwable" ___t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (nil? ___t)
            (throw (NullPointerException.))
        )
        (ß Util'<RuntimeException>sneakyThrow0(___t))
        nil
    )

    (defn- #_"<T extends Throwable> void" Util'sneakyThrow0 [#_"Throwable" ___t] #_(§ throws T)
        (throw (ß (T) ___t))
    )

    (defn #_"Object" Util'loadWithClass [#_"String" ___scriptbase, #_"Class<?>" ___loadFrom] #_(§ throws IOException, ClassNotFoundException)
        (ß Var'pushThreadBindings(RT'map(
            (object-array [
                Compiler'LOADER (.getClassLoader ___loadFrom)
            ])
        )))
        (try
            (ß RT'var-2("cloiure.core", "load").invoke(___scriptbase))
            (finally
                (Var'popThreadBindings)
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns TBox
    (defn- #_"TBox" TBox'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_"Thread" :thread nil
        )
    )

    (defn #_"TBox" TBox'new [#_"Thread" ___t, #_"Object" ___val]
        (let [this (TBox'init)]
            (§ ass (:thread this) ___t)
            (§ ass (:val this) ___val)
            this
        )
    )
)

(class-ns Unbound (§ extends AFn)
    (defn- #_"Unbound" Unbound'init []
        (hash-map
            #_"Var" :v nil
        )
    )

    (defn #_"Unbound" Unbound'new [#_"Var" ___v]
        (let [this (merge (AFn'new) (Unbound'init))]
            (§ ass (:v this) ___v)
            this
        )
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Unbound" this]
        (str "Unbound: " (:v this))
    )

    #_method
    (§ defn #_"Object" (§ method throwArity) [#_"Unbound" this, #_"int" ___n]
        (throw (IllegalStateException. (str "Attempting to call unbound fn: " (:v this))))
    )
)

(class-ns Frame
    (§ def #_"Frame" Frame'TOP (Frame'new PersistentHashMap'EMPTY, nil))

    (defn- #_"Frame" Frame'init []
        (hash-map
            ;; Var->TBox
            #_"Associative" :bindings nil
            ;; Var->val
            #_"Frame" :prev nil
        )
    )

    (defn #_"Frame" Frame'new [#_"Associative" ___bindings, #_"Frame" ___prev]
        (let [this (Frame'init)]
            (§ ass (:bindings this) ___bindings)
            (§ ass (:prev this) ___prev)
            this
        )
    )

    #_protected
    #_method
    (§ defn #_"Object" (§ method clone) [#_"Frame" this]
        (ß Frame'new((:bindings this), nil))
    )
)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (def #_"ThreadLocal<Frame>" Var'dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_method
            (§ defn #_"Frame" (§ method initialValue) [#_"ThreadLocal<Frame>" this]
                Frame'TOP
            )
        )
    )

    #_volatile
    (def #_"int" Var'rev 0)

    (§ def #_"Keyword" Var'privateKey (Keyword'intern-2 nil, "private"))
    (§ def #_"IPersistentMap" Var'privateMeta (PersistentArrayMap'new-1 (object-array [ privateKey, Boolean/TRUE ])))
    (§ def #_"Keyword" Var'macroKey (Keyword'intern-2 nil, "macro"))
    (§ def #_"Keyword" Var'nameKey (Keyword'intern-2 nil, "name"))
    (§ def #_"Keyword" Var'nsKey (Keyword'intern-2 nil, "ns"))

    (defn #_"Object" Var'getThreadBindingFrame []
        (.get Var'dvals)
    )

    (defn #_"Object" Var'cloneThreadBindingFrame []
        (.clone (.get Var'dvals))
    )

    (defn #_"void" Var'resetThreadBindingFrame [#_"Object" ___frame]
        (ß Var'dvals.set((cast' Frame ___frame)))
        nil
    )

    (defn #_"Var" Var'intern-3 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (Var'intern-4 ___ns, ___sym, ___root, true)
    )

    (defn #_"Var" Var'intern-4 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root, #_"boolean" ___replaceRoot]
        (let [#_"Var" ___dvout (.intern ___ns, ___sym)]
            (when (ß (not (ß ___dvout.hasRoot())) || ___replaceRoot)
                (.bindRoot ___dvout, ___root)
            )
            ___dvout
        )
    )

    (defn #_"Var" Var'find [#_"Symbol" ___nsQualifiedSym]
        (when (ß (:ns ___nsQualifiedSym) == nil)
            (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
        )
        (let [#_"Namespace" ___ns (ß Namespace'find(Symbol'intern-1((:ns ___nsQualifiedSym))))]
            (when (nil? ___ns)
                (throw (IllegalArgumentException. (str "No such namespace: " (:ns ___nsQualifiedSym))))
            )
            (ß ___ns.findInternedVar(Symbol'intern-1((:name ___nsQualifiedSym))))
        )
    )

    (defn #_"Var" Var'intern-2n [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (.intern ___ns, ___sym)
    )

    (defn #_"Var" Var'intern-2s [#_"Symbol" ___nsName, #_"Symbol" ___sym]
        (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsName)]
            (Var'intern-2n ___ns, ___sym)
        )
    )

    (defn #_"Var" Var'internPrivate [#_"String" ___nsName, #_"String" ___sym]
        (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(Symbol'intern-1(___nsName)))]
            (let [#_"Var" ___ret (Var'intern-2n ___ns, (Symbol'intern-1 ___sym))]
                (.setMeta ___ret, Var'privateMeta)
                ___ret
            )
        )
    )

    (defn #_"Var" Var'create-0 []
        (Var'new-2 nil, nil)
    )

    (defn #_"Var" Var'create-1 [#_"Object" ___root]
        (Var'new-3 nil, nil, ___root)
    )

    (defn- #_"Var" Var'init []
        (hash-map
            #_volatile
            #_"Object" :root nil

            #_volatile
            #_"boolean" :dynamic false
            #_transient
            #_"AtomicBoolean" :threadBound nil
            #_"Symbol" :sym nil
            #_"Namespace" :ns nil
        )
    )

    (defn #_"Var" Var'new-2 [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (let [this (merge (ARef'new-0) (Var'init))]
            (§ ass (:ns this) ___ns)
            (§ ass (:sym this) ___sym)
            (§ ass (:threadBound this) (AtomicBoolean. false))
            (§ ass (:root this) (Unbound'new this))
            (ß this.setMeta(PersistentHashMap'EMPTY))
            this
        )
    )

    (defn #_"Var" Var'new-3 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (let [this (Var'new-2 ___ns, ___sym)]
            (§ ass (:root this) ___root)
            (§ ass rev (+ rev 1))
            this
        )
    )

    #_method
    (§ defn #_"Var" (§ method setDynamic) [#_"Var" this]
        (§ ass (:dynamic this) true)
        this
    )

    #_method
    (§ defn #_"Var" (§ method setDynamic) [#_"Var" this, #_"boolean" ___b]
        (§ ass (:dynamic this) ___b)
        this
    )

    #_method
    (§ defn #_"boolean" (§ method isDynamic) [#_"Var" this]
        (:dynamic this)
    )

    #_method
    (§ defn #_"String" (§ method toString) [#_"Var" this]
        (when (some? (:ns this))
            (§ return (str "#'" (:name (:ns this)) "/" (:sym this)))
        )
        (str "#<Var: " (if (some? (:sym this)) (ß (:sym this).toString()) "--unnamed--") ">")
    )

    #_method
    (§ defn #_"boolean" (§ method isBound) [#_"Var" this]
        (ß ((.hasRoot this) || ((:threadBound this).get() && (:bindings (.get Var'dvals)).containsKey(this))))
    )

    #_method
    (§ defn #_"Object" (§ method get) [#_"Var" this]
        (when (not (ß (:threadBound this).get()))
            (§ return (:root this))
        )
        (deref this)
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Var" this]
        (let [#_"TBox" ___b (.getThreadBinding this)]
            (when (some? ___b)
                (§ return (:val ___b))
            )
            (:root this)
        )
    )

    #_method
    (§ defn #_"void" (§ method setValidator) [#_"Var" this, #_"IFn" ___vf]
        (when (.hasRoot this)
            (.validate this, ___vf, (:root this))
        )
        (§ ass (:validator this) ___vf)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method alter) [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß this.set(___fn.applyTo(RT'cons((deref this), ___args))))
        this
    )

    #_method
    (§ defn #_"Object" (§ method set) [#_"Var" this, #_"Object" ___val]
        (ß this.validate((.getValidator this), ___val))
        (let [#_"TBox" ___b (.getThreadBinding this)]
            (when (some? ___b)
                (when (ß Thread/currentThread() != (:thread ___b))
                    (throw (IllegalStateException. (String/format "Can't set!: %s from non-binding thread", (object-array [ (:sym this) ]))))
                )
                (§ ass (:val ___b) ___val)
                (§ return ___val)
            )
            (throw (IllegalStateException. (String/format "Can't change/establish root binding of: %s with set", (object-array [ (:sym this) ]))))
        )
    )

    #_method
    (§ defn #_"Object" (§ method doSet) [#_"Var" this, #_"Object" ___val]
        (.set this, ___val)
    )

    #_method
    (§ defn #_"Object" (§ method doReset) [#_"Var" this, #_"Object" ___val]
        (.bindRoot this, ___val)
        ___val
    )

    #_method
    (§ defn #_"void" (§ method setMeta) [#_"Var" this, #_"IPersistentMap" ___m]
        ;; ensure these basis keys
        (ß this.resetMeta(___m.assoc(nameKey, (:sym this)).assoc(nsKey, (:ns this))))
        nil
    )

    #_method
    (§ defn #_"void" (§ method setMacro) [#_"Var" this]
        (ß this.alterMeta(assoc, RT'list-2(macroKey, RT'T)))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method isMacro) [#_"Var" this]
        (ß RT'booleanCast-1o((.meta this).valAt(macroKey)))
    )

    #_method
    (§ defn #_"boolean" (§ method isPublic) [#_"Var" this]
        (not (RT'booleanCast-1o (ß (.meta this).valAt(privateKey))))
    )

    #_method
    (§ defn #_"Object" (§ method getRawRoot) [#_"Var" this]
        (:root this)
    )

    #_method
    (§ defn #_"Object" (§ method getTag) [#_"Var" this]
        (ß (.meta this).valAt(RT'TAG_KEY))
    )

    #_method
    (§ defn #_"void" (§ method setTag) [#_"Var" this, #_"Symbol" ___tag]
        (ß this.alterMeta(assoc, RT'list-2(RT'TAG_KEY, ___tag)))
        nil
    )

    #_method
    (§ defn #_"boolean" (§ method hasRoot) [#_"Var" this]
        (not (ß (:root this) instanceof Unbound))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" (§ method bindRoot) [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß this.validate((.getValidator this), ___root))
            (let [#_"Object" ___oldroot (:root this)]
                (§ ass (:root this) ___root)
                (§ ass rev (+ rev 1))
                (ß this.alterMeta(Var'dissoc, RT'list-1(macroKey)))
                (.notifyWatches this, ___oldroot, (:root this))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method swapRoot) [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß this.validate((.getValidator this), ___root))
            (let [#_"Object" ___oldroot (:root this)]
                (§ ass (:root this) ___root)
                (§ ass rev (+ rev 1))
                (.notifyWatches this, ___oldroot, ___root)
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method unbindRoot) [#_"Var" this]
        (§ sync this
            (§ ass (:root this) (Unbound'new this))
            (§ ass rev (+ rev 1))
        )
        nil
    )

    #_method
    (§ defn #_"void" (§ method commuteRoot) [#_"Var" this, #_"IFn" ___fn]
        (§ sync this
            (let [#_"Object" ___newRoot (.invoke ___fn, (:root this))]
                (ß this.validate((.getValidator this), ___newRoot))
                (let [#_"Object" ___oldroot (:root this)]
                    (§ ass (:root this) ___newRoot)
                    (§ ass rev (+ rev 1))
                    (.notifyWatches this, ___oldroot, ___newRoot)
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" (§ method alterRoot) [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (§ sync this
            (let [#_"Object" ___newRoot (ß ___fn.applyTo(RT'cons((:root this), ___args)))]
                (ß this.validate((.getValidator this), ___newRoot))
                (let [#_"Object" ___oldroot (:root this)]
                    (§ ass (:root this) ___newRoot)
                    (§ ass rev (+ rev 1))
                    (.notifyWatches this, ___oldroot, ___newRoot)
                    ___newRoot
                )
            )
        )
    )

    (defn #_"void" Var'pushThreadBindings [#_"Associative" ___bindings]
        (let [#_"Frame" ___f (.get Var'dvals)]
            (let [#_"Associative" ___bmap (:bindings ___f)]
                (loop-when-recur [#_"ISeq" ___bs (.seq ___bindings)] (some? ___bs) [(next ___bs)]
                    (let [#_"IMapEntry" ___e (ß (IMapEntry) (first ___bs))]
                        (let [#_"Var" ___v (ß (Var) (.key ___e))]
                            (when (not (:dynamic ___v))
                                (throw (IllegalStateException. (String/format "Can't dynamically bind non-dynamic var: %s/%s", (object-array [ (:ns ___v), (:sym ___v) ]))))
                            )
                            (ß ___v.validate((.getValidator ___v), (.val ___e)))
                            (ß (:threadBound ___v).set(true))
                            (§ ass ___bmap (ß ___bmap.assoc(___v, TBox'new(Thread/currentThread(), (.val ___e)))))
                        )
                    )
                )
                (ß Var'dvals.set(Frame'new(___bmap, ___f)))
                nil
            )
        )
    )

    (defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" ___f (:prev (.get Var'dvals))]
            (cond (nil? ___f)
                (do
                    (throw (IllegalStateException. "Pop without matching push"))
                )
                (ß ___f == Frame'TOP)
                (do
                    (.remove Var'dvals)
                )
                :else
                (do
                    (ß Var'dvals.set(___f))
                )
            )
            nil
        )
    )

    (defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" ___f (.get Var'dvals)]
            (let [#_"IPersistentMap" ___ret PersistentHashMap'EMPTY]
                (loop-when-recur [#_"ISeq" ___bs (.seq (:bindings ___f))] (some? ___bs) [(next ___bs)]
                    (let [#_"IMapEntry" ___e (ß (IMapEntry) (first ___bs))]
                        (let [#_"Var" ___v (ß (Var) (.key ___e))]
                            (let [#_"TBox" ___b (ß (TBox) (.val ___e))]
                                (§ ass ___ret (.assoc ___ret, ___v, (:val ___b)))
                            )
                        )
                    )
                )
                ___ret
            )
        )
    )

    #_method
    (§ defn #_"TBox" (§ method getThreadBinding) [#_"Var" this]
        (when (.get (:threadBound this))
            (let [#_"IMapEntry" ___e (ß (:bindings (.get Var'dvals)).entryAt(this))]
                (when (some? ___e)
                    (§ return (ß (TBox) (.val ___e)))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IFn" (§ method fn) [#_"Var" this]
        (ß (IFn) (deref this))
    )

    #_method
    (§ defn #_"Object" (§ method call) [#_"Var" this]
        (.invoke this)
    )

    #_method
    (§ defn #_"void" (§ method run) [#_"Var" this]
        (.invoke this)
        nil
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this]
        (.invoke (.fn this))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" (§ method invoke) [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß (.fn this).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil)),
                (Object[])Util'ret1(___args, (§ ass ___args nil))))
    )

    #_method
    (§ defn #_"Object" (§ method applyTo) [#_"Var" this, #_"ISeq" ___arglist]
        (ß (.fn this).applyTo(___arglist))
    )

    (def #_"IFn" Var'assoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___m, #_"Object" ___k, #_"Object" ___v]
                (RT'assoc ___m, ___k, ___v)
            )
        )
    )

    (def #_"IFn" Var'dissoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" (§ method invoke) [#_"AFn" this, #_"Object" ___c, #_"Object" ___k]
                (RT'dissoc ___c, ___k)
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (defn- #_"Volatile" Volatile'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"Volatile" Volatile'new [#_"Object" ___val]
        (let [this (Volatile'init)]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" (§ method deref) [#_"Volatile" this]
        (:val this)
    )

    #_method
    (§ defn #_"Object" (§ method reset) [#_"Volatile" this, #_"Object" ___newval]
        (§ ass (:val this) ___newval)
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" main'CLOIURE_MAIN (Symbol'intern-1 "cloiure.main"))
    (§ def- #_"Var" main'REQUIRE (RT'var-2 "cloiure.core", "require"))
    (§ def- #_"Var" main'MAIN (RT'var-2 "cloiure.main", "main"))

    (defn #_"void" -main [#_"String[]" ___args]
        (ß main'REQUIRE.invoke(main'CLOIURE_MAIN))
        (ß main'MAIN.applyTo(RT'seq(___args)))
        nil
    )
)
)
