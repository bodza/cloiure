(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

#_public
#_abstract
(class-ns AFn (§ implements IFn)
    #_public
    (§ method Object call()
        (§ return (§ expr invoke()))
    )

    #_public
    (§ method void run()
        (§ call invoke())
    )

    #_public
    (§ method Object invoke()
        (§ return (§ expr throwArity(0)))
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ return (§ expr throwArity(1)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2)
        (§ return (§ expr throwArity(2)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ return (§ expr throwArity(3)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ return (§ expr throwArity(4)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ return (§ expr throwArity(5)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ return (§ expr throwArity(6)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ return (§ expr throwArity(7)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))
    (§
        (§ return (§ expr throwArity(8)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))
    (§
        (§ return (§ expr throwArity(9)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))
    (§
        (§ return (§ expr throwArity(10)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))
    (§
        (§ return (§ expr throwArity(11)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))
    (§
        (§ return (§ expr throwArity(12)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))
    (§
        (§ return (§ expr throwArity(13)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))
    (§
        (§ return (§ expr throwArity(14)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))
    (§
        (§ return (§ expr throwArity(15)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))
    (§
        (§ return (§ expr throwArity(16)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))
    (§
        (§ return (§ expr throwArity(17)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))
    (§
        (§ return (§ expr throwArity(18)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))
    (§
        (§ return (§ expr throwArity(19)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))
    (§
        (§ return (§ expr throwArity(20)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
      #_arg Object... args))
    (§
        (§ return (§ expr throwArity(21)))
    )

    #_public
    (§ method Object applyTo(ISeq arglist)
        (§ return (§ expr applyToHelper(this, Util.ret1(arglist, arglist = nil))))
    )

    #_static
    #_public
    (§ method Object applyToHelper(IFn ifn, ISeq arglist)
        (§ switch (RT.boundedLength(arglist, 20)))
        (§
            (§ case 0)
            (§
                (§ ass arglist = nil)
                (§ return (§ expr ifn.invoke()))
            )
            (§ case 1)
            (§
                (§ return (§ expr ifn.invoke(Util.ret1(arglist.first(), arglist = nil))))
            )
            (§ case 2)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 3)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 4)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 5)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 6)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 7)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 8)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 9)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 10)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 11)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 12)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 13)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 14)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 15)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 16)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 17)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 18)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 19)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ case 20)
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            )
            (§ default )
            (§
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                  #_arg RT.seqToArray(Util.ret1(arglist.next(), arglist = nil)))))
            )
        )
    )

    #_public
    (§ method Object throwArity(int n)
        (§ let String name = getClass().getSimpleName())
        (§ throw new ArityException(n, Compiler.demunge(name)))
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_public
#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    #_public
    #_volatile
    (§ field MethodImplCache __methodImplCache)

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr nil))
    )

    #_public
    (§ method IObj withMeta(final IPersistentMap meta)
        (§ return (§ expr new RestFn()
        (§ inner
            #_protected
            (§ method Object doInvoke(Object args)
                (§ return (§ expr AFunction.this.applyTo((ISeq) args)))
            )

            #_public
            (§ method IPersistentMap meta()
                (§ return (§ expr meta))
            )

            #_public
            (§ method IObj withMeta(IPersistentMap meta)
                (§ return (§ expr AFunction.this.withMeta(meta)))
            )

            #_public
            (§ method int getRequiredArity()
                (§ return (§ expr 0))
            )
        )))
    )

    #_public
    (§ method int compare(Object o1, Object o2)
        (§ let Object o = invoke(o1, o2))

        (§ if (o instanceof Boolean))
        (§
            (§ if (RT.booleanCast(o)))
            (§
                (§ return (§ expr -1))
            )
            (§ return (§ expr RT.booleanCast(invoke(o2, o1)) ? 1 :or 0))
        )

        (§ let Number n = (Number) o)
        (§ return (§ expr n.intValue()))
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

#_public
(class-ns Agent (§ extends ARef)
    #_static
    (class-ns ActionQueue
        #_public
        #_final
        (§ field IPersistentStack q)
        #_public
        #_final
        (§ field Throwable error) ;; non-null indicates fail state
        #_static
        #_final
        (§ field ActionQueue EMPTY = new ActionQueue(PersistentQueue.EMPTY, nil))

        #_public
        (§ method ActionQueue(IPersistentStack q, Throwable error)
            (§ ass this.q = q)
            (§ ass this.error = error)
        )
    )

    #_static
    #_final
    (§ field Keyword CONTINUE = Keyword.intern(nil, "continue"))
    #_static
    #_final
    (§ field Keyword FAIL = Keyword.intern(nil, "fail"))

    #_volatile
    (§ field Object state)
    (§ field AtomicReference<ActionQueue> aq = new AtomicReference<ActionQueue>(ActionQueue.EMPTY))

    #_volatile
    (§ field Keyword errorMode = CONTINUE)
    #_volatile
    (§ field IFn errorHandler = nil)

    #_final
    #_private
    #_static
    (§ field AtomicLong sendThreadPoolCounter = new AtomicLong(0))

    #_final
    #_private
    #_static
    (§ field AtomicLong sendOffThreadPoolCounter = new AtomicLong(0))

    #_volatile
    #_public
    #_static
    (§ field ExecutorService pooledExecutor = Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter)))

    #_volatile
    #_public
    #_static
    (§ field ExecutorService soloExecutor = Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter)))

    #_final
    #_static
    (§ field ThreadLocal<IPersistentVector> nested = new ThreadLocal<IPersistentVector>())

    #_private
    #_static
    (§ method ThreadFactory createThreadFactory(final String format, final AtomicLong threadPoolCounter)
        (§ return (§ expr new ThreadFactory()
        (§ inner
            #_public
            (§ method Thread newThread(Runnable runnable)
                (§ let Thread thread = new Thread(runnable))
                (§ call thread.setName(String.format(format, threadPoolCounter.getAndIncrement())))
                (§ return (§ expr thread))
            )
        )))
    )

    #_public
    #_static
    (§ method void shutdown()
        (§ call soloExecutor.shutdown())
        (§ call pooledExecutor.shutdown())
    )

    #_static
    (class-ns Action (§ implements Runnable)
        #_final
        (§ field Agent agent)
        #_final
        (§ field IFn fn)
        #_final
        (§ field ISeq args)
        #_final
        (§ field Executor exec)

        #_public
        (§ method Action(Agent agent, IFn fn, ISeq args, Executor exec)
            (§ ass this.agent = agent)
            (§ ass this.args = args)
            (§ ass this.fn = fn)
            (§ ass this.exec = exec)
        )

        (§ method void execute()
            (§ try )
            (§
                (§ call exec.execute(this))
            )
            (§ catch (Throwable error))
            (§
                (§ if (agent.errorHandler != nil))
                (§
                    (§ try )
                    (§
                        (§ call agent.errorHandler.invoke(agent, error))
                    )
                    (§ catch (Throwable e)) ;; ignore errorHandler errors
                    (§
                    )
                )
            )
        )

        #_static
        (§ method void doRun(Action action)
            (§ try )
            (§
                (§ call nested.set(PersistentVector.EMPTY))

                (§ let Throwable error = nil)
                (§ try )
                (§
                    (§ let Object oldval = action.agent.state)
                    (§ let Object newval =  action.fn.applyTo(RT.cons(action.agent.state, action.args)))
                    (§ call action.agent.setState(newval))
                    (§ call action.agent.notifyWatches(oldval, newval))
                )
                (§ catch (Throwable e))
                (§
                    (§ ass error = e)
                )

                (§ if (error == nil))
                (§
                    (§ call releasePendingSends())
                )
                (§ else )
                (§
                    (§ call nested.set(nil)) ;; allow errorHandler to send
                    (§ if (action.agent.errorHandler != nil))
                    (§
                        (§ try )
                        (§
                            (§ call action.agent.errorHandler.invoke(action.agent, error))
                        )
                        (§ catch (Throwable e)) ;; ignore errorHandler errors
                        (§
                        )
                    )
                    (§ if (action.agent.errorMode == CONTINUE))
                    (§
                        (§ ass error = nil)
                    )
                )

                (§ let boolean popped = false)
                (§ let ActionQueue next = nil)
                (§ while (!popped))
                (§
                    (§ let ActionQueue prior = action.agent.aq.get())
                    (§ ass next = new ActionQueue(prior.q.pop(), error))
                    (§ ass popped = action.agent.aq.compareAndSet(prior, next))
                )

                (§ if (error == nil && next.q.count() > 0))
                (§
                    ((Action) next.q.peek()).execute()
                )
            )
            (§ finally )
            (§
                (§ call nested.set(nil))
            )
        )

        #_public
        (§ method void run()
            (§ call doRun(this))
        )
    )

    #_public
    (§ method Agent(Object state)
        (§ this(state, nil))
    )

    #_public
    (§ method Agent(Object state, IPersistentMap meta)
        (§ super(meta))
        (§ call setState(state))
    )

    (§ method boolean setState(Object newState)
        (§ call validate(newState))
        (§ let boolean ret = (state != newState))
        (§ ass state = newState)
        (§ return (§ expr ret))
    )

    #_public
    (§ method Object deref()
        (§ return (§ expr state))
    )

    #_public
    (§ method Throwable getError()
        (§ return (§ expr aq.get().error))
    )

    #_public
    (§ method void setErrorMode(Keyword k)
        (§ ass errorMode = k)
    )

    #_public
    (§ method Keyword getErrorMode()
        (§ return (§ expr errorMode))
    )

    #_public
    (§ method void setErrorHandler(IFn f)
        (§ ass errorHandler = f)
    )

    #_public
    (§ method IFn getErrorHandler()
        (§ return (§ expr errorHandler))
    )

    #_synchronized
    #_public
    (§ method Object restart(Object newState, boolean clearActions)
        (§ if (getError() == nil))
        (§
            (§ throw Util.runtimeException("Agent does not need a restart"))
        )
        (§ call validate(newState))
        (§ ass state = newState)

        (§ if (clearActions))
        (§
            (§ call aq.set(ActionQueue.EMPTY))
        )
        (§ else )
        (§
            (§ let boolean restarted = false)
            (§ let ActionQueue prior = nil)
            (§ while (!restarted))
            (§
                (§ ass prior = aq.get())
                (§ ass restarted = aq.compareAndSet(prior, new ActionQueue(prior.q, nil)))
            )

            (§ if (prior.q.count() > 0))
            (§
                ((Action) prior.q.peek()).execute()
            )
        )

        (§ return (§ expr newState))
    )

    #_public
    (§ method Object dispatch(IFn fn, ISeq args, Executor exec)
        (§ let Throwable error = getError())
        (§ if (error != nil))
        (§
            (§ throw Util.runtimeException("Agent is failed, needs restart", error))
        )
        (§ let Action action = new Action(this, fn, args, exec))
        (§ call dispatchAction(action))

        (§ return (§ expr this))
    )

    #_static
    (§ method void dispatchAction(Action action)
        (§ let LockingTransaction trans = LockingTransaction.getRunning())
        (§ if (trans != nil))
        (§
            (§ call trans.enqueue(action))
        )
        (§ elseif (nested.get() != nil))
        (§
            (§ call nested.set(nested.get().cons(action)))
        )
        (§ else )
        (§
            (§ call action.agent.enqueue(action))
        )
    )

    (§ method void enqueue(Action action)
        (§ let boolean queued = false)
        (§ let ActionQueue prior = nil)
        (§ while (!queued))
        (§
            (§ ass prior = aq.get())
            (§ ass queued = aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error)))
        )

        (§ if (prior.q.count() == 0 && prior.error == nil))
        (§
            (§ call action.execute())
        )
    )

    #_public
    (§ method int getQueueCount()
        (§ return (§ expr aq.get().q.count()))
    )

    #_static
    #_public
    (§ method int releasePendingSends()
        (§ let IPersistentVector sends = nested.get())
        (§ if (sends == nil))
        (§
            (§ return (§ expr 0))
        )
        (§ for (int i = 0 i < sends.count() i++))
        (§
            (§ let Action a = (Action) sends.valAt(i))
            (§ call a.agent.enqueue(a))
        )
        (§ call nested.set(PersistentVector.EMPTY))
        (§ return (§ expr sends.count()))
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_public
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_public
    (§ method Object nth(int i)
        (§ if (i == 0))
        (§
            (§ return (§ expr key()))
        )
        (§ elseif (i == 1))
        (§
            (§ return (§ expr val()))
        )
        (§ else )
        (§
            (§ throw new IndexOutOfBoundsException())
        )
    )

    #_private
    (§ method IPersistentVector asVector()
        (§ return (§ expr LazilyPersistentVector.createOwning(key(), val())))
    )

    #_public
    (§ method IPersistentVector assocN(int i, Object val)
        (§ return (§ expr asVector().assocN(i, val)))
    )

    #_public
    (§ method int count()
        (§ return (§ expr 2))
    )

    #_public
    (§ method ISeq seq()
        (§ return (§ expr asVector().seq()))
    )

    #_public
    (§ method IPersistentVector cons(Object o)
        (§ return (§ expr asVector().cons(o)))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr nil))
    )

    #_public
    (§ method IPersistentStack pop()
        (§ return (§ expr LazilyPersistentVector.createOwning(key())))
    )

    #_public
    (§ method Object setValue(Object value)
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

#_public
#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)

    #_public
    (§ method String toString()
        (§ return (§ expr RT.printString(this)))
    )

    #_public
    (§ method IPersistentCollection cons(Object o)
        (§ if (o instanceof Map.Entry))
        (§
            (§ let Map.Entry e = (Map.Entry) o)

            (§ return (§ expr assoc(e.getKey(), e.getValue())))
        )
        (§ elseif (o instanceof IPersistentVector))
        (§
            (§ let IPersistentVector v = (IPersistentVector) o)
            (§ if (v.count() != 2))
            (§
                (§ throw new IllegalArgumentException("Vector arg to map conj must be a pair"))
            )
            (§ return (§ expr assoc(v.nth(0), v.nth(1))))
        )

        (§ let IPersistentMap ret = this)
        (§ for (ISeq es = RT.seq(o) es != nil es = es.next()))
        (§
            (§ let Map.Entry e = (Map.Entry) es.first())
            (§ ass ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ return (§ expr mapEquals(this, obj)))
    )

    #_static
    #_public
    (§ method boolean mapEquals(IPersistentMap m1, Object obj)
        (§ if (m1 == obj))
        (§
            (§ return (§ expr true))
        )
        (§ if (!(obj instanceof Map)))
        (§
            (§ return (§ expr false))
        )
        (§ let Map m = (Map) obj)

        (§ if (m.size() != m1.count()))
        (§
            (§ return (§ expr false))
        )

        (§ for (ISeq s = m1.seq() s != nil s = s.next()))
        (§
            (§ let Map.Entry e = (Map.Entry) s.first())
            (§ let boolean found = m.containsKey(e.getKey()))

            (§ if (!found || !Util.equals(e.getValue(), m.get(e.getKey()))))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ if (!(obj instanceof Map)))
        (§
            (§ return (§ expr false))
        )
        (§ if (obj instanceof IPersistentMap && !(obj instanceof MapEquivalence)))
        (§
            (§ return (§ expr false))
        )

        (§ let Map m = (Map) obj)

        (§ if (m.size() != size()))
        (§
            (§ return (§ expr false))
        )

        (§ for (ISeq s = seq() s != nil s = s.next()))
        (§
            (§ let Map.Entry e = (Map.Entry) s.first())
            (§ let boolean found = m.containsKey(e.getKey()))

            (§ if (!found || !Util.equiv(e.getValue(), m.get(e.getKey()))))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    #_public
    (§ method int hashCode()
        (§ let int cached = this._hash)
        (§ if (cached == 0))
        (§
            (§ ass this._hash = cached = mapHash(this))
        )
        (§ return (§ expr cached))
    )

    #_static
    #_public
    (§ method int mapHash(IPersistentMap m)
        (§ let int hash = 0)
        (§ for (ISeq s = m.seq() s != nil s = s.next()))
        (§
            (§ let Map.Entry e = (Map.Entry) s.first())
            (§ ass hash += ((e.getKey() == nil) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == nil) ? 0 :or e.getValue().hashCode()))
        )
        (§ return (§ expr hash))
    )

    #_public
    (§ method int hasheq()
        (§ let int cached = this._hasheq)
        (§ if (cached == 0))
        (§
            (§ ass this._hasheq = cached = Murmur3.hashUnordered(this))
        )
        (§ return (§ expr cached))
    )

    #_static
    #_public
    (§ method int mapHasheq(IPersistentMap m)
        (§ return (§ expr Murmur3.hashUnordered(m)))
    )

    #_static
    #_public
    (class-ns KeySeq (§ extends ASeq)
        #_final
        (§ field ISeq seq)
        #_final
        (§ field Iterable iterable)

        #_static
        #_public
        (§ method KeySeq create(ISeq seq)
            (§ if (seq == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new KeySeq(seq, nil)))
        )

        #_static
        #_public
        (§ method KeySeq createFromMap(IPersistentMap map)
            (§ if (map == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let ISeq seq = map.seq())
            (§ if (seq == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new KeySeq(seq, map)))
        )

        #_private
        (§ method KeySeq(ISeq seq, Iterable iterable)
            (§ ass this.seq = seq)
            (§ ass this.iterable = iterable)
        )

        #_private
        (§ method KeySeq(IPersistentMap meta, ISeq seq, Iterable iterable)
            (§ super(meta))
            (§ ass this.seq = seq)
            (§ ass this.iterable = iterable)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr ((Map.Entry) seq.first()).getKey()))
        )

        #_public
        (§ method ISeq next()
            (§ return (§ expr create(seq.next())))
        )

        #_public
        (§ method KeySeq withMeta(IPersistentMap meta)
            (§ return (§ expr new KeySeq(meta, seq, iterable)))
        )

        #_public
        (§ method Iterator iterator()
            (§ if (iterable == nil))
            (§
                (§ return (§ expr super.iterator()))
            )

            (§ if (iterable instanceof IMapIterable))
            (§
                (§ return (§ expr ((IMapIterable)iterable).keyIterator()))
            )

            (§ let final Iterator mapIter = iterable.iterator())
            (§ return (§ expr new Iterator()
            (§ inner
                #_public
                (§ method boolean hasNext()
                    (§ return (§ expr mapIter.hasNext()))
                )

                #_public
                (§ method Object next()
                    (§ return (§ expr ((Map.Entry)mapIter.next()).getKey()))
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )
    )

    #_static
    #_public
    (class-ns ValSeq (§ extends ASeq)
        #_final
        (§ field ISeq seq)
        #_final
        (§ field Iterable iterable)

        #_static
        #_public
        (§ method ValSeq create(ISeq seq)
            (§ if (seq == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new ValSeq(seq, nil)))
        )

        #_static
        #_public
        (§ method ValSeq createFromMap(IPersistentMap map)
            (§ if (map == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let ISeq seq = map.seq())
            (§ if (seq == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new ValSeq(seq, map)))
        )

        #_private
        (§ method ValSeq(ISeq seq, Iterable iterable)
            (§ ass this.seq = seq)
            (§ ass this.iterable = iterable)
        )

        #_private
        (§ method ValSeq(IPersistentMap meta, ISeq seq, Iterable iterable)
            (§ super(meta))
            (§ ass this.seq = seq)
            (§ ass this.iterable = iterable)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr ((Map.Entry) seq.first()).getValue()))
        )

        #_public
        (§ method ISeq next()
            (§ return (§ expr create(seq.next())))
        )

        #_public
        (§ method ValSeq withMeta(IPersistentMap meta)
            (§ return (§ expr new ValSeq(meta, seq, iterable)))
        )

        #_public
        (§ method Iterator iterator()
            (§ if (iterable == nil))
            (§
                (§ return (§ expr super.iterator()))
            )

            (§ if (iterable instanceof IMapIterable))
            (§
                (§ return (§ expr ((IMapIterable)iterable).valIterator()))
            )

            (§ let final Iterator mapIter = iterable.iterator())
            (§ return (§ expr new Iterator()
            (§ inner
                #_public
                (§ method boolean hasNext()
                    (§ return (§ expr mapIter.hasNext()))
                )

                #_public
                (§ method Object next()
                    (§ return (§ expr ((Map.Entry)mapIter.next()).getValue()))
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )
    )

    #_static
    #_final
    (§ field IFn MAKE_ENTRY = new AFn()
    (§ inner
        #_public
        (§ method Object invoke(Object key, Object val)
            (§ return (§ expr MapEntry.create(key, val)))
        )
    ))

    #_static
    #_final
    (§ field IFn MAKE_KEY = new AFn()
    (§ inner
        #_public
        (§ method Object invoke(Object key, Object val)
            (§ return (§ expr key))
        )
    ))

    #_static
    #_final
    (§ field IFn MAKE_VAL = new AFn()
    (§ inner
        #_public
        (§ method Object invoke(Object key, Object val)
            (§ return (§ expr val))
        )
    ))

    #_public
    (§ method Object invoke(Object arg1)
        (§ return (§ expr valAt(arg1)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object notFound)
        (§ return (§ expr valAt(arg1, notFound)))
    )

    #_public
    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean containsValue(Object value)
        (§ return (§ expr values().contains(value)))
    )

    #_public
    (§ method Set entrySet()
        (§ return (§ expr new AbstractSet()
        (§ inner
            #_public
            (§ method Iterator iterator()
                (§ return (§ expr APersistentMap.this.iterator()))
            )

            #_public
            (§ method int size()
                (§ return (§ expr count()))
            )

            #_public
            (§ method int hashCode()
                (§ return (§ expr APersistentMap.this.hashCode()))
            )

            #_public
            (§ method boolean contains(Object o)
                (§ if (o instanceof Entry))
                (§
                    (§ let Entry e = (Entry) o)
                    (§ let Entry found = entryAt(e.getKey()))
                    (§ if (found != nil && Util.equals(found.getValue(), e.getValue())))
                    (§
                        (§ return (§ expr true))
                    )
                )
                (§ return (§ expr false))
            )
        )))
    )

    #_public
    (§ method Object get(Object key)
        (§ return (§ expr valAt(key)))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (count() == 0)))
    )

    #_public
    (§ method Set keySet()
        (§ return (§ expr new AbstractSet()
        (§ inner
            #_public
            (§ method Iterator iterator()
                (§ let final Iterator mi = APersistentMap.this.iterator())

                (§ return (§ expr new Iterator()
                (§ inner
                    #_public
                    (§ method boolean hasNext()
                        (§ return (§ expr mi.hasNext()))
                    )

                    #_public
                    (§ method Object next()
                        (§ let Entry e = (Entry) mi.next())
                        (§ return (§ expr e.getKey()))
                    )

                    #_public
                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )))
            )

            #_public
            (§ method int size()
                (§ return (§ expr count()))
            )

            #_public
            (§ method boolean contains(Object o)
                (§ return (§ expr APersistentMap.this.containsKey(o)))
            )
        )))
    )

    #_public
    (§ method Object put(Object key, Object value)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void putAll(Map t)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method Object remove(Object key)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method int size()
        (§ return (§ expr count()))
    )

    #_public
    (§ method Collection values()
        (§ return (§ expr new AbstractCollection()
        (§ inner
            #_public
            (§ method Iterator iterator()
                (§ let final Iterator mi = APersistentMap.this.iterator())

                (§ return (§ expr new Iterator()
                (§ inner
                    #_public
                    (§ method boolean hasNext()
                        (§ return (§ expr mi.hasNext()))
                    )

                    #_public
                    (§ method Object next()
                        (§ let Entry e = (Entry) mi.next())
                        (§ return (§ expr e.getValue()))
                    )

                    #_public
                    (§ method void remove()
                        (§ throw new UnsupportedOperationException())
                    )
                )))
            )

            #_public
            (§ method int size()
                (§ return (§ expr count()))
            )
        )))
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_public
#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)
    #_final
    (§ field IPersistentMap impl)

    #_protected
    (§ method APersistentSet(IPersistentMap impl)
        (§ ass this.impl = impl)
    )

    #_public
    (§ method String toString()
        (§ return (§ expr RT.printString(this)))
    )

    #_public
    (§ method boolean contains(Object key)
        (§ return (§ expr impl.containsKey(key)))
    )

    #_public
    (§ method Object get(Object key)
        (§ return (§ expr impl.valAt(key)))
    )

    #_public
    (§ method int count()
        (§ return (§ expr impl.count()))
    )

    #_public
    (§ method ISeq seq()
        (§ return (§ expr RT.keys(impl)))
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ return (§ expr get(arg1)))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ return (§ expr setEquals(this, obj)))
    )

    #_static
    #_public
    (§ method boolean setEquals(IPersistentSet s1, Object obj)
        (§ if (s1 == obj))
        (§
            (§ return (§ expr true))
        )
        (§ if (!(obj instanceof Set)))
        (§
            (§ return (§ expr false))
        )
        (§ let Set m = (Set) obj)

        (§ if (m.size() != s1.count()))
        (§
            (§ return (§ expr false))
        )

        (§ for (Object aM :in m))
        (§
            (§ if (!s1.contains(aM)))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ if (!(obj instanceof Set)))
        (§
            (§ return (§ expr false))
        )

        (§ let Set m = (Set) obj)

        (§ if (m.size() != size()))
        (§
            (§ return (§ expr false))
        )

        (§ for (Object aM :in m))
        (§
            (§ if (!contains(aM)))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    #_public
    (§ method int hashCode()
        (§ let int hash = this._hash)
        (§ if (hash == 0))
        (§
            (§ for (ISeq s = seq() s != nil s = s.next()))
            (§
                (§ let Object e = s.first())
                (§ ass hash +=  Util.hash(e))
            )
            (§ ass this._hash = hash)
        )
        (§ return (§ expr hash))
    )

    #_public
    (§ method int hasheq()
        (§ let int cached = this._hasheq)
        (§ if (cached == 0))
        (§
            (§ ass this._hasheq = cached = Murmur3.hashUnordered(this))
        )
        (§ return (§ expr cached))
    )

    #_public
    (§ method Object[] toArray()
        (§ return (§ expr RT.seqToArray(seq())))
    )

    #_public
    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean containsAll(Collection c)
        (§ for (Object o :in c))
        (§
            (§ if (!contains(o)))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    #_public
    (§ method Object[] toArray(Object[] a)
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    #_public
    (§ method int size()
        (§ return (§ expr count()))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (count() == 0)))
    )

    #_public
    (§ method Iterator iterator()
        (§ if (impl instanceof IMapIterable))
        (§
            (§ return (§ expr ((IMapIterable)impl).keyIterator()))
        )
        (§ else )
        (§
            (§ return (§ expr new Iterator()
            (§ inner
                #_private
                #_final
                (§ field Iterator iter = impl.iterator())

                #_public
                (§ method boolean hasNext()
                    (§ return (§ expr iter.hasNext()))
                )

                #_public
                (§ method Object next()
                    (§ return (§ expr ((IMapEntry)iter.next()).key()))
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

#_public
#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)

    #_public
    (§ method String toString()
        (§ return (§ expr RT.printString(this)))
    )

    #_public
    (§ method ISeq seq()
        (§ if (count() > 0))
        (§
            (§ return (§ expr new Seq(this, 0)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method ISeq rseq()
        (§ if (count() > 0))
        (§
            (§ return (§ expr new RSeq(this, count() - 1)))
        )
        (§ return (§ expr nil))
    )

    #_static
    (§ method boolean doEquals(IPersistentVector v, Object obj)
        (§ if (obj instanceof IPersistentVector))
        (§
            (§ let IPersistentVector ov = (IPersistentVector) obj)
            (§ if (ov.count() != v.count()))
            (§
                (§ return (§ expr false))
            )
            (§ for (int i = 0 i < v.count() i++))
            (§
                (§ if (!Util.equals(v.nth(i), ov.nth(i))))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        (§ elseif (obj instanceof List))
        (§
            (§ let Collection ma = (Collection) obj)
            (§ if (ma.size() != v.count() || ma.hashCode() != v.hashCode()))
            (§
                (§ return (§ expr false))
            )
            (§ for (Iterator i1 = ((List) v).iterator(), i2 = ma.iterator() i1.hasNext() ))
            (§
                (§ if (!Util.equals(i1.next(), i2.next())))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        (§ else )
        (§
            (§ if (!(obj instanceof Sequential)))
            (§
                (§ return (§ expr false))
            )
            (§ let ISeq ms = RT.seq(obj))
            (§ for (int i = 0 i < v.count() i++, ms = ms.next()))
            (§
                (§ if (ms == nil || !Util.equals(v.nth(i), ms.first())))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ if (ms != nil))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    #_static
    (§ method boolean doEquiv(IPersistentVector v, Object obj)
        (§ if (obj instanceof IPersistentVector))
        (§
            (§ let IPersistentVector ov = (IPersistentVector) obj)
            (§ if (ov.count() != v.count()))
            (§
                (§ return (§ expr false))
            )
            (§ for (int i = 0 i < v.count() i++))
            (§
                (§ if (!Util.equiv(v.nth(i), ov.nth(i))))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        (§ elseif (obj instanceof List))
        (§
            (§ let Collection ma = (Collection) obj)
            (§ if (ma.size() != v.count()))
            (§
                (§ return (§ expr false))
            )
            (§ for (Iterator i1 = ((List) v).iterator(), i2 = ma.iterator() i1.hasNext() ))
            (§
                (§ if (!Util.equiv(i1.next(), i2.next())))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        (§ else )
        (§
            (§ if (!(obj instanceof Sequential)))
            (§
                (§ return (§ expr false))
            )
            (§ let ISeq ms = RT.seq(obj))
            (§ for (int i = 0 i < v.count() i++, ms = ms.next()))
            (§
                (§ if (ms == nil || !Util.equiv(v.nth(i), ms.first())))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ if (ms != nil))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ if (obj == this))
        (§
            (§ return (§ expr true))
        )
        (§ return (§ expr doEquals(this, obj)))
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ if (obj == this))
        (§
            (§ return (§ expr true))
        )
        (§ return (§ expr doEquiv(this, obj)))
    )

    #_public
    (§ method int hashCode()
        (§ let int hash = this._hash)
        (§ if (hash == 0))
        (§
            (§ ass hash = 1)
            (§ for (int i = 0 i < count() i++))
            (§
                (§ let Object obj = nth(i))
                (§ ass hash = 31 * hash + ((obj == nil) ? 0 :or obj.hashCode()))
            )
            (§ ass this._hash = hash)
        )
        (§ return (§ expr hash))
    )

    #_public
    (§ method int hasheq()
        (§ let int hash = this._hasheq)
        (§ if (hash == 0))
        (§
            (§ let int n)
            (§ ass hash = 1)

            (§ for (n = 0 n < count() ++n))
            (§
                (§ ass hash = 31 * hash + Util.hasheq(nth(n)))
            )

            (§ ass this._hasheq = hash = Murmur3.mixCollHash(hash, n))
        )
        (§ return (§ expr hash))
    )

    #_public
    (§ method Object get(int index)
        (§ return (§ expr nth(index)))
    )

    #_public
    (§ method Object nth(int i, Object notFound)
        (§ if (i >= 0 && i < count()))
        (§
            (§ return (§ expr nth(i)))
        )
        (§ return (§ expr notFound))
    )

    #_public
    (§ method Object remove(int i)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method int indexOf(Object o)
        (§ for (int i = 0 i < count() i++))
        (§
            (§ if (Util.equiv(nth(i), o)))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    #_public
    (§ method int lastIndexOf(Object o)
        (§ for (int i = count() - 1 i >= 0 i--))
        (§
            (§ if (Util.equiv(nth(i), o)))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    #_public
    (§ method ListIterator listIterator()
        (§ return (§ expr listIterator(0)))
    )

    #_public
    (§ method ListIterator listIterator(final int index)
        (§ return (§ expr new ListIterator()
        (§ inner
            (§ let int nexti = index)

            #_public
            (§ method boolean hasNext()
                (§ return (§ expr (nexti < count())))
            )

            #_public
            (§ method Object next()
                (§ if (nexti < count()))
                (§
                    (§ return (§ expr nth(nexti++)))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method boolean hasPrevious()
                (§ return (§ expr (nexti > 0)))
            )

            #_public
            (§ method Object previous()
                (§ if (nexti > 0))
                (§
                    (§ return (§ expr nth(--nexti)))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method int nextIndex()
                (§ return (§ expr nexti))
            )

            #_public
            (§ method int previousIndex()
                (§ return (§ expr nexti - 1))
            )

            #_public
            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )

            #_public
            (§ method void set(Object o)
                (§ throw new UnsupportedOperationException())
            )

            #_public
            (§ method void add(Object o)
                (§ throw new UnsupportedOperationException())
            )
        )))
    )

    (§ method Iterator rangedIterator(final int start, final int end)
        (§ return (§ expr new Iterator()
        (§ inner
            (§ let int i = start)

            #_public
            (§ method boolean hasNext()
                (§ return (§ expr (i < end)))
            )

            #_public
            (§ method Object next()
                (§ if (i < end))
                (§
                    (§ return (§ expr nth(i++)))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )))
    )

    #_public
    (§ method List subList(int fromIndex, int toIndex)
        (§ return (§ expr (List) RT.subvec(this, fromIndex, toIndex)))
    )

    #_public
    (§ method Object set(int i, Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void add(int i, Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(int i, Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ if (Util.isInteger(arg1)))
        (§
            (§ return (§ expr nth(((Number) arg1).intValue())))
        )
        (§ throw new IllegalArgumentException("Key must be integer"))
    )

    #_public
    (§ method Iterator iterator()
        ;; todo - something more efficient
        (§ return (§ expr new Iterator()
        (§ inner
            (§ let int i = 0)

            #_public
            (§ method boolean hasNext()
                (§ return (§ expr (i < count())))
            )

            #_public
            (§ method Object next()
                (§ if (i < count()))
                (§
                    (§ return (§ expr nth(i++)))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )))
    )

    #_public
    (§ method Object peek()
        (§ if (count() > 0))
        (§
            (§ return (§ expr nth(count() - 1)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method boolean containsKey(Object key)
        (§ if (!(Util.isInteger(key))))
        (§
            (§ return (§ expr false))
        )
        (§ let int i = ((Number) key).intValue())
        (§ return (§ expr (i >= 0 && i < count())))
    )

    #_public
    (§ method IMapEntry entryAt(Object key)
        (§ if (Util.isInteger(key)))
        (§
            (§ let int i = ((Number) key).intValue())
            (§ if (i >= 0 && i < count()))
            (§
                (§ return (§ expr (IMapEntry) MapEntry.create(key, nth(i))))
            )
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method IPersistentVector assoc(Object key, Object val)
        (§ if (Util.isInteger(key)))
        (§
            (§ let int i = ((Number) key).intValue())
            (§ return (§ expr assocN(i, val)))
        )
        (§ throw new IllegalArgumentException("Key must be integer"))
    )

    #_public
    (§ method Object valAt(Object key, Object notFound)
        (§ if (Util.isInteger(key)))
        (§
            (§ let int i = ((Number) key).intValue())
            (§ if (i >= 0 && i < count()))
            (§
                (§ return (§ expr nth(i)))
            )
        )
        (§ return (§ expr notFound))
    )

    #_public
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    (§ method Object[] toArray()
        (§ let Object[] ret = new Object[count()])
        (§ for (int i = 0 i < count() i++))
        (§
            (§ ass ret[i] = nth(i))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean containsAll(Collection c)
        (§ for (Object o :in c))
        (§
            (§ if (!contains(o)))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    #_public
    (§ method Object[] toArray(Object[] a)
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    #_public
    (§ method int size()
        (§ return (§ expr count()))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (count() == 0)))
    )

    #_public
    (§ method boolean contains(Object o)
        (§ for (ISeq s = seq() s != nil s = s.next()))
        (§
            (§ if (Util.equiv(s.first(), o)))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method int length()
        (§ return (§ expr count()))
    )

    #_public
    (§ method int compareTo(Object o)
        (§ let IPersistentVector v = (IPersistentVector) o)
        (§ if (count() < v.count()))
        (§
            (§ return (§ expr -1))
        )
        (§ elseif (count() > v.count()))
        (§
            (§ return (§ expr 1))
        )
        (§ for (int i = 0 i < count() i++))
        (§
            (§ let int c = Util.compare(nth(i), v.nth(i)))
            (§ if (c != 0))
            (§
                (§ return (§ expr c))
            )
        )
        (§ return (§ expr 0))
    )

    #_static
    (class-ns Seq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        ;; todo - something more efficient
        #_final
        (§ field IPersistentVector v)
        #_final
        (§ field int i)

        #_public
        (§ method Seq(IPersistentVector v, int i)
            (§ ass this.v = v)
            (§ ass this.i = i)
        )

        (§ method Seq(IPersistentMap meta, IPersistentVector v, int i)
            (§ super(meta))
            (§ ass this.v = v)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr v.nth(i)))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < v.count()))
            (§
                (§ return (§ expr new APersistentVector.Seq(v, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method int count()
            (§ return (§ expr v.count() - i))
        )

        #_public
        (§ method APersistentVector.Seq withMeta(IPersistentMap meta)
            (§ return (§ expr new APersistentVector.Seq(meta, v, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = v.nth(i))
            (§ for (int x = i + 1 x < v.count() x++))
            (§
                (§ ass ret = f.invoke(ret, v.nth(x)))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, v.nth(i)))
            (§ for (int x = i + 1 x < v.count() x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, v.nth(x)))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )
    )

    #_public
    #_static
    (class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
        #_final
        (§ field IPersistentVector v)
        #_final
        (§ field int i)

        #_public
        (§ method RSeq(IPersistentVector vector, int i)
            (§ ass this.v = vector)
            (§ ass this.i = i)
        )

        (§ method RSeq(IPersistentMap meta, IPersistentVector v, int i)
            (§ super(meta))
            (§ ass this.v = v)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr v.nth(i)))
        )

        #_public
        (§ method ISeq next()
            (§ if (i > 0))
            (§
                (§ return (§ expr new APersistentVector.RSeq(v, i - 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method int count()
            (§ return (§ expr i + 1))
        )

        #_public
        (§ method APersistentVector.RSeq withMeta(IPersistentMap meta)
            (§ return (§ expr new APersistentVector.RSeq(meta, v, i)))
        )
    )

    #_public
    #_static
    (class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
        #_public
        #_final
        (§ field IPersistentVector v)
        #_public
        #_final
        (§ field int start)
        #_public
        #_final
        (§ field int end)
        #_final
        (§ field IPersistentMap _meta)

        #_public
        (§ method SubVector(IPersistentMap meta, IPersistentVector v, int start, int end)
            (§ ass this._meta = meta)

            (§ if (v instanceof APersistentVector.SubVector))
            (§
                (§ let APersistentVector.SubVector sv = (APersistentVector.SubVector) v)
                (§ ass start += sv.start)
                (§ ass end += sv.start)
                (§ ass v = sv.v)
            )
            (§ ass this.v = v)
            (§ ass this.start = start)
            (§ ass this.end = end)
        )

        #_public
        (§ method Iterator iterator()
            (§ if (v instanceof APersistentVector))
            (§
                (§ return (§ expr ((APersistentVector)v).rangedIterator(start, end)))
            )
            (§ return (§ expr super.iterator()))
        )

        #_public
        (§ method Object nth(int i)
            (§ if ((start + i >= end) || (i < 0)))
            (§
                (§ throw new IndexOutOfBoundsException())
            )
            (§ return (§ expr v.nth(start + i)))
        )

        #_public
        (§ method IPersistentVector assocN(int i, Object val)
            (§ if (start + i > end))
            (§
                (§ throw new IndexOutOfBoundsException())
            )
            (§ elseif (start + i == end))
            (§
                (§ return (§ expr cons(val)))
            )
            (§ return (§ expr new SubVector(_meta, v.assocN(start + i, val), start, end)))
        )

        #_public
        (§ method int count()
            (§ return (§ expr end - start))
        )

        #_public
        (§ method IPersistentVector cons(Object o)
            (§ return (§ expr new SubVector(_meta, v.assocN(end, o), start, end + 1)))
        )

        #_public
        (§ method IPersistentCollection empty()
            (§ return (§ expr PersistentVector.EMPTY.withMeta(meta())))
        )

        #_public
        (§ method IPersistentStack pop()
            (§ if (end - 1 == start))
            (§
                (§ return (§ expr PersistentVector.EMPTY))
            )
            (§ return (§ expr new SubVector(_meta, v, start, end - 1)))
        )

        #_public
        (§ method SubVector withMeta(IPersistentMap meta)
            (§ if (meta == _meta))
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new SubVector(meta, v, start, end)))
        )

        #_public
        (§ method IPersistentMap meta()
            (§ return (§ expr _meta))
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_public
#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    #_protected
    #_volatile
    (§ field IFn validator = nil)
    #_private
    #_volatile
    (§ field IPersistentMap watches = PersistentHashMap.EMPTY)

    #_public
    (§ method ARef()
        (§ super())
    )

    #_public
    (§ method ARef(IPersistentMap meta)
        (§ super(meta))
    )

    (§ method void validate(IFn vf, Object val)
        (§ try )
        (§
            (§ if (vf != nil && !RT.booleanCast(vf.invoke(val))))
            (§
                (§ throw new IllegalStateException("Invalid reference state"))
            )
        )
        (§ catch (RuntimeException re))
        (§
            (§ throw re)
        )
        (§ catch (Exception e))
        (§
            (§ throw new IllegalStateException("Invalid reference state", e))
        )
    )

    (§ method void validate(Object val)
        (§ call validate(validator, val))
    )

    #_public
    (§ method void setValidator(IFn vf)
        (§ call validate(vf, deref()))
        (§ ass validator = vf)
    )

    #_public
    (§ method IFn getValidator()
        (§ return (§ expr validator))
    )

    #_public
    (§ method IPersistentMap getWatches()
        (§ return (§ expr watches))
    )

    #_synchronized
    #_public
    (§ method IRef addWatch(Object key, IFn callback)
        (§ ass watches = watches.assoc(key, callback))
        (§ return (§ expr this))
    )

    #_synchronized
    #_public
    (§ method IRef removeWatch(Object key)
        (§ ass watches = watches.without(key))
        (§ return (§ expr this))
    )

    #_public
    (§ method void notifyWatches(Object oldval, Object newval)
        (§ let IPersistentMap ws = watches)
        (§ if (ws.count() > 0))
        (§
            (§ for (ISeq s = ws.seq() s != nil s = s.next()))
            (§
                (§ let Map.Entry e = (Map.Entry) s.first())
                (§ let IFn fn = (IFn) e.getValue())
                (§ if (fn != nil))
                (§
                    (§ call fn.invoke(e.getKey(), this, oldval, newval))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.AReference

#_public
(class-ns AReference (§ implements IReference)
    #_private
    (§ field IPersistentMap _meta)

    #_public
    (§ method AReference()
        (§ this(nil))
    )

    #_public
    (§ method AReference(IPersistentMap meta)
        (§ ass _meta = meta)
    )

    #_synchronized
    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    #_synchronized
    #_public
    (§ method IPersistentMap alterMeta(IFn alter, ISeq args)
        (§ ass _meta = (IPersistentMap) alter.applyTo(new Cons(_meta, args)))
        (§ return (§ expr _meta))
    )

    #_synchronized
    #_public
    (§ method IPersistentMap resetMeta(IPersistentMap m)
        (§ ass _meta = m)
        (§ return (§ expr m))
    )
)
)

(java-ns cloiure.lang.ArityException

#_public
(class-ns ArityException (§ extends IllegalArgumentException)
    #_final
    #_public
    (§ field int actual)

    #_final
    #_public
    (§ field String name)

    #_public
    (§ method ArityException(int actual, String name)
        (§ this(actual, name, nil))
    )

    #_public
    (§ method ArityException(int actual, String name, Throwable cause)
        (§ super("Wrong number of args (" + actual + ") passed to: " + name, cause))
        (§ ass this.actual = actual)
        (§ ass this.name = name)
    )
)
)

(java-ns cloiure.lang.ArrayChunk

#_public
#_final
(class-ns ArrayChunk (§ implements IChunk)
    #_final
    (§ field Object[] array)
    #_final
    (§ field int off)
    #_final
    (§ field int end)

    #_public
    (§ method ArrayChunk(Object[] array)
        (§ this(array, 0, array.length))
    )

    #_public
    (§ method ArrayChunk(Object[] array, int off)
        (§ this(array, off, array.length))
    )

    #_public
    (§ method ArrayChunk(Object[] array, int off, int end)
        (§ ass this.array = array)
        (§ ass this.off = off)
        (§ ass this.end = end)
    )

    #_public
    (§ method Object nth(int i)
        (§ return (§ expr array[off + i]))
    )

    #_public
    (§ method Object nth(int i, Object notFound)
        (§ if (i >= 0 && i < count()))
        (§
            (§ return (§ expr nth(i)))
        )
        (§ return (§ expr notFound))
    )

    #_public
    (§ method int count()
        (§ return (§ expr end - off))
    )

    #_public
    (§ method IChunk dropFirst()
        (§ if (off == end))
        (§
            (§ throw new IllegalStateException("dropFirst of empty chunk"))
        )
        (§ return (§ expr new ArrayChunk(array, off + 1, end)))
    )

    #_public
    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = f.invoke(start, array[off]))
        (§ if (RT.isReduced(ret)))
        (§
            (§ return (§ expr ret))
        )
        (§ for (int x = off + 1 x < end x++))
        (§
            (§ ass ret = f.invoke(ret, array[x]))
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ret))
            )
        )
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

#_public
(class-ns ArrayIter (§ implements Iterator)
    #_final
    (§ field Object[] array)
    (§ field int i)

    #_static
    #_public
    (§ field Iterator EMPTY_ITERATOR = new Iterator()
    (§ inner
        #_public
        (§ method boolean hasNext()
            (§ return (§ expr false))
        )

        #_public
        (§ method Object next()
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    ))

    #_static
    #_public
    (§ method Iterator create()
        (§ return (§ expr EMPTY_ITERATOR))
    )

    #_static
    #_public
    (§ method Iterator create(Object... array)
        (§ if (array == nil || array.length == 0))
        (§
            (§ return (§ expr EMPTY_ITERATOR))
        )
        (§ return (§ expr new ArrayIter(array, 0)))
    )

    #_static
    #_public
    (§ method Iterator createFromObject(Object array)
        (§ if (array == nil || Array.getLength(array) == 0))
        (§
            (§ return (§ expr EMPTY_ITERATOR))
        )
        (§ let Class aclass = array.getClass())
        (§ if (aclass == int[].class))
        (§
            (§ return (§ expr new ArrayIter_int((int[]) array, 0)))
        )
        (§ if (aclass == float[].class))
        (§
            (§ return (§ expr new ArrayIter_float((float[]) array, 0)))
        )
        (§ if (aclass == double[].class))
        (§
            (§ return (§ expr new ArrayIter_double((double[]) array, 0)))
        )
        (§ if (aclass == long[].class))
        (§
            (§ return (§ expr new ArrayIter_long((long[]) array, 0)))
        )
        (§ if (aclass == byte[].class))
        (§
            (§ return (§ expr new ArrayIter_byte((byte[]) array, 0)))
        )
        (§ if (aclass == char[].class))
        (§
            (§ return (§ expr new ArrayIter_char((char[]) array, 0)))
        )
        (§ if (aclass == short[].class))
        (§
            (§ return (§ expr new ArrayIter_short((short[]) array, 0)))
        )
        (§ if (aclass == boolean[].class))
        (§
            (§ return (§ expr new ArrayIter_boolean((boolean[]) array, 0)))
        )
        (§ return (§ expr new ArrayIter(array, 0)))
    )

    (§ method ArrayIter(Object array, int i)
        (§ ass this.i = i)
        (§ ass this.array = (Object[]) array)
    )

    #_public
    (§ method boolean hasNext()
        (§ return (§ expr (array != nil && i < array.length)))
    )

    #_public
    (§ method Object next()
        (§ if (array != nil && i < array.length))
        (§
            (§ return (§ expr array[i++]))
        )
        (§ throw new java.util.NoSuchElementException())
    )

    #_public
    (§ method void remove()
        (§ throw new UnsupportedOperationException("remove() not supported"))
    )

    #_static
    #_public
    (class-ns ArrayIter_int (§ implements Iterator<Long>)
        #_final
        (§ field int[] array)
        (§ field int i)

        (§ method ArrayIter_int(int[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Long next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr Long.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_float (§ implements Iterator<Double>)
        #_final
        (§ field float[] array)
        (§ field int i)

        (§ method ArrayIter_float(float[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Double next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr Double.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_double (§ implements Iterator<Double>)
        #_final
        (§ field double[] array)
        (§ field int i)

        (§ method ArrayIter_double(double[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Double next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr array[i++]))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_long (§ implements Iterator<Long>)
        #_final
        (§ field long[] array)
        (§ field int i)

        (§ method ArrayIter_long(long[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Long next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr Long.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_byte (§ implements Iterator<Byte>)
        #_final
        (§ field byte[] array)
        (§ field int i)

        (§ method ArrayIter_byte(byte[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Byte next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr array[i++]))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_char (§ implements Iterator<Character>)
        #_final
        (§ field char[] array)
        (§ field int i)

        (§ method ArrayIter_char(char[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Character next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr array[i++]))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_short (§ implements Iterator<Long>)
        #_final
        (§ field short[] array)
        (§ field int i)

        (§ method ArrayIter_short(short[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Long next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr Long.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )

    #_static
    #_public
    (class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
        #_final
        (§ field boolean[] array)
        (§ field int i)

        (§ method ArrayIter_boolean(boolean[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (array != nil && i < array.length)))
        )

        #_public
        (§ method Boolean next()
            (§ if (array != nil && i < array.length))
            (§
                (§ return (§ expr Boolean.valueOf(array[i++])))
            )
            (§ throw new java.util.NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException("remove() not supported"))
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

#_public
(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    #_public
    #_final
    (§ field Object[] array)
    #_final
    (§ field int i)

    #_static
    #_public
    (§ method ArraySeq create()
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method ArraySeq create(Object... array)
        (§ if (array == nil || array.length == 0))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new ArraySeq(array, 0)))
    )

    #_static
    (§ method ISeq createFromObject(Object array)
        (§ if (array == nil || Array.getLength(array) == 0))
        (§
            (§ return (§ expr nil))
        )
        (§ let Class aclass = array.getClass())
        (§ if (aclass == int[].class))
        (§
            (§ return (§ expr new ArraySeq_int(nil, (int[]) array, 0)))
        )
        (§ if (aclass == float[].class))
        (§
            (§ return (§ expr new ArraySeq_float(nil, (float[]) array, 0)))
        )
        (§ if (aclass == double[].class))
        (§
            (§ return (§ expr new ArraySeq_double(nil, (double[]) array, 0)))
        )
        (§ if (aclass == long[].class))
        (§
            (§ return (§ expr new ArraySeq_long(nil, (long[]) array, 0)))
        )
        (§ if (aclass == byte[].class))
        (§
            (§ return (§ expr new ArraySeq_byte(nil, (byte[]) array, 0)))
        )
        (§ if (aclass == char[].class))
        (§
            (§ return (§ expr new ArraySeq_char(nil, (char[]) array, 0)))
        )
        (§ if (aclass == short[].class))
        (§
            (§ return (§ expr new ArraySeq_short(nil, (short[]) array, 0)))
        )
        (§ if (aclass == boolean[].class))
        (§
            (§ return (§ expr new ArraySeq_boolean(nil, (boolean[]) array, 0)))
        )
        (§ return (§ expr new ArraySeq(array, 0)))
    )

    (§ method ArraySeq(Object array, int i)
        (§ ass this.i = i)
        (§ ass this.array = (Object[]) array)
    )

    (§ method ArraySeq(IPersistentMap meta, Object array, int i)
        (§ super(meta))
        (§ ass this.i = i)
        (§ ass this.array = (Object[]) array)
    )

    #_public
    (§ method Object first()
        (§ if (array != nil))
        (§
            (§ return (§ expr array[i]))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method ISeq next()
        (§ if (array != nil && i + 1 < array.length))
        (§
            (§ return (§ expr new ArraySeq(array, i + 1)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method int count()
        (§ if (array != nil))
        (§
            (§ return (§ expr array.length - i))
        )
        (§ return (§ expr 0))
    )

    #_public
    (§ method int index()
        (§ return (§ expr i))
    )

    #_public
    (§ method ArraySeq withMeta(IPersistentMap meta)
        (§ return (§ expr new ArraySeq(meta, array, i)))
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ if (array != nil))
        (§
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method Object reduce(IFn f, Object start)
        (§ if (array != nil))
        (§
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method int indexOf(Object o)
        (§ if (array != nil))
        (§
            (§ for (int j = i j < array.length j++))
            (§
                (§ if (Util.equals(o, array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
        )
        (§ return (§ expr -1))
    )

    #_public
    (§ method int lastIndexOf(Object o)
        (§ if (array != nil))
        (§
            (§ if (o == nil))
            (§
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (array[j] == nil))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ else )
            (§
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (o.equals(array[j])))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
        )
        (§ return (§ expr -1))
    )

    #_static
    #_public
    (class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field int[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_int(IPersistentMap meta, int[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr array[i]))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_int(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_int withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_int(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let int k = ((Number) o).intValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (k == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let int k = ((Number) o).intValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (k == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field float[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_float(IPersistentMap meta, float[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr Numbers.num(array[i])))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_float(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_float withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_float(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = Numbers.num(array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, Numbers.num(array[x])))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, Numbers.num(array[i])))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, Numbers.num(array[x])))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let float f = ((Number) o).floatValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (f == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let float f = ((Number) o).floatValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (f == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field double[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_double(IPersistentMap meta, double[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr array[i]))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_double(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_double withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_double(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let double d = ((Number) o).doubleValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (d == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let double d = ((Number) o).doubleValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (d == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field long[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_long(IPersistentMap meta, long[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr Numbers.num(array[i])))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_long(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_long withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_long(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = Numbers.num(array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, Numbers.num(array[x])))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, Numbers.num(array[i])))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, Numbers.num(array[x])))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let long l = ((Number) o).longValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (l == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Number))
            (§
                (§ let long l = ((Number) o).longValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (l == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field byte[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_byte(IPersistentMap meta, byte[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr array[i]))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_byte(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_byte withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_byte(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Byte))
            (§
                (§ let byte b = ((Byte) o).byteValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (b == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = i j < array.length j++))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Byte))
            (§
                (§ let byte b = ((Byte) o).byteValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (b == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = array.length - 1 j >= i j--))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field char[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_char(IPersistentMap meta, char[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr array[i]))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_char(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_char withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_char(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Character))
            (§
                (§ let char c = ((Character) o).charValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (c == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = i j < array.length j++))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Character))
            (§
                (§ let char c = ((Character) o).charValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (c == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = array.length - 1 j >= i j--))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field short[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_short(IPersistentMap meta, short[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr array[i]))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_short(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_short withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_short(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Short))
            (§
                (§ let short s = ((Short) o).shortValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (s == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = i j < array.length j++))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Short))
            (§
                (§ let short s = ((Short) o).shortValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (s == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = array.length - 1 j >= i j--))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )

    #_static
    #_public
    (class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        #_public
        #_final
        (§ field boolean[] array)
        #_final
        (§ field int i)

        (§ method ArraySeq_boolean(IPersistentMap meta, boolean[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr array[i]))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 1 < array.length))
            (§
                (§ return (§ expr new ArraySeq_boolean(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr array.length - i))
        )

        #_public
        (§ method int index()
            (§ return (§ expr i))
        )

        #_public
        (§ method ArraySeq_boolean withMeta(IPersistentMap meta)
            (§ return (§ expr new ArraySeq_boolean(meta, array, i)))
        )

        #_public
        (§ method Object reduce(IFn f)
            (§ let Object ret = array[i])
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ ass ret = f.invoke(ret, array[x]))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method Object reduce(IFn f, Object start)
            (§ let Object ret = f.invoke(start, array[i]))
            (§ for (int x = i + 1 x < array.length x++))
            (§
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                (§ ass ret = f.invoke(ret, array[x]))
            )
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method int indexOf(Object o)
            (§ if (o instanceof Boolean))
            (§
                (§ let boolean b = ((Boolean) o).booleanValue())
                (§ for (int j = i j < array.length j++))
                (§
                    (§ if (b == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = i j < array.length j++))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ if (o instanceof Boolean))
            (§
                (§ let boolean b = ((Boolean) o).booleanValue())
                (§ for (int j = array.length - 1 j >= i j--))
                (§
                    (§ if (b == array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ if (o == nil))
            (§
                (§ return (§ expr -1))
            )
            (§ for (int j = array.length - 1 j >= i j--))
            (§
                (§ if (o.equals(array[j])))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_public
#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    #_transient
    (§ field int _hash)
    #_transient
    (§ field int _hasheq)

    #_public
    (§ method String toString()
        (§ return (§ expr RT.printString(this)))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr PersistentList.EMPTY))
    )

    #_protected
    (§ method ASeq(IPersistentMap meta)
        (§ super(meta))
    )

    #_protected
    (§ method ASeq()
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ if (!(obj instanceof Sequential || obj instanceof List)))
        (§
            (§ return (§ expr false))
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ for (ISeq s = seq() s != nil s = s.next(), ms = ms.next()))
        (§
            (§ if (ms == nil || !Util.equiv(s.first(), ms.first())))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ if (this == obj))
        (§
            (§ return (§ expr true))
        )
        (§ if (!(obj instanceof Sequential || obj instanceof List)))
        (§
            (§ return (§ expr false))
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ for (ISeq s = seq() s != nil s = s.next(), ms = ms.next()))
        (§
            (§ if (ms == nil || !Util.equals(s.first(), ms.first())))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    #_public
    (§ method int hashCode()
        (§ if (_hash == 0))
        (§
            (§ let int hash = 1)
            (§ for (ISeq s = seq() s != nil s = s.next()))
            (§
                (§ ass hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
            )
            (§ ass this._hash = hash)
        )
        (§ return (§ expr _hash))
    )

    #_public
    (§ method int hasheq()
        (§ if (_hasheq == 0))
        (§
            (§ ass _hasheq = Murmur3.hashOrdered(this))
        )
        (§ return (§ expr _hasheq))
    )

    #_public
    (§ method int count()
        (§ let int i = 1)
        (§ for (ISeq s = next() s != nil s = s.next(), i++))
        (§
            (§ if (s instanceof Counted))
            (§
                (§ return (§ expr i + s.count()))
            )
        )
        (§ return (§ expr i))
    )

    #_final
    #_public
    (§ method ISeq seq()
        (§ return (§ expr this))
    )

    #_public
    (§ method ISeq cons(Object o)
        (§ return (§ expr new Cons(o, this)))
    )

    #_public
    (§ method ISeq more()
        (§ let ISeq s = next())
        (§ if (s == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr s))
    )

    #_public
    (§ method Object[] toArray()
        (§ return (§ expr RT.seqToArray(seq())))
    )

    #_public
    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean containsAll(Collection c)
        (§ for (Object o :in c))
        (§
            (§ if (!contains(o)))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    #_public
    (§ method Object[] toArray(Object[] a)
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    #_public
    (§ method int size()
        (§ return (§ expr count()))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (seq() == nil)))
    )

    #_public
    (§ method boolean contains(Object o)
        (§ for (ISeq s = seq() s != nil s = s.next()))
        (§
            (§ if (Util.equiv(s.first(), o)))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr new SeqIterator(this)))
    )

    #_private
    (§ method List reify()
        (§ return (§ expr Collections.unmodifiableList(new ArrayList(this))))
    )

    #_public
    (§ method List subList(int fromIndex, int toIndex)
        (§ return (§ expr reify().subList(fromIndex, toIndex)))
    )

    #_public
    (§ method Object set(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method Object remove(int index)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method int indexOf(Object o)
        (§ let ISeq s = seq())
        (§ for (int i = 0 s != nil s = s.next(), i++))
        (§
            (§ if (Util.equiv(s.first(), o)))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    #_public
    (§ method int lastIndexOf(Object o)
        (§ return (§ expr reify().lastIndexOf(o)))
    )

    #_public
    (§ method ListIterator listIterator()
        (§ return (§ expr reify().listIterator()))
    )

    #_public
    (§ method ListIterator listIterator(int index)
        (§ return (§ expr reify().listIterator(index)))
    )

    #_public
    (§ method Object get(int index)
        (§ return (§ expr RT.nth(this, index)))
    )

    #_public
    (§ method void add(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(int index, Collection c)
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.Associative

#_public
(§ interface Associative (§ extends IPersistentCollection, ILookup)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
    (§ abstract Associative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

#_final
#_public
(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    #_final
    (§ field AtomicReference state)

    #_public
    (§ method Atom(Object state)
        (§ ass this.state = new AtomicReference(state))
    )

    #_public
    (§ method Atom(Object state, IPersistentMap meta)
        (§ super(meta))
        (§ ass this.state = new AtomicReference(state))
    )

    #_public
    (§ method Object deref()
        (§ return (§ expr state.get()))
    )

    #_public
    (§ method Object swap(IFn f)
        (§ while (true))
        (§
            (§ let Object v = deref())
            (§ let Object newv = f.invoke(v))
            (§ call validate(newv))
            (§ if (state.compareAndSet(v, newv)))
            (§
                (§ call notifyWatches(v, newv))
                (§ return (§ expr newv))
            )
        )
    )

    #_public
    (§ method Object swap(IFn f, Object arg)
        (§ while (true))
        (§
            (§ let Object v = deref())
            (§ let Object newv = f.invoke(v, arg))
            (§ call validate(newv))
            (§ if (state.compareAndSet(v, newv)))
            (§
                (§ call notifyWatches(v, newv))
                (§ return (§ expr newv))
            )
        )
    )

    #_public
    (§ method Object swap(IFn f, Object arg1, Object arg2)
        (§ while (true))
        (§
            (§ let Object v = deref())
            (§ let Object newv = f.invoke(v, arg1, arg2))
            (§ call validate(newv))
            (§ if (state.compareAndSet(v, newv)))
            (§
                (§ call notifyWatches(v, newv))
                (§ return (§ expr newv))
            )
        )
    )

    #_public
    (§ method Object swap(IFn f, Object x, Object y, ISeq args)
        (§ while (true))
        (§
            (§ let Object v = deref())
            (§ let Object newv = f.applyTo(RT.listStar(v, x, y, args)))
            (§ call validate(newv))
            (§ if (state.compareAndSet(v, newv)))
            (§
                (§ call notifyWatches(v, newv))
                (§ return (§ expr newv))
            )
        )
    )

    #_public
    (§ method IPersistentVector swapVals(IFn f)
        (§ while (true))
        (§
            (§ let Object oldv = deref())
            (§ let Object newv = f.invoke(oldv))
            (§ call validate(newv))
            (§ if (state.compareAndSet(oldv, newv)))
            (§
                (§ call notifyWatches(oldv, newv))
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    #_public
    (§ method IPersistentVector swapVals(IFn f, Object arg)
        (§ while (true))
        (§
            (§ let Object oldv = deref())
            (§ let Object newv = f.invoke(oldv, arg))
            (§ call validate(newv))
            (§ if (state.compareAndSet(oldv, newv)))
            (§
                (§ call notifyWatches(oldv, newv))
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    #_public
    (§ method IPersistentVector swapVals(IFn f, Object arg1, Object arg2)
        (§ while (true))
        (§
            (§ let Object oldv = deref())
            (§ let Object newv = f.invoke(oldv, arg1, arg2))
            (§ call validate(newv))
            (§ if (state.compareAndSet(oldv, newv)))
            (§
                (§ call notifyWatches(oldv, newv))
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    #_public
    (§ method IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)
        (§ while (true))
        (§
            (§ let Object oldv = deref())
            (§ let Object newv = f.applyTo(RT.listStar(oldv, x, y, args)))
            (§ call validate(newv))
            (§ if (state.compareAndSet(oldv, newv)))
            (§
                (§ call notifyWatches(oldv, newv))
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    #_public
    (§ method boolean compareAndSet(Object oldv, Object newv)
        (§ call validate(newv))
        (§ let boolean ret = state.compareAndSet(oldv, newv))
        (§ if (ret))
        (§
            (§ call notifyWatches(oldv, newv))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method Object reset(Object newval)
        (§ let Object oldval = state.get())
        (§ call validate(newval))
        (§ call state.set(newval))
        (§ call notifyWatches(oldval, newval))
        (§ return (§ expr newval))
    )

    #_public
    (§ method IPersistentVector resetVals(Object newv)
        (§ call validate(newv))
        (§ while (true))
        (§
            (§ let Object oldv = deref())
            (§ if (state.compareAndSet(oldv, newv)))
            (§
                (§ call notifyWatches(oldv, newv))
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

(§ import cloiure.lang.PersistentHashMap.INode)

#_public
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    (§ abstract void ensureEditable())
    (§ abstract ITransientMap doAssoc(Object key, Object val))
    (§ abstract ITransientMap doWithout(Object key))
    (§ abstract Object doValAt(Object key, Object notFound))
    (§ abstract int doCount())
    (§ abstract IPersistentMap doPersistent())

    #_public
    (§ method ITransientMap conj(Object o)
        (§ call ensureEditable())
        (§ if (o instanceof Map.Entry))
        (§
            (§ let Map.Entry e = (Map.Entry) o)

            (§ return (§ expr assoc(e.getKey(), e.getValue())))
        )
        (§ elseif (o instanceof IPersistentVector))
        (§
            (§ let IPersistentVector v = (IPersistentVector) o)
            (§ if (v.count() != 2))
            (§
                (§ throw new IllegalArgumentException("Vector arg to map conj must be a pair"))
            )
            (§ return (§ expr assoc(v.nth(0), v.nth(1))))
        )

        (§ let ITransientMap ret = this)
        (§ for (ISeq es = RT.seq(o) es != nil es = es.next()))
        (§
            (§ let Map.Entry e = (Map.Entry) es.first())
            (§ ass ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (§ return (§ expr ret))
    )

    #_public
    #_final
    (§ method Object invoke(Object arg1)
        (§ return (§ expr valAt(arg1)))
    )

    #_public
    #_final
    (§ method Object invoke(Object arg1, Object notFound)
        (§ return (§ expr valAt(arg1, notFound)))
    )

    #_public
    #_final
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    #_final
    (§ method ITransientMap assoc(Object key, Object val)
        (§ call ensureEditable())
        (§ return (§ expr doAssoc(key, val)))
    )

    #_public
    #_final
    (§ method ITransientMap without(Object key)
        (§ call ensureEditable())
        (§ return (§ expr doWithout(key)))
    )

    #_public
    #_final
    (§ method IPersistentMap persistent()
        (§ call ensureEditable())
        (§ return (§ expr doPersistent()))
    )

    #_public
    #_final
    (§ method Object valAt(Object key, Object notFound)
        (§ call ensureEditable())
        (§ return (§ expr doValAt(key, notFound)))
    )

    #_private
    #_static
    #_final
    (§ field Object NOT_FOUND = new Object())
    #_public
    #_final
    (§ method boolean containsKey(Object key)
        (§ return (§ expr (valAt(key, NOT_FOUND) != NOT_FOUND)))
    )
    #_public
    #_final
    (§ method IMapEntry entryAt(Object key)
        (§ let Object v = valAt(key, NOT_FOUND))
        (§ if (v != NOT_FOUND))
        (§
            (§ return (§ expr MapEntry.create(key, v)))
        )
        (§ return (§ expr nil))
    )

    #_public
    #_final
    (§ method int count()
        (§ call ensureEditable())
        (§ return (§ expr doCount()))
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_public
#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    #_volatile
    (§ field ITransientMap impl)

    (§ method ATransientSet(ITransientMap impl)
        (§ ass this.impl = impl)
    )

    #_public
    (§ method int count()
        (§ return (§ expr impl.count()))
    )

    #_public
    (§ method ITransientSet conj(Object val)
        (§ let ITransientMap m = impl.assoc(val, val))
        (§ if (m != impl))
        (§
            (§ ass this.impl = m)
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method boolean contains(Object key)
        (§ return (§ expr (this != impl.valAt(key, this))))
    )

    #_public
    (§ method ITransientSet disjoin(Object key)
        (§ let ITransientMap m = impl.without(key))
        (§ if (m != impl))
        (§
            (§ ass this.impl = m)
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method Object get(Object key)
        (§ return (§ expr impl.valAt(key)))
    )

    #_public
    (§ method Object invoke(Object key, Object notFound)
        (§ return (§ expr impl.valAt(key, notFound)))
    )

    #_public
    (§ method Object invoke(Object key)
        (§ return (§ expr impl.valAt(key)))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

#_public
#_final
(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    #_final
    #_public
    (§ field long lpart)
    #_final
    #_public
    (§ field BigInteger bipart)

    #_final
    #_public
    #_static
    (§ field BigInt ZERO = new BigInt(0, nil))
    #_final
    #_public
    #_static
    (§ field BigInt ONE = new BigInt(1, nil))

    ;; must follow Long
    #_public
    (§ method int hashCode()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (§ return (§ expr bipart.hashCode()))
    )

    #_public
    (§ method int hasheq()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr Murmur3.hashLong(lpart)))
        )
        (§ return (§ expr bipart.hashCode()))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ if (this == obj))
        (§
            (§ return (§ expr true))
        )
        (§ if (obj instanceof BigInt))
        (§
            (§ let BigInt o = (BigInt) obj)
            (§ if (bipart == nil))
            (§
                (§ return (§ expr (o.bipart == nil && this.lpart == o.lpart)))
            )
            (§ return (§ expr (o.bipart != nil && this.bipart.equals(o.bipart))))
        )
        (§ return (§ expr false))
    )

    #_private
    (§ method BigInt(long lpart, BigInteger bipart)
        (§ ass this.lpart = lpart)
        (§ ass this.bipart = bipart)
    )

    #_public
    #_static
    (§ method BigInt fromBigInteger(BigInteger val)
        (§ if (val.bitLength() < 64))
        (§
            (§ return (§ expr new BigInt(val.longValue(), nil)))
        )
        (§ else )
        (§
            (§ return (§ expr new BigInt(0, val)))
        )
    )

    #_public
    #_static
    (§ method BigInt fromLong(long val)
        (§ return (§ expr new BigInt(val, nil)))
    )

    #_public
    (§ method BigInteger toBigInteger()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr BigInteger.valueOf(lpart)))
        )
        (§ else )
        (§
            (§ return (§ expr bipart))
        )
    )

    #_public
    (§ method BigDecimal toBigDecimal()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr BigDecimal.valueOf(lpart)))
        )
        (§ else )
        (§
            (§ return (§ expr new BigDecimal(bipart)))
        )
    )

    #_public
    (§ method int intValue()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr (int) lpart))
        )
        (§ else )
        (§
            (§ return (§ expr bipart.intValue()))
        )
    )

    #_public
    (§ method long longValue()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr lpart))
        )
        (§ else )
        (§
            (§ return (§ expr bipart.longValue()))
        )
    )

    #_public
    (§ method float floatValue()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr lpart))
        )
        (§ else )
        (§
            (§ return (§ expr bipart.floatValue()))
        )
    )

    #_public
    (§ method double doubleValue()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr lpart))
        )
        (§ else )
        (§
            (§ return (§ expr bipart.doubleValue()))
        )
    )

    #_public
    (§ method byte byteValue()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr (byte) lpart))
        )
        (§ else )
        (§
            (§ return (§ expr bipart.byteValue()))
        )
    )

    #_public
    (§ method short shortValue()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr (short) lpart))
        )
        (§ else )
        (§
            (§ return (§ expr bipart.shortValue()))
        )
    )

    #_public
    #_static
    (§ method BigInt valueOf(long val)
        (§ return (§ expr new BigInt(val, nil)))
    )

    #_public
    (§ method String toString()
        (§ if (bipart == nil))
        (§
            (§ return (§ expr String.valueOf(lpart)))
        )
        (§ return (§ expr bipart.toString()))
    )

    #_public
    (§ method int bitLength()
        (§ return (§ expr toBigInteger().bitLength()))
    )

    #_public
    (§ method BigInt add(BigInt y)
        (§ if ((bipart == nil) && (y.bipart == nil)))
        (§
            (§ let long ret = lpart + y.lpart)
            (§ if ((ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0))
            (§
                (§ return (§ expr BigInt.valueOf(ret)))
            )
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger()))))
    )

    #_public
    (§ method BigInt multiply(BigInt y)
        (§ if ((bipart == nil) && (y.bipart == nil)))
        (§
            (§ let long ret = lpart * y.lpart)
            (§ if (y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE)))
            (§
                (§ return (§ expr BigInt.valueOf(ret)))
            )
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger()))))
    )

    #_public
    (§ method BigInt quotient(BigInt y)
        (§ if ((bipart == nil) && (y.bipart == nil)))
        (§
            (§ if (lpart == Long.MIN_VALUE && y.lpart == -1))
            (§
                (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (§ expr BigInt.valueOf(lpart / y.lpart)))
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger()))))
    )

    #_public
    (§ method BigInt remainder(BigInt y)
        (§ if ((bipart == nil) && (y.bipart == nil)))
        (§
            (§ return (§ expr BigInt.valueOf(lpart % y.lpart)))
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger()))))
    )

    #_public
    (§ method boolean lt(BigInt y)
        (§ if ((bipart == nil) && (y.bipart == nil)))
        (§
            (§ return (§ expr (lpart < y.lpart)))
        )
        (§ return (§ expr (this.toBigInteger().compareTo(y.toBigInteger()) < 0)))
    )
)
)

(java-ns cloiure.lang.Binding

#_public
(class-ns Binding #_"<T>"
    #_public
    (§ field T val)
    #_public
    #_final
    (§ field Binding rest)

    #_public
    (§ method Binding(T val)
        (§ ass this.val = val)
        (§ ass this.rest = nil)
    )

    #_public
    (§ method Binding(T val, Binding rest)
        (§ ass this.val = val)
        (§ ass this.rest = rest)
    )
)
)

(java-ns cloiure.lang.Box

#_public
(class-ns Box
    #_public
    (§ field Object val)

    #_public
    (§ method Box(Object val)
        (§ ass this.val = val)
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

#_final
#_public
(class-ns ChunkBuffer (§ implements Counted)
    (§ field Object[] buffer)
    (§ field int end)

    #_public
    (§ method ChunkBuffer(int capacity)
        (§ ass buffer = new Object[capacity])
        (§ ass end = 0)
    )

    #_public
    (§ method void add(Object o)
        (§ ass buffer[end++] = o)
    )

    #_public
    (§ method IChunk chunk()
        (§ let ArrayChunk ret = new ArrayChunk(buffer, 0, end))
        (§ ass buffer = nil)
        (§ return (§ expr ret))
    )

    #_public
    (§ method int count()
        (§ return (§ expr end))
    )
)
)

(java-ns cloiure.lang.ChunkedCons

#_final
#_public
(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    #_final
    (§ field IChunk chunk)
    #_final
    (§ field ISeq _more)

    (§ method ChunkedCons(IPersistentMap meta, IChunk chunk, ISeq more)
        (§ super(meta))
        (§ ass this.chunk = chunk)
        (§ ass this._more = more)
    )

    #_public
    (§ method ChunkedCons(IChunk chunk, ISeq more)
        (§ this(nil, chunk, more))
    )

    #_public
    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (meta != _meta))
        (§
            (§ return (§ expr new ChunkedCons(meta, chunk, _more)))
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr chunk.nth(0)))
    )

    #_public
    (§ method ISeq next()
        (§ if (chunk.count() > 1))
        (§
            (§ return (§ expr new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (§ return (§ expr chunkedNext()))
    )

    #_public
    (§ method ISeq more()
        (§ if (chunk.count() > 1))
        (§
            (§ return (§ expr new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (§ if (_more == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _more))
    )

    #_public
    (§ method IChunk chunkedFirst()
        (§ return (§ expr chunk))
    )

    #_public
    (§ method ISeq chunkedNext()
        (§ return (§ expr chunkedMore().seq()))
    )

    #_public
    (§ method ISeq chunkedMore()
        (§ if (_more == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _more))
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

#_public
(class-ns Compile
    #_private
    #_static
    #_final
    (§ field String PATH_PROP = "cloiure.compile.path")
    #_private
    #_static
    #_final
    (§ field String REFLECTION_WARNING_PROP = "cloiure.compile.warn-on-reflection")
    #_private
    #_static
    #_final
    (§ field String UNCHECKED_MATH_PROP = "cloiure.compile.unchecked-math")

    #_private
    #_static
    #_final
    (§ field Var compile_path = RT.var("cloiure.core", "*compile-path*"))
    #_private
    #_static
    #_final
    (§ field Var compile = RT.var("cloiure.core", "compile"))
    #_private
    #_static
    #_final
    (§ field Var warn_on_reflection = RT.var("cloiure.core", "*warn-on-reflection*"))
    #_private
    #_static
    #_final
    (§ field Var unchecked_math = RT.var("cloiure.core", "*unchecked-math*"))

    #_public
    #_static
    (§ method void main(String[] args) (§ throws IOException, ClassNotFoundException)
        (§ let OutputStreamWriter out = (OutputStreamWriter) RT.OUT.deref())
        (§ let PrintWriter err = RT.errPrintWriter())
        (§ let String path = System.getProperty(PATH_PROP))
        (§ let int count = args.length)

        (§ if (path == nil))
        (§
            (§ call err.println("ERROR: Must set system property " + PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
            (§ call System.exit(1))
        )

        (§ let boolean warnOnReflection = System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true"))
        (§ let String uncheckedMathProp = System.getProperty(UNCHECKED_MATH_PROP))
        (§ let Object uncheckedMath = Boolean.FALSE)
        (§ if ("true".equals(uncheckedMathProp)))
        (§
            (§ ass uncheckedMath = Boolean.TRUE)
        )
        (§ elseif ("warn-on-boxed".equals(uncheckedMathProp)))
        (§
            (§ ass uncheckedMath = Keyword.intern("warn-on-boxed"))
        )

        ;; force load to avoid transitive compilation during lazy load
        (§ call RT.load("cloiure/core/specs/alpha"))

        (§ try )
        (§
            (§ call Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath)))

            (§ for (String lib :in args))
            (§
                (§ call out.write("Compiling " + lib + " to " + path + "\n"))
                (§ call out.flush())
                (§ call compile.invoke(Symbol.intern(lib)))
            )
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
            (§ try )
            (§
                (§ call out.flush())
            )
            (§ catch (IOException e))
            (§
                (§ call e.printStackTrace(err))
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

#_public
(class-ns Compiler (§ implements Opcodes)
    #_static
    #_final
    (§ field Symbol DEF = Symbol.intern("def"))
    #_static
    #_final
    (§ field Symbol LOOP = Symbol.intern("loop*"))
    #_static
    #_final
    (§ field Symbol RECUR = Symbol.intern("recur"))
    #_static
    #_final
    (§ field Symbol IF = Symbol.intern("if"))
    #_static
    #_final
    (§ field Symbol LET = Symbol.intern("let*"))
    #_static
    #_final
    (§ field Symbol LETFN = Symbol.intern("letfn*"))
    #_static
    #_final
    (§ field Symbol DO = Symbol.intern("do"))
    #_static
    #_final
    (§ field Symbol FN = Symbol.intern("fn*"))
    #_static
    #_final
    (§ field Symbol FNONCE = (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(nil, "once"), RT.T)))
    #_static
    #_final
    (§ field Symbol QUOTE = Symbol.intern("quote"))
    #_static
    #_final
    (§ field Symbol THE_VAR = Symbol.intern("var"))
    #_static
    #_final
    (§ field Symbol DOT = Symbol.intern("."))
    #_static
    #_final
    (§ field Symbol ASSIGN = Symbol.intern("set!"))
    #_static
    #_final
    (§ field Symbol TRY = Symbol.intern("try"))
    #_static
    #_final
    (§ field Symbol CATCH = Symbol.intern("catch"))
    #_static
    #_final
    (§ field Symbol FINALLY = Symbol.intern("finally"))
    #_static
    #_final
    (§ field Symbol THROW = Symbol.intern("throw"))
    #_static
    #_final
    (§ field Symbol MONITOR_ENTER = Symbol.intern("monitor-enter"))
    #_static
    #_final
    (§ field Symbol MONITOR_EXIT = Symbol.intern("monitor-exit"))
    #_static
    #_final
    (§ field Symbol IMPORT = Symbol.intern("cloiure.core", "import*"))
    #_static
    #_final
    (§ field Symbol DEFTYPE = Symbol.intern("deftype*"))
    #_static
    #_final
    (§ field Symbol CASE = Symbol.intern("case*"))

    #_static
    #_final
    (§ field Symbol CLASS = Symbol.intern("Class"))
    #_static
    #_final
    (§ field Symbol NEW = Symbol.intern("new"))
    #_static
    #_final
    (§ field Symbol THIS = Symbol.intern("this"))
    #_static
    #_final
    (§ field Symbol REIFY = Symbol.intern("reify*"))
    #_static
    #_final
    (§ field Symbol LIST = Symbol.intern("cloiure.core", "list"))
    #_static
    #_final
    (§ field Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map"))
    #_static
    #_final
    (§ field Symbol VECTOR = Symbol.intern("cloiure.core", "vector"))
    #_static
    #_final
    (§ field Symbol IDENTITY = Symbol.intern("cloiure.core", "identity"))

    #_static
    #_final
    (§ field Symbol _AMP_ = Symbol.intern("&"))
    #_static
    #_final
    (§ field Symbol ISEQ = Symbol.intern("cloiure.lang.ISeq"))

    #_static
    #_final
    (§ field Keyword loadNs = Keyword.intern(nil, "load-ns"))
    #_static
    #_final
    (§ field Keyword inlineKey = Keyword.intern(nil, "inline"))
    #_static
    #_final
    (§ field Keyword inlineAritiesKey = Keyword.intern(nil, "inline-arities"))
    #_static
    #_final
    (§ field Keyword staticKey = Keyword.intern(nil, "static"))
    #_static
    #_final
    (§ field Keyword arglistsKey = Keyword.intern(nil, "arglists"))
    #_static
    #_final
    (§ field Symbol INVOKE_STATIC = Symbol.intern("invokeStatic"))

    #_static
    #_final
    (§ field Keyword volatileKey = Keyword.intern(nil, "volatile"))
    #_static
    #_final
    (§ field Keyword implementsKey = Keyword.intern(nil, "implements"))
    #_static
    #_final
    (§ field String COMPILE_STUB_PREFIX = "compile__stub")

    #_static
    #_final
    (§ field Keyword protocolKey = Keyword.intern(nil, "protocol"))
    #_static
    #_final
    (§ field Keyword onKey = Keyword.intern(nil, "on"))
    #_static
    (§ field Keyword dynamicKey = Keyword.intern("dynamic"))
    #_static
    #_final
    (§ field Keyword redefKey = Keyword.intern(nil, "redef"))

    #_static
    #_final
    (§ field Symbol NS = Symbol.intern("ns"))
    #_static
    #_final
    (§ field Symbol IN_NS = Symbol.intern("in-ns"))

    #_static
    #_final
    #_public
    (§ field IPersistentMap specials = PersistentHashMap.create(
  #_map DEF, new DefExpr.Parser(),
  #_map LOOP, new LetExpr.Parser(),
  #_map RECUR, new RecurExpr.Parser(),
  #_map IF, new IfExpr.Parser(),
  #_map CASE, new CaseExpr.Parser(),
  #_map LET, new LetExpr.Parser(),
  #_map LETFN, new LetFnExpr.Parser(),
  #_map DO, new BodyExpr.Parser(),
  #_map FN, nil,
  #_map QUOTE, new ConstantExpr.Parser(),
  #_map THE_VAR, new TheVarExpr.Parser(),
  #_map IMPORT, new ImportExpr.Parser(),
  #_map DOT, new HostExpr.Parser(),
  #_map ASSIGN, new AssignExpr.Parser(),
  #_map DEFTYPE, new NewInstanceExpr.DeftypeParser(),
  #_map REIFY, new NewInstanceExpr.ReifyParser(),
  #_map TRY, new TryExpr.Parser(),
  #_map THROW, new ThrowExpr.Parser(),
  #_map MONITOR_ENTER, new MonitorEnterExpr.Parser(),
  #_map MONITOR_EXIT, new MonitorExitExpr.Parser(),
  #_map CATCH, nil,
  #_map FINALLY, nil,
  #_map NEW, new NewExpr.Parser(),
  #_map _AMP_, nil
    ))

    #_private
    #_static
    #_final
    (§ field int MAX_POSITIONAL_ARITY = 20)
    #_private
    #_static
    #_final
    (§ field Type OBJECT_TYPE)
    #_private
    #_static
    #_final
    (§ field Type KEYWORD_TYPE = Type.getType(Keyword.class))
    #_private
    #_static
    #_final
    (§ field Type VAR_TYPE = Type.getType(Var.class))
    #_private
    #_static
    #_final
    (§ field Type SYMBOL_TYPE = Type.getType(Symbol.class))
    #_private
    #_static
    #_final
    (§ field Type IFN_TYPE = Type.getType(IFn.class))
    #_private
    #_static
    #_final
    (§ field Type AFUNCTION_TYPE = Type.getType(AFunction.class))
    #_private
    #_static
    #_final
    (§ field Type RT_TYPE = Type.getType(RT.class))
    #_private
    #_static
    #_final
    (§ field Type NUMBERS_TYPE = Type.getType(Numbers.class))

    #_final
    #_static
    (§ field Type CLASS_TYPE = Type.getType(Class.class))
    #_final
    #_static
    (§ field Type NS_TYPE = Type.getType(Namespace.class))
    #_final
    #_static
    (§ field Type UTIL_TYPE = Type.getType(Util.class))
    #_final
    #_static
    (§ field Type REFLECTOR_TYPE = Type.getType(Reflector.class))
    #_final
    #_static
    (§ field Type THROWABLE_TYPE = Type.getType(Throwable.class))
    #_final
    #_static
    (§ field Type BOOLEAN_OBJECT_TYPE = Type.getType(Boolean.class))
    #_final
    #_static
    (§ field Type IPERSISTENTMAP_TYPE = Type.getType(IPersistentMap.class))
    #_final
    #_static
    (§ field Type IOBJ_TYPE = Type.getType(IObj.class))
    #_final
    #_static
    (§ field Type TUPLE_TYPE = Type.getType(Tuple.class))

    #_final
    #_static
    (§ field Method[] createTupleMethods =
    (§ array
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create()")),
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create(Object)")),
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)")),
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)")),
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)")),
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)")),
        (§ expr Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)"))
    ))

    #_private
    #_static
    #_final
    (§ field Type[][] ARG_TYPES)
    #_private
    #_static
    #_final
    (§ field Type[] EXCEPTION_TYPES = (§))

    (§ static )
    (§
        (§ ass OBJECT_TYPE = Type.getType(Object.class))
        (§ ass ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][])
        (§ for (int i = 0 i <= MAX_POSITIONAL_ARITY ++i))
        (§
            (§ let Type[] a = new Type[i])
            (§ for (int j = 0 j < i j++))
            (§
                (§ ass a[j] = OBJECT_TYPE)
            )
            (§ ass ARG_TYPES[i] = a)
        )
        (§ let Type[] a = new Type[MAX_POSITIONAL_ARITY + 1])
        (§ for (int j = 0 j < MAX_POSITIONAL_ARITY j++))
        (§
            (§ ass a[j] = OBJECT_TYPE)
        )
        (§ ass a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/Object;"))
        (§ ass ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a)
    )

    ;; symbol->localbinding
    #_static
    #_final
    #_public
    (§ field Var LOCAL_ENV = Var.create(nil).setDynamic())

    ;; vector<localbinding>
    #_static
    #_final
    #_public
    (§ field Var LOOP_LOCALS = Var.create().setDynamic())

    ;; Label
    #_static
    #_final
    #_public
    (§ field Var LOOP_LABEL = Var.create().setDynamic())

    ;; vector<object>
    #_static
    #_final
    #_public
    (§ field Var CONSTANTS = Var.create().setDynamic())

    ;; IdentityHashMap
    #_static
    #_final
    #_public
    (§ field Var CONSTANT_IDS = Var.create().setDynamic())

    ;; vector<keyword>
    #_static
    #_final
    #_public
    (§ field Var KEYWORD_CALLSITES = Var.create().setDynamic())

    ;; vector<var>
    #_static
    #_final
    #_public
    (§ field Var PROTOCOL_CALLSITES = Var.create().setDynamic())

    ;; set<var>
    #_static
    #_final
    #_public
    (§ field Var VAR_CALLSITES = Var.create().setDynamic())

    ;; keyword->constid
    #_static
    #_final
    #_public
    (§ field Var KEYWORDS = Var.create().setDynamic())

    ;; var->constid
    #_static
    #_final
    #_public
    (§ field Var VARS = Var.create().setDynamic())

    ;; FnFrame
    #_static
    #_final
    #_public
    (§ field Var METHOD = Var.create(nil).setDynamic())

    ;; nil or not
    #_static
    #_final
    #_public
    (§ field Var IN_CATCH_FINALLY = Var.create(nil).setDynamic())

    #_static
    #_final
    #_public
    (§ field Var METHOD_RETURN_CONTEXT = Var.create(nil).setDynamic())

    #_static
    #_final
    #_public
    (§ field Var NO_RECUR = Var.create(nil).setDynamic())

    ;; DynamicClassLoader
    #_static
    #_final
    #_public
    (§ field Var LOADER = Var.create().setDynamic())

    ;; String
    #_static
    #_final
    #_public
    (§ field Var SOURCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic())

    ;; String
    #_static
    #_final
    #_public
    (§ field Var SOURCE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic())

    ;; String
    #_static
    #_final
    #_public
    (§ field Var COMPILE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), nil).setDynamic())
    ;; boolean
    #_static
    #_final
    #_public
    (§ field Var COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic())

    #_static
    #_final
    #_public
    (§ field Var INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?")))

    #_static
    #_final
    #_public
    (§ field Var ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations")))

    #_static
    #_final
    #_public
    (§ field Keyword disableLocalsClearingKey = Keyword.intern("disable-locals-clearing"))
    #_static
    #_final
    #_public
    (§ field Keyword directLinkingKey = Keyword.intern("direct-linking"))
    #_static
    #_final
    #_public
    (§ field Keyword elideMetaKey = Keyword.intern("elide-meta"))

    #_static
    #_final
    #_public
    (§ field Var COMPILER_OPTIONS)

    #_static
    #_public
    (§ method Object getCompilerOption(Keyword k)
        (§ return (§ expr RT.get(COMPILER_OPTIONS.deref(), k)))
    )

    (§ static )
    (§
        (§ let Object compilerOptions = nil)

        (§ for (Map.Entry e :in System.getProperties().entrySet()))
        (§
            (§ let String name = (String) e.getKey())
            (§ let String v = (String) e.getValue())
            (§ if (name.startsWith("cloiure.compiler.")))
            (§
                (§ ass compilerOptions = RT.assoc(compilerOptions, RT.keyword(nil, name.substring(1 + name.lastIndexOf(\.))), RT.readString(v)))
            )
        )

        (§ ass COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic())
    )

    #_static
    (§ method Object elideMeta(Object m)
        (§ let Collection<Object> elides = (Collection<Object>) getCompilerOption(elideMetaKey))
        (§ if (elides != nil))
        (§
            (§ for (Object k :in elides))
            (§
                (§ ass m = RT.dissoc(m, k))
            )
        )
        (§ return (§ expr m))
    )

    ;; Integer
    #_static
    #_final
    #_public
    (§ field Var LINE = Var.create(0).setDynamic())
    #_static
    #_final
    #_public
    (§ field Var COLUMN = Var.create(0).setDynamic())

    #_static
    (§ method int lineDeref()
        (§ return (§ expr ((Number)LINE.deref()).intValue()))
    )

    #_static
    (§ method int columnDeref()
        (§ return (§ expr ((Number)COLUMN.deref()).intValue()))
    )

    ;; Integer
    #_static
    #_final
    #_public
    (§ field Var LINE_BEFORE = Var.create(0).setDynamic())
    #_static
    #_final
    #_public
    (§ field Var COLUMN_BEFORE = Var.create(0).setDynamic())
    #_static
    #_final
    #_public
    (§ field Var LINE_AFTER = Var.create(0).setDynamic())
    #_static
    #_final
    #_public
    (§ field Var COLUMN_AFTER = Var.create(0).setDynamic())

    ;; Integer
    #_static
    #_final
    #_public
    (§ field Var NEXT_LOCAL_NUM = Var.create(0).setDynamic())

    ;; Integer
    #_static
    #_final
    #_public
    (§ field Var RET_LOCAL_NUM = Var.create().setDynamic())

    #_static
    #_final
    #_public
    (§ field Var COMPILE_STUB_SYM = Var.create(nil).setDynamic())
    #_static
    #_final
    #_public
    (§ field Var COMPILE_STUB_CLASS = Var.create(nil).setDynamic())

    ;; PathNode chain
    #_static
    #_final
    #_public
    (§ field Var CLEAR_PATH = Var.create(nil).setDynamic())

    ;; tail of PathNode chain
    #_static
    #_final
    #_public
    (§ field Var CLEAR_ROOT = Var.create(nil).setDynamic())

    ;; LocalBinding -> Set<LocalBindingExpr>
    #_static
    #_final
    #_public
    (§ field Var CLEAR_SITES = Var.create(nil).setDynamic())

    #_public
    (§ enum C
        (§ item STATEMENT), ;; value ignored
        (§ item EXPRESSION), ;; value required
        (§ item RETURN), ;; tail position relative to enclosing recur frame
        (§ item EVAL)
    )

    #_private
    (class-ns Recur
    )

    #_static
    #_final
    #_public
    (§ field Class RECUR_CLASS = Recur.class)

    (§ interface Expr
        (§ abstract Object eval())
        (§ abstract void emit(C context, ObjExpr objx, GeneratorAdapter gen))
        (§ abstract boolean hasJavaClass())
        (§ abstract Class getJavaClass())
    )

    #_public
    #_static
    #_abstract
    (class-ns UntypedExpr (§ implements Expr)
        #_public
        (§ method Class getJavaClass()
            (§ throw new IllegalArgumentException("Has no Java class"))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr false))
        )
    )

    (§ interface IParser
        (§ abstract Expr parse(C context, Object form))
    )

    #_static
    (§ method boolean isSpecial(Object sym)
        (§ return (§ expr specials.containsKey(sym)))
    )

    #_static
    (§ method boolean inTailCall(C context)
        (§ return (§ expr (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil)))
    )

    #_static
    (§ method Symbol resolveSymbol(Symbol sym)
        ;; already qualified or classname?
        (§ if (sym.name.indexOf(\.) > 0))
        (§
            (§ return (§ expr sym))
        )
        (§ if (sym.ns != nil))
        (§
            (§ let Namespace ns = namespaceFor(sym))
            (§ if (ns == nil || ((ns.name.name == nil) ? (sym.ns == nil) :or ns.name.name.equals(sym.ns))))
            (§
                (§ return (§ expr sym))
            )
            (§ return (§ expr Symbol.intern(ns.name.name, sym.name)))
        )
        (§ let Object o = currentNS().getMapping(sym))
        (§ if (o == nil))
        (§
            (§ return (§ expr Symbol.intern(currentNS().name.name, sym.name)))
        )
        (§ elseif (o instanceof Class))
        (§
            (§ return (§ expr Symbol.intern(nil, ((Class) o).getName())))
        )
        (§ elseif (o instanceof Var))
        (§
            (§ let Var v = (Var) o)
            (§ return (§ expr Symbol.intern(v.ns.name.name, v.sym.name)))
        )
        (§ return (§ expr nil))
    )

    #_static
    (class-ns DefExpr (§ implements Expr)
        #_public
        #_final
        (§ field Var var)
        #_public
        #_final
        (§ field Expr init)
        #_public
        #_final
        (§ field Expr meta)
        #_public
        #_final
        (§ field boolean initProvided)
        #_public
        #_final
        (§ field boolean isDynamic)
        #_public
        #_final
        (§ field boolean shadowsCoreMapping)
        #_public
        #_final
        (§ field String source)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)

        #_final
        #_static
        (§ field Method bindRootMethod = Method.getMethod("void bindRoot(Object)"))
        #_final
        #_static
        (§ field Method setTagMethod = Method.getMethod("void setTag(cloiure.lang.Symbol)"))
        #_final
        #_static
        (§ field Method setMetaMethod = Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)"))
        #_final
        #_static
        (§ field Method setDynamicMethod = Method.getMethod("cloiure.lang.Var setDynamic(boolean)"))
        #_final
        #_static
        (§ field Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String, String)"))
        #_final
        #_static
        (§ field Method internVar = Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

        #_public
        (§ method DefExpr(String source, int line, int column, Var var, Expr init, Expr meta, boolean initProvided, boolean isDynamic, boolean shadowsCoreMapping)
            (§ ass this.source = source)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.var = var)
            (§ ass this.init = init)
            (§ ass this.meta = meta)
            (§ ass this.isDynamic = isDynamic)
            (§ ass this.shadowsCoreMapping = shadowsCoreMapping)
            (§ ass this.initProvided = initProvided)
        )

        #_private
        (§ method boolean includesExplicitMetadata(MapExpr expr)
            (§ for (int i = 0 i < expr.keyvals.count() i += 2))
            (§
                (§ let Keyword k = ((KeywordExpr) expr.keyvals.nth(i)).k)
                (§ if ((k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY)))
                (§
                    (§ return (§ expr true))
                )
            )
            (§ return (§ expr false))
        )

        #_public
        (§ method Object eval()
            (§ try )
            (§
                (§ if (initProvided))
                (§
                    (§ call var.bindRoot(init.eval()))
                )
                (§ if (meta != nil))
                (§
                    (§ let IPersistentMap metaMap = (IPersistentMap) meta.eval())
                    (§ if (initProvided || true)) ;; includesExplicitMetadata((MapExpr) meta)
                    (§
                        (§ call var.setMeta(metaMap))
                    )
                )
                (§ return (§ expr var.setDynamic(isDynamic)))
            )
            (§ catch (Throwable e))
            (§
                (§ if (!(e instanceof CompilerException)))
                (§
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else )
                (§
                    (§ throw (CompilerException) e)
                )
            )
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call objx.emitVar(gen, var))

            (§ if (shadowsCoreMapping))
            (§
                (§ call gen.dup())
                (§ call gen.getField(VAR_TYPE, "ns", NS_TYPE))
                (§ call gen.swap())
                (§ call gen.dup())
                (§ call gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE))
                (§ call gen.swap())
                (§ call gen.invokeVirtual(NS_TYPE, internVar))
            )

            (§ if (isDynamic))
            (§
                (§ call gen.push(isDynamic))
                (§ call gen.invokeVirtual(VAR_TYPE, setDynamicMethod))
            )
            (§ if (meta != nil))
            (§
                (§ if (initProvided || true)) ;; includesExplicitMetadata((MapExpr) meta)
                (§
                    (§ call gen.dup())
                    (§ call meta.emit(C.EXPRESSION, objx, gen))
                    (§ call gen.checkCast(IPERSISTENTMAP_TYPE))
                    (§ call gen.invokeVirtual(VAR_TYPE, setMetaMethod))
                )
            )
            (§ if (initProvided))
            (§
                (§ call gen.dup())
                (§ if (init instanceof FnExpr))
                (§
                    ((FnExpr)init).emitForDefn(objx, gen)
                )
                (§ else )
                (§
                    (§ call init.emit(C.EXPRESSION, objx, gen))
                )
                (§ call gen.invokeVirtual(VAR_TYPE, bindRootMethod))
            )

            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr Var.class))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object form)
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                (§ let String docstring = nil)
                (§ if (RT.count(form) == 4 && (RT.third(form) instanceof String)))
                (§
                    (§ ass docstring = (String) RT.third(form))
                    (§ ass form = RT.list(RT.first(form), RT.second(form), RT.fourth(form)))
                )
                (§ if (RT.count(form) > 3))
                (§
                    (§ throw Util.runtimeException("Too many arguments to def"))
                )
                (§ elseif (RT.count(form) < 2))
                (§
                    (§ throw Util.runtimeException("Too few arguments to def"))
                )
                (§ elseif (!(RT.second(form) instanceof Symbol)))
                (§
                    (§ throw Util.runtimeException("First argument to def must be a Symbol"))
                )
                (§ let Symbol sym = (Symbol) RT.second(form))
                (§ let Var v = lookupVar(sym, true))
                (§ if (v == nil))
                (§
                    (§ throw Util.runtimeException("Can't refer to qualified var that doesn't exist"))
                )
                (§ let boolean shadowsCoreMapping = false)
                (§ if (!v.ns.equals(currentNS())))
                (§
                    (§ if (sym.ns == nil))
                    (§
                        (§ ass v = currentNS().intern(sym))
                        (§ ass shadowsCoreMapping = true)
                        (§ call registerVar(v))
                    )
                    (§ else )
                    (§
                        (§ throw Util.runtimeException("Can't create defs outside of current ns"))
                    )
                )
                (§ let IPersistentMap mm = sym.meta())
                (§ let boolean isDynamic = RT.booleanCast(RT.get(mm, dynamicKey)))
                (§ if (isDynamic))
                (§
                    (§ call v.setDynamic())
                )
                (§ if (!isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2))
                (§
                    (§ call RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", sym, SOURCE_PATH.get(), LINE.get()))
                )
                (§ if (RT.booleanCast(RT.get(mm, arglistsKey))))
                (§
                    (§ let IPersistentMap vm = v.meta())
                    ;; drop quote
                    (§ ass vm = (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey))))
                    (§ call v.setMeta(vm))
                )
                (§ let Object source_path = SOURCE_PATH.get())
                (§ ass source_path = (source_path == nil) ? "NO_SOURCE_FILE" :or source_path)
                (§ ass mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path))
                (§ if (docstring != nil))
                (§
                    (§ ass mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring))
                )
                (§ ass mm = (IPersistentMap) elideMeta(mm))
                (§ let Expr meta = (mm.count() == 0) ? nil :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm))
                (§ return (§ expr new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name), meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping)))
            )
        )
    )

    #_public
    #_static
    (class-ns AssignExpr (§ implements Expr)
        #_public
        #_final
        (§ field AssignableExpr target)
        #_public
        #_final
        (§ field Expr val)

        #_public
        (§ method AssignExpr(AssignableExpr target, Expr val)
            (§ ass this.target = target)
            (§ ass this.val = val)
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr target.evalAssign(val)))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call target.emitAssign(context, objx, gen, val))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr val.hasJavaClass()))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr val.getJavaClass()))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                (§ if (RT.length(form) != 3))
                (§
                    (§ throw new IllegalArgumentException("Malformed assignment, expecting (set! target val)"))
                )
                (§ let Expr target = analyze(C.EXPRESSION, RT.second(form)))
                (§ if (!(target instanceof AssignableExpr)))
                (§
                    (§ throw new IllegalArgumentException("Invalid assignment target"))
                )
                (§ return (§ expr new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form)))))
            )
        )
    )

    #_public
    #_static
    (class-ns VarExpr (§ implements Expr, AssignableExpr)
        #_public
        #_final
        (§ field Var var)
        #_public
        #_final
        (§ field Object tag)
        #_final
        #_static
        (§ field Method getMethod = Method.getMethod("Object get()"))
        #_final
        #_static
        (§ field Method setMethod = Method.getMethod("Object set(Object)"))

        (§ field Class jc)

        #_public
        (§ method VarExpr(Var var, Symbol tag)
            (§ ass this.var = var)
            (§ ass this.tag = (tag != nil) ? tag :or var.getTag())
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr var.deref()))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call objx.emitVarValue(gen, var))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (tag != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = HostExpr.tagToClass(tag))
            )
            (§ return (§ expr jc))
        )

        #_public
        (§ method Object evalAssign(Expr val)
            (§ return (§ expr var.set(val.eval())))
        )

        #_public
        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (§ call objx.emitVar(gen, var))
            (§ call val.emit(C.EXPRESSION, objx, gen))
            (§ call gen.invokeVirtual(VAR_TYPE, setMethod))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )
    )

    #_public
    #_static
    (class-ns TheVarExpr (§ implements Expr)
        #_public
        #_final
        (§ field Var var)

        #_public
        (§ method TheVarExpr(Var var)
            (§ ass this.var = var)
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr var))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call objx.emitVar(gen, var))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr Var.class))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object form)
                (§ let Symbol sym = (Symbol) RT.second(form))
                (§ let Var v = lookupVar(sym, false))
                (§ if (v != nil))
                (§
                    (§ return (§ expr new TheVarExpr(v)))
                )
                (§ throw Util.runtimeException("Unable to resolve var: " + sym + " in this context"))
            )
        )
    )

    #_public
    #_static
    (class-ns KeywordExpr (§ extends LiteralExpr)
        #_public
        #_final
        (§ field Keyword k)

        #_public
        (§ method KeywordExpr(Keyword k)
            (§ ass this.k = k)
        )

        (§ method Object val()
            (§ return (§ expr k))
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr k))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call objx.emitKeyword(gen, k))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr Keyword.class))
        )
    )

    #_public
    #_static
    (class-ns ImportExpr (§ implements Expr)
        #_public
        #_final
        (§ field String c)

        #_final
        #_static
        (§ field Method forNameMethod = Method.getMethod("Class classForNameNonLoading(String)"))
        #_final
        #_static
        (§ field Method importClassMethod = Method.getMethod("Class importClass(Class)"))
        #_final
        #_static
        (§ field Method derefMethod = Method.getMethod("Object deref()"))

        #_public
        (§ method ImportExpr(String c)
            (§ ass this.c = c)
        )

        #_public
        (§ method Object eval()
            (§ let Namespace ns = (Namespace) RT.CURRENT_NS.deref())
            (§ call ns.importClass(RT.classForNameNonLoading(c)))
            (§ return (§ expr nil))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE))
            (§ call gen.invokeVirtual(VAR_TYPE, derefMethod))
            (§ call gen.checkCast(NS_TYPE))
            (§ call gen.push(c))
            (§ call gen.invokeStatic(RT_TYPE, forNameMethod))
            (§ call gen.invokeVirtual(NS_TYPE, importClassMethod))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr false))
        )

        #_public
        (§ method Class getJavaClass()
            (§ throw new IllegalArgumentException("ImportExpr has no Java class"))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object form)
                (§ return (§ expr new ImportExpr((String) RT.second(form))))
            )
        )
    )

    #_public
    #_static
    #_abstract
    (class-ns LiteralExpr (§ implements Expr)
        (§ abstract Object val())

        #_public
        (§ method Object eval()
            (§ return (§ expr val()))
        )
    )

    #_static
    (§ interface AssignableExpr
        (§ abstract Object evalAssign(Expr val))
        (§ abstract void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val))
    )

    #_static
    #_public
    (§ interface MaybePrimitiveExpr (§ extends Expr)
        (§ abstract boolean canEmitPrimitive())
        (§ abstract void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen))
    )

    #_static
    #_public
    #_abstract
    (class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
        #_final
        #_static
        (§ field Type BOOLEAN_TYPE = Type.getType(Boolean.class))
        #_final
        #_static
        (§ field Type CHAR_TYPE = Type.getType(Character.class))
        #_final
        #_static
        (§ field Type INTEGER_TYPE = Type.getType(Integer.class))
        #_final
        #_static
        (§ field Type LONG_TYPE = Type.getType(Long.class))
        #_final
        #_static
        (§ field Type FLOAT_TYPE = Type.getType(Float.class))
        #_final
        #_static
        (§ field Type DOUBLE_TYPE = Type.getType(Double.class))
        #_final
        #_static
        (§ field Type SHORT_TYPE = Type.getType(Short.class))
        #_final
        #_static
        (§ field Type BYTE_TYPE = Type.getType(Byte.class))
        #_final
        #_static
        (§ field Type NUMBER_TYPE = Type.getType(Number.class))

        #_final
        #_static
        (§ field Method charValueMethod = Method.getMethod("char charValue()"))
        #_final
        #_static
        (§ field Method booleanValueMethod = Method.getMethod("boolean booleanValue()"))

        #_final
        #_static
        (§ field Method charValueOfMethod = Method.getMethod("Character valueOf(char)"))
        #_final
        #_static
        (§ field Method intValueOfMethod = Method.getMethod("Integer valueOf(int)"))
        #_final
        #_static
        (§ field Method longValueOfMethod = Method.getMethod("Long valueOf(long)"))
        #_final
        #_static
        (§ field Method floatValueOfMethod = Method.getMethod("Float valueOf(float)"))
        #_final
        #_static
        (§ field Method doubleValueOfMethod = Method.getMethod("Double valueOf(double)"))
        #_final
        #_static
        (§ field Method shortValueOfMethod = Method.getMethod("Short valueOf(short)"))
        #_final
        #_static
        (§ field Method byteValueOfMethod = Method.getMethod("Byte valueOf(byte)"))

        #_final
        #_static
        (§ field Method intValueMethod = Method.getMethod("int intValue()"))
        #_final
        #_static
        (§ field Method longValueMethod = Method.getMethod("long longValue()"))
        #_final
        #_static
        (§ field Method floatValueMethod = Method.getMethod("float floatValue()"))
        #_final
        #_static
        (§ field Method doubleValueMethod = Method.getMethod("double doubleValue()"))
        #_final
        #_static
        (§ field Method byteValueMethod = Method.getMethod("byte byteValue()"))
        #_final
        #_static
        (§ field Method shortValueMethod = Method.getMethod("short shortValue()"))

        #_final
        #_static
        (§ field Method fromIntMethod = Method.getMethod("cloiure.lang.Num from(int)"))
        #_final
        #_static
        (§ field Method fromLongMethod = Method.getMethod("cloiure.lang.Num from(long)"))
        #_final
        #_static
        (§ field Method fromDoubleMethod = Method.getMethod("cloiure.lang.Num from(double)"))

        #_public
        #_static
        (§ method void emitBoxReturn(ObjExpr objx, GeneratorAdapter gen, Class returnType)
            (§ if (returnType.isPrimitive()))
            (§
                (§ if (returnType == boolean.class))
                (§
                    (§ let Label falseLabel = gen.newLabel())
                    (§ let Label endLabel = gen.newLabel())
                    (§ call gen.ifZCmp(GeneratorAdapter.EQ, falseLabel))
                    (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                    (§ call gen.goTo(endLabel))
                    (§ call gen.mark(falseLabel))
                    (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                    (§ call gen.mark(endLabel))
                )
                (§ elseif (returnType == void.class))
                (§
                    (§ call NIL_EXPR.emit(C.EXPRESSION, objx, gen))
                )
                (§ elseif (returnType == char.class))
                (§
                    (§ call gen.invokeStatic(CHAR_TYPE, charValueOfMethod))
                )
                (§ else )
                (§
                    (§ if (returnType == int.class))
                    (§
                        (§ call gen.invokeStatic(INTEGER_TYPE, intValueOfMethod))
                    )
                    (§ elseif (returnType == float.class))
                    (§
                        (§ call gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod))
                    )
                    (§ elseif (returnType == double.class))
                    (§
                        (§ call gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod))
                    )
                    (§ elseif (returnType == long.class))
                    (§
                        (§ call gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)")))
                    )
                    (§ elseif (returnType == byte.class))
                    (§
                        (§ call gen.invokeStatic(BYTE_TYPE, byteValueOfMethod))
                    )
                    (§ elseif (returnType == short.class))
                    (§
                        (§ call gen.invokeStatic(SHORT_TYPE, shortValueOfMethod))
                    )
                )
            )
        )

        #_public
        #_static
        (§ method void emitUnboxArg(ObjExpr objx, GeneratorAdapter gen, Class paramType)
            (§ if (paramType.isPrimitive()))
            (§
                (§ if (paramType == boolean.class))
                (§
                    (§ call gen.checkCast(BOOLEAN_TYPE))
                    (§ call gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod))
                )
                (§ elseif (paramType == char.class))
                (§
                    (§ call gen.checkCast(CHAR_TYPE))
                    (§ call gen.invokeVirtual(CHAR_TYPE, charValueMethod))
                )
                (§ else )
                (§
                    (§ let Method m = nil)
                    (§ call gen.checkCast(NUMBER_TYPE))
                    (§ if (RT.booleanCast(RT.UNCHECKED_MATH.deref())))
                    (§
                        (§ if (paramType == int.class))
                        (§
                            (§ ass m = Method.getMethod("int uncheckedIntCast(Object)"))
                        )
                        (§ elseif (paramType == float.class))
                        (§
                            (§ ass m = Method.getMethod("float uncheckedFloatCast(Object)"))
                        )
                        (§ elseif (paramType == double.class))
                        (§
                            (§ ass m = Method.getMethod("double uncheckedDoubleCast(Object)"))
                        )
                        (§ elseif (paramType == long.class))
                        (§
                            (§ ass m = Method.getMethod("long uncheckedLongCast(Object)"))
                        )
                        (§ elseif (paramType == byte.class))
                        (§
                            (§ ass m = Method.getMethod("byte uncheckedByteCast(Object)"))
                        )
                        (§ elseif (paramType == short.class))
                        (§
                            (§ ass m = Method.getMethod("short uncheckedShortCast(Object)"))
                        )
                    )
                    (§ else )
                    (§
                        (§ if (paramType == int.class))
                        (§
                            (§ ass m = Method.getMethod("int intCast(Object)"))
                        )
                        (§ elseif (paramType == float.class))
                        (§
                            (§ ass m = Method.getMethod("float floatCast(Object)"))
                        )
                        (§ elseif (paramType == double.class))
                        (§
                            (§ ass m = Method.getMethod("double doubleCast(Object)"))
                        )
                        (§ elseif (paramType == long.class))
                        (§
                            (§ ass m = Method.getMethod("long longCast(Object)"))
                        )
                        (§ elseif (paramType == byte.class))
                        (§
                            (§ ass m = Method.getMethod("byte byteCast(Object)"))
                        )
                        (§ elseif (paramType == short.class))
                        (§
                            (§ ass m = Method.getMethod("short shortCast(Object)"))
                        )
                    )
                    (§ call gen.invokeStatic(RT_TYPE, m))
                )
            )
            (§ else )
            (§
                (§ call gen.checkCast(Type.getType(paramType)))
            )
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (. x fieldname-sym) or
                ;; (. x 0-ary-method)
                ;; (. x methodname-sym args+)
                ;; (. x (methodname-sym args?))
                (§ if (RT.length(form) < 3))
                (§
                    (§ throw new IllegalArgumentException("Malformed member expression, expecting (. target member ...)"))
                )
                ;; determine static or instance
                ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                (§ let int line = lineDeref())
                (§ let int column = columnDeref())
                (§ let String source = (String) SOURCE.deref())
                (§ let Class c = maybeClass(RT.second(form), false))
                ;; at this point c will be non-null if static
                (§ let Expr instance = nil)
                (§ if (c == nil))
                (§
                    (§ ass instance = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))
                )

                (§ let boolean maybeField = (RT.length(form) == 3) && (RT.third(form) instanceof Symbol))

                (§ if (maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == \-)))
                (§
                    (§ let Symbol sym = (Symbol) RT.third(form))
                    (§ if (c != nil))
                    (§
                        (§ ass maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0)
                    )
                    (§ elseif (instance != nil && instance.hasJavaClass() && instance.getJavaClass() != nil))
                    (§
                        (§ ass maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0)
                    )
                )

                (§ if (maybeField)) ;; field
                (§
                    (§ let Symbol sym = (((Symbol)RT.third(form)).name.charAt(0) == \-) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form))
                    (§ let Symbol tag = tagOf(form))
                    (§ if (c != nil))
                    (§
                        (§ return (§ expr new StaticFieldExpr(line, column, c, munge(sym.name), tag)))
                    )
                    (§ else )
                    (§
                        (§ return (§ expr new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == \-))))
                    )
                )
                (§ else )
                (§
                    (§ let ISeq call = (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form))))
                    (§ if (!(RT.first(call) instanceof Symbol)))
                    (§
                        (§ throw new IllegalArgumentException("Malformed member expression"))
                    )
                    (§ let Symbol sym = (Symbol) RT.first(call))
                    (§ let Symbol tag = tagOf(form))
                    (§ let PersistentVector args = PersistentVector.EMPTY)
                    (§ let boolean tailPosition = inTailCall(context))
                    (§ for (ISeq s = RT.next(call) s != nil s = s.next()))
                    (§
                        (§ ass args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                    )
                    (§ if (c != nil))
                    (§
                        (§ return (§ expr new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition)))
                    )
                    (§ else )
                    (§
                        (§ return (§ expr new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition)))
                    )
                )
            )
        )

        #_public
        #_static
        (§ method Class maybeClass(Object form, boolean stringOk)
            (§ if (form instanceof Class))
            (§
                (§ return (§ expr (Class) form))
            )
            (§ let Class c = nil)
            (§ if (form instanceof Symbol))
            (§
                (§ let Symbol sym = (Symbol) form)
                (§ if (sym.ns == nil)) ;; if ns-qualified can't be classname
                (§
                    (§ if (Util.equals(sym, COMPILE_STUB_SYM.get())))
                    (§
                        (§ return (§ expr (Class) COMPILE_STUB_CLASS.get()))
                    )
                    (§ if (sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[))
                    (§
                        (§ ass c = RT.classForNameNonLoading(sym.name))
                    )
                    (§ else )
                    (§
                        (§ let Object o = currentNS().getMapping(sym))
                        (§ if (o instanceof Class))
                        (§
                            (§ ass c = (Class) o)
                        )
                        (§ elseif (LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form)))
                        (§
                            (§ return (§ expr nil))
                        )
                        (§ else )
                        (§
                            (§ try )
                            (§
                                (§ ass c = RT.classForNameNonLoading(sym.name))
                            )
                            (§ catch (Exception e))
                            (§
                                ;; aargh
                                ;; leave c set to nil -> return nil
                            )
                        )
                    )
                )
            )
            (§ elseif (stringOk && form instanceof String))
            (§
                (§ ass c = RT.classForNameNonLoading((String) form))
            )
            (§ return (§ expr c))
        )

        #_public
        #_static
        (§ method Class maybeSpecialTag(Symbol sym)
            (§ let Class c = primClass(sym))
            (§ if (c != nil))
            (§
                (§ return (§ expr c))
            )
            (§ elseif (sym.name.equals("objects")))
            (§
                (§ ass c = Object[].class)
            )
            (§ elseif (sym.name.equals("ints")))
            (§
                (§ ass c = int[].class)
            )
            (§ elseif (sym.name.equals("longs")))
            (§
                (§ ass c = long[].class)
            )
            (§ elseif (sym.name.equals("floats")))
            (§
                (§ ass c = float[].class)
            )
            (§ elseif (sym.name.equals("doubles")))
            (§
                (§ ass c = double[].class)
            )
            (§ elseif (sym.name.equals("chars")))
            (§
                (§ ass c = char[].class)
            )
            (§ elseif (sym.name.equals("shorts")))
            (§
                (§ ass c = short[].class)
            )
            (§ elseif (sym.name.equals("bytes")))
            (§
                (§ ass c = byte[].class)
            )
            (§ elseif (sym.name.equals("booleans")))
            (§
                (§ ass c = boolean[].class)
            )
            (§ return (§ expr c))
        )

        #_static
        (§ method Class tagToClass(Object tag)
            (§ let Class c = nil)
            (§ if (tag instanceof Symbol))
            (§
                (§ let Symbol sym = (Symbol) tag)
                (§ if (sym.ns == nil)) ;; if ns-qualified can't be classname
                (§
                    (§ ass c = maybeSpecialTag(sym))
                )
            )
            (§ if (c == nil))
            (§
                (§ ass c = maybeClass(tag, true))
            )
            (§ if (c != nil))
            (§
                (§ return (§ expr c))
            )
            (§ throw new IllegalArgumentException("Unable to resolve classname: " + tag))
        )
    )

    #_static
    #_abstract
    (class-ns FieldExpr (§ extends HostExpr)
    )

    #_static
    (class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        #_public
        #_final
        (§ field Expr target)
        #_public
        #_final
        (§ field Class targetClass)
        #_public
        #_final
        (§ field java.lang.reflect.Field field)
        #_public
        #_final
        (§ field String fieldName)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)
        #_public
        #_final
        (§ field Symbol tag)
        #_public
        #_final
        (§ field boolean requireField)

        #_final
        #_static
        (§ field Method invokeNoArgInstanceMember = Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)"))
        #_final
        #_static
        (§ field Method setInstanceFieldMethod = Method.getMethod("Object setInstanceField(Object,String,Object)"))

        (§ field Class jc)

        #_public
        (§ method InstanceFieldExpr(int line, int column, Expr target, String fieldName, Symbol tag, boolean requireField)
            (§ ass this.target = target)
            (§ ass this.targetClass = target.hasJavaClass() ? target.getJavaClass() :or nil)
            (§ ass this.field = (targetClass != nil) ? Reflector.getField(targetClass, fieldName, false) :or nil)
            (§ ass this.fieldName = fieldName)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.tag = tag)
            (§ ass this.requireField = requireField)

            (§ if (field == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
            (§
                (§ if (targetClass == nil))
                (§
                    (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName))
                )
                (§ else )
                (§
                    (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName()))
                )
            )
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField)))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr (targetClass != nil && field != nil && Util.isPrimitive(field.getType()))))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (targetClass != nil && field != nil))
            (§
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.checkCast(getType(targetClass)))
                (§ call gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
            )
            (§ else )
            (§
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (targetClass != nil && field != nil))
            (§
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.checkCast(getType(targetClass)))
                (§ call gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                (§ call HostExpr.emitBoxReturn(objx, gen, field.getType()))
                (§ if (context == C.STATEMENT))
                (§
                    (§ call gen.pop())
                )
            )
            (§ else )
            (§
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.push(fieldName))
                (§ call gen.push(requireField))
                (§ call gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember))
                (§ if (context == C.STATEMENT))
                (§
                    (§ call gen.pop())
                )
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (field != nil || tag != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            (§ return (§ expr jc))
        )

        #_public
        (§ method Object evalAssign(Expr val)
            (§ return (§ expr Reflector.setInstanceField(target.eval(), fieldName, val.eval())))
        )

        #_public
        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (§ if (targetClass != nil && field != nil))
            (§
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.checkCast(getType(targetClass)))
                (§ call val.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.dupX1())
                (§ call HostExpr.emitUnboxArg(objx, gen, field.getType()))
                (§ call gen.putField(getType(targetClass), fieldName, Type.getType(field.getType())))
            )
            (§ else )
            (§
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.push(fieldName))
                (§ call val.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )
    )

    #_static
    (class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        #_public
        #_final
        (§ field String fieldName)
        #_public
        #_final
        (§ field Class c)
        #_public
        #_final
        (§ field java.lang.reflect.Field field)
        #_public
        #_final
        (§ field Symbol tag)

        #_final
        (§ field int line)
        #_final
        (§ field int column)

        (§ field Class jc)

        #_public
        (§ method StaticFieldExpr(int line, int column, Class c, String fieldName, Symbol tag)
            (§ ass this.fieldName = fieldName)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.c = c)
            (§ try )
            (§
                (§ ass field = c.getField(fieldName))
            )
            (§ catch (NoSuchFieldException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ ass this.tag = tag)
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr Reflector.getStaticField(c, fieldName)))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr Util.isPrimitive(field.getType())))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call gen.visitLineNumber(line, gen.mark()))
            (§ call gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call gen.visitLineNumber(line, gen.mark()))

            (§ call gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (§ call HostExpr.emitBoxReturn(objx, gen, field.getType()))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            (§ return (§ expr jc))
        )

        #_public
        (§ method Object evalAssign(Expr val)
            (§ return (§ expr Reflector.setStaticField(c, fieldName, val.eval())))
        )

        #_public
        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (§ call val.emit(C.EXPRESSION, objx, gen))
            (§ call gen.visitLineNumber(line, gen.mark()))
            (§ call gen.dup())
            (§ call HostExpr.emitUnboxArg(objx, gen, field.getType()))
            (§ call gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )
    )

    #_static
    (§ method Class maybePrimitiveType(Expr e)
        (§ if (e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive()))
        (§
            (§ let Class c = e.getJavaClass())
            (§ if (Util.isPrimitive(c)))
            (§
                (§ return (§ expr c))
            )
        )
        (§ return (§ expr nil))
    )

    #_static
    (§ method Class maybeJavaClass(Collection<Expr> exprs)
        (§ let Class match = nil)
        (§ try )
        (§
            (§ for (Expr e :in exprs))
            (§
                (§ if (e instanceof ThrowExpr))
                (§
                    (§ continue )
                )
                (§ if (!e.hasJavaClass()))
                (§
                    (§ return (§ expr nil))
                )
                (§ let Class c = e.getJavaClass())
                (§ if (match == nil))
                (§
                    (§ ass match = c)
                )
                (§ elseif (match != c))
                (§
                    (§ return (§ expr nil))
                )
            )
        )
        (§ catch (Exception e))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr match))
    )

    #_static
    #_abstract
    (class-ns MethodExpr (§ extends HostExpr)
        #_static
        (§ method void emitArgsAsArray(IPersistentVector args, ObjExpr objx, GeneratorAdapter gen)
            (§ call gen.push(args.count()))
            (§ call gen.newArray(OBJECT_TYPE))
            (§ for (int i = 0 i < args.count() i++))
            (§
                (§ call gen.dup())
                (§ call gen.push(i))
                ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen)
                (§ call gen.arrayStore(OBJECT_TYPE))
            )
        )

        #_public
        #_static
        (§ method void emitTypedArgs(ObjExpr objx, GeneratorAdapter gen, Class[] parameterTypes, IPersistentVector args)
            (§ for (int i = 0 i < parameterTypes.length i++))
            (§
                (§ let Expr e = (Expr) args.nth(i))
                (§ try )
                (§
                    (§ let final Class primc = maybePrimitiveType(e))
                    (§ if (primc == parameterTypes[i]))
                    (§
                        (§ let final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (§ call pe.emitUnboxed(C.EXPRESSION, objx, gen))
                    )
                    (§ elseif (primc == int.class && parameterTypes[i] == long.class))
                    (§
                        (§ let final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (§ call pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (§ call gen.visitInsn(I2L))
                    )
                    (§ elseif (primc == long.class && parameterTypes[i] == int.class))
                    (§
                        (§ let final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (§ call pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (§ if (RT.booleanCast(RT.UNCHECKED_MATH.deref())))
                        (§
                            (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)")))
                        )
                        (§ else )
                        (§
                            (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                        )
                    )
                    (§ elseif (primc == float.class && parameterTypes[i] == double.class))
                    (§
                        (§ let final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (§ call pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (§ call gen.visitInsn(F2D))
                    )
                    (§ elseif (primc == double.class && parameterTypes[i] == float.class))
                    (§
                        (§ let final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e)
                        (§ call pe.emitUnboxed(C.EXPRESSION, objx, gen))
                        (§ call gen.visitInsn(D2F))
                    )
                    (§ else )
                    (§
                        (§ call e.emit(C.EXPRESSION, objx, gen))
                        (§ call HostExpr.emitUnboxArg(objx, gen, parameterTypes[i]))
                    )
                )
                (§ catch (Exception e1))
                (§
                    (§ throw Util.sneakyThrow(e1))
                )
            )
        )
    )

    #_static
    (class-ns InstanceMethodExpr (§ extends MethodExpr)
        #_public
        #_final
        (§ field Expr target)
        #_public
        #_final
        (§ field String methodName)
        #_public
        #_final
        (§ field IPersistentVector args)
        #_public
        #_final
        (§ field String source)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)
        #_public
        #_final
        (§ field Symbol tag)
        #_public
        #_final
        (§ field boolean tailPosition)
        #_public
        #_final
        (§ field java.lang.reflect.Method method)

        (§ field Class jc)

        #_final
        #_static
        (§ field Method invokeInstanceMethodMethod = Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])"))

        #_public
        (§ method InstanceMethodExpr(String source, int line, int column, Symbol tag, Expr target, String methodName, IPersistentVector args, boolean tailPosition)
            (§ ass this.source = source)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.args = args)
            (§ ass this.methodName = methodName)
            (§ ass this.target = target)
            (§ ass this.tag = tag)
            (§ ass this.tailPosition = tailPosition)
            (§ if (target.hasJavaClass() && target.getJavaClass() != nil))
            (§
                (§ let List methods = Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false))
                (§ if (methods.isEmpty()))
                (§
                    (§ ass method = nil)
                    (§ if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
                    (§
                        (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName()))
                    )
                )
                (§ else )
                (§
                    (§ let int methodidx = 0)
                    (§ if (methods.size() > 1))
                    (§
                        (§ let ArrayList<Class[]> params = new ArrayList())
                        (§ let ArrayList<Class> rets = new ArrayList())
                        (§ for (int i = 0 i < methods.size() i++))
                        (§
                            (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))
                            (§ call params.add(m.getParameterTypes()))
                            (§ call rets.add(m.getReturnType()))
                        )
                        (§ ass methodidx = getMatchingParams(methodName, params, args, rets))
                    )
                    (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))
                    (§ if (m != nil && !Modifier.isPublic(m.getDeclaringClass().getModifiers())))
                    (§
                        ;; public method of non-public class, try to find it in hierarchy
                        (§ ass m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m))
                    )
                    (§ ass method = m)
                    (§ if (method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
                    (§
                        (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args)))
                    )
                )
            )
            (§ else )
            (§
                (§ ass method = nil)
                (§ if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
                (§
                    (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), line, column, methodName))
                )
            )
        )

        #_public
        (§ method Object eval()
            (§ try )
            (§
                (§ let Object targetval = target.eval())
                (§ let Object[] argvals = new Object[args.count()])
                (§ for (int i = 0 i < args.count() i++))
                (§
                    (§ ass argvals[i] = ((Expr) args.nth(i)).eval())
                )
                (§ if (method != nil))
                (§
                    (§ let LinkedList ms = new LinkedList())
                    (§ call ms.add(method))
                    (§ return (§ expr Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)))
                )
                (§ return (§ expr Reflector.invokeInstanceMethod(targetval, methodName, argvals)))
            )
            (§ catch (Throwable e))
            (§
                (§ if (!(e instanceof CompilerException)))
                (§
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else )
                (§
                    (§ throw (CompilerException) e)
                )
            )
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr (method != nil && Util.isPrimitive(method.getReturnType()))))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (method != nil))
            (§
                (§ let Type type = Type.getType(method.getDeclaringClass()))
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.checkCast(type))
                (§ call MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ if (tailPosition && !objx.canBeDirect))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearThis(gen))
                )
                (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                (§ if (method.getDeclaringClass().isInterface()))
                (§
                    (§ call gen.invokeInterface(type, m))
                )
                (§ else )
                (§
                    (§ call gen.invokeVirtual(type, m))
                )
            )
            (§ else )
            (§
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (method != nil))
            (§
                (§ let Type type = Type.getType(method.getDeclaringClass()))
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.checkCast(type))
                (§ call MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ if (context == C.RETURN))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearLocals(gen))
                )
                (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                (§ if (method.getDeclaringClass().isInterface()))
                (§
                    (§ call gen.invokeInterface(type, m))
                )
                (§ else )
                (§
                    (§ call gen.invokeVirtual(type, m))
                )
                (§ call HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
            )
            (§ else )
            (§
                (§ call target.emit(C.EXPRESSION, objx, gen))
                (§ call gen.push(methodName))
                (§ call emitArgsAsArray(args, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ if (context == C.RETURN))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearLocals(gen))
                )
                (§ call gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (method != nil || tag != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            (§ return (§ expr jc))
        )
    )

    #_static
    (class-ns StaticMethodExpr (§ extends MethodExpr)
        #_public
        #_final
        (§ field Class c)
        #_public
        #_final
        (§ field String methodName)
        #_public
        #_final
        (§ field IPersistentVector args)
        #_public
        #_final
        (§ field String source)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)
        #_public
        #_final
        (§ field java.lang.reflect.Method method)
        #_public
        #_final
        (§ field Symbol tag)
        #_public
        #_final
        (§ field boolean tailPosition)

        #_final
        #_static
        (§ field Method forNameMethod = Method.getMethod("Class classForName(String)"))
        #_final
        #_static
        (§ field Method invokeStaticMethodMethod = Method.getMethod("Object invokeStaticMethod(Class,String,Object[])"))
        #_final
        #_static
        (§ field Keyword warnOnBoxedKeyword = Keyword.intern("warn-on-boxed"))

        (§ field Class jc)

        #_public
        (§ method StaticMethodExpr(String source, int line, int column, Symbol tag, Class c, String methodName, IPersistentVector args, boolean tailPosition)
            (§ ass this.c = c)
            (§ ass this.methodName = methodName)
            (§ ass this.args = args)
            (§ ass this.source = source)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.tag = tag)
            (§ ass this.tailPosition = tailPosition)

            (§ let List methods = Reflector.getMethods(c, args.count(), methodName, true))
            (§ if (methods.isEmpty()))
            (§
                (§ throw new IllegalArgumentException("No matching method: " + methodName))
            )

            (§ let int methodidx = 0)
            (§ if (methods.size() > 1))
            (§
                (§ let ArrayList<Class[]> params = new ArrayList())
                (§ let ArrayList<Class> rets = new ArrayList())
                (§ for (int i = 0 i < methods.size() i++))
                (§
                    (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))
                    (§ call params.add(m.getParameterTypes()))
                    (§ call rets.add(m.getReturnType()))
                )
                (§ ass methodidx = getMatchingParams(methodName, params, args, rets))
            )
            (§ ass method = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))
            (§ if (method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
            (§
                (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args)))
            )
            (§ if (method != nil && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method)))
            (§
                (§ call RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), line, column, method.toString()))
            )
        )

        #_public
        #_static
        (§ method boolean isBoxedMath(java.lang.reflect.Method m)
            (§ let Class c = m.getDeclaringClass())
            (§ if (c.equals(Numbers.class)))
            (§
                (§ let WarnBoxedMath boxedMath = m.getAnnotation(WarnBoxedMath.class))
                (§ if (boxedMath != nil))
                (§
                    (§ return (§ expr boxedMath.value()))
                )

                (§ let Class[] argTypes = m.getParameterTypes())
                (§ for (Class argType :in argTypes))
                (§
                    (§ if (argType.equals(Object.class) || argType.equals(Number.class)))
                    (§
                        (§ return (§ expr true))
                    )
                )
            )
            (§ return (§ expr false))
        )

        #_public
        (§ method Object eval()
            (§ try )
            (§
                (§ let Object[] argvals = new Object[args.count()])
                (§ for (int i = 0 i < args.count() i++))
                (§
                    (§ ass argvals[i] = ((Expr) args.nth(i)).eval())
                )
                (§ if (method != nil))
                (§
                    (§ let LinkedList ms = new LinkedList())
                    (§ call ms.add(method))
                    (§ return (§ expr Reflector.invokeMatchingMethod(methodName, ms, nil, argvals)))
                )
                (§ return (§ expr Reflector.invokeStaticMethod(c, methodName, argvals)))
            )
            (§ catch (Throwable e))
            (§
                (§ if (!(e instanceof CompilerException)))
                (§
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else )
                (§
                    (§ throw (CompilerException) e)
                )
            )
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr (method != nil && Util.isPrimitive(method.getReturnType()))))
        )

        #_public
        (§ method boolean canEmitIntrinsicPredicate()
            (§ return (§ expr (method != nil && RT.get(Intrinsics.preds, method.toString()) != nil)))
        )

        #_public
        (§ method void emitIntrinsicPredicate(C context, ObjExpr objx, GeneratorAdapter gen, Label falseLabel)
            (§ call gen.visitLineNumber(line, gen.mark()))
            (§ if (method != nil))
            (§
                (§ call MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (§ if (context == C.RETURN))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearLocals(gen))
                )
                (§ let Object[] predOps = (Object[]) RT.get(Intrinsics.preds, method.toString()))
                (§ for (int i = 0 i < predOps.length - 1 i++))
                (§
                    (§ call gen.visitInsn((Integer)predOps[i]))
                )
                (§ call gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel))
            )
            (§ else )
            (§
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (method != nil))
            (§
                (§ call MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ if (context == C.RETURN))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearLocals(gen))
                )
                (§ let Object ops = RT.get(Intrinsics.ops, method.toString()))
                (§ if (ops != nil))
                (§
                    (§ if (ops instanceof Object[]))
                    (§
                        (§ for (Object op :in (Object[])ops))
                        (§
                            (§ call gen.visitInsn((Integer) op))
                        )
                    )
                    (§ else )
                    (§
                        (§ call gen.visitInsn((Integer) ops))
                    )
                )
                (§ else )
                (§
                    (§ let Type type = Type.getType(c))
                    (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                    (§ call gen.invokeStatic(type, m))
                )
            )
            (§ else )
            (§
                (§ throw new UnsupportedOperationException("Unboxed emit of unknown member"))
            )
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (method != nil))
            (§
                (§ call MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ if (tailPosition && !objx.canBeDirect))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearThis(gen))
                )
                (§ let Type type = Type.getType(c))
                (§ let Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))
                (§ call gen.invokeStatic(type, m))
                (§ let Class retClass = method.getReturnType())
                (§ if (context == C.STATEMENT))
                (§
                    (§ if (retClass == long.class || retClass == double.class))
                    (§
                        (§ call gen.pop2())
                    )
                    (§ elseif (retClass != void.class))
                    (§
                        (§ call gen.pop())
                    )
                )
                (§ else )
                (§
                    (§ call HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                )
            )
            (§ else )
            (§
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.push(c.getName()))
                (§ call gen.invokeStatic(RT_TYPE, forNameMethod))
                (§ call gen.push(methodName))
                (§ call emitArgsAsArray(args, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ if (context == C.RETURN))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearLocals(gen))
                )
                (§ call gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod))
                (§ if (context == C.STATEMENT))
                (§
                    (§ call gen.pop())
                )
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (method != nil || tag != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            (§ return (§ expr jc))
        )
    )

    #_static
    (class-ns UnresolvedVarExpr (§ implements Expr)
        #_public
        #_final
        (§ field Symbol symbol)

        #_public
        (§ method UnresolvedVarExpr(Symbol symbol)
            (§ ass this.symbol = symbol)
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr false))
        )

        #_public
        (§ method Class getJavaClass()
            (§ throw new IllegalArgumentException("UnresolvedVarExpr has no Java class"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        )

        #_public
        (§ method Object eval()
            (§ throw new IllegalArgumentException("UnresolvedVarExpr cannot be evalled"))
        )
    )

    #_static
    (class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
        #_final
        (§ field Number n)
        #_public
        #_final
        (§ field int id)

        #_public
        (§ method NumberExpr(Number n)
            (§ ass this.n = n)
            (§ ass this.id = registerConstant(n))
        )

        (§ method Object val()
            (§ return (§ expr n))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (context != C.STATEMENT))
            (§
                (§ call objx.emitConstant(gen, id))
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (n instanceof Integer))
            (§
                (§ return (§ expr long.class))
            )
            (§ elseif (n instanceof Double))
            (§
                (§ return (§ expr double.class))
            )
            (§ elseif (n instanceof Long))
            (§
                (§ return (§ expr long.class))
            )
            (§ else )
            (§
                (§ throw new IllegalStateException("Unsupported Number type: " + n.getClass().getName()))
            )
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr true))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (n instanceof Integer))
            (§
                (§ call gen.push(n.longValue()))
            )
            (§ elseif (n instanceof Double))
            (§
                (§ call gen.push(n.doubleValue()))
            )
            (§ elseif (n instanceof Long))
            (§
                (§ call gen.push(n.longValue()))
            )
        )

        #_static
        #_public
        (§ method Expr parse(Number form)
            (§ if (form instanceof Integer || form instanceof Double || form instanceof Long))
            (§
                (§ return (§ expr new NumberExpr(form)))
            )
            (§ else )
            (§
                (§ return (§ expr new ConstantExpr(form)))
            )
        )
    )

    #_static
    (class-ns ConstantExpr (§ extends LiteralExpr)
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        #_public
        #_final
        (§ field Object v)
        #_public
        #_final
        (§ field int id)

        #_public
        (§ method ConstantExpr(Object v)
            (§ ass this.v = v)
            (§ ass this.id = registerConstant(v))
        )

        (§ method Object val()
            (§ return (§ expr v))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call objx.emitConstant(gen, id))

            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr Modifier.isPublic(v.getClass().getModifiers())))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (v instanceof APersistentMap))
            (§
                (§ return (§ expr APersistentMap.class))
            )
            (§ elseif (v instanceof APersistentSet))
            (§
                (§ return (§ expr APersistentSet.class))
            )
            (§ elseif (v instanceof APersistentVector))
            (§
                (§ return (§ expr APersistentVector.class))
            )
            (§ else )
            (§
                (§ return (§ expr v.getClass()))
            )
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_static
            (§ field Keyword formKey = Keyword.intern("form"))

            #_public
            (§ method Expr parse(C context, Object form)
                (§ let int argCount = RT.count(form) - 1)
                (§ if (argCount != 1))
                (§
                    (§ let IPersistentMap exData = new PersistentArrayMap(new Object[] (§ formKey, form )))
                    (§ throw new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData))
                )
                (§ let Object v = RT.second(form))

                (§ if (v == nil))
                (§
                    (§ return (§ expr NIL_EXPR))
                )
                (§ elseif (v == Boolean.TRUE))
                (§
                    (§ return (§ expr TRUE_EXPR))
                )
                (§ elseif (v == Boolean.FALSE))
                (§
                    (§ return (§ expr FALSE_EXPR))
                )
                (§ if (v instanceof Number))
                (§
                    (§ return (§ expr NumberExpr.parse((Number)v)))
                )
                (§ elseif (v instanceof String))
                (§
                    (§ return (§ expr new StringExpr((String) v)))
                )
                (§ elseif (v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0))
                (§
                    (§ return (§ expr new EmptyExpr(v)))
                )
                (§ else )
                (§
                    (§ return (§ expr new ConstantExpr(v)))
                )
            )
        )
    )

    #_static
    (class-ns NilExpr (§ extends LiteralExpr)
        (§ method Object val()
            (§ return (§ expr nil))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call gen.visitInsn(Opcodes.ACONST_NULL))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr nil))
        )
    )

    #_final
    #_static
    (§ field NilExpr NIL_EXPR = new NilExpr())

    #_static
    (class-ns BooleanExpr (§ extends LiteralExpr)
        #_public
        #_final
        (§ field boolean val)

        #_public
        (§ method BooleanExpr(boolean val)
            (§ ass this.val = val)
        )

        (§ method Object val()
            (§ return (§ expr val ? RT.T :or RT.F))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (val))
            (§
                (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
            )
            (§ else )
            (§
                (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr Boolean.class))
        )
    )

    #_final
    #_static
    (§ field BooleanExpr TRUE_EXPR = new BooleanExpr(true))
    #_final
    #_static
    (§ field BooleanExpr FALSE_EXPR = new BooleanExpr(false))

    #_static
    (class-ns StringExpr (§ extends LiteralExpr)
        #_public
        #_final
        (§ field String str)

        #_public
        (§ method StringExpr(String str)
            (§ ass this.str = str)
        )

        (§ method Object val()
            (§ return (§ expr str))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (context != C.STATEMENT))
            (§
                (§ call gen.push(str))
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr String.class))
        )
    )

    #_static
    (class-ns MonitorEnterExpr (§ extends UntypedExpr)
        #_final
        (§ field Expr target)

        #_public
        (§ method MonitorEnterExpr(Expr target)
            (§ ass this.target = target)
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval monitor-enter"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call target.emit(C.EXPRESSION, objx, gen))
            (§ call gen.monitorEnter())
            (§ call NIL_EXPR.emit(context, objx, gen))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object form)
                (§ return (§ expr new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form)))))
            )
        )
    )

    #_static
    (class-ns MonitorExitExpr (§ extends UntypedExpr)
        #_final
        (§ field Expr target)

        #_public
        (§ method MonitorExitExpr(Expr target)
            (§ ass this.target = target)
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval monitor-exit"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call target.emit(C.EXPRESSION, objx, gen))
            (§ call gen.monitorExit())
            (§ call NIL_EXPR.emit(context, objx, gen))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object form)
                (§ return (§ expr new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form)))))
            )
        )
    )

    #_public
    #_static
    (class-ns TryExpr (§ implements Expr)
        #_public
        #_final
        (§ field Expr tryExpr)
        #_public
        #_final
        (§ field Expr finallyExpr)
        #_public
        #_final
        (§ field PersistentVector catchExprs)
        #_public
        #_final
        (§ field int retLocal)
        #_public
        #_final
        (§ field int finallyLocal)

        #_public
        #_static
        (class-ns CatchClause
            #_public
            #_final
            (§ field Class c)
            #_public
            #_final
            (§ field LocalBinding lb)
            #_public
            #_final
            (§ field Expr handler)
            (§ field Label label)
            (§ field Label endLabel)

            #_public
            (§ method CatchClause(Class c, LocalBinding lb, Expr handler)
                (§ ass this.c = c)
                (§ ass this.lb = lb)
                (§ ass this.handler = handler)
            )
        )

        #_public
        (§ method TryExpr(Expr tryExpr, PersistentVector catchExprs, Expr finallyExpr, int retLocal, int finallyLocal)
            (§ ass this.tryExpr = tryExpr)
            (§ ass this.catchExprs = catchExprs)
            (§ ass this.finallyExpr = finallyExpr)
            (§ ass this.retLocal = retLocal)
            (§ ass this.finallyLocal = finallyLocal)
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval try"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label startTry = gen.newLabel())
            (§ let Label endTry = gen.newLabel())
            (§ let Label end = gen.newLabel())
            (§ let Label ret = gen.newLabel())
            (§ let Label finallyLabel = gen.newLabel())
            (§ for (int i = 0 i < catchExprs.count() i++))
            (§
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (§ ass clause.label = gen.newLabel())
                (§ ass clause.endLabel = gen.newLabel())
            )

            (§ call gen.mark(startTry))
            (§ call tryExpr.emit(context, objx, gen))
            (§ if (context != C.STATEMENT))
            (§
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
            )
            (§ call gen.mark(endTry))
            (§ if (finallyExpr != nil))
            (§
                (§ call finallyExpr.emit(C.STATEMENT, objx, gen))
            )
            (§ call gen.goTo(ret))

            (§ for (int i = 0 i < catchExprs.count() i++))
            (§
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (§ call gen.mark(clause.label))
                ;; exception should be on stack
                ;; put in clause local
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx))
                (§ call clause.handler.emit(context, objx, gen))
                (§ if (context != C.STATEMENT))
                (§
                    (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                )
                (§ call gen.mark(clause.endLabel))

                (§ if (finallyExpr != nil))
                (§
                    (§ call finallyExpr.emit(C.STATEMENT, objx, gen))
                )
                (§ call gen.goTo(ret))
            )
            (§ if (finallyExpr != nil))
            (§
                (§ call gen.mark(finallyLabel))
                ;; exception should be on stack
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal))
                (§ call finallyExpr.emit(C.STATEMENT, objx, gen))
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal))
                (§ call gen.throwException())
            )
            (§ call gen.mark(ret))
            (§ if (context != C.STATEMENT))
            (§
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal))
            )
            (§ call gen.mark(end))
            (§ for (int i = 0 i < catchExprs.count() i++))
            (§
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (§ call gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace(\., \/)))
            )
            (§ if (finallyExpr != nil))
            (§
                (§ call gen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))
                (§ for (int i = 0 i < catchExprs.count() i++))
                (§
                    (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                    (§ call gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, nil))
                )
            )
            (§ for (int i = 0 i < catchExprs.count() i++))
            (§
                (§ let CatchClause clause = (CatchClause) catchExprs.nth(i))
                (§ call gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", nil, clause.label, clause.endLabel, clause.lb.idx))
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr tryExpr.hasJavaClass()))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr tryExpr.getJavaClass()))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                (§ if (context != C.RETURN))
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                ;; (try try-expr* catch-expr* finally-expr?)
                ;; catch-expr: (catch class sym expr*)
                ;; finally-expr: (finally expr*)

                (§ let PersistentVector body = PersistentVector.EMPTY)
                (§ let PersistentVector catches = PersistentVector.EMPTY)
                (§ let Expr bodyExpr = nil)
                (§ let Expr finallyExpr = nil)
                (§ let boolean caught = false)

                (§ let int retLocal = getAndIncLocalNum())
                (§ let int finallyLocal = getAndIncLocalNum())
                (§ for (ISeq fs = form.next() fs != nil fs = fs.next()))
                (§
                    (§ let Object f = fs.first())
                    (§ let Object op = (f instanceof ISeq) ? ((ISeq) f).first() :or nil)
                    (§ if (!Util.equals(op, CATCH) && !Util.equals(op, FINALLY)))
                    (§
                        (§ if (caught))
                        (§
                            (§ throw Util.runtimeException("Only catch or finally clause can follow catch in try expression"))
                        )
                        (§ ass body = body.cons(f))
                    )
                    (§ else )
                    (§
                        (§ if (bodyExpr == nil))
                        (§
                            (§ try )
                            (§
                                (§ call Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil)))
                                (§ ass bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                            )
                            (§ finally )
                            (§
                                (§ call Var.popThreadBindings())
                            )
                        )

                        (§ if (Util.equals(op, CATCH)))
                        (§
                            (§ let Class c = HostExpr.maybeClass(RT.second(f), false))
                            (§ if (c == nil))
                            (§
                                (§ throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(f)))
                            )
                            (§ if (!(RT.third(f) instanceof Symbol)))
                            (§
                                (§ throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f)))
                            )
                            (§ let Symbol sym = (Symbol) RT.third(f))
                            (§ if (sym.getNamespace() != nil))
                            (§
                                (§ throw Util.runtimeException("Can't bind qualified name:" + sym))
                            )

                            (§ let IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T))
                            (§ try )
                            (§
                                (§ call Var.pushThreadBindings(dynamicBindings))
                                (§ let LocalBinding lb = registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or nil), nil, false))
                                (§ let Expr handler = (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f)))))
                                (§ ass catches = catches.cons(new CatchClause(c, lb, handler)))
                            )
                            (§ finally )
                            (§
                                (§ call Var.popThreadBindings())
                            )
                            (§ ass caught = true)
                        )
                        (§ else ) ;; finally
                        (§
                            (§ if (fs.next() != nil))
                            (§
                                (§ throw Util.runtimeException("finally clause must be last in try expression"))
                            )
                            (§ try )
                            (§
                                (§ call Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T)))
                                (§ ass finallyExpr = (new BodyExpr.Parser()).parse(C.STATEMENT, RT.next(f)))
                            )
                            (§ finally )
                            (§
                                (§ call Var.popThreadBindings())
                            )
                        )
                    )
                )
                (§ if (bodyExpr == nil))
                (§
                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                    ;; return a body expr directly
                    (§ try )
                    (§
                        (§ call Var.pushThreadBindings(RT.map(NO_RECUR, true)))
                        (§ ass bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                    )
                    (§ finally )
                    (§
                        (§ call Var.popThreadBindings())
                    )
                    (§ return (§ expr bodyExpr))
                )

                (§ return (§ expr new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal)))
            )
        )
    )

    #_static
    (class-ns ThrowExpr (§ extends UntypedExpr)
        #_public
        #_final
        (§ field Expr excExpr)

        #_public
        (§ method ThrowExpr(Expr excExpr)
            (§ ass this.excExpr = excExpr)
        )

        #_public
        (§ method Object eval()
            (§ throw Util.runtimeException("Can't eval throw"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call excExpr.emit(C.EXPRESSION, objx, gen))
            (§ call gen.checkCast(THROWABLE_TYPE))
            (§ call gen.throwException())
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object form)
                (§ if (context == C.EVAL))
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )
                (§ elseif (RT.count(form) == 1))
                (§
                    (§ throw Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance"))
                )
                (§ elseif (RT.count(form) > 2))
                (§
                    (§ throw Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance"))
                )
                (§ return (§ expr new ThrowExpr(analyze(C.EXPRESSION, RT.second(form)))))
            )
        )
    )

    #_static
    #_public
    (§ method boolean subsumes(Class[] c1, Class[] c2)
        ;; presumes matching lengths
        (§ let Boolean better = false)
        (§ for (int i = 0 i < c1.length i++))
        (§
            (§ if (c1[i] != c2[i])) ;; || c2[i].isPrimitive() && c1[i] == Object.class
            (§
                (§ if (!c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i])))
                (§
                    (§ ass better = true)
                )
                (§ else )
                (§
                    (§ return (§ expr false))
                )
            )
        )
        (§ return (§ expr better))
    )

    #_static
    (§ method String getTypeStringForArgs(IPersistentVector args)
        (§ let StringBuilder sb = new StringBuilder())
        (§ for (int i = 0 i < args.count() i++))
        (§
            (§ let Expr arg = (Expr) args.nth(i))
            (§ if (i > 0))
            (§
                (§ call sb.append(", "))
            )
            (§ call sb.append((arg.hasJavaClass() && arg.getJavaClass() != nil) ? arg.getJavaClass().getName() :or "unknown"))
        )
        (§ return (§ expr sb.toString()))
    )

    #_static
    (§ method int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs, List<Class> rets)
        ;; presumes matching lengths
        (§ let int matchIdx = -1)
        (§ let boolean tied = false)
        (§ let boolean foundExact = false)
        (§ for (int i = 0 i < paramlists.size() i++))
        (§
            (§ let boolean match = true)
            (§ let ISeq aseq = argexprs.seq())
            (§ let int exact = 0)
            (§ for (int p = 0 match && p < argexprs.count() && aseq != nil ++p, aseq = aseq.next()))
            (§
                (§ let Expr arg = (Expr) aseq.first())
                (§ let Class aclass = arg.hasJavaClass() ? arg.getJavaClass() :or Object.class)
                (§ let Class pclass = paramlists.get(i)[p])
                (§ if (arg.hasJavaClass() && aclass == pclass))
                (§
                    (§ ass exact++)
                )
                (§ else )
                (§
                    (§ ass match = Reflector.paramArgTypeMatch(pclass, aclass))
                )
            )
            (§ if (exact == argexprs.count()))
            (§
                (§ if (!foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i))))
                (§
                    (§ ass matchIdx = i)
                )
                (§ ass tied = false)
                (§ ass foundExact = true)
            )
            (§ elseif (match && !foundExact))
            (§
                (§ if (matchIdx == -1))
                (§
                    (§ ass matchIdx = i)
                )
                (§ else )
                (§
                    (§ if (subsumes(paramlists.get(i), paramlists.get(matchIdx))))
                    (§
                        (§ ass matchIdx = i)
                        (§ ass tied = false)
                    )
                    (§ elseif (Arrays.equals(paramlists.get(matchIdx), paramlists.get(i))))
                    (§
                        (§ if (rets.get(matchIdx).isAssignableFrom(rets.get(i))))
                        (§
                            (§ ass matchIdx = i)
                        )
                    )
                    (§ elseif (!(subsumes(paramlists.get(matchIdx), paramlists.get(i)))))
                    (§
                        (§ ass tied = true)
                    )
                )
            )
        )
        (§ if (tied))
        (§
            (§ throw new IllegalArgumentException("More than one matching method found: " + methodName))
        )

        (§ return (§ expr matchIdx))
    )

    #_public
    #_static
    (class-ns NewExpr (§ implements Expr)
        #_public
        #_final
        (§ field IPersistentVector args)
        #_public
        #_final
        (§ field Constructor ctor)
        #_public
        #_final
        (§ field Class c)

        #_final
        #_static
        (§ field Method invokeConstructorMethod = Method.getMethod("Object invokeConstructor(Class,Object[])"))
        #_final
        #_static
        (§ field Method forNameMethod = Method.getMethod("Class classForName(String)"))

        #_public
        (§ method NewExpr(Class c, IPersistentVector args, int line, int column)
            (§ ass this.args = args)
            (§ ass this.c = c)
            (§ let Constructor[] allctors = c.getConstructors())
            (§ let ArrayList ctors = new ArrayList())
            (§ let ArrayList<Class[]> params = new ArrayList())
            (§ let ArrayList<Class> rets = new ArrayList())
            (§ for (int i = 0 i < allctors.length i++))
            (§
                (§ let Constructor ctor = allctors[i])
                (§ if (ctor.getParameterTypes().length == args.count()))
                (§
                    (§ call ctors.add(ctor))
                    (§ call params.add(ctor.getParameterTypes()))
                    (§ call rets.add(c))
                )
            )
            (§ if (ctors.isEmpty()))
            (§
                (§ throw new IllegalArgumentException("No matching ctor found for " + c))
            )

            (§ let int ctoridx = 0)
            (§ if (ctors.size() > 1))
            (§
                (§ ass ctoridx = getMatchingParams(c.getName(), params, args, rets))
            )

            (§ ass this.ctor = (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or nil)
            (§ if (ctor == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
            (§
                (§ call RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), line, column, c.getName()))
            )
        )

        #_public
        (§ method Object eval()
            (§ let Object[] argvals = new Object[args.count()])
            (§ for (int i = 0 i < args.count() i++))
            (§
                (§ ass argvals[i] = ((Expr) args.nth(i)).eval())
            )
            (§ if (this.ctor != nil))
            (§
                (§ try )
                (§
                    (§ return (§ expr ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))))
                )
                (§ catch (Exception e))
                (§
                    (§ throw Util.sneakyThrow(e))
                )
            )
            (§ return (§ expr Reflector.invokeConstructor(c, argvals)))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (this.ctor != nil))
            (§
                (§ let Type type = getType(c))
                (§ call gen.newInstance(type))
                (§ call gen.dup())
                (§ call MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args))
                (§ call gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor))))
            )
            (§ else )
            (§
                (§ call gen.push(destubClassName(c.getName())))
                (§ call gen.invokeStatic(RT_TYPE, forNameMethod))
                (§ call MethodExpr.emitArgsAsArray(args, objx, gen))
                (§ call gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr c))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let int line = lineDeref())
                (§ let int column = columnDeref())
                (§ let ISeq form = (ISeq) frm)
                ;; (new Classname args...)
                (§ if (form.count() < 2))
                (§
                    (§ throw Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)"))
                )
                (§ let Class c = HostExpr.maybeClass(RT.second(form), false))
                (§ if (c == nil))
                (§
                    (§ throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(form)))
                )
                (§ let PersistentVector args = PersistentVector.EMPTY)
                (§ for (ISeq s = RT.next(RT.next(form)) s != nil s = s.next()))
                (§
                    (§ ass args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                )
                (§ return (§ expr new NewExpr(c, args, line, column)))
            )
        )
    )

    #_public
    #_static
    (class-ns MetaExpr (§ implements Expr)
        #_public
        #_final
        (§ field Expr expr)
        #_public
        #_final
        (§ field Expr meta)

        #_final
        #_static
        (§ field Type IOBJ_TYPE = Type.getType(IObj.class))
        #_final
        #_static
        (§ field Method withMetaMethod = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

        #_public
        (§ method MetaExpr(Expr expr, Expr meta)
            (§ ass this.expr = expr)
            (§ ass this.meta = meta)
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval())))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call expr.emit(C.EXPRESSION, objx, gen))
            (§ call gen.checkCast(IOBJ_TYPE))
            (§ call meta.emit(C.EXPRESSION, objx, gen))
            (§ call gen.checkCast(IPERSISTENTMAP_TYPE))
            (§ call gen.invokeInterface(IOBJ_TYPE, withMetaMethod))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr expr.hasJavaClass()))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr expr.getJavaClass()))
        )
    )

    #_public
    #_static
    (class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
        #_public
        #_final
        (§ field Expr testExpr)
        #_public
        #_final
        (§ field Expr thenExpr)
        #_public
        #_final
        (§ field Expr elseExpr)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)

        #_public
        (§ method IfExpr(int line, int column, Expr testExpr, Expr thenExpr, Expr elseExpr)
            (§ ass this.testExpr = testExpr)
            (§ ass this.thenExpr = thenExpr)
            (§ ass this.elseExpr = elseExpr)
            (§ ass this.line = line)
            (§ ass this.column = column)
        )

        #_public
        (§ method Object eval()
            (§ let Object t = testExpr.eval())
            (§ if (t != nil && t != Boolean.FALSE))
            (§
                (§ return (§ expr thenExpr.eval()))
            )
            (§ return (§ expr elseExpr.eval()))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call doEmit(context, objx, gen, false))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call doEmit(context, objx, gen, true))
        )

        #_public
        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (§ let Label nullLabel = gen.newLabel())
            (§ let Label falseLabel = gen.newLabel())
            (§ let Label endLabel = gen.newLabel())

            (§ call gen.visitLineNumber(line, gen.mark()))

            (§ if (testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate()))
            (§
                ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel)
            )
            (§ elseif (maybePrimitiveType(testExpr) == boolean.class))
            (§
                ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen)
                (§ call gen.ifZCmp(gen.EQ, falseLabel))
            )
            (§ else )
            (§
                (§ call testExpr.emit(C.EXPRESSION, objx, gen))
                (§ call gen.dup())
                (§ call gen.ifNull(nullLabel))
                (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                (§ call gen.visitJumpInsn(IF_ACMPEQ, falseLabel))
            )
            (§ if (emitUnboxed))
            (§
                ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen)
            )
            (§ else )
            (§
                (§ call thenExpr.emit(context, objx, gen))
            )
            (§ call gen.goTo(endLabel))
            (§ call gen.mark(nullLabel))
            (§ call gen.pop())
            (§ call gen.mark(falseLabel))
            (§ if (emitUnboxed))
            (§
                ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen)
            )
            (§ else )
            (§
                (§ call elseExpr.emit(context, objx, gen))
            )
            (§ call gen.mark(endLabel))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr thenExpr.hasJavaClass()
          #_arg && elseExpr.hasJavaClass()
          #_arg && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
              #_arg || thenExpr.getJavaClass() == RECUR_CLASS
              #_arg || elseExpr.getJavaClass() == RECUR_CLASS
              #_arg || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
              #_arg || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive()))))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ try )
            (§
                (§ return (§ expr thenExpr instanceof MaybePrimitiveExpr
              #_arg && elseExpr instanceof MaybePrimitiveExpr
              #_arg && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                      #_arg || thenExpr.getJavaClass() == RECUR_CLASS
                      #_arg || elseExpr.getJavaClass() == RECUR_CLASS)
              #_arg && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
              #_arg && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive()))
            )
            (§ catch (Exception e))
            (§
                (§ return (§ expr false))
            )
        )

        #_public
        (§ method Class getJavaClass()
            (§ let Class thenClass = thenExpr.getJavaClass())
            (§ if (thenClass != nil && thenClass != RECUR_CLASS))
            (§
                (§ return (§ expr thenClass))
            )
            (§ return (§ expr elseExpr.getJavaClass()))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (if test then) or (if test then else)
                (§ if (form.count() > 4))
                (§
                    (§ throw Util.runtimeException("Too many arguments to if"))
                )
                (§ elseif (form.count() < 3))
                (§
                    (§ throw Util.runtimeException("Too few arguments to if"))
                )
                (§ let PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))
                (§ let Expr testexpr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))
                (§ let Expr thenexpr, elseexpr)
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                    (§ ass thenexpr = analyze(context, RT.third(form)))
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                    (§ ass elseexpr = analyze(context, RT.fourth(form)))
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
                (§ return (§ expr new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr)))
            )
        )
    )

    #_static
    #_final
    #_public
    (§ field IPersistentMap CHAR_MAP = PersistentHashMap.create(
      #_map \-, "_",
      #_map \:, "_COLON_",
      #_map \+, "_PLUS_",
      #_map \>, "_GT_",
      #_map \<, "_LT_",
      #_map \=, "_EQ_",
      #_map \~, "_TILDE_",
      #_map \!, "_BANG_",
      #_map \@, "_CIRCA_",
      #_map \#, "_SHARP_",
      #_map \', "_SINGLEQUOTE_",
      #_map \", "_DOUBLEQUOTE_", ;; oops! "
      #_map \%, "_PERCENT_",
      #_map \^, "_CARET_",
      #_map \&, "_AMPERSAND_",
      #_map \*, "_STAR_",
      #_map \|, "_BAR_",
      #_map \{, "_LBRACE_",
      #_map \}, "_RBRACE_",
      #_map \[, "_LBRACK_",
      #_map \], "_RBRACK_",
      #_map \/, "_SLASH_",
      #_map \\, "_BSLASH_",
      #_map \?, "_QMARK_"
    ))

    #_static
    #_final
    #_public
    (§ field IPersistentMap DEMUNGE_MAP)
    #_static
    #_final
    #_public
    (§ field Pattern DEMUNGE_PATTERN)

    (§ static )
    (§
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (§ let IPersistentMap m = RT.map("$", \/))
        (§ for (ISeq s = RT.seq(CHAR_MAP) s != nil s = s.next()))
        (§
            (§ let IMapEntry e = (IMapEntry) s.first())
            (§ let Character origCh = (Character) e.key())
            (§ let String escapeStr = (String) e.val())
            (§ ass m = m.assoc(escapeStr, origCh))
        )
        (§ ass DEMUNGE_MAP = m)

        ;; DEMUNGE_PATTERN searches for the first of any occurrence of
        ;; the strings that are keys of DEMUNGE_MAP.
        ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
        ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
        ;; as desired.  Sorting string keys of DEMUNGE_MAP from longest to
        ;; shortest ensures correct matching behavior, even if some strings are
        ;; prefixes of others.
        (§ let Object[] mungeStrs = RT.toArray(RT.keys(m)))
        (§ call Arrays.sort(mungeStrs, new Comparator()
        (§ inner
            #_public
            (§ method int compare(Object s1, Object s2)
                (§ return (§ expr ((String) s2).length() - ((String) s1).length()))
            )
        )))
        (§ let StringBuilder sb = new StringBuilder())
        (§ let boolean first = true)
        (§ for (Object s :in mungeStrs))
        (§
            (§ let String escapeStr = (String) s)
            (§ if (!first))
            (§
                (§ call sb.append("|"))
            )
            (§ ass first = false)
            (§ call sb.append("\\Q"))
            (§ call sb.append(escapeStr))
            (§ call sb.append("\\E"))
        )
        (§ ass DEMUNGE_PATTERN = Pattern.compile(sb.toString()))
    )

    #_static
    #_public
    (§ method String munge(String name)
        (§ let StringBuilder sb = new StringBuilder())
        (§ for (char c :in name.toCharArray()))
        (§
            (§ let String sub = (String) CHAR_MAP.valAt(c))
            (§ if (sub != nil))
            (§
                (§ call sb.append(sub))
            )
            (§ else )
            (§
                (§ call sb.append(c))
            )
        )
        (§ return (§ expr sb.toString()))
    )

    #_static
    #_public
    (§ method String demunge(String mungedName)
        (§ let StringBuilder sb = new StringBuilder())
        (§ let Matcher m = DEMUNGE_PATTERN.matcher(mungedName))
        (§ let int lastMatchEnd = 0)
        (§ while (m.find()))
        (§
            (§ let int start = m.start())
            (§ let int end = m.end())
            ;; Keep everything before the match
            (§ call sb.append(mungedName.substring(lastMatchEnd, start)))
            (§ ass lastMatchEnd = end)
            ;; Replace the match with DEMUNGE_MAP result
            (§ let Character origCh = (Character) DEMUNGE_MAP.valAt(m.group()))
            (§ call sb.append(origCh))
        )
        ;; Keep everything after the last match
        (§ call sb.append(mungedName.substring(lastMatchEnd)))
        (§ return (§ expr sb.toString()))
    )

    #_public
    #_static
    (class-ns EmptyExpr (§ implements Expr)
        #_public
        #_final
        (§ field Object coll)

        #_final
        #_static
        (§ field Type HASHMAP_TYPE = Type.getType(PersistentArrayMap.class))
        #_final
        #_static
        (§ field Type HASHSET_TYPE = Type.getType(PersistentHashSet.class))
        #_final
        #_static
        (§ field Type VECTOR_TYPE = Type.getType(PersistentVector.class))
        #_final
        #_static
        (§ field Type IVECTOR_TYPE = Type.getType(IPersistentVector.class))
        #_final
        #_static
        (§ field Type TUPLE_TYPE = Type.getType(Tuple.class))
        #_final
        #_static
        (§ field Type LIST_TYPE = Type.getType(PersistentList.class))
        #_final
        #_static
        (§ field Type EMPTY_LIST_TYPE = Type.getType(PersistentList.EmptyList.class))

        #_public
        (§ method EmptyExpr(Object coll)
            (§ ass this.coll = coll)
        )

        #_public
        (§ method Object eval()
            (§ return (§ expr coll))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (coll instanceof IPersistentList))
            (§
                (§ call gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE))
            )
            (§ elseif (coll instanceof IPersistentVector))
            (§
                (§ call gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE))
            )
            (§ elseif (coll instanceof IPersistentMap))
            (§
                (§ call gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE))
            )
            (§ elseif (coll instanceof IPersistentSet))
            (§
                (§ call gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE))
            )
            (§ else )
            (§
                (§ throw new UnsupportedOperationException("Unknown Collection type"))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (coll instanceof IPersistentList))
            (§
                (§ return (§ expr IPersistentList.class))
            )
            (§ elseif (coll instanceof IPersistentVector))
            (§
                (§ return (§ expr IPersistentVector.class))
            )
            (§ elseif (coll instanceof IPersistentMap))
            (§
                (§ return (§ expr IPersistentMap.class))
            )
            (§ elseif (coll instanceof IPersistentSet))
            (§
                (§ return (§ expr IPersistentSet.class))
            )
            (§ else )
            (§
                (§ throw new UnsupportedOperationException("Unknown Collection type"))
            )
        )
    )

    #_public
    #_static
    (class-ns ListExpr (§ implements Expr)
        #_public
        #_final
        (§ field IPersistentVector args)

        #_final
        #_static
        (§ field Method arrayToListMethod = Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])"))

        #_public
        (§ method ListExpr(IPersistentVector args)
            (§ ass this.args = args)
        )

        #_public
        (§ method Object eval()
            (§ let IPersistentVector ret = PersistentVector.EMPTY)
            (§ for (int i = 0 i < args.count() i++))
            (§
                (§ ass ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
            )
            (§ return (§ expr ret.seq()))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call MethodExpr.emitArgsAsArray(args, objx, gen))
            (§ call gen.invokeStatic(RT_TYPE, arrayToListMethod))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr IPersistentList.class))
        )
    )

    #_public
    #_static
    (class-ns MapExpr (§ implements Expr)
        #_public
        #_final
        (§ field IPersistentVector keyvals)

        #_final
        #_static
        (§ field Method mapMethod = Method.getMethod("cloiure.lang.IPersistentMap map(Object[])"))
        #_final
        #_static
        (§ field Method mapUniqueKeysMethod = Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

        #_public
        (§ method MapExpr(IPersistentVector keyvals)
            (§ ass this.keyvals = keyvals)
        )

        #_public
        (§ method Object eval()
            (§ let Object[] ret = new Object[keyvals.count()])
            (§ for (int i = 0 i < keyvals.count() i++))
            (§
                (§ ass ret[i] = ((Expr) keyvals.nth(i)).eval())
            )
            (§ return (§ expr RT.map(ret)))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let boolean allKeysConstant = true)
            (§ let boolean allConstantKeysUnique = true)
            (§ let IPersistentSet constantKeys = PersistentHashSet.EMPTY)
            (§ for (int i = 0 i < keyvals.count() i+=2))
            (§
                (§ let Expr k = (Expr) keyvals.nth(i))
                (§ if (k instanceof LiteralExpr))
                (§
                    (§ let Object kval = k.eval())
                    (§ if (constantKeys.contains(kval)))
                    (§
                        (§ ass allConstantKeysUnique = false)
                    )
                    (§ else )
                    (§
                        (§ ass constantKeys = (IPersistentSet)constantKeys.cons(kval))
                    )
                )
                (§ else )
                (§
                    (§ ass allKeysConstant = false)
                )
            )
            (§ call MethodExpr.emitArgsAsArray(keyvals, objx, gen))
            (§ if ((allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2)))
            (§
                (§ call gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod))
            )
            (§ else )
            (§
                (§ call gen.invokeStatic(RT_TYPE, mapMethod))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr IPersistentMap.class))
        )

        #_static
        #_public
        (§ method Expr parse(C context, IPersistentMap form)
            (§ let IPersistentVector keyvals = PersistentVector.EMPTY)
            (§ let boolean keysConstant = true)
            (§ let boolean valsConstant = true)
            (§ let boolean allConstantKeysUnique = true)
            (§ let IPersistentSet constantKeys = PersistentHashSet.EMPTY)
            (§ for (ISeq s = RT.seq(form) s != nil s = s.next()))
            (§
                (§ let IMapEntry e = (IMapEntry) s.first())
                (§ let Expr k = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key()))
                (§ let Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val()))
                (§ ass keyvals = (IPersistentVector) keyvals.cons(k))
                (§ ass keyvals = (IPersistentVector) keyvals.cons(v))
                (§ if (k instanceof LiteralExpr))
                (§
                    (§ let Object kval = k.eval())
                    (§ if (constantKeys.contains(kval)))
                    (§
                        (§ ass allConstantKeysUnique = false)
                    )
                    (§ else )
                    (§
                        (§ ass constantKeys = (IPersistentSet)constantKeys.cons(kval))
                    )
                )
                (§ else )
                (§
                    (§ ass keysConstant = false)
                )
                (§ if (!(v instanceof LiteralExpr)))
                (§
                    (§ ass valsConstant = false)
                )
            )

            (§ let Expr ret = new MapExpr(keyvals))
            (§ if (form instanceof IObj && ((IObj) form).meta() != nil))
            (§
                (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
            )
            (§ elseif (keysConstant))
            (§
                ;; TBD: Add more detail to exception thrown below.
                (§ if (!allConstantKeysUnique))
                (§
                    (§ throw new IllegalArgumentException("Duplicate constant keys in map"))
                )
                (§ if (valsConstant))
                (§
                    (§ let IPersistentMap m = PersistentArrayMap.EMPTY)
                    (§ for (int i = 0 i < keyvals.length() i += 2))
                    (§
                        (§ ass m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val()))
                    )
                    (§ return (§ expr new ConstantExpr(m)))
                )
                (§ else )
                (§
                    (§ return (§ expr ret))
                )
            )
            (§ else )
            (§
                (§ return (§ expr ret))
            )
        )
    )

    #_public
    #_static
    (class-ns SetExpr (§ implements Expr)
        #_public
        #_final
        (§ field IPersistentVector keys)

        #_final
        #_static
        (§ field Method setMethod = Method.getMethod("cloiure.lang.IPersistentSet set(Object[])"))

        #_public
        (§ method SetExpr(IPersistentVector keys)
            (§ ass this.keys = keys)
        )

        #_public
        (§ method Object eval()
            (§ let Object[] ret = new Object[keys.count()])
            (§ for (int i = 0 i < keys.count() i++))
            (§
                (§ ass ret[i] = ((Expr) keys.nth(i)).eval())
            )
            (§ return (§ expr RT.set(ret)))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call MethodExpr.emitArgsAsArray(keys, objx, gen))
            (§ call gen.invokeStatic(RT_TYPE, setMethod))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr IPersistentSet.class))
        )

        #_static
        #_public
        (§ method Expr parse(C context, IPersistentSet form)
            (§ let IPersistentVector keys = PersistentVector.EMPTY)
            (§ let boolean constant = true)

            (§ for (ISeq s = RT.seq(form) s != nil s = s.next()))
            (§
                (§ let Object e = s.first())
                (§ let Expr expr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e))
                (§ ass keys = (IPersistentVector) keys.cons(expr))
                (§ if (!(expr instanceof LiteralExpr)))
                (§
                    (§ ass constant = false)
                )
            )
            (§ let Expr ret = new SetExpr(keys))
            (§ if (form instanceof IObj && ((IObj) form).meta() != nil))
            (§
                (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
            )
            (§ elseif (constant))
            (§
                (§ let IPersistentSet set = PersistentHashSet.EMPTY)
                (§ for (int i = 0 i < keys.count() i++))
                (§
                    (§ let LiteralExpr ve = (LiteralExpr)keys.nth(i))
                    (§ ass set = (IPersistentSet)set.cons(ve.val()))
                )
                (§ return (§ expr new ConstantExpr(set)))
            )
            (§ else )
            (§
                (§ return (§ expr ret))
            )
        )
    )

    #_public
    #_static
    (class-ns VectorExpr (§ implements Expr)
        #_public
        #_final
        (§ field IPersistentVector args)

        #_final
        #_static
        (§ field Method vectorMethod = Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])"))

        #_public
        (§ method VectorExpr(IPersistentVector args)
            (§ ass this.args = args)
        )

        #_public
        (§ method Object eval()
            (§ let IPersistentVector ret = PersistentVector.EMPTY)
            (§ for (int i = 0 i < args.count() i++))
            (§
                (§ ass ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (args.count() <= Tuple.MAX_SIZE))
            (§
                (§ for (int i = 0 i < args.count() i++))
                (§
                    ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen)
                )
                (§ call gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
            )
            (§ else )
            (§
                (§ call MethodExpr.emitArgsAsArray(args, objx, gen))
                (§ call gen.invokeStatic(RT_TYPE, vectorMethod))
            )

            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr IPersistentVector.class))
        )

        #_static
        #_public
        (§ method Expr parse(C context, IPersistentVector form)
            (§ let boolean constant = true)

            (§ let IPersistentVector args = PersistentVector.EMPTY)
            (§ for (int i = 0 i < form.count() i++))
            (§
                (§ let Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i)))
                (§ ass args = (IPersistentVector) args.cons(v))
                (§ if (!(v instanceof LiteralExpr)))
                (§
                    (§ ass constant = false)
                )
            )
            (§ let Expr ret = new VectorExpr(args))
            (§ if (form instanceof IObj && ((IObj) form).meta() != nil))
            (§
                (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
            )
            (§ elseif (constant))
            (§
                (§ let IPersistentVector rv = PersistentVector.EMPTY)
                (§ for (int i = 0 i < args.count() i++))
                (§
                    (§ let LiteralExpr ve = (LiteralExpr)args.nth(i))
                    (§ ass rv = rv.cons(ve.val()))
                )
                (§ return (§ expr new ConstantExpr(rv)))
            )
            (§ else )
            (§
                (§ return (§ expr ret))
            )
        )
    )

    #_static
    (class-ns KeywordInvokeExpr (§ implements Expr)
        #_public
        #_final
        (§ field KeywordExpr kw)
        #_public
        #_final
        (§ field Object tag)
        #_public
        #_final
        (§ field Expr target)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)
        #_public
        #_final
        (§ field int siteIndex)
        #_public
        #_final
        (§ field String source)

        #_static
        (§ field Type ILOOKUP_TYPE = Type.getType(ILookup.class))

        (§ field Class jc)

        #_public
        (§ method KeywordInvokeExpr(String source, int line, int column, Symbol tag, KeywordExpr kw, Expr target)
            (§ ass this.source = source)
            (§ ass this.kw = kw)
            (§ ass this.target = target)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.tag = tag)
            (§ ass this.siteIndex = registerKeywordCallsite(kw.k))
        )

        #_public
        (§ method Object eval()
            (§ try )
            (§
                (§ return (§ expr kw.k.invoke(target.eval())))
            )
            (§ catch (Throwable e))
            (§
                (§ if (!(e instanceof CompilerException)))
                (§
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else )
                (§
                    (§ throw (CompilerException) e)
                )
            )
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label endLabel = gen.newLabel())
            (§ let Label faultLabel = gen.newLabel())

            (§ call gen.visitLineNumber(line, gen.mark()))
            (§ call gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE))
            (§ call gen.dup()) ;; thunk, thunk
            (§ call target.emit(C.EXPRESSION, objx, gen)) ;; thunk, thunk, target
            (§ call gen.visitLineNumber(line, gen.mark()))
            (§ call gen.dupX2()) ;; target, thunk, thunk, target
            (§ call gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; target, thunk, result
            (§ call gen.dupX2()) ;; result, target, thunk, result
            (§ call gen.visitJumpInsn(IF_ACMPEQ, faultLabel)) ;; result, target
            (§ call gen.pop()) ;; result
            (§ call gen.goTo(endLabel))

            (§ call gen.mark(faultLabel)) ;; result, target
            (§ call gen.swap()) ;; target, result
            (§ call gen.pop()) ;; target
            (§ call gen.dup()) ;; target, target
            (§ call gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
            (§ call gen.swap()) ;; target, site, target
            (§ call gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
            (§ call gen.dup()) ;; target, new-thunk, new-thunk
            (§ call gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
            (§ call gen.swap()) ;; new-thunk, target
            (§ call gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; result

            (§ call gen.mark(endLabel))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (tag != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = HostExpr.tagToClass(tag))
            )
            (§ return (§ expr jc))
        )
    )

    #_public
    #_static
    (class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Expr expr)
        (§ field Class c)

        #_public
        (§ method InstanceOfExpr(Class c, Expr expr)
            (§ ass this.expr = expr)
            (§ ass this.c = c)
        )

        #_public
        (§ method Object eval()
            (§ if (c.isInstance(expr.eval())))
            (§
                (§ return (§ expr RT.T))
            )
            (§ return (§ expr RT.F))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr true))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call expr.emit(C.EXPRESSION, objx, gen))
            (§ call gen.instanceOf(getType(c)))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call emitUnboxed(context, objx, gen))
            (§ call HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr Boolean.TYPE))
        )
    )

    #_static
    (class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
        #_public
        #_final
        (§ field Type target)
        #_public
        #_final
        (§ field Class retClass)
        #_public
        #_final
        (§ field Class[] paramclasses)
        #_public
        #_final
        (§ field Type[] paramtypes)
        #_public
        #_final
        (§ field IPersistentVector args)
        #_public
        #_final
        (§ field boolean variadic)
        #_public
        #_final
        (§ field boolean tailPosition)
        #_public
        #_final
        (§ field Object tag)

        (§ field Class jc)

        (§ method StaticInvokeExpr(Type target, Class retClass, Class[] paramclasses, Type[] paramtypes, boolean variadic, IPersistentVector args, Object tag, boolean tailPosition)
            (§ ass this.target = target)
            (§ ass this.retClass = retClass)
            (§ ass this.paramclasses = paramclasses)
            (§ ass this.paramtypes = paramtypes)
            (§ ass this.args = args)
            (§ ass this.variadic = variadic)
            (§ ass this.tailPosition = tailPosition)
            (§ ass this.tag = tag)
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval StaticInvokeExpr"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call emitUnboxed(context, objx, gen))
            (§ if (context != C.STATEMENT))
            (§
                (§ call HostExpr.emitBoxReturn(objx, gen, retClass))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ if (retClass == long.class || retClass == double.class))
                (§
                    (§ call gen.pop2())
                )
                (§ else )
                (§
                    (§ call gen.pop())
                )
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, retClass))
            )
            (§ return (§ expr jc))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr retClass.isPrimitive()))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Method ms = new Method("invokeStatic", getReturnType(), paramtypes))
            (§ if (variadic))
            (§
                (§ for (int i = 0 i < paramclasses.length - 1 i++))
                (§
                    (§ let Expr e = (Expr) args.nth(i))
                    (§ if (maybePrimitiveType(e) == paramclasses[i]))
                    (§
                        ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    (§ else )
                    (§
                        (§ call e.emit(C.EXPRESSION, objx, gen))
                        (§ call HostExpr.emitUnboxArg(objx, gen, paramclasses[i]))
                    )
                )
                (§ let IPersistentVector restArgs = RT.subvec(args, paramclasses.length - 1, args.count()))
                (§ call MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                (§ call gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])")))
            )
            (§ else )
            (§
                (§ call MethodExpr.emitTypedArgs(objx, gen, paramclasses, args))
            )

            (§ if (tailPosition && !objx.canBeDirect))
            (§
                (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                (§ call method.emitClearThis(gen))
            )

            (§ call gen.invokeStatic(target, ms))
        )

        #_private
        (§ method Type getReturnType()
            (§ return (§ expr Type.getType(retClass)))
        )

        #_public
        #_static
        (§ method Expr parse(Var v, ISeq args, Object tag, boolean tailPosition)
            (§ if (!v.isBound() || v.get() == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let Class c = v.get().getClass())
            (§ let String cname = c.getName())

            (§ let java.lang.reflect.Method[] allmethods = c.getMethods())

            (§ let boolean variadic = false)
            (§ let int argcount = RT.count(args))
            (§ let java.lang.reflect.Method method = nil)
            (§ for (java.lang.reflect.Method m :in allmethods))
            (§
                (§ if (Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic")))
                (§
                    (§ let Class[] params = m.getParameterTypes())
                    (§ if (argcount == params.length))
                    (§
                        (§ ass method = m)
                        (§ ass variadic = (argcount > 0 && params[params.length - 1] == ISeq.class))
                        (§ break )
                    )
                    (§ elseif (argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class))
                    (§
                        (§ ass method = m)
                        (§ ass variadic = true)
                        (§ break )
                    )
                )
            )
            (§ if (method == nil))
            (§
                (§ return (§ expr nil))
            )

            (§ let Class retClass = method.getReturnType())

            (§ let Class[] paramClasses = method.getParameterTypes())
            (§ let Type[] paramTypes = new Type[paramClasses.length])

            (§ for (int i = 0 i < paramClasses.length i++))
            (§
                (§ ass paramTypes[i] = Type.getType(paramClasses[i]))
            )

            (§ let Type target = Type.getType(c))

            (§ let PersistentVector argv = PersistentVector.EMPTY)
            (§ for (ISeq s = RT.seq(args) s != nil s = s.next()))
            (§
                (§ ass argv = argv.cons(analyze(C.EXPRESSION, s.first())))
            )

            (§ return (§ expr new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition)))
        )
    )

    #_static
    (class-ns InvokeExpr (§ implements Expr)
        #_public
        #_final
        (§ field Expr fexpr)
        #_public
        #_final
        (§ field Object tag)
        #_public
        #_final
        (§ field IPersistentVector args)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)
        #_public
        #_final
        (§ field boolean tailPosition)
        #_public
        #_final
        (§ field String source)

        #_public
        (§ field boolean isProtocol = false)
        #_public
        (§ field boolean isDirect = false)
        #_public
        (§ field int siteIndex = -1)
        #_public
        (§ field Class protocolOn)
        #_public
        (§ field java.lang.reflect.Method onMethod)

        #_static
        (§ field Keyword onKey = Keyword.intern("on"))
        #_static
        (§ field Keyword methodMapKey = Keyword.intern("method-map"))

        (§ field Class jc)

        #_static
        (§ method Object sigTag(int argcount, Var v)
            (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
            (§ let Object sigTag = nil)
            (§ for (ISeq s = RT.seq(arglists) s != nil s = s.next()))
            (§
                (§ let APersistentVector sig = (APersistentVector) s.first())
                (§ let int restOffset = sig.indexOf(_AMP_))
                (§ if (argcount == sig.count() || (restOffset > -1 && argcount >= restOffset)))
                (§
                    (§ return (§ expr tagOf(sig)))
                )
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition)
            (§ ass this.source = source)
            (§ ass this.fexpr = fexpr)
            (§ ass this.args = args)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.tailPosition = tailPosition)

            (§ if (fexpr instanceof VarExpr))
            (§
                (§ let Var fvar = ((VarExpr)fexpr).var)
                (§ let Var pvar =  (Var)RT.get(fvar.meta(), protocolKey))
                (§ if (pvar != nil && PROTOCOL_CALLSITES.isBound()))
                (§
                    (§ ass this.isProtocol = true)
                    (§ ass this.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var))
                    (§ let Object pon = RT.get(pvar.get(), onKey))
                    (§ ass this.protocolOn = HostExpr.maybeClass(pon, false))
                    (§ if (this.protocolOn != nil))
                    (§
                        (§ let IPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey))
                        (§ let Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym)))
                        (§ if (mmapVal == nil))
                        (§
                            (§ throw new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)"))
                        )
                        (§ let String mname = munge(mmapVal.sym.toString()))
                        (§ let List methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false))
                        (§ if (methods.size() != 1))
                        (§
                            (§ throw new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym))
                        )
                        (§ ass this.onMethod = (java.lang.reflect.Method) methods.get(0))
                    )
                )
            )

            (§ if (tag != nil))
            (§
                (§ ass this.tag = tag)
            )
            (§ elseif (fexpr instanceof VarExpr))
            (§
                (§ let Var v = ((VarExpr) fexpr).var)
                (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
                (§ let Object sigTag = sigTag(args.count(), v))
                (§ ass this.tag = (sigTag == nil) ? ((VarExpr) fexpr).tag :or sigTag)
            )
            (§ else )
            (§
                (§ ass this.tag = nil)
            )
        )

        #_public
        (§ method Object eval()
            (§ try )
            (§
                (§ let IFn fn = (IFn) fexpr.eval())
                (§ let PersistentVector argvs = PersistentVector.EMPTY)
                (§ for (int i = 0 i < args.count() i++))
                (§
                    (§ ass argvs = argvs.cons(((Expr) args.nth(i)).eval()))
                )
                (§ return (§ expr fn.applyTo(RT.seq(Util.ret1(argvs, argvs = nil)))))
            )
            (§ catch (Throwable e))
            (§
                (§ if (!(e instanceof CompilerException)))
                (§
                    (§ throw new CompilerException(source, line, column, e))
                )
                (§ else )
                (§
                    (§ throw (CompilerException) e)
                )
            )
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (isProtocol))
            (§
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call emitProto(context, objx, gen))
            )
            (§ else )
            (§
                (§ call fexpr.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitLineNumber(line, gen.mark()))
                (§ call gen.checkCast(IFN_TYPE))
                (§ call emitArgsAndCall(0, context, objx, gen))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method void emitProto(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label onLabel = gen.newLabel())
            (§ let Label callLabel = gen.newLabel())
            (§ let Label endLabel = gen.newLabel())

            (§ let Var v = ((VarExpr)fexpr).var)

            (§ let Expr e = (Expr) args.nth(0))
            (§ call e.emit(C.EXPRESSION, objx, gen))
            (§ call gen.dup()) ;; target, target
            (§ call gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
            (§ call gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target, class, cached-class
            (§ call gen.visitJumpInsn(IF_ACMPEQ, callLabel)) ;; target
            (§ if (protocolOn != nil))
            (§
                (§ call gen.dup()) ;; target, target
                (§ call gen.instanceOf(Type.getType(protocolOn)))
                (§ call gen.ifZCmp(GeneratorAdapter.NE, onLabel))
            )

            (§ call gen.dup()) ;; target, target
            (§ call gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
            (§ call gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target

            (§ call gen.mark(callLabel)) ;; target
            (§ call objx.emitVar(gen, v))
            (§ call gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))) ;; target, proto-fn
            (§ call gen.swap())
            (§ call emitArgsAndCall(1, context, objx, gen))
            (§ call gen.goTo(endLabel))

            (§ call gen.mark(onLabel)) ;; target
            (§ if (protocolOn != nil))
            (§
                (§ call gen.checkCast(Type.getType(protocolOn)))
                (§ call MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count())))
                (§ if (context == C.RETURN))
                (§
                    (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                    (§ call method.emitClearLocals(gen))
                )
                (§ let Method m = new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod)))
                (§ call gen.invokeInterface(Type.getType(protocolOn), m))
                (§ call HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType()))
            )
            (§ call gen.mark(endLabel))
        )

        (§ method void emitArgsAndCall(int firstArgToEmit, C context, ObjExpr objx, GeneratorAdapter gen)
            (§ for (int i = firstArgToEmit i < Math.min(MAX_POSITIONAL_ARITY, args.count()) i++))
            (§
                (§ let Expr e = (Expr) args.nth(i))
                (§ call e.emit(C.EXPRESSION, objx, gen))
            )
            (§ if (args.count() > MAX_POSITIONAL_ARITY))
            (§
                (§ let PersistentVector restArgs = PersistentVector.EMPTY)
                (§ for (int i = MAX_POSITIONAL_ARITY i < args.count() i++))
                (§
                    (§ ass restArgs = restArgs.cons(args.nth(i)))
                )
                (§ call MethodExpr.emitArgsAsArray(restArgs, objx, gen))
            )
            (§ call gen.visitLineNumber(line, gen.mark()))

            (§ if (tailPosition && !objx.canBeDirect))
            (§
                (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                (§ call method.emitClearThis(gen))
            )

            (§ call gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())])))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (tag != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = HostExpr.tagToClass(tag))
            )
            (§ return (§ expr jc))
        )

        #_static
        #_public
        (§ method Expr parse(C context, ISeq form)
            (§ let boolean tailPosition = inTailCall(context))
            (§ if (context != C.EVAL))
            (§
                (§ ass context = C.EXPRESSION)
            )
            (§ let Expr fexpr = analyze(context, form.first()))
            (§ if (fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3))
            (§
                (§ let Expr sexpr = analyze(C.EXPRESSION, RT.second(form)))
                (§ if (sexpr instanceof ConstantExpr))
                (§
                    (§ let Object val = ((ConstantExpr) sexpr).val())
                    (§ if (val instanceof Class))
                    (§
                        (§ return (§ expr new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))))
                    )
                )
            )

            (§ if (RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL))
            (§
                (§ let Var v = ((VarExpr)fexpr).var)
                (§ if (!v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false))))
                (§
                    (§ let Symbol formtag = tagOf(form))
                    (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
                    (§ let int arity = RT.count(form.next()))
                    (§ let Object sigtag = sigTag(arity, v))
                    (§ let Object vtag = RT.get(RT.meta(v), RT.TAG_KEY))
                    (§ let Expr ret = StaticInvokeExpr.parse(v, RT.next(form), (formtag != nil) ? formtag :or (sigtag != nil) ? sigtag :or vtag, tailPosition))
                    (§ if (ret != nil))
                    (§
                        (§ return (§ expr ret))
                    )
                )
            )

            (§ if (fexpr instanceof VarExpr && context != C.EVAL))
            (§
                (§ let Var v = ((VarExpr)fexpr).var)
                (§ let Object arglists = RT.get(RT.meta(v), arglistsKey))
                (§ let int arity = RT.count(form.next()))
                (§ for (ISeq s = RT.seq(arglists) s != nil s = s.next()))
                (§
                    (§ let IPersistentVector args = (IPersistentVector) s.first())
                    (§ if (args.count() == arity))
                    (§
                        (§ let String primc = FnMethod.primInterface(args))
                        (§ if (primc != nil))
                        (§
                            (§ return (§ expr analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"), ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))), form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))))
                        )
                        (§ break )
                    )
                )
            )

            (§ if (fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound()))
            (§
                (§ let Expr target = analyze(context, RT.second(form)))
                (§ return (§ expr new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)))
            )
            (§ let PersistentVector args = PersistentVector.EMPTY)
            (§ for (ISeq s = RT.seq(form.next()) s != nil s = s.next()))
            (§
                (§ ass args = args.cons(analyze(context, s.first())))
            )

            (§ return (§ expr new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition)))
        )
    )

    #_static
    (class-ns SourceDebugExtensionAttribute (§ extends Attribute)
        #_public
        (§ method SourceDebugExtensionAttribute()
            (§ super("SourceDebugExtension"))
        )

        (§ method void writeSMAP(ClassWriter cw, String smap)
            (§ let ByteVector bv = write(cw, nil, -1, -1, -1))
            (§ call bv.putUTF8(smap))
        )
    )

    #_static
    #_public
    (class-ns FnExpr (§ extends ObjExpr)
        #_final
        #_static
        (§ field Type aFnType = Type.getType(AFunction.class))
        #_final
        #_static
        (§ field Type restFnType = Type.getType(RestFn.class))

        ;; if there is a variadic overload (there can only be one) it is stored here
        (§ field FnMethod variadicMethod = nil)
        (§ field IPersistentCollection methods)
        #_private
        (§ field boolean hasPrimSigs)
        #_private
        (§ field boolean hasMeta)
        #_private
        (§ field boolean hasEnclosingMethod)

        (§ field Class jc)

        #_public
        (§ method FnExpr(Object tag)
            (§ super(tag))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        (§ method boolean supportsMeta()
            (§ return (§ expr hasMeta))
        )

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = (tag != nil) ? HostExpr.tagToClass(tag) :or AFunction.class)
            )
            (§ return (§ expr jc))
        )

        #_protected
        (§ method void emitMethods(ClassVisitor cv)
            ;; override of invoke/doInvoke for each method
            (§ for (ISeq s = RT.seq(methods) s != nil s = s.next()))
            (§
                (§ let ObjMethod method = (ObjMethod) s.first())
                (§ call method.emit(this, cv))
            )

            (§ if (isVariadic()))
            (§
                (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), nil, nil, cv))
                (§ call gen.visitCode())
                (§ call gen.push(variadicMethod.reqParms.count()))
                (§ call gen.returnValue())
                (§ call gen.endMethod())
            )
        )

        #_static
        (§ method Expr parse(C context, ISeq form, String name)
            (§ let ISeq origForm = form)
            (§ let FnExpr fn = new FnExpr(tagOf(form)))
            (§ let Keyword retkey = Keyword.intern(nil, "rettag"))
            (§ let Object rettag = RT.get(RT.meta(form), retkey))
            (§ ass fn.src = form)
            (§ let ObjMethod enclosingMethod = (ObjMethod) METHOD.deref())
            (§ ass fn.hasEnclosingMethod = enclosingMethod != nil)
            (§ if (((IMeta) form.first()).meta() != nil))
            (§
                (§ ass fn.onceOnly = RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(nil, "once"))))
            )

            (§ let String basename = ((enclosingMethod != nil) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$")

            (§ let Symbol nm = nil)

            (§ if (RT.second(form) instanceof Symbol))
            (§
                (§ ass nm = (Symbol) RT.second(form))
                (§ ass name = nm.name + "__" + RT.nextID())
            )
            (§ else )
            (§
                (§ if (name == nil))
                (§
                    (§ ass name = "fn__" + RT.nextID())
                )
                (§ elseif (enclosingMethod != nil))
                (§
                    (§ ass name += "__" + RT.nextID())
                )
            )

            (§ let String simpleName = munge(name).replace(".", "_DOT_"))

            (§ ass fn.name = basename + simpleName)
            (§ ass fn.internalName = fn.name.replace(\., \/))
            (§ ass fn.objtype = Type.getObjectType(fn.internalName))
            (§ let ArrayList<String> prims = new ArrayList())
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map CONSTANTS, PersistentVector.EMPTY,
                      #_map CONSTANT_IDS, new IdentityHashMap(),
                      #_map KEYWORDS, PersistentHashMap.EMPTY,
                      #_map VARS, PersistentHashMap.EMPTY,
                      #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                      #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                      #_map VAR_CALLSITES, emptyVarCallSites(),
                      #_map NO_RECUR, nil
                )))

                ;; arglist might be preceded by symbol naming this fn
                (§ if (nm != nil))
                (§
                    (§ ass fn.thisName = nm.name)
                    (§ ass form = RT.cons(FN, RT.next(RT.next(form))))
                )

                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                ;; turn former into latter
                (§ if (RT.second(form) instanceof IPersistentVector))
                (§
                    (§ ass form = RT.list(FN, RT.next(form)))
                )
                (§ ass fn.line = lineDeref())
                (§ ass fn.column = columnDeref())
                (§ let FnMethod[] methodArray = new FnMethod[MAX_POSITIONAL_ARITY + 1])
                (§ let FnMethod variadicMethod = nil)
                (§ let boolean usesThis = false)
                (§ for (ISeq s = RT.next(form) s != nil s = RT.next(s)))
                (§
                    (§ let FnMethod f = FnMethod.parse(fn, (ISeq) RT.first(s), rettag))
                    (§ if (f.usesThis))
                    (§
                        (§ ass usesThis = true)
                    )
                    (§ if (f.isVariadic()))
                    (§
                        (§ if (variadicMethod == nil))
                        (§
                            (§ ass variadicMethod = f)
                        )
                        (§ else )
                        (§
                            (§ throw Util.runtimeException("Can't have more than 1 variadic overload"))
                        )
                    )
                    (§ elseif (methodArray[f.reqParms.count()] == nil))
                    (§
                        (§ ass methodArray[f.reqParms.count()] = f)
                    )
                    (§ else )
                    (§
                        (§ throw Util.runtimeException("Can't have 2 overloads with same arity"))
                    )
                    (§ if (f.prim != nil))
                    (§
                        (§ call prims.add(f.prim))
                    )
                )
                (§ if (variadicMethod != nil))
                (§
                    (§ for (int i = variadicMethod.reqParms.count() + 1 i <= MAX_POSITIONAL_ARITY i++))
                    (§
                        (§ if (methodArray[i] != nil))
                        (§
                            (§ throw Util.runtimeException("Can't have fixed arity function with more params than variadic function"))
                        )
                    )
                )

                (§ ass fn.canBeDirect = (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis))

                (§ let IPersistentCollection methods = nil)
                (§ for (int i = 0 i < methodArray.length i++))
                (§
                    (§ if (methodArray[i] != nil))
                    (§
                        (§ ass methods = RT.conj(methods, methodArray[i]))
                    )
                )
                (§ if (variadicMethod != nil))
                (§
                    (§ ass methods = RT.conj(methods, variadicMethod))
                )

                (§ if (fn.canBeDirect))
                (§
                    (§ for (FnMethod fm :in (Collection<FnMethod>)methods))
                    (§
                        (§ if (fm.locals != nil))
                        (§
                            (§ for (LocalBinding lb :in (Collection<LocalBinding>)RT.keys(fm.locals)))
                            (§
                                (§ if (lb.isArg))
                                (§
                                    (§ ass lb.idx -= 1)
                                )
                            )
                        )
                    )
                )

                (§ ass fn.methods = methods)
                (§ ass fn.variadicMethod = variadicMethod)
                (§ ass fn.keywords = (IPersistentMap) KEYWORDS.deref())
                (§ ass fn.vars = (IPersistentMap) VARS.deref())
                (§ ass fn.constants = (PersistentVector) CONSTANTS.deref())
                (§ ass fn.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                (§ ass fn.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                (§ ass fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())

                (§ ass fn.constantsID = RT.nextID())
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
            (§ ass fn.hasPrimSigs = prims.size() > 0)
            (§ let IPersistentMap fmeta = RT.meta(origForm))
            (§ if (fmeta != nil))
            (§
                (§ ass fmeta = fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey))
            )

            (§ ass fn.hasMeta = RT.count(fmeta) > 0)

            (§ try )
            (§
                (§ call fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? nil :or prims.toArray(new String[prims.size()]), fn.onceOnly))
            )
            (§ catch (IOException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ call fn.getCompiledClass())

            (§ if (fn.supportsMeta()))
            (§
                (§ return (§ expr new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta))))
            )
            (§ else )
            (§
                (§ return (§ expr fn))
            )
        )

        #_public
        #_final
        (§ method ObjMethod variadicMethod()
            (§ return (§ expr variadicMethod))
        )

        (§ method boolean isVariadic()
            (§ return (§ expr (variadicMethod != nil)))
        )

        #_public
        #_final
        (§ method IPersistentCollection methods()
            (§ return (§ expr methods))
        )

        #_public
        (§ method void emitForDefn(ObjExpr objx, GeneratorAdapter gen)
            (§ call emit(C.EXPRESSION, objx, gen))
        )
    )

    #_static
    #_public
    (class-ns ObjExpr (§ implements Expr)
        #_static
        #_final
        (§ field String CONST_PREFIX = "const__")

        (§ field String name)
        (§ field String internalName)
        (§ field String thisName)
        (§ field Type objtype)
        #_public
        #_final
        (§ field Object tag)
        ;; localbinding->itself
        (§ field IPersistentMap closes = PersistentHashMap.EMPTY)
        ;; localbndingexprs
        (§ field IPersistentVector closesExprs = PersistentVector.EMPTY)
        ;; symbols
        (§ field IPersistentSet volatiles = PersistentHashSet.EMPTY)

        ;; symbol->lb
        (§ field IPersistentMap fields = nil)

        ;; hinted fields
        (§ field IPersistentVector hintedFields = PersistentVector.EMPTY)

        ;; Keyword->KeywordExpr
        (§ field IPersistentMap keywords = PersistentHashMap.EMPTY)
        (§ field IPersistentMap vars = PersistentHashMap.EMPTY)
        (§ field Class compiledClass)
        (§ field int line)
        (§ field int column)
        (§ field PersistentVector constants)
        (§ field IPersistentSet usedConstants = PersistentHashSet.EMPTY)

        (§ field int constantsID)
        (§ field int altCtorDrops = 0)

        (§ field IPersistentVector keywordCallsites)
        (§ field IPersistentVector protocolCallsites)
        (§ field IPersistentSet varCallsites)
        (§ field boolean onceOnly = false)

        (§ field Object src)

        (§ field IPersistentMap opts = PersistentHashMap.EMPTY)

        #_final
        #_static
        (§ field Method voidctor = Method.getMethod("void <init>()"))
        #_protected
        (§ field IPersistentMap classMeta)
        #_protected
        (§ field boolean canBeDirect)

        #_public
        #_final
        (§ method String name()
            (§ return (§ expr name))
        )

        #_public
        #_final
        (§ method String internalName()
            (§ return (§ expr internalName))
        )

        #_public
        #_final
        (§ method String thisName()
            (§ return (§ expr thisName))
        )

        #_public
        #_final
        (§ method Type objtype()
            (§ return (§ expr objtype))
        )

        #_public
        #_final
        (§ method IPersistentMap closes()
            (§ return (§ expr closes))
        )

        #_public
        #_final
        (§ method IPersistentMap keywords()
            (§ return (§ expr keywords))
        )

        #_public
        #_final
        (§ method IPersistentMap vars()
            (§ return (§ expr vars))
        )

        #_public
        #_final
        (§ method Class compiledClass()
            (§ return (§ expr compiledClass))
        )

        #_public
        #_final
        (§ method int line()
            (§ return (§ expr line))
        )

        #_public
        #_final
        (§ method int column()
            (§ return (§ expr column))
        )

        #_public
        #_final
        (§ method PersistentVector constants()
            (§ return (§ expr constants))
        )

        #_public
        #_final
        (§ method int constantsID()
            (§ return (§ expr constantsID))
        )

        #_final
        #_static
        (§ field Method kwintern = Method.getMethod("cloiure.lang.Keyword intern(String, String)"))
        #_final
        #_static
        (§ field Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String)"))
        #_final
        #_static
        (§ field Method varintern = Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)"))

        #_final
        #_static
        (§ field Type DYNAMIC_CLASSLOADER_TYPE = Type.getType(DynamicClassLoader.class))
        #_final
        #_static
        (§ field Method getClassMethod = Method.getMethod("Class getClass()"))
        #_final
        #_static
        (§ field Method getClassLoaderMethod = Method.getMethod("ClassLoader getClassLoader()"))
        #_final
        #_static
        (§ field Method getConstantsMethod = Method.getMethod("Object[] getConstants(int)"))
        #_final
        #_static
        (§ field Method readStringMethod = Method.getMethod("Object readString(String)"))

        #_final
        #_static
        (§ field Type ILOOKUP_SITE_TYPE = Type.getType(ILookupSite.class))
        #_final
        #_static
        (§ field Type ILOOKUP_THUNK_TYPE = Type.getType(ILookupThunk.class))
        #_final
        #_static
        (§ field Type KEYWORD_LOOKUPSITE_TYPE = Type.getType(KeywordLookupSite.class))

        #_private
        (§ field DynamicClassLoader loader)
        #_private
        (§ field byte[] bytecode)

        #_public
        (§ method ObjExpr(Object tag)
            (§ ass this.tag = tag)
        )

        #_static
        (§ method String trimGenID(String name)
            (§ let int i = name.lastIndexOf("__"))
            (§ return (§ expr (i == -1) ? name :or name.substring(0, i)))
        )

        (§ method Type[] ctorTypes()
            (§ let IPersistentVector tv = !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE))
            (§ for (ISeq s = RT.keys(closes) s != nil s = s.next()))
            (§
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ if (lb.getPrimitiveType() != nil))
                (§
                    (§ ass tv = tv.cons(Type.getType(lb.getPrimitiveType())))
                )
                (§ else )
                (§
                    (§ ass tv = tv.cons(OBJECT_TYPE))
                )
            )
            (§ let Type[] ret = new Type[tv.count()])
            (§ for (int i = 0 i < tv.count() i++))
            (§
                (§ ass ret[i] = (Type) tv.nth(i))
            )
            (§ return (§ expr ret))
        )

        (§ method void compile(String superName, String[] interfaceNames, boolean oneTimeUse) (§ throws IOException)
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            (§ let ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS))
            (§ let ClassVisitor cv = cw)
            (§ call cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, superName, interfaceNames))
            (§ let String source = (String) SOURCE.deref())
            (§ let int lineBefore = (Integer) LINE_BEFORE.deref())
            (§ let int lineAfter = (Integer) LINE_AFTER.deref() + 1)
            (§ let int columnBefore = (Integer) COLUMN_BEFORE.deref())
            (§ let int columnAfter = (Integer) COLUMN_AFTER.deref() + 1)

            (§ if (source != nil && SOURCE_PATH.deref() != nil))
            (§
                (§ let String smap = "SMAP\n"
              #_arg + ((source.lastIndexOf(\.) > 0) ? source.substring(0, source.lastIndexOf(\.)) :or source) ;; :or simpleName
              #_arg + ".java\n"
              #_arg + "Cloiure\n"
              #_arg + "*S Cloiure\n"
              #_arg + "*F\n"
              #_arg + "+ 1 " + source + "\n"
              #_arg + (String) SOURCE_PATH.deref() + "\n"
              #_arg + "*L\n"
              #_arg + String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore)
              #_arg + "*E")
                (§ call cv.visitSource(source, smap))
            )
            (§ call addAnnotation(cv, classMeta))

            (§ if (supportsMeta()))
            (§
                (§ call cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
            )
            ;; instance fields for closed-overs
            (§ for (ISeq s = RT.keys(closes) s != nil s = s.next()))
            (§
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ if (isDeftype()))
                (§
                    (§ let int access = isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL))
                    (§ let FieldVisitor fv)
                    (§ if (lb.getPrimitiveType() != nil))
                    (§
                        (§ ass fv = cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                    )
                    (§ else )
                    (§
                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                        (§ ass fv = cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                    )
                    (§ call addAnnotation(fv, RT.meta(lb.sym)))
                )
                (§ else )
                (§
                    ;; todo - only enable this non-private+writability for letfns where we need it
                    (§ if (lb.getPrimitiveType() != nil))
                    (§
                        (§ call cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                    )
                    (§ else )
                    (§
                        (§ call cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                    )
                )
            )

            ;; static fields for callsites and thunks
            (§ for (int i = 0 i < protocolCallsites.count() i++))
            (§
                (§ call cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), nil, nil))
            )

            ;; ctor that takes closed-overs and inits base + fields
            (§ let Method m = new Method("<init>", Type.VOID_TYPE, ctorTypes()))
            (§ let GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))
            (§ let Label start = ctorgen.newLabel())
            (§ let Label end = ctorgen.newLabel())
            (§ call ctorgen.visitCode())
            (§ call ctorgen.visitLineNumber(line, ctorgen.mark()))
            (§ call ctorgen.visitLabel(start))
            (§ call ctorgen.loadThis())
            (§ call ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))

            (§ if (supportsMeta()))
            (§
                (§ call ctorgen.loadThis())
                (§ call ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1))
                (§ call ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE))
            )

            (§ let int a = supportsMeta() ? 2 :or 1)
            (§ for (ISeq s = RT.keys(closes) s != nil s = s.next(), ++a))
            (§
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ call ctorgen.loadThis())
                (§ let Class primc = lb.getPrimitiveType())
                (§ if (primc != nil))
                (§
                    (§ call ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a))
                    (§ call ctorgen.putField(objtype, lb.name, Type.getType(primc)))
                    (§ if (primc == Long.TYPE || primc == Double.TYPE))
                    (§
                        (§ ass ++a)
                    )
                )
                (§ else )
                (§
                    (§ call ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a))
                    (§ call ctorgen.putField(objtype, lb.name, OBJECT_TYPE))
                )
                (§ ass closesExprs = closesExprs.cons(new LocalBindingExpr(lb, nil)))
            )

            (§ call ctorgen.visitLabel(end))

            (§ call ctorgen.returnValue())

            (§ call ctorgen.endMethod())

            (§ if (altCtorDrops > 0))
            (§
                ;; ctor that takes closed-overs and inits base + fields
                (§ let Type[] ctorTypes = ctorTypes())
                (§ let Type[] altCtorTypes = new Type[ctorTypes.length-altCtorDrops])
                (§ for (int i = 0 i < altCtorTypes.length i++))
                (§
                    (§ ass altCtorTypes[i] = ctorTypes[i])
                )
                (§ let Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (§ ass ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (§ call ctorgen.visitCode())
                (§ call ctorgen.loadThis())
                (§ call ctorgen.loadArgs())

                (§ call ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                (§ call ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (§ call ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (§ call ctorgen.returnValue())
                (§ call ctorgen.endMethod())

                ;; alt ctor no __hash, __hasheq
                (§ ass altCtorTypes = new Type[ctorTypes.length-2])
                (§ for (int i = 0 i < altCtorTypes.length i++))
                (§
                    (§ ass altCtorTypes[i] = ctorTypes[i])
                )

                (§ ass alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (§ ass ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (§ call ctorgen.visitCode())
                (§ call ctorgen.loadThis())
                (§ call ctorgen.loadArgs())

                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (§ call ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (§ call ctorgen.returnValue())
                (§ call ctorgen.endMethod())
            )

            (§ if (supportsMeta()))
            (§
                ;; ctor that takes closed-overs but not meta
                (§ let Type[] ctorTypes = ctorTypes())
                (§ let Type[] noMetaCtorTypes = new Type[ctorTypes.length-1])
                (§ for (int i = 1 i < ctorTypes.length i++))
                (§
                    (§ ass noMetaCtorTypes[i - 1] = ctorTypes[i])
                )
                (§ let Method alt = new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes))
                (§ ass ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (§ call ctorgen.visitCode())
                (§ call ctorgen.loadThis())
                (§ call ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; nil meta
                (§ call ctorgen.loadArgs())
                (§ call ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (§ call ctorgen.returnValue())
                (§ call ctorgen.endMethod())

                ;; meta()
                (§ let Method meth = Method.getMethod("cloiure.lang.IPersistentMap meta()"))

                (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))
                (§ call gen.visitCode())
                (§ call gen.loadThis())
                (§ call gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE))

                (§ call gen.returnValue())
                (§ call gen.endMethod())

                ;; withMeta()
                (§ ass meth = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                (§ ass gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))
                (§ call gen.visitCode())
                (§ call gen.newInstance(objtype))
                (§ call gen.dup())
                (§ call gen.loadArg(0))

                (§ for (ISeq s = RT.keys(closes) s != nil s = s.next(), ++a))
                (§
                    (§ let LocalBinding lb = (LocalBinding) s.first())
                    (§ call gen.loadThis())
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ if (primc != nil))
                    (§
                        (§ call gen.getField(objtype, lb.name, Type.getType(primc)))
                    )
                    (§ else )
                    (§
                        (§ call gen.getField(objtype, lb.name, OBJECT_TYPE))
                    )
                )

                (§ call gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))
                (§ call gen.returnValue())
                (§ call gen.endMethod())
            )

            (§ call emitStatics(cv))
            (§ call emitMethods(cv))

            ;; static fields for constants
            (§ for (int i = 0 i < constants.count() i++))
            (§
                (§ if (usedConstants.contains(i)))
                (§
                    (§ call cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), nil, nil))
                )
            )

            ;; static fields for lookup sites
            (§ for (int i = 0 i < keywordCallsites.count() i++))
            (§
                (§ call cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                (§ call cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
            )

            ;; static init for constants, keywords and vars
            (§ let GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))
            (§ call clinitgen.visitCode())
            (§ call clinitgen.visitLineNumber(line, clinitgen.mark()))

            (§ if (constants.count() > 0))
            (§
                (§ call emitConstants(clinitgen))
            )

            (§ if (keywordCallsites.count() > 0))
            (§
                (§ call emitKeywordCallsites(clinitgen))
            )

            (§ if (isDeftype() && RT.booleanCast(RT.get(opts, loadNs))))
            (§
                (§ let String nsname = ((Symbol)RT.second(src)).getNamespace())
                (§ if (!nsname.equals("cloiure.core")))
                (§
                    (§ call clinitgen.push("cloiure.core"))
                    (§ call clinitgen.push("require"))
                    (§ call clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                    (§ call clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")))
                    (§ call clinitgen.checkCast(IFN_TYPE))
                    (§ call clinitgen.push(nsname))
                    (§ call clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)")))
                    (§ call clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)")))
                    (§ call clinitgen.pop())
                )
            )

            (§ call clinitgen.returnValue())

            (§ call clinitgen.endMethod())

            ;; end of class
            (§ call cv.visitEnd())

            (§ ass bytecode = cw.toByteArray())
            (§ if (RT.booleanCast(COMPILE_FILES.deref())))
            (§
                (§ call writeClassFile(internalName, bytecode))
            )
        )

        #_private
        (§ method void emitKeywordCallsites(GeneratorAdapter clinitgen)
            (§ for (int i = 0 i < keywordCallsites.count() i++))
            (§
                (§ let Keyword k = (Keyword) keywordCallsites.nth(i))
                (§ call clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE))
                (§ call clinitgen.dup())
                (§ call emitValue(k, clinitgen))
                (§ call clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)")))
                (§ call clinitgen.dup())
                (§ call clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE))
                (§ call clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE))
            )
        )

        #_protected
        (§ method void emitStatics(ClassVisitor gen)
        )

        #_protected
        (§ method void emitMethods(ClassVisitor gen)
        )

        (§ method void emitListAsObjectArray(Object value, GeneratorAdapter gen)
            (§ call gen.push(((List) value).size()))
            (§ call gen.newArray(OBJECT_TYPE))
            (§ let int i = 0)
            (§ for (Iterator it = ((List) value).iterator() it.hasNext() i++))
            (§
                (§ call gen.dup())
                (§ call gen.push(i))
                (§ call emitValue(it.next(), gen))
                (§ call gen.arrayStore(OBJECT_TYPE))
            )
        )

        (§ method void emitValue(Object value, GeneratorAdapter gen)
            (§ let boolean partial = true)

            (§ if (value == nil))
            (§
                (§ call gen.visitInsn(Opcodes.ACONST_NULL))
            )
            (§ elseif (value instanceof String))
            (§
                (§ call gen.push((String) value))
            )
            (§ elseif (value instanceof Boolean))
            (§
                (§ if (((Boolean) value).booleanValue()))
                (§
                    (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                )
                (§ else )
                (§
                    (§ call gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                )
            )
            (§ elseif (value instanceof Integer))
            (§
                (§ call gen.push(((Integer) value).intValue()))
                (§ call gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)")))
            )
            (§ elseif (value instanceof Long))
            (§
                (§ call gen.push(((Long) value).longValue()))
                (§ call gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)")))
            )
            (§ elseif (value instanceof Double))
            (§
                (§ call gen.push(((Double) value).doubleValue()))
                (§ call gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)")))
            )
            (§ elseif (value instanceof Character))
            (§
                (§ call gen.push(((Character) value).charValue()))
                (§ call gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)")))
            )
            (§ elseif (value instanceof Class))
            (§
                (§ let Class cc = (Class)value)
                (§ if (cc.isPrimitive()))
                (§
                    (§ let Type bt)
                    (§ if (cc == boolean.class))
                    (§
                        (§ ass bt = Type.getType(Boolean.class))
                    )
                    (§ elseif (cc == byte.class))
                    (§
                        (§ ass bt = Type.getType(Byte.class))
                    )
                    (§ elseif (cc == char.class))
                    (§
                        (§ ass bt = Type.getType(Character.class))
                    )
                    (§ elseif (cc == double.class))
                    (§
                        (§ ass bt = Type.getType(Double.class))
                    )
                    (§ elseif (cc == float.class))
                    (§
                        (§ ass bt = Type.getType(Float.class))
                    )
                    (§ elseif (cc == int.class))
                    (§
                        (§ ass bt = Type.getType(Integer.class))
                    )
                    (§ elseif (cc == long.class))
                    (§
                        (§ ass bt = Type.getType(Long.class))
                    )
                    (§ elseif (cc == short.class))
                    (§
                        (§ ass bt = Type.getType(Short.class))
                    )
                    (§ else )
                    (§
                        (§ throw Util.runtimeException("Can't embed unknown primitive in code: " + value))
                    )
                    (§ call gen.getStatic(bt, "TYPE", Type.getType(Class.class)))
                )
                (§ else )
                (§
                    (§ call gen.push(destubClassName(cc.getName())))
                    (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                )
            )
            (§ elseif (value instanceof Symbol))
            (§
                (§ call gen.push(((Symbol) value).ns))
                (§ call gen.push(((Symbol) value).name))
                (§ call gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)")))
            )
            (§ elseif (value instanceof Keyword))
            (§
                (§ call gen.push(((Keyword) value).sym.ns))
                (§ call gen.push(((Keyword) value).sym.name))
                (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)")))
            )
            (§ elseif (value instanceof Var))
            (§
                (§ let Var var = (Var) value)
                (§ call gen.push(var.ns.name.toString()))
                (§ call gen.push(var.sym.toString()))
                (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
            )
            (§ elseif (value instanceof IType))
            (§
                (§ let Method ctor = new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0])))
                (§ call gen.newInstance(Type.getType(value.getClass())))
                (§ call gen.dup())
                (§ let IPersistentVector fields = (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§)))
                (§ for (ISeq s = RT.seq(fields) s != nil s = s.next()))
                (§
                    (§ let Symbol field = (Symbol) s.first())
                    (§ let Class k = tagClass(tagOf(field)))
                    (§ let Object val = Reflector.getInstanceField(value, munge(field.name)))
                    (§ call emitValue(val, gen))

                    (§ if (k.isPrimitive()))
                    (§
                        (§ let Type b = Type.getType(boxClass(k)))
                        (§ let String p = Type.getType(k).getDescriptor())
                        (§ let String n = k.getName())

                        (§ call gen.invokeVirtual(b, new Method(n+"Value", "()"+p)))
                    )
                )
                (§ call gen.invokeConstructor(Type.getType(value.getClass()), ctor))
            )
            (§ elseif (value instanceof IRecord))
            (§
                (§ let Method createMethod = Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))
                (§ call emitValue(PersistentArrayMap.create((java.util.Map) value), gen))
                (§ call gen.invokeStatic(getType(value.getClass()), createMethod))
            )
            (§ elseif (value instanceof IPersistentMap))
            (§
                (§ let List entries = new ArrayList())
                (§ for (Map.Entry entry :in (Set<Map.Entry>) ((Map) value).entrySet()))
                (§
                    (§ call entries.add(entry.getKey()))
                    (§ call entries.add(entry.getValue()))
                )
                (§ call emitListAsObjectArray(entries, gen))
                (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
            )
            (§ elseif (value instanceof IPersistentVector))
            (§
                (§ let IPersistentVector args = (IPersistentVector) value)
                (§ if (args.count() <= Tuple.MAX_SIZE))
                (§
                    (§ for (int i = 0 i < args.count() i++))
                    (§
                        (§ call emitValue(args.nth(i), gen))
                    )
                    (§ call gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                )
                (§ else )
                (§
                    (§ call emitListAsObjectArray(value, gen))
                    (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                )
            )
            (§ elseif (value instanceof PersistentHashSet))
            (§
                (§ let ISeq vs = RT.seq(value))
                (§ if (vs == nil))
                (§
                    (§ call gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class)))
                )
                (§ else )
                (§
                    (§ call emitListAsObjectArray(vs, gen))
                    (§ call gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                )
            )
            (§ elseif (value instanceof ISeq || value instanceof IPersistentList))
            (§
                (§ call emitListAsObjectArray(value, gen))
                (§ call gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])")))
                (§ call gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
            )
            (§ elseif (value instanceof Pattern))
            (§
                (§ call emitValue(value.toString(), gen))
                (§ call gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)")))
            )
            (§ else )
            (§
                (§ let String cs = nil)
                (§ try )
                (§
                    (§ ass cs = RT.printString(value))
                )
                (§ catch (Exception e))
                (§
                    (§ throw Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value))
                )
                (§ if (cs.length() == 0))
                (§
                    (§ throw Util.runtimeException("Can't embed unreadable object in code: " + value))
                )

                (§ if (cs.startsWith("#<")))
                (§
                    (§ throw Util.runtimeException("Can't embed unreadable object in code: " + cs))
                )

                (§ call gen.push(cs))
                (§ call gen.invokeStatic(RT_TYPE, readStringMethod))
                (§ ass partial = false)
            )

            (§ if (partial))
            (§
                (§ if (value instanceof IObj && RT.count(((IObj) value).meta()) > 0))
                (§
                    (§ call gen.checkCast(IOBJ_TYPE))
                    (§ let Object m = ((IObj) value).meta())
                    (§ call emitValue(elideMeta(m), gen))
                    (§ call gen.checkCast(IPERSISTENTMAP_TYPE))
                    (§ call gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                )
            )
        )

        (§ method void emitConstants(GeneratorAdapter clinitgen)
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                (§ for (int i = 0 i < constants.count() i++))
                (§
                    (§ if (usedConstants.contains(i)))
                    (§
                        (§ call emitValue(constants.nth(i), clinitgen))
                        (§ call clinitgen.checkCast(constantType(i)))
                        (§ call clinitgen.putStatic(objtype, constantName(i), constantType(i)))
                    )
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )

        (§ method boolean isMutable(LocalBinding lb)
            (§ return (§ expr isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable")))))
        )

        (§ method boolean isVolatile(LocalBinding lb)
            (§ return (§ expr RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable")))))
        )

        (§ method boolean isDeftype()
            (§ return (§ expr (fields != nil)))
        )

        (§ method boolean supportsMeta()
            (§ return (§ expr !isDeftype()))
        )

        (§ method void emitClearCloses(GeneratorAdapter gen)
        )

        #_synchronized
        (§ method Class getCompiledClass()
            (§ if (compiledClass == nil))
            (§
                (§ ass loader = (DynamicClassLoader) LOADER.deref())
                (§ ass compiledClass = loader.defineClass(name, bytecode, src))
            )
            (§ return (§ expr compiledClass))
        )

        #_public
        (§ method Object eval()
            (§ if (isDeftype()))
            (§
                (§ return (§ expr nil))
            )
            (§ try )
            (§
                (§ return (§ expr getCompiledClass().newInstance()))
            )
            (§ catch (Exception e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )

        #_public
        (§ method void emitLetFnInits(GeneratorAdapter gen, ObjExpr objx, IPersistentSet letFnLocals)
            ;; objx arg is enclosing objx, not this
            (§ call gen.checkCast(objtype))

            (§ for (ISeq s = RT.keys(closes) s != nil s = s.next()))
            (§
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ if (letFnLocals.contains(lb)))
                (§
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ call gen.dup())
                    (§ if (primc != nil))
                    (§
                        (§ call objx.emitUnboxedLocal(gen, lb))
                        (§ call gen.putField(objtype, lb.name, Type.getType(primc)))
                    )
                    (§ else )
                    (§
                        (§ call objx.emitLocal(gen, lb, false))
                        (§ call gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
            )
            (§ call gen.pop())
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            (§ if (isDeftype()))
            (§
                (§ call gen.visitInsn(Opcodes.ACONST_NULL))
            )
            (§ else )
            (§
                (§ call gen.newInstance(objtype))
                (§ call gen.dup())
                (§ if (supportsMeta()))
                (§
                    (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                )
                (§ for (ISeq s = RT.seq(closesExprs) s != nil s = s.next()))
                (§
                    (§ let LocalBindingExpr lbe = (LocalBindingExpr) s.first())
                    (§ let LocalBinding lb = lbe.b)
                    (§ if (lb.getPrimitiveType() != nil))
                    (§
                        (§ call objx.emitUnboxedLocal(gen, lb))
                    )
                    (§ else )
                    (§
                        (§ call objx.emitLocal(gen, lb, lbe.shouldClear))
                    )
                )
                (§ call gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes())))
            )
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        (§ field Class jc)

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr.tagToClass(tag) :or IFn.class)
            )
            (§ return (§ expr jc))
        )

        #_public
        (§ method void emitAssignLocal(GeneratorAdapter gen, LocalBinding lb, Expr val)
            (§ if (!isMutable(lb)))
            (§
                (§ throw new IllegalArgumentException("Cannot assign to non-mutable: " + lb.name))
            )
            (§ let Class primc = lb.getPrimitiveType())
            (§ call gen.loadThis())
            (§ if (primc != nil))
            (§
                (§ if (!(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive())))
                (§
                    (§ throw new IllegalArgumentException("Must assign primitive to primitive mutable: " + lb.name))
                )
                (§ let MaybePrimitiveExpr me = (MaybePrimitiveExpr) val)
                (§ call me.emitUnboxed(C.EXPRESSION, this, gen))
                (§ call gen.putField(objtype, lb.name, Type.getType(primc)))
            )
            (§ else )
            (§
                (§ call val.emit(C.EXPRESSION, this, gen))
                (§ call gen.putField(objtype, lb.name, OBJECT_TYPE))
            )
        )

        #_private
        (§ method void emitLocal(GeneratorAdapter gen, LocalBinding lb, boolean clear)
            (§ if (closes.containsKey(lb)))
            (§
                (§ let Class primc = lb.getPrimitiveType())
                (§ call gen.loadThis())
                (§ if (primc != nil))
                (§
                    (§ call gen.getField(objtype, lb.name, Type.getType(primc)))
                    (§ call HostExpr.emitBoxReturn(this, gen, primc))
                )
                (§ else )
                (§
                    (§ call gen.getField(objtype, lb.name, OBJECT_TYPE))
                    (§ if (onceOnly && clear && lb.canBeCleared))
                    (§
                        (§ call gen.loadThis())
                        (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                        (§ call gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
            )
            (§ else )
            (§
                (§ let int argoff = canBeDirect ? 0 :or 1)
                (§ let Class primc = lb.getPrimitiveType())
                (§ if (lb.isArg))
                (§
                    (§ call gen.loadArg(lb.idx-argoff))
                    (§ if (primc != nil))
                    (§
                        (§ call HostExpr.emitBoxReturn(this, gen, primc))
                    )
                    (§ elseif (clear && lb.canBeCleared))
                    (§
                        (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                        (§ call gen.storeArg(lb.idx - argoff))
                    )
                )
                (§ else )
                (§
                    (§ if (primc != nil))
                    (§
                        (§ call gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                        (§ call HostExpr.emitBoxReturn(this, gen, primc))
                    )
                    (§ else )
                    (§
                        (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx))
                        (§ if (clear && lb.canBeCleared))
                        (§
                            (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                            (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                        )
                    )
                )
            )
        )

        #_private
        (§ method void emitUnboxedLocal(GeneratorAdapter gen, LocalBinding lb)
            (§ let int argoff = canBeDirect ? 0 :or 1)
            (§ let Class primc = lb.getPrimitiveType())
            (§ if (closes.containsKey(lb)))
            (§
                (§ call gen.loadThis())
                (§ call gen.getField(objtype, lb.name, Type.getType(primc)))
            )
            (§ elseif (lb.isArg))
            (§
                (§ call gen.loadArg(lb.idx-argoff))
            )
            (§ else )
            (§
                (§ call gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
            )
        )

        #_public
        (§ method void emitVar(GeneratorAdapter gen, Var var)
            (§ let Integer i = (Integer) vars.valAt(var))
            (§ call emitConstant(gen, i))
        )

        #_final
        #_static
        (§ field Method varGetMethod = Method.getMethod("Object get()"))
        #_final
        #_static
        (§ field Method varGetRawMethod = Method.getMethod("Object getRawRoot()"))

        #_public
        (§ method void emitVarValue(GeneratorAdapter gen, Var v)
            (§ let Integer i = (Integer) vars.valAt(v))
            (§ if (!v.isDynamic()))
            (§
                (§ call emitConstant(gen, i))
                (§ call gen.invokeVirtual(VAR_TYPE, varGetRawMethod))
            )
            (§ else )
            (§
                (§ call emitConstant(gen, i))
                (§ call gen.invokeVirtual(VAR_TYPE, varGetMethod))
            )
        )

        #_public
        (§ method void emitKeyword(GeneratorAdapter gen, Keyword k)
            (§ let Integer i = (Integer) keywords.valAt(k))
            (§ call emitConstant(gen, i))
        )

        #_public
        (§ method void emitConstant(GeneratorAdapter gen, int id)
            (§ ass usedConstants = (IPersistentSet) usedConstants.cons(id))
            (§ call gen.getStatic(objtype, constantName(id), constantType(id)))
        )

        (§ method String constantName(int id)
            (§ return (§ expr CONST_PREFIX + id))
        )

        (§ method String siteName(int n)
            (§ return (§ expr "__site__" + n))
        )

        (§ method String siteNameStatic(int n)
            (§ return (§ expr siteName(n) + "__"))
        )

        (§ method String thunkName(int n)
            (§ return (§ expr "__thunk__" + n))
        )

        (§ method String cachedClassName(int n)
            (§ return (§ expr "__cached_class__" + n))
        )

        (§ method String cachedVarName(int n)
            (§ return (§ expr "__cached_var__" + n))
        )

        (§ method String varCallsiteName(int n)
            (§ return (§ expr "__var__callsite__" + n))
        )

        (§ method String thunkNameStatic(int n)
            (§ return (§ expr thunkName(n) + "__"))
        )

        (§ method Type constantType(int id)
            (§ let Object o = constants.nth(id))
            (§ let Class c = cloiure.lang.Util.classOf(o))
            (§ if (c!= nil && Modifier.isPublic(c.getModifiers())))
            (§
                ;; can't emit derived fn types due to visibility
                (§ if (LazySeq.class.isAssignableFrom(c)))
                (§
                    (§ return (§ expr Type.getType(ISeq.class)))
                )
                (§ elseif (c == Keyword.class))
                (§
                    (§ return (§ expr Type.getType(Keyword.class)))
                )
                (§ elseif (RestFn.class.isAssignableFrom(c)))
                (§
                    (§ return (§ expr Type.getType(RestFn.class)))
                )
                (§ elseif (AFn.class.isAssignableFrom(c)))
                (§
                    (§ return (§ expr Type.getType(AFn.class)))
                )
                (§ elseif (c == Var.class))
                (§
                    (§ return (§ expr Type.getType(Var.class)))
                )
                (§ elseif (c == String.class))
                (§
                    (§ return (§ expr Type.getType(String.class)))
                )
            )
            (§ return (§ expr OBJECT_TYPE))
        )
    )

    (§ enum PATHTYPE
        (§ item PATH),
        (§ item BRANCH)
    )

    #_static
    (class-ns PathNode
        #_final
        (§ field PATHTYPE type)
        #_final
        (§ field PathNode parent)

        (§ method PathNode(PATHTYPE type, PathNode parent)
            (§ ass this.type = type)
            (§ ass this.parent = parent)
        )
    )

    #_static
    (§ method PathNode clearPathRoot()
        (§ return (§ expr (PathNode) CLEAR_ROOT.get()))
    )

    (§ enum PSTATE
        (§ item REQ),
        (§ item REST),
        (§ item DONE)
    )

    #_public
    #_static
    (class-ns FnMethod (§ extends ObjMethod)
        ;; localbinding->localbinding
        (§ field PersistentVector reqParms = PersistentVector.EMPTY)
        (§ field LocalBinding restParm = nil)
        (§ field Type[] argtypes)
        (§ field Class[] argclasses)
        (§ field Class retClass)
        (§ field String prim)

        #_public
        (§ method FnMethod(ObjExpr objx, ObjMethod parent)
            (§ super(objx, parent))
        )

        #_static
        #_public
        (§ method char classChar(Object x)
            (§ let Class c = nil)
            (§ if (x instanceof Class))
            (§
                (§ ass c = (Class) x)
            )
            (§ elseif (x instanceof Symbol))
            (§
                (§ ass c = primClass((Symbol) x))
            )
            (§ if (c == nil || !c.isPrimitive()))
            (§
                (§ return (§ expr \O))
            )
            (§ if (c == long.class))
            (§
                (§ return (§ expr \L))
            )
            (§ if (c == double.class))
            (§
                (§ return (§ expr \D))
            )
            (§ throw new IllegalArgumentException("Only long and double primitives are supported"))
        )

        #_static
        #_public
        (§ method String primInterface(IPersistentVector arglist)
            (§ let StringBuilder sb = new StringBuilder())
            (§ for (int i = 0 i < arglist.count() i++))
            (§
                (§ call sb.append(classChar(tagOf(arglist.nth(i)))))
            )
            (§ call sb.append(classChar(tagOf(arglist))))
            (§ let String ret = sb.toString())
            (§ let boolean prim = ret.contains("L") || ret.contains("D"))
            (§ if (prim && arglist.count() > 4))
            (§
                (§ throw new IllegalArgumentException("fns taking primitives support only 4 or fewer args"))
            )
            (§ if (prim))
            (§
                (§ return (§ expr "cloiure.lang.IFn$" + ret))
            )
            (§ return (§ expr nil))
        )

        #_static
        (§ method FnMethod parse(ObjExpr objx, ISeq form, Object rettag)
            ;; ([args] body...)
            (§ let IPersistentVector parms = (IPersistentVector) RT.first(form))
            (§ let ISeq body = RT.next(form))
            (§ try )
            (§
                (§ let FnMethod method = new FnMethod(objx, (ObjMethod) METHOD.deref()))
                (§ ass method.line = lineDeref())
                (§ ass method.column = columnDeref())
                ;; register as the current method and set up a new env frame
                (§ let PathNode pnode =  (PathNode) CLEAR_PATH.get())
                (§ if (pnode == nil))
                (§
                    (§ ass pnode = new PathNode(PATHTYPE.PATH, nil))
                )
                (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map METHOD, method,
                      #_map LOCAL_ENV, LOCAL_ENV.deref(),
                      #_map LOOP_LOCALS, nil,
                      #_map NEXT_LOCAL_NUM, 0,
                      #_map CLEAR_PATH, pnode,
                      #_map CLEAR_ROOT, pnode,
                      #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                      #_map METHOD_RETURN_CONTEXT, RT.T
                )))

                (§ ass method.prim = primInterface(parms))
                (§ if (method.prim != nil))
                (§
                    (§ ass method.prim = method.prim.replace(\., \/))
                )

                (§ if (rettag instanceof String))
                (§
                    (§ ass rettag = Symbol.intern(nil, (String) rettag))
                )
                (§ if (!(rettag instanceof Symbol)))
                (§
                    (§ ass rettag = nil)
                )
                (§ if (rettag != nil))
                (§
                    (§ let String retstr = ((Symbol)rettag).getName())
                    (§ if (!(retstr.equals("long") || retstr.equals("double"))))
                    (§
                        (§ ass rettag = nil)
                    )
                )
                (§ ass method.retClass = tagClass((tagOf(parms) != nil) ? tagOf(parms) :or rettag))
                (§ if (method.retClass.isPrimitive()))
                (§
                    (§ if (!(method.retClass == double.class || method.retClass == long.class)))
                    (§
                        (§ throw new IllegalArgumentException("Only long and double primitives are supported"))
                    )
                )
                (§ else )
                (§
                    (§ ass method.retClass = Object.class)
                )
                ;; register 'this' as local 0
                (§ if (objx.thisName != nil))
                (§
                    (§ call registerLocal(Symbol.intern(objx.thisName), nil, nil, false))
                )
                (§ else )
                (§
                    (§ call getAndIncLocalNum())
                )
                (§ let PSTATE state = PSTATE.REQ)
                (§ let PersistentVector argLocals = PersistentVector.EMPTY)
                (§ let ArrayList<Type> argtypes = new ArrayList())
                (§ let ArrayList<Class> argclasses = new ArrayList())
                (§ for (int i = 0 i < parms.count() i++))
                (§
                    (§ if (!(parms.nth(i) instanceof Symbol)))
                    (§
                        (§ throw new IllegalArgumentException("fn params must be Symbols"))
                    )
                    (§ let Symbol p = (Symbol) parms.nth(i))
                    (§ if (p.getNamespace() != nil))
                    (§
                        (§ throw Util.runtimeException("Can't use qualified name as parameter: " + p))
                    )
                    (§ if (p.equals(_AMP_)))
                    (§
                        (§ if (state == PSTATE.REQ))
                        (§
                            (§ ass state = PSTATE.REST)
                        )
                        (§ else )
                        (§
                            (§ throw Util.runtimeException("Invalid parameter list"))
                        )
                    )
                    (§ else )
                    (§
                        (§ let Class pc = primClass(tagClass(tagOf(p))))
                        (§ if (pc.isPrimitive() && !(pc == double.class || pc == long.class)))
                        (§
                            (§ throw new IllegalArgumentException("Only long and double primitives are supported: " + p))
                        )

                        (§ if (state == PSTATE.REST && tagOf(p) != nil))
                        (§
                            (§ throw Util.runtimeException("& arg cannot have type hint"))
                        )
                        (§ if (state == PSTATE.REST && method.prim != nil))
                        (§
                            (§ throw Util.runtimeException("fns taking primitives cannot be variadic"))
                        )

                        (§ if (state == PSTATE.REST))
                        (§
                            (§ ass pc = ISeq.class)
                        )
                        (§ call argtypes.add(Type.getType(pc)))
                        (§ call argclasses.add(pc))
                        (§ let LocalBinding lb = pc.isPrimitive() ? registerLocal(p, nil, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), nil, true))
                        (§ ass argLocals = argLocals.cons(lb))
                        (§ switch (state))
                        (§
                            (§ case REQ)
                            (§
                                (§ ass method.reqParms = method.reqParms.cons(lb))
                                (§ break )
                            )
                            (§ case REST)
                            (§
                                (§ ass method.restParm = lb)
                                (§ ass state = PSTATE.DONE)
                                (§ break )
                            )
                            (§ default )
                            (§
                                (§ throw Util.runtimeException("Unexpected parameter"))
                            )
                        )
                    )
                )
                (§ if (method.reqParms.count() > MAX_POSITIONAL_ARITY))
                (§
                    (§ throw Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params"))
                )
                (§ call LOOP_LOCALS.set(argLocals))
                (§ ass method.argLocals = argLocals)
                (§ ass method.argtypes = argtypes.toArray(new Type[argtypes.size()]))
                (§ ass method.argclasses = argclasses.toArray(new Class[argtypes.size()]))
                (§ if (method.prim != nil))
                (§
                    (§ for (int i = 0 i < method.argclasses.length i++))
                    (§
                        (§ if (method.argclasses[i] == long.class || method.argclasses[i] == double.class))
                        (§
                            (§ call getAndIncLocalNum())
                        )
                    )
                )
                (§ ass method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                (§ return (§ expr method))
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )

        #_public
        (§ method void emit(ObjExpr fn, ClassVisitor cv)
            (§ if (fn.canBeDirect))
            (§
                (§ call doEmitStatic(fn, cv))
            )
            (§ elseif (prim != nil))
            (§
                (§ call doEmitPrim(fn, cv))
            )
            (§ else )
            (§
                (§ call doEmit(fn, cv))
            )
        )

        #_public
        (§ method void doEmitStatic(ObjExpr fn, ClassVisitor cv)
            (§ let Type returnType = Type.getType(retClass))

            (§ let Method ms = new Method("invokeStatic", returnType, argtypes))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
              #_arg ms,
              #_arg nil,
                    ;; todo don't hardwire this
              #_arg EXCEPTION_TYPES,
              #_arg cv))
            (§ call gen.visitCode())
            (§ let Label loopLabel = gen.mark())
            (§ call gen.visitLineNumber(line, loopLabel))
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                (§ call emitBody(objx, gen, retClass, body))

                (§ let Label end = gen.mark())
                (§ for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next()))
                (§
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (§ call gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )

            (§ call gen.returnValue())
            (§ call gen.endMethod())

            ;; generate the regular invoke, calling the static method
            (§ let Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))

            (§ ass gen = new GeneratorAdapter(ACC_PUBLIC,
              #_arg m,
              #_arg nil,
                    ;; todo don't hardwire this
              #_arg EXCEPTION_TYPES,
              #_arg cv))
            (§ call gen.visitCode())
            (§ for (int i = 0 i < argtypes.length i++))
            (§
                (§ call gen.loadArg(i))
                (§ call HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                (§ if (!argclasses[i].isPrimitive()))
                (§
                    (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                    (§ call gen.storeArg(i))
                )
            )
            (§ let Label callLabel = gen.mark())
            (§ call gen.visitLineNumber(line, callLabel))
            (§ call gen.invokeStatic(objx.objtype, ms))
            (§ call gen.box(returnType))

            (§ call gen.returnValue())
            (§ call gen.endMethod())

            ;; generate primInvoke if prim
            (§ if (prim != nil))
            (§
                (§ if (retClass == double.class || retClass == long.class))
                (§
                    (§ ass returnType = getReturnType())
                )
                (§ let else returnType = OBJECT_TYPE)

                (§ let Method pm = new Method("invokePrim", returnType, argtypes))

                (§ ass gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                  #_arg pm,
                  #_arg nil,
                        ;; todo don't hardwire this
                  #_arg EXCEPTION_TYPES,
                  #_arg cv))
                (§ call gen.visitCode())
                (§ for (int i = 0 i < argtypes.length i++))
                (§
                    (§ call gen.loadArg(i))
                    (§ if (!argclasses[i].isPrimitive()))
                    (§
                        (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                        (§ call gen.storeArg(i))
                    )
                )
                (§ call gen.invokeStatic(objx.objtype, ms))

                (§ call gen.returnValue())
                (§ call gen.endMethod())
            )
        )

        #_public
        (§ method void doEmitPrim(ObjExpr fn, ClassVisitor cv)
            (§ let Type returnType)
            (§ if (retClass == double.class || retClass == long.class))
            (§
                (§ ass returnType = getReturnType())
            )
            (§ else )
            (§
                (§ ass returnType = OBJECT_TYPE)
            )
            (§ let Method ms = new Method("invokePrim", returnType, argtypes))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
              #_arg ms,
              #_arg nil,
                    ;; todo don't hardwire this
              #_arg EXCEPTION_TYPES,
              #_arg cv))
            (§ call gen.visitCode())

            (§ let Label loopLabel = gen.mark())
            (§ call gen.visitLineNumber(line, loopLabel))
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                (§ call emitBody(objx, gen, retClass, body))

                (§ let Label end = gen.mark())
                (§ call gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                (§ for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next()))
                (§
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (§ call gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )

            (§ call gen.returnValue())
            (§ call gen.endMethod())

            ;; generate the regular invoke, calling the prim method
            (§ let Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))

            (§ ass gen = new GeneratorAdapter(ACC_PUBLIC,
              #_arg m,
              #_arg nil,
                    ;; todo don't hardwire this
              #_arg EXCEPTION_TYPES,
              #_arg cv))
            (§ call gen.visitCode())
            (§ call gen.loadThis())
            (§ for (int i = 0 i < argtypes.length i++))
            (§
                (§ call gen.loadArg(i))
                (§ call HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
            )
            (§ call gen.invokeInterface(Type.getType("L"+prim+";"), ms))
            (§ call gen.box(getReturnType()))

            (§ call gen.returnValue())
            (§ call gen.endMethod())
        )

        #_public
        (§ method void doEmit(ObjExpr fn, ClassVisitor cv)
            (§ let Method m = new Method(getMethodName(), getReturnType(), getArgTypes()))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
              #_arg m,
              #_arg nil,
                    ;; todo don't hardwire this
              #_arg EXCEPTION_TYPES,
              #_arg cv))
            (§ call gen.visitCode())

            (§ let Label loopLabel = gen.mark())
            (§ call gen.visitLineNumber(line, loopLabel))
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                (§ call body.emit(C.RETURN, fn, gen))
                (§ let Label end = gen.mark())

                (§ call gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                (§ for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next()))
                (§
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (§ call gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )

            (§ call gen.returnValue())
            (§ call gen.endMethod())
        )

        #_public
        #_final
        (§ method PersistentVector reqParms()
            (§ return (§ expr reqParms))
        )

        #_public
        #_final
        (§ method LocalBinding restParm()
            (§ return (§ expr restParm))
        )

        (§ method boolean isVariadic()
            (§ return (§ expr (restParm != nil)))
        )

        (§ method int numParams()
            (§ return (§ expr reqParms.count() + (isVariadic() ? 1 :or 0)))
        )

        (§ method String getMethodName()
            (§ return (§ expr isVariadic() ? "doInvoke" :or "invoke"))
        )

        (§ method Type getReturnType()
            (§ if (prim != nil)) ;; objx.isStatic
            (§
                (§ return (§ expr Type.getType(retClass)))
            )
            (§ return (§ expr OBJECT_TYPE))
        )

        (§ method Type[] getArgTypes()
            (§ if (isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY))
            (§
                (§ let Type[] ret = new Type[MAX_POSITIONAL_ARITY + 1])
                (§ for (int i = 0 i < MAX_POSITIONAL_ARITY + 1 i++))
                (§
                    (§ ass ret[i] = OBJECT_TYPE)
                )
                (§ return (§ expr ret))
            )
            (§ return (§ expr  ARG_TYPES[numParams()]))
        )

        (§ method void emitClearLocals(GeneratorAdapter gen)
        )
    )

    #_abstract
    #_public
    #_static
    (class-ns ObjMethod
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        #_public
        #_final
        (§ field ObjMethod parent)
        ;; localbinding->localbinding
        (§ field IPersistentMap locals = nil)
        ;; num->localbinding
        (§ field IPersistentMap indexlocals = nil)
        (§ field Expr body = nil)
        (§ field ObjExpr objx)
        (§ field PersistentVector argLocals)
        (§ field int maxLocal = 0)
        (§ field int line)
        (§ field int column)
        (§ field boolean usesThis = false)
        (§ field PersistentHashSet localsUsedInCatchFinally = PersistentHashSet.EMPTY)
        #_protected
        (§ field IPersistentMap methodMeta)

        #_public
        #_final
        (§ method IPersistentMap locals()
            (§ return (§ expr locals))
        )

        #_public
        #_final
        (§ method Expr body()
            (§ return (§ expr body))
        )

        #_public
        #_final
        (§ method ObjExpr objx()
            (§ return (§ expr objx))
        )

        #_public
        #_final
        (§ method PersistentVector argLocals()
            (§ return (§ expr argLocals))
        )

        #_public
        #_final
        (§ method int maxLocal()
            (§ return (§ expr maxLocal))
        )

        #_public
        #_final
        (§ method int line()
            (§ return (§ expr line))
        )

        #_public
        #_final
        (§ method int column()
            (§ return (§ expr column))
        )

        #_public
        (§ method ObjMethod(ObjExpr objx, ObjMethod parent)
            (§ ass this.parent = parent)
            (§ ass this.objx = objx)
        )

        #_static
        (§ method void emitBody(ObjExpr objx, GeneratorAdapter gen, Class retClass, Expr body)
            (§ let MaybePrimitiveExpr be = (MaybePrimitiveExpr) body)
            (§ if (Util.isPrimitive(retClass) && be.canEmitPrimitive()))
            (§
                (§ let Class bc = maybePrimitiveType(be))
                (§ if (bc == retClass))
                (§
                    (§ call be.emitUnboxed(C.RETURN, objx, gen))
                )
                (§ elseif (retClass == long.class && bc == int.class))
                (§
                    (§ call be.emitUnboxed(C.RETURN, objx, gen))
                    (§ call gen.visitInsn(I2L))
                )
                (§ elseif (retClass == double.class && bc == float.class))
                (§
                    (§ call be.emitUnboxed(C.RETURN, objx, gen))
                    (§ call gen.visitInsn(F2D))
                )
                (§ elseif (retClass == int.class && bc == long.class))
                (§
                    (§ call be.emitUnboxed(C.RETURN, objx, gen))
                    (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                )
                (§ elseif (retClass == float.class && bc == double.class))
                (§
                    (§ call be.emitUnboxed(C.RETURN, objx, gen))
                    (§ call gen.visitInsn(D2F))
                )
                (§ else )
                (§
                    (§ throw new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass()))
                )
            )
            (§ else )
            (§
                (§ call body.emit(C.RETURN, objx, gen))
                (§ if (retClass == void.class))
                (§
                    (§ call gen.pop())
                )
                (§ else )
                (§
                    (§ call gen.unbox(Type.getType(retClass)))
                )
            )
        )

        (§ abstract int numParams())
        (§ abstract String getMethodName())
        (§ abstract Type getReturnType())
        (§ abstract Type[] getArgTypes())

        #_public
        (§ method void emit(ObjExpr fn, ClassVisitor cv)
            (§ let Method m = new Method(getMethodName(), getReturnType(), getArgTypes()))

            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
              #_arg m,
              #_arg nil,
                    ;; todo don't hardwire this
              #_arg EXCEPTION_TYPES,
              #_arg cv))
            (§ call gen.visitCode())

            (§ let Label loopLabel = gen.mark())
            (§ call gen.visitLineNumber(line, loopLabel))
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                (§ call body.emit(C.RETURN, fn, gen))
                (§ let Label end = gen.mark())
                (§ call gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                (§ for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next()))
                (§
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (§ call gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )

            (§ call gen.returnValue())
            (§ call gen.endMethod())
        )

        (§ method void emitClearLocals(GeneratorAdapter gen)
        )

        (§ method void emitClearLocalsOld(GeneratorAdapter gen)
            (§ for (int i = 0 i < argLocals.count() i++))
            (§
                (§ let LocalBinding lb = (LocalBinding) argLocals.nth(i))
                (§ if (!localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == nil))
                (§
                    (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                    (§ call gen.storeArg(lb.idx - 1))
                )
            )
            (§ for (int i = numParams() + 1 i < maxLocal + 1 i++))
            (§
                (§ if (!localsUsedInCatchFinally.contains(i)))
                (§
                    (§ let LocalBinding b = (LocalBinding) RT.get(indexlocals, i))
                    (§ if (b == nil || maybePrimitiveType(b.init) == nil))
                    (§
                        (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                        (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i))
                    )
                )
            )
        )

        (§ method void emitClearThis(GeneratorAdapter gen)
            (§ call gen.visitInsn(Opcodes.ACONST_NULL))
            (§ call gen.visitVarInsn(Opcodes.ASTORE, 0))
        )
    )

    #_public
    #_static
    (class-ns LocalBinding
        #_public
        #_final
        (§ field Symbol sym)
        #_public
        #_final
        (§ field Symbol tag)
        #_public
        (§ field Expr init)
        (§ field int idx)
        #_public
        #_final
        (§ field String name)
        #_public
        #_final
        (§ field boolean isArg)
        #_public
        #_final
        (§ field PathNode clearPathRoot)
        #_public
        (§ field boolean canBeCleared = !RT.booleanCast(getCompilerOption(disableLocalsClearingKey)))
        #_public
        (§ field boolean recurMistmatch = false)
        #_public
        (§ field boolean used = false)

        #_public
        (§ method LocalBinding(int num, Symbol sym, Symbol tag, Expr init, boolean isArg, PathNode clearPathRoot)
            (§ if (maybePrimitiveType(init) != nil && tag != nil))
            (§
                (§ throw new UnsupportedOperationException("Can't type hint a local with a primitive initializer"))
            )
            (§ ass this.idx = num)
            (§ ass this.sym = sym)
            (§ ass this.tag = tag)
            (§ ass this.init = init)
            (§ ass this.isArg = isArg)
            (§ ass this.clearPathRoot = clearPathRoot)
            (§ ass name = munge(sym.name))
        )

        (§ field Boolean hjc)

        #_public
        (§ method boolean hasJavaClass()
            (§ if (hjc == nil))
            (§
                (§ if (init != nil && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr)))
                (§
                    (§ ass hjc =  false)
                )
                (§ else )
                (§
                    (§ ass hjc = (tag != nil || (init != nil && init.hasJavaClass())))
                )
            )
            (§ return (§ expr hjc))
        )

        (§ field Class jc)

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ ass jc = (tag != nil) ? HostExpr.tagToClass(tag) :or init.getJavaClass())
            )
            (§ return (§ expr jc))
        )

        #_public
        (§ method Class getPrimitiveType()
            (§ return (§ expr maybePrimitiveType(init)))
        )
    )

    #_public
    #_static
    (class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
        #_public
        #_final
        (§ field LocalBinding b)
        #_public
        #_final
        (§ field Symbol tag)

        #_public
        #_final
        (§ field PathNode clearPath)
        #_public
        #_final
        (§ field PathNode clearRoot)
        #_public
        (§ field boolean shouldClear = false)

        #_public
        (§ method LocalBindingExpr(LocalBinding b, Symbol tag)
            (§ if (b.getPrimitiveType() != nil && tag != nil))
            (§
                (§ throw new UnsupportedOperationException("Can't type hint a primitive local"))
            )
            (§ ass this.b = b)
            (§ ass this.tag = tag)

            (§ ass this.clearPath = (PathNode)CLEAR_PATH.get())
            (§ ass this.clearRoot = (PathNode)CLEAR_ROOT.get())
            (§ let IPersistentCollection sites = (IPersistentCollection) RT.get(CLEAR_SITES.get(), b))
            (§ ass b.used = true)

            (§ if (b.idx > 0))
            (§
                (§ if (sites != nil))
                (§
                    (§ for (ISeq s = sites.seq() s != nil s = s.next()))
                    (§
                        (§ let LocalBindingExpr o = (LocalBindingExpr) s.first())
                        (§ let PathNode common = commonPath(clearPath, o.clearPath))
                        (§ if (common != nil && common.type == PATHTYPE.PATH))
                        (§
                            (§ ass o.shouldClear = false)
                        )
                    )
                )

                (§ if (clearRoot == b.clearPathRoot))
                (§
                    (§ ass this.shouldClear = true)
                    (§ ass sites = RT.conj(sites, this))
                    (§ call CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites)))
                )
            )
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval locals"))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr (b.getPrimitiveType() != nil)))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call objx.emitUnboxedLocal(gen, b))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ if (context != C.STATEMENT))
            (§
                (§ call objx.emitLocal(gen, b, shouldClear))
            )
        )

        #_public
        (§ method Object evalAssign(Expr val)
            (§ throw new UnsupportedOperationException("Can't eval locals"))
        )

        #_public
        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (§ call objx.emitAssignLocal(gen, b, val))
            (§ if (context != C.STATEMENT))
            (§
                (§ call objx.emitLocal(gen, b, false))
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (tag != nil || b.hasJavaClass())))
        )

        (§ field Class jc)

        #_public
        (§ method Class getJavaClass()
            (§ if (jc == nil))
            (§
                (§ if (tag != nil))
                (§
                    (§ ass jc = HostExpr.tagToClass(tag))
                )
                (§ else )
                (§
                    (§ ass jc = b.getJavaClass())
                )
            )
            (§ return (§ expr jc))
        )
    )

    #_public
    #_static
    (class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field PersistentVector exprs)

        #_public
        #_final
        (§ method PersistentVector exprs()
            (§ return (§ expr exprs))
        )

        #_public
        (§ method BodyExpr(PersistentVector exprs)
            (§ ass this.exprs = exprs)
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frms)
                (§ let ISeq forms = (ISeq) frms)
                (§ if (Util.equals(RT.first(forms), DO)))
                (§
                    (§ ass forms = RT.next(forms))
                )
                (§ let PersistentVector exprs = PersistentVector.EMPTY)
                (§ for (  forms != nil forms = forms.next()))
                (§
                    (§ let Expr e = (context != C.EVAL && (context == C.STATEMENT || forms.next() != nil)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first()))
                    (§ ass exprs = exprs.cons(e))
                )
                (§ if (exprs.count() == 0))
                (§
                    (§ ass exprs = exprs.cons(NIL_EXPR))
                )
                (§ return (§ expr new BodyExpr(exprs)))
            )
        )

        #_public
        (§ method Object eval()
            (§ let Object ret = nil)
            (§ for (Object o :in exprs))
            (§
                (§ let Expr e = (Expr) o)
                (§ ass ret = e.eval())
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive())))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ for (int i = 0 i < exprs.count() - 1 i++))
            (§
                (§ let Expr e = (Expr) exprs.nth(i))
                (§ call e.emit(C.STATEMENT, objx, gen))
            )
            (§ let MaybePrimitiveExpr last = (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1))
            (§ call last.emitUnboxed(context, objx, gen))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ for (int i = 0 i < exprs.count() - 1 i++))
            (§
                (§ let Expr e = (Expr) exprs.nth(i))
                (§ call e.emit(C.STATEMENT, objx, gen))
            )
            (§ let Expr last = (Expr) exprs.nth(exprs.count() - 1))
            (§ call last.emit(context, objx, gen))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr lastExpr().hasJavaClass()))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr lastExpr().getJavaClass()))
        )

        #_private
        (§ method Expr lastExpr()
            (§ return (§ expr (Expr) exprs.nth(exprs.count() - 1)))
        )
    )

    #_public
    #_static
    (class-ns BindingInit
        (§ field LocalBinding binding)
        (§ field Expr init)

        #_public
        #_final
        (§ method LocalBinding binding()
            (§ return (§ expr binding))
        )

        #_public
        #_final
        (§ method Expr init()
            (§ return (§ expr init))
        )

        #_public
        (§ method BindingInit(LocalBinding binding, Expr init)
            (§ ass this.binding = binding)
            (§ ass this.init = init)
        )
    )

    #_public
    #_static
    (class-ns LetFnExpr (§ implements Expr)
        #_public
        #_final
        (§ field PersistentVector bindingInits)
        #_public
        #_final
        (§ field Expr body)

        #_public
        (§ method LetFnExpr(PersistentVector bindingInits, Expr body)
            (§ ass this.bindingInits = bindingInits)
            (§ ass this.body = body)
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (letfns* [var (fn [args] body) ...] body...)
                (§ if (!(RT.second(form) instanceof IPersistentVector)))
                (§
                    (§ throw new IllegalArgumentException("Bad binding form, expected vector"))
                )

                (§ let IPersistentVector bindings = (IPersistentVector) RT.second(form))
                (§ if ((bindings.count() % 2) != 0))
                (§
                    (§ throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs"))
                )

                (§ let ISeq body = RT.next(RT.next(form)))

                (§ if (context == C.EVAL))
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                (§ let IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))

                (§ try )
                (§
                    (§ call Var.pushThreadBindings(dynamicBindings))

                    ;; pre-seed env (like Lisp labels)
                    (§ let PersistentVector lbs = PersistentVector.EMPTY)
                    (§ for (int i = 0 i < bindings.count() i += 2))
                    (§
                        (§ if (!(bindings.nth(i) instanceof Symbol)))
                        (§
                            (§ throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i)))
                        )
                        (§ let Symbol sym = (Symbol) bindings.nth(i))
                        (§ if (sym.getNamespace() != nil))
                        (§
                            (§ throw Util.runtimeException("Can't let qualified name: " + sym))
                        )
                        (§ let LocalBinding lb = registerLocal(sym, tagOf(sym), nil, false))
                        (§ ass lb.canBeCleared = false)
                        (§ ass lbs = lbs.cons(lb))
                    )
                    (§ let PersistentVector bindingInits = PersistentVector.EMPTY)
                    (§ for (int i = 0 i < bindings.count() i += 2))
                    (§
                        (§ let Symbol sym = (Symbol) bindings.nth(i))
                        (§ let Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))
                        (§ let LocalBinding lb = (LocalBinding) lbs.nth(i / 2))
                        (§ ass lb.init = init)
                        (§ let BindingInit bi = new BindingInit(lb, init))
                        (§ ass bindingInits = bindingInits.cons(bi))
                    )
                    (§ return (§ expr new LetFnExpr(bindingInits, (new BodyExpr.Parser()).parse(context, body))))
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
            )
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval letfns"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ for (int i = 0 i < bindingInits.count() i++))
            (§
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (§ call gen.visitInsn(Opcodes.ACONST_NULL))
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
            )

            (§ let IPersistentSet lbset = PersistentHashSet.EMPTY)

            (§ for (int i = 0 i < bindingInits.count() i++))
            (§
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (§ ass lbset = (IPersistentSet) lbset.cons(bi.binding))
                (§ call bi.init.emit(C.EXPRESSION, objx, gen))
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
            )

            (§ for (int i = 0 i < bindingInits.count() i++))
            (§
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (§ let ObjExpr fe = (ObjExpr) bi.init)
                (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx))
                (§ call fe.emitLetFnInits(gen, objx, lbset))
            )

            (§ let Label loopLabel = gen.mark())

            (§ call body.emit(context, objx, gen))

            (§ let Label end = gen.mark())
            (§ for (ISeq bis = bindingInits.seq() bis != nil bis = bis.next()))
            (§
                (§ let BindingInit bi = (BindingInit) bis.first())
                (§ let String lname = bi.binding.name)
                (§ if (lname.endsWith("__auto__")))
                (§
                    (§ ass lname += RT.nextID())
                )
                (§ let Class primc = maybePrimitiveType(bi.init))
                (§ if (primc != nil))
                (§
                    (§ call gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, loopLabel, end, bi.binding.idx))
                )
                (§ else )
                (§
                    (§ call gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, loopLabel, end, bi.binding.idx))
                )
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr body.hasJavaClass()))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr body.getJavaClass()))
        )
    )

    #_public
    #_static
    (class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
        #_public
        #_final
        (§ field PersistentVector bindingInits)
        #_public
        #_final
        (§ field Expr body)
        #_public
        #_final
        (§ field boolean isLoop)

        #_public
        (§ method LetExpr(PersistentVector bindingInits, Expr body, boolean isLoop)
            (§ ass this.bindingInits = bindingInits)
            (§ ass this.body = body)
            (§ ass this.isLoop = isLoop)
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                ;; (let [var val var2 val2 ...] body...)
                (§ let boolean isLoop = RT.first(form).equals(LOOP))
                (§ if (!(RT.second(form) instanceof IPersistentVector)))
                (§
                    (§ throw new IllegalArgumentException("Bad binding form, expected vector"))
                )

                (§ let IPersistentVector bindings = (IPersistentVector) RT.second(form))
                (§ if ((bindings.count() % 2) != 0))
                (§
                    (§ throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs"))
                )

                (§ let ISeq body = RT.next(RT.next(form)))

                (§ if (context == C.EVAL || (context == C.EXPRESSION && isLoop)))
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                (§ let ObjMethod method = (ObjMethod) METHOD.deref())
                (§ let IPersistentMap backupMethodLocals = method.locals)
                (§ let IPersistentMap backupMethodIndexLocals = method.indexlocals)
                (§ let IPersistentVector recurMismatches = PersistentVector.EMPTY)
                (§ for (int i = 0 i < bindings.count() / 2 i++))
                (§
                    (§ ass recurMismatches = recurMismatches.cons(RT.F))
                )

                ;; may repeat once for each binding with a mismatch, return breaks
                (§ while (true))
                (§
                    (§ let IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))
                    (§ ass method.locals = backupMethodLocals)
                    (§ ass method.indexlocals = backupMethodIndexLocals)

                    (§ let PathNode looproot = new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))
                    (§ let PathNode clearroot = new PathNode(PATHTYPE.PATH, looproot))
                    (§ let PathNode clearpath = new PathNode(PATHTYPE.PATH, looproot))
                    (§ if (isLoop))
                    (§
                        (§ ass dynamicBindings = dynamicBindings.assoc(LOOP_LOCALS, nil))
                    )

                    (§ try )
                    (§
                        (§ call Var.pushThreadBindings(dynamicBindings))

                        (§ let PersistentVector bindingInits = PersistentVector.EMPTY)
                        (§ let PersistentVector loopLocals = PersistentVector.EMPTY)
                        (§ for (int i = 0 i < bindings.count() i += 2))
                        (§
                            (§ if (!(bindings.nth(i) instanceof Symbol)))
                            (§
                                (§ throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i)))
                            )
                            (§ let Symbol sym = (Symbol) bindings.nth(i))
                            (§ if (sym.getNamespace() != nil))
                            (§
                                (§ throw Util.runtimeException("Can't let qualified name: " + sym))
                            )
                            (§ let Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))
                            (§ if (isLoop))
                            (§
                                (§ if (recurMismatches != nil && RT.booleanCast(recurMismatches.nth(i / 2))))
                                (§
                                    (§ ass init = new StaticMethodExpr("", 0, 0, nil, RT.class, "box", RT.vector(init), false))
                                    (§ if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
                                    (§
                                        (§ call RT.errPrintWriter().println("Auto-boxing loop arg: " + sym))
                                    )
                                )
                                (§ elseif (maybePrimitiveType(init) == int.class))
                                (§
                                    (§ ass init = new StaticMethodExpr("", 0, 0, nil, RT.class, "longCast", RT.vector(init), false))
                                )
                                (§ elseif (maybePrimitiveType(init) == float.class))
                                (§
                                    (§ ass init = new StaticMethodExpr("", 0, 0, nil, RT.class, "doubleCast", RT.vector(init), false))
                                )
                            )
                            ;; sequential enhancement of env (like Lisp let*)
                            (§ try )
                            (§
                                (§ if (isLoop))
                                (§
                                    (§ call Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, nil)))
                                )
                                (§ let LocalBinding lb = registerLocal(sym, tagOf(sym), init, false))
                                (§ let BindingInit bi = new BindingInit(lb, init))
                                (§ ass bindingInits = bindingInits.cons(bi))
                                (§ if (isLoop))
                                (§
                                    (§ ass loopLocals = loopLocals.cons(lb))
                                )
                            )
                            (§ finally )
                            (§
                                (§ if (isLoop))
                                (§
                                    (§ call Var.popThreadBindings())
                                )
                            )
                        )
                        (§ if (isLoop))
                        (§
                            (§ call LOOP_LOCALS.set(loopLocals))
                        )
                        (§ let Expr bodyExpr)
                        (§ let boolean moreMismatches = false)
                        (§ try )
                        (§
                            (§ if (isLoop))
                            (§
                                (§ let Object methodReturnContext = (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil)
                                (§ call Var.pushThreadBindings(RT.map(
                                      #_map CLEAR_PATH, clearpath,
                                      #_map CLEAR_ROOT, clearroot,
                                      #_map NO_RECUR, nil,
                                      #_map METHOD_RETURN_CONTEXT, methodReturnContext
                                )))
                            )
                            (§ ass bodyExpr = (new BodyExpr.Parser()).parse(isLoop ? C.RETURN :or context, body))
                        )
                        (§ finally )
                        (§
                            (§ if (isLoop))
                            (§
                                (§ call Var.popThreadBindings())
                                (§ for (int i = 0 i < loopLocals.count() i++))
                                (§
                                    (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                                    (§ if (lb.recurMistmatch))
                                    (§
                                        (§ ass recurMismatches = (IPersistentVector)recurMismatches.assoc(i, RT.T))
                                        (§ ass moreMismatches = true)
                                    )
                                )
                            )
                        )
                        (§ if (!moreMismatches))
                        (§
                            (§ return (§ expr new LetExpr(bindingInits, bodyExpr, isLoop)))
                        )
                    )
                    (§ finally )
                    (§
                        (§ call Var.popThreadBindings())
                    )
                )
            )
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval let/loop"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call doEmit(context, objx, gen, false))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call doEmit(context, objx, gen, true))
        )

        #_public
        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (§ let HashMap<BindingInit, Label> bindingLabels = new HashMap())
            (§ for (int i = 0 i < bindingInits.count() i++))
            (§
                (§ let BindingInit bi = (BindingInit) bindingInits.nth(i))
                (§ let Class primc = maybePrimitiveType(bi.init))
                (§ if (primc != nil))
                (§
                    ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen)
                    (§ call gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx))
                )
                (§ else )
                (§
                    (§ call bi.init.emit(C.EXPRESSION, objx, gen))
                    (§ if (!bi.binding.used && bi.binding.canBeCleared))
                    (§
                        (§ call gen.pop())
                    )
                    (§ else )
                    (§
                        (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                    )
                )
                (§ call bindingLabels.put(bi, gen.mark()))
            )
            (§ let Label loopLabel = gen.mark())
            (§ if (isLoop))
            (§
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel)))
                    (§ if (emitUnboxed))
                    (§
                        ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen)
                    )
                    (§ else )
                    (§
                        (§ call body.emit(context, objx, gen))
                    )
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
            )
            (§ else )
            (§
                (§ if (emitUnboxed))
                (§
                    ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen)
                )
                (§ else )
                (§
                    (§ call body.emit(context, objx, gen))
                )
            )
            (§ let Label end = gen.mark())
            (§ for (ISeq bis = bindingInits.seq() bis != nil bis = bis.next()))
            (§
                (§ let BindingInit bi = (BindingInit) bis.first())
                (§ let String lname = bi.binding.name)
                (§ if (lname.endsWith("__auto__")))
                (§
                    (§ ass lname += RT.nextID())
                )
                (§ let Class primc = maybePrimitiveType(bi.init))
                (§ if (primc != nil))
                (§
                    (§ call gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, bindingLabels.get(bi), end, bi.binding.idx))
                )
                (§ else )
                (§
                    (§ call gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, bindingLabels.get(bi), end, bi.binding.idx))
                )
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr body.hasJavaClass()))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr body.getJavaClass()))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive())))
        )
    )

    #_public
    #_static
    (class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
        #_public
        #_final
        (§ field IPersistentVector args)
        #_public
        #_final
        (§ field IPersistentVector loopLocals)

        #_final
        (§ field int line)
        #_final
        (§ field int column)
        #_final
        (§ field String source)

        #_public
        (§ method RecurExpr(IPersistentVector loopLocals, IPersistentVector args, int line, int column, String source)
            (§ ass this.loopLocals = loopLocals)
            (§ ass this.args = args)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ ass this.source = source)
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval recur"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ let Label loopLabel = (Label) LOOP_LABEL.deref())
            (§ if (loopLabel == nil))
            (§
                (§ throw new IllegalStateException())
            )
            (§ for (int i = 0 i < loopLocals.count() i++))
            (§
                (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                (§ let Expr arg = (Expr) args.nth(i))
                (§ if (lb.getPrimitiveType() != nil))
                (§
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ let final Class pc = maybePrimitiveType(arg))
                    (§ if (pc == primc))
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    (§ elseif (primc == long.class && pc == int.class))
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        (§ call gen.visitInsn(I2L))
                    )
                    (§ elseif (primc == double.class && pc == float.class))
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        (§ call gen.visitInsn(F2D))
                    )
                    (§ elseif (primc == int.class && pc == long.class))
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        (§ call gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                    )
                    (§ elseif (primc == float.class && pc == double.class))
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        (§ call gen.visitInsn(D2F))
                    )
                    (§ else )
                    (§
                        (§ throw new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName()))
                    )
                )
                (§ else )
                (§
                    (§ call arg.emit(C.EXPRESSION, objx, gen))
                )
            )

            (§ for (int i = loopLocals.count() - 1 i >= 0 i--))
            (§
                (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                (§ let Class primc = lb.getPrimitiveType())
                (§ if (lb.isArg))
                (§
                    (§ call gen.storeArg(lb.idx - (objx.canBeDirect ? 0 :or 1)))
                )
                (§ else )
                (§
                    (§ if (primc != nil))
                    (§
                        (§ call gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx))
                    )
                    (§ else )
                    (§
                        (§ call gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                    )
                )
            )

            (§ call gen.goTo(loopLabel))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr true))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr RECUR_CLASS))
        )

        #_static
        (class-ns Parser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let int line = lineDeref())
                (§ let int column = columnDeref())
                (§ let String source = (String) SOURCE.deref())

                (§ let ISeq form = (ISeq) frm)
                (§ let IPersistentVector loopLocals = (IPersistentVector) LOOP_LOCALS.deref())
                (§ if (context != C.RETURN || loopLocals == nil))
                (§
                    (§ throw new UnsupportedOperationException("Can only recur from tail position"))
                )
                (§ if (NO_RECUR.deref() != nil))
                (§
                    (§ throw new UnsupportedOperationException("Cannot recur across try"))
                )
                (§ let PersistentVector args = PersistentVector.EMPTY)
                (§ for (ISeq s = RT.seq(form.next()) s != nil s = s.next()))
                (§
                    (§ ass args = args.cons(analyze(C.EXPRESSION, s.first())))
                )
                (§ if (args.count() != loopLocals.count()))
                (§
                    (§ throw new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count())))
                )
                (§ for (int i = 0 i < loopLocals.count() i++))
                (§
                    (§ let LocalBinding lb = (LocalBinding) loopLocals.nth(i))
                    (§ let Class primc = lb.getPrimitiveType())
                    (§ if (primc != nil))
                    (§
                        (§ let boolean mismatch = false)
                        (§ let final Class pc = maybePrimitiveType((Expr) args.nth(i)))
                        (§ if (primc == long.class))
                        (§
                            (§ if (!(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class)))
                            (§
                                (§ ass mismatch = true)
                            )
                        )
                        (§ elseif (primc == double.class))
                        (§
                            (§ if (!(pc == double.class || pc == float.class)))
                            (§
                                (§ ass mismatch = true)
                            )
                        )
                        (§ if (mismatch))
                        (§
                            (§ ass lb.recurMistmatch = true)
                            (§ if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
                            (§
                                (§ call RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + ((pc != nil) ? pc.getName() :or "Object") + ", needed: " + primc.getName()))
                            )
                        )
                    )
                )
                (§ return (§ expr new RecurExpr(loopLocals, args, line, column, source)))
            )
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr true))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call emit(context, objx, gen))
        )
    )

    #_private
    #_static
    (§ method LocalBinding registerLocal(Symbol sym, Symbol tag, Expr init, boolean isArg)
        (§ let int num = getAndIncLocalNum())
        (§ let LocalBinding b = new LocalBinding(num, sym, tag, init, isArg, clearPathRoot()))
        (§ let IPersistentMap localsMap = (IPersistentMap) LOCAL_ENV.deref())
        (§ call LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b)))
        (§ let ObjMethod method = (ObjMethod) METHOD.deref())
        (§ ass method.locals = (IPersistentMap) RT.assoc(method.locals, b, b))
        (§ ass method.indexlocals = (IPersistentMap) RT.assoc(method.indexlocals, num, b))
        (§ return (§ expr b))
    )

    #_private
    #_static
    (§ method int getAndIncLocalNum()
        (§ let int num = ((Number) NEXT_LOCAL_NUM.deref()).intValue())
        (§ let ObjMethod m = (ObjMethod) METHOD.deref())
        (§ if (num > m.maxLocal))
        (§
            (§ ass m.maxLocal = num)
        )
        (§ call NEXT_LOCAL_NUM.set(num + 1))
        (§ return (§ expr num))
    )

    #_public
    #_static
    (§ method Expr analyze(C context, Object form)
        (§ return (§ expr analyze(context, form, nil)))
    )

    #_private
    #_static
    (§ method Expr analyze(C context, Object form, String name)
        ;; todo symbol macro expansion?
        (§ try )
        (§
            (§ if (form instanceof LazySeq))
            (§
                (§ let Object mform = form)
                (§ ass form = RT.seq(form))
                (§ if (form == nil))
                (§
                    (§ ass form = PersistentList.EMPTY)
                )
                (§ ass form = ((IObj)form).withMeta(RT.meta(mform)))
            )
            (§ if (form == nil))
            (§
                (§ return (§ expr NIL_EXPR))
            )
            (§ elseif (form == Boolean.TRUE))
            (§
                (§ return (§ expr TRUE_EXPR))
            )
            (§ elseif (form == Boolean.FALSE))
            (§
                (§ return (§ expr FALSE_EXPR))
            )
            (§ let Class fclass = form.getClass())
            (§ if (fclass == Symbol.class))
            (§
                (§ return (§ expr analyzeSymbol((Symbol) form)))
            )
            (§ elseif (fclass == Keyword.class))
            (§
                (§ return (§ expr registerKeyword((Keyword) form)))
            )
            (§ elseif (form instanceof Number))
            (§
                (§ return (§ expr NumberExpr.parse((Number) form)))
            )
            (§ elseif (fclass == String.class))
            (§
                (§ return (§ expr new StringExpr(((String) form).intern())))
            )
            (§ elseif (form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0))
            (§
                (§ let Expr ret = new EmptyExpr(form))
                (§ if (RT.meta(form) != nil))
                (§
                    (§ ass ret = new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                )
                (§ return (§ expr ret))
            )
            (§ elseif (form instanceof ISeq))
            (§
                (§ return (§ expr analyzeSeq(context, (ISeq) form, name)))
            )
            (§ elseif (form instanceof IPersistentVector))
            (§
                (§ return (§ expr VectorExpr.parse(context, (IPersistentVector) form)))
            )
            (§ elseif (form instanceof IRecord))
            (§
                (§ return (§ expr new ConstantExpr(form)))
            )
            (§ elseif (form instanceof IType))
            (§
                (§ return (§ expr new ConstantExpr(form)))
            )
            (§ elseif (form instanceof IPersistentMap))
            (§
                (§ return (§ expr MapExpr.parse(context, (IPersistentMap) form)))
            )
            (§ elseif (form instanceof IPersistentSet))
            (§
                (§ return (§ expr SetExpr.parse(context, (IPersistentSet) form)))
            )

            (§ return (§ expr new ConstantExpr(form)))
        )
        (§ catch (Throwable e))
        (§
            (§ if (!(e instanceof CompilerException)))
            (§
                (§ throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e))
            )
            (§ else )
            (§
                (§ throw (CompilerException) e)
            )
        )
    )

    #_static
    #_public
    (class-ns CompilerException (§ extends RuntimeException)
        #_final
        #_public
        (§ field String source)

        #_final
        #_public
        (§ field int line)

        #_public
        (§ method CompilerException(String source, int line, int column, Throwable cause)
            (§ super(errorMsg(source, line, column, cause.toString()), cause))
            (§ ass this.source = source)
            (§ ass this.line = line)
        )

        #_public
        (§ method String toString()
            (§ return (§ expr getMessage()))
        )
    )

    #_static
    #_public
    (§ method Var isMacro(Object op)
        ;; no local macros for now
        (§ if (op instanceof Symbol && referenceLocal((Symbol) op) != nil))
        (§
            (§ return (§ expr nil))
        )
        (§ if (op instanceof Symbol || op instanceof Var))
        (§
            (§ let Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false))
            (§ if (v != nil && v.isMacro()))
            (§
                (§ if (v.ns != currentNS() && !v.isPublic()))
                (§
                    (§ throw new IllegalStateException("var: " + v + " is not public"))
                )
                (§ return (§ expr v))
            )
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method IFn isInline(Object op, int arity)
        ;; no local inlines for now
        (§ if (op instanceof Symbol && referenceLocal((Symbol) op) != nil))
        (§
            (§ return (§ expr nil))
        )
        (§ if (op instanceof Symbol || op instanceof Var))
        (§
            (§ let Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false))
            (§ if (v != nil))
            (§
                (§ if (v.ns != currentNS() && !v.isPublic()))
                (§
                    (§ throw new IllegalStateException("var: " + v + " is not public"))
                )
                (§ let IFn ret = (IFn) RT.get(v.meta(), inlineKey))
                (§ if (ret != nil))
                (§
                    (§ let IFn arityPred = (IFn) RT.get(v.meta(), inlineAritiesKey))
                    (§ if (arityPred == nil || RT.booleanCast(arityPred.invoke(arity))))
                    (§
                        (§ return (§ expr ret))
                    )
                )
            )
        )
        (§ return (§ expr nil))
    )

    #_public
    #_static
    (§ method boolean namesStaticMember(Symbol sym)
        (§ return (§ expr (sym.ns != nil && namespaceFor(sym) == nil)))
    )

    #_public
    #_static
    (§ method Object preserveTag(ISeq src, Object dst)
        (§ let Symbol tag = tagOf(src))
        (§ if (tag != nil && dst instanceof IObj))
        (§
            (§ let IPersistentMap meta = RT.meta(dst))
            (§ return (§ expr ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))))
        )
        (§ return (§ expr dst))
    )

    #_private
    #_static
    #_volatile
    (§ field Var MACRO_CHECK = nil)
    #_private
    #_static
    #_volatile
    (§ field boolean MACRO_CHECK_LOADING = false)
    #_private
    #_static
    #_final
    (§ field Object MACRO_CHECK_LOCK = new Object())

    #_private
    #_static
    (§ method Var ensureMacroCheck() (§ throws ClassNotFoundException, IOException)
        (§ if (MACRO_CHECK == nil))
        (§
            (§ synchronized (MACRO_CHECK_LOCK))
            (§
                (§ if (MACRO_CHECK == nil))
                (§
                    (§ ass MACRO_CHECK_LOADING = true)
                    (§ call RT.load("cloiure/spec/alpha"))
                    (§ call RT.load("cloiure/core/specs/alpha"))
                    (§ ass MACRO_CHECK = Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check")))
                    (§ ass MACRO_CHECK_LOADING = false)
                )
            )
        )
        (§ return (§ expr MACRO_CHECK))
    )

    #_public
    #_static
    (§ method void checkSpecs(Var v, ISeq form)
        (§ if (RT.CHECK_SPECS && !MACRO_CHECK_LOADING))
        (§
            (§ try )
            (§
                (§ call ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next()))))
            )
            (§ catch (Exception e))
            (§
                (§ throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e))
            )
        )
    )

    #_public
    #_static
    (§ method Object macroexpand1(Object x)
        (§ if (x instanceof ISeq))
        (§
            (§ let ISeq form = (ISeq) x)
            (§ let Object op = RT.first(form))
            (§ if (isSpecial(op)))
            (§
                (§ return (§ expr x))
            )
            ;; macro expansion
            (§ let Var v = isMacro(op))
            (§ if (v != nil))
            (§
                (§ call checkSpecs(v, form))

                (§ try )
                (§
                    (§ let ISeq args = RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next())))
                    (§ return (§ expr v.applyTo(args)))
                )
                (§ catch (ArityException e))
                (§
                    ;; hide the 2 extra params for a macro
                    (§ throw new ArityException(e.actual - 2, e.name))
                )
            )
            (§ else )
            (§
                (§ if (op instanceof Symbol))
                (§
                    (§ let Symbol sym = (Symbol) op)
                    (§ let String sname = sym.name)
                    ;; (.substring s 2 5) => (. s substring 2 5)
                    (§ if (sym.name.charAt(0) == \.))
                    (§
                        (§ if (RT.length(form) < 2))
                        (§
                            (§ throw new IllegalArgumentException("Malformed member expression, expecting (.member target ...)"))
                        )
                        (§ let Symbol meth = Symbol.intern(sname.substring(1)))
                        (§ let Object target = RT.second(form))
                        (§ if (HostExpr.maybeClass(target, false) != nil))
                        (§
                            (§ ass target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS)))
                        )
                        (§ return (§ expr preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))))
                    )
                    (§ elseif (namesStaticMember(sym)))
                    (§
                        (§ let Symbol target = Symbol.intern(sym.ns))
                        (§ let Class c = HostExpr.maybeClass(target, false))
                        (§ if (c != nil))
                        (§
                            (§ let Symbol meth = Symbol.intern(sym.name))
                            (§ return (§ expr preserveTag(form, RT.listStar(DOT, target, meth, form.next()))))
                        )
                    )
                    (§ else )
                    (§
                        ;; (s.substring 2 5) => (. s substring 2 5)
                        ;; also (package.class.name ...) (. package.class name ...)
                        (§ let int idx = sname.lastIndexOf(\.))
                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                        (§ if (idx == sname.length() - 1))
                        (§
                            (§ return (§ expr RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())))
                        )
                    )
                )
            )
        )
        (§ return (§ expr x))
    )

    #_static
    (§ method Object macroexpand(Object form)
        (§ let Object exf = macroexpand1(form))
        (§ if (exf != form))
        (§
            (§ return (§ expr macroexpand(exf)))
        )
        (§ return (§ expr form))
    )

    #_private
    #_static
    (§ method Expr analyzeSeq(C context, ISeq form, String name)
        (§ let Object line = lineDeref())
        (§ let Object column = columnDeref())
        (§ if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY)))
        (§
            (§ ass line = RT.meta(form).valAt(RT.LINE_KEY))
        )
        (§ if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY)))
        (§
            (§ ass column = RT.meta(form).valAt(RT.COLUMN_KEY))
        )
        (§ call Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
        (§ try )
        (§
            (§ let Object me = macroexpand1(form))
            (§ if (me != form))
            (§
                (§ return (§ expr analyze(context, me, name)))
            )

            (§ let Object op = RT.first(form))
            (§ if (op == nil))
            (§
                (§ throw new IllegalArgumentException("Can't call nil, form: " + form))
            )
            (§ let IFn inline = isInline(op, RT.count(RT.next(form))))
            (§ if (inline != nil))
            (§
                (§ return (§ expr analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))))
            )
            (§ let IParser p)
            (§ if (op.equals(FN)))
            (§
                (§ return (§ expr FnExpr.parse(context, form, name)))
            )
            (§ elseif ((p = (IParser) specials.valAt(op)) != nil))
            (§
                (§ return (§ expr p.parse(context, form)))
            )
            (§ else )
            (§
                (§ return (§ expr InvokeExpr.parse(context, form)))
            )
        )
        (§ catch (Throwable e))
        (§
            (§ if (!(e instanceof CompilerException)))
            (§
                (§ throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e))
            )
            (§ else )
            (§
                (§ throw (CompilerException) e)
            )
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
        )
    )

    #_static
    (§ method String errorMsg(String source, int line, int column, String s)
        (§ return (§ expr String.format("%s, compiling:(%s:%d:%d)", s, source, line, column)))
    )

    #_public
    #_static
    (§ method Object eval(Object form)
        (§ return (§ expr eval(form, true)))
    )

    #_public
    #_static
    (§ method Object eval(Object form, boolean freshLoader)
        (§ let boolean createdLoader = false)
        (§ if (true)) ;; !LOADER.isBound()
        (§
            (§ call Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader())))
            (§ ass createdLoader = true)
        )
        (§ try )
        (§
            (§ let Object line = lineDeref())
            (§ let Object column = columnDeref())
            (§ if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY)))
            (§
                (§ ass line = RT.meta(form).valAt(RT.LINE_KEY))
            )
            (§ if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY)))
            (§
                (§ ass column = RT.meta(form).valAt(RT.COLUMN_KEY))
            )
            (§ call Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
            (§ try )
            (§
                (§ ass form = macroexpand(form))
                (§ if (form instanceof ISeq && Util.equals(RT.first(form), DO)))
                (§
                    (§ let ISeq s = RT.next(form))
                    (§ for (  RT.next(s) != nil s = RT.next(s)))
                    (§
                        (§ call eval(RT.first(s), false))
                    )
                    (§ return (§ expr eval(RT.first(s), false)))
                )
                (§ elseif ((form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def")))))
                (§
                    (§ let ObjExpr fexpr = (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID()))
                    (§ let IFn fn = (IFn) fexpr.eval())
                    (§ return (§ expr fn.invoke()))
                )
                (§ else )
                (§
                    (§ let Expr expr = analyze(C.EVAL, form))
                    (§ return (§ expr expr.eval()))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )
        (§ finally )
        (§
            (§ if (createdLoader))
            (§
                (§ call Var.popThreadBindings())
            )
        )
    )

    #_private
    #_static
    (§ method int registerConstant(Object o)
        (§ if (!CONSTANTS.isBound()))
        (§
            (§ return (§ expr -1))
        )
        (§ let PersistentVector v = (PersistentVector) CONSTANTS.deref())
        (§ let IdentityHashMap<Object, Integer> ids = (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref())
        (§ let Integer i = ids.get(o))
        (§ if (i != nil))
        (§
            (§ return (§ expr i))
        )
        (§ call CONSTANTS.set(RT.conj(v, o)))
        (§ call ids.put(o, v.count()))
        (§ return (§ expr v.count()))
    )

    #_private
    #_static
    (§ method KeywordExpr registerKeyword(Keyword keyword)
        (§ if (!KEYWORDS.isBound()))
        (§
            (§ return (§ expr new KeywordExpr(keyword)))
        )

        (§ let IPersistentMap keywordsMap = (IPersistentMap) KEYWORDS.deref())
        (§ let Object id = RT.get(keywordsMap, keyword))
        (§ if (id == nil))
        (§
            (§ call KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword))))
        )
        (§ return (§ expr new KeywordExpr(keyword)))
    )

    #_private
    #_static
    (§ method int registerKeywordCallsite(Keyword keyword)
        (§ if (!KEYWORD_CALLSITES.isBound()))
        (§
            (§ throw new IllegalAccessError("KEYWORD_CALLSITES is not bound"))
        )

        (§ let IPersistentVector keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())

        (§ ass keywordCallsites = keywordCallsites.cons(keyword))
        (§ call KEYWORD_CALLSITES.set(keywordCallsites))
        (§ return (§ expr keywordCallsites.count() - 1))
    )

    #_private
    #_static
    (§ method int registerProtocolCallsite(Var v)
        (§ if (!PROTOCOL_CALLSITES.isBound()))
        (§
            (§ throw new IllegalAccessError("PROTOCOL_CALLSITES is not bound"))
        )

        (§ let IPersistentVector protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())

        (§ ass protocolCallsites = protocolCallsites.cons(v))
        (§ call PROTOCOL_CALLSITES.set(protocolCallsites))
        (§ return (§ expr protocolCallsites.count() - 1))
    )

    #_private
    #_static
    (§ method void registerVarCallsite(Var v)
        (§ if (!VAR_CALLSITES.isBound()))
        (§
            (§ throw new IllegalAccessError("VAR_CALLSITES is not bound"))
        )

        (§ let IPersistentCollection varCallsites = (IPersistentCollection) VAR_CALLSITES.deref())

        (§ ass varCallsites = varCallsites.cons(v))
        (§ call VAR_CALLSITES.set(varCallsites))
    )

    #_static
    (§ method ISeq fwdPath(PathNode p1)
        (§ let ISeq ret = nil)
        (§ for (  p1 != nil p1 = p1.parent))
        (§
            (§ ass ret = RT.cons(p1, ret))
        )
        (§ return (§ expr ret))
    )

    #_static
    (§ method PathNode commonPath(PathNode n1, PathNode n2)
        (§ let ISeq xp = fwdPath(n1))
        (§ let ISeq yp = fwdPath(n2))
        (§ if (RT.first(xp) != RT.first(yp)))
        (§
            (§ return (§ expr nil))
        )
        (§ while (RT.second(xp) != nil && RT.second(xp) == RT.second(yp)))
        (§
            (§ ass xp = xp.next())
            (§ ass yp = yp.next())
        )
        (§ return (§ expr (PathNode) RT.first(xp)))
    )

    #_static
    (§ method void addAnnotation(Object visitor, IPersistentMap meta)
        (§ if (meta != nil && ADD_ANNOTATIONS.isBound()))
        (§
            (§ call ADD_ANNOTATIONS.invoke(visitor, meta))
        )
    )

    #_static
    (§ method void addParameterAnnotation(Object visitor, IPersistentMap meta, int i)
        (§ if (meta != nil && ADD_ANNOTATIONS.isBound()))
        (§
            (§ call ADD_ANNOTATIONS.invoke(visitor, meta, i))
        )
    )

    #_private
    #_static
    (§ method Expr analyzeSymbol(Symbol sym)
        (§ let Symbol tag = tagOf(sym))
        (§ if (sym.ns == nil)) ;; ns-qualified syms are always Vars
        (§
            (§ let LocalBinding b = referenceLocal(sym))
            (§ if (b != nil))
            (§
                (§ return (§ expr new LocalBindingExpr(b, tag)))
            )
        )
        (§ elseif (namespaceFor(sym) == nil))
        (§
            (§ let Symbol nsSym = Symbol.intern(sym.ns))
            (§ let Class c = HostExpr.maybeClass(nsSym, false))
            (§ if (c != nil))
            (§
                (§ if (Reflector.getField(c, sym.name, true) != nil))
                (§
                    (§ return (§ expr new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)))
                )
                (§ throw Util.runtimeException("Unable to find static field: " + sym.name + " in " + c))
            )
        )
        (§ let Object o = resolve(sym))
        (§ if (o instanceof Var))
        (§
            (§ let Var v = (Var) o)
            (§ if (isMacro(v) != nil))
            (§
                (§ throw Util.runtimeException("Can't take value of a macro: " + v))
            )
            (§ if (RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY))))
            (§
                (§ return (§ expr analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))))
            )
            (§ call registerVar(v))
            (§ return (§ expr new VarExpr(v, tag)))
        )
        (§ elseif (o instanceof Class))
        (§
            (§ return (§ expr new ConstantExpr(o)))
        )
        (§ elseif (o instanceof Symbol))
        (§
            (§ return (§ expr new UnresolvedVarExpr((Symbol) o)))
        )

        (§ throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context"))
    )

    #_static
    (§ method String destubClassName(String className)
        ;; skip over prefix + '.' or '/'
        (§ if (className.startsWith(COMPILE_STUB_PREFIX)))
        (§
            (§ return (§ expr className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        (§ return (§ expr className))
    )

    #_static
    (§ method Type getType(Class c)
        (§ let String descriptor = Type.getType(c).getDescriptor())
        (§ if (descriptor.startsWith("L")))
        (§
            (§ ass descriptor = "L" + destubClassName(descriptor.substring(1)))
        )
        (§ return (§ expr Type.getType(descriptor)))
    )

    #_static
    (§ method Object resolve(Symbol sym, boolean allowPrivate)
        (§ return (§ expr resolveIn(currentNS(), sym, allowPrivate)))
    )

    #_static
    (§ method Object resolve(Symbol sym)
        (§ return (§ expr resolveIn(currentNS(), sym, false)))
    )

    #_static
    (§ method Namespace namespaceFor(Symbol sym)
        (§ return (§ expr namespaceFor(currentNS(), sym)))
    )

    #_static
    (§ method Namespace namespaceFor(Namespace inns, Symbol sym)
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (§ let Symbol nsSym = Symbol.intern(sym.ns))
        (§ let Namespace ns = inns.lookupAlias(nsSym))
        (§ if (ns == nil))
        (§
            ;; ...otherwise check the Namespaces map.
            (§ ass ns = Namespace.find(nsSym))
        )
        (§ return (§ expr ns))
    )

    #_static
    #_public
    (§ method Object resolveIn(Namespace n, Symbol sym, boolean allowPrivate)
        ;; note - ns-qualified vars must already exist
        (§ if (sym.ns != nil))
        (§
            (§ let Namespace ns = namespaceFor(n, sym))
            (§ if (ns == nil))
            (§
                (§ throw Util.runtimeException("No such namespace: " + sym.ns))
            )

            (§ let Var v = ns.findInternedVar(Symbol.intern(sym.name)))
            (§ if (v == nil))
            (§
                (§ throw Util.runtimeException("No such var: " + sym))
            )
            (§ elseif (v.ns != currentNS() && !v.isPublic() && !allowPrivate))
            (§
                (§ throw new IllegalStateException("var: " + sym + " is not public"))
            )
            (§ return (§ expr v))
        )
        (§ elseif (sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[))
        (§
            (§ return (§ expr RT.classForName(sym.name)))
        )
        (§ elseif (sym.equals(NS)))
        (§
            (§ return (§ expr RT.NS_VAR))
        )
        (§ elseif (sym.equals(IN_NS)))
        (§
            (§ return (§ expr RT.IN_NS_VAR))
        )
        (§ else )
        (§
            (§ if (Util.equals(sym, COMPILE_STUB_SYM.get())))
            (§
                (§ return (§ expr COMPILE_STUB_CLASS.get()))
            )
            (§ let Object o = n.getMapping(sym))
            (§ if (o == nil))
            (§
                (§ if (RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref())))
                (§
                    (§ return (§ expr sym))
                )
                (§ else )
                (§
                    (§ throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context"))
                )
            )
            (§ return (§ expr o))
        )
    )

    #_static
    #_public
    (§ method Object maybeResolveIn(Namespace n, Symbol sym)
        ;; note - ns-qualified vars must already exist
        (§ if (sym.ns != nil))
        (§
            (§ let Namespace ns = namespaceFor(n, sym))
            (§ if (ns == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let Var v = ns.findInternedVar(Symbol.intern(sym.name)))
            (§ if (v == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr v))
        )
        (§ elseif (sym.name.indexOf(\.) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == \[))
        (§
            (§ return (§ expr RT.classForName(sym.name)))
        )
        (§ elseif (sym.equals(NS)))
        (§
            (§ return (§ expr RT.NS_VAR))
        )
        (§ elseif (sym.equals(IN_NS)))
        (§
            (§ return (§ expr RT.IN_NS_VAR))
        )
        (§ else )
        (§
            (§ let Object o = n.getMapping(sym))
            (§ return (§ expr o))
        )
    )

    #_static
    (§ method Var lookupVar(Symbol sym, boolean internNew, boolean registerMacro)
        (§ let Var var = nil)

        ;; note - ns-qualified vars in other namespaces must already exist
        (§ if (sym.ns != nil))
        (§
            (§ let Namespace ns = namespaceFor(sym))
            (§ if (ns == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let Symbol name = Symbol.intern(sym.name))
            (§ if (internNew && ns == currentNS()))
            (§
                (§ ass var = currentNS().intern(name))
            )
            (§ else )
            (§
                (§ ass var = ns.findInternedVar(name))
            )
        )
        (§ elseif (sym.equals(NS)))
        (§
            (§ ass var = RT.NS_VAR)
        )
        (§ elseif (sym.equals(IN_NS)))
        (§
            (§ ass var = RT.IN_NS_VAR)
        )
        (§ else )
        (§
            ;; is it mapped?
            (§ let Object o = currentNS().getMapping(sym))
            (§ if (o == nil))
            (§
                ;; introduce a new var in the current ns
                (§ if (internNew))
                (§
                    (§ ass var = currentNS().intern(Symbol.intern(sym.name)))
                )
            )
            (§ elseif (o instanceof Var))
            (§
                (§ ass var = (Var) o)
            )
            (§ else )
            (§
                (§ throw Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o))
            )
        )
        (§ if (var != nil && (!var.isMacro() || registerMacro)))
        (§
            (§ call registerVar(var))
        )
        (§ return (§ expr var))
    )

    #_static
    (§ method Var lookupVar(Symbol sym, boolean internNew)
        (§ return (§ expr lookupVar(sym, internNew, true)))
    )

    #_private
    #_static
    (§ method void registerVar(Var var)
        (§ if (!VARS.isBound()))
        (§
            (§ return (§ expr ))
        )
        (§ let IPersistentMap varsMap = (IPersistentMap) VARS.deref())
        (§ let Object id = RT.get(varsMap, var))
        (§ if (id == nil))
        (§
            (§ call VARS.set(RT.assoc(varsMap, var, registerConstant(var))))
        )
    )

    #_static
    (§ method Namespace currentNS()
        (§ return (§ expr (Namespace) RT.CURRENT_NS.deref()))
    )

    #_static
    (§ method void closeOver(LocalBinding b, ObjMethod method)
        (§ if (b != nil && method != nil))
        (§
            (§ let LocalBinding lb = (LocalBinding) RT.get(method.locals, b))
            (§ if (lb == nil))
            (§
                (§ ass method.objx.closes = (IPersistentMap) RT.assoc(method.objx.closes, b, b))
                (§ call closeOver(b, method.parent))
            )
            (§ else )
            (§
                (§ if (lb.idx == 0))
                (§
                    (§ ass method.usesThis = true)
                )
                (§ if (IN_CATCH_FINALLY.deref() != nil))
                (§
                    (§ ass method.localsUsedInCatchFinally = (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx))
                )
            )
        )
    )

    #_static
    (§ method LocalBinding referenceLocal(Symbol sym)
        (§ if (!LOCAL_ENV.isBound()))
        (§
            (§ return (§ expr nil))
        )
        (§ let LocalBinding b = (LocalBinding) RT.get(LOCAL_ENV.deref(), sym))
        (§ if (b != nil))
        (§
            (§ let ObjMethod method = (ObjMethod) METHOD.deref())
            (§ if (b.idx == 0))
            (§
                (§ ass method.usesThis = true)
            )
            (§ call closeOver(b, method))
        )
        (§ return (§ expr b))
    )

    #_private
    #_static
    (§ method Symbol tagOf(Object o)
        (§ let Object tag = RT.get(RT.meta(o), RT.TAG_KEY))
        (§ if (tag instanceof Symbol))
        (§
            (§ return (§ expr (Symbol) tag))
        )
        (§ elseif (tag instanceof String))
        (§
            (§ return (§ expr Symbol.intern(nil, (String) tag)))
        )
        (§ return (§ expr nil))
    )

    #_public
    #_static
    (§ method Object loadFile(String file) (§ throws IOException)
        (§ let FileInputStream f = new FileInputStream(file))
        (§ try )
        (§
            (§ return (§ expr load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName())))
        )
        (§ finally )
        (§
            (§ call f.close())
        )
    )

    #_public
    #_static
    (§ method Object load(Reader rdr)
        (§ return (§ expr load(rdr, nil, "NO_SOURCE_FILE")))
    )

    #_static
    (§ method void consumeWhitespaces(LineNumberingPushbackReader pushbackReader)
        (§ let int ch = LispReader.read1(pushbackReader))
        (§ while (LispReader.isWhitespace(ch)))
        (§
            (§ ass ch = LispReader.read1(pushbackReader))
        )
        (§ call LispReader.unread(pushbackReader, ch))
    )

    #_private
    #_static
    #_final
    (§ field Object OPTS_COND_ALLOWED = RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW))

    #_private
    #_static
    (§ method Object readerOpts(String sourceName)
        (§ if (sourceName != nil && sourceName.endsWith(".clic")))
        (§
            (§ return (§ expr OPTS_COND_ALLOWED))
        )
        (§ else )
        (§
            (§ return (§ expr nil))
        )
    )

    #_public
    #_static
    (§ method Object load(Reader rdr, String sourcePath, String sourceName)
        (§ let Object EOF = new Object())
        (§ let Object ret = nil)
        (§ let LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))
        (§ call consumeWhitespaces(pushbackReader))
        (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map LOADER, RT.makeClassLoader(),
              #_map SOURCE_PATH, sourcePath,
              #_map SOURCE, sourceName,
              #_map METHOD, nil,
              #_map LOCAL_ENV, nil,
              #_map LOOP_LOCALS, nil,
              #_map NEXT_LOCAL_NUM, 0,
              #_map RT.READEVAL, RT.T,
              #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
              #_map LINE_BEFORE, pushbackReader.getLineNumber(),
              #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
              #_map LINE_AFTER, pushbackReader.getLineNumber(),
              #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
              #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
              #_map RT.DATA_READERS, RT.DATA_READERS.deref()
        )))

        (§ let Object readerOpts = readerOpts(sourceName))
        (§ try )
        (§
            (§ for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts) r != EOF r = LispReader.read(pushbackReader, false, EOF, false, readerOpts)))
            (§
                (§ call consumeWhitespaces(pushbackReader))
                (§ call LINE_AFTER.set(pushbackReader.getLineNumber()))
                (§ call COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                (§ ass ret = eval(r, false))
                (§ call LINE_BEFORE.set(pushbackReader.getLineNumber()))
                (§ call COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
            )
        )
        (§ catch (LispReader.ReaderException e))
        (§
            (§ throw new CompilerException(sourcePath, e.line, e.column, e.getCause()))
        )
        (§ catch (Throwable e))
        (§
            (§ if (!(e instanceof CompilerException)))
            (§
                (§ throw new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e))
            )
            (§ else )
            (§
                (§ throw (CompilerException) e)
            )
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method void writeClassFile(String internalName, byte[] bytecode) (§ throws IOException)
        (§ let String genPath = (String) COMPILE_PATH.deref())
        (§ if (genPath == nil))
        (§
            (§ throw Util.runtimeException("*compile-path* not set"))
        )
        (§ let String[] dirs = internalName.split("/"))
        (§ let String p = genPath)
        (§ for (int i = 0 i < dirs.length - 1 i++))
        (§
            (§ ass p += File.separator + dirs[i])
            (new File(p)).mkdir()
        )
        (§ let String path = genPath + File.separator + internalName + ".class")
        (§ let File cf = new File(path))
        (§ call cf.createNewFile())
        (§ let FileOutputStream cfs = new FileOutputStream(cf))
        (§ try )
        (§
            (§ call cfs.write(bytecode))
            (§ call cfs.flush())
        )
        (§ finally )
        (§
            (§ call cfs.close())
        )
    )

    #_public
    #_static
    (§ method void pushNS()
        (§ call Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil)))
    )

    #_public
    #_static
    (§ method void pushNSandLoader(ClassLoader loader)
        (§ call Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T)))
    )

    #_public
    #_static
    (§ method ILookupThunk getLookupThunk(Object target, Keyword k)
        (§ return (§ expr nil))
    )

    #_static
    (§ method void compile1(GeneratorAdapter gen, ObjExpr objx, Object form)
        (§ let Object line = lineDeref())
        (§ let Object column = columnDeref())
        (§ if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY)))
        (§
            (§ ass line = RT.meta(form).valAt(RT.LINE_KEY))
        )
        (§ if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY)))
        (§
            (§ ass column = RT.meta(form).valAt(RT.COLUMN_KEY))
        )
        (§ call Var.pushThreadBindings(RT.map(
              #_map LINE, line, COLUMN, column,
              #_map LOADER, RT.makeClassLoader()
        )))
        (§ try )
        (§
            (§ ass form = macroexpand(form))
            (§ if (form instanceof ISeq && Util.equals(RT.first(form), DO)))
            (§
                (§ for (ISeq s = RT.next(form) s != nil s = RT.next(s)))
                (§
                    (§ call compile1(gen, objx, RT.first(s)))
                )
            )
            (§ else )
            (§
                (§ let Expr expr = analyze(C.EVAL, form))
                (§ ass objx.keywords = (IPersistentMap) KEYWORDS.deref())
                (§ ass objx.vars = (IPersistentMap) VARS.deref())
                (§ ass objx.constants = (PersistentVector) CONSTANTS.deref())
                (§ call expr.emit(C.EXPRESSION, objx, gen))
                (§ call expr.eval())
            )
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
        )
    )

    #_public
    #_static
    (§ method Object compile(Reader rdr, String sourcePath, String sourceName) (§ throws IOException)
        (§ if (COMPILE_PATH.deref() == nil))
        (§
            (§ throw Util.runtimeException("*compile-path* not set"))
        )

        (§ let Object EOF = new Object())
        (§ let Object ret = nil)
        (§ let LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))
        (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map SOURCE_PATH, sourcePath,
              #_map SOURCE, sourceName,
              #_map METHOD, nil,
              #_map LOCAL_ENV, nil,
              #_map LOOP_LOCALS, nil,
              #_map NEXT_LOCAL_NUM, 0,
              #_map RT.READEVAL, RT.T,
              #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
              #_map LINE_BEFORE, pushbackReader.getLineNumber(),
              #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
              #_map LINE_AFTER, pushbackReader.getLineNumber(),
              #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
              #_map CONSTANTS, PersistentVector.EMPTY,
              #_map CONSTANT_IDS, new IdentityHashMap(),
              #_map KEYWORDS, PersistentHashMap.EMPTY,
              #_map VARS, PersistentHashMap.EMPTY,
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
              #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
              #_map RT.DATA_READERS, RT.DATA_READERS.deref()
        )))

        (§ try )
        (§
            ;; generate loader class
            (§ let ObjExpr objx = new ObjExpr(nil))
            (§ ass objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf(\.)) + RT.LOADER_SUFFIX)

            (§ ass objx.objtype = Type.getObjectType(objx.internalName))
            (§ let ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS))
            (§ let ClassVisitor cv = cw)
            (§ call cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, nil, "java/lang/Object", nil))

            ;; static load method
            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), nil, nil, cv))
            (§ call gen.visitCode())

            (§ let Object readerOpts = readerOpts(sourceName))
            (§ for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts) r != EOF r = LispReader.read(pushbackReader, false, EOF, false, readerOpts)))
            (§
                (§ call LINE_AFTER.set(pushbackReader.getLineNumber()))
                (§ call COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                (§ call compile1(gen, objx, r))
                (§ call LINE_BEFORE.set(pushbackReader.getLineNumber()))
                (§ call COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
            )
            ;; end of load
            (§ call gen.returnValue())
            (§ call gen.endMethod())

            ;; static fields for constants
            (§ for (int i = 0 i < objx.constants.count() i++))
            (§
                (§ if (objx.usedConstants.contains(i)))
                (§
                    (§ call cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), nil, nil))
                )
            )

            (§ let final int INITS_PER = 100)
            (§ let int numInits =  objx.constants.count() / INITS_PER)
            (§ if (objx.constants.count() % INITS_PER != 0))
            (§
                (§ ass ++numInits)
            )

            (§ for (int n = 0 n < numInits n++))
            (§
                (§ let GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), nil, nil, cv))
                (§ call clinitgen.visitCode())
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                    (§ for (int i = n * INITS_PER i < objx.constants.count() && i < (n + 1) * INITS_PER i++))
                    (§
                        (§ if (objx.usedConstants.contains(i)))
                        (§
                            (§ call objx.emitValue(objx.constants.nth(i), clinitgen))
                            (§ call clinitgen.checkCast(objx.constantType(i)))
                            (§ call clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i)))
                        )
                    )
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
                (§ call clinitgen.returnValue())
                (§ call clinitgen.endMethod())
            )

            ;; static init for constants, keywords and vars
            (§ let GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))
            (§ call clinitgen.visitCode())
            (§ let Label startTry = clinitgen.newLabel())
            (§ let Label endTry = clinitgen.newLabel())
            (§ let Label end = clinitgen.newLabel())
            (§ let Label finallyLabel = clinitgen.newLabel())

            (§ for (int n = 0 n < numInits n++))
            (§
                (§ call clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()")))
            )

            (§ call clinitgen.push(objx.internalName.replace(\/, \.)))
            (§ call clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
            (§ call clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()")))
            (§ call clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)")))
            (§ call clinitgen.mark(startTry))
            (§ call clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()")))
            (§ call clinitgen.mark(endTry))
            (§ call clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
            (§ call clinitgen.goTo(end))

            (§ call clinitgen.mark(finallyLabel))
            ;; exception should be on stack
            (§ call clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
            (§ call clinitgen.throwException())
            (§ call clinitgen.mark(end))
            (§ call clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))

            ;; end of static init
            (§ call clinitgen.returnValue())
            (§ call clinitgen.endMethod())

            ;; end of class
            (§ call cv.visitEnd())

            (§ call writeClassFile(objx.internalName, cw.toByteArray()))
        )
        (§ catch (LispReader.ReaderException e))
        (§
            (§ throw new CompilerException(sourcePath, e.line, e.column, e.getCause()))
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (class-ns NewInstanceExpr (§ extends ObjExpr)
        (§ field IPersistentCollection methods)

        (§ field Map<IPersistentVector, java.lang.reflect.Method> mmap)
        (§ field Map<IPersistentVector, Set<Class>> covariants)

        #_public
        (§ method NewInstanceExpr(Object tag)
            (§ super(tag))
        )

        #_static
        (class-ns DeftypeParser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, final Object frm)
                (§ let ISeq rform = (ISeq) frm)
                ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                (§ ass rform = RT.next(rform))
                (§ let String tagname = ((Symbol) rform.first()).getName())
                (§ ass rform = rform.next())
                (§ let Symbol classname = (Symbol) rform.first())
                (§ ass rform = rform.next())
                (§ let IPersistentVector fields = (IPersistentVector) rform.first())
                (§ ass rform = rform.next())
                (§ let IPersistentMap opts = PersistentHashMap.EMPTY)
                (§ while (rform != nil && rform.first() instanceof Keyword))
                (§
                    (§ ass opts = opts.assoc(rform.first(), RT.second(rform)))
                    (§ ass rform = rform.next().next())
                )

                (§ let ObjExpr ret = build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, nil, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts))
                (§ return (§ expr ret))
            )
        )

        #_static
        (class-ns ReifyParser (§ implements IParser)
            #_public
            (§ method Expr parse(C context, Object frm)
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                (§ let ISeq form = (ISeq) frm)
                (§ let ObjMethod enclosingMethod = (ObjMethod) METHOD.deref())
                (§ let String basename = (enclosingMethod != nil) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$"))
                (§ let String simpleName = "reify__" + RT.nextID())
                (§ let String classname = basename + simpleName)

                (§ let ISeq rform = RT.next(form))

                (§ let IPersistentVector interfaces = ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj")))

                (§ ass rform = RT.next(rform))

                (§ let ObjExpr ret = build(interfaces, nil, nil, classname, Symbol.intern(classname), nil, rform, frm, nil))
                (§ if (frm instanceof IObj && ((IObj) frm).meta() != nil))
                (§
                    (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta()))))
                )
                (§ else )
                (§
                    (§ return (§ expr ret))
                )
            )
        )

        #_static
        (§ method ObjExpr build(IPersistentVector interfaceSyms, IPersistentVector fieldSyms, Symbol thisSym, String tagName, Symbol className, Symbol typeTag, ISeq methodForms, Object frm, IPersistentMap opts)
            (§ let NewInstanceExpr ret = new NewInstanceExpr(nil))

            (§ ass ret.src = frm)
            (§ ass ret.name = className.toString())
            (§ ass ret.classMeta = RT.meta(className))
            (§ ass ret.internalName = ret.name.replace(\., \/))
            (§ ass ret.objtype = Type.getObjectType(ret.internalName))
            (§ ass ret.opts = opts)

            (§ if (thisSym != nil))
            (§
                (§ ass ret.thisName = thisSym.name)
            )

            (§ if (fieldSyms != nil))
            (§
                (§ let IPersistentMap fmap = PersistentHashMap.EMPTY)
                (§ let Object[] closesvec = new Object[2 * fieldSyms.count()])
                (§ for (int i = 0 i < fieldSyms.count() i++))
                (§
                    (§ let Symbol sym = (Symbol) fieldSyms.nth(i))
                    (§ let LocalBinding lb = new LocalBinding(-1, sym, nil, new MethodParamExpr(tagClass(tagOf(sym))), false, nil))
                    (§ ass fmap = fmap.assoc(sym, lb))
                    (§ ass closesvec[i * 2] = lb)
                    (§ ass closesvec[i * 2 + 1] = lb)
                )

                ;; todo - inject __meta et al into closes - when?
                ;; use array map to preserve ctor order
                (§ ass ret.closes = new PersistentArrayMap(closesvec))
                (§ ass ret.fields = fmap)
                (§ for (int i = fieldSyms.count() - 1 i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq")) --i))
                (§
                    (§ ass ret.altCtorDrops++)
                )
            )

            (§ let PersistentVector interfaces = PersistentVector.EMPTY)
            (§ for (ISeq s = RT.seq(interfaceSyms) s != nil s = s.next()))
            (§
                (§ let Class c = (Class) resolve((Symbol) s.first()))
                (§ if (!c.isInterface()))
                (§
                    (§ throw new IllegalArgumentException("only interfaces are supported, had: " + c.getName()))
                )
                (§ ass interfaces = interfaces.cons(c))
            )
            (§ let Class superClass = Object.class)
            (§ let Map[] mc = gatherMethods(superClass, RT.seq(interfaces)))
            (§ let Map overrideables = mc[0])
            (§ let Map covariants = mc[1])
            (§ ass ret.mmap = overrideables)
            (§ ass ret.covariants = covariants)

            (§ let String[] inames = interfaceNames(interfaces))

            (§ let Class stub = compileStub(slashname(superClass), ret, inames, frm))
            (§ let Symbol thistag = Symbol.intern(nil, stub.getName()))

            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map CONSTANTS, PersistentVector.EMPTY,
                      #_map CONSTANT_IDS, new IdentityHashMap(),
                      #_map KEYWORDS, PersistentHashMap.EMPTY,
                      #_map VARS, PersistentHashMap.EMPTY,
                      #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                      #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                      #_map VAR_CALLSITES, emptyVarCallSites(),
                      #_map NO_RECUR, nil
                )))
                (§ if (ret.isDeftype()))
                (§
                    (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
                          #_map METHOD, nil,
                          #_map LOCAL_ENV, ret.fields,
                          #_map COMPILE_STUB_SYM, Symbol.intern(nil, tagName),
                          #_map COMPILE_STUB_CLASS, stub
                    )))

                    (§ ass ret.hintedFields = RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops))
                )

                ;; now (methodname [args] body)*
                (§ ass ret.line = lineDeref())
                (§ ass ret.column = columnDeref())
                (§ let IPersistentCollection methods = nil)
                (§ for (ISeq s = methodForms s != nil s = RT.next(s)))
                (§
                    (§ let NewInstanceMethod m = NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables))
                    (§ ass methods = RT.conj(methods, m))
                )

                (§ ass ret.methods = methods)
                (§ ass ret.keywords = (IPersistentMap) KEYWORDS.deref())
                (§ ass ret.vars = (IPersistentMap) VARS.deref())
                (§ ass ret.constants = (PersistentVector) CONSTANTS.deref())
                (§ ass ret.constantsID = RT.nextID())
                (§ ass ret.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                (§ ass ret.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                (§ ass ret.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())
            )
            (§ finally )
            (§
                (§ if (ret.isDeftype()))
                (§
                    (§ call Var.popThreadBindings())
                )
                (§ call Var.popThreadBindings())
            )

            (§ try )
            (§
                (§ call ret.compile(slashname(superClass), inames, false))
            )
            (§ catch (IOException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ call ret.getCompiledClass())
            (§ return (§ expr ret))
        )

        ;;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;;
        #_static
        (§ method Class compileStub(String superName, NewInstanceExpr ret, String[] interfaceNames, Object frm)
            (§ let ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS))
            (§ let ClassVisitor cv = cw)
            (§ call cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, nil, superName, interfaceNames))

            ;; instance fields for closed-overs
            (§ for (ISeq s = RT.keys(ret.closes) s != nil s = s.next()))
            (§
                (§ let LocalBinding lb = (LocalBinding) s.first())
                (§ let int access = ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL))
                (§ if (lb.getPrimitiveType() != nil))
                (§
                    (§ call cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                )
                (§ else )
                (§
                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                    (§ call cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                )
            )

            ;; ctor that takes closed-overs and does nothing
            (§ let Method m = new Method("<init>", Type.VOID_TYPE, ret.ctorTypes()))
            (§ let GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))
            (§ call ctorgen.visitCode())
            (§ call ctorgen.loadThis())
            (§ call ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))
            (§ call ctorgen.returnValue())
            (§ call ctorgen.endMethod())

            (§ if (ret.altCtorDrops > 0))
            (§
                (§ let Type[] ctorTypes = ret.ctorTypes())
                (§ let Type[] altCtorTypes = new Type[ctorTypes.length-ret.altCtorDrops])
                (§ for (int i = 0 i < altCtorTypes.length i++))
                (§
                    (§ ass altCtorTypes[i] = ctorTypes[i])
                )
                (§ let Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (§ ass ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (§ call ctorgen.visitCode())
                (§ call ctorgen.loadThis())
                (§ call ctorgen.loadArgs())

                (§ call ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                (§ call ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (§ call ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (§ call ctorgen.returnValue())
                (§ call ctorgen.endMethod())

                ;; alt ctor no __hash, __hasheq
                (§ ass altCtorTypes = new Type[ctorTypes.length-2])
                (§ for (int i = 0 i < altCtorTypes.length i++))
                (§
                    (§ ass altCtorTypes[i] = ctorTypes[i])
                )

                (§ ass alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                (§ ass ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                (§ call ctorgen.visitCode())
                (§ call ctorgen.loadThis())
                (§ call ctorgen.loadArgs())

                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                (§ call ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                (§ call ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                (§ call ctorgen.returnValue())
                (§ call ctorgen.endMethod())
            )
            ;; end of class
            (§ call cv.visitEnd())

            (§ let byte[] bytecode = cw.toByteArray())
            (§ let DynamicClassLoader loader = (DynamicClassLoader) LOADER.deref())
            (§ return (§ expr loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm)))
        )

        #_static
        (§ method String[] interfaceNames(IPersistentVector interfaces)
            (§ let int icnt = interfaces.count())
            (§ let String[] inames = (icnt > 0) ? new String[icnt] :or nil)
            (§ for (int i = 0 i < icnt i++))
            (§
                (§ ass inames[i] = slashname((Class) interfaces.nth(i)))
            )
            (§ return (§ expr inames))
        )

        #_static
        (§ method String slashname(Class c)
            (§ return (§ expr c.getName().replace(\., \/)))
        )

        #_protected
        (§ method void emitStatics(ClassVisitor cv)
            (§ if (this.isDeftype()))
            (§
                ;; getBasis()
                (§ let Method meth = Method.getMethod("cloiure.lang.IPersistentVector getBasis()"))
                (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, nil, nil, cv))
                (§ call emitValue(hintedFields, gen))
                (§ call gen.returnValue())
                (§ call gen.endMethod())

                (§ if (this.isDeftype() && this.fields.count() > this.hintedFields.count()))
                (§
                    ;; create(IPersistentMap)
                    (§ let String className = name.replace(\., \/))
                    (§ let int i = 1)
                    (§ let int fieldCount = hintedFields.count())

                    (§ let MethodVisitor mv = cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", nil, nil))
                    (§ call mv.visitCode())

                    (§ for (ISeq s = RT.seq(hintedFields) s != nil s = s.next(), i++))
                    (§
                        (§ let String bName = ((Symbol)s.first()).name)
                        (§ let Class k = tagClass(tagOf(s.first())))

                        (§ call mv.visitVarInsn(ALOAD, 0))
                        (§ call mv.visitLdcInsn(bName))
                        (§ call mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                        (§ call mv.visitInsn(ACONST_NULL))
                        (§ call mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                        (§ if (k.isPrimitive()))
                        (§
                            (§ call mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName()))
                        )
                        (§ call mv.visitVarInsn(ASTORE, i))
                        (§ call mv.visitVarInsn(ALOAD, 0))
                        (§ call mv.visitLdcInsn(bName))
                        (§ call mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                        (§ call mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                        (§ call mv.visitVarInsn(ASTORE, 0))
                    )

                    (§ call mv.visitTypeInsn(Opcodes.NEW, className))
                    (§ call mv.visitInsn(DUP))

                    (§ let Method ctor = new Method("<init>", Type.VOID_TYPE, ctorTypes()))

                    (§ if (hintedFields.count() > 0))
                    (§
                        (§ for (i = 1 i <= fieldCount i++))
                        (§
                            (§ call mv.visitVarInsn(ALOAD, i))
                            (§ let Class k = tagClass(tagOf(hintedFields.nth(i - 1))))
                            (§ if (k.isPrimitive()))
                            (§
                                (§ let String b = Type.getType(boxClass(k)).getInternalName())
                                (§ let String p = Type.getType(k).getDescriptor())
                                (§ let String n = k.getName())

                                (§ call mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p))
                            )
                        )
                    )

                    (§ call mv.visitInsn(ACONST_NULL)) ;; __meta
                    (§ call mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                    (§ call mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                    (§ call mv.visitInsn(ICONST_0)) ;; __hash
                    (§ call mv.visitInsn(ICONST_0)) ;; __hasheq
                    (§ call mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor()))
                    (§ call mv.visitInsn(ARETURN))
                    (§ call mv.visitMaxs(4 + fieldCount, 1 + fieldCount))
                    (§ call mv.visitEnd())
                )
            )
        )

        #_protected
        (§ method void emitMethods(ClassVisitor cv)
            (§ for (ISeq s = RT.seq(methods) s != nil s = s.next()))
            (§
                (§ let ObjMethod method = (ObjMethod) s.first())
                (§ call method.emit(this, cv))
            )
            ;; emit bridge methods
            (§ for (Map.Entry<IPersistentVector, Set<Class>> e :in covariants.entrySet()))
            (§
                (§ let java.lang.reflect.Method m = mmap.get(e.getKey()))
                (§ let Class[] params = m.getParameterTypes())
                (§ let Type[] argTypes = new Type[params.length])

                (§ for (int i = 0 i < params.length i++))
                (§
                    (§ ass argTypes[i] = Type.getType(params[i]))
                )

                (§ let Method target = new Method(m.getName(), Type.getType(m.getReturnType()), argTypes))

                (§ for (Class retType :in e.getValue()))
                (§
                    (§ let Method meth = new Method(m.getName(), Type.getType(retType), argTypes))

                    (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE,
                      #_arg meth,
                      #_arg nil,
                            ;; todo don't hardwire this
                      #_arg EXCEPTION_TYPES,
                      #_arg cv))
                    (§ call gen.visitCode())
                    (§ call gen.loadThis())
                    (§ call gen.loadArgs())
                    (§ call gen.invokeInterface(Type.getType(m.getDeclaringClass()), target))
                    (§ call gen.returnValue())
                    (§ call gen.endMethod())
                )
            )
        )

        #_static
        #_public
        (§ method IPersistentVector msig(java.lang.reflect.Method m)
            (§ return (§ expr RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType())))
        )

        #_static
        (§ method void considerMethod(java.lang.reflect.Method m, Map mm)
            (§ let IPersistentVector mk = msig(m))
            (§ let int mods = m.getModifiers())

            (§ if (!(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods))))
            (§
                (§ call mm.put(mk, m))
            )
        )

        #_static
        (§ method void gatherMethods(Class c, Map mm)
            (§ for (  c != nil c = c.getSuperclass()))
            (§
                (§ for (java.lang.reflect.Method m :in c.getDeclaredMethods()))
                (§
                    (§ call considerMethod(m, mm))
                )
                (§ for (java.lang.reflect.Method m :in c.getMethods()))
                (§
                    (§ call considerMethod(m, mm))
                )
            )
        )

        #_static
        #_public
        (§ method Map[] gatherMethods(Class sc, ISeq interfaces)
            (§ let Map allm = new HashMap())
            (§ call gatherMethods(sc, allm))
            (§ for (  interfaces != nil interfaces = interfaces.next()))
            (§
                (§ call gatherMethods((Class) interfaces.first(), allm))
            )

            (§ let Map<IPersistentVector, java.lang.reflect.Method> mm = new HashMap<IPersistentVector, java.lang.reflect.Method>())
            (§ let Map<IPersistentVector, Set<Class>> covariants = new HashMap<IPersistentVector, Set<Class>>())
            (§ for (Object o :in allm.entrySet()))
            (§
                (§ let Map.Entry e = (Map.Entry) o)
                (§ let IPersistentVector mk = (IPersistentVector) e.getKey())
                (§ ass mk = (IPersistentVector) mk.pop())
                (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())
                (§ if (mm.containsKey(mk))) ;; covariant return
                (§
                    (§ let Set<Class> cvs = covariants.get(mk))
                    (§ if (cvs == nil))
                    (§
                        (§ ass cvs = new HashSet<Class>())
                        (§ call covariants.put(mk, cvs))
                    )
                    (§ let java.lang.reflect.Method om = mm.get(mk))
                    (§ if (om.getReturnType().isAssignableFrom(m.getReturnType())))
                    (§
                        (§ call cvs.add(om.getReturnType()))
                        (§ call mm.put(mk, m))
                    )
                    (§ else )
                    (§
                        (§ call cvs.add(m.getReturnType()))
                    )
                )
                (§ else )
                (§
                    (§ call mm.put(mk, m))
                )
            )
            (§ return (§ expr new Map[] (§ mm, covariants )))
        )
    )

    #_public
    #_static
    (class-ns NewInstanceMethod (§ extends ObjMethod)
        (§ field String name)
        (§ field Type[] argTypes)
        (§ field Type retType)
        (§ field Class retClass)
        (§ field Class[] exclasses)

        #_static
        (§ field Symbol dummyThis = Symbol.intern(nil, "dummy_this_dlskjsdfower"))
        #_private
        (§ field IPersistentVector parms)

        #_public
        (§ method NewInstanceMethod(ObjExpr objx, ObjMethod parent)
            (§ super(objx, parent))
        )

        (§ method int numParams()
            (§ return (§ expr argLocals.count()))
        )

        (§ method String getMethodName()
            (§ return (§ expr name))
        )

        (§ method Type getReturnType()
            (§ return (§ expr retType))
        )

        (§ method Type[] getArgTypes()
            (§ return (§ expr argTypes))
        )

        #_static
        #_public
        (§ method IPersistentVector msig(String name, Class[] paramTypes)
            (§ return (§ expr RT.vector(name, RT.seq(paramTypes))))
        )

        #_static
        (§ method NewInstanceMethod parse(ObjExpr objx, ISeq form, Symbol thistag, Map overrideables)
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            (§ let NewInstanceMethod method = new NewInstanceMethod(objx, (ObjMethod) METHOD.deref()))
            (§ let Symbol dotname = (Symbol)RT.first(form))
            (§ let Symbol name = (Symbol) Symbol.intern(nil, munge(dotname.name)).withMeta(RT.meta(dotname)))
            (§ let IPersistentVector parms = (IPersistentVector) RT.second(form))
            (§ if (parms.count() == 0))
            (§
                (§ throw new IllegalArgumentException("Must supply at least one argument for 'this' in: " + dotname))
            )
            (§ let Symbol thisName = (Symbol) parms.nth(0))
            (§ ass parms = RT.subvec(parms, 1, parms.count()))
            (§ let ISeq body = RT.next(RT.next(form)))
            (§ try )
            (§
                (§ ass method.line = lineDeref())
                (§ ass method.column = columnDeref())
                ;; register as the current method and set up a new env frame
                (§ let PathNode pnode =  new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))
                (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map METHOD, method,
                      #_map LOCAL_ENV, LOCAL_ENV.deref(),
                      #_map LOOP_LOCALS, nil,
                      #_map NEXT_LOCAL_NUM, 0,
                      #_map CLEAR_PATH, pnode,
                      #_map CLEAR_ROOT, pnode,
                      #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                      #_map METHOD_RETURN_CONTEXT, RT.T
                )))

                ;; register 'this' as local 0
                (§ if (thisName != nil))
                (§
                    (§ call registerLocal((thisName == nil) ? dummyThis:thisName, thistag, nil, false))
                )
                (§ else )
                (§
                    (§ call getAndIncLocalNum())
                )

                (§ let PersistentVector argLocals = PersistentVector.EMPTY)
                (§ ass method.retClass = tagClass(tagOf(name)))
                (§ ass method.argTypes = new Type[parms.count()])
                (§ let boolean hinted = tagOf(name) != nil)
                (§ let Class[] pclasses = new Class[parms.count()])
                (§ let Symbol[] psyms = new Symbol[parms.count()])

                (§ for (int i = 0 i < parms.count() i++))
                (§
                    (§ if (!(parms.nth(i) instanceof Symbol)))
                    (§
                        (§ throw new IllegalArgumentException("params must be Symbols"))
                    )
                    (§ let Symbol p = (Symbol) parms.nth(i))
                    (§ let Object tag = tagOf(p))
                    (§ if (tag != nil))
                    (§
                        (§ ass hinted = true)
                    )
                    (§ if (p.getNamespace() != nil))
                    (§
                        (§ ass p = Symbol.intern(p.name))
                    )
                    (§ let Class pclass = tagClass(tag))
                    (§ ass pclasses[i] = pclass)
                    (§ ass psyms[i] = p)
                )
                (§ let Map matches = findMethodsWithNameAndArity(name.name, parms.count(), overrideables))
                (§ let Object mk = msig(name.name, pclasses))
                (§ let java.lang.reflect.Method m = nil)
                (§ if (matches.size() > 0))
                (§
                    ;; multiple methods
                    (§ if (matches.size() > 1))
                    (§
                        ;; must be hinted and match one method
                        (§ if (!hinted))
                        (§
                            (§ throw new IllegalArgumentException("Must hint overloaded method: " + name.name))
                        )
                        (§ ass m = (java.lang.reflect.Method) matches.get(mk))
                        (§ if (m == nil))
                        (§
                            (§ throw new IllegalArgumentException("Can't find matching overloaded method: " + name.name))
                        )
                        (§ if (m.getReturnType() != method.retClass))
                        (§
                            (§ throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName()))
                        )
                    )
                    (§ else ) ;; one match
                    (§
                        ;; if hinted, validate match
                        (§ if (hinted))
                        (§
                            (§ ass m = (java.lang.reflect.Method) matches.get(mk))
                            (§ if (m == nil))
                            (§
                                (§ throw new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match."))
                            )
                            (§ if (m.getReturnType() != method.retClass))
                            (§
                                (§ throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName()))
                            )
                        )
                        (§ else ) ;; adopt found method sig
                        (§
                            (§ ass m = (java.lang.reflect.Method) matches.values().iterator().next())
                            (§ ass method.retClass = m.getReturnType())
                            (§ ass pclasses = m.getParameterTypes())
                        )
                    )
                )
                (§ else )
                (§
                    (§ throw new IllegalArgumentException("Can't define method not in interfaces: " + name.name))
                )

                ;; validate unque name+arity among additional methods

                (§ ass method.retType = Type.getType(method.retClass))
                (§ ass method.exclasses = m.getExceptionTypes())

                (§ for (int i = 0 i < parms.count() i++))
                (§
                    (§ let LocalBinding lb = registerLocal(psyms[i], nil, new MethodParamExpr(pclasses[i]), true))
                    (§ ass argLocals = argLocals.assocN(i, lb))
                    (§ ass method.argTypes[i] = Type.getType(pclasses[i]))
                )
                (§ for (int i = 0 i < parms.count() i++))
                (§
                    (§ if (pclasses[i] == long.class || pclasses[i] == double.class))
                    (§
                        (§ call getAndIncLocalNum())
                    )
                )
                (§ call LOOP_LOCALS.set(argLocals))
                (§ ass method.name = name.name)
                (§ ass method.methodMeta = RT.meta(name))
                (§ ass method.parms = parms)
                (§ ass method.argLocals = argLocals)
                (§ ass method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                (§ return (§ expr method))
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )

        #_private
        #_static
        (§ method Map findMethodsWithNameAndArity(String name, int arity, Map mm)
            (§ let Map ret = new HashMap())
            (§ for (Object o :in mm.entrySet()))
            (§
                (§ let Map.Entry e = (Map.Entry) o)
                (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())
                (§ if (name.equals(m.getName()) && m.getParameterTypes().length == arity))
                (§
                    (§ call ret.put(e.getKey(), e.getValue()))
                )
            )
            (§ return (§ expr ret))
        )

        #_private
        #_static
        (§ method Map findMethodsWithName(String name, Map mm)
            (§ let Map ret = new HashMap())
            (§ for (Object o :in mm.entrySet()))
            (§
                (§ let Map.Entry e = (Map.Entry) o)
                (§ let java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())
                (§ if (name.equals(m.getName())))
                (§
                    (§ call ret.put(e.getKey(), e.getValue()))
                )
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method void emit(ObjExpr obj, ClassVisitor cv)
            (§ let Method m = new Method(getMethodName(), getReturnType(), getArgTypes()))

            (§ let Type[] extypes = nil)
            (§ if (exclasses.length > 0))
            (§
                (§ ass extypes = new Type[exclasses.length])
                (§ for (int i = 0 i < exclasses.length i++))
                (§
                    (§ ass extypes[i] = Type.getType(exclasses[i]))
                )
            )
            (§ let GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, extypes, cv))
            (§ call addAnnotation(gen, methodMeta))
            (§ for (int i = 0 i < parms.count() i++))
            (§
                (§ let IPersistentMap meta = RT.meta(parms.nth(i)))
                (§ call addParameterAnnotation(gen, meta, i))
            )
            (§ call gen.visitCode())

            (§ let Label loopLabel = gen.mark())

            (§ call gen.visitLineNumber(line, loopLabel))
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                (§ call emitBody(objx, gen, retClass, body))
                (§ let Label end = gen.mark())
                (§ call gen.visitLocalVariable("this", obj.objtype.getDescriptor(), nil, loopLabel, end, 0))
                (§ for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next()))
                (§
                    (§ let LocalBinding lb = (LocalBinding) lbs.first())
                    (§ call gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )

            (§ call gen.returnValue())
            (§ call gen.endMethod())
        )
    )

    #_static
    (§ method boolean inty(Class c)
        (§ return (§ expr (c == int.class || c == short.class || c == byte.class || c == char.class)))
    )

    #_static
    (§ method Class retType(Class tc, Class ret)
        (§ if (tc == nil))
        (§
            (§ return (§ expr ret))
        )
        (§ if (ret == nil))
        (§
            (§ return (§ expr tc))
        )
        (§ if (ret.isPrimitive() && tc.isPrimitive()))
        (§
            (§ if ((inty(ret) && inty(tc)) || (ret == tc)))
            (§
                (§ return (§ expr tc))
            )
            (§ throw new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead"))
        )
        (§ return (§ expr tc))
    )

    #_static
    (§ method Class primClass(Symbol sym)
        (§ if (sym == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ let Class c = nil)
        (§ if (sym.name.equals("int")))
        (§
            (§ ass c = int.class)
        )
        (§ elseif (sym.name.equals("long")))
        (§
            (§ ass c = long.class)
        )
        (§ elseif (sym.name.equals("float")))
        (§
            (§ ass c = float.class)
        )
        (§ elseif (sym.name.equals("double")))
        (§
            (§ ass c = double.class)
        )
        (§ elseif (sym.name.equals("char")))
        (§
            (§ ass c = char.class)
        )
        (§ elseif (sym.name.equals("short")))
        (§
            (§ ass c = short.class)
        )
        (§ elseif (sym.name.equals("byte")))
        (§
            (§ ass c = byte.class)
        )
        (§ elseif (sym.name.equals("boolean")))
        (§
            (§ ass c = boolean.class)
        )
        (§ elseif (sym.name.equals("void")))
        (§
            (§ ass c = void.class)
        )
        (§ return (§ expr c))
    )

    #_static
    (§ method Class tagClass(Object tag)
        (§ if (tag == nil))
        (§
            (§ return (§ expr Object.class))
        )
        (§ let Class c = nil)
        (§ if (tag instanceof Symbol))
        (§
            (§ ass c = primClass((Symbol) tag))
        )
        (§ if (c == nil))
        (§
            (§ ass c = HostExpr.tagToClass(tag))
        )
        (§ return (§ expr c))
    )

    #_static
    (§ method Class primClass(Class c)
        (§ return (§ expr c.isPrimitive() ? c :or Object.class))
    )

    #_static
    (§ method Class boxClass(Class p)
        (§ if (!p.isPrimitive()))
        (§
            (§ return (§ expr p))
        )

        (§ let Class c = nil)

        (§ if (p == Integer.TYPE))
        (§
            (§ ass c = Integer.class)
        )
        (§ elseif (p == Long.TYPE))
        (§
            (§ ass c = Long.class)
        )
        (§ elseif (p == Float.TYPE))
        (§
            (§ ass c = Float.class)
        )
        (§ elseif (p == Double.TYPE))
        (§
            (§ ass c = Double.class)
        )
        (§ elseif (p == Character.TYPE))
        (§
            (§ ass c = Character.class)
        )
        (§ elseif (p == Short.TYPE))
        (§
            (§ ass c = Short.class)
        )
        (§ elseif (p == Byte.TYPE))
        (§
            (§ ass c = Byte.class)
        )
        (§ elseif (p == Boolean.TYPE))
        (§
            (§ ass c = Boolean.class)
        )

        (§ return (§ expr c))
    )

    #_static
    #_public
    (class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
        #_final
        (§ field Class c)

        #_public
        (§ method MethodParamExpr(Class c)
            (§ ass this.c = c)
        )

        #_public
        (§ method Object eval()
            (§ throw Util.runtimeException("Can't eval"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ throw Util.runtimeException("Can't emit"))
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (c != nil)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr c))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr Util.isPrimitive(c)))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ throw Util.runtimeException("Can't emit"))
        )
    )

    #_public
    #_static
    (class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
        #_public
        #_final
        (§ field LocalBindingExpr expr)
        #_public
        #_final
        (§ field int shift, mask, low, high)
        #_public
        #_final
        (§ field Expr defaultExpr)
        #_public
        #_final
        (§ field SortedMap<Integer, Expr> tests)
        #_public
        #_final
        (§ field HashMap<Integer, Expr> thens)
        #_public
        #_final
        (§ field Keyword switchType)
        #_public
        #_final
        (§ field Keyword testType)
        #_public
        #_final
        (§ field Set<Integer> skipCheck)
        #_public
        #_final
        (§ field Class returnType)
        #_public
        #_final
        (§ field int line)
        #_public
        #_final
        (§ field int column)

        #_final
        #_static
        (§ field Type NUMBER_TYPE = Type.getType(Number.class))
        #_final
        #_static
        (§ field Method intValueMethod = Method.getMethod("int intValue()"))

        #_final
        #_static
        (§ field Method hashMethod = Method.getMethod("int hash(Object)"))
        #_final
        #_static
        (§ field Method hashCodeMethod = Method.getMethod("int hashCode()"))
        #_final
        #_static
        (§ field Method equivMethod = Method.getMethod("boolean equiv(Object, Object)"))
        #_final
        #_static
        (§ field Keyword compactKey = Keyword.intern(nil, "compact"))
        #_final
        #_static
        (§ field Keyword sparseKey = Keyword.intern(nil, "sparse"))
        #_final
        #_static
        (§ field Keyword hashIdentityKey = Keyword.intern(nil, "hash-identity"))
        #_final
        #_static
        (§ field Keyword hashEquivKey = Keyword.intern(nil, "hash-equiv"))
        #_final
        #_static
        (§ field Keyword intKey = Keyword.intern(nil, "int"))

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        #_public
        (§ method CaseExpr(int line, int column, LocalBindingExpr expr, int shift, int mask, int low, int high, Expr defaultExpr, SortedMap<Integer, Expr> tests, HashMap<Integer, Expr> thens, Keyword switchType, Keyword testType, Set<Integer> skipCheck)
            (§ ass this.expr = expr)
            (§ ass this.shift = shift)
            (§ ass this.mask = mask)
            (§ ass this.low = low)
            (§ ass this.high = high)
            (§ ass this.defaultExpr = defaultExpr)
            (§ ass this.tests = tests)
            (§ ass this.thens = thens)
            (§ ass this.line = line)
            (§ ass this.column = column)
            (§ if (switchType != compactKey && switchType != sparseKey))
            (§
                (§ throw new IllegalArgumentException("Unexpected switch type: "+switchType))
            )
            (§ ass this.switchType = switchType)
            (§ if (testType != intKey && testType != hashEquivKey && testType != hashIdentityKey))
            (§
                (§ throw new IllegalArgumentException("Unexpected test type: "+switchType))
            )
            (§ ass this.testType = testType)
            (§ ass this.skipCheck = skipCheck)
            (§ let Collection<Expr> returns = new ArrayList(thens.values()))
            (§ call returns.add(defaultExpr))
            (§ ass this.returnType = maybeJavaClass(returns))
            (§ if (RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
            (§
                (§ call RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), line, column))
            )
        )

        #_public
        (§ method boolean hasJavaClass()
            (§ return (§ expr (returnType != nil)))
        )

        #_public
        (§ method boolean canEmitPrimitive()
            (§ return (§ expr Util.isPrimitive(returnType)))
        )

        #_public
        (§ method Class getJavaClass()
            (§ return (§ expr returnType))
        )

        #_public
        (§ method Object eval()
            (§ throw new UnsupportedOperationException("Can't eval case"))
        )

        #_public
        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call doEmit(context, objx, gen, false))
        )

        #_public
        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (§ call doEmit(context, objx, gen, true))
        )

        #_public
        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (§ let Label defaultLabel = gen.newLabel())
            (§ let Label endLabel = gen.newLabel())
            (§ let SortedMap<Integer, Label> labels = new TreeMap())

            (§ for (Integer i :in tests.keySet()))
            (§
                (§ call labels.put(i, gen.newLabel()))
            )

            (§ call gen.visitLineNumber(line, gen.mark()))

            (§ let Class primExprClass = maybePrimitiveType(expr))
            (§ let Type primExprType = (primExprClass == nil) ? nil :or Type.getType(primExprClass))

            (§ if (testType == intKey))
            (§
                (§ call emitExprForInts(objx, gen, primExprType, defaultLabel))
            )
            (§ else )
            (§
                (§ call emitExprForHashes(objx, gen))
            )

            (§ if (switchType == sparseKey))
            (§
                (§ let Label[] la = new Label[labels.size()])
                (§ ass la = labels.values().toArray(la))
                (§ let int[] ints = Numbers.int_array(tests.keySet()))
                (§ call gen.visitLookupSwitchInsn(defaultLabel, ints, la))
            )
            (§ else )
            (§
                (§ let Label[] la = new Label[(high - low) + 1])
                (§ for (int i = low i <= high i++))
                (§
                    (§ ass la[i - low] = labels.containsKey(i) ? labels.get(i) :or defaultLabel)
                )
                (§ call gen.visitTableSwitchInsn(low, high, defaultLabel, la))
            )

            (§ for (Integer i :in labels.keySet()))
            (§
                (§ call gen.mark(labels.get(i)))
                (§ if (testType == intKey))
                (§
                    (§ call emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                )
                (§ elseif (RT.contains(skipCheck, i) == RT.T))
                (§
                    (§ call emitExpr(objx, gen, thens.get(i), emitUnboxed))
                )
                (§ else )
                (§
                    (§ call emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                )
                (§ call gen.goTo(endLabel))
            )

            (§ call gen.mark(defaultLabel))
            (§ call emitExpr(objx, gen, defaultExpr, emitUnboxed))
            (§ call gen.mark(endLabel))
            (§ if (context == C.STATEMENT))
            (§
                (§ call gen.pop())
            )
        )

        #_private
        (§ method boolean isShiftMasked()
            (§ return (§ expr (mask != 0)))
        )

        #_private
        (§ method void emitShiftMask(GeneratorAdapter gen)
            (§ if (isShiftMasked()))
            (§
                (§ call gen.push(shift))
                (§ call gen.visitInsn(ISHR))
                (§ call gen.push(mask))
                (§ call gen.visitInsn(IAND))
            )
        )

        #_private
        (§ method void emitExprForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Label defaultLabel)
            (§ if (exprType == nil))
            (§
                (§ if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref())))
                (§
                    (§ call RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column))
                )
                (§ call expr.emit(C.EXPRESSION, objx, gen))
                (§ call gen.instanceOf(NUMBER_TYPE))
                (§ call gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                (§ call expr.emit(C.EXPRESSION, objx, gen))
                (§ call gen.checkCast(NUMBER_TYPE))
                (§ call gen.invokeVirtual(NUMBER_TYPE, intValueMethod))
                (§ call emitShiftMask(gen))
            )
            (§ elseif (exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE))
            (§
                (§ call expr.emitUnboxed(C.EXPRESSION, objx, gen))
                (§ call gen.cast(exprType, Type.INT_TYPE))
                (§ call emitShiftMask(gen))
            )
            (§ else )
            (§
                (§ call gen.goTo(defaultLabel))
            )
        )

        #_private
        (§ method void emitThenForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
            (§ if (exprType == nil))
            (§
                (§ call expr.emit(C.EXPRESSION, objx, gen))
                (§ call test.emit(C.EXPRESSION, objx, gen))
                (§ call gen.invokeStatic(UTIL_TYPE, equivMethod))
                (§ call gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                (§ call emitExpr(objx, gen, then, emitUnboxed))
            )
            (§ elseif (exprType == Type.LONG_TYPE))
            (§
                ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen)
                (§ call expr.emitUnboxed(C.EXPRESSION, objx, gen))
                (§ call gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                (§ call emitExpr(objx, gen, then, emitUnboxed))
            )
            (§ elseif (exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE))
            (§
                (§ if (isShiftMasked()))
                (§
                    ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen)
                    (§ call expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (§ call gen.cast(exprType, Type.LONG_TYPE))
                    (§ call gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                )
                ;; else direct match
                (§ call emitExpr(objx, gen, then, emitUnboxed))
            )
            (§ else )
            (§
                (§ call gen.goTo(defaultLabel))
            )
        )

        #_private
        (§ method void emitExprForHashes(ObjExpr objx, GeneratorAdapter gen)
            (§ call expr.emit(C.EXPRESSION, objx, gen))
            (§ call gen.invokeStatic(UTIL_TYPE, hashMethod))
            (§ call emitShiftMask(gen))
        )

        #_private
        (§ method void emitThenForHashes(ObjExpr objx, GeneratorAdapter gen, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
            (§ call expr.emit(C.EXPRESSION, objx, gen))
            (§ call test.emit(C.EXPRESSION, objx, gen))
            (§ if (testType == hashIdentityKey))
            (§
                (§ call gen.visitJumpInsn(IF_ACMPNE, defaultLabel))
            )
            (§ else )
            (§
                (§ call gen.invokeStatic(UTIL_TYPE, equivMethod))
                (§ call gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
            )
            (§ call emitExpr(objx, gen, then, emitUnboxed))
        )

        #_private
        #_static
        (§ method void emitExpr(ObjExpr objx, GeneratorAdapter gen, Expr expr, boolean emitUnboxed)
            (§ if (emitUnboxed && expr instanceof MaybePrimitiveExpr))
            (§
                ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen)
            )
            (§ else )
            (§
                (§ call expr.emit(C.EXPRESSION, objx, gen))
            )
        )

        #_static
        (class-ns Parser (§ implements IParser)
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            #_public
            (§ method Expr parse(C context, Object frm)
                (§ let ISeq form = (ISeq) frm)
                (§ if (context == C.EVAL))
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )
                (§ let IPersistentVector args = LazilyPersistentVector.create(form.next()))

                (§ let Object exprForm = args.nth(0))
                (§ let int shift = ((Number)args.nth(1)).intValue())
                (§ let int mask = ((Number)args.nth(2)).intValue())
                (§ let Object defaultForm = args.nth(3))
                (§ let Map caseMap = (Map)args.nth(4))
                (§ let Keyword switchType = ((Keyword)args.nth(5)))
                (§ let Keyword testType = ((Keyword)args.nth(6)))
                (§ let Set skipCheck = (RT.count(args) < 8) ? nil :or (Set)args.nth(7))

                (§ let ISeq keys = RT.keys(caseMap))
                (§ let int low = ((Number)RT.first(keys)).intValue())
                (§ let int high = ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue())

                (§ let LocalBindingExpr testexpr = (LocalBindingExpr) analyze(C.EXPRESSION, exprForm))
                (§ ass testexpr.shouldClear = false)

                (§ let SortedMap<Integer, Expr> tests = new TreeMap())
                (§ let HashMap<Integer, Expr> thens = new HashMap())

                (§ let PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))

                (§ for (Object o :in caseMap.entrySet()))
                (§
                    (§ let Map.Entry e = (Map.Entry) o)
                    (§ let Integer minhash = ((Number)e.getKey()).intValue())
                    (§ let Object pair = e.getValue()) ;; [test-val then-expr]
                    (§ let Expr testExpr = (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair)))
                    (§ call tests.put(minhash, testExpr))

                    (§ let Expr thenExpr)
                    (§ try )
                    (§
                        (§ call Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                        (§ ass thenExpr = analyze(context, RT.second(pair)))
                    )
                    (§ finally )
                    (§
                        (§ call Var.popThreadBindings())
                    )
                    (§ call thens.put(minhash, thenExpr))
                )

                (§ let Expr defaultExpr)
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                    (§ ass defaultExpr = analyze(context, args.nth(3)))
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )

                (§ let int line = ((Number)LINE.deref()).intValue())
                (§ let int column = ((Number)COLUMN.deref()).intValue())
                (§ return (§ expr new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck)))
            )
        )
    )

    #_static
    (§ method IPersistentCollection emptyVarCallSites()
        (§ return (§ expr PersistentHashSet.EMPTY))
    )
)
)

(java-ns cloiure.lang.Cons

#_final
#_public
(class-ns Cons (§ extends ASeq)
    #_private
    #_final
    (§ field Object _first)
    #_private
    #_final
    (§ field ISeq _more)

    #_public
    (§ method Cons(Object first, ISeq _more)
        (§ ass this._first = first)
        (§ ass this._more = _more)
    )

    #_public
    (§ method Cons(IPersistentMap meta, Object _first, ISeq _more)
        (§ super(meta))
        (§ ass this._first = _first)
        (§ ass this._more = _more)
    )

    #_public
    (§ method Object first()
        (§ return (§ expr _first))
    )

    #_public
    (§ method ISeq next()
        (§ return (§ expr more().seq()))
    )

    #_public
    (§ method ISeq more()
        (§ if (_more == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _more))
    )

    #_public
    (§ method int count()
        (§ return (§ expr 1 + RT.count(_more)))
    )

    #_public
    (§ method Cons withMeta(IPersistentMap meta)
        (§ return (§ expr new Cons(meta, _first, _more)))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
#_public
(§ interface Counted
    (§ abstract int count())
)
)

(java-ns cloiure.lang.Cycle

#_public
(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    #_private
    #_final
    (§ field ISeq all) ;; never nil
    #_private
    #_final
    (§ field ISeq prev)
    #_private
    #_volatile
    (§ field ISeq _current) ;; lazily realized
    #_private
    #_volatile
    (§ field ISeq _next) ;; cached

    #_private
    (§ method Cycle(ISeq all, ISeq prev, ISeq current)
        (§ ass this.all = all)
        (§ ass this.prev = prev)
        (§ ass this._current = current)
    )

    #_private
    (§ method Cycle(IPersistentMap meta, ISeq all, ISeq prev, ISeq current, ISeq next)
        (§ super(meta))
        (§ ass this.all = all)
        (§ ass this.prev = prev)
        (§ ass this._current = current)
        (§ ass this._next = next)
    )

    #_public
    #_static
    (§ method ISeq create(ISeq vals)
        (§ if (vals == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr new Cycle(vals, nil, vals)))
    )

    ;; realization for use of current
    #_private
    (§ method ISeq current()
        (§ if (_current == nil))
        (§
            (§ let ISeq current = prev.next())
            (§ ass _current = (current == nil) ? all :or current)
        )
        (§ return (§ expr _current))
    )

    #_public
    (§ method boolean isRealized()
        (§ return (§ expr (_current != nil)))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr current().first()))
    )

    #_public
    (§ method ISeq next()
        (§ if (_next == nil))
        (§
            (§ ass _next = new Cycle(all, current(), nil))
        )
        (§ return (§ expr _next))
    )

    #_public
    (§ method Cycle withMeta(IPersistentMap meta)
        (§ return (§ expr new Cycle(meta, all, prev, _current, _next)))
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ let ISeq s = current())
        (§ let Object ret = s.first())
        (§ while (true))
        (§
            (§ ass s = s.next())
            (§ if (s == nil))
            (§
                (§ ass s = all)
            )
            (§ ass ret = f.invoke(ret, s.first()))
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
        )
    )

    #_public
    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = start)
        (§ let ISeq s = current())
        (§ while (true))
        (§
            (§ ass ret = f.invoke(ret, s.first()))
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ ass s = s.next())
            (§ if (s == nil))
            (§
                (§ ass s = all)
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

#_public
(class-ns Delay (§ implements IDeref, IPending)
    #_volatile
    (§ field Object val)
    #_volatile
    (§ field Throwable exception)
    #_volatile
    (§ field IFn fn)

    #_public
    (§ method Delay(IFn fn)
        (§ ass this.fn = fn)
        (§ ass this.val = nil)
        (§ ass this.exception = nil)
    )

    #_static
    #_public
    (§ method Object force(Object x)
        (§ return (§ expr (x instanceof Delay) ? ((Delay) x).deref() :or x))
    )

    #_public
    (§ method Object deref()
        (§ if (fn != nil))
        (§
            (§ synchronized (this))
            (§
                ;; double check
                (§ if (fn != nil))
                (§
                    (§ try )
                    (§
                        (§ ass val = fn.invoke())
                    )
                    (§ catch (Throwable t))
                    (§
                        (§ ass exception = t)
                    )
                    (§ ass fn = nil)
                )
            )
        )
        (§ if (exception != nil))
        (§
            (§ throw Util.sneakyThrow(exception))
        )
        (§ return (§ expr val))
    )

    #_synchronized
    #_public
    (§ method boolean isRealized()
        (§ return (§ expr (fn == nil)))
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

#_public
(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (§ field HashMap<Integer, Object[]> constantVals = new HashMap<Integer, Object[]>())
    #_static
    (§ field ConcurrentHashMap<String, Reference<Class>>classCache = new ConcurrentHashMap<String, Reference<Class> >())

    #_static
    #_final
    (§ field URL[] EMPTY_URLS = new URL[] (§))

    #_static
    #_final
    (§ field ReferenceQueue rq = new ReferenceQueue())

    #_public
    (§ method DynamicClassLoader()
        ;; pseudo test in lieu of hasContextClassLoader()
        (§ super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == nil || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader()))
    )

    #_public
    (§ method DynamicClassLoader(ClassLoader parent)
        (§ super(EMPTY_URLS, parent))
    )

    #_public
    (§ method Class defineClass(String name, byte[] bytes, Object srcForm)
        (§ call Util.clearCache(rq, classCache))
        (§ let Class c = defineClass(name, bytes, 0, bytes.length))
        (§ call classCache.put(name, new SoftReference(c, rq)))
        (§ return (§ expr c))
    )

    #_static
    (§ method Class<?> findInMemoryClass(String name)
        (§ let Reference<Class> cr = classCache.get(name))
        (§ if (cr != nil))
        (§
            (§ let Class c = cr.get())
            (§ if (c != nil))
            (§
                (§ return (§ expr c))
            )
            (§ else )
            (§
                (§ call classCache.remove(name, cr))
            )
        )
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Class<?>findClass(String name) (§ throws ClassNotFoundException)
        (§ let Class c = findInMemoryClass(name))
        (§ if (c != nil))
        (§
            (§ return (§ expr c))
        )
        (§ else )
        (§
            (§ return (§ expr super.findClass(name)))
        )
    )

    #_protected
    #_synchronized
    (§ method Class<?> loadClass(String name, boolean resolve) (§ throws ClassNotFoundException)
        (§ let Class c = findLoadedClass(name))
        (§ if (c == nil))
        (§
            (§ ass c = findInMemoryClass(name))
            (§ if (c == nil))
            (§
                (§ ass c = super.loadClass(name, false))
            )
        )
        (§ if (resolve))
        (§
            (§ call resolveClass(c))
        )
        (§ return (§ expr c))
    )

    #_public
    (§ method void registerConstants(int id, Object[] val)
        (§ call constantVals.put(id, val))
    )

    #_public
    (§ method Object[] getConstants(int id)
        (§ return (§ expr constantVals.get(id)))
    )

    #_public
    (§ method void addURL(URL url)
        (§ call super.addURL(url))
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

#_public
(class-ns EdnReader
    #_static
    (§ field IFn[] macros = new IFn[256])
    #_static
    (§ field IFn[] dispatchMacros = new IFn[256])
    #_static
    (§ field Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    #_static
    (§ field Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    #_static
    (§ field Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)"))
    #_static
    (§ field Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    #_static
    (§ field IFn taggedReader = new TaggedReader())

    (§ static )
    (§
        (§ ass macros[\"] = new StringReader()) ;; oops! "
        (§ ass macros[\;] = new CommentReader())
        (§ ass macros[\^] = new MetaReader())
        (§ ass macros[\(] = new ListReader())
        (§ ass macros[\)] = new UnmatchedDelimiterReader())
        (§ ass macros[\[] = new VectorReader())
        (§ ass macros[\]] = new UnmatchedDelimiterReader())
        (§ ass macros[\{] = new MapReader())
        (§ ass macros[\}] = new UnmatchedDelimiterReader())
        (§ ass macros[\\] = new CharacterReader())
        (§ ass macros[\#] = new DispatchReader())

        (§ ass dispatchMacros[\#] = new SymbolicValueReader())
        (§ ass dispatchMacros[\^] = new MetaReader())
        (§ ass dispatchMacros[\{] = new SetReader())
        (§ ass dispatchMacros[\<] = new UnreadableReader())
        (§ ass dispatchMacros[\_] = new DiscardReader())
        (§ ass dispatchMacros[\:] = new NamespaceMapReader())
    )

    #_static
    (§ method boolean nonConstituent(int ch)
        (§ return (§ expr (ch == \@ || ch == \` || ch == \~)))
    )

    #_static
    #_public
    (§ method Object readString(String s, IPersistentMap opts)
        (§ let PushbackReader r = new PushbackReader(new java.io.StringReader(s)))
        (§ return (§ expr read(r, opts)))
    )

    #_static
    (§ method boolean isWhitespace(int ch)
        (§ return (§ expr (Character.isWhitespace(ch) || ch == \,)))
    )

    #_static
    (§ method void unread(PushbackReader r, int ch)
        (§ if (ch != -1))
        (§
            (§ try )
            (§
                (§ call r.unread(ch))
            )
            (§ catch (IOException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )
    )

    #_public
    #_static
    (class-ns ReaderException (§ extends RuntimeException)
        #_final
        (§ field int line)
        #_final
        (§ field int column)

        #_public
        (§ method ReaderException(int line, int column, Throwable cause)
            (§ super(cause))
            (§ ass this.line = line)
            (§ ass this.column = column)
        )
    )

    #_static
    #_public
    (§ method int read1(Reader r)
        (§ try )
        (§
            (§ return (§ expr r.read()))
        )
        (§ catch (IOException e))
        (§
            (§ throw Util.sneakyThrow(e))
        )
    )

    #_static
    #_final
    (§ field Keyword EOF = Keyword.intern(nil, "eof"))

    #_static
    #_public
    (§ method Object read(PushbackReader r, IPersistentMap opts)
        (§ return (§ expr read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts)))
    )

    #_static
    #_public
    (§ method Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
        (§ try )
        (§
            (§ while (true))
            (§
                (§ let int ch = read1(r))

                (§ while (isWhitespace(ch)))
                (§
                    (§ ass ch = read1(r))
                )

                (§ if (ch == -1))
                (§
                    (§ if (eofIsError))
                    (§
                        (§ throw Util.runtimeException("EOF while reading"))
                    )
                    (§ return (§ expr eofValue))
                )

                (§ if (Character.isDigit(ch)))
                (§
                    (§ let Object n = readNumber(r, (char) ch))
                    (§ if (RT.suppressRead()))
                    (§
                        (§ return (§ expr nil))
                    )
                    (§ return (§ expr n))
                )

                (§ let IFn macroFn = getMacro(ch))
                (§ if (macroFn != nil))
                (§
                    (§ let Object ret = macroFn.invoke(r, (char) ch, opts))
                    (§ if (RT.suppressRead()))
                    (§
                        (§ return (§ expr nil))
                    )
                    ;; no op macros return the reader
                    (§ if (ret == r))
                    (§
                        (§ continue )
                    )
                    (§ return (§ expr ret))
                )

                (§ if (ch == \+ || ch == \-))
                (§
                    (§ let int ch2 = read1(r))
                    (§ if (Character.isDigit(ch2)))
                    (§
                        (§ call unread(r, ch2))
                        (§ let Object n = readNumber(r, (char) ch))
                        (§ if (RT.suppressRead()))
                        (§
                            (§ return (§ expr nil))
                        )
                        (§ return (§ expr n))
                    )
                    (§ call unread(r, ch2))
                )

                (§ let String token = readToken(r, (char) ch, true))
                (§ if (RT.suppressRead()))
                (§
                    (§ return (§ expr nil))
                )
                (§ return (§ expr interpretToken(token)))
            )
        )
        (§ catch (Exception e))
        (§
            (§ if (isRecursive || !(r instanceof LineNumberingPushbackReader)))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ let LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r)
            (§ throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e))
        )
    )

    #_static
    #_private
    (§ method String readToken(PushbackReader r, char initch, boolean leadConstituent)
        (§ let StringBuilder sb = new StringBuilder())
        (§ if (leadConstituent && nonConstituent(initch)))
        (§
            (§ throw Util.runtimeException("Invalid leading character: " + (char)initch))
        )

        (§ call sb.append(initch))

        (§ while (true))
        (§
            (§ let int ch = read1(r))

            (§ if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch)))
            (§
                (§ call unread(r, ch))
                (§ return (§ expr sb.toString()))
            )
            (§ elseif (nonConstituent(ch)))
            (§
                (§ throw Util.runtimeException("Invalid constituent character: " + (char)ch))
            )
            (§ call sb.append((char) ch))
        )
    )

    #_static
    #_private
    (§ method Object readNumber(PushbackReader r, char initch)
        (§ let StringBuilder sb = new StringBuilder())
        (§ call sb.append(initch))

        (§ while (true))
        (§
            (§ let int ch = read1(r))
            (§ if (ch == -1 || isWhitespace(ch) || isMacro(ch)))
            (§
                (§ call unread(r, ch))
                (§ break )
            )
            (§ call sb.append((char) ch))
        )

        (§ let String s = sb.toString())
        (§ let Object n = matchNumber(s))
        (§ if (n == nil))
        (§
            (§ throw new NumberFormatException("Invalid number: " + s))
        )
        (§ return (§ expr n))
    )

    #_static
    #_private
    (§ method int readUnicodeChar(String token, int offset, int length, int base)
        (§ if (token.length() != offset + length))
        (§
            (§ throw new IllegalArgumentException("Invalid unicode character: \\" + token))
        )
        (§ let int uc = 0)
        (§ for (int i = offset i < offset + length ++i))
        (§
            (§ let int d = Character.digit(token.charAt(i), base))
            (§ if (d == -1))
            (§
                (§ throw new IllegalArgumentException("Invalid digit: " + token.charAt(i)))
            )
            (§ ass uc = uc * base + d)
        )
        (§ return (§ expr (char) uc))
    )

    #_static
    #_private
    (§ method int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
        (§ let int uc = Character.digit(initch, base))
        (§ if (uc == -1))
        (§
            (§ throw new IllegalArgumentException("Invalid digit: " + (char) initch))
        )
        (§ let int i = 1)
        (§ for (  i < length ++i))
        (§
            (§ let int ch = read1(r))
            (§ if (ch == -1 || isWhitespace(ch) || isMacro(ch)))
            (§
                (§ call unread(r, ch))
                (§ break )
            )
            (§ let int d = Character.digit(ch, base))
            (§ if (d == -1))
            (§
                (§ throw new IllegalArgumentException("Invalid digit: " + (char) ch))
            )
            (§ ass uc = uc * base + d)
        )
        (§ if (i != length && exact))
        (§
            (§ throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length))
        )
        (§ return (§ expr uc))
    )

    #_static
    #_private
    (§ method Object interpretToken(String s)
        (§ if (s.equals("nil")))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (s.equals("true")))
        (§
            (§ return (§ expr RT.T))
        )
        (§ elseif (s.equals("false")))
        (§
            (§ return (§ expr RT.F))
        )

        (§ let Object ret = nil)

        (§ ass ret = matchSymbol(s))
        (§ if (ret != nil))
        (§
            (§ return (§ expr ret))
        )

        (§ throw Util.runtimeException("Invalid token: " + s))
    )

    #_private
    #_static
    (§ method Object matchSymbol(String s)
        (§ let Matcher m = symbolPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ let int gc = m.groupCount())
            (§ let String ns = m.group(1))
            (§ let String name = m.group(2))
            (§ if (ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1))
            (§
                (§ return (§ expr nil))
            )
            (§ if (s.startsWith("::")))
            (§
                (§ return (§ expr nil))
            )
            (§ let boolean isKeyword = s.charAt(0) == \:)
            (§ let Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0)))
            (§ if (isKeyword))
            (§
                (§ return (§ expr Keyword.intern(sym)))
            )
            (§ return (§ expr sym))
        )
        (§ return (§ expr nil))
    )

    #_private
    #_static
    (§ method Object matchNumber(String s)
        (§ let Matcher m = intPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ if (m.group(2) != nil))
            (§
                (§ if (m.group(8) != nil))
                (§
                    (§ return (§ expr BigInt.ZERO))
                )
                (§ return (§ expr Numbers.num(0)))
            )
            (§ let boolean negate = m.group(1).equals("-"))
            (§ let String n)
            (§ let int radix = 10)
            (§ if ((n = m.group(3)) != nil))
            (§
                (§ ass radix = 10)
            )
            (§ elseif ((n = m.group(4)) != nil))
            (§
                (§ ass radix = 16)
            )
            (§ elseif ((n = m.group(5)) != nil))
            (§
                (§ ass radix = 8)
            )
            (§ elseif ((n = m.group(7)) != nil))
            (§
                (§ ass radix = Integer.parseInt(m.group(6)))
            )
            (§ if (n == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let BigInteger bn = new BigInteger(n, radix))
            (§ if (negate))
            (§
                (§ ass bn = bn.negate())
            )
            (§ if (m.group(8) != nil))
            (§
                (§ return (§ expr BigInt.fromBigInteger(bn)))
            )
            (§ return (§ expr (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
        )
        (§ ass m = floatPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ if (m.group(4) != nil))
            (§
                (§ return (§ expr new BigDecimal(m.group(1))))
            )
            (§ return (§ expr Double.parseDouble(s)))
        )
        (§ ass m = ratioPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ let String numerator = m.group(1))
            (§ if (numerator.startsWith("+")))
            (§
                (§ ass numerator = numerator.substring(1))
            )

            (§ return (§ expr Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_private
    (§ method IFn getMacro(int ch)
        (§ if (ch < macros.length))
        (§
            (§ return (§ expr macros[ch]))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_private
    (§ method boolean isMacro(int ch)
        (§ return (§ expr (ch < macros.length && macros[ch] != nil)))
    )

    #_static
    #_private
    (§ method boolean isTerminatingMacro(int ch)
        (§ return (§ expr (ch != \# && ch != \' && isMacro(ch))))
    )

    #_public
    #_static
    (class-ns StringReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object doublequote, Object opts)
            (§ let StringBuilder sb = new StringBuilder())
            (§ let Reader r = (Reader) reader)

            (§ for (int ch = read1(r) ch != \" ch = read1(r))) ;; oops! "
            (§
                (§ if (ch == -1))
                (§
                    (§ throw Util.runtimeException("EOF while reading string"))
                )
                (§ if (ch == \\)) ;; escape
                (§
                    (§ ass ch = read1(r))
                    (§ if (ch == -1))
                    (§
                        (§ throw Util.runtimeException("EOF while reading string"))
                    )
                    (§ switch (ch))
                    (§
                        (§ case \t)
                        (§
                            (§ ass ch = \tab)
                            (§ break )
                        )
                        (§ case \r)
                        (§
                            (§ ass ch = \return)
                            (§ break )
                        )
                        (§ case \n)
                        (§
                            (§ ass ch = \newline)
                            (§ break )
                        )
                        (§ case \\)
                        (§
                            (§ break )
                        )
                        (§ case \") ;; oops! "
                        (§
                            (§ break )
                        )
                        (§ case \b)
                        (§
                            (§ ass ch = \backspace)
                            (§ break )
                        )
                        (§ case \f)
                        (§
                            (§ ass ch = \formfeed)
                            (§ break )
                        )
                        (§ case \u)
                        (§
                            (§ ass ch = read1(r))
                            (§ if (Character.digit(ch, 16) == -1))
                            (§
                                (§ throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch))
                            )
                            (§ ass ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                            (§ break )
                        )
                        (§ default )
                        (§
                            (§ if (Character.isDigit(ch)))
                            (§
                                (§ ass ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                (§ if (ch > 0377))
                                (§
                                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                                )
                            )
                            (§ else )
                            (§
                                (§ throw Util.runtimeException("Unsupported escape character: \\" + (char) ch))
                            )
                            (§ break )
                        )
                    )
                )
                (§ call sb.append((char) ch))
            )
            (§ return (§ expr sb.toString()))
        )
    )

    #_public
    #_static
    (class-ns CommentReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object semicolon, Object opts)
            (§ let Reader r = (Reader) reader)
            (§ let int ch)
            (§ do
            (§
                (§ ass ch = read1(r))
            ) while (ch != -1 && ch != \newline && ch != \return))
            (§ return (§ expr r))
        )
    )

    #_public
    #_static
    (class-ns DiscardReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object underscore, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ call read(r, true, nil, true, opts))
            (§ return (§ expr r))
        )
    )

    #_public
    #_static
    (class-ns NamespaceMapReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object colon, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)

            ;; Read ns symbol
            (§ let Object sym = read(r, true, nil, false, opts))
            (§ if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil))
            (§
                (§ throw new RuntimeException("Namespaced map must specify a valid namespace: " + sym))
            )
            (§ let String ns = ((Symbol)sym).getName())

            ;; Read map
            (§ let int nextChar = read1(r))
            (§ while (isWhitespace(nextChar)))
            (§
                (§ ass nextChar = read1(r))
            )
            (§ if (\{ != nextChar))
            (§
                (§ throw new RuntimeException("Namespaced map must specify a map"))
            )
            (§ let List kvs = readDelimitedList(\}, r, true, opts))
            (§ if ((kvs.size() & 1) == 1))
            (§
                (§ throw Util.runtimeException("Namespaced map literal must contain an even number of forms"))
            )

            ;; Construct output map
            (§ let Object[] a = new Object[kvs.size()])
            (§ let Iterator iter = kvs.iterator())
            (§ for (int i = 0 iter.hasNext() i += 2))
            (§
                (§ let Object key = iter.next())
                (§ let Object val = iter.next())

                (§ if (key instanceof Keyword))
                (§
                    (§ let Keyword kw = (Keyword) key)
                    (§ if (kw.getNamespace() == nil))
                    (§
                        (§ ass key = Keyword.intern(ns, kw.getName()))
                    )
                    (§ elseif (kw.getNamespace().equals("_")))
                    (§
                        (§ ass key = Keyword.intern(nil, kw.getName()))
                    )
                )
                (§ elseif (key instanceof Symbol))
                (§
                    (§ let Symbol s = (Symbol) key)
                    (§ if (s.getNamespace() == nil))
                    (§
                        (§ ass key = Symbol.intern(ns, s.getName()))
                    )
                    (§ elseif (s.getNamespace().equals("_")))
                    (§
                        (§ ass key = Symbol.intern(nil, s.getName()))
                    )
                )
                (§ ass a[i] = key)
                (§ ass a[i + 1] = val)
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    #_public
    #_static
    (class-ns DispatchReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object hash, Object opts)
            (§ let int ch = read1((Reader) reader))
            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let IFn fn = dispatchMacros[ch])

            (§ if (fn == nil))
            (§
                ;; try tagged reader
                (§ if (Character.isLetter(ch)))
                (§
                    (§ call unread((PushbackReader) reader, ch))
                    (§ return (§ expr taggedReader.invoke(reader, ch, opts)))
                )

                (§ throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch)))
            )
            (§ return (§ expr fn.invoke(reader, ch, opts)))
        )
    )

    #_public
    #_static
    (class-ns MetaReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object caret, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (r instanceof LineNumberingPushbackReader))
            (§
                (§ ass line = ((LineNumberingPushbackReader) r).getLineNumber())
                (§ ass column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ let Object meta = read(r, true, nil, true, opts))
            (§ if (meta instanceof Symbol || meta instanceof String))
            (§
                (§ ass meta = RT.map(RT.TAG_KEY, meta))
            )
            (§ elseif (meta instanceof Keyword))
            (§
                (§ ass meta = RT.map(meta, RT.T))
            )
            (§ elseif (!(meta instanceof IPersistentMap)))
            (§
                (§ throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map"))
            )

            (§ let Object o = read(r, true, nil, true, opts))
            (§ if (o instanceof IMeta))
            (§
                (§ if (line != -1 && o instanceof ISeq))
                (§
                    (§ ass meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                )
                (§ if (o instanceof IReference))
                (§
                    ((IReference)o).resetMeta((IPersistentMap) meta)
                    (§ return (§ expr o))
                )
                (§ let Object ometa = RT.meta(o))
                (§ for (ISeq s = RT.seq(meta) s != nil s = s.next()))
                (§
                    (§ let IMapEntry kv = (IMapEntry) s.first())
                    (§ ass ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                )
                (§ return (§ expr ((IObj) o).withMeta((IPersistentMap) ometa)))
            )
            (§ else )
            (§
                (§ throw new IllegalArgumentException("Metadata can only be applied to IMetas"))
            )
        )
    )

    #_public
    #_static
    (class-ns CharacterReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object backslash, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let String token = readToken(r, (char) ch, false))
            (§ if (token.length() == 1))
            (§
                (§ return (§ expr Character.valueOf(token.charAt(0))))
            )
            (§ elseif (token.equals("newline")))
            (§
                (§ return (§ expr \newline))
            )
            (§ elseif (token.equals("space")))
            (§
                (§ return (§ expr \space))
            )
            (§ elseif (token.equals("tab")))
            (§
                (§ return (§ expr \tab))
            )
            (§ elseif (token.equals("backspace")))
            (§
                (§ return (§ expr \backspace))
            )
            (§ elseif (token.equals("formfeed")))
            (§
                (§ return (§ expr \formfeed))
            )
            (§ elseif (token.equals("return")))
            (§
                (§ return (§ expr \return))
            )
            (§ elseif (token.startsWith("u")))
            (§
                (§ let char c = (char) readUnicodeChar(token, 1, 4, 16))
                (§ if (c >= (§ char "\ud800") && c <= (§ char "\udfff"))) ;; surrogate code unit?
                (§
                    (§ throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16)))
                )
                (§ return (§ expr c))
            )
            (§ elseif (token.startsWith("o")))
            (§
                (§ let int len = token.length() - 1)
                (§ if (len > 3))
                (§
                    (§ throw Util.runtimeException("Invalid octal escape sequence length: " + len))
                )
                (§ let int uc = readUnicodeChar(token, 1, len, 8))
                (§ if (uc > 0377))
                (§
                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                )
                (§ return (§ expr (char) uc))
            )
            (§ throw Util.runtimeException("Unsupported character: \\" + token))
        )
    )

    #_public
    #_static
    (class-ns ListReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (r instanceof LineNumberingPushbackReader))
            (§
                (§ ass line = ((LineNumberingPushbackReader) r).getLineNumber())
                (§ ass column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ let List list = readDelimitedList(\), r, true, opts))
            (§ if (list.isEmpty()))
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ let IObj s = (IObj) PersistentList.create(list))
            (§ return (§ expr s))
        )
    )

    #_public
    #_static
    (class-ns VectorReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ return (§ expr LazilyPersistentVector.create(readDelimitedList(\], r, true, opts))))
        )
    )

    #_public
    #_static
    (class-ns MapReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object[] a = readDelimitedList(\}, r, true, opts).toArray())
            (§ if ((a.length & 1) == 1))
            (§
                (§ throw Util.runtimeException("Map literal must contain an even number of forms"))
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    #_public
    #_static
    (class-ns SetReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftbracket, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ return (§ expr PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts))))
        )
    )

    #_public
    #_static
    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object rightdelim, Object opts)
            (§ throw Util.runtimeException("Unmatched delimiter: " + rightdelim))
        )
    )

    #_public
    #_static
    (class-ns UnreadableReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftangle, Object opts)
            (§ throw Util.runtimeException("Unreadable form"))
        )
    )

    #_public
    #_static
    (class-ns SymbolicValueReader (§ extends AFn)
        #_static
        (§ field IPersistentMap specials = PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        ))

        #_public
        (§ method Object invoke(Object reader, Object quote, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts))

            (§ if (!(o instanceof Symbol)))
            (§
                (§ throw Util.runtimeException("Invalid token: ##" + o))
            )
            (§ if (!(specials.containsKey(o))))
            (§
                (§ throw Util.runtimeException("Unknown symbolic value: ##" + o))
            )

            (§ return (§ expr specials.valAt(o)))
        )
    )

    #_public
    #_static
    (§ method List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts)
        (§ let final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)

        (§ let ArrayList a = new ArrayList())

        (§ while (true))
        (§
            (§ let int ch = read1(r))

            (§ while (isWhitespace(ch)))
            (§
                (§ ass ch = read1(r))
            )

            (§ if (ch == -1))
            (§
                (§ if (firstline < 0))
                (§
                    (§ throw Util.runtimeException("EOF while reading"))
                )
                (§ else )
                (§
                    (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                )
            )

            (§ if (ch == delim))
            (§
                (§ break )
            )

            (§ let IFn macroFn = getMacro(ch))
            (§ if (macroFn != nil))
            (§
                (§ let Object mret = macroFn.invoke(r, (char) ch, opts))
                ;; no op macros return the reader
                (§ if (mret != r))
                (§
                    (§ call a.add(mret))
                )
            )
            (§ else )
            (§
                (§ call unread(r, ch))

                (§ let Object o = read(r, true, nil, isRecursive, opts))
                (§ if (o != r))
                (§
                    (§ call a.add(o))
                )
            )
        )

        (§ return (§ expr a))
    )

    #_public
    #_static
    (class-ns TaggedReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object firstChar, Object opts)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object name = read(r, true, nil, false, opts))
            (§ if (!(name instanceof Symbol)))
            (§
                (§ throw new RuntimeException("Reader tag must be a symbol"))
            )
            (§ let Symbol sym = (Symbol)name)
            (§ return (§ expr readTagged(r, sym, (IPersistentMap) opts)))
        )

        #_static
        (§ field Keyword READERS = Keyword.intern(nil, "readers"))
        #_static
        (§ field Keyword DEFAULT = Keyword.intern(nil, "default"))

        #_private
        (§ method Object readTagged(PushbackReader reader, Symbol tag, IPersistentMap opts)
            (§ let Object o = read(reader, true, nil, true, opts))

            (§ let ILookup readers = (ILookup)RT.get(opts, READERS))
            (§ let IFn dataReader = (IFn)RT.get(readers, tag))
            (§ if (dataReader == nil))
            (§
                (§ ass dataReader = (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag))
            )
            (§ if (dataReader == nil))
            (§
                (§ let IFn defaultReader = (IFn)RT.get(opts, DEFAULT))
                (§ if (defaultReader != nil))
                (§
                    (§ return (§ expr defaultReader.invoke(tag, o)))
                )
                (§ else )
                (§
                    (§ throw new RuntimeException("No reader function for tag " + tag.toString()))
                )
            )
            (§ else )
            (§
                (§ return (§ expr dataReader.invoke(o)))
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

#_public
(class-ns EnumerationSeq (§ extends ASeq)
    #_final
    (§ field Enumeration iter)
    #_final
    (§ field State state)

    #_static
    (class-ns State
        #_volatile
        (§ field Object val)
        #_volatile
        (§ field Object _rest)
    )

    #_public
    #_static
    (§ method EnumerationSeq create(Enumeration iter)
        (§ if (iter.hasMoreElements()))
        (§
            (§ return (§ expr new EnumerationSeq(iter)))
        )
        (§ return (§ expr nil))
    )

    (§ method EnumerationSeq(Enumeration iter)
        (§ ass this.iter = iter)
        (§ ass state = new State())
        (§ ass this.state.val = state)
        (§ ass this.state._rest = state)
    )

    (§ method EnumerationSeq(IPersistentMap meta, Enumeration iter, State state)
        (§ super(meta))
        (§ ass this.iter = iter)
        (§ ass this.state = state)
    )

    #_public
    (§ method Object first()
        (§ if (state.val == state))
        (§
            (§ synchronized (state))
            (§
                (§ if (state.val == state))
                (§
                    (§ ass state.val = iter.nextElement())
                )
            )
        )
        (§ return (§ expr state.val))
    )

    #_public
    (§ method ISeq next()
        (§ if (state._rest == state))
        (§
            (§ synchronized (state))
            (§
                (§ if (state._rest == state))
                (§
                    (§ call first())
                    (§ ass state._rest = create(iter))
                )
            )
        )
        (§ return (§ expr (ISeq) state._rest))
    )

    #_public
    (§ method EnumerationSeq withMeta(IPersistentMap meta)
        (§ return (§ expr new EnumerationSeq(meta, iter, state)))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
#_public
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    #_public
    #_final
    (§ field IPersistentMap data)

    #_public
    (§ method ExceptionInfo(String s, IPersistentMap data)
        (§ this(s, data, nil))
    )

    #_public
    (§ method ExceptionInfo(String s, IPersistentMap data, Throwable throwable)
        ;; nil cause is equivalent to not passing a cause
        (§ super(s, throwable))
        (§ if (data != nil))
        (§
            (§ ass this.data = data)
        )
        (§ else )
        (§
            (§ throw new IllegalArgumentException("Additional data must be non-nil."))
        )
    )

    #_public
    (§ method IPersistentMap getData()
        (§ return (§ expr data))
    )

    #_public
    (§ method String toString()
        (§ return (§ expr "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString()))
    )
)
)

(java-ns cloiure.lang.Fn

#_public
(§ interface Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

#_public
(class-ns FnLoaderThunk (§ extends RestFn)
    #_final
    (§ field Var v)
    #_final
    (§ field ClassLoader loader)
    #_final
    (§ field String fnClassName)
    (§ field IFn fn)

    #_public
    (§ method FnLoaderThunk(Var v, String fnClassName)
        (§ ass this.v = v)
        (§ ass this.loader = (ClassLoader) RT.FN_LOADER_VAR.get())
        (§ ass this.fnClassName = fnClassName)
        (§ ass fn = nil)
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ call load())
        (§ return (§ expr fn.invoke(arg1)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2)
        (§ call load())
        (§ return (§ expr fn.invoke(arg1, arg2)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ call load())
        (§ return (§ expr fn.invoke(arg1, arg2, arg3)))
    )

    #_protected
    (§ method Object doInvoke(Object args)
        (§ call load())
        (§ return (§ expr fn.applyTo((ISeq) args)))
    )

    #_private
    (§ method void load()
        (§ if (fn == nil))
        (§
            (§ try )
            (§
                (§ ass fn = (IFn) Class.forName(fnClassName, true, loader).newInstance())
            )
            (§ catch (Exception e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ ass v.root = fn)
        )
    )

    #_public
    (§ method int getRequiredArity()
        (§ return (§ expr 0))
    )

    #_public
    (§ method IObj withMeta(IPersistentMap meta)
        (§ return (§ expr this))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr nil))
    )
)
)

(java-ns cloiure.lang.IAtom

#_public
(§ interface IAtom
    (§ abstract Object swap(IFn f))
    (§ abstract Object swap(IFn f, Object arg))
    (§ abstract Object swap(IFn f, Object arg1, Object arg2))
    (§ abstract Object swap(IFn f, Object x, Object y, ISeq args))
    (§ abstract boolean compareAndSet(Object oldv, Object newv))
    (§ abstract Object reset(Object newval))
)
)

(java-ns cloiure.lang.IAtom2

#_public
(§ interface IAtom2 (§ extends IAtom)
    (§ abstract IPersistentVector swapVals(IFn f))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg1, Object arg2))
    (§ abstract IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args))
    (§ abstract IPersistentVector resetVals(Object newv))
)
)

(java-ns cloiure.lang.IBlockingDeref

#_public
(§ interface IBlockingDeref
    (§ abstract Object deref(long ms, Object timeoutValue))
)
)

(java-ns cloiure.lang.IChunk

#_public
(§ interface IChunk (§ extends Indexed)
    (§ abstract IChunk dropFirst())
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IChunkedSeq

#_public
(§ interface IChunkedSeq (§ extends ISeq, Sequential)
    (§ abstract IChunk chunkedFirst())
    (§ abstract ISeq chunkedNext())
    (§ abstract ISeq chunkedMore())
)
)

(java-ns cloiure.lang.IDeref

#_public
(§ interface IDeref
    (§ abstract Object deref())
)
)

(java-ns cloiure.lang.IEditableCollection

#_public
(§ interface IEditableCollection
    (§ abstract ITransientCollection asTransient())
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
#_public
(§ interface IExceptionInfo
    (§ abstract public IPersistentMap getData())
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
#_public
(§ interface IFn (§ extends Callable, Runnable)
    (§ abstract public Object invoke())
    (§ abstract public Object invoke(Object arg1))
    (§ abstract public Object invoke(Object arg1, Object arg2))
    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3))
    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4))
    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5))
    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6))
    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7))
    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))

    (§ abstract public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
      #_arg Object... args))

    (§ abstract public Object applyTo(ISeq arglist))

    #_static
    #_public
    (§ interface L
        (§ abstract long invokePrim())
    )

    #_static
    #_public
    (§ interface D
        (§ abstract double invokePrim())
    )

    #_static
    #_public
    (§ interface OL
        (§ abstract long invokePrim(Object arg0))
    )

    #_static
    #_public
    (§ interface OD
        (§ abstract double invokePrim(Object arg0))
    )

    #_static
    #_public
    (§ interface LO
        (§ abstract Object invokePrim(long arg0))
    )

    #_static
    #_public
    (§ interface LL
        (§ abstract long invokePrim(long arg0))
    )

    #_static
    #_public
    (§ interface LD
        (§ abstract double invokePrim(long arg0))
    )

    #_static
    #_public
    (§ interface DO
        (§ abstract Object invokePrim(double arg0))
    )

    #_static
    #_public
    (§ interface DL
        (§ abstract long invokePrim(double arg0))
    )

    #_static
    #_public
    (§ interface DD
        (§ abstract double invokePrim(double arg0))
    )

    #_static
    #_public
    (§ interface OOL
        (§ abstract long invokePrim(Object arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface OOD
        (§ abstract double invokePrim(Object arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface OLO
        (§ abstract Object invokePrim(Object arg0, long arg1))
    )

    #_static
    #_public
    (§ interface OLL
        (§ abstract long invokePrim(Object arg0, long arg1))
    )

    #_static
    #_public
    (§ interface OLD
        (§ abstract double invokePrim(Object arg0, long arg1))
    )

    #_static
    #_public
    (§ interface ODO
        (§ abstract Object invokePrim(Object arg0, double arg1))
    )

    #_static
    #_public
    (§ interface ODL
        (§ abstract long invokePrim(Object arg0, double arg1))
    )

    #_static
    #_public
    (§ interface ODD
        (§ abstract double invokePrim(Object arg0, double arg1))
    )

    #_static
    #_public
    (§ interface LOO
        (§ abstract Object invokePrim(long arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface LOL
        (§ abstract long invokePrim(long arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface LOD
        (§ abstract double invokePrim(long arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface LLO
        (§ abstract Object invokePrim(long arg0, long arg1))
    )

    #_static
    #_public
    (§ interface LLL
        (§ abstract long invokePrim(long arg0, long arg1))
    )

    #_static
    #_public
    (§ interface LLD
        (§ abstract double invokePrim(long arg0, long arg1))
    )

    #_static
    #_public
    (§ interface LDO
        (§ abstract Object invokePrim(long arg0, double arg1))
    )

    #_static
    #_public
    (§ interface LDL
        (§ abstract long invokePrim(long arg0, double arg1))
    )

    #_static
    #_public
    (§ interface LDD
        (§ abstract double invokePrim(long arg0, double arg1))
    )

    #_static
    #_public
    (§ interface DOO
        (§ abstract Object invokePrim(double arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface DOL
        (§ abstract long invokePrim(double arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface DOD
        (§ abstract double invokePrim(double arg0, Object arg1))
    )

    #_static
    #_public
    (§ interface DLO
        (§ abstract Object invokePrim(double arg0, long arg1))
    )

    #_static
    #_public
    (§ interface DLL
        (§ abstract long invokePrim(double arg0, long arg1))
    )

    #_static
    #_public
    (§ interface DLD
        (§ abstract double invokePrim(double arg0, long arg1))
    )

    #_static
    #_public
    (§ interface DDO
        (§ abstract Object invokePrim(double arg0, double arg1))
    )

    #_static
    #_public
    (§ interface DDL
        (§ abstract long invokePrim(double arg0, double arg1))
    )

    #_static
    #_public
    (§ interface DDD
        (§ abstract double invokePrim(double arg0, double arg1))
    )

    #_static
    #_public
    (§ interface OOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface OOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface OOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface OOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface OOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface OODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface OODL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface OODD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface OLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface OLOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface OLOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface OLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface OLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface OLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface OLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface OLDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface OLDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface ODOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface ODOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface ODOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface ODLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface ODLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface ODLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface ODDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface ODDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface ODDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LOLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LOLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LODO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LODL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LODD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LLOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LLOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LLOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LLDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LLDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LLDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LDOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LDOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LDOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface LDLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LDLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LDLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface LDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface LDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DOLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DOLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DODO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DODL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DODD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DLOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DLOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DLOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DLDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DLDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DLDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DDOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DDOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DDOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2))
    )

    #_static
    #_public
    (§ interface DDLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DDLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DDLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2))
    )

    #_static
    #_public
    (§ interface DDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface DDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2))
    )

    #_static
    #_public
    (§ interface OOOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OOOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OOOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OOOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OOOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OOODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OOODL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OOODD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OOLOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OOLOL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OOLOD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OOLLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OOLLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OOLLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OOLDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OOLDL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OOLDD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OODOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OODOL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OODOD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OODLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OODLL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OODLD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OODDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OODDL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OODDD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLOOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLOOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLOOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLOLO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLOLL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLOLD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLODO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLODL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLODD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLLOL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLLOD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLLDL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLLDD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLDOO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLDOL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLDOD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface OLDLO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLDLL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLDLD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface OLDDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLDDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface OLDDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODOOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODOOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODOOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODOLO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODOLL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODOLD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODODO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODODL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODODD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODLOO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODLOL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODLOD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODLLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODLLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODLLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODLDO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODLDL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODLDD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODDOO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODDOL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODDOD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface ODDLO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODDLL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODDLD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface ODDDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODDDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface ODDDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LOOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LOOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LOOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LOOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LOOLL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LOOLD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LOODO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LOODL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LOODD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LOLOO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LOLOL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LOLOD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LOLLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LOLLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LOLLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LOLDO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LOLDL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LOLDD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LODOO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LODOL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LODOD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LODLO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LODLL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LODLD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LODDO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LODDL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LODDD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLOOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLOOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLOOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLOLO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLOLL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLOLD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLODO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLODL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLODD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLLOO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLLOL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLLOD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLLDO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLLDL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLLDD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLDOO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLDOL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLDOD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LLDLO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLDLL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLDLD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LLDDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLDDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LLDDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDOOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDOOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDOOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDOLO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDOLL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDOLD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDODO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDODL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDODD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDLOO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDLOL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDLOD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDLLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDLLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDLLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDLDO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDLDL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDLDD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDDOO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDDOL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDDOD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface LDDLO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDDLL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDDLD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface LDDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface LDDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DOOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DOOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DOOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DOOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DOOLL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DOOLD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DOODO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DOODL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DOODD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DOLOO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DOLOL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DOLOD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DOLLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DOLLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DOLLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DOLDO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DOLDL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DOLDD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DODOO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DODOL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DODOD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DODLO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DODLL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DODLD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DODDO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DODDL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DODDD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLOOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLOOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLOOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLOLO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLOLL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLOLD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLODO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLODL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLODD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLLOO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLLOL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLLOD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLLDO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLLDL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLLDD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLDOO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLDOL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLDOD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DLDLO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLDLL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLDLD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DLDDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLDDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DLDDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDOOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDOOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDOOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDOLO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDOLL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDOLD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDODO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDODL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDODD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDLOO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDLOL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDLOD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDLLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDLLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDLLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDLDO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDLDL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDLDD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDDOO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDDOL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDDOD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    #_static
    #_public
    (§ interface DDDLO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDDLL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDDLD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    #_static
    #_public
    (§ interface DDDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    #_static
    #_public
    (§ interface DDDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, double arg3))
    )
)
)

(java-ns cloiure.lang.IHashEq

#_public
(§ interface IHashEq
    (§ abstract int hasheq())
)
)

(java-ns cloiure.lang.IKeywordLookup

#_public
(§ interface IKeywordLookup
    (§ abstract ILookupThunk getLookupThunk(Keyword k))
)
)

(java-ns cloiure.lang.IKVReduce

#_public
(§ interface IKVReduce
    (§ abstract Object kvreduce(IFn f, Object init))
)
)

(java-ns cloiure.lang.ILookup

#_public
(§ interface ILookup
    (§ abstract Object valAt(Object key))
    (§ abstract Object valAt(Object key, Object notFound))
)
)

(java-ns cloiure.lang.ILookupSite

#_public
(§ interface ILookupSite
    (§ abstract ILookupThunk fault(Object target))
)
)

(java-ns cloiure.lang.ILookupThunk

#_public
(§ interface ILookupThunk
    (§ abstract Object get(Object target))
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

#_public
(§ interface IMapEntry (§ extends Map).Entry
    (§ abstract Object key())
    (§ abstract Object val())
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
#_public
(§ interface IMapIterable
    (§ abstract Iterator keyIterator())
    (§ abstract Iterator valIterator())
)
)

(java-ns cloiure.lang.IMeta

#_public
(§ interface IMeta
    (§ abstract IPersistentMap meta())
)
)

(java-ns cloiure.lang.Indexed

#_public
(§ interface Indexed (§ extends Counted)
    (§ abstract Object nth(int i))
    (§ abstract Object nth(int i, Object notFound))
)
)

(java-ns cloiure.lang.IndexedSeq

#_public
(§ interface IndexedSeq (§ extends ISeq, Sequential, Counted)
    (§ abstract public int index())
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_public
(class-ns Intrinsics (§ implements Opcodes)
    #_private
    #_static
    (§ method Object[] oa(Object... arr)
        (§ return (§ expr arr))
    )

    #_static
    (§ field IPersistentMap ops = RT.map(
      #_map "public static double cloiure.lang.Numbers.add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.and(long,long)", LAND,
      #_map "public static long cloiure.lang.Numbers.or(long,long)", LOR,
      #_map "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
      #_map "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
      #_map "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
      #_map "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
      #_map "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
      #_map "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
      #_map "public static double cloiure.lang.Numbers.minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
      #_map "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
      #_map "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
      #_map "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
      #_map "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
      #_map "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
      #_map "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
      #_map "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
      #_map "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
      #_map "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

      #_map "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
      #_map "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
      #_map "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
      #_map "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
      #_map "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
      #_map "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
      #_map "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
      #_map "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
      #_map "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
      #_map "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

      #_map "public static double cloiure.lang.RT.doubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.doubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.doubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.doubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
      #_map "public static long cloiure.lang.RT.longCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.longCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(int)", I2L,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    ))

    ;; map to instructions terminated with comparator for branch to false
    #_static
    (§ field IPersistentMap preds = RT.map(
      #_map "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
      #_map "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
      #_map "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
      #_map "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

      #_map "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    ))
)
)

(java-ns cloiure.lang.IObj

#_public
(§ interface IObj (§ extends IMeta)
    (§ abstract public IObj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.IPending

#_public
(§ interface IPending
    (§ abstract boolean isRealized())
)
)

(java-ns cloiure.lang.IPersistentCollection

#_public
(§ interface IPersistentCollection (§ extends Seqable)
    (§ abstract int count())
    (§ abstract IPersistentCollection cons(Object o))
    (§ abstract IPersistentCollection empty())
    (§ abstract boolean equiv(Object o))
)
)

(java-ns cloiure.lang.IPersistentList

#_public
(§ interface IPersistentList (§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

#_public
(§ interface IPersistentMap (§ extends Iterable, Associative, Counted)
    (§ abstract IPersistentMap assoc(Object key, Object val))
    (§ abstract IPersistentMap assocEx(Object key, Object val))
    (§ abstract IPersistentMap without(Object key))
)
)

(java-ns cloiure.lang.IPersistentSet

#_public
(§ interface IPersistentSet (§ extends IPersistentCollection, Counted)
    (§ abstract public IPersistentSet disjoin(Object key))
    (§ abstract public boolean contains(Object key))
    (§ abstract public Object get(Object key))
)
)

(java-ns cloiure.lang.IPersistentStack

#_public
(§ interface IPersistentStack (§ extends IPersistentCollection)
    (§ abstract Object peek())
    (§ abstract IPersistentStack pop())
)
)

(java-ns cloiure.lang.IPersistentVector

#_public
(§ interface IPersistentVector (§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    (§ abstract int length())
    (§ abstract IPersistentVector assocN(int i, Object val))
    (§ abstract IPersistentVector cons(Object o))
)
)

(java-ns cloiure.lang.IProxy

#_public
(§ interface IProxy
    (§ abstract public void __initCloiureFnMappings(IPersistentMap m))
    (§ abstract public void __updateCloiureFnMappings(IPersistentMap m))
    (§ abstract public IPersistentMap __getCloiureFnMappings())
)
)

(java-ns cloiure.lang.IRecord

#_public
(§ interface IRecord
)
)

(java-ns cloiure.lang.IReduce

#_public
(§ interface IReduce (§ extends IReduceInit)
    (§ abstract Object reduce(IFn f))
)
)

(java-ns cloiure.lang.IReduceInit

#_public
(§ interface IReduceInit
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IRef

#_public
(§ interface IRef (§ extends IDeref)
    (§ abstract void setValidator(IFn vf))
    (§ abstract IFn getValidator())
    (§ abstract IPersistentMap getWatches())
    (§ abstract IRef addWatch(Object key, IFn callback))
    (§ abstract IRef removeWatch(Object key))
)
)

(java-ns cloiure.lang.IReference

#_public
(§ interface IReference (§ extends IMeta)
    (§ abstract IPersistentMap alterMeta(IFn alter, ISeq args))
    (§ abstract IPersistentMap resetMeta(IPersistentMap m))
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
#_public
(§ interface ISeq (§ extends IPersistentCollection)
    (§ abstract Object first())
    (§ abstract ISeq next())
    (§ abstract ISeq more())
    (§ abstract ISeq cons(Object o))
)
)

(java-ns cloiure.lang.Iterate

#_public
(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    #_private
    #_static
    #_final
    (§ field Object UNREALIZED_SEED = new Object())
    #_private
    #_final
    (§ field IFn f) ;; never nil
    #_private
    #_final
    (§ field Object prevSeed)
    #_private
    #_volatile
    (§ field Object _seed) ;; lazily realized
    #_private
    #_volatile
    (§ field ISeq _next) ;; cached

    #_private
    (§ method Iterate(IFn f, Object prevSeed, Object seed)
        (§ ass this.f = f)
        (§ ass this.prevSeed = prevSeed)
        (§ ass this._seed = seed)
    )

    #_private
    (§ method Iterate(IPersistentMap meta, IFn f, Object prevSeed, Object seed, ISeq next)
        (§ super(meta))
        (§ ass this.f = f)
        (§ ass this.prevSeed = prevSeed)
        (§ ass this._seed = seed)
        (§ ass this._next = next)
    )

    #_public
    #_static
    (§ method ISeq create(IFn f, Object seed)
        (§ return (§ expr new Iterate(f, nil, seed)))
    )

    #_public
    (§ method boolean isRealized()
        (§ return (§ expr (_seed != UNREALIZED_SEED)))
    )

    #_public
    (§ method Object first()
        (§ if (_seed == UNREALIZED_SEED))
        (§
            (§ ass _seed = f.invoke(prevSeed))
        )
        (§ return (§ expr _seed))
    )

    #_public
    (§ method ISeq next()
        (§ if (_next == nil))
        (§
            (§ ass _next = new Iterate(f, first(), UNREALIZED_SEED))
        )
        (§ return (§ expr _next))
    )

    #_public
    (§ method Iterate withMeta(IPersistentMap meta)
        (§ return (§ expr new Iterate(meta, f, prevSeed, _seed, _next)))
    )

    #_public
    (§ method Object reduce(IFn rf)
        (§ let Object first = first())
        (§ let Object ret = first)
        (§ let Object v = f.invoke(first))
        (§ while (true))
        (§
            (§ ass ret = rf.invoke(ret, v))
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ ass v = f.invoke(v))
        )
    )

    #_public
    (§ method Object reduce(IFn rf, Object start)
        (§ let Object ret = start)
        (§ let Object v = first())
        (§ while (true))
        (§
            (§ ass ret = rf.invoke(ret, v))
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ ass v = f.invoke(v))
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

#_public
(class-ns IteratorSeq (§ extends ASeq)
    #_final
    (§ field Iterator iter)
    #_final
    (§ field State state)

    #_static
    (class-ns State
        #_volatile
        (§ field Object val)
        #_volatile
        (§ field Object _rest)
    )

    #_public
    #_static
    (§ method IteratorSeq create(Iterator iter)
        (§ if (iter.hasNext()))
        (§
            (§ return (§ expr new IteratorSeq(iter)))
        )
        (§ return (§ expr nil))
    )

    (§ method IteratorSeq(Iterator iter)
        (§ ass this.iter = iter)
        (§ ass state = new State())
        (§ ass this.state.val = state)
        (§ ass this.state._rest = state)
    )

    (§ method IteratorSeq(IPersistentMap meta, Iterator iter, State state)
        (§ super(meta))
        (§ ass this.iter = iter)
        (§ ass this.state = state)
    )

    #_public
    (§ method Object first()
        (§ if (state.val == state))
        (§
            (§ synchronized (state))
            (§
                (§ if (state.val == state))
                (§
                    (§ ass state.val = iter.next())
                )
            )
        )
        (§ return (§ expr state.val))
    )

    #_public
    (§ method ISeq next()
        (§ if (state._rest == state))
        (§
            (§ synchronized (state))
            (§
                (§ if (state._rest == state))
                (§
                    (§ call first())
                    (§ ass state._rest = create(iter))
                )
            )
        )
        (§ return (§ expr (ISeq) state._rest))
    )

    #_public
    (§ method IteratorSeq withMeta(IPersistentMap meta)
        (§ return (§ expr new IteratorSeq(meta, iter, state)))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

#_public
(§ interface ITransientAssociative (§ extends ITransientCollection, ILookup)
    (§ abstract ITransientAssociative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.ITransientAssociative2

#_public
(§ interface ITransientAssociative2 (§ extends ITransientAssociative)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
)
)

(java-ns cloiure.lang.ITransientCollection

#_public
(§ interface ITransientCollection
    (§ abstract ITransientCollection conj(Object val))
    (§ abstract IPersistentCollection persistent())
)
)

(java-ns cloiure.lang.ITransientMap

#_public
(§ interface ITransientMap (§ extends ITransientAssociative, Counted)
    (§ abstract ITransientMap assoc(Object key, Object val))
    (§ abstract ITransientMap without(Object key))
    (§ abstract IPersistentMap persistent())
)
)

(java-ns cloiure.lang.ITransientSet

#_public
(§ interface ITransientSet (§ extends ITransientCollection, Counted)
    (§ abstract public ITransientSet disjoin(Object key))
    (§ abstract public boolean contains(Object key))
    (§ abstract public Object get(Object key))
)
)

(java-ns cloiure.lang.ITransientVector

#_public
(§ interface ITransientVector (§ extends ITransientAssociative, Indexed)
    (§ abstract ITransientVector assocN(int i, Object val))
    (§ abstract ITransientVector pop())
)
)

(java-ns cloiure.lang.IType

#_public
(§ interface IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

#_public
(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    #_private
    #_static
    (§ field ConcurrentHashMap<Symbol, Reference<Keyword>> table = new ConcurrentHashMap())

    #_static
    #_final
    (§ field ReferenceQueue rq = new ReferenceQueue())

    #_public
    #_final
    (§ field Symbol sym)
    #_final
    (§ field int hasheq)
    #_transient
    (§ field String _str)

    #_public
    #_static
    (§ method Keyword intern(Symbol sym)
        (§ let Keyword k = nil)
        (§ let Reference<Keyword> existingRef = table.get(sym))
        (§ if (existingRef == nil))
        (§
            (§ call Util.clearCache(rq, table))
            (§ if (sym.meta() != nil))
            (§
                (§ ass sym = (Symbol) sym.withMeta(nil))
            )
            (§ ass k = new Keyword(sym))
            (§ ass existingRef = table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq)))
        )
        (§ if (existingRef == nil))
        (§
            (§ return (§ expr k))
        )
        (§ let Keyword existingk = existingRef.get())
        (§ if (existingk != nil))
        (§
            (§ return (§ expr existingk))
        )
        ;; entry died in the interim, do over
        (§ call table.remove(sym, existingRef))
        (§ return (§ expr intern(sym)))
    )

    #_public
    #_static
    (§ method Keyword intern(String ns, String name)
        (§ return (§ expr intern(Symbol.intern(ns, name))))
    )

    #_public
    #_static
    (§ method Keyword intern(String nsname)
        (§ return (§ expr intern(Symbol.intern(nsname))))
    )

    #_private
    (§ method Keyword(Symbol sym)
        (§ ass this.sym = sym)
        (§ ass hasheq = sym.hasheq() + 0x9e3779b9)
    )

    #_public
    #_static
    (§ method Keyword find(Symbol sym)
        (§ let Reference<Keyword> ref = table.get(sym))
        (§ if (ref != nil))
        (§
            (§ return (§ expr ref.get()))
        )
        (§ else )
        (§
            (§ return (§ expr nil))
        )
    )

    #_public
    #_static
    (§ method Keyword find(String ns, String name)
        (§ return (§ expr find(Symbol.intern(ns, name))))
    )

    #_public
    #_static
    (§ method Keyword find(String nsname)
        (§ return (§ expr find(Symbol.intern(nsname))))
    )

    #_public
    #_final
    (§ method int hashCode()
        (§ return (§ expr sym.hashCode() + 0x9e3779b9))
    )

    #_public
    (§ method int hasheq()
        (§ return (§ expr hasheq))
    )

    #_public
    (§ method String toString()
        (§ if (_str == nil))
        (§
            (§ ass _str = (":" + sym))
        )
        (§ return (§ expr _str))
    )

    #_public
    (§ method Object throwArity()
        (§ throw new IllegalArgumentException("Wrong number of args passed to keyword: " + toString()))
    )

    #_public
    (§ method Object call()
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method void run()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method Object invoke()
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method int compareTo(Object o)
        (§ return (§ expr sym.compareTo(((Keyword) o).sym)))
    )

    #_public
    (§ method String getNamespace()
        (§ return (§ expr sym.getNamespace()))
    )

    #_public
    (§ method String getName()
        (§ return (§ expr sym.getName()))
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_final
    #_public
    (§ method Object invoke(Object obj)
        (§ if (obj instanceof ILookup))
        (§
            (§ return (§ expr ((ILookup)obj).valAt(this)))
        )
        (§ return (§ expr RT.get(obj, this)))
    )

    #_final
    #_public
    (§ method Object invoke(Object obj, Object notFound)
        (§ if (obj instanceof ILookup))
        (§
            (§ return (§ expr ((ILookup)obj).valAt(this, notFound)))
        )
        (§ return (§ expr RT.get(obj, this, notFound)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
      #_arg Object... args))
    (§
        (§ return (§ expr throwArity()))
    )

    #_public
    (§ method Object applyTo(ISeq arglist)
        (§ return (§ expr AFn.applyToHelper(this, arglist)))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

#_public
#_final
(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    #_final
    (§ field Keyword k)

    #_public
    (§ method KeywordLookupSite(Keyword k)
        (§ ass this.k = k)
    )

    #_public
    (§ method ILookupThunk fault(Object target)
        (§ if (target instanceof IKeywordLookup))
        (§
            (§ return (§ expr install(target)))
        )
        (§ elseif (target instanceof ILookup))
        (§
            (§ return (§ expr ilookupThunk(target.getClass())))
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method Object get(Object target)
        (§ if (target instanceof IKeywordLookup || target instanceof ILookup))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr RT.get(target, k)))
    )

    #_private
    (§ method ILookupThunk ilookupThunk(final Class c)
        (§ return (§ expr new ILookupThunk()
        (§ inner
            #_public
            (§ method Object get(Object target)
                (§ if (target != nil && target.getClass() == c))
                (§
                    (§ return (§ expr ((ILookup) target).valAt(k)))
                )
                (§ return (§ expr this))
            )
        )))
    )

    #_private
    (§ method ILookupThunk install(Object target)
        (§ let ILookupThunk t = ((IKeywordLookup)target).getLookupThunk(k))
        (§ if (t != nil))
        (§
            (§ return (§ expr t))
        )
        (§ return (§ expr ilookupThunk(target.getClass())))
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_public
(class-ns LazilyPersistentVector
    #_static
    #_public
    (§ method IPersistentVector createOwning(Object... items)
        (§ if (items.length <= 32))
        (§
            (§ return (§ expr new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)))
        )
        (§ return (§ expr PersistentVector.create(items)))
    )

    #_static
    (§ method int fcount(Object c)
        (§ if (c instanceof Counted))
        (§
            (§ return (§ expr ((Counted) c).count()))
        )
        (§ return (§ expr ((Collection)c).size()))
    )

    #_static
    #_public
    (§ method IPersistentVector create(Object obj)
        (§ if (obj instanceof IReduceInit))
        (§
            (§ return (§ expr PersistentVector.create((IReduceInit) obj)))
        )
        (§ elseif (obj instanceof ISeq))
        (§
            (§ return (§ expr PersistentVector.create(RT.seq(obj))))
        )
        (§ elseif (obj instanceof Iterable))
        (§
            (§ return (§ expr PersistentVector.create((Iterable)obj)))
        )
        (§ else )
        (§
            (§ return (§ expr createOwning(RT.toArray(obj))))
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

#_public
#_final
(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    #_private
    (§ field IFn fn)
    #_private
    (§ field Object sv)
    #_private
    (§ field ISeq s)

    #_public
    (§ method LazySeq(IFn fn)
        (§ ass this.fn = fn)
    )

    #_private
    (§ method LazySeq(IPersistentMap meta, ISeq s)
        (§ super(meta))
        (§ ass this.fn = nil)
        (§ ass this.s = s)
    )

    #_public
    (§ method Obj withMeta(IPersistentMap meta)
        (§ return (§ expr new LazySeq(meta, seq())))
    )

    #_final
    #_synchronized
    (§ method Object sval()
        (§ if (fn != nil))
        (§
            (§ ass sv = fn.invoke())
            (§ ass fn = nil)
        )
        (§ if (sv != nil))
        (§
            (§ return (§ expr sv))
        )
        (§ return (§ expr s))
    )

    #_final
    #_synchronized
    #_public
    (§ method ISeq seq()
        (§ call sval())
        (§ if (sv != nil))
        (§
            (§ let Object ls = sv)
            (§ ass sv = nil)
            (§ while (ls instanceof LazySeq))
            (§
                (§ ass ls = ((LazySeq)ls).sval())
            )
            (§ ass s = RT.seq(ls))
        )
        (§ return (§ expr s))
    )

    #_public
    (§ method int count()
        (§ let int c = 0)
        (§ for (ISeq s = seq() s != nil s = s.next()))
        (§
            (§ ass ++c)
        )
        (§ return (§ expr c))
    )

    #_public
    (§ method Object first()
        (§ call seq())
        (§ if (s == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr s.first()))
    )

    #_public
    (§ method ISeq next()
        (§ call seq())
        (§ if (s == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr s.next()))
    )

    #_public
    (§ method ISeq more()
        (§ call seq())
        (§ if (s == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr s.more()))
    )

    #_public
    (§ method ISeq cons(Object o)
        (§ return (§ expr RT.cons(o, seq())))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr PersistentList.EMPTY))
    )

    #_public
    (§ method boolean equiv(Object o)
        (§ let ISeq s = seq())
        (§ if (s != nil))
        (§
            (§ return (§ expr s.equiv(o)))
        )
        (§ else )
        (§
            (§ return (§ expr (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )
    )

    #_public
    (§ method int hashCode()
        (§ let ISeq s = seq())
        (§ if (s == nil))
        (§
            (§ return (§ expr 1))
        )
        (§ return (§ expr Util.hash(s)))
    )

    #_public
    (§ method int hasheq()
        (§ return (§ expr Murmur3.hashOrdered(this)))
    )

    #_public
    (§ method boolean equals(Object o)
        (§ let ISeq s = seq())
        (§ if (s != nil))
        (§
            (§ return (§ expr s.equals(o)))
        )
        (§ else )
        (§
            (§ return (§ expr (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )
    )

    #_public
    (§ method Object[] toArray()
        (§ return (§ expr RT.seqToArray(seq())))
    )

    #_public
    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean containsAll(Collection c)
        (§ for (Object o :in c))
        (§
            (§ if (!contains(o)))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    #_public
    (§ method Object[] toArray(Object[] a)
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    #_public
    (§ method int size()
        (§ return (§ expr count()))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (seq() == nil)))
    )

    #_public
    (§ method boolean contains(Object o)
        (§ for (ISeq s = seq() s != nil s = s.next()))
        (§
            (§ if (Util.equiv(s.first(), o)))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr new SeqIterator(this)))
    )

    #_private
    (§ method List reify()
        (§ return (§ expr new ArrayList(this)))
    )

    #_public
    (§ method List subList(int fromIndex, int toIndex)
        (§ return (§ expr reify().subList(fromIndex, toIndex)))
    )

    #_public
    (§ method Object set(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method Object remove(int index)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method int indexOf(Object o)
        (§ let ISeq s = seq())
        (§ for (int i = 0 s != nil s = s.next(), i++))
        (§
            (§ if (Util.equiv(s.first(), o)))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    #_public
    (§ method int lastIndexOf(Object o)
        (§ return (§ expr reify().lastIndexOf(o)))
    )

    #_public
    (§ method ListIterator listIterator()
        (§ return (§ expr reify().listIterator()))
    )

    #_public
    (§ method ListIterator listIterator(int index)
        (§ return (§ expr reify().listIterator(index)))
    )

    #_public
    (§ method Object get(int index)
        (§ return (§ expr RT.nth(this, index)))
    )

    #_public
    (§ method void add(int index, Object element)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(int index, Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_synchronized
    #_public
    (§ method boolean isRealized()
        (§ return (§ expr (fn == nil)))
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

#_public
(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.

    #_private
    #_static
    #_final
    (§ field int newline = (int) \newline)

    #_private
    (§ field boolean _atLineStart = true)
    #_private
    (§ field boolean _prev)
    #_private
    (§ field int _columnNumber = 1)

    #_public
    (§ method LineNumberingPushbackReader(Reader r)
        (§ super(new LineNumberReader(r)))
    )

    #_public
    (§ method LineNumberingPushbackReader(Reader r, int size)
        (§ super(new LineNumberReader(r, size)))
    )

    #_public
    (§ method int getLineNumber()
        (§ return (§ expr ((LineNumberReader) in).getLineNumber() + 1))
    )

    #_public
    (§ method void setLineNumber(int line)
        ((LineNumberReader) in).setLineNumber(line - 1)
    )

    #_public
    (§ method int getColumnNumber()
        (§ return (§ expr _columnNumber))
    )

    #_public
    (§ method int read() (§ throws IOException)
        (§ let int c = super.read())
        (§ ass _prev = _atLineStart)
        (§ if ((c == newline) || (c == -1)))
        (§
            (§ ass _atLineStart = true)
            (§ ass _columnNumber = 1)
        )
        (§ else )
        (§
            (§ ass _atLineStart = false)
            (§ ass _columnNumber++)
        )
        (§ return (§ expr c))
    )

    #_public
    (§ method void unread(int c) (§ throws IOException)
        (§ call super.unread(c))
        (§ ass _atLineStart = _prev)
        (§ ass _columnNumber--)
    )

    #_public
    (§ method String readLine() (§ throws IOException)
        (§ let int c = read())
        (§ let String line)
        (§ switch (c))
        (§
            (§ case -1)
            (§
                (§ ass line = nil)
                (§ break )
            )
            (§ case newline)
            (§
                (§ ass line = "")
                (§ break )
            )
            (§ default )
            (§
                (§ let String first = String.valueOf((char) c))
                (§ let String rest = ((LineNumberReader)in).readLine())
                (§ ass line = (rest == nil) ? first :or first + rest)
                (§ ass _prev = false)
                (§ ass _atLineStart = true)
                (§ ass _columnNumber = 1)
                (§ break )
            )
        )
        (§ return (§ expr line))
    )

    #_public
    (§ method boolean atLineStart()
        (§ return (§ expr _atLineStart))
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

#_public
(class-ns LispReader
    #_static
    #_final
    (§ field Symbol QUOTE = Symbol.intern("quote"))
    #_static
    #_final
    (§ field Symbol THE_VAR = Symbol.intern("var"))

    #_static
    (§ field Symbol UNQUOTE = Symbol.intern("cloiure.core", "unquote"))
    #_static
    (§ field Symbol UNQUOTE_SPLICING = Symbol.intern("cloiure.core", "unquote-splicing"))
    #_static
    (§ field Symbol CONCAT = Symbol.intern("cloiure.core", "concat"))
    #_static
    (§ field Symbol SEQ = Symbol.intern("cloiure.core", "seq"))
    #_static
    (§ field Symbol LIST = Symbol.intern("cloiure.core", "list"))
    #_static
    (§ field Symbol APPLY = Symbol.intern("cloiure.core", "apply"))
    #_static
    (§ field Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map"))
    #_static
    (§ field Symbol HASHSET = Symbol.intern("cloiure.core", "hash-set"))
    #_static
    (§ field Symbol VECTOR = Symbol.intern("cloiure.core", "vector"))
    #_static
    (§ field Symbol WITH_META = Symbol.intern("cloiure.core", "with-meta"))
    #_static
    (§ field Symbol META = Symbol.intern("cloiure.core", "meta"))
    #_static
    (§ field Symbol DEREF = Symbol.intern("cloiure.core", "deref"))
    #_static
    (§ field Symbol READ_COND = Symbol.intern("cloiure.core", "read-cond"))
    #_static
    (§ field Symbol READ_COND_SPLICING = Symbol.intern("cloiure.core", "read-cond-splicing"))
    #_static
    (§ field Keyword UNKNOWN = Keyword.intern(nil, "unknown"))

    #_static
    (§ field IFn[] macros = new IFn[256])
    #_static
    (§ field IFn[] dispatchMacros = new IFn[256])

    #_static
    (§ field Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    #_static
    (§ field Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    #_static
    (§ field Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)"))
    #_static
    (§ field Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    #_static
    (§ field Var GENSYM_ENV = Var.create(nil).setDynamic())
    ;; sorted-map num->gensymbol
    #_static
    (§ field Var ARG_ENV = Var.create(nil).setDynamic())
    #_static
    (§ field IFn ctorReader = new CtorReader())

    ;; Dynamic var set to true in a read-cond context
    #_static
    (§ field Var READ_COND_ENV = Var.create(nil).setDynamic())

    (§ static )
    (§
        (§ ass macros[\"] = new StringReader()) ;; oops! "
        (§ ass macros[\;] = new CommentReader())
        (§ ass macros[\'] = new WrappingReader(QUOTE))
        (§ ass macros[\@] = new WrappingReader(DEREF))
        (§ ass macros[\^] = new MetaReader())
        (§ ass macros[\`] = new SyntaxQuoteReader())
        (§ ass macros[\~] = new UnquoteReader())
        (§ ass macros[\(] = new ListReader())
        (§ ass macros[\)] = new UnmatchedDelimiterReader())
        (§ ass macros[\[] = new VectorReader())
        (§ ass macros[\]] = new UnmatchedDelimiterReader())
        (§ ass macros[\{] = new MapReader())
        (§ ass macros[\}] = new UnmatchedDelimiterReader())
        (§ ass macros[\\] = new CharacterReader())
        (§ ass macros[\%] = new ArgReader())
        (§ ass macros[\#] = new DispatchReader())

        (§ ass dispatchMacros[\^] = new MetaReader())
        (§ ass dispatchMacros[\#] = new SymbolicValueReader())
        (§ ass dispatchMacros[\'] = new VarReader())
        (§ ass dispatchMacros[\"] = new RegexReader()) ;; oops! "
        (§ ass dispatchMacros[\(] = new FnReader())
        (§ ass dispatchMacros[\{] = new SetReader())
        (§ ass dispatchMacros[\=] = new EvalReader())
        (§ ass dispatchMacros[\!] = new CommentReader())
        (§ ass dispatchMacros[\<] = new UnreadableReader())
        (§ ass dispatchMacros[\_] = new DiscardReader())
        (§ ass dispatchMacros[\?] = new ConditionalReader())
        (§ ass dispatchMacros[\:] = new NamespaceMapReader())
    )

    #_public
    #_static
    (§ interface Resolver
        (§ abstract Symbol currentNS())
        (§ abstract Symbol resolveClass(Symbol sym))
        (§ abstract Symbol resolveAlias(Symbol sym))
        (§ abstract Symbol resolveVar(Symbol sym))
    )

    #_static
    (§ method boolean isWhitespace(int ch)
        (§ return (§ expr (Character.isWhitespace(ch) || ch == \,)))
    )

    #_static
    (§ method void unread(PushbackReader r, int ch)
        (§ if (ch != -1))
        (§
            (§ try )
            (§
                (§ call r.unread(ch))
            )
            (§ catch (IOException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )
    )

    #_public
    #_static
    (class-ns ReaderException (§ extends RuntimeException)
        #_final
        (§ field int line)
        #_final
        (§ field int column)

        #_public
        (§ method ReaderException(int line, int column, Throwable cause)
            (§ super(cause))
            (§ ass this.line = line)
            (§ ass this.column = column)
        )
    )

    #_static
    #_public
    (§ method int read1(Reader r)
        (§ try )
        (§
            (§ return (§ expr r.read()))
        )
        (§ catch (IOException e))
        (§
            (§ throw Util.sneakyThrow(e))
        )
    )

    ;; Reader opts
    #_static
    #_public
    #_final
    (§ field Keyword OPT_EOF = Keyword.intern(nil, "eof"))
    #_static
    #_public
    #_final
    (§ field Keyword OPT_FEATURES = Keyword.intern(nil, "features"))
    #_static
    #_public
    #_final
    (§ field Keyword OPT_READ_COND = Keyword.intern(nil, "read-cond"))

    ;; EOF special value to throw on eof
    #_static
    #_public
    #_final
    (§ field Keyword EOFTHROW = Keyword.intern(nil, "eofthrow"))

    ;; Platform features - always installed
    #_static
    #_private
    #_final
    (§ field Keyword PLATFORM_KEY = Keyword.intern(nil, "cli"))
    #_static
    #_private
    #_final
    (§ field Object PLATFORM_FEATURES = PersistentHashSet.create(PLATFORM_KEY))

    ;; Reader conditional options - use with :read-cond
    #_static
    #_public
    #_final
    (§ field Keyword COND_ALLOW = Keyword.intern(nil, "allow"))
    #_static
    #_public
    #_final
    (§ field Keyword COND_PRESERVE = Keyword.intern(nil, "preserve"))

    #_static
    #_public
    (§ method Object read(PushbackReader r, Object opts)
        (§ let boolean eofIsError = true)
        (§ let Object eofValue = nil)
        (§ if (opts != nil && opts instanceof IPersistentMap))
        (§
            (§ let Object eof = ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW))
            (§ if (!EOFTHROW.equals(eof)))
            (§
                (§ ass eofIsError = false)
                (§ ass eofValue = eof)
            )
        )
        (§ return (§ expr read(r, eofIsError, eofValue, false, opts)))
    )

    #_static
    #_public
    (§ method Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive)
        (§ return (§ expr read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY)))
    )

    #_static
    #_public
    (§ method Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (§ return (§ expr read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, nil, (Resolver) RT.READER_RESOLVER.deref())))
    )

    #_static
    #_private
    (§ method Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts, Object pendingForms)
        (§ return (§ expr read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref())))
    )

    #_static
    #_private
    (§ method Object ensurePending(Object pendingForms)
        (§ if (pendingForms == nil))
        (§
            (§ return (§ expr new LinkedList()))
        )
        (§ else )
        (§
            (§ return (§ expr pendingForms))
        )
    )

    #_static
    #_private
    (§ method Object installPlatformFeature(Object opts)
        (§ if (opts == nil))
        (§
            (§ return (§ expr RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES)))
        )
        (§ else )
        (§
            (§ let IPersistentMap mopts = (IPersistentMap) opts)
            (§ let Object features = mopts.valAt(OPT_FEATURES))
            (§ if (features == nil))
            (§
                (§ return (§ expr mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES)))
            )
            (§ else )
            (§
                (§ return (§ expr mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY))))
            )
        )
    )

    #_static
    #_private
    (§ method Object read(PushbackReader r, boolean eofIsError, Object eofValue, Character returnOn, Object returnOnValue, boolean isRecursive, Object opts, Object pendingForms, Resolver resolver)
        (§ if (RT.READEVAL.deref() == UNKNOWN))
        (§
            (§ throw Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown"))
        )

        (§ ass opts = installPlatformFeature(opts))

        (§ try )
        (§
            (§ while (true))
            (§
                (§ if (pendingForms instanceof List && !((List)pendingForms).isEmpty()))
                (§
                    (§ return (§ expr ((List)pendingForms).remove(0)))
                )

                (§ let int ch = read1(r))

                (§ while (isWhitespace(ch)))
                (§
                    (§ ass ch = read1(r))
                )

                (§ if (ch == -1))
                (§
                    (§ if (eofIsError))
                    (§
                        (§ throw Util.runtimeException("EOF while reading"))
                    )
                    (§ return (§ expr eofValue))
                )

                (§ if (returnOn != nil && (returnOn.charValue() == ch)))
                (§
                    (§ return (§ expr returnOnValue))
                )

                (§ if (Character.isDigit(ch)))
                (§
                    (§ let Object n = readNumber(r, (char) ch))
                    (§ return (§ expr n))
                )

                (§ let IFn macroFn = getMacro(ch))
                (§ if (macroFn != nil))
                (§
                    (§ let Object ret = macroFn.invoke(r, (char) ch, opts, pendingForms))
                    ;; no op macros return the reader
                    (§ if (ret == r))
                    (§
                        (§ continue )
                    )
                    (§ return (§ expr ret))
                )

                (§ if (ch == \+ || ch == \-))
                (§
                    (§ let int ch2 = read1(r))
                    (§ if (Character.isDigit(ch2)))
                    (§
                        (§ call unread(r, ch2))
                        (§ let Object n = readNumber(r, (char) ch))
                        (§ return (§ expr n))
                    )
                    (§ call unread(r, ch2))
                )

                (§ let String token = readToken(r, (char) ch))
                (§ return (§ expr interpretToken(token, resolver)))
            )
        )
        (§ catch (Exception e))
        (§
            (§ if (isRecursive || !(r instanceof LineNumberingPushbackReader)))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ let LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r)
            (§ throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e))
        )
    )

    #_static
    #_private
    (§ method String readToken(PushbackReader r, char initch)
        (§ let StringBuilder sb = new StringBuilder())
        (§ call sb.append(initch))

        (§ while (true))
        (§
            (§ let int ch = read1(r))
            (§ if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch)))
            (§
                (§ call unread(r, ch))
                (§ return (§ expr sb.toString()))
            )
            (§ call sb.append((char) ch))
        )
    )

    #_static
    #_private
    (§ method Object readNumber(PushbackReader r, char initch)
        (§ let StringBuilder sb = new StringBuilder())
        (§ call sb.append(initch))

        (§ while (true))
        (§
            (§ let int ch = read1(r))
            (§ if (ch == -1 || isWhitespace(ch) || isMacro(ch)))
            (§
                (§ call unread(r, ch))
                (§ break )
            )
            (§ call sb.append((char) ch))
        )

        (§ let String s = sb.toString())
        (§ let Object n = matchNumber(s))
        (§ if (n == nil))
        (§
            (§ throw new NumberFormatException("Invalid number: " + s))
        )
        (§ return (§ expr n))
    )

    #_static
    #_private
    (§ method int readUnicodeChar(String token, int offset, int length, int base)
        (§ if (token.length() != offset + length))
        (§
            (§ throw new IllegalArgumentException("Invalid unicode character: \\" + token))
        )
        (§ let int uc = 0)
        (§ for (int i = offset i < offset + length ++i))
        (§
            (§ let int d = Character.digit(token.charAt(i), base))
            (§ if (d == -1))
            (§
                (§ throw new IllegalArgumentException("Invalid digit: " + token.charAt(i)))
            )
            (§ ass uc = uc * base + d)
        )
        (§ return (§ expr (char) uc))
    )

    #_static
    #_private
    (§ method int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
        (§ let int uc = Character.digit(initch, base))
        (§ if (uc == -1))
        (§
            (§ throw new IllegalArgumentException("Invalid digit: " + (char) initch))
        )
        (§ let int i = 1)
        (§ for (  i < length ++i))
        (§
            (§ let int ch = read1(r))
            (§ if (ch == -1 || isWhitespace(ch) || isMacro(ch)))
            (§
                (§ call unread(r, ch))
                (§ break )
            )
            (§ let int d = Character.digit(ch, base))
            (§ if (d == -1))
            (§
                (§ throw new IllegalArgumentException("Invalid digit: " + (char) ch))
            )
            (§ ass uc = uc * base + d)
        )
        (§ if (i != length && exact))
        (§
            (§ throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length))
        )
        (§ return (§ expr uc))
    )

    #_static
    #_private
    (§ method Object interpretToken(String s, Resolver resolver)
        (§ if (s.equals("nil")))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (s.equals("true")))
        (§
            (§ return (§ expr RT.T))
        )
        (§ elseif (s.equals("false")))
        (§
            (§ return (§ expr RT.F))
        )
        (§ let Object ret = nil)

        (§ ass ret = matchSymbol(s, resolver))
        (§ if (ret != nil))
        (§
            (§ return (§ expr ret))
        )

        (§ throw Util.runtimeException("Invalid token: " + s))
    )

    #_private
    #_static
    (§ method Object matchSymbol(String s, Resolver resolver)
        (§ let Matcher m = symbolPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ let int gc = m.groupCount())
            (§ let String ns = m.group(1))
            (§ let String name = m.group(2))
            (§ if (ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1))
            (§
                (§ return (§ expr nil))
            )
            (§ if (s.startsWith("::")))
            (§
                (§ let Symbol ks = Symbol.intern(s.substring(2)))
                (§ if (resolver != nil))
                (§
                    (§ let Symbol nsym)
                    (§ if (ks.ns != nil))
                    (§
                        (§ ass nsym = resolver.resolveAlias(Symbol.intern(ks.ns)))
                    )
                    (§ else )
                    (§
                        (§ ass nsym = resolver.currentNS())
                    )
                    ;; auto-resolving keyword
                    (§ if (nsym != nil))
                    (§
                        (§ return (§ expr Keyword.intern(nsym.name, ks.name)))
                    )
                    (§ else )
                    (§
                        (§ return (§ expr nil))
                    )
                )
                (§ else )
                (§
                    (§ let Namespace kns)
                    (§ if (ks.ns != nil))
                    (§
                        (§ ass kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns)))
                    )
                    (§ else )
                    (§
                        (§ ass kns = Compiler.currentNS())
                    )
                    ;; auto-resolving keyword
                    (§ if (kns != nil))
                    (§
                        (§ return (§ expr Keyword.intern(kns.name.name, ks.name)))
                    )
                    (§ else )
                    (§
                        (§ return (§ expr nil))
                    )
                )
            )
            (§ let boolean isKeyword = (s.charAt(0) == \:))
            (§ let Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0)))
            (§ if (isKeyword))
            (§
                (§ return (§ expr Keyword.intern(sym)))
            )
            (§ return (§ expr sym))
        )
        (§ return (§ expr nil))
    )

    #_private
    #_static
    (§ method Object matchNumber(String s)
        (§ let Matcher m = intPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ if (m.group(2) != nil))
            (§
                (§ if (m.group(8) != nil))
                (§
                    (§ return (§ expr BigInt.ZERO))
                )
                (§ return (§ expr Numbers.num(0)))
            )
            (§ let boolean negate = m.group(1).equals("-"))
            (§ let String n)
            (§ let int radix = 10)
            (§ if ((n = m.group(3)) != nil))
            (§
                (§ ass radix = 10)
            )
            (§ elseif ((n = m.group(4)) != nil))
            (§
                (§ ass radix = 16)
            )
            (§ elseif ((n = m.group(5)) != nil))
            (§
                (§ ass radix = 8)
            )
            (§ elseif ((n = m.group(7)) != nil))
            (§
                (§ ass radix = Integer.parseInt(m.group(6)))
            )
            (§ if (n == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ let BigInteger bn = new BigInteger(n, radix))
            (§ if (negate))
            (§
                (§ ass bn = bn.negate())
            )
            (§ if (m.group(8) != nil))
            (§
                (§ return (§ expr BigInt.fromBigInteger(bn)))
            )
            (§ return (§ expr (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
        )
        (§ ass m = floatPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ if (m.group(4) != nil))
            (§
                (§ return (§ expr new BigDecimal(m.group(1))))
            )
            (§ return (§ expr Double.parseDouble(s)))
        )
        (§ ass m = ratioPat.matcher(s))
        (§ if (m.matches()))
        (§
            (§ let String numerator = m.group(1))
            (§ if (numerator.startsWith("+")))
            (§
                (§ ass numerator = numerator.substring(1))
            )
            (§ return (§ expr Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_private
    (§ method IFn getMacro(int ch)
        (§ if (ch < macros.length))
        (§
            (§ return (§ expr macros[ch]))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_private
    (§ method boolean isMacro(int ch)
        (§ return (§ expr (ch < macros.length && macros[ch] != nil)))
    )

    #_static
    #_private
    (§ method boolean isTerminatingMacro(int ch)
        (§ return (§ expr (ch != \# && ch != \' && ch != \% && isMacro(ch))))
    )

    #_public
    #_static
    (class-ns RegexReader (§ extends AFn)
        #_static
        (§ field StringReader stringrdr = new StringReader())

        #_public
        (§ method Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
            (§ let StringBuilder sb = new StringBuilder())
            (§ let Reader r = (Reader) reader)
            (§ for (int ch = read1(r) ch != \" ch = read1(r))) ;; oops! "
            (§
                (§ if (ch == -1))
                (§
                    (§ throw Util.runtimeException("EOF while reading regex"))
                )
                (§ call sb.append((char) ch))
                (§ if (ch == \\)) ;; escape
                (§
                    (§ ass ch = read1(r))
                    (§ if (ch == -1))
                    (§
                        (§ throw Util.runtimeException("EOF while reading regex"))
                    )
                    (§ call sb.append((char) ch))
                )
            )
            (§ return (§ expr Pattern.compile(sb.toString())))
        )
    )

    #_public
    #_static
    (class-ns StringReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
            (§ let StringBuilder sb = new StringBuilder())
            (§ let Reader r = (Reader) reader)

            (§ for (int ch = read1(r) ch != \" ch = read1(r))) ;; oops! "
            (§
                (§ if (ch == -1))
                (§
                    (§ throw Util.runtimeException("EOF while reading string"))
                )
                (§ if (ch == \\)) ;; escape
                (§
                    (§ ass ch = read1(r))
                    (§ if (ch == -1))
                    (§
                        (§ throw Util.runtimeException("EOF while reading string"))
                    )
                    (§ switch (ch))
                    (§
                        (§ case \t)
                        (§
                            (§ ass ch = \tab)
                            (§ break )
                        )
                        (§ case \r)
                        (§
                            (§ ass ch = \return)
                            (§ break )
                        )
                        (§ case \n)
                        (§
                            (§ ass ch = \newline)
                            (§ break )
                        )
                        (§ case \\)
                        (§
                            (§ break )
                        )
                        (§ case \") ;; oops! "
                        (§
                            (§ break )
                        )
                        (§ case \b)
                        (§
                            (§ ass ch = \backspace)
                            (§ break )
                        )
                        (§ case \f)
                        (§
                            (§ ass ch = \formfeed)
                            (§ break )
                        )
                        (§ case \u)
                        (§
                            (§ ass ch = read1(r))
                            (§ if (Character.digit(ch, 16) == -1))
                            (§
                                (§ throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch))
                            )
                            (§ ass ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                            (§ break )
                        )
                        (§ default )
                        (§
                            (§ if (Character.isDigit(ch)))
                            (§
                                (§ ass ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                (§ if (ch > 0377))
                                (§
                                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                                )
                            )
                            (§ else )
                            (§
                                (§ throw Util.runtimeException("Unsupported escape character: \\" + (char) ch))
                            )
                            (§ break )
                        )
                    )
                )
                (§ call sb.append((char) ch))
            )
            (§ return (§ expr sb.toString()))
        )
    )

    #_public
    #_static
    (class-ns CommentReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object semicolon, Object opts, Object pendingForms)
            (§ let Reader r = (Reader) reader)
            (§ let int ch)
            (§ do
            (§
                (§ ass ch = read1(r))
            ) while (ch != -1 && ch != \newline && ch != \return))
            (§ return (§ expr r))
        )
    )

    #_public
    #_static
    (class-ns DiscardReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object underscore, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ call read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ return (§ expr r))
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    #_public
    #_static
    (class-ns NamespaceMapReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object colon, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)

            (§ let boolean auto = false)
            (§ let int autoChar = read1(r))
            (§ if (autoChar == \:))
            (§
                (§ ass auto = true)
            )
            (§ else )
            (§
                (§ call unread(r, autoChar))
            )

            (§ let Object sym = nil)
            (§ let int nextChar = read1(r))
            (§ if (isWhitespace(nextChar))) ;; the #:: { } case or an error
            (§
                (§ if (auto))
                (§
                    (§ while (isWhitespace(nextChar)))
                    (§
                        (§ ass nextChar = read1(r))
                    )
                    (§ if (nextChar != \{))
                    (§
                        (§ call unread(r, nextChar))
                        (§ throw Util.runtimeException("Namespaced map must specify a namespace"))
                    )
                )
                (§ else )
                (§
                    (§ call unread(r, nextChar))
                    (§ throw Util.runtimeException("Namespaced map must specify a namespace"))
                )
            )
            (§ elseif (nextChar != \{)) ;; #:foo { } or #::foo { }
            (§
                (§ call unread(r, nextChar))
                (§ ass sym = read(r, true, nil, false, opts, pendingForms))
                (§ ass nextChar = read1(r))
                (§ while (isWhitespace(nextChar)))
                (§
                    (§ ass nextChar = read1(r))
                )
            )
            (§ if (nextChar != \{))
            (§
                (§ throw Util.runtimeException("Namespaced map must specify a map"))
            )

            ;; Resolve autoresolved ns
            (§ let String ns)
            (§ if (auto))
            (§
                (§ let Resolver resolver = (Resolver) RT.READER_RESOLVER.deref())
                (§ if (sym == nil))
                (§
                    (§ if (resolver != nil))
                    (§
                        (§ ass ns = resolver.currentNS().name)
                    )
                    (§ else )
                    (§
                        (§ ass ns = Compiler.currentNS().getName().getName())
                    )
                )
                (§ elseif (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil))
                (§
                    (§ throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym))
                )
                (§ else )
                (§
                    (§ let Symbol resolvedNS)
                    (§ if (resolver != nil))
                    (§
                        (§ ass resolvedNS = resolver.resolveAlias((Symbol) sym))
                    )
                    (§ else )
                    (§
                        (§ let Namespace rns = Compiler.currentNS().lookupAlias((Symbol)sym))
                        (§ ass resolvedNS = (rns != nil) ? rns.getName() :or nil)
                    )

                    (§ if (resolvedNS == nil))
                    (§
                        (§ throw Util.runtimeException("Unknown auto-resolved namespace alias: " + sym))
                    )
                    (§ else )
                    (§
                        (§ ass ns = resolvedNS.getName())
                    )
                )
            )
            (§ elseif (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil))
            (§
                (§ throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym))
            )
            (§ else )
            (§
                (§ ass ns = ((Symbol)sym).getName())
            )

            ;; Read map
            (§ let List kvs = readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))
            (§ if ((kvs.size() & 1) == 1))
            (§
                (§ throw Util.runtimeException("Namespaced map literal must contain an even number of forms"))
            )

            ;; Construct output map
            (§ let Object[] a = new Object[kvs.size()])
            (§ let Iterator iter = kvs.iterator())
            (§ for (int i = 0 iter.hasNext() i += 2))
            (§
                (§ let Object key = iter.next())
                (§ let Object val = iter.next())

                (§ if (key instanceof Keyword))
                (§
                    (§ let Keyword kw = (Keyword) key)
                    (§ if (kw.getNamespace() == nil))
                    (§
                        (§ ass key = Keyword.intern(ns, kw.getName()))
                    )
                    (§ elseif (kw.getNamespace().equals("_")))
                    (§
                        (§ ass key = Keyword.intern(nil, kw.getName()))
                    )
                )
                (§ elseif (key instanceof Symbol))
                (§
                    (§ let Symbol s = (Symbol) key)
                    (§ if (s.getNamespace() == nil))
                    (§
                        (§ ass key = Symbol.intern(ns, s.getName()))
                    )
                    (§ elseif (s.getNamespace().equals("_")))
                    (§
                        (§ ass key = Symbol.intern(nil, s.getName()))
                    )
                )
                (§ ass a[i] = key)
                (§ ass a[i + 1] = val)
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    #_public
    #_static
    (class-ns SymbolicValueReader (§ extends AFn)
        #_static
        (§ field IPersistentMap  specials = PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        ))

        #_public
        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))

            (§ if (!(o instanceof Symbol)))
            (§
                (§ throw Util.runtimeException("Invalid token: ##" + o))
            )
            (§ if (!(specials.containsKey(o))))
            (§
                (§ throw Util.runtimeException("Unknown symbolic value: ##" + o))
            )

            (§ return (§ expr specials.valAt(o)))
        )
    )

    #_public
    #_static
    (class-ns WrappingReader (§ extends AFn)
        #_final
        (§ field Symbol sym)

        #_public
        (§ method WrappingReader(Symbol sym)
            (§ ass this.sym = sym)
        )

        #_public
        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ return (§ expr RT.list(sym, o)))
        )
    )

    #_public
    #_static
    (class-ns DeprecatedWrappingReader (§ extends AFn)
        #_final
        (§ field Symbol sym)
        #_final
        (§ field String macro)

        #_public
        (§ method DeprecatedWrappingReader(Symbol sym, String macro)
            (§ ass this.sym = sym)
            (§ ass this.macro = macro)
        )

        #_public
        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ call System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead"))
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ return (§ expr RT.list(sym, o)))
        )
    )

    #_public
    #_static
    (class-ns VarReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ return (§ expr RT.list(THE_VAR, o)))
        )
    )

    #_public
    #_static
    (class-ns DispatchReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object hash, Object opts, Object pendingForms)
            (§ let int ch = read1((Reader) reader))
            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let IFn fn = dispatchMacros[ch])

            ;; Try the ctor reader first
            (§ if (fn == nil))
            (§
                (§ call unread((PushbackReader) reader, ch))
                (§ ass pendingForms = ensurePending(pendingForms))
                (§ let Object result = ctorReader.invoke(reader, ch, opts, pendingForms))

                (§ if (result != nil))
                (§
                    (§ return (§ expr result))
                )
                (§ else )
                (§
                    (§ throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch)))
                )
            )
            (§ return (§ expr fn.invoke(reader, ch, opts, pendingForms)))
        )
    )

    #_static
    (§ method Symbol garg(int n)
        (§ return (§ expr Symbol.intern(nil, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#")))
    )

    #_public
    #_static
    (class-ns FnReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object lparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ if (ARG_ENV.deref() != nil))
            (§
                (§ throw new IllegalStateException("Nested #()s are not allowed"))
            )
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY)))
                (§ call unread(r, \())
                (§ let Object form = read(r, true, nil, true, opts, ensurePending(pendingForms)))

                (§ let PersistentVector args = PersistentVector.EMPTY)
                (§ let PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref())
                (§ let ISeq rargs = argsyms.rseq())
                (§ if (rargs != nil))
                (§
                    (§ let int higharg = (Integer) ((Map.Entry) rargs.first()).getKey())
                    (§ if (higharg > 0))
                    (§
                        (§ for (int i = 1 i <= higharg ++i))
                        (§
                            (§ let Object sym = argsyms.valAt(i))
                            (§ if (sym == nil))
                            (§
                                (§ ass sym = garg(i))
                            )
                            (§ ass args = args.cons(sym))
                        )
                    )
                    (§ let Object restsym = argsyms.valAt(-1))
                    (§ if (restsym != nil))
                    (§
                        (§ ass args = args.cons(Compiler._AMP_))
                        (§ ass args = args.cons(restsym))
                    )
                )
                (§ return (§ expr RT.list(Compiler.FN, args, form)))
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )
    )

    #_static
    (§ method Symbol registerArg(int n)
        (§ let PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref())
        (§ if (argsyms == nil))
        (§
            (§ throw new IllegalStateException("arg literal not in #()"))
        )
        (§ let Symbol ret = (Symbol) argsyms.valAt(n))
        (§ if (ret == nil))
        (§
            (§ ass ret = garg(n))
            (§ call ARG_ENV.set(argsyms.assoc(n, ret)))
        )
        (§ return (§ expr ret))
    )

    #_static
    (class-ns ArgReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object pct, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ if (ARG_ENV.deref() == nil))
            (§
                (§ return (§ expr interpretToken(readToken(r, \%), nil)))
            )
            (§ let int ch = read1(r))
            (§ call unread(r, ch))
            ;; % alone is first arg
            (§ if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch)))
            (§
                (§ return (§ expr registerArg(1)))
            )
            (§ let Object n = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ if (n.equals(Compiler._AMP_)))
            (§
                (§ return (§ expr registerArg(-1)))
            )
            (§ if (!(n instanceof Number)))
            (§
                (§ throw new IllegalStateException("arg literal must be %, %& or %integer"))
            )
            (§ return (§ expr registerArg(((Number) n).intValue())))
        )
    )

    #_public
    #_static
    (class-ns MetaReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object caret, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (r instanceof LineNumberingPushbackReader))
            (§
                (§ ass line = ((LineNumberingPushbackReader) r).getLineNumber())
                (§ ass column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ ass pendingForms = ensurePending(pendingForms))
            (§ let Object meta = read(r, true, nil, true, opts, pendingForms))
            (§ if (meta instanceof Symbol || meta instanceof String))
            (§
                (§ ass meta = RT.map(RT.TAG_KEY, meta))
            )
            (§ elseif (meta instanceof Keyword))
            (§
                (§ ass meta = RT.map(meta, RT.T))
            )
            (§ elseif (!(meta instanceof IPersistentMap)))
            (§
                (§ throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map"))
            )

            (§ let Object o = read(r, true, nil, true, opts, pendingForms))
            (§ if (o instanceof IMeta))
            (§
                (§ if (line != -1 && o instanceof ISeq))
                (§
                    (§ ass meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                )
                (§ if (o instanceof IReference))
                (§
                    ((IReference)o).resetMeta((IPersistentMap) meta)
                    (§ return (§ expr o))
                )
                (§ let Object ometa = RT.meta(o))
                (§ for (ISeq s = RT.seq(meta) s != nil s = s.next()))
                (§
                    (§ let IMapEntry kv = (IMapEntry) s.first())
                    (§ ass ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                )
                (§ return (§ expr ((IObj) o).withMeta((IPersistentMap) ometa)))
            )
            (§ else )
            (§
                (§ throw new IllegalArgumentException("Metadata can only be applied to IMetas"))
            )
        )
    )

    #_public
    #_static
    (class-ns SyntaxQuoteReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object backquote, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY)))

                (§ let Object form = read(r, true, nil, true, opts, ensurePending(pendingForms)))
                (§ return (§ expr syntaxQuote(form)))
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )

        #_static
        (§ method Object syntaxQuote(Object form)
            (§ let Object ret)
            (§ if (Compiler.isSpecial(form)))
            (§
                (§ ass ret = RT.list(Compiler.QUOTE, form))
            )
            (§ elseif (form instanceof Symbol))
            (§
                (§ let Resolver resolver = (Resolver) RT.READER_RESOLVER.deref())
                (§ let Symbol sym = (Symbol) form)
                (§ if (sym.ns == nil && sym.name.endsWith("#")))
                (§
                    (§ let IPersistentMap gmap = (IPersistentMap) GENSYM_ENV.deref())
                    (§ if (gmap == nil))
                    (§
                        (§ throw new IllegalStateException("Gensym literal not in syntax-quote"))
                    )
                    (§ let Symbol gs = (Symbol) gmap.valAt(sym))
                    (§ if (gs == nil))
                    (§
                        (§ call GENSYM_ENV.set(gmap.assoc(sym, gs = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__"))))
                    )
                    (§ ass sym = gs)
                )
                (§ elseif (sym.ns == nil && sym.name.endsWith(".")))
                (§
                    (§ let Symbol csym = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1)))
                    (§ if (resolver != nil))
                    (§
                        (§ let Symbol rc = resolver.resolveClass(csym))
                        (§ if (rc != nil))
                        (§
                            (§ ass csym = rc)
                        )
                    )
                    (§ else )
                    (§
                        (§ ass csym = Compiler.resolveSymbol(csym))
                    )
                    (§ ass sym = Symbol.intern(nil, csym.name.concat(".")))
                )
                (§ elseif (sym.ns == nil && sym.name.startsWith(".")))
                (§
                    ;; Simply quote method names.
                )
                (§ elseif (resolver != nil))
                (§
                    (§ let Symbol nsym = nil)
                    (§ if (sym.ns != nil))
                    (§
                        (§ let Symbol alias = Symbol.intern(nil, sym.ns))
                        (§ ass nsym = resolver.resolveClass(alias))
                        (§ if (nsym == nil))
                        (§
                            (§ ass nsym = resolver.resolveAlias(alias))
                        )
                    )
                    (§ if (nsym != nil))
                    (§
                        ;; Classname/foo -> package.qualified.Classname/foo
                        (§ ass sym = Symbol.intern(nsym.name, sym.name))
                    )
                    (§ elseif (sym.ns == nil))
                    (§
                        (§ let Symbol rsym = resolver.resolveClass(sym))
                        (§ if (rsym == nil))
                        (§
                            (§ ass rsym = resolver.resolveVar(sym))
                        )
                        (§ if (rsym != nil))
                        (§
                            (§ ass sym = rsym)
                        )
                        (§ else )
                        (§
                            (§ ass sym = Symbol.intern(resolver.currentNS().name, sym.name))
                        )
                    )
                    ;; leave alone if qualified
                )
                (§ else )
                (§
                    (§ let Object maybeClass = nil)
                    (§ if (sym.ns != nil))
                    (§
                        (§ ass maybeClass = Compiler.currentNS().getMapping(Symbol.intern(nil, sym.ns)))
                    )
                    (§ if (maybeClass instanceof Class))
                    (§
                        ;; Classname/foo -> package.qualified.Classname/foo
                        (§ ass sym = Symbol.intern(((Class)maybeClass).getName(), sym.name))
                    )
                    (§ else )
                    (§
                        (§ ass sym = Compiler.resolveSymbol(sym))
                    )
                )
                (§ ass ret = RT.list(Compiler.QUOTE, sym))
            )
            (§ elseif (isUnquote(form)))
            (§
                (§ return (§ expr RT.second(form)))
            )
            (§ elseif (isUnquoteSplicing(form)))
            (§
                (§ throw new IllegalStateException("splice not in list"))
            )
            (§ elseif (form instanceof IPersistentCollection))
            (§
                (§ if (form instanceof IRecord))
                (§
                    (§ ass ret = form)
                )
                (§ elseif (form instanceof IPersistentMap))
                (§
                    (§ let IPersistentVector keyvals = flattenMap(form))
                    (§ ass ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq())))))
                )
                (§ elseif (form instanceof IPersistentVector))
                (§
                    (§ ass ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq())))))
                )
                (§ elseif (form instanceof IPersistentSet))
                (§
                    (§ ass ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq())))))
                )
                (§ elseif (form instanceof ISeq || form instanceof IPersistentList))
                (§
                    (§ let ISeq seq = RT.seq(form))
                    (§ if (seq == nil))
                    (§
                        (§ ass ret = RT.cons(LIST, nil))
                    )
                    (§ else )
                    (§
                        (§ ass ret = RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq))))
                    )
                )
                (§ else )
                (§
                    (§ throw new UnsupportedOperationException("Unknown Collection type"))
                )
            )
            (§ elseif (form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String))
            (§
                (§ ass ret = form)
            )
            (§ else )
            (§
                (§ ass ret = RT.list(Compiler.QUOTE, form))
            )

            (§ if (form instanceof IObj && RT.meta(form) != nil))
            (§
                ;; filter line and column numbers
                (§ let IPersistentMap newMeta = ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY))
                (§ if (newMeta.count() > 0))
                (§
                    (§ return (§ expr RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))))
                )
            )
            (§ return (§ expr ret))
        )

        #_private
        #_static
        (§ method ISeq sqExpandList(ISeq seq)
            (§ let PersistentVector ret = PersistentVector.EMPTY)
            (§ for (  seq != nil seq = seq.next()))
            (§
                (§ let Object item = seq.first())
                (§ if (isUnquote(item)))
                (§
                    (§ ass ret = ret.cons(RT.list(LIST, RT.second(item))))
                )
                (§ elseif (isUnquoteSplicing(item)))
                (§
                    (§ ass ret = ret.cons(RT.second(item)))
                )
                (§ else )
                (§
                    (§ ass ret = ret.cons(RT.list(LIST, syntaxQuote(item))))
                )
            )
            (§ return (§ expr ret.seq()))
        )

        #_private
        #_static
        (§ method IPersistentVector flattenMap(Object form)
            (§ let IPersistentVector keyvals = PersistentVector.EMPTY)
            (§ for (ISeq s = RT.seq(form) s != nil s = s.next()))
            (§
                (§ let IMapEntry e = (IMapEntry) s.first())
                (§ ass keyvals = (IPersistentVector) keyvals.cons(e.key()))
                (§ ass keyvals = (IPersistentVector) keyvals.cons(e.val()))
            )
            (§ return (§ expr keyvals))
        )
    )

    #_static
    (§ method boolean isUnquoteSplicing(Object form)
        (§ return (§ expr form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING)))
    )

    #_static
    (§ method boolean isUnquote(Object form)
        (§ return (§ expr form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE)))
    )

    #_static
    (class-ns UnquoteReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object comma, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ ass pendingForms = ensurePending(pendingForms))
            (§ if (ch == \@))
            (§
                (§ let Object o = read(r, true, nil, true, opts, pendingForms))
                (§ return (§ expr RT.list(UNQUOTE_SPLICING, o)))
            )
            (§ else )
            (§
                (§ call unread(r, ch))
                (§ let Object o = read(r, true, nil, true, opts, pendingForms))
                (§ return (§ expr RT.list(UNQUOTE, o)))
            )
        )
    )

    #_public
    #_static
    (class-ns CharacterReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object backslash, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )
            (§ let String token = readToken(r, (char) ch))
            (§ if (token.length() == 1))
            (§
                (§ return (§ expr Character.valueOf(token.charAt(0))))
            )
            (§ elseif (token.equals("newline")))
            (§
                (§ return (§ expr \newline))
            )
            (§ elseif (token.equals("space")))
            (§
                (§ return (§ expr \space))
            )
            (§ elseif (token.equals("tab")))
            (§
                (§ return (§ expr \tab))
            )
            (§ elseif (token.equals("backspace")))
            (§
                (§ return (§ expr \backspace))
            )
            (§ elseif (token.equals("formfeed")))
            (§
                (§ return (§ expr \formfeed))
            )
            (§ elseif (token.equals("return")))
            (§
                (§ return (§ expr \return))
            )
            (§ elseif (token.startsWith("u")))
            (§
                (§ let char c = (char) readUnicodeChar(token, 1, 4, 16))
                (§ if (c >= (§ char "\ud800") && c <= (§ char "\udfff"))) ;; surrogate code unit?
                (§
                    (§ throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16)))
                )
                (§ return (§ expr c))
            )
            (§ elseif (token.startsWith("o")))
            (§
                (§ let int len = token.length() - 1)
                (§ if (len > 3))
                (§
                    (§ throw Util.runtimeException("Invalid octal escape sequence length: " + len))
                )
                (§ let int uc = readUnicodeChar(token, 1, len, 8))
                (§ if (uc > 0377))
                (§
                    (§ throw Util.runtimeException("Octal escape sequence must be in range [0, 377]."))
                )
                (§ return (§ expr (char) uc))
            )
            (§ throw Util.runtimeException("Unsupported character: \\" + token))
        )
    )

    #_public
    #_static
    (class-ns ListReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int line = -1)
            (§ let int column = -1)
            (§ if (r instanceof LineNumberingPushbackReader))
            (§
                (§ ass line = ((LineNumberingPushbackReader) r).getLineNumber())
                (§ ass column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
            )
            (§ let List list = readDelimitedList(\), r, true, opts, ensurePending(pendingForms)))
            (§ if (list.isEmpty()))
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ let IObj s = (IObj) PersistentList.create(list))
            (§ if (line != -1))
            (§
                (§ return (§ expr s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column))))
            )
            (§ else )
            (§
                (§ return (§ expr s))
            )
        )
    )

    #_public
    #_static
    (class-ns EvalReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object eq, Object opts, Object pendingForms)
            (§ if (!RT.booleanCast(RT.READEVAL.deref())))
            (§
                (§ throw Util.runtimeException("EvalReader not allowed when *read-eval* is false."))
            )

            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object o = read(r, true, nil, true, opts, ensurePending(pendingForms)))
            (§ if (o instanceof Symbol))
            (§
                (§ return (§ expr RT.classForName(o.toString())))
            )
            (§ elseif (o instanceof IPersistentList))
            (§
                (§ let Symbol fs = (Symbol) RT.first(o))
                (§ if (fs.equals(THE_VAR)))
                (§
                    (§ let Symbol vs = (Symbol) RT.second(o))
                    (§ return (§ expr RT.var(vs.ns, vs.name)))
                )
                (§ if (fs.name.endsWith(".")))
                (§
                    (§ let Object[] args = RT.toArray(RT.next(o)))
                    (§ return (§ expr Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)))
                )
                (§ if (Compiler.namesStaticMember(fs)))
                (§
                    (§ let Object[] args = RT.toArray(RT.next(o)))
                    (§ return (§ expr Reflector.invokeStaticMethod(fs.ns, fs.name, args)))
                )
                (§ let Object v = Compiler.maybeResolveIn(Compiler.currentNS(), fs))
                (§ if (v instanceof Var))
                (§
                    (§ return (§ expr ((IFn) v).applyTo(RT.next(o))))
                )
                (§ throw Util.runtimeException("Can't resolve " + fs))
            )
            (§ else )
            (§
                (§ throw new IllegalArgumentException("Unsupported #= form"))
            )
        )
    )

    #_public
    #_static
    (class-ns VectorReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ return (§ expr LazilyPersistentVector.create(readDelimitedList(\], r, true, opts, ensurePending(pendingForms)))))
        )
    )

    #_public
    #_static
    (class-ns MapReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let Object[] a = readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)).toArray())
            (§ if ((a.length & 1) == 1))
            (§
                (§ throw Util.runtimeException("Map literal must contain an even number of forms"))
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    #_public
    #_static
    (class-ns SetReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftbracket, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ return (§ expr PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))))
        )
    )

    #_public
    #_static
    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object rightdelim, Object opts, Object pendingForms)
            (§ throw Util.runtimeException("Unmatched delimiter: " + rightdelim))
        )
    )

    #_public
    #_static
    (class-ns UnreadableReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object leftangle, Object opts, Object pendingForms)
            (§ throw Util.runtimeException("Unreadable form"))
        )
    )

    ;; Sentinel values for reading lists
    #_private
    #_static
    #_final
    (§ field Object READ_EOF = new Object())
    #_private
    #_static
    #_final
    (§ field Object READ_FINISHED = new Object())

    #_public
    #_static
    (§ method List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts, Object pendingForms)
        (§ let final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)

        (§ let ArrayList a = new ArrayList())
        (§ let Resolver resolver = (Resolver) RT.READER_RESOLVER.deref())

        (§ while (true))
        (§
            (§ let Object form = read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver))

            (§ if (form == READ_EOF))
            (§
                (§ if (firstline < 0))
                (§
                    (§ throw Util.runtimeException("EOF while reading"))
                )
                (§ else )
                (§
                    (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                )
            )
            (§ elseif (form == READ_FINISHED))
            (§
                (§ return (§ expr a))
            )

            (§ call a.add(form))
        )
    )

    #_public
    #_static
    (class-ns CtorReader (§ extends AFn)
        #_public
        (§ method Object invoke(Object reader, Object firstChar, Object opts, Object pendingForms)
            (§ let PushbackReader r = (PushbackReader) reader)
            (§ ass pendingForms = ensurePending(pendingForms))
            (§ let Object name = read(r, true, nil, false, opts, pendingForms))
            (§ if (!(name instanceof Symbol)))
            (§
                (§ throw new RuntimeException("Reader tag must be a symbol"))
            )
            (§ let Symbol sym = (Symbol)name)
            (§ let Object form = read(r, true, nil, true, opts, pendingForms))

            (§ if (isPreserveReadCond(opts) || RT.suppressRead()))
            (§
                (§ return (§ expr TaggedLiteral.create(sym, form)))
            )
            (§ else )
            (§
                (§ return (§ expr sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms)))
            )
        )

        #_private
        (§ method Object readTagged(Object o, Symbol tag, Object opts, Object pendingForms)
            (§ let ILookup data_readers = (ILookup)RT.DATA_READERS.deref())
            (§ let IFn data_reader = (IFn)RT.get(data_readers, tag))
            (§ if (data_reader == nil))
            (§
                (§ ass data_readers = (ILookup)RT.DEFAULT_DATA_READERS.deref())
                (§ ass data_reader = (IFn)RT.get(data_readers, tag))
                (§ if (data_reader == nil))
                (§
                    (§ let IFn default_reader = (IFn)RT.DEFAULT_DATA_READER_FN.deref())
                    (§ if (default_reader != nil))
                    (§
                        (§ return (§ expr default_reader.invoke(tag, o)))
                    )
                    (§ else )
                    (§
                        (§ throw new RuntimeException("No reader function for tag " + tag.toString()))
                    )
                )
            )

            (§ return (§ expr data_reader.invoke(o)))
        )

        #_private
        (§ method Object readRecord(Object form, Symbol recordName, Object opts, Object pendingForms)
            (§ let boolean readeval = RT.booleanCast(RT.READEVAL.deref()))

            (§ if (!readeval))
            (§
                (§ throw Util.runtimeException("Record construction syntax can only be used when *read-eval* == true"))
            )

            (§ let Class recordClass = RT.classForNameNonLoading(recordName.toString()))

            (§ let boolean shortForm = true)

            (§ if (form instanceof IPersistentMap))
            (§
                (§ ass shortForm = false)
            )
            (§ elseif (form instanceof IPersistentVector))
            (§
                (§ ass shortForm = true)
            )
            (§ else )
            (§
                (§ throw Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\""))
            )

            (§ let Object ret = nil)
            (§ let Constructor[] allctors = ((Class)recordClass).getConstructors())

            (§ if (shortForm))
            (§
                (§ let IPersistentVector recordEntries = (IPersistentVector)form)
                (§ let boolean ctorFound = false)
                (§ for (Constructor ctor :in allctors))
                (§
                    (§ if (ctor.getParameterTypes().length == recordEntries.count()))
                    (§
                        (§ ass ctorFound = true)
                    )
                )

                (§ if (!ctorFound))
                (§
                    (§ throw Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count()))
                )

                (§ ass ret = Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries)))
            )
            (§ else )
            (§
                (§ let IPersistentMap vals = (IPersistentMap)form)
                (§ for (ISeq s = RT.keys(vals) s != nil s = s.next()))
                (§
                    (§ if (!(s.first() instanceof Keyword)))
                    (§
                        (§ throw Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString()))
                    )
                )
                (§ ass ret = Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ vals )))
            )

            (§ return (§ expr ret))
        )
    )

    #_static
    (§ method boolean isPreserveReadCond(Object opts)
        (§ if (RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap))
        (§
            (§ let Object readCond = ((IPersistentMap) opts).valAt(OPT_READ_COND))
            (§ return (§ expr COND_PRESERVE.equals(readCond)))
        )
        (§ else )
        (§
            (§ return (§ expr false))
        )
    )

    #_public
    #_static
    (class-ns ConditionalReader (§ extends AFn)
        #_final
        #_static
        #_private
        (§ field Object READ_STARTED = new Object())
        #_final
        #_static
        #_public
        (§ field Keyword DEFAULT_FEATURE = Keyword.intern(nil, "default"))
        #_final
        #_static
        #_public
        (§ field IPersistentSet RESERVED_FEATURES = RT.set(Keyword.intern(nil, "else"), Keyword.intern(nil, "none")))

        #_public
        #_static
        (§ method boolean hasFeature(Object feature, Object opts)
            (§ if (!(feature instanceof Keyword)))
            (§
                (§ throw Util.runtimeException("Feature should be a keyword: " + feature))
            )

            (§ if (DEFAULT_FEATURE.equals(feature)))
            (§
                (§ return (§ expr true))
            )

            (§ let IPersistentSet custom = (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES))
            (§ return (§ expr (custom != nil && custom.contains(feature))))
        )

        #_public
        #_static
        (§ method Object readCondDelimited(PushbackReader r, boolean splicing, Object opts, Object pendingForms)
            (§ let Object result = READ_STARTED)
            (§ let Object form) ;; The most recently ready form
            (§ let boolean toplevel = (pendingForms == nil))
            (§ ass pendingForms = ensurePending(pendingForms))

            (§ let final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)

            (§ while (true))
            (§
                (§ if (result == READ_STARTED))
                (§
                    ;; Read the next feature
                    (§ ass form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, nil))

                    (§ if (form == READ_EOF))
                    (§
                        (§ if (firstline < 0))
                        (§
                            (§ throw Util.runtimeException("EOF while reading"))
                        )
                        (§ else )
                        (§
                            (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                        )
                    )
                    (§ elseif (form == READ_FINISHED))
                    (§
                        (§ break ) ;; read-cond form is done
                    )

                    (§ if (RESERVED_FEATURES.contains(form)))
                    (§
                        (§ throw Util.runtimeException("Feature name " + form + " is reserved."))
                    )

                    (§ if (hasFeature(form, opts)))
                    (§
                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                        (§ ass form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                        (§ if (form == READ_EOF))
                        (§
                            (§ if (firstline < 0))
                            (§
                                (§ throw Util.runtimeException("EOF while reading"))
                            )
                            (§ else )
                            (§
                                (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                            )
                        )
                        (§ elseif (form == READ_FINISHED))
                        (§
                            (§ if (firstline < 0))
                            (§
                                (§ throw Util.runtimeException("read-cond requires an even number of forms."))
                            )
                            (§ else )
                            (§
                                (§ throw Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms"))
                            )
                        )
                        (§ else )
                        (§
                            (§ ass result = form)
                        )
                    )
                )

                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T)))
                    (§ ass form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                    (§ if (form == READ_EOF))
                    (§
                        (§ if (firstline < 0))
                        (§
                            (§ throw Util.runtimeException("EOF while reading"))
                        )
                        (§ else )
                        (§
                            (§ throw Util.runtimeException("EOF while reading, starting at line " + firstline))
                        )
                    )
                    (§ elseif (form == READ_FINISHED))
                    (§
                        (§ break )
                    )
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
            )

            (§ if (result == READ_STARTED)) ;; no features matched
            (§
                (§ return (§ expr r))
            )

            (§ if (splicing))
            (§
                (§ if (!(result instanceof List)))
                (§
                    (§ throw Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List"))
                )

                (§ if (toplevel))
                (§
                    (§ throw Util.runtimeException("Reader conditional splicing not allowed at the top level."))
                )

                ((List)pendingForms).addAll(0, (List)result)

                (§ return (§ expr r))
            )
            (§ else )
            (§
                (§ return (§ expr result))
            )
        )

        #_private
        #_static
        (§ method void checkConditionalAllowed(Object opts)
            (§ let IPersistentMap mopts = (IPersistentMap)opts)
            (§ if (!(opts != nil && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND))))))
            (§
                (§ throw Util.runtimeException("Conditional read not allowed"))
            )
        )

        #_public
        (§ method Object invoke(Object reader, Object mode, Object opts, Object pendingForms)
            (§ call checkConditionalAllowed(opts))

            (§ let PushbackReader r = (PushbackReader) reader)
            (§ let int ch = read1(r))
            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )

            (§ let boolean splicing = false)

            (§ if (ch == \@))
            (§
                (§ ass splicing = true)
                (§ ass ch = read1(r))
            )

            (§ while (isWhitespace(ch)))
            (§
                (§ ass ch = read1(r))
            )

            (§ if (ch == -1))
            (§
                (§ throw Util.runtimeException("EOF while reading character"))
            )

            (§ if (ch != \())
            (§
                (§ throw Util.runtimeException("read-cond body must be a list"))
            )

            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T)))

                (§ if (isPreserveReadCond(opts)))
                (§
                    (§ let IFn listReader = getMacro(ch)) ;; should always be a list
                    (§ let Object form = listReader.invoke(r, ch, opts, ensurePending(pendingForms)))

                    (§ return (§ expr ReaderConditional.create(form, splicing)))
                )
                (§ else )
                (§
                    (§ return (§ expr readCondDelimited(r, splicing, opts, pendingForms)))
                )
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(§ anno @SuppressWarnings((§ "SynchronizeOnNonFinalField" )))
#_public
(class-ns LockingTransaction
    #_public
    #_static
    #_final
    (§ field int RETRY_LIMIT = 10000)
    #_public
    #_static
    #_final
    (§ field int LOCK_WAIT_MSECS = 100)
    #_public
    #_static
    #_final
    (§ field long BARGE_WAIT_NANOS = 10 * 1000000)

    #_static
    #_final
    (§ field int RUNNING = 0)
    #_static
    #_final
    (§ field int COMMITTING = 1)
    #_static
    #_final
    (§ field int RETRY = 2)
    #_static
    #_final
    (§ field int KILLED = 3)
    #_static
    #_final
    (§ field int COMMITTED = 4)

    #_final
    #_static
    (§ field ThreadLocal<LockingTransaction> transaction = new ThreadLocal<LockingTransaction>())

    #_static
    (class-ns RetryEx (§ extends Error)
    )

    #_static
    (class-ns AbortException (§ extends Exception)
    )

    #_public
    #_static
    (class-ns Info
        #_final
        (§ field AtomicInteger status)
        #_final
        (§ field long startPoint)
        #_final
        (§ field CountDownLatch latch)

        #_public
        (§ method Info(int status, long startPoint)
            (§ ass this.status = new AtomicInteger(status))
            (§ ass this.startPoint = startPoint)
            (§ ass this.latch = new CountDownLatch(1))
        )

        #_public
        (§ method boolean running()
            (§ let int s = status.get())
            (§ return (§ expr (s == RUNNING || s == COMMITTING)))
        )
    )

    #_static
    (class-ns CFn
        #_final
        (§ field IFn fn)
        #_final
        (§ field ISeq args)

        #_public
        (§ method CFn(IFn fn, ISeq args)
            (§ ass this.fn = fn)
            (§ ass this.args = args)
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    #_final
    #_private
    #_static
    (§ field AtomicLong lastPoint = new AtomicLong())

    (§ method void getReadPoint()
        (§ ass readPoint = lastPoint.incrementAndGet())
    )

    (§ method long getCommitPoint()
        (§ return (§ expr lastPoint.incrementAndGet()))
    )

    (§ method void stop(int status)
        (§ if (info != nil))
        (§
            (§ synchronized (info))
            (§
                (§ call info.status.set(status))
                (§ call info.latch.countDown())
            )
            (§ ass info = nil)
            (§ call vals.clear())
            (§ call sets.clear())
            (§ call commutes.clear())
        )
    )

    (§ field Info info)
    (§ field long readPoint)
    (§ field long startPoint)
    (§ field long startTime)

    #_final
    (§ field RetryEx retryex = new RetryEx())
    #_final
    (§ field ArrayList<Agent.Action> actions = new ArrayList<Agent.Action>())
    #_final
    (§ field HashMap<Ref, Object> vals = new HashMap<Ref, Object>())
    #_final
    (§ field HashSet<Ref> sets = new HashSet<Ref>())
    #_final
    (§ field TreeMap<Ref, ArrayList<CFn>> commutes = new TreeMap<Ref, ArrayList<CFn>>())

    #_final
    (§ field HashSet<Ref> ensures = new HashSet<Ref>()) ;; all hold readLock

    (§ method void tryWriteLock(Ref ref)
        (§ try )
        (§
            (§ if (!ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS)))
            (§
                (§ throw retryex)
            )
        )
        (§ catch (InterruptedException e))
        (§
            (§ throw retryex)
        )
    )

    ;; returns the most recent val
    (§ method Object lock(Ref ref)
        ;; can't upgrade readLock, so release it
        (§ call releaseIfEnsured(ref))

        (§ let boolean unlocked = true)
        (§ try )
        (§
            (§ call tryWriteLock(ref))
            (§ ass unlocked = false)

            (§ if (ref.tvals != nil && ref.tvals.point > readPoint))
            (§
                (§ throw retryex)
            )
            (§ let Info refinfo = ref.tinfo)

            ;; write lock conflict
            (§ if (refinfo != nil && refinfo != info && refinfo.running()))
            (§
                (§ if (!barge(refinfo)))
                (§
                    (§ call ref.lock.writeLock().unlock())
                    (§ ass unlocked = true)
                    (§ return (§ expr blockAndBail(refinfo)))
                )
            )
            (§ ass ref.tinfo = info)
            (§ return (§ expr (ref.tvals == nil) ? nil :or ref.tvals.val))
        )
        (§ finally )
        (§
            (§ if (!unlocked))
            (§
                (§ call ref.lock.writeLock().unlock())
            )
        )
    )

    #_private
    (§ method Object blockAndBail(Info refinfo)
        ;; stop prior to blocking
        (§ call stop(RETRY))
        (§ try )
        (§
            (§ call refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
        )
        (§ catch (InterruptedException e))
        (§
            ;; ignore
        )
        (§ throw retryex)
    )

    #_private
    (§ method void releaseIfEnsured(Ref ref)
        (§ if (ensures.contains(ref)))
        (§
            (§ call ensures.remove(ref))
            (§ call ref.lock.readLock().unlock())
        )
    )

    (§ method void abort() (§ throws AbortException)
        (§ call stop(KILLED))
        (§ throw new AbortException())
    )

    #_private
    (§ method boolean bargeTimeElapsed()
        (§ return (§ expr (System.nanoTime() - startTime > BARGE_WAIT_NANOS)))
    )

    #_private
    (§ method boolean barge(Info refinfo)
        (§ let boolean barged = false)
        ;; if this transaction is older, try to abort the other
        (§ if (bargeTimeElapsed() && startPoint < refinfo.startPoint))
        (§
            (§ ass barged = refinfo.status.compareAndSet(RUNNING, KILLED))
            (§ if (barged))
            (§
                (§ call refinfo.latch.countDown())
            )
        )
        (§ return (§ expr barged))
    )

    #_static
    (§ method LockingTransaction getEx()
        (§ let LockingTransaction t = transaction.get())
        (§ if (t == nil || t.info == nil))
        (§
            (§ throw new IllegalStateException("No transaction running"))
        )
        (§ return (§ expr t))
    )

    #_static
    #_public
    (§ method boolean isRunning()
        (§ return (§ expr (getRunning() != nil)))
    )

    #_static
    (§ method LockingTransaction getRunning()
        (§ let LockingTransaction t = transaction.get())
        (§ if (t == nil || t.info == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr t))
    )

    #_static
    #_public
    (§ method Object runInTransaction(Callable fn) (§ throws Exception)
        (§ let LockingTransaction t = transaction.get())
        (§ let Object ret)
        (§ if (t == nil))
        (§
            (§ call transaction.set(t = new LockingTransaction()))
            (§ try )
            (§
                (§ ass ret = t.run(fn))
            )
            (§ finally )
            (§
                (§ call transaction.remove())
            )
        )
        (§ else )
        (§
            (§ if (t.info != nil))
            (§
                (§ ass ret = fn.call())
            )
            (§ else )
            (§
                (§ ass ret = t.run(fn))
            )
        )

        (§ return (§ expr ret))
    )

    #_static
    (class-ns Notify
        #_final
        #_public
        (§ field Ref ref)
        #_final
        #_public
        (§ field Object oldval)
        #_final
        #_public
        (§ field Object newval)

        (§ method Notify(Ref ref, Object oldval, Object newval)
            (§ ass this.ref = ref)
            (§ ass this.oldval = oldval)
            (§ ass this.newval = newval)
        )
    )

    (§ method Object run(Callable fn) (§ throws Exception)
        (§ let boolean done = false)
        (§ let Object ret = nil)
        (§ let ArrayList<Ref> locked = new ArrayList<Ref>())
        (§ let ArrayList<Notify> notify = new ArrayList<Notify>())

        (§ for (int i = 0 !done && i < RETRY_LIMIT i++))
        (§
            (§ try )
            (§
                (§ call getReadPoint())
                (§ if (i == 0))
                (§
                    (§ ass startPoint = readPoint)
                    (§ ass startTime = System.nanoTime())
                )
                (§ ass info = new Info(RUNNING, startPoint))
                (§ ass ret = fn.call())
                ;; make sure no one has killed us before this point, and can't from now on
                (§ if (info.status.compareAndSet(RUNNING, COMMITTING)))
                (§
                    (§ for (Map.Entry<Ref, ArrayList<CFn>> e :in commutes.entrySet()))
                    (§
                        (§ let Ref ref = e.getKey())
                        (§ if (sets.contains(ref)))
                        (§
                            (§ continue )
                        )

                        (§ let boolean wasEnsured = ensures.contains(ref))
                        ;; can't upgrade readLock, so release it
                        (§ call releaseIfEnsured(ref))
                        (§ call tryWriteLock(ref))
                        (§ call locked.add(ref))
                        (§ if (wasEnsured && ref.tvals != nil && ref.tvals.point > readPoint))
                        (§
                            (§ throw retryex)
                        )

                        (§ let Info refinfo = ref.tinfo)
                        (§ if (refinfo != nil && refinfo != info && refinfo.running()))
                        (§
                            (§ if (!barge(refinfo)))
                            (§
                                (§ throw retryex)
                            )
                        )
                        (§ let Object val = (ref.tvals == nil) ? nil :or ref.tvals.val)
                        (§ call vals.put(ref, val))
                        (§ for (CFn f :in e.getValue()))
                        (§
                            (§ call vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args))))
                        )
                    )
                    (§ for (Ref ref :in sets))
                    (§
                        (§ call tryWriteLock(ref))
                        (§ call locked.add(ref))
                    )

                    ;; validate and enqueue notifications
                    (§ for (Map.Entry<Ref, Object> e :in vals.entrySet()))
                    (§
                        (§ let Ref ref = e.getKey())
                        (§ call ref.validate(ref.getValidator(), e.getValue()))
                    )

                    ;; at this point, all values calced, all refs to be written locked
                    ;; no more client code to be called
                    (§ let long commitPoint = getCommitPoint())
                    (§ for (Map.Entry<Ref, Object> e :in vals.entrySet()))
                    (§
                        (§ let Ref ref = e.getKey())
                        (§ let Object oldval = (ref.tvals == nil) ? nil :or ref.tvals.val)
                        (§ let Object newval = e.getValue())
                        (§ let int hcount = ref.histCount())

                        (§ if (ref.tvals == nil))
                        (§
                            (§ ass ref.tvals = new Ref.TVal(newval, commitPoint))
                        )
                        (§ elseif ((ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory))
                        (§
                            (§ ass ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals))
                            (§ call ref.faults.set(0))
                        )
                        (§ else )
                        (§
                            (§ ass ref.tvals = ref.tvals.next)
                            (§ ass ref.tvals.val = newval)
                            (§ ass ref.tvals.point = commitPoint)
                        )
                        (§ if (ref.getWatches().count() > 0))
                        (§
                            (§ call notify.add(new Notify(ref, oldval, newval)))
                        )
                    )

                    (§ ass done = true)
                    (§ call info.status.set(COMMITTED))
                )
            )
            (§ catch (RetryEx retry))
            (§
                ;; eat this so we retry rather than fall out
            )
            (§ finally )
            (§
                (§ for (int k = locked.size() - 1 k >= 0 --k))
                (§
                    (§ call locked.get(k).lock.writeLock().unlock())
                )
                (§ call locked.clear())
                (§ for (Ref r :in ensures))
                (§
                    (§ call r.lock.readLock().unlock())
                )
                (§ call ensures.clear())
                (§ call stop(done ? COMMITTED :or RETRY))
                (§ try )
                (§
                    (§ if (done)) ;; re-dispatch out of transaction
                    (§
                        (§ for (Notify n :in notify))
                        (§
                            (§ call n.ref.notifyWatches(n.oldval, n.newval))
                        )
                        (§ for (Agent.Action action :in actions))
                        (§
                            (§ call Agent.dispatchAction(action))
                        )
                    )
                )
                (§ finally )
                (§
                    (§ call notify.clear())
                    (§ call actions.clear())
                )
            )
        )
        (§ if (!done))
        (§
            (§ throw Util.runtimeException("Transaction failed after reaching retry limit"))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method void enqueue(Agent.Action action)
        (§ call actions.add(action))
    )

    (§ method Object doGet(Ref ref)
        (§ if (!info.running()))
        (§
            (§ throw retryex)
        )
        (§ if (vals.containsKey(ref)))
        (§
            (§ return (§ expr vals.get(ref)))
        )
        (§ try )
        (§
            (§ call ref.lock.readLock().lock())
            (§ if (ref.tvals == nil))
            (§
                (§ throw new IllegalStateException(ref.toString() + " is unbound."))
            )
            (§ let Ref.TVal ver = ref.tvals)
            (§ do
            (§
                (§ if (ver.point <= readPoint))
                (§
                    (§ return (§ expr ver.val))
                )
            ) while ((ver = ver.prior) != ref.tvals))
        )
        (§ finally )
        (§
            (§ call ref.lock.readLock().unlock())
        )
        ;; no version of val precedes the read point
        (§ call ref.faults.incrementAndGet())
        (§ throw retryex)
    )

    (§ method Object doSet(Ref ref, Object val)
        (§ if (!info.running()))
        (§
            (§ throw retryex)
        )
        (§ if (commutes.containsKey(ref)))
        (§
            (§ throw new IllegalStateException("Can't set after commute"))
        )
        (§ if (!sets.contains(ref)))
        (§
            (§ call sets.add(ref))
            (§ call lock(ref))
        )
        (§ call vals.put(ref, val))
        (§ return (§ expr val))
    )

    (§ method void doEnsure(Ref ref)
        (§ if (!info.running()))
        (§
            (§ throw retryex)
        )
        (§ if (ensures.contains(ref)))
        (§
            (§ return (§ expr ))
        )
        (§ call ref.lock.readLock().lock())

        ;; someone completed a write after our snapshot
        (§ if (ref.tvals != nil && ref.tvals.point > readPoint))
        (§
            (§ call ref.lock.readLock().unlock())
            (§ throw retryex)
        )

        (§ let Info refinfo = ref.tinfo)

        ;; writer exists
        (§ if (refinfo != nil && refinfo.running()))
        (§
            (§ call ref.lock.readLock().unlock())

            (§ if (refinfo != info)) ;; not us, ensure is doomed
            (§
                (§ call blockAndBail(refinfo))
            )
        )
        (§ else )
        (§
            (§ call ensures.add(ref))
        )
    )

    (§ method Object doCommute(Ref ref, IFn fn, ISeq args)
        (§ if (!info.running()))
        (§
            (§ throw retryex)
        )
        (§ if (!vals.containsKey(ref)))
        (§
            (§ let Object val = nil)
            (§ try )
            (§
                (§ call ref.lock.readLock().lock())
                (§ ass val = (ref.tvals == nil) ? nil :or ref.tvals.val)
            )
            (§ finally )
            (§
                (§ call ref.lock.readLock().unlock())
            )
            (§ call vals.put(ref, val))
        )
        (§ let ArrayList<CFn> fns = commutes.get(ref))
        (§ if (fns == nil))
        (§
            (§ call commutes.put(ref, fns = new ArrayList<CFn>()))
        )
        (§ call fns.add(new CFn(fn, args)))
        (§ let Object ret = fn.applyTo(RT.cons(vals.get(ref), args)))
        (§ call vals.put(ref, ret))
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
#_public
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    #_private
    #_static
    #_final
    (§ field int CHUNK_SIZE = 32)

    ;; Invariants guarantee this is never an empty or infinite seq
    #_final
    (§ field long start)
    #_final
    (§ field long end)
    #_final
    (§ field long step)
    #_final
    (§ field BoundsCheck boundsCheck)

    #_private
    #_volatile
    (§ field LongChunk _chunk) ;; lazy
    #_private
    #_volatile
    (§ field ISeq _chunkNext) ;; lazy
    #_private
    #_volatile
    (§ field ISeq _next) ;; cached

    #_private
    #_static
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(long val))
    )

    #_private
    #_static
    (§ method BoundsCheck positiveStep(final long end)
        (§ return (§ expr new BoundsCheck()
        (§ inner
            #_public
            (§ method boolean exceededBounds(long val)
                (§ return (§ expr (val >= end)))
            )
        )))
    )

    #_private
    #_static
    (§ method BoundsCheck negativeStep(final long end)
        (§ return (§ expr new BoundsCheck()
        (§ inner
            #_public
            (§ method boolean exceededBounds(long val)
                (§ return (§ expr (val <= end)))
            )
        )))
    )

    #_private
    (§ method LongRange(long start, long end, long step, BoundsCheck boundsCheck)
        (§ ass this.start = start)
        (§ ass this.end = end)
        (§ ass this.step = step)
        (§ ass this.boundsCheck = boundsCheck)
    )

    #_private
    (§ method LongRange(long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
        (§ ass this.start = start)
        (§ ass this.end = end)
        (§ ass this.step = step)
        (§ ass this.boundsCheck = boundsCheck)
        (§ ass this._chunk = chunk)
        (§ ass this._chunkNext = chunkNext)
    )

    #_private
    (§ method LongRange(IPersistentMap meta, long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
        (§ super(meta))
        (§ ass this.start = start)
        (§ ass this.end = end)
        (§ ass this.step = step)
        (§ ass this.boundsCheck = boundsCheck)
        (§ ass this._chunk = chunk)
        (§ ass this._chunkNext = chunkNext)
    )

    #_public
    #_static
    (§ method ISeq create(long end)
        (§ if (end > 0))
        (§
            (§ return (§ expr new LongRange(0, end, 1, positiveStep(end))))
        )
        (§ return (§ expr PersistentList.EMPTY))
    )

    #_public
    #_static
    (§ method ISeq create(long start, long end)
        (§ if (start >= end))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr new LongRange(start, end, 1, positiveStep(end))))
    )

    #_public
    #_static
    (§ method ISeq create(final long start, long end, long step)
        (§ if (step > 0))
        (§
            (§ if (end <= start))
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr new LongRange(start, end, step, positiveStep(end))))
        )
        (§ elseif (step < 0))
        (§
            (§ if (end >= start))
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr new LongRange(start, end, step, negativeStep(end))))
        )
        (§ else )
        (§
            (§ if (end == start))
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr Repeat.create(start)))
        )
    )

    #_public
    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (meta == _meta))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext)))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr start))
    )

    #_public
    (§ method void forceChunk()
        (§ if (_chunk != nil))
        (§
            (§ return (§ expr ))
        )

        (§ let long count)
        (§ try )
        (§
            (§ ass count = rangeCount(start, end, step))
        )
        (§ catch (ArithmeticException e))
        (§
            ;; size of total range is > Long.MAX_VALUE so must step to count
            ;; this only happens in pathological range cases like:
            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
            (§ ass count = steppingCount(start, end, step))
        )

        (§ if (count > CHUNK_SIZE)) ;; not last chunk
        (§
            (§ let long nextStart = start + (step * CHUNK_SIZE)) ;; cannot overflow, must be < end
            (§ ass _chunkNext = new LongRange(nextStart, end, step, boundsCheck))
            (§ ass _chunk = new LongChunk(start, step, CHUNK_SIZE))
        )
        (§ else ) ;; last chunk
        (§
            (§ ass _chunk = new LongChunk(start, step, (int) count)) ;; count must be <= CHUNK_SIZE
        )
    )

    #_public
    (§ method ISeq next()
        (§ if (_next != nil))
        (§
            (§ return (§ expr _next))
        )

        (§ call forceChunk())
        (§ if (_chunk.count() > 1))
        (§
            (§ let LongChunk smallerChunk = _chunk.dropFirst())
            (§ ass _next = new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext))
            (§ return (§ expr _next))
        )
        (§ return (§ expr chunkedNext()))
    )

    #_public
    (§ method IChunk chunkedFirst()
        (§ call forceChunk())
        (§ return (§ expr _chunk))
    )

    #_public
    (§ method ISeq chunkedNext()
        (§ return (§ expr chunkedMore().seq()))
    )

    #_public
    (§ method ISeq chunkedMore()
        (§ call forceChunk())
        (§ if (_chunkNext == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _chunkNext))
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    (§ method long steppingCount(long start, long end, long step)
        (§ let long count = 1)
        (§ let long s = start)
        (§ while (count <= CHUNK_SIZE))
        (§
            (§ try )
            (§
                (§ ass s = Numbers.add(s, step))
                (§ if (boundsCheck.exceededBounds(s)))
                (§
                    (§ break )
                )
                (§ else )
                (§
                    (§ ass count++)
                )
            )
            (§ catch (ArithmeticException e))
            (§
                (§ break )
            )
        )
        (§ return (§ expr count))
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    (§ method long rangeCount(long start, long end, long step)
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (§ return (§ expr Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step))
    )

    #_public
    (§ method int count()
        (§ try )
        (§
            (§ let long c = rangeCount(start, end, step))
            (§ if (c > Integer.MAX_VALUE))
            (§
                (§ return (§ expr Numbers.throwIntOverflow()))
            )
            (§ else )
            (§
                (§ return (§ expr (int) c))
            )
        )
        (§ catch (ArithmeticException e))
        (§
            ;; rare case from large range or step, fall back to iterating and counting
            (§ let Iterator iter = this.iterator())
            (§ let long count = 0)
            (§ while (iter.hasNext()))
            (§
                (§ call iter.next())
                (§ ass count++)
            )

            (§ if (count > Integer.MAX_VALUE))
            (§
                (§ return (§ expr Numbers.throwIntOverflow()))
            )
            (§ else )
            (§
                (§ return (§ expr (int)count))
            )
        )
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ let Object acc = start)
        (§ let long i = start + step)
        (§ while (!boundsCheck.exceededBounds(i)))
        (§
            (§ ass acc = f.invoke(acc, i))
            (§ if (acc instanceof Reduced))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            (§ ass i += step)
        )
        (§ return (§ expr acc))
    )

    #_public
    (§ method Object reduce(IFn f, Object val)
        (§ let Object acc = val)
        (§ let long i = start)
        (§ do
        (§
            (§ ass acc = f.invoke(acc, i))
            (§ if (RT.isReduced(acc)))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            (§ ass i += step)
        ) while (!boundsCheck.exceededBounds(i)))
        (§ return (§ expr acc))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr new LongRangeIterator()))
    )

    (class-ns LongRangeIterator (§ implements Iterator)
        #_private
        (§ field long next)
        #_private
        (§ field boolean hasNext)

        #_public
        (§ method LongRangeIterator()
            (§ ass this.next = start)
            (§ ass this.hasNext = true)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr hasNext))
        )

        #_public
        (§ method Object next()
            (§ if (hasNext))
            (§
                (§ let long ret = next)
                (§ try )
                (§
                    (§ ass next = Numbers.add(next, step))
                    (§ ass hasNext = !boundsCheck.exceededBounds(next))
                )
                (§ catch (ArithmeticException e))
                (§
                    (§ ass hasNext = false)
                )
                (§ return (§ expr ret))
            )
            (§ else )
            (§
                (§ throw new NoSuchElementException())
            )
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    #_private
    #_static
    (class-ns LongChunk (§ implements IChunk)
        #_final
        (§ field long start)
        #_final
        (§ field long step)
        #_final
        (§ field int count)

        #_public
        (§ method LongChunk(long start, long step, int count)
            (§ ass this.start = start)
            (§ ass this.step = step)
            (§ ass this.count = count)
        )

        #_public
        (§ method long first()
            (§ return (§ expr start))
        )

        #_public
        (§ method Object nth(int i)
            (§ return (§ expr start + (i * step)))
        )

        #_public
        (§ method Object nth(int i, Object notFound)
            (§ if (i >= 0 && i < count))
            (§
                (§ return (§ expr start + (i * step)))
            )
            (§ return (§ expr notFound))
        )

        #_public
        (§ method int count()
            (§ return (§ expr count))
        )

        #_public
        (§ method LongChunk dropFirst()
            (§ if (count <= 1))
            (§
                (§ throw new IllegalStateException("dropFirst of empty chunk"))
            )
            (§ return (§ expr new LongChunk(start + step, step, count - 1)))
        )

        #_public
        (§ method Object reduce(IFn f, Object init)
            (§ let long x = start)
            (§ let Object ret = init)
            (§ for (int i = 0 i < count i++))
            (§
                (§ ass ret = f.invoke(ret, x))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ret))
                )
                (§ ass x += step)
            )
            (§ return (§ expr ret))
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

#_public
(class-ns MapEntry (§ extends AMapEntry)
    #_final
    (§ field Object _key)
    #_final
    (§ field Object _val)

    #_static
    #_public
    (§ method MapEntry create(Object key, Object val)
        (§ return (§ expr new MapEntry(key, val)))
    )

    #_public
    (§ method MapEntry(Object key, Object val)
        (§ ass this._key = key)
        (§ ass this._val = val)
    )

    #_public
    (§ method Object key()
        (§ return (§ expr _key))
    )

    #_public
    (§ method Object val()
        (§ return (§ expr _val))
    )

    #_public
    (§ method Object getKey()
        (§ return (§ expr key()))
    )

    #_public
    (§ method Object getValue()
        (§ return (§ expr val()))
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
#_public
(§ interface MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

#_public
#_final
(class-ns MethodImplCache
    #_static
    #_public
    (class-ns Entry
        #_final
        #_public
        (§ field Class c)
        #_final
        #_public
        (§ field IFn fn)

        #_public
        (§ method Entry(Class c, IFn fn)
            (§ ass this.c = c)
            (§ ass this.fn = fn)
        )
    )

    #_public
    #_final
    (§ field IPersistentMap protocol)
    #_public
    #_final
    (§ field Keyword methodk)
    #_public
    #_final
    (§ field int shift)
    #_public
    #_final
    (§ field int mask)
    #_public
    #_final
    (§ field Object[] table) ;; [class, entry. class, entry ...]
    #_public
    #_final
    (§ field Map map)

    (§ field Entry mre = nil)

    #_public
    (§ method MethodImplCache(IPersistentMap protocol, Keyword methodk)
        (§ this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY))
    )

    #_public
    (§ method MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table)
        (§ ass this.protocol = protocol)
        (§ ass this.methodk = methodk)
        (§ ass this.shift = shift)
        (§ ass this.mask = mask)
        (§ ass this.table = table)
        (§ ass this.map = nil)
    )

    #_public
    (§ method MethodImplCache(IPersistentMap protocol, Keyword methodk, Map map)
        (§ ass this.protocol = protocol)
        (§ ass this.methodk = methodk)
        (§ ass this.shift = 0)
        (§ ass this.mask = 0)
        (§ ass this.table = nil)
        (§ ass this.map = map)
    )

    #_public
    (§ method IFn fnFor(Class c)
        (§ let Entry last = mre)
        (§ if (last != nil && last.c == c))
        (§
            (§ return (§ expr last.fn))
        )
        (§ return (§ expr findFnFor(c)))
    )

    (§ method IFn findFnFor(Class c)
        (§ if (map != nil))
        (§
            (§ let Entry e = (Entry) map.get(c))
            (§ ass mre = e)
            (§ return (§ expr (e != nil) ? e.fn :or nil))
        )
        (§ else )
        (§
            (§ let int idx = ((Util.hash(c) >> shift) & mask) << 1)
            (§ if (idx < table.length && table[idx] == c))
            (§
                (§ let Entry e = ((Entry) table[idx + 1]))
                (§ ass mre = e)
                (§ return (§ expr (e != nil) ? e.fn :or nil))
            )
            (§ return (§ expr nil))
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

#_public
(class-ns MultiFn (§ extends AFn)
    #_final
    #_public
    (§ field IFn dispatchFn)
    #_final
    #_public
    (§ field Object defaultDispatchVal)
    #_final
    #_public
    (§ field IRef hierarchy)
    #_final
    (§ field String name)
    #_final
    (§ field ReentrantReadWriteLock rw)

    #_volatile
    (§ field IPersistentMap methodTable)
    #_volatile
    (§ field IPersistentMap preferTable)
    #_volatile
    (§ field IPersistentMap methodCache)
    #_volatile
    (§ field Object cachedHierarchy)

    #_static
    #_final
    (§ field Var assoc = RT.var("cloiure.core", "assoc"))
    #_static
    #_final
    (§ field Var dissoc = RT.var("cloiure.core", "dissoc"))
    #_static
    #_final
    (§ field Var isa = RT.var("cloiure.core", "isa?"))
    #_static
    #_final
    (§ field Var parents = RT.var("cloiure.core", "parents"))

    #_public
    (§ method MultiFn(String name, IFn dispatchFn, Object defaultDispatchVal, IRef hierarchy)
        (§ ass this.rw = new ReentrantReadWriteLock())
        (§ ass this.name = name)
        (§ ass this.dispatchFn = dispatchFn)
        (§ ass this.defaultDispatchVal = defaultDispatchVal)
        (§ ass this.methodTable = PersistentHashMap.EMPTY)
        (§ ass this.methodCache = getMethodTable())
        (§ ass this.preferTable = PersistentHashMap.EMPTY)
        (§ ass this.hierarchy = hierarchy)
        (§ ass cachedHierarchy = nil)
    )

    #_public
    (§ method MultiFn reset()
        (§ call rw.writeLock().lock())
        (§ try )
        (§
            (§ ass methodTable = methodCache = preferTable = PersistentHashMap.EMPTY)
            (§ ass cachedHierarchy = nil)
            (§ return (§ expr this))
        )
        (§ finally )
        (§
            (§ call rw.writeLock().unlock())
        )
    )

    #_public
    (§ method MultiFn addMethod(Object dispatchVal, IFn method)
        (§ call rw.writeLock().lock())
        (§ try )
        (§
            (§ ass methodTable = getMethodTable().assoc(dispatchVal, method))
            (§ call resetCache())
            (§ return (§ expr this))
        )
        (§ finally )
        (§
            (§ call rw.writeLock().unlock())
        )
    )

    #_public
    (§ method MultiFn removeMethod(Object dispatchVal)
        (§ call rw.writeLock().lock())
        (§ try )
        (§
            (§ ass methodTable = getMethodTable().without(dispatchVal))
            (§ call resetCache())
            (§ return (§ expr this))
        )
        (§ finally )
        (§
            (§ call rw.writeLock().unlock())
        )
    )

    #_public
    (§ method MultiFn preferMethod(Object dispatchValX, Object dispatchValY)
        (§ call rw.writeLock().lock())
        (§ try )
        (§
            (§ if (prefers(dispatchValY, dispatchValX)))
            (§
                (§ throw new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX)))
            )
            (§ ass preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY)))
            (§ call resetCache())
            (§ return (§ expr this))
        )
        (§ finally )
        (§
            (§ call rw.writeLock().unlock())
        )
    )

    #_private
    (§ method boolean prefers(Object x, Object y)
        (§ let IPersistentSet xprefs = (IPersistentSet) getPreferTable().valAt(x))
        (§ if (xprefs != nil && xprefs.contains(y)))
        (§
            (§ return (§ expr true))
        )
        (§ for (ISeq ps = RT.seq(parents.invoke(y)) ps != nil ps = ps.next()))
        (§
            (§ if (prefers(x, ps.first())))
            (§
                (§ return (§ expr true))
            )
        )
        (§ for (ISeq ps = RT.seq(parents.invoke(x)) ps != nil ps = ps.next()))
        (§
            (§ if (prefers(ps.first(), y)))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    #_private
    (§ method boolean isA(Object x, Object y)
        (§ return (§ expr RT.booleanCast(isa.invoke(hierarchy.deref(), x, y))))
    )

    #_private
    (§ method boolean dominates(Object x, Object y)
        (§ return (§ expr prefers(x, y) || isA(x, y)))
    )

    #_private
    (§ method IPersistentMap resetCache()
        (§ call rw.writeLock().lock())
        (§ try )
        (§
            (§ ass methodCache = getMethodTable())
            (§ ass cachedHierarchy = hierarchy.deref())
            (§ return (§ expr methodCache))
        )
        (§ finally )
        (§
            (§ call rw.writeLock().unlock())
        )
    )

    #_public
    (§ method IFn getMethod(Object dispatchVal)
        (§ if (cachedHierarchy != hierarchy.deref()))
        (§
            (§ call resetCache())
        )
        (§ let IFn targetFn = (IFn) methodCache.valAt(dispatchVal))
        (§ if (targetFn != nil))
        (§
            (§ return (§ expr targetFn))
        )
        (§ return (§ expr findAndCacheBestMethod(dispatchVal)))
    )

    #_private
    (§ method IFn getFn(Object dispatchVal)
        (§ let IFn targetFn = getMethod(dispatchVal))
        (§ if (targetFn == nil))
        (§
            (§ throw new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal)))
        )
        (§ return (§ expr targetFn))
    )

    #_private
    (§ method IFn findAndCacheBestMethod(Object dispatchVal)
        (§ call rw.readLock().lock())
        (§ let Object bestValue)
        (§ let IPersistentMap mt = methodTable)
        (§ let IPersistentMap pt = preferTable)
        (§ let Object ch = cachedHierarchy)
        (§ try )
        (§
            (§ let Map.Entry bestEntry = nil)
            (§ for (Object o :in getMethodTable()))
            (§
                (§ let Map.Entry e = (Map.Entry) o)
                (§ if (isA(dispatchVal, e.getKey())))
                (§
                    (§ if (bestEntry == nil || dominates(e.getKey(), bestEntry.getKey())))
                    (§
                        (§ ass bestEntry = e)
                    )
                    (§ if (!dominates(bestEntry.getKey(), e.getKey())))
                    (§
                        (§ throw new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey())))
                    )
                )
            )
            (§ if (bestEntry == nil))
            (§
                (§ ass bestValue = methodTable.valAt(defaultDispatchVal))
                (§ if (bestValue == nil))
                (§
                    (§ return (§ expr nil))
                )
            )
            (§ else )
            (§
                (§ ass bestValue = bestEntry.getValue())
            )
        )
        (§ finally )
        (§
            (§ call rw.readLock().unlock())
        )

        ;; ensure basis has stayed stable throughout, else redo
        (§ call rw.writeLock().lock())
        (§ try )
        (§
            (§ if (mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref()))
            (§
                ;; place in cache
                (§ ass methodCache = methodCache.assoc(dispatchVal, bestValue))
                (§ return (§ expr (IFn) bestValue))
            )
            (§ else )
            (§
                (§ call resetCache())
                (§ return (§ expr findAndCacheBestMethod(dispatchVal)))
            )
        )
        (§ finally )
        (§
            (§ call rw.writeLock().unlock())
        )
    )

    #_public
    (§ method Object invoke()
        (§ return (§ expr getFn(dispatchFn.invoke()).invoke()))
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, arg1 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15, arg16)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil),
              #_arg Util.ret1(arg16, arg16 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15, arg16, arg17)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil),
              #_arg Util.ret1(arg16, arg16 = nil),
              #_arg Util.ret1(arg17, arg17 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15, arg16, arg17, arg18)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil),
              #_arg Util.ret1(arg16, arg16 = nil),
              #_arg Util.ret1(arg17, arg17 = nil),
              #_arg Util.ret1(arg18, arg18 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15, arg16, arg17, arg18, arg19)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil),
              #_arg Util.ret1(arg16, arg16 = nil),
              #_arg Util.ret1(arg17, arg17 = nil),
              #_arg Util.ret1(arg18, arg18 = nil),
              #_arg Util.ret1(arg19, arg19 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15, arg16, arg17, arg18, arg19, arg20)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil),
              #_arg Util.ret1(arg16, arg16 = nil),
              #_arg Util.ret1(arg17, arg17 = nil),
              #_arg Util.ret1(arg18, arg18 = nil),
              #_arg Util.ret1(arg19, arg19 = nil),
              #_arg Util.ret1(arg20, arg20 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args))
    (§
        (§ return (§ expr getFn(
          #_arg dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
              #_arg arg15, arg16, arg17, arg18, arg19, arg20, args)).
      #_arg invoke(Util.ret1(arg1, arg1 = nil),
              #_arg Util.ret1(arg2, arg2 = nil),
              #_arg Util.ret1(arg3, arg3 = nil),
              #_arg Util.ret1(arg4, arg4 = nil),
              #_arg Util.ret1(arg5, arg5 = nil),
              #_arg Util.ret1(arg6, arg6 = nil),
              #_arg Util.ret1(arg7, arg7 = nil),
              #_arg Util.ret1(arg8, arg8 = nil),
              #_arg Util.ret1(arg9, arg9 = nil),
              #_arg Util.ret1(arg10, arg10 = nil),
              #_arg Util.ret1(arg11, arg11 = nil),
              #_arg Util.ret1(arg12, arg12 = nil),
              #_arg Util.ret1(arg13, arg13 = nil),
              #_arg Util.ret1(arg14, arg14 = nil),
              #_arg Util.ret1(arg15, arg15 = nil),
              #_arg Util.ret1(arg16, arg16 = nil),
              #_arg Util.ret1(arg17, arg17 = nil),
              #_arg Util.ret1(arg18, arg18 = nil),
              #_arg Util.ret1(arg19, arg19 = nil),
              #_arg Util.ret1(arg20, arg20 = nil),
              #_arg args)))
    )

    #_public
    (§ method IPersistentMap getMethodTable()
        (§ return (§ expr methodTable))
    )

    #_public
    (§ method IPersistentMap getPreferTable()
        (§ return (§ expr preferTable))
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_public
#_final
(class-ns Murmur3
    #_private
    #_static
    #_final
    (§ field int seed = 0)
    #_private
    #_static
    #_final
    (§ field int C1 = 0xcc9e2d51)
    #_private
    #_static
    #_final
    (§ field int C2 = 0x1b873593)

    #_public
    #_static
    (§ method int hashInt(int input)
        (§ if (input == 0))
        (§
            (§ return (§ expr 0))
        )
        (§ let int k1 = mixK1(input))
        (§ let int h1 = mixH1(seed, k1))

        (§ return (§ expr fmix(h1, 4)))
    )

    #_public
    #_static
    (§ method int hashLong(long input)
        (§ if (input == 0))
        (§
            (§ return (§ expr 0))
        )
        (§ let int low = (int) input)
        (§ let int high = (int) (input >>> 32))

        (§ let int k1 = mixK1(low))
        (§ let int h1 = mixH1(seed, k1))

        (§ ass k1 = mixK1(high))
        (§ ass h1 = mixH1(h1, k1))

        (§ return (§ expr fmix(h1, 8)))
    )

    #_public
    #_static
    (§ method int hashUnencodedChars(CharSequence input)
        (§ let int h1 = seed)

        ;; step through the CharSequence 2 chars at a time
        (§ for (int i = 1 i < input.length() i += 2))
        (§
            (§ let int k1 = input.charAt(i - 1) | (input.charAt(i) << 16))
            (§ ass k1 = mixK1(k1))
            (§ ass h1 = mixH1(h1, k1))
        )

        ;; deal with any remaining characters
        (§ if ((input.length() & 1) == 1))
        (§
            (§ let int k1 = input.charAt(input.length() - 1))
            (§ ass k1 = mixK1(k1))
            (§ ass h1 ^= k1)
        )

        (§ return (§ expr fmix(h1, 2 * input.length())))
    )

    #_public
    #_static
    (§ method int mixCollHash(int hash, int count)
        (§ let int h1 = seed)
        (§ let int k1 = mixK1(hash))
        (§ ass h1 = mixH1(h1, k1))
        (§ return (§ expr fmix(h1, count)))
    )

    #_public
    #_static
    (§ method int hashOrdered(Iterable xs)
        (§ let int n = 0)
        (§ let int hash = 1)

        (§ for (Object x :in xs))
        (§
            (§ ass hash = 31 * hash + Util.hasheq(x))
            (§ ass ++n)
        )

        (§ return (§ expr mixCollHash(hash, n)))
    )

    #_public
    #_static
    (§ method int hashUnordered(Iterable xs)
        (§ let int hash = 0)
        (§ let int n = 0)
        (§ for (Object x :in xs))
        (§
            (§ ass hash += Util.hasheq(x))
            (§ ass ++n)
        )

        (§ return (§ expr mixCollHash(hash, n)))
    )

    #_private
    #_static
    (§ method int mixK1(int k1)
        (§ ass k1 *= C1)
        (§ ass k1 = Integer.rotateLeft(k1, 15))
        (§ ass k1 *= C2)
        (§ return (§ expr k1))
    )

    #_private
    #_static
    (§ method int mixH1(int h1, int k1)
        (§ ass h1 ^= k1)
        (§ ass h1 = Integer.rotateLeft(h1, 13))
        (§ ass h1 = h1 * 5 + 0xe6546b64)
        (§ return (§ expr h1))
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    #_private
    #_static
    (§ method int fmix(int h1, int length)
        (§ ass h1 ^= length)
        (§ ass h1 ^= h1 >>> 16)
        (§ ass h1 *= 0x85ebca6b)
        (§ ass h1 ^= h1 >>> 13)
        (§ ass h1 *= 0xc2b2ae35)
        (§ ass h1 ^= h1 >>> 16)
        (§ return (§ expr h1))
    )
)
)

(java-ns cloiure.lang.Named

#_public
(§ interface Named
    (§ abstract String getNamespace())
    (§ abstract String getName())
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

#_public
(class-ns Namespace (§ extends AReference)
    #_final
    #_public
    (§ field Symbol name)

    #_transient
    #_final
    (§ field AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>())
    #_transient
    #_final
    (§ field AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>())

    #_final
    #_static
    (§ field ConcurrentHashMap<Symbol, Namespace> namespaces = new ConcurrentHashMap<Symbol, Namespace>())

    #_public
    (§ method String toString()
        (§ return (§ expr name.toString()))
    )

    (§ method Namespace(Symbol name)
        (§ super(name.meta()))
        (§ ass this.name = name)
        (§ call mappings.set(RT.DEFAULT_IMPORTS))
        (§ call aliases.set(RT.map()))
    )

    #_public
    #_static
    (§ method ISeq all()
        (§ return (§ expr RT.seq(namespaces.values())))
    )

    #_public
    (§ method Symbol getName()
        (§ return (§ expr name))
    )

    #_public
    (§ method IPersistentMap getMappings()
        (§ return (§ expr mappings.get()))
    )

    #_public
    (§ method Var intern(Symbol sym)
        (§ if (sym.ns != nil))
        (§
            (§ throw new IllegalArgumentException("Can't intern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ let Object o)
        (§ let Var v = nil)
        (§ while ((o = map.valAt(sym)) == nil))
        (§
            (§ if (v == nil))
            (§
                (§ ass v = new Var(this, sym))
            )
            (§ let IPersistentMap newMap = map.assoc(sym, v))
            (§ call mappings.compareAndSet(map, newMap))
            (§ ass map = getMappings())
        )
        (§ if (o instanceof Var && ((Var) o).ns == this))
        (§
            (§ return (§ expr (Var) o))
        )

        (§ if (v == nil))
        (§
            (§ ass v = new Var(this, sym))
        )

        (§ call warnOrFailOnReplace(sym, o, v))

        (§ while (!mappings.compareAndSet(map, map.assoc(sym, v))))
        (§
            (§ ass map = getMappings())
        )

        (§ return (§ expr v))
    )

    #_private
    (§ method void warnOrFailOnReplace(Symbol sym, Object o, Object v)
        (§ if (o instanceof Var))
        (§
            (§ let Namespace ns = ((Var)o).ns)
            (§ if (ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOIURE_NS)))
            (§
                (§ return (§ expr ))
            )
            (§ if (ns != RT.CLOIURE_NS))
            (§
                (§ throw new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name))
            )
        )
        (§ call RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v))
    )

    (§ method Object reference(Symbol sym, Object val)
        (§ if (sym.ns != nil))
        (§
            (§ throw new IllegalArgumentException("Can't intern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ let Object o)
        (§ while ((o = map.valAt(sym)) == nil))
        (§
            (§ let IPersistentMap newMap = map.assoc(sym, val))
            (§ call mappings.compareAndSet(map, newMap))
            (§ ass map = getMappings())
        )
        (§ if (o == val))
        (§
            (§ return (§ expr o))
        )

        (§ call warnOrFailOnReplace(sym, o, val))

        (§ while (!mappings.compareAndSet(map, map.assoc(sym, val))))
        (§
            (§ ass map = getMappings())
        )

        (§ return (§ expr val))
    )

    #_public
    #_static
    (§ method boolean areDifferentInstancesOfSameClassName(Class cls1, Class cls2)
        (§ return (§ expr (cls1 != cls2) && (cls1.getName().equals(cls2.getName()))))
    )

    (§ method Class referenceClass(Symbol sym, Class val)
        (§ if (sym.ns != nil))
        (§
            (§ throw new IllegalArgumentException("Can't intern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ let Class c = (Class) map.valAt(sym))
        (§ while ((c == nil) || (areDifferentInstancesOfSameClassName(c, val))))
        (§
            (§ let IPersistentMap newMap = map.assoc(sym, val))
            (§ call mappings.compareAndSet(map, newMap))
            (§ ass map = getMappings())
            (§ ass c = (Class) map.valAt(sym))
        )
        (§ if (c == val))
        (§
            (§ return (§ expr c))
        )

        (§ throw new IllegalStateException(sym + " already refers to: " + c + " in namespace: " + name))
    )

    #_public
    (§ method void unmap(Symbol sym)
        (§ if (sym.ns != nil))
        (§
            (§ throw new IllegalArgumentException("Can't unintern namespace-qualified symbol"))
        )
        (§ let IPersistentMap map = getMappings())
        (§ while (map.containsKey(sym)))
        (§
            (§ let IPersistentMap newMap = map.without(sym))
            (§ call mappings.compareAndSet(map, newMap))
            (§ ass map = getMappings())
        )
    )

    #_public
    (§ method Class importClass(Symbol sym, Class c)
        (§ return (§ expr referenceClass(sym, c)))
    )

    #_public
    (§ method Class importClass(Class c)
        (§ let String n = c.getName())
        (§ return (§ expr importClass(Symbol.intern(n.substring(n.lastIndexOf(\.) + 1)), c)))
    )

    #_public
    (§ method Var refer(Symbol sym, Var var)
        (§ return (§ expr (Var) reference(sym, var)))
    )

    #_public
    #_static
    (§ method Namespace findOrCreate(Symbol name)
        (§ let Namespace ns = namespaces.get(name))
        (§ if (ns != nil))
        (§
            (§ return (§ expr ns))
        )
        (§ let Namespace newns = new Namespace(name))
        (§ ass ns = namespaces.putIfAbsent(name, newns))
        (§ return (§ expr (ns == nil) ? newns :or ns))
    )

    #_public
    #_static
    (§ method Namespace remove(Symbol name)
        (§ if (name.equals(RT.CLOIURE_NS.name)))
        (§
            (§ throw new IllegalArgumentException("Cannot remove cloiure namespace"))
        )
        (§ return (§ expr namespaces.remove(name)))
    )

    #_public
    #_static
    (§ method Namespace find(Symbol name)
        (§ return (§ expr namespaces.get(name)))
    )

    #_public
    (§ method Object getMapping(Symbol name)
        (§ return (§ expr mappings.get().valAt(name)))
    )

    #_public
    (§ method Var findInternedVar(Symbol symbol)
        (§ let Object o = mappings.get().valAt(symbol))
        (§ if (o != nil && o instanceof Var && ((Var) o).ns == this))
        (§
            (§ return (§ expr (Var) o))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method IPersistentMap getAliases()
        (§ return (§ expr aliases.get()))
    )

    #_public
    (§ method Namespace lookupAlias(Symbol alias)
        (§ let IPersistentMap map = getAliases())
        (§ return (§ expr (Namespace) map.valAt(alias)))
    )

    #_public
    (§ method void addAlias(Symbol alias, Namespace ns)
        (§ if (alias == nil || ns == nil))
        (§
            (§ throw new NullPointerException("Expecting Symbol + Namespace"))
        )
        (§ let IPersistentMap map = getAliases())
        (§ while (!map.containsKey(alias)))
        (§
            (§ let IPersistentMap newMap = map.assoc(alias, ns))
            (§ call aliases.compareAndSet(map, newMap))
            (§ ass map = getAliases())
        )
        ;; you can rebind an alias, but only to the initially-aliased namespace.
        (§ if (!map.valAt(alias).equals(ns)))
        (§
            (§ throw new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias)))
        )
    )

    #_public
    (§ method void removeAlias(Symbol alias)
        (§ let IPersistentMap map = getAliases())
        (§ while (map.containsKey(alias)))
        (§
            (§ let IPersistentMap newMap = map.without(alias))
            (§ call aliases.compareAndSet(map, newMap))
            (§ ass map = getAliases())
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

#_public
(class-ns Numbers
    #_static
    (§ interface Ops
        (§ abstract Ops combine(Ops y))
        (§ abstract Ops opsWith(LongOps x))
        (§ abstract Ops opsWith(DoubleOps x))
        (§ abstract Ops opsWith(RatioOps x))
        (§ abstract Ops opsWith(BigIntOps x))
        (§ abstract Ops opsWith(BigDecimalOps x))
        (§ abstract boolean isZero(Number x))
        (§ abstract boolean isPos(Number x))
        (§ abstract boolean isNeg(Number x))
        (§ abstract Number add(Number x, Number y))
        (§ abstract Number addP(Number x, Number y))
        (§ abstract Number multiply(Number x, Number y))
        (§ abstract Number multiplyP(Number x, Number y))
        (§ abstract Number divide(Number x, Number y))
        (§ abstract Number quotient(Number x, Number y))
        (§ abstract Number remainder(Number x, Number y))
        (§ abstract boolean equiv(Number x, Number y))
        (§ abstract boolean lt(Number x, Number y))
        (§ abstract boolean lte(Number x, Number y))
        (§ abstract boolean gte(Number x, Number y))
        (§ abstract Number negate(Number x))
        (§ abstract Number negateP(Number x))
        (§ abstract Number inc(Number x))
        (§ abstract Number incP(Number x))
        (§ abstract Number dec(Number x))
        (§ abstract Number decP(Number x))
    )

    #_static
    #_abstract
    (class-ns OpsP (§ implements Ops)
        #_public
        (§ method Number addP(Number x, Number y)
            (§ return (§ expr add(x, y)))
        )

        #_public
        (§ method Number multiplyP(Number x, Number y)
            (§ return (§ expr multiply(x, y)))
        )

        #_public
        (§ method Number negateP(Number x)
            (§ return (§ expr negate(x)))
        )

        #_public
        (§ method Number incP(Number x)
            (§ return (§ expr inc(x)))
        )

        #_public
        (§ method Number decP(Number x)
            (§ return (§ expr dec(x)))
        )
    )

    #_static
    #_public
    (§ method boolean isZero(Object x)
        (§ return (§ expr ops(x).isZero((Number)x)))
    )

    #_static
    #_public
    (§ method boolean isPos(Object x)
        (§ return (§ expr ops(x).isPos((Number)x)))
    )

    #_static
    #_public
    (§ method boolean isNeg(Object x)
        (§ return (§ expr ops(x).isNeg((Number)x)))
    )

    #_static
    #_public
    (§ method Number minus(Object x)
        (§ return (§ expr ops(x).negate((Number)x)))
    )

    #_static
    #_public
    (§ method Number minusP(Object x)
        (§ return (§ expr ops(x).negateP((Number)x)))
    )

    #_static
    #_public
    (§ method Number inc(Object x)
        (§ return (§ expr ops(x).inc((Number)x)))
    )

    #_static
    #_public
    (§ method Number incP(Object x)
        (§ return (§ expr ops(x).incP((Number)x)))
    )

    #_static
    #_public
    (§ method Number dec(Object x)
        (§ return (§ expr ops(x).dec((Number)x)))
    )

    #_static
    #_public
    (§ method Number decP(Object x)
        (§ return (§ expr ops(x).decP((Number)x)))
    )

    #_static
    #_public
    (§ method Number add(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).add((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method Number addP(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).addP((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method Number minus(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ return (§ expr ops(x).combine(yops).add((Number)x, yops.negate((Number)y))))
    )

    #_static
    #_public
    (§ method Number minusP(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ let Number negativeY = yops.negateP((Number) y))
        (§ let Ops negativeYOps = ops(negativeY))
        (§ return (§ expr ops(x).combine(negativeYOps).addP((Number)x, negativeY)))
    )

    #_static
    #_public
    (§ method Number multiply(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).multiply((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method Number multiplyP(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method Number divide(Object x, Object y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr (Number)x))
        )
        (§ elseif (isNaN(y)))
        (§
            (§ return (§ expr (Number)y))
        )
        (§ let Ops yops = ops(y))
        (§ if (yops.isZero((Number)y)))
        (§
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (§ return (§ expr ops(x).combine(yops).divide((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method Number quotient(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ if (yops.isZero((Number) y)))
        (§
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (§ return (§ expr ops(x).combine(yops).quotient((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method Number remainder(Object x, Object y)
        (§ let Ops yops = ops(y))
        (§ if (yops.isZero((Number) y)))
        (§
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (§ return (§ expr ops(x).combine(yops).remainder((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method double quotient(double n, double d)
        (§ if (d == 0))
        (§
            (§ throw new ArithmeticException("Divide by zero"))
        )

        (§ let double q = n / d)
        (§ if (q <= Long.MAX_VALUE && q >= Long.MIN_VALUE))
        (§
            (§ return (§ expr (double)(long) q))
        )
        (§ else ) ;; bigint quotient
        (§
            (§ return (§ expr new BigDecimal(q).toBigInteger().doubleValue()))
        )
    )

    #_static
    #_public
    (§ method double remainder(double n, double d)
        (§ if (d == 0))
        (§
            (§ throw new ArithmeticException("Divide by zero"))
        )

        (§ let double q = n / d)
        (§ if (q <= Long.MAX_VALUE && q >= Long.MIN_VALUE))
        (§
            (§ return (§ expr (n - ((long) q) * d)))
        )
        (§ else ) ;; bigint quotient
        (§
            (§ let Number bq = new BigDecimal(q).toBigInteger())
            (§ return (§ expr (n - bq.doubleValue() * d)))
        )
    )

    #_static
    #_public
    (§ method boolean equiv(Object x, Object y)
        (§ return (§ expr equiv((Number) x, (Number) y)))
    )

    #_static
    #_public
    (§ method boolean equiv(Number x, Number y)
        (§ return (§ expr ops(x).combine(ops(y)).equiv(x, y)))
    )

    #_static
    #_public
    (§ method boolean equal(Number x, Number y)
        (§ return (§ expr (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y))))
    )

    #_static
    #_public
    (§ method boolean lt(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).lt((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method boolean lte(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).lte((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method boolean gt(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).lt((Number)y, (Number)x)))
    )

    #_static
    #_public
    (§ method boolean gte(Object x, Object y)
        (§ return (§ expr ops(x).combine(ops(y)).gte((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method int compare(Number x, Number y)
        (§ let Ops ops = ops(x).combine(ops(y)))
        (§ if (ops.lt(x, y)))
        (§
            (§ return (§ expr -1))
        )
        (§ elseif (ops.lt(y, x)))
        (§
            (§ return (§ expr 1))
        )
        (§ return (§ expr 0))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    (§ method BigInt toBigInt(Object x)
        (§ if (x instanceof BigInt))
        (§
            (§ return (§ expr (BigInt) x))
        )
        (§ if (x instanceof BigInteger))
        (§
            (§ return (§ expr BigInt.fromBigInteger((BigInteger) x)))
        )
        (§ else )
        (§
            (§ return (§ expr BigInt.fromLong(((Number) x).longValue())))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    (§ method BigInteger toBigInteger(Object x)
        (§ if (x instanceof BigInteger))
        (§
            (§ return (§ expr (BigInteger) x))
        )
        (§ elseif (x instanceof BigInt))
        (§
            (§ return (§ expr ((BigInt) x).toBigInteger()))
        )
        (§ else )
        (§
            (§ return (§ expr BigInteger.valueOf(((Number) x).longValue())))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    (§ method BigDecimal toBigDecimal(Object x)
        (§ if (x instanceof BigDecimal))
        (§
            (§ return (§ expr (BigDecimal) x))
        )
        (§ elseif (x instanceof BigInt))
        (§
            (§ let BigInt bi = (BigInt) x)
            (§ if (bi.bipart == nil))
            (§
                (§ return (§ expr BigDecimal.valueOf(bi.lpart)))
            )
            (§ else )
            (§
                (§ return (§ expr new BigDecimal(bi.bipart)))
            )
        )
        (§ elseif (x instanceof BigInteger))
        (§
            (§ return (§ expr new BigDecimal((BigInteger) x)))
        )
        (§ elseif (x instanceof Double))
        (§
            (§ return (§ expr new BigDecimal(((Number) x).doubleValue())))
        )
        (§ elseif (x instanceof Float))
        (§
            (§ return (§ expr new BigDecimal(((Number) x).doubleValue())))
        )
        (§ elseif (x instanceof Ratio))
        (§
            (§ let Ratio r = (Ratio)x)
            (§ return (§ expr (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator)))
        )
        (§ else )
        (§
            (§ return (§ expr BigDecimal.valueOf(((Number) x).longValue())))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method Ratio toRatio(Object x)
        (§ if (x instanceof Ratio))
        (§
            (§ return (§ expr (Ratio) x))
        )
        (§ elseif (x instanceof BigDecimal))
        (§
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ let BigInteger bv = bx.unscaledValue())
            (§ let int scale = bx.scale())
            (§ if (scale < 0))
            (§
                (§ return (§ expr new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)))
            )
            (§ else )
            (§
                (§ return (§ expr new Ratio(bv, BigInteger.TEN.pow(scale))))
            )
        )
        (§ return (§ expr new Ratio(toBigInteger(x), BigInteger.ONE)))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method Number rationalize(Number x)
        (§ if (x instanceof Float || x instanceof Double))
        (§
            (§ return (§ expr rationalize(BigDecimal.valueOf(x.doubleValue()))))
        )
        (§ elseif (x instanceof BigDecimal))
        (§
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ let BigInteger bv = bx.unscaledValue())
            (§ let int scale = bx.scale())
            (§ if (scale < 0))
            (§
                (§ return (§ expr BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))))
            )
            (§ else )
            (§
                (§ return (§ expr divide(bv, BigInteger.TEN.pow(scale))))
            )
        )
        (§ return (§ expr x))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method Number reduceBigInt(BigInt val)
        (§ if (val.bipart == nil))
        (§
            (§ return (§ expr num(val.lpart)))
        )
        (§ else )
        (§
            (§ return (§ expr val.bipart))
        )
    )

    #_static
    #_public
    (§ method Number divide(BigInteger n, BigInteger d)
        (§ if (d.equals(BigInteger.ZERO)))
        (§
            (§ throw new ArithmeticException("Divide by zero"))
        )
        (§ let BigInteger gcd = n.gcd(d))
        (§ if (gcd.equals(BigInteger.ZERO)))
        (§
            (§ return (§ expr BigInt.ZERO))
        )
        (§ ass n = n.divide(gcd))
        (§ ass d = d.divide(gcd))
        (§ if (d.equals(BigInteger.ONE)))
        (§
            (§ return (§ expr BigInt.fromBigInteger(n)))
        )
        (§ elseif (d.equals(BigInteger.ONE.negate())))
        (§
            (§ return (§ expr BigInt.fromBigInteger(n.negate())))
        )
        (§ return (§ expr new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d))))
    )

    #_static
    #_public
    (§ method int shiftLeftInt(int x, int n)
        (§ return (§ expr x << n))
    )

    #_static
    #_public
    (§ method long shiftLeft(Object x, Object y)
        (§ return (§ expr shiftLeft(bitOpsCast(x), bitOpsCast(y))))
    )
    #_static
    #_public
    (§ method long shiftLeft(Object x, long y)
        (§ return (§ expr shiftLeft(bitOpsCast(x), y)))
    )
    #_static
    #_public
    (§ method long shiftLeft(long x, Object y)
        (§ return (§ expr shiftLeft(x, bitOpsCast(y))))
    )
    #_static
    #_public
    (§ method long shiftLeft(long x, long n)
        (§ return (§ expr x << n))
    )

    #_static
    #_public
    (§ method int shiftRightInt(int x, int n)
        (§ return (§ expr x >> n))
    )

    #_static
    #_public
    (§ method long shiftRight(Object x, Object y)
        (§ return (§ expr shiftRight(bitOpsCast(x), bitOpsCast(y))))
    )
    #_static
    #_public
    (§ method long shiftRight(Object x, long y)
        (§ return (§ expr shiftRight(bitOpsCast(x), y)))
    )
    #_static
    #_public
    (§ method long shiftRight(long x, Object y)
        (§ return (§ expr shiftRight(x, bitOpsCast(y))))
    )
    #_static
    #_public
    (§ method long shiftRight(long x, long n)
        (§ return (§ expr x >> n))
    )

    #_static
    #_public
    (§ method int unsignedShiftRightInt(int x, int n)
        (§ return (§ expr x >>> n))
    )

    #_static
    #_public
    (§ method long unsignedShiftRight(Object x, Object y)
        (§ return (§ expr unsignedShiftRight(bitOpsCast(x), bitOpsCast(y))))
    )
    #_static
    #_public
    (§ method long unsignedShiftRight(Object x, long y)
        (§ return (§ expr unsignedShiftRight(bitOpsCast(x), y)))
    )
    #_static
    #_public
    (§ method long unsignedShiftRight(long x, Object y)
        (§ return (§ expr unsignedShiftRight(x, bitOpsCast(y))))
    )
    #_static
    #_public
    (§ method long unsignedShiftRight(long x, long n)
        (§ return (§ expr x >>> n))
    )

    #_final
    #_static
    (class-ns LongOps (§ implements Ops)
        #_public
        (§ method Ops combine(Ops y)
            (§ return (§ expr y.opsWith(this)))
        )

        #_final
        #_public
        (§ method Ops opsWith(LongOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(DoubleOps x)
            (§ return (§ expr DOUBLE_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(RatioOps x)
            (§ return (§ expr RATIO_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigIntOps x)
            (§ return (§ expr BIGINT_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigDecimalOps x)
            (§ return (§ expr BIGDECIMAL_OPS))
        )

        #_public
        (§ method boolean isZero(Number x)
            (§ return (§ expr (x.longValue() == 0)))
        )

        #_public
        (§ method boolean isPos(Number x)
            (§ return (§ expr (x.longValue() > 0)))
        )

        #_public
        (§ method boolean isNeg(Number x)
            (§ return (§ expr (x.longValue() < 0)))
        )

        #_final
        #_public
        (§ method Number add(Number x, Number y)
            (§ return (§ expr num(Numbers.add(x.longValue(), y.longValue()))))
        )

        #_final
        #_public
        (§ method Number addP(Number x, Number y)
            (§ let long lx = x.longValue(), ly = y.longValue())
            (§ let long ret = lx + ly)
            (§ if ((ret :xor lx) < 0 && (ret :xor ly) < 0))
            (§
                (§ return (§ expr BIGINT_OPS.add(x, y)))
            )
            (§ return (§ expr num(ret)))
        )

        #_final
        #_public
        (§ method Number multiply(Number x, Number y)
            (§ return (§ expr num(Numbers.multiply(x.longValue(), y.longValue()))))
        )

        #_final
        #_public
        (§ method Number multiplyP(Number x, Number y)
            (§ let long lx = x.longValue(), ly = y.longValue())
            (§ if (lx == Long.MIN_VALUE && ly < 0))
            (§
                (§ return (§ expr BIGINT_OPS.multiply(x, y)))
            )
            (§ let long ret = lx * ly)
            (§ if (ly != 0 && ret/ly != lx))
            (§
                (§ return (§ expr BIGINT_OPS.multiply(x, y)))
            )
            (§ return (§ expr num(ret)))
        )

        #_static
        (§ method long gcd(long u, long v)
            (§ while (v != 0))
            (§
                (§ let long r = u % v)
                (§ ass u = v)
                (§ ass v = r)
            )
            (§ return (§ expr u))
        )

        #_public
        (§ method Number divide(Number x, Number y)
            (§ let long n = x.longValue())
            (§ let long val = y.longValue())
            (§ let long gcd = gcd(n, val))
            (§ if (gcd == 0))
            (§
                (§ return (§ expr num(0)))
            )

            (§ ass n = n / gcd)
            (§ let long d = val / gcd)
            (§ if (d == 1))
            (§
                (§ return (§ expr num(n)))
            )
            (§ if (d < 0))
            (§
                (§ ass n = -n)
                (§ ass d = -d)
            )
            (§ return (§ expr new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d))))
        )

        #_public
        (§ method Number quotient(Number x, Number y)
            (§ return (§ expr num(x.longValue() / y.longValue())))
        )

        #_public
        (§ method Number remainder(Number x, Number y)
            (§ return (§ expr num(x.longValue() % y.longValue())))
        )

        #_public
        (§ method boolean equiv(Number x, Number y)
            (§ return (§ expr (x.longValue() == y.longValue())))
        )

        #_public
        (§ method boolean lt(Number x, Number y)
            (§ return (§ expr (x.longValue() < y.longValue())))
        )

        #_public
        (§ method boolean lte(Number x, Number y)
            (§ return (§ expr (x.longValue() <= y.longValue())))
        )

        #_public
        (§ method boolean gte(Number x, Number y)
            (§ return (§ expr (x.longValue() >= y.longValue())))
        )

        #_final
        #_public
        (§ method Number negate(Number x)
            (§ let long val = x.longValue())
            (§ return (§ expr num(Numbers.minus(val))))
        )

        #_final
        #_public
        (§ method Number negateP(Number x)
            (§ let long val = x.longValue())
            (§ if (val > Long.MIN_VALUE))
            (§
                (§ return (§ expr num(-val)))
            )
            (§ return (§ expr BigInt.fromBigInteger(BigInteger.valueOf(val).negate())))
        )

        #_public
        (§ method Number inc(Number x)
            (§ let long val = x.longValue())
            (§ return (§ expr num(Numbers.inc(val))))
        )

        #_public
        (§ method Number incP(Number x)
            (§ let long val = x.longValue())
            (§ if (val < Long.MAX_VALUE))
            (§
                (§ return (§ expr num(val + 1)))
            )
            (§ return (§ expr BIGINT_OPS.inc(x)))
        )

        #_public
        (§ method Number dec(Number x)
            (§ let long val = x.longValue())
            (§ return (§ expr num(Numbers.dec(val))))
        )

        #_public
        (§ method Number decP(Number x)
            (§ let long val = x.longValue())
            (§ if (val > Long.MIN_VALUE))
            (§
                (§ return (§ expr num(val - 1)))
            )
            (§ return (§ expr BIGINT_OPS.dec(x)))
        )
    )

    #_final
    #_static
    (class-ns DoubleOps (§ extends OpsP)
        #_public
        (§ method Ops combine(Ops y)
            (§ return (§ expr y.opsWith(this)))
        )

        #_final
        #_public
        (§ method Ops opsWith(LongOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(DoubleOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(RatioOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigIntOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigDecimalOps x)
            (§ return (§ expr this))
        )

        #_public
        (§ method boolean isZero(Number x)
            (§ return (§ expr (x.doubleValue() == 0)))
        )

        #_public
        (§ method boolean isPos(Number x)
            (§ return (§ expr (x.doubleValue() > 0)))
        )

        #_public
        (§ method boolean isNeg(Number x)
            (§ return (§ expr (x.doubleValue() < 0)))
        )

        #_final
        #_public
        (§ method Number add(Number x, Number y)
            (§ return (§ expr Double.valueOf(x.doubleValue() + y.doubleValue())))
        )

        #_final
        #_public
        (§ method Number multiply(Number x, Number y)
            (§ return (§ expr Double.valueOf(x.doubleValue() * y.doubleValue())))
        )

        #_public
        (§ method Number divide(Number x, Number y)
            (§ return (§ expr Double.valueOf(x.doubleValue() / y.doubleValue())))
        )

        #_public
        (§ method Number quotient(Number x, Number y)
            (§ return (§ expr Numbers.quotient(x.doubleValue(), y.doubleValue())))
        )

        #_public
        (§ method Number remainder(Number x, Number y)
            (§ return (§ expr Numbers.remainder(x.doubleValue(), y.doubleValue())))
        )

        #_public
        (§ method boolean equiv(Number x, Number y)
            (§ return (§ expr (x.doubleValue() == y.doubleValue())))
        )

        #_public
        (§ method boolean lt(Number x, Number y)
            (§ return (§ expr (x.doubleValue() < y.doubleValue())))
        )

        #_public
        (§ method boolean lte(Number x, Number y)
            (§ return (§ expr (x.doubleValue() <= y.doubleValue())))
        )

        #_public
        (§ method boolean gte(Number x, Number y)
            (§ return (§ expr (x.doubleValue() >= y.doubleValue())))
        )

        #_final
        #_public
        (§ method Number negate(Number x)
            (§ return (§ expr Double.valueOf(-x.doubleValue())))
        )

        #_public
        (§ method Number inc(Number x)
            (§ return (§ expr Double.valueOf(x.doubleValue() + 1)))
        )

        #_public
        (§ method Number dec(Number x)
            (§ return (§ expr Double.valueOf(x.doubleValue() - 1)))
        )
    )

    #_final
    #_static
    (class-ns RatioOps (§ extends OpsP)
        #_public
        (§ method Ops combine(Ops y)
            (§ return (§ expr y.opsWith(this)))
        )

        #_final
        #_public
        (§ method Ops opsWith(LongOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(DoubleOps x)
            (§ return (§ expr DOUBLE_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(RatioOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigIntOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigDecimalOps x)
            (§ return (§ expr BIGDECIMAL_OPS))
        )

        #_public
        (§ method boolean isZero(Number x)
            (§ let Ratio r = (Ratio) x)
            (§ return (§ expr (r.numerator.signum() == 0)))
        )

        #_public
        (§ method boolean isPos(Number x)
            (§ let Ratio r = (Ratio) x)
            (§ return (§ expr (r.numerator.signum() > 0)))
        )

        #_public
        (§ method boolean isNeg(Number x)
            (§ let Ratio r = (Ratio) x)
            (§ return (§ expr (r.numerator.signum() < 0)))
        )

        #_static
        (§ method Number normalizeRet(Number ret, Number x, Number y)
            (§ return (§ expr ret))
        )

        #_final
        #_public
        (§ method Number add(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let Number ret = divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator)))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        #_final
        #_public
        (§ method Number multiply(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let Number ret = Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator)))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        #_public
        (§ method Number divide(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let Number ret = Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator)))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        #_public
        (§ method Number quotient(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))
            (§ return (§ expr normalizeRet(BigInt.fromBigInteger(q), x, y)))
        )

        #_public
        (§ method Number remainder(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ let BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))
            (§ let Number ret = Numbers.minus(x, Numbers.multiply(q, y)))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        #_public
        (§ method boolean equiv(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ return (§ expr (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator))))
        )

        #_public
        (§ method boolean lt(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ return (§ expr Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))))
        )

        #_public
        (§ method boolean lte(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ return (§ expr Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))))
        )

        #_public
        (§ method boolean gte(Number x, Number y)
            (§ let Ratio rx = toRatio(x))
            (§ let Ratio ry = toRatio(y))
            (§ return (§ expr Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))))
        )

        #_final
        #_public
        (§ method Number negate(Number x)
            (§ let Ratio r = (Ratio) x)
            (§ return (§ expr new Ratio(r.numerator.negate(), r.denominator)))
        )

        #_public
        (§ method Number inc(Number x)
            (§ return (§ expr Numbers.add(x, 1)))
        )

        #_public
        (§ method Number dec(Number x)
            (§ return (§ expr Numbers.add(x, -1)))
        )
    )

    #_final
    #_static
    (class-ns BigIntOps (§ extends OpsP)
        #_public
        (§ method Ops combine(Ops y)
            (§ return (§ expr y.opsWith(this)))
        )

        #_final
        #_public
        (§ method Ops opsWith(LongOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(DoubleOps x)
            (§ return (§ expr DOUBLE_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(RatioOps x)
            (§ return (§ expr RATIO_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigIntOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigDecimalOps x)
            (§ return (§ expr BIGDECIMAL_OPS))
        )

        #_public
        (§ method boolean isZero(Number x)
            (§ let BigInt bx = toBigInt(x))
            (§ if (bx.bipart == nil))
            (§
                (§ return (§ expr (bx.lpart == 0)))
            )
            (§ return (§ expr (bx.bipart.signum() == 0)))
        )

        #_public
        (§ method boolean isPos(Number x)
            (§ let BigInt bx = toBigInt(x))
            (§ if (bx.bipart == nil))
            (§
                (§ return (§ expr (bx.lpart > 0)))
            )
            (§ return (§ expr (bx.bipart.signum() > 0)))
        )

        #_public
        (§ method boolean isNeg(Number x)
            (§ let BigInt bx = toBigInt(x))
            (§ if (bx.bipart == nil))
            (§
                (§ return (§ expr (bx.lpart < 0)))
            )
            (§ return (§ expr (bx.bipart.signum() < 0)))
        )

        #_final
        #_public
        (§ method Number add(Number x, Number y)
            (§ return (§ expr toBigInt(x).add(toBigInt(y))))
        )

        #_final
        #_public
        (§ method Number multiply(Number x, Number y)
            (§ return (§ expr toBigInt(x).multiply(toBigInt(y))))
        )

        #_public
        (§ method Number divide(Number x, Number y)
            (§ return (§ expr Numbers.divide(toBigInteger(x), toBigInteger(y))))
        )

        #_public
        (§ method Number quotient(Number x, Number y)
            (§ return (§ expr toBigInt(x).quotient(toBigInt(y))))
        )

        #_public
        (§ method Number remainder(Number x, Number y)
            (§ return (§ expr toBigInt(x).remainder(toBigInt(y))))
        )

        #_public
        (§ method boolean equiv(Number x, Number y)
            (§ return (§ expr toBigInt(x).equals(toBigInt(y))))
        )

        #_public
        (§ method boolean lt(Number x, Number y)
            (§ return (§ expr toBigInt(x).lt(toBigInt(y))))
        )

        #_public
        (§ method boolean lte(Number x, Number y)
            (§ return (§ expr (toBigInteger(x).compareTo(toBigInteger(y)) <= 0)))
        )

        #_public
        (§ method boolean gte(Number x, Number y)
            (§ return (§ expr (toBigInteger(x).compareTo(toBigInteger(y)) >= 0)))
        )

        #_final
        #_public
        (§ method Number negate(Number x)
            (§ return (§ expr BigInt.fromBigInteger(toBigInteger(x).negate())))
        )

        #_public
        (§ method Number inc(Number x)
            (§ let BigInteger bx = toBigInteger(x))
            (§ return (§ expr BigInt.fromBigInteger(bx.add(BigInteger.ONE))))
        )

        #_public
        (§ method Number dec(Number x)
            (§ let BigInteger bx = toBigInteger(x))
            (§ return (§ expr BigInt.fromBigInteger(bx.subtract(BigInteger.ONE))))
        )
    )

    #_final
    #_static
    (class-ns BigDecimalOps (§ extends OpsP)
        #_final
        #_static
        (§ field Var MATH_CONTEXT = RT.MATH_CONTEXT)

        #_public
        (§ method Ops combine(Ops y)
            (§ return (§ expr y.opsWith(this)))
        )

        #_final
        #_public
        (§ method Ops opsWith(LongOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(DoubleOps x)
            (§ return (§ expr DOUBLE_OPS))
        )

        #_final
        #_public
        (§ method Ops opsWith(RatioOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigIntOps x)
            (§ return (§ expr this))
        )

        #_final
        #_public
        (§ method Ops opsWith(BigDecimalOps x)
            (§ return (§ expr this))
        )

        #_public
        (§ method boolean isZero(Number x)
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ return (§ expr (bx.signum() == 0)))
        )

        #_public
        (§ method boolean isPos(Number x)
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ return (§ expr (bx.signum() > 0)))
        )

        #_public
        (§ method boolean isNeg(Number x)
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ return (§ expr (bx.signum() < 0)))
        )

        #_final
        #_public
        (§ method Number add(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc)))
        )

        #_final
        #_public
        (§ method Number multiply(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc)))
        )

        #_public
        (§ method Number divide(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc)))
        )

        #_public
        (§ method Number quotient(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc)))
        )

        #_public
        (§ method Number remainder(Number x, Number y)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc)))
        )

        #_public
        (§ method boolean equiv(Number x, Number y)
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0)))
        )

        #_public
        (§ method boolean lt(Number x, Number y)
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0)))
        )

        #_public
        (§ method boolean lte(Number x, Number y)
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0)))
        )

        #_public
        (§ method boolean gte(Number x, Number y)
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0)))
        )

        #_final
        #_public
        (§ method Number negate(Number x)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ return (§ expr (mc == nil) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc)))
        )

        #_public
        (§ method Number inc(Number x)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ return (§ expr (mc == nil) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc)))
        )

        #_public
        (§ method Number dec(Number x)
            (§ let MathContext mc = (MathContext) MATH_CONTEXT.deref())
            (§ let BigDecimal bx = (BigDecimal) x)
            (§ return (§ expr (mc == nil) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc)))
        )
    )

    #_static
    #_final
    (§ field LongOps LONG_OPS = new LongOps())
    #_static
    #_final
    (§ field DoubleOps DOUBLE_OPS = new DoubleOps())
    #_static
    #_final
    (§ field RatioOps RATIO_OPS = new RatioOps())
    #_static
    #_final
    (§ field BigIntOps BIGINT_OPS = new BigIntOps())
    #_static
    #_final
    (§ field BigDecimalOps BIGDECIMAL_OPS = new BigDecimalOps())

    #_static
    #_public
    (§ enum Category
        (§ item INTEGER),
        (§ item FLOATING),
        (§ item DECIMAL),
        (§ item RATIO)
    )

    #_static
    (§ method Ops ops(Object x)
        (§ let Class xc = x.getClass())

        (§ if (xc == Long.class))
        (§
            (§ return (§ expr LONG_OPS))
        )
        (§ elseif (xc == Double.class))
        (§
            (§ return (§ expr DOUBLE_OPS))
        )
        (§ elseif (xc == Integer.class))
        (§
            (§ return (§ expr LONG_OPS))
        )
        (§ elseif (xc == Float.class))
        (§
            (§ return (§ expr DOUBLE_OPS))
        )
        (§ elseif (xc == BigInt.class))
        (§
            (§ return (§ expr BIGINT_OPS))
        )
        (§ elseif (xc == BigInteger.class))
        (§
            (§ return (§ expr BIGINT_OPS))
        )
        (§ elseif (xc == Ratio.class))
        (§
            (§ return (§ expr RATIO_OPS))
        )
        (§ elseif (xc == BigDecimal.class))
        (§
            (§ return (§ expr BIGDECIMAL_OPS))
        )
        (§ else )
        (§
            (§ return (§ expr LONG_OPS))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    (§ method int hasheqFrom(Number x, Class xc)
        (§ if (xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE))))
        (§
            (§ let long lpart = x.longValue())
            (§ return (§ expr Murmur3.hashLong(lpart)))
        )
        (§ if (xc == BigDecimal.class))
        (§
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode.  Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (§ if (isZero(x)))
            (§
                (§ return (§ expr BigDecimal.ZERO.hashCode()))
            )
            (§ else )
            (§
                (§ return (§ expr ((BigDecimal) x).stripTrailingZeros().hashCode()))
            )
        )
        (§ if (xc == Float.class && x.equals((§ float -0.0))))
        (§
            (§ return (§ expr 0)) ;; match 0.0f
        )
        (§ return (§ expr x.hashCode()))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    (§ method int hasheq(Number x)
        (§ let Class xc = x.getClass())

        (§ if (xc == Long.class))
        (§
            (§ let long lpart = x.longValue())
            (§ return (§ expr Murmur3.hashLong(lpart)))
        )
        (§ if (xc == Double.class))
        (§
            (§ if (x.equals(-0.0)))
            (§
                (§ return (§ expr 0)) ;; match 0.0
            )
            (§ return (§ expr x.hashCode()))
        )
        (§ return (§ expr hasheqFrom(x, xc)))
    )

    #_static
    (§ method Category category(Object x)
        (§ let Class xc = x.getClass())

        (§ if (xc == Integer.class))
        (§
            (§ return (§ expr Category.INTEGER))
        )
        (§ elseif (xc == Double.class))
        (§
            (§ return (§ expr Category.FLOATING))
        )
        (§ elseif (xc == Long.class))
        (§
            (§ return (§ expr Category.INTEGER))
        )
        (§ elseif (xc == Float.class))
        (§
            (§ return (§ expr Category.FLOATING))
        )
        (§ elseif (xc == BigInt.class))
        (§
            (§ return (§ expr Category.INTEGER))
        )
        (§ elseif (xc == Ratio.class))
        (§
            (§ return (§ expr Category.RATIO))
        )
        (§ elseif (xc == BigDecimal.class))
        (§
            (§ return (§ expr Category.DECIMAL))
        )
        (§ else )
        (§
            (§ return (§ expr Category.INTEGER))
        )
    )

    #_static
    (§ method long bitOpsCast(Object x)
        (§ let Class xc = x.getClass())

        (§ if (xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class))
        (§
            (§ return (§ expr RT.longCast(x)))
        )
        ;; no bignums, no decimals
        (§ throw new IllegalArgumentException("bit operation not supported for: " + xc))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method float[] float_array(int size, Object init)
        (§ let float[] ret = new float[size])
        (§ if (init instanceof Number))
        (§
            (§ let float f = ((Number) init).floatValue())
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = f)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).floatValue())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method float[] float_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new float[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let float[] ret = new float[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).floatValue())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method double[] double_array(int size, Object init)
        (§ let double[] ret = new double[size])
        (§ if (init instanceof Number))
        (§
            (§ let double f = ((Number) init).doubleValue())
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = f)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).doubleValue())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method double[] double_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new double[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let double[] ret = new double[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).doubleValue())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method int[] int_array(int size, Object init)
        (§ let int[] ret = new int[size])
        (§ if (init instanceof Number))
        (§
            (§ let int f = ((Number) init).intValue())
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = f)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).intValue())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method int[] int_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new int[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let int[] ret = new int[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).intValue())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method long[] long_array(int size, Object init)
        (§ let long[] ret = new long[size])
        (§ if (init instanceof Number))
        (§
            (§ let long f = ((Number) init).longValue())
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = f)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).longValue())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method long[] long_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new long[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let long[] ret = new long[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).longValue())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method short[] short_array(int size, Object init)
        (§ let short[] ret = new short[size])
        (§ if (init instanceof Short))
        (§
            (§ let short s = (Short) init)
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = s)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).shortValue())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method short[] short_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new short[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let short[] ret = new short[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).shortValue())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method char[] char_array(int size, Object init)
        (§ let char[] ret = new char[size])
        (§ if (init instanceof Character))
        (§
            (§ let char c = (Character) init)
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = c)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = (Character) s.first())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method char[] char_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new char[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let char[] ret = new char[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = (Character) s.first())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method byte[] byte_array(int size, Object init)
        (§ let byte[] ret = new byte[size])
        (§ if (init instanceof Byte))
        (§
            (§ let byte b = (Byte) init)
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = b)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).byteValue())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method byte[] byte_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new byte[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let byte[] ret = new byte[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = ((Number) s.first()).byteValue())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method boolean[] boolean_array(int size, Object init)
        (§ let boolean[] ret = new boolean[size])
        (§ if (init instanceof Boolean))
        (§
            (§ let boolean b = (Boolean) init)
            (§ for (int i = 0 i < ret.length i++))
            (§
                (§ ass ret[i] = b)
            )
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(init))
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = (Boolean)s.first())
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method boolean[] boolean_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new boolean[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let boolean[] ret = new boolean[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = (Boolean)s.first())
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method boolean[] booleans(Object array)
        (§ return (§ expr (boolean[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method byte[] bytes(Object array)
        (§ return (§ expr (byte[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method char[] chars(Object array)
        (§ return (§ expr (char[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method short[] shorts(Object array)
        (§ return (§ expr (short[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method float[] floats(Object array)
        (§ return (§ expr (float[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method double[] doubles(Object array)
        (§ return (§ expr (double[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method int[] ints(Object array)
        (§ return (§ expr (int[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    #_static
    #_public
    (§ method long[] longs(Object array)
        (§ return (§ expr (long[]) array))
    )

    #_static
    #_public
    (§ method Number num(Object x)
        (§ return (§ expr (Number) x))
    )

    #_static
    #_public
    (§ method Number num(float x)
        (§ return (§ expr Float.valueOf(x)))
    )

    #_static
    #_public
    (§ method Number num(double x)
        (§ return (§ expr Double.valueOf(x)))
    )

    #_static
    #_public
    (§ method double add(double x, double y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method double addP(double x, double y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method double minus(double x, double y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method double minusP(double x, double y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method double minus(double x)
        (§ return (§ expr -x))
    )

    #_static
    #_public
    (§ method double minusP(double x)
        (§ return (§ expr -x))
    )

    #_static
    #_public
    (§ method double inc(double x)
        (§ return (§ expr x + 1))
    )

    #_static
    #_public
    (§ method double incP(double x)
        (§ return (§ expr x + 1))
    )

    #_static
    #_public
    (§ method double dec(double x)
        (§ return (§ expr x - 1))
    )

    #_static
    #_public
    (§ method double decP(double x)
        (§ return (§ expr x - 1))
    )

    #_static
    #_public
    (§ method double multiply(double x, double y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method double multiplyP(double x, double y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method double divide(double x, double y)
        (§ return (§ expr x / y))
    )

    #_static
    #_public
    (§ method boolean equiv(double x, double y)
        (§ return (§ expr (x == y)))
    )

    #_static
    #_public
    (§ method boolean lt(double x, double y)
        (§ return (§ expr (x < y)))
    )

    #_static
    #_public
    (§ method boolean lte(double x, double y)
        (§ return (§ expr (x <= y)))
    )

    #_static
    #_public
    (§ method boolean gt(double x, double y)
        (§ return (§ expr (x > y)))
    )

    #_static
    #_public
    (§ method boolean gte(double x, double y)
        (§ return (§ expr (x >= y)))
    )

    #_static
    #_public
    (§ method boolean isPos(double x)
        (§ return (§ expr (x > 0)))
    )

    #_static
    #_public
    (§ method boolean isNeg(double x)
        (§ return (§ expr (x < 0)))
    )

    #_static
    #_public
    (§ method boolean isZero(double x)
        (§ return (§ expr (x == 0)))
    )

    #_static
    (§ method int throwIntOverflow()
        (§ throw new ArithmeticException("integer overflow"))
    )

    #_static
    #_public
    (§ method int unchecked_int_add(int x, int y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method int unchecked_int_subtract(int x, int y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method int unchecked_int_negate(int x)
        (§ return (§ expr -x))
    )

    #_static
    #_public
    (§ method int unchecked_int_inc(int x)
        (§ return (§ expr x + 1))
    )

    #_static
    #_public
    (§ method int unchecked_int_dec(int x)
        (§ return (§ expr x - 1))
    )

    #_static
    #_public
    (§ method int unchecked_int_multiply(int x, int y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method long not(Object x)
        (§ return (§ expr not(bitOpsCast(x))))
    )

    #_static
    #_public
    (§ method long not(long x)
        (§ return (§ expr ~x))
    )

    #_static
    #_public
    (§ method long and(Object x, Object y)
        (§ return (§ expr and(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long and(Object x, long y)
        (§ return (§ expr and(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long and(long x, Object y)
        (§ return (§ expr and(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long and(long x, long y)
        (§ return (§ expr x & y))
    )

    #_static
    #_public
    (§ method long or(Object x, Object y)
        (§ return (§ expr or(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long or(Object x, long y)
        (§ return (§ expr or(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long or(long x, Object y)
        (§ return (§ expr or(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long or(long x, long y)
        (§ return (§ expr x | y))
    )

    #_static
    #_public
    (§ method long xor(Object x, Object y)
        (§ return (§ expr xor(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long xor(Object x, long y)
        (§ return (§ expr xor(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long xor(long x, Object y)
        (§ return (§ expr xor(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long xor(long x, long y)
        (§ return (§ expr x :xor y))
    )

    #_static
    #_public
    (§ method long andNot(Object x, Object y)
        (§ return (§ expr andNot(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long andNot(Object x, long y)
        (§ return (§ expr andNot(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long andNot(long x, Object y)
        (§ return (§ expr andNot(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long andNot(long x, long y)
        (§ return (§ expr x & ~y))
    )

    #_static
    #_public
    (§ method long clearBit(Object x, Object y)
        (§ return (§ expr clearBit(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long clearBit(Object x, long y)
        (§ return (§ expr clearBit(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long clearBit(long x, Object y)
        (§ return (§ expr clearBit(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long clearBit(long x, long n)
        (§ return (§ expr x & ~(1 << n)))
    )

    #_static
    #_public
    (§ method long setBit(Object x, Object y)
        (§ return (§ expr setBit(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long setBit(Object x, long y)
        (§ return (§ expr setBit(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long setBit(long x, Object y)
        (§ return (§ expr setBit(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long setBit(long x, long n)
        (§ return (§ expr x | (1 << n)))
    )

    #_static
    #_public
    (§ method long flipBit(Object x, Object y)
        (§ return (§ expr flipBit(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long flipBit(Object x, long y)
        (§ return (§ expr flipBit(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method long flipBit(long x, Object y)
        (§ return (§ expr flipBit(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method long flipBit(long x, long n)
        (§ return (§ expr x :xor (1 << n)))
    )

    #_static
    #_public
    (§ method boolean testBit(Object x, Object y)
        (§ return (§ expr testBit(bitOpsCast(x), bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method boolean testBit(Object x, long y)
        (§ return (§ expr testBit(bitOpsCast(x), y)))
    )

    #_static
    #_public
    (§ method boolean testBit(long x, Object y)
        (§ return (§ expr testBit(x, bitOpsCast(y))))
    )

    #_static
    #_public
    (§ method boolean testBit(long x, long n)
        (§ return (§ expr ((x & (1 << n)) != 0)))
    )

    #_static
    #_public
    (§ method int unchecked_int_divide(int x, int y)
        (§ return (§ expr x / y))
    )

    #_static
    #_public
    (§ method int unchecked_int_remainder(int x, int y)
        (§ return (§ expr x % y))
    )

    #_static
    #_public
    (§ method Number num(long x)
        (§ return (§ expr Long.valueOf(x)))
    )

    #_static
    #_public
    (§ method long unchecked_add(long x, long y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method long unchecked_minus(long x, long y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method long unchecked_multiply(long x, long y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method long unchecked_minus(long x)
        (§ return (§ expr -x))
    )

    #_static
    #_public
    (§ method long unchecked_inc(long x)
        (§ return (§ expr x + 1))
    )

    #_static
    #_public
    (§ method long unchecked_dec(long x)
        (§ return (§ expr x - 1))
    )

    #_static
    #_public
    (§ method Number unchecked_add(Object x, Object y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_minus(Object x, Object y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_multiply(Object x, Object y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_minus(Object x)
        (§ return (§ expr minus(x)))
    )

    #_static
    #_public
    (§ method Number unchecked_inc(Object x)
        (§ return (§ expr inc(x)))
    )

    #_static
    #_public
    (§ method Number unchecked_dec(Object x)
        (§ return (§ expr dec(x)))
    )

    #_static
    #_public
    (§ method double unchecked_add(double x, double y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_minus(double x, double y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_multiply(double x, double y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_minus(double x)
        (§ return (§ expr minus(x)))
    )

    #_static
    #_public
    (§ method double unchecked_inc(double x)
        (§ return (§ expr inc(x)))
    )

    #_static
    #_public
    (§ method double unchecked_dec(double x)
        (§ return (§ expr dec(x)))
    )

    #_static
    #_public
    (§ method double unchecked_add(double x, Object y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_minus(double x, Object y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_multiply(double x, Object y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_add(Object x, double y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_minus(Object x, double y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_multiply(Object x, double y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_add(double x, long y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_minus(double x, long y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_multiply(double x, long y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_add(long x, double y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_minus(long x, double y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method double unchecked_multiply(long x, double y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_add(long x, Object y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_minus(long x, Object y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_multiply(long x, Object y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_add(Object x, long y)
        (§ return (§ expr add(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_minus(Object x, long y)
        (§ return (§ expr minus(x, y)))
    )

    #_static
    #_public
    (§ method Number unchecked_multiply(Object x, long y)
        (§ return (§ expr multiply(x, y)))
    )

    #_static
    #_public
    (§ method Number quotient(double x, Object y)
        (§ return (§ expr quotient((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number quotient(Object x, double y)
        (§ return (§ expr quotient(x, (Object)y)))
    )

    #_static
    #_public
    (§ method Number quotient(long x, Object y)
        (§ return (§ expr quotient((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number quotient(Object x, long y)
        (§ return (§ expr quotient(x, (Object)y)))
    )

    #_static
    #_public
    (§ method double quotient(double x, long y)
        (§ return (§ expr quotient(x, (double)y)))
    )

    #_static
    #_public
    (§ method double quotient(long x, double y)
        (§ return (§ expr quotient((double)x, y)))
    )

    #_static
    #_public
    (§ method Number remainder(double x, Object y)
        (§ return (§ expr remainder((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number remainder(Object x, double y)
        (§ return (§ expr remainder(x, (Object)y)))
    )

    #_static
    #_public
    (§ method Number remainder(long x, Object y)
        (§ return (§ expr remainder((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number remainder(Object x, long y)
        (§ return (§ expr remainder(x, (Object)y)))
    )

    #_static
    #_public
    (§ method double remainder(double x, long y)
        (§ return (§ expr remainder(x, (double)y)))
    )

    #_static
    #_public
    (§ method double remainder(long x, double y)
        (§ return (§ expr remainder((double)x, y)))
    )

    #_static
    #_public
    (§ method long add(long x, long y)
        (§ let long ret = x + y)
        (§ if ((ret :xor x) < 0 && (ret :xor y) < 0))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method Number addP(long x, long y)
        (§ let long ret = x + y)
        (§ if ((ret :xor x) < 0 && (ret :xor y) < 0))
        (§
            (§ return (§ expr addP((Number)x, (Number)y)))
        )
        (§ return (§ expr num(ret)))
    )

    #_static
    #_public
    (§ method long minus(long x, long y)
        (§ let long ret = x - y)
        (§ if (((ret :xor x) < 0 && (ret :xor ~y) < 0)))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method Number minusP(long x, long y)
        (§ let long ret = x - y)
        (§ if (((ret :xor x) < 0 && (ret :xor ~y) < 0)))
        (§
            (§ return (§ expr minusP((Number)x, (Number)y)))
        )
        (§ return (§ expr num(ret)))
    )

    #_static
    #_public
    (§ method long minus(long x)
        (§ if (x == Long.MIN_VALUE))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr -x))
    )

    #_static
    #_public
    (§ method Number minusP(long x)
        (§ if (x == Long.MIN_VALUE))
        (§
            (§ return (§ expr BigInt.fromBigInteger(BigInteger.valueOf(x).negate())))
        )
        (§ return (§ expr num(-x)))
    )

    #_static
    #_public
    (§ method long inc(long x)
        (§ if (x == Long.MAX_VALUE))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr x + 1))
    )

    #_static
    #_public
    (§ method Number incP(long x)
        (§ if (x == Long.MAX_VALUE))
        (§
            (§ return (§ expr BIGINT_OPS.inc(x)))
        )
        (§ return (§ expr num(x + 1)))
    )

    #_static
    #_public
    (§ method long dec(long x)
        (§ if (x == Long.MIN_VALUE))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr x - 1))
    )

    #_static
    #_public
    (§ method Number decP(long x)
        (§ if (x == Long.MIN_VALUE))
        (§
            (§ return (§ expr BIGINT_OPS.dec(x)))
        )
        (§ return (§ expr num(x - 1)))
    )

    #_static
    #_public
    (§ method long multiply(long x, long y)
        (§ if (x == Long.MIN_VALUE && y < 0))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ let long ret = x * y)
        (§ if (y != 0 && ret/y != x))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method Number multiplyP(long x, long y)
        (§ if (x == Long.MIN_VALUE && y < 0))
        (§
            (§ return (§ expr multiplyP((Number)x, (Number)y)))
        )
        (§ let long ret = x * y)
        (§ if (y != 0 && ret/y != x))
        (§
            (§ return (§ expr multiplyP((Number)x, (Number)y)))
        )
        (§ return (§ expr num(ret)))
    )

    #_static
    #_public
    (§ method long quotient(long x, long y)
        (§ return (§ expr x / y))
    )

    #_static
    #_public
    (§ method long remainder(long x, long y)
        (§ return (§ expr x % y))
    )

    #_static
    #_public
    (§ method boolean equiv(long x, long y)
        (§ return (§ expr (x == y)))
    )

    #_static
    #_public
    (§ method boolean lt(long x, long y)
        (§ return (§ expr (x < y)))
    )

    #_static
    #_public
    (§ method boolean lte(long x, long y)
        (§ return (§ expr (x <= y)))
    )

    #_static
    #_public
    (§ method boolean gt(long x, long y)
        (§ return (§ expr (x > y)))
    )

    #_static
    #_public
    (§ method boolean gte(long x, long y)
        (§ return (§ expr (x >= y)))
    )

    #_static
    #_public
    (§ method boolean isPos(long x)
        (§ return (§ expr (x > 0)))
    )

    #_static
    #_public
    (§ method boolean isNeg(long x)
        (§ return (§ expr (x < 0)))
    )

    #_static
    #_public
    (§ method boolean isZero(long x)
        (§ return (§ expr (x == 0)))
    )

    ;; overload resolution

    #_static
    #_public
    (§ method Number add(long x, Object y)
        (§ return (§ expr add((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number add(Object x, long y)
        (§ return (§ expr add(x, (Object)y)))
    )

    #_static
    #_public
    (§ method Number addP(long x, Object y)
        (§ return (§ expr addP((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number addP(Object x, long y)
        (§ return (§ expr addP(x, (Object)y)))
    )

    #_static
    #_public
    (§ method double add(double x, Object y)
        (§ return (§ expr add(x, ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method double add(Object x, double y)
        (§ return (§ expr add(((Number)x).doubleValue(), y)))
    )

    #_static
    #_public
    (§ method double add(double x, long y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method double add(long x, double y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method double addP(double x, Object y)
        (§ return (§ expr addP(x, ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method double addP(Object x, double y)
        (§ return (§ expr addP(((Number)x).doubleValue(), y)))
    )

    #_static
    #_public
    (§ method double addP(double x, long y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method double addP(long x, double y)
        (§ return (§ expr x + y))
    )

    #_static
    #_public
    (§ method Number minus(long x, Object y)
        (§ return (§ expr minus((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number minus(Object x, long y)
        (§ return (§ expr minus(x, (Object)y)))
    )

    #_static
    #_public
    (§ method Number minusP(long x, Object y)
        (§ return (§ expr minusP((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number minusP(Object x, long y)
        (§ return (§ expr minusP(x, (Object)y)))
    )

    #_static
    #_public
    (§ method double minus(double x, Object y)
        (§ return (§ expr minus(x, ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method double minus(Object x, double y)
        (§ return (§ expr minus(((Number)x).doubleValue(), y)))
    )

    #_static
    #_public
    (§ method double minus(double x, long y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method double minus(long x, double y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method double minusP(double x, Object y)
        (§ return (§ expr minus(x, ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method double minusP(Object x, double y)
        (§ return (§ expr minus(((Number)x).doubleValue(), y)))
    )

    #_static
    #_public
    (§ method double minusP(double x, long y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method double minusP(long x, double y)
        (§ return (§ expr x - y))
    )

    #_static
    #_public
    (§ method Number multiply(long x, Object y)
        (§ return (§ expr multiply((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number multiply(Object x, long y)
        (§ return (§ expr multiply(x, (Object)y)))
    )

    #_static
    #_public
    (§ method Number multiplyP(long x, Object y)
        (§ return (§ expr multiplyP((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number multiplyP(Object x, long y)
        (§ return (§ expr multiplyP(x, (Object)y)))
    )

    #_static
    #_public
    (§ method double multiply(double x, Object y)
        (§ return (§ expr multiply(x, ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method double multiply(Object x, double y)
        (§ return (§ expr multiply(((Number)x).doubleValue(), y)))
    )

    #_static
    #_public
    (§ method double multiply(double x, long y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method double multiply(long x, double y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method double multiplyP(double x, Object y)
        (§ return (§ expr multiplyP(x, ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method double multiplyP(Object x, double y)
        (§ return (§ expr multiplyP(((Number)x).doubleValue(), y)))
    )

    #_static
    #_public
    (§ method double multiplyP(double x, long y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method double multiplyP(long x, double y)
        (§ return (§ expr x * y))
    )

    #_static
    #_public
    (§ method Number divide(long x, Object y)
        (§ return (§ expr divide((Object)x, y)))
    )

    #_static
    #_public
    (§ method Number divide(Object x, long y)
        (§ return (§ expr divide(x, (Object)y)))
    )

    #_static
    #_public
    (§ method double divide(double x, Object y)
        (§ return (§ expr x / ((Number)y).doubleValue()))
    )

    #_static
    #_public
    (§ method double divide(Object x, double y)
        (§ return (§ expr ((Number)x).doubleValue() / y))
    )

    #_static
    #_public
    (§ method double divide(double x, long y)
        (§ return (§ expr x / y))
    )

    #_static
    #_public
    (§ method double divide(long x, double y)
        (§ return (§ expr x / y))
    )

    #_static
    #_public
    (§ method Number divide(long x, long y)
        (§ return (§ expr divide((Number)x, (Number)y)))
    )

    #_static
    #_public
    (§ method boolean lt(long x, Object y)
        (§ return (§ expr lt((Object)x, y)))
    )

    #_static
    #_public
    (§ method boolean lt(Object x, long y)
        (§ return (§ expr lt(x, (Object)y)))
    )

    #_static
    #_public
    (§ method boolean lt(double x, Object y)
        (§ return (§ expr (x < ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method boolean lt(Object x, double y)
        (§ return (§ expr (((Number)x).doubleValue() < y)))
    )

    #_static
    #_public
    (§ method boolean lt(double x, long y)
        (§ return (§ expr (x < y)))
    )

    #_static
    #_public
    (§ method boolean lt(long x, double y)
        (§ return (§ expr (x < y)))
    )

    #_static
    #_public
    (§ method boolean lte(long x, Object y)
        (§ return (§ expr lte((Object)x, y)))
    )

    #_static
    #_public
    (§ method boolean lte(Object x, long y)
        (§ return (§ expr lte(x, (Object)y)))
    )

    #_static
    #_public
    (§ method boolean lte(double x, Object y)
        (§ return (§ expr (x <= ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method boolean lte(Object x, double y)
        (§ return (§ expr (((Number)x).doubleValue() <= y)))
    )

    #_static
    #_public
    (§ method boolean lte(double x, long y)
        (§ return (§ expr (x <= y)))
    )

    #_static
    #_public
    (§ method boolean lte(long x, double y)
        (§ return (§ expr (x <= y)))
    )

    #_static
    #_public
    (§ method boolean gt(long x, Object y)
        (§ return (§ expr gt((Object)x, y)))
    )

    #_static
    #_public
    (§ method boolean gt(Object x, long y)
        (§ return (§ expr gt(x, (Object)y)))
    )

    #_static
    #_public
    (§ method boolean gt(double x, Object y)
        (§ return (§ expr (x > ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method boolean gt(Object x, double y)
        (§ return (§ expr (((Number)x).doubleValue() > y)))
    )

    #_static
    #_public
    (§ method boolean gt(double x, long y)
        (§ return (§ expr (x > y)))
    )

    #_static
    #_public
    (§ method boolean gt(long x, double y)
        (§ return (§ expr (x > y)))
    )

    #_static
    #_public
    (§ method boolean gte(long x, Object y)
        (§ return (§ expr gte((Object)x, y)))
    )

    #_static
    #_public
    (§ method boolean gte(Object x, long y)
        (§ return (§ expr gte(x, (Object)y)))
    )

    #_static
    #_public
    (§ method boolean gte(double x, Object y)
        (§ return (§ expr (x >= ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method boolean gte(Object x, double y)
        (§ return (§ expr (((Number)x).doubleValue() >= y)))
    )

    #_static
    #_public
    (§ method boolean gte(double x, long y)
        (§ return (§ expr (x >= y)))
    )

    #_static
    #_public
    (§ method boolean gte(long x, double y)
        (§ return (§ expr (x >= y)))
    )

    #_static
    #_public
    (§ method boolean equiv(long x, Object y)
        (§ return (§ expr equiv((Object)x, y)))
    )

    #_static
    #_public
    (§ method boolean equiv(Object x, long y)
        (§ return (§ expr equiv(x, (Object)y)))
    )

    #_static
    #_public
    (§ method boolean equiv(double x, Object y)
        (§ return (§ expr (x == ((Number)y).doubleValue())))
    )

    #_static
    #_public
    (§ method boolean equiv(Object x, double y)
        (§ return (§ expr (((Number)x).doubleValue() == y)))
    )

    #_static
    #_public
    (§ method boolean equiv(double x, long y)
        (§ return (§ expr (x == y)))
    )

    #_static
    #_public
    (§ method boolean equiv(long x, double y)
        (§ return (§ expr (x == y)))
    )

    #_static
    (§ method boolean isNaN(Object x)
        (§ return (§ expr (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN()))
    )

    #_static
    #_public
    (§ method double max(double x, double y)
        (§ return (§ expr Math.max(x, y)))
    )

    #_static
    #_public
    (§ method Object max(double x, long y)
        (§ if (Double.isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ if (x > y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object max(double x, Object y)
        (§ if (Double.isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ elseif (isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (x > ((Number)y).doubleValue()))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object max(long x, double y)
        (§ if (Double.isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (x > y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method long max(long x, long y)
        (§ if (x > y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object max(long x, Object y)
        (§ if (isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (gt(x, y)))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object max(Object x, long y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ if (gt(x, y)))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object max(Object x, double y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ elseif (Double.isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (((Number)x).doubleValue() > y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object max(Object x, Object y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ elseif (isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (gt(x, y)))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method double min(double x, double y)
        (§ return (§ expr Math.min(x, y)))
    )

    #_static
    #_public
    (§ method Object min(double x, long y)
        (§ if (Double.isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ if (x < y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object min(double x, Object y)
        (§ if (Double.isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ elseif (isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (x < ((Number)y).doubleValue()))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object min(long x, double y)
        (§ if (Double.isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (x < y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method long min(long x, long y)
        (§ if (x < y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object min(long x, Object y)
        (§ if (isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (lt(x, y)))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object min(Object x, long y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ if (lt(x, y)))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object min(Object x, double y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ elseif (Double.isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (((Number)x).doubleValue() < y))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )

    #_static
    #_public
    (§ method Object min(Object x, Object y)
        (§ if (isNaN(x)))
        (§
            (§ return (§ expr x))
        )
        (§ elseif (isNaN(y)))
        (§
            (§ return (§ expr y))
        )
        (§ if (lt(x, y)))
        (§
            (§ return (§ expr x))
        )
        (§ else )
        (§
            (§ return (§ expr y))
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_public
#_abstract
(class-ns Obj (§ implements IObj)
    #_final
    (§ field IPersistentMap _meta)

    #_public
    (§ method Obj(IPersistentMap meta)
        (§ ass this._meta = meta)
    )

    #_public
    (§ method Obj()
        (§ ass _meta = nil)
    )

    #_final
    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    (§ abstract public Obj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
#_public
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    #_final
    (§ field Object[] array)
    #_static
    #_final
    (§ field int HASHTABLE_THRESHOLD = 16)

    #_public
    #_static
    #_final
    (§ field PersistentArrayMap EMPTY = new PersistentArrayMap())
    #_private
    #_final
    (§ field IPersistentMap _meta)

    #_static
    #_public
    (§ method IPersistentMap create(Map other)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ for (Object o :in other.entrySet()))
        (§
            (§ let Map.Entry e = (Entry) o)
            (§ ass ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (§ return (§ expr ret.persistent()))
    )

    #_protected
    (§ method PersistentArrayMap()
        (§ ass this.array = new Object[] (§))
        (§ ass this._meta = nil)
    )

    #_public
    (§ method PersistentArrayMap withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentArrayMap(meta, array)))
    )

    (§ method PersistentArrayMap create(Object... init)
        (§ return (§ expr new PersistentArrayMap(meta(), init)))
    )

    (§ method IPersistentMap createHT(Object[] init)
        (§ return (§ expr PersistentHashMap.create(meta(), init)))
    )

    #_static
    #_public
    (§ method PersistentArrayMap createWithCheck(Object[] init)
        (§ for (int i = 0 i < init.length i += 2))
        (§
            (§ for (int j = i + 2 j < init.length j += 2))
            (§
                (§ if (equalKey(init[i], init[j])))
                (§
                    (§ throw new IllegalArgumentException("Duplicate key: " + init[i]))
                )
            )
        )
        (§ return (§ expr new PersistentArrayMap(init)))
    )

    #_static
    #_public
    (§ method PersistentArrayMap createAsIfByAssoc(Object[] init)
        (§ if ((init.length & 1) == 1))
        (§
            (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1])))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (§ let int n = 0)
        (§ for (int i = 0 i < init.length i += 2))
        (§
            (§ let boolean duplicateKey = false)
            (§ for (int j = 0 j < i j += 2))
            (§
                (§ if (equalKey(init[i], init[j])))
                (§
                    (§ ass duplicateKey = true)
                    (§ break )
                )
            )
            (§ if (!duplicateKey))
            (§
                (§ ass n += 2)
            )
        )
        (§ if (n < init.length))
        (§
            ;; Create a new shorter array with unique keys, and
            ;; the last value associated with each key.  To behave
            ;; like assoc, the first occurrence of each key must
            ;; be used, since its metadata may be different than
            ;; later equal keys.
            (§ let Object[] nodups = new Object[n])
            (§ let int m = 0)
            (§ for (int i = 0 i < init.length i += 2))
            (§
                (§ let boolean duplicateKey = false)
                (§ for (int j = 0 j < m j += 2))
                (§
                    (§ if (equalKey(init[i], nodups[j])))
                    (§
                        (§ ass duplicateKey = true)
                        (§ break )
                    )
                )
                (§ if (!duplicateKey))
                (§
                    (§ let int j)
                    (§ for (j = init.length - 2 j >= i j -= 2))
                    (§
                        (§ if (equalKey(init[i], init[j])))
                        (§
                            (§ break )
                        )
                    )
                    (§ ass nodups[m] = init[i])
                    (§ ass nodups[m + 1] = init[j + 1])
                    (§ ass m += 2)
                )
            )
            (§ if (m != n))
            (§
                (§ throw new IllegalArgumentException("Internal error: m=" + m))
            )
            (§ ass init = nodups)
        )
        (§ return (§ expr new PersistentArrayMap(init)))
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    #_public
    (§ method PersistentArrayMap(Object[] init)
        (§ ass this.array = init)
        (§ ass this._meta = nil)
    )

    #_public
    (§ method PersistentArrayMap(IPersistentMap meta, Object[] init)
        (§ ass this._meta = meta)
        (§ ass this.array = init)
    )

    #_public
    (§ method int count()
        (§ return (§ expr array.length / 2))
    )

    #_public
    (§ method boolean containsKey(Object key)
        (§ return (§ expr (indexOf(key) >= 0)))
    )

    #_public
    (§ method IMapEntry entryAt(Object key)
        (§ let int i = indexOf(key))
        (§ if (i >= 0))
        (§
            (§ return (§ expr (IMapEntry) MapEntry.create(array[i], array[i + 1])))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method IPersistentMap assocEx(Object key, Object val)
        (§ let int i = indexOf(key))
        (§ let Object[] newArray)
        (§ if (i >= 0))
        (§
            (§ throw Util.runtimeException("Key already present"))
        )
        (§ else ) ;; didn't have key, grow
        (§
            (§ if (array.length > HASHTABLE_THRESHOLD))
            (§
                (§ return (§ expr createHT(array).assocEx(key, val)))
            )
            (§ ass newArray = new Object[array.length + 2])
            (§ if (array.length > 0))
            (§
                (§ call System.arraycopy(array, 0, newArray, 2, array.length))
            )
            (§ ass newArray[0] = key)
            (§ ass newArray[1] = val)
        )
        (§ return (§ expr create(newArray)))
    )

    #_public
    (§ method IPersistentMap assoc(Object key, Object val)
        (§ let int i = indexOf(key))
        (§ let Object[] newArray)
        (§ if (i >= 0)) ;; already have key, same-sized replacement
        (§
            (§ if (array[i + 1] == val)) ;; no change, no op
            (§
                (§ return (§ expr this))
            )
            (§ ass newArray = array.clone())
            (§ ass newArray[i + 1] = val)
        )
        (§ else ) ;; didn't have key, grow
        (§
            (§ if (array.length > HASHTABLE_THRESHOLD))
            (§
                (§ return (§ expr createHT(array).assoc(key, val)))
            )
            (§ ass newArray = new Object[array.length + 2])
            (§ if (array.length > 0))
            (§
                (§ call System.arraycopy(array, 0, newArray, 0, array.length))
            )
            (§ ass newArray[newArray.length - 2] = key)
            (§ ass newArray[newArray.length - 1] = val)
        )
        (§ return (§ expr create(newArray)))
    )

    #_public
    (§ method IPersistentMap without(Object key)
        (§ let int i = indexOf(key))
        (§ if (i >= 0)) ;; have key, will remove
        (§
            (§ let int newlen = array.length - 2)
            (§ if (newlen == 0))
            (§
                (§ return (§ expr empty()))
            )
            (§ let Object[] newArray = new Object[newlen])
            (§ call System.arraycopy(array, 0, newArray, 0, i))
            (§ call System.arraycopy(array, i + 2, newArray, i, newlen - i))
            (§ return (§ expr create(newArray)))
        )
        ;; don't have key, no op
        (§ return (§ expr this))
    )

    #_public
    (§ method IPersistentMap empty()
        (§ return (§ expr (IPersistentMap) EMPTY.withMeta(meta())))
    )

    #_final
    #_public
    (§ method Object valAt(Object key, Object notFound)
        (§ let int i = indexOf(key))
        (§ if (i >= 0))
        (§
            (§ return (§ expr array[i + 1]))
        )
        (§ return (§ expr notFound))
    )

    #_public
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    (§ method int capacity()
        (§ return (§ expr count()))
    )

    #_private
    (§ method int indexOfObject(Object key)
        (§ let Util.EquivPred ep = Util.equivPred(key))
        (§ for (int i = 0 i < array.length i += 2))
        (§
            (§ if (ep.equiv(key, array[i])))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    #_private
    (§ method int indexOf(Object key)
        (§ if (key instanceof Keyword))
        (§
            (§ for (int i = 0 i < array.length i += 2))
            (§
                (§ if (key == array[i]))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )
        (§ else )
        (§
            (§ return (§ expr indexOfObject(key)))
        )
    )

    #_static
    (§ method boolean equalKey(Object k1, Object k2)
        (§ if (k1 instanceof Keyword))
        (§
            (§ return (§ expr (k1 == k2)))
        )
        (§ return (§ expr Util.equiv(k1, k2)))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr new Iter(array, APersistentMap.MAKE_ENTRY)))
    )

    #_public
    (§ method Iterator keyIterator()
        (§ return (§ expr new Iter(array, APersistentMap.MAKE_KEY)))
    )

    #_public
    (§ method Iterator valIterator()
        (§ return (§ expr new Iter(array, APersistentMap.MAKE_VAL)))
    )

    #_public
    (§ method ISeq seq()
        (§ if (array.length > 0))
        (§
            (§ return (§ expr new Seq(array, 0)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    #_static
    (class-ns Seq (§ extends ASeq) (§ implements Counted)
        #_final
        (§ field Object[] array)
        #_final
        (§ field int i)

        (§ method Seq(Object[] array, int i)
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Seq(IPersistentMap meta, Object[] array, int i)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr MapEntry.create(array[i], array[i + 1])))
        )

        #_public
        (§ method ISeq next()
            (§ if (i + 2 < array.length))
            (§
                (§ return (§ expr new Seq(array, i + 2)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ return (§ expr (array.length - i) / 2))
        )

        #_public
        (§ method Obj withMeta(IPersistentMap meta)
            (§ return (§ expr new Seq(meta, array, i)))
        )
    )

    #_static
    (class-ns Iter (§ implements Iterator)
        (§ field IFn f)
        (§ field Object[] array)
        (§ field int i)

        ;; for iterator
        (§ method Iter(Object[] array, IFn f)
            (§ this(array, -2, f))
        )

        ;; for entryAt
        (§ method Iter(Object[] array, int i, IFn f)
            (§ ass this.array = array)
            (§ ass this.i = i)
            (§ ass this.f = f)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (i < array.length - 2)))
        )

        #_public
        (§ method Object next()
            (§ try )
            (§
                (§ ass i += 2)
                (§ return (§ expr f.invoke(array[i], array[i + 1])))
            )
            (§ catch (IndexOutOfBoundsException e))
            (§
                (§ throw new NoSuchElementException())
            )
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    #_public
    (§ method Object kvreduce(IFn f, Object init)
        (§ for (int i = 0 i < array.length i += 2))
        (§
            (§ ass init = f.invoke(init, array[i], array[i + 1]))
            (§ if (RT.isReduced(init)))
            (§
                (§ return (§ expr ((IDeref)init).deref()))
            )
        )
        (§ return (§ expr init))
    )

    #_public
    (§ method ITransientMap asTransient()
        (§ return (§ expr new TransientArrayMap(array)))
    )

    #_static
    #_final
    (class-ns TransientArrayMap (§ extends ATransientMap)
        #_volatile
        (§ field int len)
        #_final
        (§ field Object[] array)
        #_volatile
        (§ field Thread owner)

        #_public
        (§ method TransientArrayMap(Object[] array)
            (§ ass this.owner = Thread.currentThread())
            (§ ass this.array = new Object[Math.max(HASHTABLE_THRESHOLD, array.length)])
            (§ call System.arraycopy(array, 0, this.array, 0, array.length))
            (§ ass this.len = array.length)
        )

        #_private
        (§ method int indexOf(Object key)
            (§ for (int i = 0 i < len i += 2))
            (§
                (§ if (equalKey(array[i], key)))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )

        (§ method ITransientMap doAssoc(Object key, Object val)
            (§ let int i = indexOf(key))
            (§ if (i >= 0)) ;; already have key,
            (§
                (§ if (array[i + 1] != val)) ;; no change, no op
                (§
                    (§ ass array[i + 1] = val)
                )
            )
            (§ else ) ;; didn't have key, grow
            (§
                (§ if (len >= array.length))
                (§
                    (§ return (§ expr PersistentHashMap.create(array).asTransient().assoc(key, val)))
                )
                (§ ass array[len++] = key)
                (§ ass array[len++] = val)
            )
            (§ return (§ expr this))
        )

        (§ method ITransientMap doWithout(Object key)
            (§ let int i = indexOf(key))
            (§ if (i >= 0)) ;; have key, will remove
            (§
                (§ if (len >= 2))
                (§
                    (§ ass array[i] = array[len - 2])
                    (§ ass array[i + 1] = array[len - 1])
                )
                (§ ass len -= 2)
            )
            (§ return (§ expr this))
        )

        (§ method Object doValAt(Object key, Object notFound)
            (§ let int i = indexOf(key))
            (§ if (i >= 0))
            (§
                (§ return (§ expr array[i + 1]))
            )
            (§ return (§ expr notFound))
        )

        (§ method int doCount()
            (§ return (§ expr len / 2))
        )

        (§ method IPersistentMap doPersistent()
            (§ call ensureEditable())
            (§ ass owner = nil)
            (§ let Object[] a = new Object[len])
            (§ call System.arraycopy(array, 0, a, 0, len))
            (§ return (§ expr new PersistentArrayMap(a)))
        )

        (§ method void ensureEditable()
            (§ if (owner == nil))
            (§
                (§ throw new IllegalAccessError("Transient used after persistent! call"))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
#_public
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    #_final
    (§ field int count)
    #_final
    (§ field INode root)
    #_final
    (§ field boolean hasNull)
    #_final
    (§ field Object nullValue)
    #_final
    (§ field IPersistentMap _meta)

    #_final
    #_public
    #_static
    (§ field PersistentHashMap EMPTY = new PersistentHashMap(0, nil, false, nil))
    #_final
    #_private
    #_static
    (§ field Object NOT_FOUND = new Object())

    #_static
    #_public
    (§ method IPersistentMap create(Map other)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ for (Object o :in other.entrySet()))
        (§
            (§ let Map.Entry e = (Entry) o)
            (§ ass ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (§ return (§ expr ret.persistent()))
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    #_public
    #_static
    (§ method PersistentHashMap create(Object... init)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ for (int i = 0 i < init.length i += 2))
        (§
            (§ ass ret = ret.assoc(init[i], init[i + 1]))
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    #_public
    #_static
    (§ method PersistentHashMap createWithCheck(Object... init)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ for (int i = 0 i < init.length i += 2))
        (§
            (§ ass ret = ret.assoc(init[i], init[i + 1]))
            (§ if (ret.count() != i / 2 + 1))
            (§
                (§ throw new IllegalArgumentException("Duplicate key: " + init[i]))
            )
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentHashMap create(ISeq items)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ for (  items != nil items = items.next().next()))
        (§
            (§ if (items.next() == nil))
            (§
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (§ ass ret = ret.assoc(items.first(), RT.second(items)))
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentHashMap createWithCheck(ISeq items)
        (§ let ITransientMap ret = EMPTY.asTransient())
        (§ for (int i = 0 items != nil items = items.next().next(), ++i))
        (§
            (§ if (items.next() == nil))
            (§
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (§ ass ret = ret.assoc(items.first(), RT.second(items)))
            (§ if (ret.count() != i + 1))
            (§
                (§ throw new IllegalArgumentException("Duplicate key: " + items.first()))
            )
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    #_public
    #_static
    (§ method PersistentHashMap create(IPersistentMap meta, Object... init)
        (§ return (§ expr create(init).withMeta(meta)))
    )

    (§ method PersistentHashMap(int count, INode root, boolean hasNull, Object nullValue)
        (§ ass this.count = count)
        (§ ass this.root = root)
        (§ ass this.hasNull = hasNull)
        (§ ass this.nullValue = nullValue)
        (§ ass this._meta = nil)
    )

    #_public
    (§ method PersistentHashMap(IPersistentMap meta, int count, INode root, boolean hasNull, Object nullValue)
        (§ ass this._meta = meta)
        (§ ass this.count = count)
        (§ ass this.root = root)
        (§ ass this.hasNull = hasNull)
        (§ ass this.nullValue = nullValue)
    )

    #_static
    (§ method int hash(Object k)
        (§ return (§ expr Util.hasheq(k)))
    )

    #_public
    (§ method boolean containsKey(Object key)
        (§ if (key == nil))
        (§
            (§ return (§ expr hasNull))
        )
        (§ return (§ expr (root != nil) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false))
    )

    #_public
    (§ method IMapEntry entryAt(Object key)
        (§ if (key == nil))
        (§
            (§ return (§ expr hasNull ? (IMapEntry) MapEntry.create(nil, nullValue) :or nil))
        )
        (§ return (§ expr (root != nil) ? root.find(0, hash(key), key) :or nil))
    )

    #_public
    (§ method IPersistentMap assoc(Object key, Object val)
        (§ if (key == nil))
        (§
            (§ if (hasNull && val == nullValue))
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)))
        )
        (§ let Box addedLeaf = new Box(nil))
        (§ let INode newroot = ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf))
        (§ if (newroot == root))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentHashMap(meta(), (addedLeaf.val == nil) ? count :or count + 1, newroot, hasNull, nullValue)))
    )

    #_public
    (§ method Object valAt(Object key, Object notFound)
        (§ if (key == nil))
        (§
            (§ return (§ expr hasNull ? nullValue :or notFound))
        )
        (§ return (§ expr (root != nil) ? root.find(0, hash(key), key, notFound) :or notFound))
    )

    #_public
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    (§ method IPersistentMap assocEx(Object key, Object val)
        (§ if (containsKey(key)))
        (§
            (§ throw Util.runtimeException("Key already present"))
        )
        (§ return (§ expr assoc(key, val)))
    )

    #_public
    (§ method IPersistentMap without(Object key)
        (§ if (key == nil))
        (§
            (§ return (§ expr hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        (§ if (root == nil))
        (§
            (§ return (§ expr this))
        )
        (§ let INode newroot = root.without(0, hash(key), key))
        (§ if (newroot == root))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue)))
    )

    #_static
    #_final
    (§ field Iterator EMPTY_ITER = new Iterator()
    (§ inner
        #_public
        (§ method boolean hasNext()
            (§ return (§ expr false))
        )

        #_public
        (§ method Object next()
            (§ throw new NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    ))

    #_private
    (§ method Iterator iterator(final IFn f)
        (§ let final Iterator rootIter = (root == nil) ? EMPTY_ITER :or root.iterator(f))
        (§ if (hasNull))
        (§
            (§ return (§ expr new Iterator()
            (§ inner
                #_private
                (§ field boolean seen = false)

                #_public
                (§ method boolean hasNext()
                    (§ if (!seen))
                    (§
                        (§ return (§ expr true))
                    )
                    (§ else )
                    (§
                        (§ return (§ expr rootIter.hasNext()))
                    )
                )

                #_public
                (§ method Object next()
                    (§ if (!seen))
                    (§
                        (§ ass seen = true)
                        (§ return (§ expr f.invoke(nil, nullValue)))
                    )
                    (§ else )
                    (§
                        (§ return (§ expr rootIter.next()))
                    )
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )
        (§ else )
        (§
            (§ return (§ expr rootIter))
        )
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr iterator(APersistentMap.MAKE_ENTRY)))
    )

    #_public
    (§ method Iterator keyIterator()
        (§ return (§ expr iterator(APersistentMap.MAKE_KEY)))
    )

    #_public
    (§ method Iterator valIterator()
        (§ return (§ expr iterator(APersistentMap.MAKE_VAL)))
    )

    #_public
    (§ method Object kvreduce(IFn f, Object init)
        (§ ass init = hasNull ? f.invoke(init, nil, nullValue) :or init)
        (§ if (RT.isReduced(init)))
        (§
            (§ return (§ expr ((IDeref)init).deref()))
        )
        (§ if (root != nil))
        (§
            (§ ass init = root.kvreduce(f, init))
            (§ if (RT.isReduced(init)))
            (§
                (§ return (§ expr ((IDeref)init).deref()))
            )
            (§ else )
            (§
                (§ return (§ expr init))
            )
        )
        (§ return (§ expr init))
    )

    #_public
    (§ method Object fold(long n, final IFn combinef, final IFn reducef, IFn fjinvoke, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
        ;; we are ignoring n for now
        (§ let Callable top = new Callable()
        (§ inner
            #_public
            (§ method Object call() (§ throws Exception)
                (§ let Object ret = combinef.invoke())
                (§ if (root != nil))
                (§
                    (§ ass ret = combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin)))
                )
                (§ return (§ expr hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), nil, nullValue)) :or ret))
            )
        ))
        (§ return (§ expr fjinvoke.invoke(top)))
    )

    #_public
    (§ method int count()
        (§ return (§ expr count))
    )

    #_public
    (§ method ISeq seq()
        (§ let ISeq s = (root != nil) ? root.nodeSeq() :or nil)
        (§ return (§ expr hasNull ? new Cons(MapEntry.create(nil, nullValue), s) :or s))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    #_static
    (§ method int mask(int hash, int shift)
        (§ return (§ expr (hash >>> shift) & 0x01f))
    )

    #_public
    (§ method PersistentHashMap withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentHashMap(meta, count, root, hasNull, nullValue)))
    )

    #_public
    (§ method TransientHashMap asTransient()
        (§ return (§ expr new TransientHashMap(this)))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    #_static
    #_final
    (class-ns TransientHashMap (§ extends ATransientMap)
        #_final
        (§ field AtomicReference<Thread> edit)
        #_volatile
        (§ field INode root)
        #_volatile
        (§ field int count)
        #_volatile
        (§ field boolean hasNull)
        #_volatile
        (§ field Object nullValue)
        #_final
        (§ field Box leafFlag = new Box(nil))

        (§ method TransientHashMap(PersistentHashMap m)
            (§ this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue))
        )

        (§ method TransientHashMap(AtomicReference<Thread> edit, INode root, int count, boolean hasNull, Object nullValue)
            (§ ass this.edit = edit)
            (§ ass this.root = root)
            (§ ass this.count = count)
            (§ ass this.hasNull = hasNull)
            (§ ass this.nullValue = nullValue)
        )

        (§ method ITransientMap doAssoc(Object key, Object val)
            (§ if (key == nil))
            (§
                (§ if (this.nullValue != val))
                (§
                    (§ ass this.nullValue = val)
                )
                (§ if (!hasNull))
                (§
                    (§ ass this.count++)
                    (§ ass this.hasNull = true)
                )
                (§ return (§ expr this))
            )
            (§ ass leafFlag.val = nil)
            (§ let INode n = ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag))
            (§ if (n != this.root))
            (§
                (§ ass this.root = n)
            )
            (§ if (leafFlag.val != nil))
            (§
                (§ ass this.count++)
            )
            (§ return (§ expr this))
        )

        (§ method ITransientMap doWithout(Object key)
            (§ if (key == nil))
            (§
                (§ if (!hasNull))
                (§
                    (§ return (§ expr this))
                )
                (§ ass hasNull = false)
                (§ ass nullValue = nil)
                (§ ass this.count--)
                (§ return (§ expr this))
            )
            (§ if (root == nil))
            (§
                (§ return (§ expr this))
            )
            (§ ass leafFlag.val = nil)
            (§ let INode n = root.without(edit, 0, hash(key), key, leafFlag))
            (§ if (n != root))
            (§
                (§ ass this.root = n)
            )
            (§ if (leafFlag.val != nil))
            (§
                (§ ass this.count--)
            )
            (§ return (§ expr this))
        )

        (§ method IPersistentMap doPersistent()
            (§ call edit.set(nil))
            (§ return (§ expr new PersistentHashMap(count, root, hasNull, nullValue)))
        )

        (§ method Object doValAt(Object key, Object notFound)
            (§ if (key == nil))
            (§
                (§ if (hasNull))
                (§
                    (§ return (§ expr nullValue))
                )
                (§ else )
                (§
                    (§ return (§ expr notFound))
                )
            )
            (§ if (root == nil))
            (§
                (§ return (§ expr notFound))
            )
            (§ return (§ expr root.find(0, hash(key), key, notFound)))
        )

        (§ method int doCount()
            (§ return (§ expr count))
        )

        (§ method void ensureEditable()
            (§ if (edit.get() == nil))
            (§
                (§ throw new IllegalAccessError("Transient used after persistent! call"))
            )
        )
    )

    #_static
    (§ interface INode
        (§ abstract INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(int shift, int hash, Object key))
        (§ abstract IMapEntry find(int shift, int hash, Object key))
        (§ abstract Object find(int shift, int hash, Object key, Object notFound))
        (§ abstract ISeq nodeSeq())
        (§ abstract INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf))
        (§ abstract Object kvreduce(IFn f, Object init))
        (§ abstract Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin))
        ;; returns the result of (f [k v]) for each iterated element
        (§ abstract Iterator iterator(IFn f))
    )

    #_final
    #_static
    (class-ns ArrayNode (§ implements INode)
        (§ field int count)
        #_final
        (§ field INode[] array)
        #_final
        (§ field AtomicReference<Thread> edit)

        (§ method ArrayNode(AtomicReference<Thread> edit, int count, INode[] array)
            (§ ass this.array = array)
            (§ ass this.edit = edit)
            (§ ass this.count = count)
        )

        #_public
        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (node == nil))
            (§
                (§ return (§ expr new ArrayNode(nil, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))))
            )
            (§ let INode n = node.assoc(shift + 5, hash, key, val, addedLeaf))
            (§ if (n == node))
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new ArrayNode(nil, count, cloneAndSet(array, idx, n))))
        )

        #_public
        (§ method INode without(int shift, int hash, Object key)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (node == nil))
            (§
                (§ return (§ expr this))
            )
            (§ let INode n = node.without(shift + 5, hash, key))
            (§ if (n == node))
            (§
                (§ return (§ expr this))
            )
            (§ if (n == nil))
            (§
                (§ if (count <= 8)) ;; shrink
                (§
                    (§ return (§ expr pack(nil, idx)))
                )
                (§ return (§ expr new ArrayNode(nil, count - 1, cloneAndSet(array, idx, n))))
            )
            (§ else )
            (§
                (§ return (§ expr new ArrayNode(nil, count, cloneAndSet(array, idx, n))))
            )
        )

        #_public
        (§ method IMapEntry find(int shift, int hash, Object key)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (node == nil))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr node.find(shift + 5, hash, key)))
        )

        #_public
        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (node == nil))
            (§
                (§ return (§ expr notFound))
            )
            (§ return (§ expr node.find(shift + 5, hash, key, notFound)))
        )

        #_public
        (§ method ISeq nodeSeq()
            (§ return (§ expr Seq.create(array)))
        )

        #_public
        (§ method Iterator iterator(IFn f)
            (§ return (§ expr new Iter(array, f)))
        )

        #_public
        (§ method Object kvreduce(IFn f, Object init)
            (§ for (INode node :in array))
            (§
                (§ if (node != nil))
                (§
                    (§ ass init = node.kvreduce(f, init))
                    (§ if (RT.isReduced(init)))
                    (§
                        (§ return (§ expr init))
                    )
                )
            )
            (§ return (§ expr init))
        )

        #_public
        (§ method Object fold(final IFn combinef, final IFn reducef, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
            (§ let List<Callable> tasks = new ArrayList())
            (§ for (final INode node :in array))
            (§
                (§ if (node != nil))
                (§
                    (§ call tasks.add(new Callable()
                    (§ inner
                        #_public
                        (§ method Object call() (§ throws Exception)
                            (§ return (§ expr node.fold(combinef, reducef, fjtask, fjfork, fjjoin)))
                        )
                    )))
                )
            )

            (§ return (§ expr foldTasks(tasks, combinef, fjtask, fjfork, fjjoin)))
        )

        #_static
        #_public
        (§ method Object foldTasks(List<Callable> tasks, final IFn combinef, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
            (§ if (tasks.isEmpty()))
            (§
                (§ return (§ expr combinef.invoke()))
            )

            (§ if (tasks.size() == 1))
            (§
                (§ let Object ret = nil)
                (§ try )
                (§
                    (§ return (§ expr tasks.get(0).call()))
                )
                (§ catch (Exception e))
                (§
                    (§ throw Util.sneakyThrow(e))
                )
            )

            (§ let List<Callable> t1 = tasks.subList(0, tasks.size() / 2))
            (§ let final List<Callable> t2 = tasks.subList(tasks.size() / 2, tasks.size()))

            (§ let Object forked = fjfork.invoke(fjtask.invoke(new Callable()
            (§ inner
                #_public
                (§ method Object call() (§ throws Exception)
                    (§ return (§ expr foldTasks(t2, combinef, fjtask, fjfork, fjjoin)))
                )
            ))))

            (§ return (§ expr combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked))))
        )

        #_private
        (§ method ArrayNode ensureEditable(AtomicReference<Thread> edit)
            (§ if (this.edit == edit))
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new ArrayNode(edit, count, this.array.clone())))
        )

        #_private
        (§ method ArrayNode editAndSet(AtomicReference<Thread> edit, int i, INode n)
            (§ let ArrayNode editable = ensureEditable(edit))
            (§ ass editable.array[i] = n)
            (§ return (§ expr editable))
        )

        #_private
        (§ method INode pack(AtomicReference<Thread> edit, int idx)
            (§ let Object[] newArray = new Object[2 * (count - 1)])
            (§ let int j = 1)
            (§ let int bitmap = 0)
            (§ for (int i = 0 i < idx i++))
            (§
                (§ if (array[i] != nil))
                (§
                    (§ ass newArray[j] = array[i])
                    (§ ass bitmap |= 1 << i)
                    (§ ass j += 2)
                )
            )
            (§ for (int i = idx + 1 i < array.length i++))
            (§
                (§ if (array[i] != nil))
                (§
                    (§ ass newArray[j] = array[i])
                    (§ ass bitmap |= 1 << i)
                    (§ ass j += 2)
                )
            )
            (§ return (§ expr new BitmapIndexedNode(edit, bitmap, newArray)))
        )

        #_public
        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (node == nil))
            (§
                (§ let ArrayNode editable = editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)))
                (§ ass editable.count++)
                (§ return (§ expr editable))
            )
            (§ let INode n = node.assoc(edit, shift + 5, hash, key, val, addedLeaf))
            (§ if (n == node))
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr editAndSet(edit, idx, n)))
        )

        #_public
        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (§ let int idx = mask(hash, shift))
            (§ let INode node = array[idx])
            (§ if (node == nil))
            (§
                (§ return (§ expr this))
            )
            (§ let INode n = node.without(edit, shift + 5, hash, key, removedLeaf))
            (§ if (n == node))
            (§
                (§ return (§ expr this))
            )
            (§ if (n == nil))
            (§
                (§ if (count <= 8)) ;; shrink
                (§
                    (§ return (§ expr pack(edit, idx)))
                )
                (§ let ArrayNode editable = editAndSet(edit, idx, n))
                (§ ass editable.count--)
                (§ return (§ expr editable))
            )
            (§ return (§ expr editAndSet(edit, idx, n)))
        )

        #_static
        (class-ns Seq (§ extends ASeq)
            #_final
            (§ field INode[] nodes)
            #_final
            (§ field int i)
            #_final
            (§ field ISeq s)

            #_static
            (§ method ISeq create(INode[] nodes)
                (§ return (§ expr create(nil, nodes, 0, nil)))
            )

            #_private
            #_static
            (§ method ISeq create(IPersistentMap meta, INode[] nodes, int i, ISeq s)
                (§ if (s != nil))
                (§
                    (§ return (§ expr new Seq(meta, nodes, i, s)))
                )
                (§ for (int j = i j < nodes.length j++))
                (§
                    (§ if (nodes[j] != nil))
                    (§
                        (§ let ISeq ns = nodes[j].nodeSeq())
                        (§ if (ns != nil))
                        (§
                            (§ return (§ expr new Seq(meta, nodes, j + 1, ns)))
                        )
                    )
                )
                (§ return (§ expr nil))
            )

            #_private
            (§ method Seq(IPersistentMap meta, INode[] nodes, int i, ISeq s)
                (§ super(meta))
                (§ ass this.nodes = nodes)
                (§ ass this.i = i)
                (§ ass this.s = s)
            )

            #_public
            (§ method Obj withMeta(IPersistentMap meta)
                (§ return (§ expr new Seq(meta, nodes, i, s)))
            )

            #_public
            (§ method Object first()
                (§ return (§ expr s.first()))
            )

            #_public
            (§ method ISeq next()
                (§ return (§ expr create(nil, nodes, i, s.next())))
            )
        )

        #_static
        (class-ns Iter (§ implements Iterator)
            #_private
            #_final
            (§ field INode[] array)
            #_private
            #_final
            (§ field IFn f)
            #_private
            (§ field int i = 0)
            #_private
            (§ field Iterator nestedIter)

            #_private
            (§ method Iter(INode[] array, IFn f)
                (§ ass this.array = array)
                (§ ass this.f = f)
            )

            #_public
            (§ method boolean hasNext()
                (§ while (true))
                (§
                    (§ if (nestedIter != nil))
                    (§
                        (§ if (nestedIter.hasNext()))
                        (§
                            (§ return (§ expr true))
                        )
                        (§ else )
                        (§
                            (§ ass nestedIter = nil)
                        )
                    )

                    (§ if (i < array.length))
                    (§
                        (§ let INode node = array[i++])
                        (§ if (node != nil))
                        (§
                            (§ ass nestedIter = node.iterator(f))
                        )
                    )
                    (§ else )
                    (§
                        (§ return (§ expr false))
                    )
                )
            )

            #_public
            (§ method Object next()
                (§ if (hasNext()))
                (§
                    (§ return (§ expr nestedIter.next()))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )
    )

    #_final
    #_static
    (class-ns BitmapIndexedNode (§ implements INode)
        #_static
        #_final
        (§ field BitmapIndexedNode EMPTY = new BitmapIndexedNode(nil, 0, new Object[0]))

        (§ field int bitmap)
        (§ field Object[] array)
        #_final
        (§ field AtomicReference<Thread> edit)

        #_final
        (§ method int index(int bit)
            (§ return (§ expr Integer.bitCount(bitmap & (bit - 1))))
        )

        (§ method BitmapIndexedNode(AtomicReference<Thread> edit, int bitmap, Object[] array)
            (§ ass this.bitmap = bitmap)
            (§ ass this.array = array)
            (§ ass this.edit = edit)
        )

        #_public
        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int bit = bitpos(hash, shift))
            (§ let int idx = index(bit))
            (§ if ((bitmap & bit) != 0))
            (§
                (§ let Object keyOrNull = array[2 * idx])
                (§ let Object valOrNode = array[2 * idx + 1])
                (§ if (keyOrNull == nil))
                (§
                    (§ let INode n = ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf))
                    (§ if (n == valOrNode))
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                )
                (§ if (Util.equiv(key, keyOrNull)))
                (§
                    (§ if (val == valOrNode))
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, val))))
                )
                (§ ass addedLeaf.val = addedLeaf)
                (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx, nil, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val)))))
            )
            (§ else )
            (§
                (§ let int n = Integer.bitCount(bitmap))
                (§ if (n >= 16))
                (§
                    (§ let INode[] nodes = new INode[32])
                    (§ let int jdx = mask(hash, shift))
                    (§ ass nodes[jdx] = EMPTY.assoc(shift + 5, hash, key, val, addedLeaf))
                    (§ let int j = 0)
                    (§ for (int i = 0 i < 32 i++))
                    (§
                        (§ if (((bitmap >>> i) & 1) != 0))
                        (§
                            (§ if (array[j] == nil))
                            (§
                                (§ ass nodes[i] = (INode) array[j + 1])
                            )
                            (§ else )
                            (§
                                (§ ass nodes[i] = EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                            )
                            (§ ass j += 2)
                        )
                    )
                    (§ return (§ expr new ArrayNode(nil, n + 1, nodes)))
                )
                (§ else )
                (§
                    (§ let Object[] newArray = new Object[2 * (n + 1)])
                    (§ call System.arraycopy(array, 0, newArray, 0, 2 * idx))
                    (§ ass newArray[2 * idx] = key)
                    (§ ass addedLeaf.val = addedLeaf)
                    (§ ass newArray[2 * idx + 1] = val)
                    (§ call System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap | bit, newArray)))
                )
            )
        )

        #_public
        (§ method INode without(int shift, int hash, Object key)
            (§ let int bit = bitpos(hash, shift))
            (§ if ((bitmap & bit) == 0))
            (§
                (§ return (§ expr this))
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (keyOrNull == nil))
            (§
                (§ let INode n = ((INode) valOrNode).without(shift + 5, hash, key))
                (§ if (n == valOrNode))
                (§
                    (§ return (§ expr this))
                )
                (§ if (n != nil))
                (§
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                )
                (§ if (bitmap == bit))
                (§
                    (§ return (§ expr nil))
                )
                (§ return (§ expr new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
            )
            (§ if (Util.equiv(key, keyOrNull)))
            (§
                ;; TODO: collapse
                (§ return (§ expr new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
            )
            (§ return (§ expr this))
        )

        #_public
        (§ method IMapEntry find(int shift, int hash, Object key)
            (§ let int bit = bitpos(hash, shift))
            (§ if ((bitmap & bit) == 0))
            (§
                (§ return (§ expr nil))
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (keyOrNull == nil))
            (§
                (§ return (§ expr ((INode) valOrNode).find(shift + 5, hash, key)))
            )
            (§ if (Util.equiv(key, keyOrNull)))
            (§
                (§ return (§ expr (IMapEntry) MapEntry.create(keyOrNull, valOrNode)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (§ let int bit = bitpos(hash, shift))
            (§ if ((bitmap & bit) == 0))
            (§
                (§ return (§ expr notFound))
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (keyOrNull == nil))
            (§
                (§ return (§ expr ((INode) valOrNode).find(shift + 5, hash, key, notFound)))
            )
            (§ if (Util.equiv(key, keyOrNull)))
            (§
                (§ return (§ expr valOrNode))
            )
            (§ return (§ expr notFound))
        )

        #_public
        (§ method ISeq nodeSeq()
            (§ return (§ expr NodeSeq.create(array)))
        )

        #_public
        (§ method Iterator iterator(IFn f)
            (§ return (§ expr new NodeIter(array, f)))
        )

        #_public
        (§ method Object kvreduce(IFn f, Object init)
            (§ return (§ expr NodeSeq.kvreduce(array, f, init)))
        )

        #_public
        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (§ return (§ expr NodeSeq.kvreduce(array, reducef, combinef.invoke())))
        )

        #_private
        (§ method BitmapIndexedNode ensureEditable(AtomicReference<Thread> edit)
            (§ if (this.edit == edit))
            (§
                (§ return (§ expr this))
            )
            (§ let int n = Integer.bitCount(bitmap))
            (§ let Object[] newArray = new Object[(n >= 0) ? 2 * (n + 1) :or 4]) ;; make room for next assoc
            (§ call System.arraycopy(array, 0, newArray, 0, 2 * n))
            (§ return (§ expr new BitmapIndexedNode(edit, bitmap, newArray)))
        )

        #_private
        (§ method BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
            (§ let BitmapIndexedNode editable = ensureEditable(edit))
            (§ ass editable.array[i] = a)
            (§ return (§ expr editable))
        )

        #_private
        (§ method BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
            (§ let BitmapIndexedNode editable = ensureEditable(edit))
            (§ ass editable.array[i] = a)
            (§ ass editable.array[j] = b)
            (§ return (§ expr editable))
        )

        #_private
        (§ method BitmapIndexedNode editAndRemovePair(AtomicReference<Thread> edit, int bit, int i)
            (§ if (bitmap == bit))
            (§
                (§ return (§ expr nil))
            )
            (§ let BitmapIndexedNode editable = ensureEditable(edit))
            (§ ass editable.bitmap ^= bit)
            (§ call System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1)))
            (§ ass editable.array[editable.array.length - 2] = nil)
            (§ ass editable.array[editable.array.length - 1] = nil)
            (§ return (§ expr editable))
        )

        #_public
        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ let int bit = bitpos(hash, shift))
            (§ let int idx = index(bit))
            (§ if ((bitmap & bit) != 0))
            (§
                (§ let Object keyOrNull = array[2 * idx])
                (§ let Object valOrNode = array[2 * idx + 1])
                (§ if (keyOrNull == nil))
                (§
                    (§ let INode n = ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf))
                    (§ if (n == valOrNode))
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr editAndSet(edit, 2 * idx + 1, n)))
                )
                (§ if (Util.equiv(key, keyOrNull)))
                (§
                    (§ if (val == valOrNode))
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr editAndSet(edit, 2 * idx + 1, val)))
                )
                (§ ass addedLeaf.val = addedLeaf)
                (§ return (§ expr editAndSet(edit, 2 * idx, nil, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val))))
            )
            (§ else )
            (§
                (§ let int n = Integer.bitCount(bitmap))
                (§ if (n * 2 < array.length))
                (§
                    (§ ass addedLeaf.val = addedLeaf)
                    (§ let BitmapIndexedNode editable = ensureEditable(edit))
                    (§ call System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx)))
                    (§ ass editable.array[2 * idx] = key)
                    (§ ass editable.array[2 * idx + 1] = val)
                    (§ ass editable.bitmap |= bit)
                    (§ return (§ expr editable))
                )
                (§ if (n >= 16))
                (§
                    (§ let INode[] nodes = new INode[32])
                    (§ let int jdx = mask(hash, shift))
                    (§ ass nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf))
                    (§ let int j = 0)
                    (§ for (int i = 0 i < 32 i++))
                    (§
                        (§ if (((bitmap >>> i) & 1) != 0))
                        (§
                            (§ if (array[j] == nil))
                            (§
                                (§ ass nodes[i] = (INode) array[j + 1])
                            )
                            (§ else )
                            (§
                                (§ ass nodes[i] = EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                            )
                            (§ ass j += 2)
                        )
                    )
                    (§ return (§ expr new ArrayNode(edit, n + 1, nodes)))
                )
                (§ else )
                (§
                    (§ let Object[] newArray = new Object[2 * (n + 4)])
                    (§ call System.arraycopy(array, 0, newArray, 0, 2 * idx))
                    (§ ass newArray[2 * idx] = key)
                    (§ ass addedLeaf.val = addedLeaf)
                    (§ ass newArray[2 * idx + 1] = val)
                    (§ call System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                    (§ let BitmapIndexedNode editable = ensureEditable(edit))
                    (§ ass editable.array = newArray)
                    (§ ass editable.bitmap |= bit)
                    (§ return (§ expr editable))
                )
            )
        )

        #_public
        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (§ let int bit = bitpos(hash, shift))
            (§ if ((bitmap & bit) == 0))
            (§
                (§ return (§ expr this))
            )
            (§ let int idx = index(bit))
            (§ let Object keyOrNull = array[2 * idx])
            (§ let Object valOrNode = array[2 * idx + 1])
            (§ if (keyOrNull == nil))
            (§
                (§ let INode n = ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf))
                (§ if (n == valOrNode))
                (§
                    (§ return (§ expr this))
                )
                (§ if (n != nil))
                (§
                    (§ return (§ expr editAndSet(edit, 2 * idx + 1, n)))
                )
                (§ if (bitmap == bit))
                (§
                    (§ return (§ expr nil))
                )
                (§ return (§ expr editAndRemovePair(edit, bit, idx)))
            )
            (§ if (Util.equiv(key, keyOrNull)))
            (§
                (§ ass removedLeaf.val = removedLeaf)
                ;; TODO: collapse
                (§ return (§ expr editAndRemovePair(edit, bit, idx)))
            )
            (§ return (§ expr this))
        )
    )

    #_final
    #_static
    (class-ns HashCollisionNode (§ implements INode)
        #_final
        (§ field int hash)
        (§ field int count)
        (§ field Object[] array)
        #_final
        (§ field AtomicReference<Thread> edit)

        (§ method HashCollisionNode(AtomicReference<Thread> edit, int hash, int count, Object... array)
            (§ ass this.edit = edit)
            (§ ass this.hash = hash)
            (§ ass this.count = count)
            (§ ass this.array = array)
        )

        #_public
        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ if (hash == this.hash))
            (§
                (§ let int idx = findIndex(key))
                (§ if (idx != -1))
                (§
                    (§ if (array[idx + 1] == val))
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr new HashCollisionNode(nil, hash, count, cloneAndSet(array, idx + 1, val))))
                )
                (§ let Object[] newArray = new Object[2 * (count + 1)])
                (§ call System.arraycopy(array, 0, newArray, 0, 2 * count))
                (§ ass newArray[2 * count] = key)
                (§ ass newArray[2 * count + 1] = val)
                (§ ass addedLeaf.val = addedLeaf)
                (§ return (§ expr new HashCollisionNode(edit, hash, count + 1, newArray)))
            )
            ;; nest it in a bitmap node
            (§ return (§ expr new BitmapIndexedNode(nil, bitpos(this.hash, shift), new Object[] (§ nil, this )).assoc(shift, hash, key, val, addedLeaf)))
        )

        #_public
        (§ method INode without(int shift, int hash, Object key)
            (§ let int idx = findIndex(key))
            (§ if (idx == -1))
            (§
                (§ return (§ expr this))
            )
            (§ if (count == 1))
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new HashCollisionNode(nil, hash, count - 1, removePair(array, idx / 2))))
        )

        #_public
        (§ method IMapEntry find(int shift, int hash, Object key)
            (§ let int idx = findIndex(key))
            (§ if (idx < 0))
            (§
                (§ return (§ expr nil))
            )
            (§ if (Util.equiv(key, array[idx])))
            (§
                (§ return (§ expr (IMapEntry) MapEntry.create(array[idx], array[idx + 1])))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (§ let int idx = findIndex(key))
            (§ if (idx < 0))
            (§
                (§ return (§ expr notFound))
            )
            (§ if (Util.equiv(key, array[idx])))
            (§
                (§ return (§ expr array[idx + 1]))
            )
            (§ return (§ expr notFound))
        )

        #_public
        (§ method ISeq nodeSeq()
            (§ return (§ expr NodeSeq.create(array)))
        )

        #_public
        (§ method Iterator iterator(IFn f)
            (§ return (§ expr new NodeIter(array, f)))
        )

        #_public
        (§ method Object kvreduce(IFn f, Object init)
            (§ return (§ expr NodeSeq.kvreduce(array, f, init)))
        )

        #_public
        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (§ return (§ expr NodeSeq.kvreduce(array, reducef, combinef.invoke())))
        )

        #_public
        (§ method int findIndex(Object key)
            (§ for (int i = 0 i < 2 * count i += 2))
            (§
                (§ if (Util.equiv(key, array[i])))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )

        #_private
        (§ method HashCollisionNode ensureEditable(AtomicReference<Thread> edit)
            (§ if (this.edit == edit))
            (§
                (§ return (§ expr this))
            )
            (§ let Object[] newArray = new Object[2 * (count + 1)]) ;; make room for next assoc
            (§ call System.arraycopy(array, 0, newArray, 0, 2 * count))
            (§ return (§ expr new HashCollisionNode(edit, hash, count, newArray)))
        )

        #_private
        (§ method HashCollisionNode ensureEditable(AtomicReference<Thread> edit, int count, Object[] array)
            (§ if (this.edit == edit))
            (§
                (§ ass this.array = array)
                (§ ass this.count = count)
                (§ return (§ expr this))
            )
            (§ return (§ expr new HashCollisionNode(edit, hash, count, array)))
        )

        #_private
        (§ method HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
            (§ let HashCollisionNode editable = ensureEditable(edit))
            (§ ass editable.array[i] = a)
            (§ return (§ expr editable))
        )

        #_private
        (§ method HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
            (§ let HashCollisionNode editable = ensureEditable(edit))
            (§ ass editable.array[i] = a)
            (§ ass editable.array[j] = b)
            (§ return (§ expr editable))
        )

        #_public
        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (§ if (hash == this.hash))
            (§
                (§ let int idx = findIndex(key))
                (§ if (idx != -1))
                (§
                    (§ if (array[idx + 1] == val))
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr editAndSet(edit, idx + 1, val)))
                )
                (§ if (array.length > 2 * count))
                (§
                    (§ ass addedLeaf.val = addedLeaf)
                    (§ let HashCollisionNode editable = editAndSet(edit, 2 * count, key, 2 * count + 1, val))
                    (§ ass editable.count++)
                    (§ return (§ expr editable))
                )
                (§ let Object[] newArray = new Object[array.length + 2])
                (§ call System.arraycopy(array, 0, newArray, 0, array.length))
                (§ ass newArray[array.length] = key)
                (§ ass newArray[array.length + 1] = val)
                (§ ass addedLeaf.val = addedLeaf)
                (§ return (§ expr ensureEditable(edit, count + 1, newArray)))
            )
            ;; nest it in a bitmap node
            (§ return (§ expr new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ nil, this, nil, nil )).assoc(edit, shift, hash, key, val, addedLeaf)))
        )

        #_public
        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (§ let int idx = findIndex(key))
            (§ if (idx == -1))
            (§
                (§ return (§ expr this))
            )
            (§ ass removedLeaf.val = removedLeaf)
            (§ if (count == 1))
            (§
                (§ return (§ expr nil))
            )
            (§ let HashCollisionNode editable = ensureEditable(edit))
            (§ ass editable.array[idx] = editable.array[2 * count - 2])
            (§ ass editable.array[idx + 1] = editable.array[2 * count - 1])
            (§ ass editable.array[2 * count - 2] = editable.array[2 * count - 1] = nil)
            (§ ass editable.count--)
            (§ return (§ expr editable))
        )
    )

    #_private
    #_static
    (§ method INode[] cloneAndSet(INode[] array, int i, INode a)
        (§ let INode[] clone = array.clone())
        (§ ass clone[i] = a)
        (§ return (§ expr clone))
    )

    #_private
    #_static
    (§ method Object[] cloneAndSet(Object[] array, int i, Object a)
        (§ let Object[] clone = array.clone())
        (§ ass clone[i] = a)
        (§ return (§ expr clone))
    )

    #_private
    #_static
    (§ method Object[] cloneAndSet(Object[] array, int i, Object a, int j, Object b)
        (§ let Object[] clone = array.clone())
        (§ ass clone[i] = a)
        (§ ass clone[j] = b)
        (§ return (§ expr clone))
    )

    #_private
    #_static
    (§ method Object[] removePair(Object[] array, int i)
        (§ let Object[] newArray = new Object[array.length - 2])
        (§ call System.arraycopy(array, 0, newArray, 0, 2 * i))
        (§ call System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i))
        (§ return (§ expr newArray))
    )

    #_private
    #_static
    (§ method INode createNode(int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
        (§ let int key1hash = hash(key1))
        (§ if (key1hash == key2hash))
        (§
            (§ return (§ expr new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
        )
        (§ let Box addedLeaf = new Box(nil))
        (§ let AtomicReference<Thread> edit = new AtomicReference<Thread>())
        (§ return (§ expr BitmapIndexedNode.EMPTY
      #_arg .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
      #_arg .assoc(edit, shift, key2hash, key2, val2, addedLeaf)))
    )

    #_private
    #_static
    (§ method INode createNode(AtomicReference<Thread> edit, int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
        (§ let int key1hash = hash(key1))
        (§ if (key1hash == key2hash))
        (§
            (§ return (§ expr new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
        )
        (§ let Box addedLeaf = new Box(nil))
        (§ return (§ expr BitmapIndexedNode.EMPTY
      #_arg .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
      #_arg .assoc(edit, shift, key2hash, key2, val2, addedLeaf)))
    )

    #_private
    #_static
    (§ method int bitpos(int hash, int shift)
        (§ return (§ expr 1 << mask(hash, shift)))
    )

    #_static
    #_final
    (class-ns NodeIter (§ implements Iterator)
        #_private
        #_static
        #_final
        (§ field Object NULL = new Object())
        #_final
        (§ field Object[] array)
        #_final
        (§ field IFn f)
        #_private
        (§ field int i = 0)
        #_private
        (§ field Object nextEntry = NULL)
        #_private
        (§ field Iterator nextIter)

        (§ method NodeIter(Object[] array, IFn f)
            (§ ass this.array = array)
            (§ ass this.f = f)
        )

        #_private
        (§ method boolean advance()
            (§ while (i<array.length))
            (§
                (§ let Object key = array[i])
                (§ let Object nodeOrVal = array[i + 1])
                (§ ass i += 2)
                (§ if (key != nil))
                (§
                    (§ ass nextEntry = f.invoke(key, nodeOrVal))
                    (§ return (§ expr true))
                )
                (§ elseif (nodeOrVal != nil))
                (§
                    (§ let Iterator iter = ((INode) nodeOrVal).iterator(f))
                    (§ if (iter != nil && iter.hasNext()))
                    (§
                        (§ ass nextIter = iter)
                        (§ return (§ expr true))
                    )
                )
            )
            (§ return (§ expr false))
        )

        #_public
        (§ method boolean hasNext()
            (§ if (nextEntry != NULL || nextIter != nil))
            (§
                (§ return (§ expr true))
            )
            (§ return (§ expr advance()))
        )

        #_public
        (§ method Object next()
            (§ let Object ret = nextEntry)
            (§ if (ret != NULL))
            (§
                (§ ass nextEntry = NULL)
                (§ return (§ expr ret))
            )
            (§ elseif (nextIter != nil))
            (§
                (§ ass ret = nextIter.next())
                (§ if (!nextIter.hasNext()))
                (§
                    (§ ass nextIter = nil)
                )
                (§ return (§ expr ret))
            )
            (§ elseif (advance()))
            (§
                (§ return (§ expr next()))
            )
            (§ throw new NoSuchElementException())
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    #_static
    #_final
    (class-ns NodeSeq (§ extends ASeq)
        #_final
        (§ field Object[] array)
        #_final
        (§ field int i)
        #_final
        (§ field ISeq s)

        (§ method NodeSeq(Object[] array, int i)
            (§ this(nil, array, i, nil))
        )

        #_static
        (§ method ISeq create(Object[] array)
            (§ return (§ expr create(array, 0, nil)))
        )

        #_static
        #_public
        (§ method Object kvreduce(Object[] array, IFn f, Object init)
            (§ for (int i = 0 i < array.length i += 2))
            (§
                (§ if (array[i] != nil))
                (§
                    (§ ass init = f.invoke(init, array[i], array[i + 1]))
                )
                (§ else )
                (§
                    (§ let INode node = (INode) array[i + 1])
                    (§ if (node != nil))
                    (§
                        (§ ass init = node.kvreduce(f, init))
                    )
                )
                (§ if (RT.isReduced(init)))
                (§
                    (§ return (§ expr init))
                )
            )
            (§ return (§ expr init))
        )

        #_private
        #_static
        (§ method ISeq create(Object[] array, int i, ISeq s)
            (§ if (s != nil))
            (§
                (§ return (§ expr new NodeSeq(nil, array, i, s)))
            )
            (§ for (int j = i j < array.length j+=2))
            (§
                (§ if (array[j] != nil))
                (§
                    (§ return (§ expr new NodeSeq(nil, array, j, nil)))
                )
                (§ let INode node = (INode) array[j + 1])
                (§ if (node != nil))
                (§
                    (§ let ISeq nodeSeq = node.nodeSeq())
                    (§ if (nodeSeq != nil))
                    (§
                        (§ return (§ expr new NodeSeq(nil, array, j + 2, nodeSeq)))
                    )
                )
            )
            (§ return (§ expr nil))
        )

        (§ method NodeSeq(IPersistentMap meta, Object[] array, int i, ISeq s)
            (§ super(meta))
            (§ ass this.array = array)
            (§ ass this.i = i)
            (§ ass this.s = s)
        )

        #_public
        (§ method Obj withMeta(IPersistentMap meta)
            (§ return (§ expr new NodeSeq(meta, array, i, s)))
        )

        #_public
        (§ method Object first()
            (§ if (s != nil))
            (§
                (§ return (§ expr s.first()))
            )
            (§ return (§ expr MapEntry.create(array[i], array[i + 1])))
        )

        #_public
        (§ method ISeq next()
            (§ if (s != nil))
            (§
                (§ return (§ expr create(array, i, s.next())))
            )
            (§ return (§ expr create(array, i + 2, nil)))
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_public
(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    #_static
    #_public
    #_final
    (§ field PersistentHashSet EMPTY = new PersistentHashSet(nil, PersistentHashMap.EMPTY))

    #_final
    (§ field IPersistentMap _meta)

    #_public
    #_static
    (§ method PersistentHashSet create(Object... init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ for (int i = 0 i < init.length i++))
        (§
            (§ ass ret = (ITransientSet)ret.conj(init[i]))
        )
        (§ return (§ expr (PersistentHashSet)ret.persistent()))
    )

    #_public
    #_static
    (§ method PersistentHashSet create(List init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ for (Object key :in init))
        (§
            (§ ass ret = (ITransientSet) ret.conj(key))
        )
        (§ return (§ expr (PersistentHashSet)ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentHashSet create(ISeq items)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ for (  items != nil items = items.next()))
        (§
            (§ ass ret = (ITransientSet) ret.conj(items.first()))
        )
        (§ return (§ expr (PersistentHashSet)ret.persistent()))
    )

    #_public
    #_static
    (§ method PersistentHashSet createWithCheck(Object... init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ for (int i = 0 i < init.length i++))
        (§
            (§ ass ret = (ITransientSet) ret.conj(init[i]))
            (§ if (ret.count() != i + 1))
            (§
                (§ throw new IllegalArgumentException("Duplicate key: " + init[i]))
            )
        )
        (§ return (§ expr (PersistentHashSet) ret.persistent()))
    )

    #_public
    #_static
    (§ method PersistentHashSet createWithCheck(List init)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ let int i = 0)
        (§ for (Object key :in init))
        (§
            (§ ass ret = (ITransientSet) ret.conj(key))
            (§ if (ret.count() != i + 1))
            (§
                (§ throw new IllegalArgumentException("Duplicate key: " + key))
            )
            (§ ass ++i)
        )
        (§ return (§ expr (PersistentHashSet) ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentHashSet createWithCheck(ISeq items)
        (§ let ITransientSet ret = (ITransientSet)EMPTY.asTransient())
        (§ for (int i = 0 items != nil items = items.next(), ++i))
        (§
            (§ ass ret = (ITransientSet) ret.conj(items.first()))
            (§ if (ret.count() != i + 1))
            (§
                (§ throw new IllegalArgumentException("Duplicate key: " + items.first()))
            )
        )
        (§ return (§ expr (PersistentHashSet) ret.persistent()))
    )

    (§ method PersistentHashSet(IPersistentMap meta, IPersistentMap impl)
        (§ super(impl))
        (§ ass this._meta = meta)
    )

    #_public
    (§ method IPersistentSet disjoin(Object key)
        (§ if (contains(key)))
        (§
            (§ return (§ expr new PersistentHashSet(meta(), impl.without(key))))
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method IPersistentSet cons(Object o)
        (§ if (contains(o)))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentHashSet(meta(), impl.assoc(o, o))))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    #_public
    (§ method PersistentHashSet withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentHashSet(meta, impl)))
    )

    #_public
    (§ method ITransientCollection asTransient()
        (§ return (§ expr new TransientHashSet(((PersistentHashMap) impl).asTransient())))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    #_static
    #_final
    (class-ns TransientHashSet (§ extends ATransientSet)
        (§ method TransientHashSet(ITransientMap impl)
            (§ super(impl))
        )

        #_public
        (§ method IPersistentCollection persistent()
            (§ return (§ expr new PersistentHashSet(nil, impl.persistent())))
        )
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

#_public
(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    #_private
    #_final
    (§ field Object _first)
    #_private
    #_final
    (§ field IPersistentList _rest)
    #_private
    #_final
    (§ field int _count)

    #_static
    #_public
    (class-ns Primordial (§ extends RestFn)
        #_final
        #_public
        (§ method int getRequiredArity()
            (§ return (§ expr 0))
        )

        #_final
        #_protected
        (§ method Object doInvoke(Object args)
            (§ if (args instanceof ArraySeq))
            (§
                (§ let Object[] argsarray = ((ArraySeq) args).array)
                (§ let IPersistentList ret = EMPTY)
                (§ for (int i = argsarray.length - 1 i >= ((ArraySeq)args).i --i))
                (§
                    (§ ass ret = (IPersistentList) ret.cons(argsarray[i]))
                )
                (§ return (§ expr ret))
            )
            (§ let LinkedList list = new LinkedList())
            (§ for (ISeq s = RT.seq(args) s != nil s = s.next()))
            (§
                (§ call list.add(s.first()))
            )
            (§ return (§ expr create(list)))
        )

        #_static
        #_public
        (§ method Object invokeStatic(ISeq args)
            (§ if (args instanceof ArraySeq))
            (§
                (§ let Object[] argsarray = ((ArraySeq) args).array)
                (§ let IPersistentList ret = EMPTY)
                (§ for (int i = argsarray.length - 1 i >= 0 --i))
                (§
                    (§ ass ret = (IPersistentList) ret.cons(argsarray[i]))
                )
                (§ return (§ expr ret))
            )
            (§ let LinkedList list = new LinkedList())
            (§ for (ISeq s = RT.seq(args) s != nil s = s.next()))
            (§
                (§ call list.add(s.first()))
            )
            (§ return (§ expr create(list)))
        )

        #_public
        (§ method IObj withMeta(IPersistentMap meta)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method IPersistentMap meta()
            (§ return (§ expr nil))
        )
    )

    #_public
    #_static
    (§ field IFn creator = new Primordial())

    #_final
    #_public
    #_static
    (§ field EmptyList EMPTY = new EmptyList(nil))

    #_public
    (§ method PersistentList(Object first)
        (§ ass this._first = first)
        (§ ass this._rest = nil)

        (§ ass this._count = 1)
    )

    (§ method PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count)
        (§ super(meta))
        (§ ass this._first = _first)
        (§ ass this._rest = _rest)
        (§ ass this._count = _count)
    )

    #_public
    #_static
    (§ method IPersistentList create(List init)
        (§ let IPersistentList ret = EMPTY)
        (§ for (ListIterator i = init.listIterator(init.size()) i.hasPrevious() ))
        (§
            (§ ass ret = (IPersistentList) ret.cons(i.previous()))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr _first))
    )

    #_public
    (§ method ISeq next()
        (§ if (_count == 1))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr (ISeq) _rest))
    )

    #_public
    (§ method Object peek()
        (§ return (§ expr first()))
    )

    #_public
    (§ method IPersistentList pop()
        (§ if (_rest == nil))
        (§
            (§ return (§ expr EMPTY.withMeta(_meta)))
        )
        (§ return (§ expr _rest))
    )

    #_public
    (§ method int count()
        (§ return (§ expr _count))
    )

    #_public
    (§ method PersistentList cons(Object o)
        (§ return (§ expr new PersistentList(meta(), o, this, _count + 1)))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    #_public
    (§ method PersistentList withMeta(IPersistentMap meta)
        (§ if (meta != _meta))
        (§
            (§ return (§ expr new PersistentList(meta, _first, _rest, _count)))
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ let Object ret = first())
        (§ for (ISeq s = next() s != nil s = s.next()))
        (§
            (§ ass ret = f.invoke(ret, s.first()))
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = f.invoke(start, first()))
        (§ for (ISeq s = next() s != nil s = s.next()))
        (§
            (§ if (RT.isReduced(ret)))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ ass ret = f.invoke(ret, s.first()))
        )
        (§ if (RT.isReduced(ret)))
        (§
            (§ return (§ expr ((IDeref)ret).deref()))
        )
        (§ return (§ expr ret))
    )

    #_static
    (class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
        #_static
        #_final
        (§ field int hasheq = Murmur3.hashOrdered(Collections.EMPTY_LIST))

        #_public
        (§ method int hashCode()
            (§ return (§ expr 1))
        )

        #_public
        (§ method int hasheq()
            (§ return (§ expr hasheq))
        )

        #_public
        (§ method String toString()
            (§ return (§ expr "()"))
        )

        #_public
        (§ method boolean equals(Object o)
            (§ return (§ expr ((o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)))
        )

        #_public
        (§ method boolean equiv(Object o)
            (§ return (§ expr equals(o)))
        )

        (§ method EmptyList(IPersistentMap meta)
            (§ super(meta))
        )

        #_public
        (§ method Object first()
            (§ return (§ expr nil))
        )

        #_public
        (§ method ISeq next()
            (§ return (§ expr nil))
        )

        #_public
        (§ method ISeq more()
            (§ return (§ expr this))
        )

        #_public
        (§ method PersistentList cons(Object o)
            (§ return (§ expr new PersistentList(meta(), o, nil, 1)))
        )

        #_public
        (§ method IPersistentCollection empty()
            (§ return (§ expr this))
        )

        #_public
        (§ method EmptyList withMeta(IPersistentMap meta)
            (§ if (meta != meta()))
            (§
                (§ return (§ expr new EmptyList(meta)))
            )
            (§ return (§ expr this))
        )

        #_public
        (§ method Object peek()
            (§ return (§ expr nil))
        )

        #_public
        (§ method IPersistentList pop()
            (§ throw new IllegalStateException("Can't pop empty list"))
        )

        #_public
        (§ method int count()
            (§ return (§ expr 0))
        )

        #_public
        (§ method ISeq seq()
            (§ return (§ expr nil))
        )

        #_public
        (§ method int size()
            (§ return (§ expr 0))
        )

        #_public
        (§ method boolean isEmpty()
            (§ return (§ expr true))
        )

        #_public
        (§ method boolean contains(Object o)
            (§ return (§ expr false))
        )

        #_public
        (§ method Iterator iterator()
            (§ return (§ expr new Iterator()
            (§ inner
                #_public
                (§ method boolean hasNext()
                    (§ return (§ expr false))
                )

                #_public
                (§ method Object next()
                    (§ throw new NoSuchElementException())
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )

        #_public
        (§ method Object[] toArray()
            (§ return (§ expr RT.EMPTY_ARRAY))
        )

        #_public
        (§ method boolean add(Object o)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method boolean remove(Object o)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method boolean addAll(Collection collection)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method void clear()
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method boolean retainAll(Collection collection)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method boolean removeAll(Collection collection)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method boolean containsAll(Collection collection)
            (§ return (§ expr collection.isEmpty()))
        )

        #_public
        (§ method Object[] toArray(Object[] objects)
            (§ if (objects.length > 0))
            (§
                (§ ass objects[0] = nil)
            )
            (§ return (§ expr objects))
        )

        #_private
        (§ method List reify()
            (§ return (§ expr Collections.unmodifiableList(new ArrayList(this))))
        )

        #_public
        (§ method List subList(int fromIndex, int toIndex)
            (§ return (§ expr reify().subList(fromIndex, toIndex)))
        )

        #_public
        (§ method Object set(int index, Object element)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method Object remove(int index)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method int indexOf(Object o)
            (§ let ISeq s = seq())
            (§ for (int i = 0 s != nil s = s.next(), i++))
            (§
                (§ if (Util.equiv(s.first(), o)))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )

        #_public
        (§ method int lastIndexOf(Object o)
            (§ return (§ expr reify().lastIndexOf(o)))
        )

        #_public
        (§ method ListIterator listIterator()
            (§ return (§ expr reify().listIterator()))
        )

        #_public
        (§ method ListIterator listIterator(int index)
            (§ return (§ expr reify().listIterator(index)))
        )

        #_public
        (§ method Object get(int index)
            (§ return (§ expr RT.nth(this, index)))
        )

        #_public
        (§ method void add(int index, Object element)
            (§ throw new UnsupportedOperationException())
        )

        #_public
        (§ method boolean addAll(int index, Collection c)
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
#_public
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    #_final
    #_public
    #_static
    (§ field PersistentQueue EMPTY = new PersistentQueue(nil, 0, nil, nil))

    #_final
    (§ field int cnt)
    #_final
    (§ field ISeq f)
    #_final
    (§ field PersistentVector r)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ method PersistentQueue(IPersistentMap meta, int cnt, ISeq f, PersistentVector r)
        (§ super(meta))
        (§ ass this.cnt = cnt)
        (§ ass this.f = f)
        (§ ass this.r = r)
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ if (!(obj instanceof Sequential)))
        (§
            (§ return (§ expr false))
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ for (ISeq s = seq() s != nil s = s.next(), ms = ms.next()))
        (§
            (§ if (ms == nil || !Util.equiv(s.first(), ms.first())))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ if (!(obj instanceof Sequential)))
        (§
            (§ return (§ expr false))
        )
        (§ let ISeq ms = RT.seq(obj))
        (§ for (ISeq s = seq() s != nil s = s.next(), ms = ms.next()))
        (§
            (§ if (ms == nil || !Util.equals(s.first(), ms.first())))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    #_public
    (§ method int hashCode()
        (§ let int hash = this._hash)
        (§ if (hash == 0))
        (§
            (§ ass hash = 1)
            (§ for (ISeq s = seq() s != nil s = s.next()))
            (§
                (§ ass hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
            )
            (§ ass this._hash = hash)
        )
        (§ return (§ expr hash))
    )

    #_public
    (§ method int hasheq()
        (§ let int cached = this._hasheq)
        (§ if (cached == 0))
        (§
            (§ ass this._hasheq = cached = Murmur3.hashOrdered(this))
        )
        (§ return (§ expr cached))
    )

    #_public
    (§ method Object peek()
        (§ return (§ expr RT.first(f)))
    )

    #_public
    (§ method PersistentQueue pop()
        (§ if (f == nil)) ;; hmmm... pop of empty queue -> empty queue?
        (§
            (§ return (§ expr this))
        )
        (§ let ISeq f1 = f.next())
        (§ let PersistentVector r1 = r)
        (§ if (f1 == nil))
        (§
            (§ ass f1 = RT.seq(r))
            (§ ass r1 = nil)
        )
        (§ return (§ expr new PersistentQueue(meta(), cnt - 1, f1, r1)))
    )

    #_public
    (§ method int count()
        (§ return (§ expr cnt))
    )

    #_public
    (§ method ISeq seq()
        (§ if (f == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new Seq(f, RT.seq(r))))
    )

    #_public
    (§ method PersistentQueue cons(Object o)
        (§ if (f == nil)) ;; empty
        (§
            (§ return (§ expr new PersistentQueue(meta(), cnt + 1, RT.list(o), nil)))
        )
        (§ else )
        (§
            (§ return (§ expr new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector.EMPTY).cons(o))))
        )
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    #_public
    (§ method PersistentQueue withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentQueue(meta, cnt, f, r)))
    )

    #_static
    (class-ns Seq (§ extends ASeq)
        #_final
        (§ field ISeq f)
        #_final
        (§ field ISeq rseq)

        (§ method Seq(ISeq f, ISeq rseq)
            (§ ass this.f = f)
            (§ ass this.rseq = rseq)
        )

        (§ method Seq(IPersistentMap meta, ISeq f, ISeq rseq)
            (§ super(meta))
            (§ ass this.f = f)
            (§ ass this.rseq = rseq)
        )

        #_public
        (§ method Object first()
            (§ return (§ expr f.first()))
        )

        #_public
        (§ method ISeq next()
            (§ let ISeq f1 = f.next())
            (§ let ISeq r1 = rseq)
            (§ if (f1 == nil))
            (§
                (§ if (rseq == nil))
                (§
                    (§ return (§ expr nil))
                )
                (§ ass f1 = rseq)
                (§ ass r1 = nil)
            )
            (§ return (§ expr new Seq(f1, r1)))
        )

        #_public
        (§ method int count()
            (§ return (§ expr RT.count(f) + RT.count(rseq)))
        )

        #_public
        (§ method Seq withMeta(IPersistentMap meta)
            (§ return (§ expr new Seq(meta, f, rseq)))
        )
    )

    #_public
    (§ method Object[] toArray()
        (§ return (§ expr RT.seqToArray(seq())))
    )

    #_public
    (§ method boolean add(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean remove(Object o)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean addAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method void clear()
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean retainAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean removeAll(Collection c)
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method boolean containsAll(Collection c)
        (§ for (Object o :in c))
        (§
            (§ if (contains(o)))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method Object[] toArray(Object[] a)
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    #_public
    (§ method int size()
        (§ return (§ expr count()))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (count() == 0)))
    )

    #_public
    (§ method boolean contains(Object o)
        (§ for (ISeq s = seq() s != nil s = s.next()))
        (§
            (§ if (Util.equiv(s.first(), o)))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr new Iterator()
        (§ inner
            #_private
            (§ field ISeq fseq = f)
            #_private
            #_final
            (§ field Iterator riter = (r != nil) ? r.iterator() :or nil)

            #_public
            (§ method boolean hasNext()
                (§ return (§ expr ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext()))))
            )

            #_public
            (§ method Object next()
                (§ if (fseq != nil))
                (§
                    (§ let Object ret = fseq.first())
                    (§ ass fseq = fseq.next())
                    (§ return (§ expr ret))
                )
                (§ elseif (riter != nil && riter.hasNext()))
                (§
                    (§ return (§ expr riter.next()))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )))
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
#_public
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    #_public
    #_final
    (§ field Comparator comp)
    #_public
    #_final
    (§ field Node tree)
    #_public
    #_final
    (§ field int _count)
    #_final
    (§ field IPersistentMap _meta)

    #_final
    #_static
    #_public
    (§ field PersistentTreeMap EMPTY = new PersistentTreeMap())

    #_static
    #_public
    (§ method IPersistentMap create(Map other)
        (§ let IPersistentMap ret = EMPTY)
        (§ for (Object o :in other.entrySet()))
        (§
            (§ let Map.Entry e = (Entry) o)
            (§ ass ret = ret.assoc(e.getKey(), e.getValue()))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method PersistentTreeMap()
        (§ this(RT.DEFAULT_COMPARATOR))
    )

    #_public
    (§ method PersistentTreeMap withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentTreeMap(meta, comp, tree, _count)))
    )

    #_private
    (§ method PersistentTreeMap(Comparator comp)
        (§ this(nil, comp))
    )

    #_public
    (§ method PersistentTreeMap(IPersistentMap meta, Comparator comp)
        (§ ass this.comp = comp)
        (§ ass this._meta = meta)
        (§ ass tree = nil)
        (§ ass _count = 0)
    )

    (§ method PersistentTreeMap(IPersistentMap meta, Comparator comp, Node tree, int _count)
        (§ ass this._meta = meta)
        (§ ass this.comp = comp)
        (§ ass this.tree = tree)
        (§ ass this._count = _count)
    )

    #_static
    #_public
    (§ method PersistentTreeMap create(ISeq items)
        (§ let IPersistentMap ret = EMPTY)
        (§ for (  items != nil items = items.next().next()))
        (§
            (§ if (items.next() == nil))
            (§
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (§ ass ret = ret.assoc(items.first(), RT.second(items)))
        )
        (§ return (§ expr (PersistentTreeMap) ret))
    )

    #_static
    #_public
    (§ method PersistentTreeMap create(Comparator comp, ISeq items)
        (§ let IPersistentMap ret = new PersistentTreeMap(comp))
        (§ for (  items != nil items = items.next().next()))
        (§
            (§ if (items.next() == nil))
            (§
                (§ throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first())))
            )
            (§ ass ret = ret.assoc(items.first(), RT.second(items)))
        )
        (§ return (§ expr (PersistentTreeMap) ret))
    )

    #_public
    (§ method boolean containsKey(Object key)
        (§ return (§ expr (entryAt(key) != nil)))
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ try )
        (§
            (§ return (§ expr super.equals(obj)))
        )
        (§ catch (ClassCastException e))
        (§
            (§ return (§ expr false))
        )
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ try )
        (§
            (§ return (§ expr super.equiv(obj)))
        )
        (§ catch (ClassCastException e))
        (§
            (§ return (§ expr false))
        )
    )

    #_public
    (§ method PersistentTreeMap assocEx(Object key, Object val)
        (§ let Box found = new Box(nil))
        (§ let Node t = add(tree, key, val, found))
        (§ if (t == nil)) ;; nil == already contains key
        (§
            (§ throw Util.runtimeException("Key already present"))
        )
        (§ return (§ expr new PersistentTreeMap(comp, t.blacken(), _count + 1, meta())))
    )

    #_public
    (§ method PersistentTreeMap assoc(Object key, Object val)
        (§ let Box found = new Box(nil))
        (§ let Node t = add(tree, key, val, found))
        (§ if (t == nil)) ;; nil == already contains key
        (§
            (§ let Node foundNode = (Node) found.val)
            (§ if (foundNode.val() == val)) ;; note only get same collection on identity of val, not equals()
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())))
        )
        (§ return (§ expr new PersistentTreeMap(comp, t.blacken(), _count + 1, meta())))
    )

    #_public
    (§ method PersistentTreeMap without(Object key)
        (§ let Box found = new Box(nil))
        (§ let Node t = remove(tree, key, found))
        (§ if (t == nil))
        (§
            (§ if (found.val == nil)) ;; nil == doesn't contain key
            (§
                (§ return (§ expr this))
            )
            ;; empty
            (§ return (§ expr new PersistentTreeMap(meta(), comp)))
        )
        (§ return (§ expr new PersistentTreeMap(comp, t.blacken(), _count - 1, meta())))
    )

    #_public
    (§ method ISeq seq()
        (§ if (_count > 0))
        (§
            (§ return (§ expr Seq.create(tree, true, _count)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr new PersistentTreeMap(meta(), comp)))
    )

    #_public
    (§ method ISeq rseq()
        (§ if (_count > 0))
        (§
            (§ return (§ expr Seq.create(tree, false, _count)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method Comparator comparator()
        (§ return (§ expr comp))
    )

    #_public
    (§ method Object entryKey(Object entry)
        (§ return (§ expr ((IMapEntry) entry).key()))
    )

    #_public
    (§ method ISeq seq(boolean ascending)
        (§ if (_count > 0))
        (§
            (§ return (§ expr Seq.create(tree, ascending, _count)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method ISeq seqFrom(Object key, boolean ascending)
        (§ if (_count > 0))
        (§
            (§ let ISeq stack = nil)
            (§ let Node t = tree)
            (§ while (t != nil))
            (§
                (§ let int c = doCompare(key, t.key))
                (§ if (c == 0))
                (§
                    (§ ass stack = RT.cons(t, stack))
                    (§ return (§ expr new Seq(stack, ascending)))
                )
                (§ elseif (ascending))
                (§
                    (§ if (c < 0))
                    (§
                        (§ ass stack = RT.cons(t, stack))
                        (§ ass t = t.left())
                    )
                    (§ else )
                    (§
                        (§ ass t = t.right())
                    )
                )
                (§ else )
                (§
                    (§ if (c > 0))
                    (§
                        (§ ass stack = RT.cons(t, stack))
                        (§ ass t = t.right())
                    )
                    (§ else )
                    (§
                        (§ ass t = t.left())
                    )
                )
            )
            (§ if (stack != nil))
            (§
                (§ return (§ expr new Seq(stack, ascending)))
            )
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method NodeIterator iterator()
        (§ return (§ expr new NodeIterator(tree, true)))
    )

    #_public
    (§ method Object kvreduce(IFn f, Object init)
        (§ if (tree != nil))
        (§
            (§ ass init = tree.kvreduce(f, init))
        )
        (§ if (RT.isReduced(init)))
        (§
            (§ ass init = ((IDeref)init).deref())
        )
        (§ return (§ expr init))
    )

    #_public
    (§ method NodeIterator reverseIterator()
        (§ return (§ expr new NodeIterator(tree, false)))
    )

    #_public
    (§ method Iterator keys()
        (§ return (§ expr keys(iterator())))
    )

    #_public
    (§ method Iterator vals()
        (§ return (§ expr vals(iterator())))
    )

    #_public
    (§ method Iterator keys(NodeIterator it)
        (§ return (§ expr new KeyIterator(it)))
    )

    #_public
    (§ method Iterator vals(NodeIterator it)
        (§ return (§ expr new ValIterator(it)))
    )

    #_public
    (§ method Object minKey()
        (§ let Node t = min())
        (§ return (§ expr (t != nil) ? t.key :or nil))
    )

    #_public
    (§ method Node min()
        (§ let Node t = tree)
        (§ if (t != nil))
        (§
            (§ while (t.left() != nil))
            (§
                (§ ass t = t.left())
            )
        )
        (§ return (§ expr t))
    )

    #_public
    (§ method Object maxKey()
        (§ let Node t = max())
        (§ return (§ expr (t != nil) ? t.key :or nil))
    )

    #_public
    (§ method Node max()
        (§ let Node t = tree)
        (§ if (t != nil))
        (§
            (§ while (t.right() != nil))
            (§
                (§ ass t = t.right())
            )
        )
        (§ return (§ expr t))
    )

    #_public
    (§ method int depth()
        (§ return (§ expr depth(tree)))
    )

    (§ method int depth(Node t)
        (§ if (t == nil))
        (§
            (§ return (§ expr 0))
        )
        (§ return (§ expr 1 + Math.max(depth(t.left()), depth(t.right()))))
    )

    #_public
    (§ method Object valAt(Object key, Object notFound)
        (§ let Node n = entryAt(key))
        (§ return (§ expr (n != nil) ? n.val() :or notFound))
    )

    #_public
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    (§ method int capacity()
        (§ return (§ expr _count))
    )

    #_public
    (§ method int count()
        (§ return (§ expr _count))
    )

    #_public
    (§ method Node entryAt(Object key)
        (§ let Node t = tree)
        (§ while (t != nil))
        (§
            (§ let int c = doCompare(key, t.key))
            (§ if (c == 0))
            (§
                (§ return (§ expr t))
            )
            (§ elseif (c < 0))
            (§
                (§ ass t = t.left())
            )
            (§ else )
            (§
                (§ ass t = t.right())
            )
        )
        (§ return (§ expr t))
    )

    #_public
    (§ method int doCompare(Object k1, Object k2)
        (§ return (§ expr comp.compare(k1, k2)))
    )

    (§ method Node add(Node t, Object key, Object val, Box found)
        (§ if (t == nil))
        (§
            (§ if (val == nil))
            (§
                (§ return (§ expr new Red(key)))
            )
            (§ return (§ expr new RedVal(key, val)))
        )
        (§ let int c = doCompare(key, t.key))
        (§ if (c == 0))
        (§
            (§ ass found.val = t)
            (§ return (§ expr nil))
        )
        (§ let Node ins = (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found))
        (§ if (ins == nil)) ;; found below
        (§
            (§ return (§ expr nil))
        )
        (§ if (c < 0))
        (§
            (§ return (§ expr t.addLeft(ins)))
        )
        (§ return (§ expr t.addRight(ins)))
    )

    (§ method Node remove(Node t, Object key, Box found)
        (§ if (t == nil))
        (§
            (§ return (§ expr nil)) ;; not found indicator
        )
        (§ let int c = doCompare(key, t.key))
        (§ if (c == 0))
        (§
            (§ ass found.val = t)
            (§ return (§ expr append(t.left(), t.right())))
        )
        (§ let Node del = (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found))
        (§ if (del == nil && found.val == nil)) ;; not found below
        (§
            (§ return (§ expr nil))
        )
        (§ if (c < 0))
        (§
            (§ if (t.left() instanceof Black))
            (§
                (§ return (§ expr balanceLeftDel(t.key, t.val(), del, t.right())))
            )
            (§ else )
            (§
                (§ return (§ expr red(t.key, t.val(), del, t.right())))
            )
        )
        (§ if (t.right() instanceof Black))
        (§
            (§ return (§ expr balanceRightDel(t.key, t.val(), t.left(), del)))
        )
        (§ return (§ expr red(t.key, t.val(), t.left(), del)))
    )

    #_static
    (§ method Node append(Node left, Node right)
        (§ if (left == nil))
        (§
            (§ return (§ expr right))
        )
        (§ elseif (right == nil))
        (§
            (§ return (§ expr left))
        )
        (§ elseif (left instanceof Red))
        (§
            (§ if (right instanceof Red))
            (§
                (§ let Node app = append(left.right(), right.left()))
                (§ if (app instanceof Red))
                (§
                    (§ return (§ expr red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right()))))
                )
                (§ else )
                (§
                    (§ return (§ expr red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right()))))
                )
            )
            (§ else )
            (§
                (§ return (§ expr red(left.key, left.val(), left.left(), append(left.right(), right))))
            )
        )
        (§ elseif (right instanceof Red))
        (§
            (§ return (§ expr red(right.key, right.val(), append(left, right.left()), right.right())))
        )
        (§ else ) ;; black/black
        (§
            (§ let Node app = append(left.right(), right.left()))
            (§ if (app instanceof Red))
            (§
                (§ return (§ expr red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right()))))
            )
            (§ else )
            (§
                (§ return (§ expr balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right()))))
            )
        )
    )

    #_static
    (§ method Node balanceLeftDel(Object key, Object val, Node del, Node right)
        (§ if (del instanceof Red))
        (§
            (§ return (§ expr red(key, val, del.blacken(), right)))
        )
        (§ elseif (right instanceof Black))
        (§
            (§ return (§ expr rightBalance(key, val, del, right.redden())))
        )
        (§ elseif (right instanceof Red && right.left() instanceof Black))
        (§
            (§ return (§ expr red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden()))))
        )
        (§ else )
        (§
            (§ throw new UnsupportedOperationException("Invariant violation"))
        )
    )

    #_static
    (§ method Node balanceRightDel(Object key, Object val, Node left, Node del)
        (§ if (del instanceof Red))
        (§
            (§ return (§ expr red(key, val, left, del.blacken())))
        )
        (§ elseif (left instanceof Black))
        (§
            (§ return (§ expr leftBalance(key, val, left.redden(), del)))
        )
        (§ elseif (left instanceof Red && left.right() instanceof Black))
        (§
            (§ return (§ expr red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del))))
        )
        (§ else )
        (§
            (§ throw new UnsupportedOperationException("Invariant violation"))
        )
    )

    #_static
    (§ method Node leftBalance(Object key, Object val, Node ins, Node right)
        (§ if (ins instanceof Red && ins.left() instanceof Red))
        (§
            (§ return (§ expr red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right))))
        )
        (§ elseif (ins instanceof Red && ins.right() instanceof Red))
        (§
            (§ return (§ expr red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right))))
        )
        (§ else )
        (§
            (§ return (§ expr black(key, val, ins, right)))
        )
    )

    #_static
    (§ method Node rightBalance(Object key, Object val, Node left, Node ins)
        (§ if (ins instanceof Red && ins.right() instanceof Red))
        (§
            (§ return (§ expr red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken())))
        )
        (§ elseif (ins instanceof Red && ins.left() instanceof Red))
        (§
            (§ return (§ expr red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right()))))
        )
        (§ else )
        (§
            (§ return (§ expr black(key, val, left, ins)))
        )
    )

    (§ method Node replace(Node t, Object key, Object val)
        (§ let int c = doCompare(key, t.key))
        (§ return (§ expr t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right())))
    )

    (§ method PersistentTreeMap(Comparator comp, Node tree, int count, IPersistentMap meta)
        (§ ass this._meta = meta)
        (§ ass this.comp = comp)
        (§ ass this.tree = tree)
        (§ ass this._count = count)
    )

    #_static
    (§ method Red red(Object key, Object val, Node left, Node right)
        (§ if (left == nil && right == nil))
        (§
            (§ if (val == nil))
            (§
                (§ return (§ expr new Red(key)))
            )
            (§ return (§ expr new RedVal(key, val)))
        )
        (§ if (val == nil))
        (§
            (§ return (§ expr new RedBranch(key, left, right)))
        )
        (§ return (§ expr new RedBranchVal(key, val, left, right)))
    )

    #_static
    (§ method Black black(Object key, Object val, Node left, Node right)
        (§ if (left == nil && right == nil))
        (§
            (§ if (val == nil))
            (§
                (§ return (§ expr new Black(key)))
            )
            (§ return (§ expr new BlackVal(key, val)))
        )
        (§ if (val == nil))
        (§
            (§ return (§ expr new BlackBranch(key, left, right)))
        )
        (§ return (§ expr new BlackBranchVal(key, val, left, right)))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    #_static
    #_abstract
    (class-ns Node (§ extends AMapEntry)
        #_final
        (§ field Object key)

        (§ method Node(Object key)
            (§ ass this.key = key)
        )

        #_public
        (§ method Object key()
            (§ return (§ expr key))
        )

        #_public
        (§ method Object val()
            (§ return (§ expr nil))
        )

        #_public
        (§ method Object getKey()
            (§ return (§ expr key()))
        )

        #_public
        (§ method Object getValue()
            (§ return (§ expr val()))
        )

        (§ method Node left()
            (§ return (§ expr nil))
        )

        (§ method Node right()
            (§ return (§ expr nil))
        )

        (§ abstract Node addLeft(Node ins))
        (§ abstract Node addRight(Node ins))
        (§ abstract Node removeLeft(Node del))
        (§ abstract Node removeRight(Node del))
        (§ abstract Node blacken())
        (§ abstract Node redden())

        (§ method Node balanceLeft(Node parent)
            (§ return (§ expr black(parent.key, parent.val(), this, parent.right())))
        )

        (§ method Node balanceRight(Node parent)
            (§ return (§ expr black(parent.key, parent.val(), parent.left(), this)))
        )

        (§ abstract Node replace(Object key, Object val, Node left, Node right))

        #_public
        (§ method Object kvreduce(IFn f, Object init)
            (§ if (left() != nil))
            (§
                (§ ass init = left().kvreduce(f, init))
                (§ if (RT.isReduced(init)))
                (§
                    (§ return (§ expr init))
                )
            )
            (§ ass init = f.invoke(init, key(), val()))
            (§ if (RT.isReduced(init)))
            (§
                (§ return (§ expr init))
            )

            (§ if (right() != nil))
            (§
                (§ ass init = right().kvreduce(f, init))
            )
            (§ return (§ expr init))
        )
    )

    #_static
    (class-ns Black (§ extends Node)
        #_public
        (§ method Black(Object key)
            (§ super(key))
        )

        (§ method Node addLeft(Node ins)
            (§ return (§ expr ins.balanceLeft(this)))
        )

        (§ method Node addRight(Node ins)
            (§ return (§ expr ins.balanceRight(this)))
        )

        (§ method Node removeLeft(Node del)
            (§ return (§ expr balanceLeftDel(key, val(), del, right())))
        )

        (§ method Node removeRight(Node del)
            (§ return (§ expr balanceRightDel(key, val(), left(), del)))
        )

        (§ method Node blacken()
            (§ return (§ expr this))
        )

        (§ method Node redden()
            (§ return (§ expr new Red(key)))
        )

        (§ method Node replace(Object key, Object val, Node left, Node right)
            (§ return (§ expr black(key, val, left, right)))
        )
    )

    #_static
    (class-ns BlackVal (§ extends Black)
        #_final
        (§ field Object val)

        #_public
        (§ method BlackVal(Object key, Object val)
            (§ super(key))
            (§ ass this.val = val)
        )

        #_public
        (§ method Object val()
            (§ return (§ expr val))
        )

        (§ method Node redden()
            (§ return (§ expr new RedVal(key, val)))
        )
    )

    #_static
    (class-ns BlackBranch (§ extends Black)
        #_final
        (§ field Node left)

        #_final
        (§ field Node right)

        #_public
        (§ method BlackBranch(Object key, Node left, Node right)
            (§ super(key))
            (§ ass this.left = left)
            (§ ass this.right = right)
        )

        #_public
        (§ method Node left()
            (§ return (§ expr left))
        )

        #_public
        (§ method Node right()
            (§ return (§ expr right))
        )

        (§ method Node redden()
            (§ return (§ expr new RedBranch(key, left, right)))
        )
    )

    #_static
    (class-ns BlackBranchVal (§ extends BlackBranch)
        #_final
        (§ field Object val)

        #_public
        (§ method BlackBranchVal(Object key, Object val, Node left, Node right)
            (§ super(key, left, right))
            (§ ass this.val = val)
        )

        #_public
        (§ method Object val()
            (§ return (§ expr val))
        )

        (§ method Node redden()
            (§ return (§ expr new RedBranchVal(key, val, left, right)))
        )
    )

    #_static
    (class-ns Red (§ extends Node)
        #_public
        (§ method Red(Object key)
            (§ super(key))
        )

        (§ method Node addLeft(Node ins)
            (§ return (§ expr red(key, val(), ins, right())))
        )

        (§ method Node addRight(Node ins)
            (§ return (§ expr red(key, val(), left(), ins)))
        )

        (§ method Node removeLeft(Node del)
            (§ return (§ expr red(key, val(), del, right())))
        )

        (§ method Node removeRight(Node del)
            (§ return (§ expr red(key, val(), left(), del)))
        )

        (§ method Node blacken()
            (§ return (§ expr new Black(key)))
        )

        (§ method Node redden()
            (§ throw new UnsupportedOperationException("Invariant violation"))
        )

        (§ method Node replace(Object key, Object val, Node left, Node right)
            (§ return (§ expr red(key, val, left, right)))
        )
    )

    #_static
    (class-ns RedVal (§ extends Red)
        #_final
        (§ field Object val)

        #_public
        (§ method RedVal(Object key, Object val)
            (§ super(key))
            (§ ass this.val = val)
        )

        #_public
        (§ method Object val()
            (§ return (§ expr val))
        )

        (§ method Node blacken()
            (§ return (§ expr new BlackVal(key, val)))
        )
    )

    #_static
    (class-ns RedBranch (§ extends Red)
        #_final
        (§ field Node left)

        #_final
        (§ field Node right)

        #_public
        (§ method RedBranch(Object key, Node left, Node right)
            (§ super(key))
            (§ ass this.left = left)
            (§ ass this.right = right)
        )

        #_public
        (§ method Node left()
            (§ return (§ expr left))
        )

        #_public
        (§ method Node right()
            (§ return (§ expr right))
        )

        (§ method Node balanceLeft(Node parent)
            (§ if (left instanceof Red))
            (§
                (§ return (§ expr red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right()))))
            )
            (§ elseif (right instanceof Red))
            (§
                (§ return (§ expr red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right()))))
            )
            (§ else )
            (§
                (§ return (§ expr super.balanceLeft(parent)))
            )
        )

        (§ method Node balanceRight(Node parent)
            (§ if (right instanceof Red))
            (§
                (§ return (§ expr red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken())))
            )
            (§ elseif (left instanceof Red))
            (§
                (§ return (§ expr red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right))))
            )
            (§ else )
            (§
                (§ return (§ expr super.balanceRight(parent)))
            )
        )

        (§ method Node blacken()
            (§ return (§ expr new BlackBranch(key, left, right)))
        )
    )

    #_static
    (class-ns RedBranchVal (§ extends RedBranch)
        #_final
        (§ field Object val)

        #_public
        (§ method RedBranchVal(Object key, Object val, Node left, Node right)
            (§ super(key, left, right))
            (§ ass this.val = val)
        )

        #_public
        (§ method Object val()
            (§ return (§ expr val))
        )

        (§ method Node blacken()
            (§ return (§ expr new BlackBranchVal(key, val, left, right)))
        )
    )

    #_static
    #_public
    (class-ns Seq (§ extends ASeq)
        #_final
        (§ field ISeq stack)
        #_final
        (§ field boolean asc)
        #_final
        (§ field int cnt)

        #_public
        (§ method Seq(ISeq stack, boolean asc)
            (§ ass this.stack = stack)
            (§ ass this.asc = asc)
            (§ ass this.cnt = -1)
        )

        #_public
        (§ method Seq(ISeq stack, boolean asc, int cnt)
            (§ ass this.stack = stack)
            (§ ass this.asc = asc)
            (§ ass this.cnt = cnt)
        )

        (§ method Seq(IPersistentMap meta, ISeq stack, boolean asc, int cnt)
            (§ super(meta))
            (§ ass this.stack = stack)
            (§ ass this.asc = asc)
            (§ ass this.cnt = cnt)
        )

        #_static
        (§ method Seq create(Node t, boolean asc, int cnt)
            (§ return (§ expr new Seq(push(t, nil, asc), asc, cnt)))
        )

        #_static
        (§ method ISeq push(Node t, ISeq stack, boolean asc)
            (§ while (t != nil))
            (§
                (§ ass stack = RT.cons(t, stack))
                (§ ass t = asc ? t.left() :or t.right())
            )
            (§ return (§ expr stack))
        )

        #_public
        (§ method Object first()
            (§ return (§ expr stack.first()))
        )

        #_public
        (§ method ISeq next()
            (§ let Node t = (Node) stack.first())
            (§ let ISeq nextstack = push(asc ? t.right() :or t.left(), stack.next(), asc))
            (§ if (nextstack != nil))
            (§
                (§ return (§ expr new Seq(nextstack, asc, cnt - 1)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method int count()
            (§ if (cnt < 0))
            (§
                (§ return (§ expr super.count()))
            )
            (§ return (§ expr cnt))
        )

        #_public
        (§ method Obj withMeta(IPersistentMap meta)
            (§ return (§ expr new Seq(meta, stack, asc, cnt)))
        )
    )

    #_static
    #_public
    (class-ns NodeIterator (§ implements Iterator)
        (§ field Stack stack = new Stack())
        (§ field boolean asc)

        (§ method NodeIterator(Node t, boolean asc)
            (§ ass this.asc = asc)
            (§ call push(t))
        )

        (§ method void push(Node t)
            (§ while (t != nil))
            (§
                (§ call stack.push(t))
                (§ ass t = asc ? t.left() :or t.right())
            )
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr !stack.isEmpty()))
        )

        #_public
        (§ method Object next()
            (§ try )
            (§
                (§ let Node t = (Node) stack.pop())
                (§ call push(asc ? t.right() :or t.left()))
                (§ return (§ expr t))
            )
            (§ catch (EmptyStackException e))
            (§
                (§ throw new NoSuchElementException())
            )
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    #_static
    (class-ns KeyIterator (§ implements Iterator)
        (§ field NodeIterator it)

        (§ method KeyIterator(NodeIterator it)
            (§ ass this.it = it)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr it.hasNext()))
        )

        #_public
        (§ method Object next()
            (§ return (§ expr ((Node) it.next()).key))
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )

    #_static
    (class-ns ValIterator (§ implements Iterator)
        (§ field NodeIterator it)

        (§ method ValIterator(NodeIterator it)
            (§ ass this.it = it)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr it.hasNext()))
        )

        #_public
        (§ method Object next()
            (§ return (§ expr ((Node) it.next()).val()))
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

#_public
(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    #_static
    #_public
    #_final
    (§ field PersistentTreeSet EMPTY = new PersistentTreeSet(nil, PersistentTreeMap.EMPTY))

    #_final
    (§ field IPersistentMap _meta)

    #_static
    #_public
    (§ method PersistentTreeSet create(ISeq items)
        (§ let PersistentTreeSet ret = EMPTY)
        (§ for (  items != nil items = items.next()))
        (§
            (§ ass ret = (PersistentTreeSet) ret.cons(items.first()))
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method PersistentTreeSet create(Comparator comp, ISeq items)
        (§ let PersistentTreeSet ret = new PersistentTreeSet(nil, new PersistentTreeMap(nil, comp)))
        (§ for (  items != nil items = items.next()))
        (§
            (§ ass ret = (PersistentTreeSet) ret.cons(items.first()))
        )
        (§ return (§ expr ret))
    )

    (§ method PersistentTreeSet(IPersistentMap meta, IPersistentMap impl)
        (§ super(impl))
        (§ ass this._meta = meta)
    )

    #_public
    (§ method boolean equals(Object obj)
        (§ try )
        (§
            (§ return (§ expr super.equals(obj)))
        )
        (§ catch (ClassCastException e))
        (§
            (§ return (§ expr false))
        )
    )

    #_public
    (§ method boolean equiv(Object obj)
        (§ try )
        (§
            (§ return (§ expr super.equiv(obj)))
        )
        (§ catch (ClassCastException e))
        (§
            (§ return (§ expr false))
        )
    )

    #_public
    (§ method IPersistentSet disjoin(Object key)
        (§ if (contains(key)))
        (§
            (§ return (§ expr new PersistentTreeSet(meta(), impl.without(key))))
        )
        (§ return (§ expr this))
    )

    #_public
    (§ method IPersistentSet cons(Object o)
        (§ if (contains(o)))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentTreeSet(meta(), impl.assoc(o, o))))
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty())))
    )

    #_public
    (§ method ISeq rseq()
        (§ return (§ expr APersistentMap.KeySeq.create(((Reversible) impl).rseq())))
    )

    #_public
    (§ method PersistentTreeSet withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentTreeSet(meta, impl)))
    )

    #_public
    (§ method Comparator comparator()
        (§ return (§ expr ((Sorted)impl).comparator()))
    )

    #_public
    (§ method Object entryKey(Object entry)
        (§ return (§ expr entry))
    )

    #_public
    (§ method ISeq seq(boolean ascending)
        (§ let PersistentTreeMap m = (PersistentTreeMap) impl)
        (§ return (§ expr RT.keys(m.seq(ascending))))
    )

    #_public
    (§ method ISeq seqFrom(Object key, boolean ascending)
        (§ let PersistentTreeMap m = (PersistentTreeMap) impl)
        (§ return (§ expr RT.keys(m.seqFrom(key, ascending))))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

#_public
(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    #_public
    #_static
    (class-ns Node
        #_transient
        #_public
        #_final
        (§ field AtomicReference<Thread> edit)
        #_public
        #_final
        (§ field Object[] array)

        #_public
        (§ method Node(AtomicReference<Thread> edit, Object[] array)
            (§ ass this.edit = edit)
            (§ ass this.array = array)
        )

        (§ method Node(AtomicReference<Thread> edit)
            (§ ass this.edit = edit)
            (§ ass this.array = new Object[32])
        )
    )

    #_final
    #_static
    (§ field AtomicReference<Thread> NOEDIT = new AtomicReference<Thread>(nil))
    #_public
    #_final
    #_static
    (§ field Node EMPTY_NODE = new Node(NOEDIT, new Object[32]))

    #_final
    (§ field int cnt)
    #_public
    #_final
    (§ field int shift)
    #_public
    #_final
    (§ field Node root)
    #_public
    #_final
    (§ field Object[] tail)
    #_final
    (§ field IPersistentMap _meta)

    #_public
    #_final
    #_static
    (§ field PersistentVector EMPTY = new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§)))

    #_private
    #_static
    #_final
    (§ field IFn TRANSIENT_VECTOR_CONJ = new AFn()
    (§ inner
        #_public
        (§ method Object invoke(Object coll, Object val)
            (§ return (§ expr ((ITransientVector)coll).conj(val)))
        )
        #_public
        (§ method Object invoke(Object coll)
            (§ return (§ expr coll))
        )
    ))

    #_static
    #_public
    (§ method PersistentVector adopt(Object [] items)
        (§ return (§ expr new PersistentVector(items.length, 5, EMPTY_NODE, items)))
    )

    #_static
    #_public
    (§ method PersistentVector create(IReduceInit items)
        (§ let TransientVector ret = EMPTY.asTransient())
        (§ call items.reduce(TRANSIENT_VECTOR_CONJ, ret))
        (§ return (§ expr ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentVector create(ISeq items)
        (§ let Object[] arr = new Object[32])
        (§ let int i = 0)
        (§ for (  items != nil && i < 32 items = items.next()))
        (§
            (§ ass arr[i++] = items.first())
        )

        (§ if (items != nil)) ;; >32, construct with array directly
        (§
            (§ let PersistentVector start = new PersistentVector(32, 5, EMPTY_NODE, arr))
            (§ let TransientVector ret = start.asTransient())
            (§ for (  items != nil items = items.next()))
            (§
                (§ ass ret = ret.conj(items.first()))
            )
            (§ return (§ expr ret.persistent()))
        )
        (§ elseif (i == 32)) ;; exactly 32, skip copy
        (§
            (§ return (§ expr new PersistentVector(32, 5, EMPTY_NODE, arr)))
        )
        (§ else ) ;; <32, copy to minimum array and construct
        (§
            (§ let Object[] arr2 = new Object[i])
            (§ call System.arraycopy(arr, 0, arr2, 0, i))
            (§ return (§ expr new PersistentVector(i, 5, EMPTY_NODE, arr2)))
        )
    )

    #_static
    #_public
    (§ method PersistentVector create(List list)
        (§ let int size = list.size())
        (§ if (size <= 32))
        (§
            (§ return (§ expr new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())))
        )

        (§ let TransientVector ret = EMPTY.asTransient())
        (§ for (int i = 0 i < size i++))
        (§
            (§ ass ret = ret.conj(list.get(i)))
        )
        (§ return (§ expr ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentVector create(Iterable items)
        ;; optimize common case
        (§ if (items instanceof ArrayList))
        (§
            (§ return (§ expr create((ArrayList)items)))
        )

        (§ let Iterator iter = items.iterator())
        (§ let TransientVector ret = EMPTY.asTransient())
        (§ while (iter.hasNext()))
        (§
            (§ ass ret = ret.conj(iter.next()))
        )
        (§ return (§ expr ret.persistent()))
    )

    #_static
    #_public
    (§ method PersistentVector create(Object... items)
        (§ let TransientVector ret = EMPTY.asTransient())
        (§ for (Object item :in items))
        (§
            (§ ass ret = ret.conj(item))
        )
        (§ return (§ expr ret.persistent()))
    )

    (§ method PersistentVector(int cnt, int shift, Node root, Object[] tail)
        (§ ass this._meta = nil)
        (§ ass this.cnt = cnt)
        (§ ass this.shift = shift)
        (§ ass this.root = root)
        (§ ass this.tail = tail)
    )

    (§ method PersistentVector(IPersistentMap meta, int cnt, int shift, Node root, Object[] tail)
        (§ ass this._meta = meta)
        (§ ass this.cnt = cnt)
        (§ ass this.shift = shift)
        (§ ass this.root = root)
        (§ ass this.tail = tail)
    )

    #_public
    (§ method TransientVector asTransient()
        (§ return (§ expr new TransientVector(this)))
    )

    #_final
    (§ method int tailoff()
        (§ if (cnt < 32))
        (§
            (§ return (§ expr 0))
        )
        (§ return (§ expr ((cnt - 1) >>> 5) << 5))
    )

    #_public
    (§ method Object[] arrayFor(int i)
        (§ if (i >= 0 && i < cnt))
        (§
            (§ if (i >= tailoff()))
            (§
                (§ return (§ expr tail))
            )
            (§ let Node node = root)
            (§ for (int level = shift level > 0 level -= 5))
            (§
                (§ ass node = (Node) node.array[(i >>> level) & 0x01f])
            )
            (§ return (§ expr node.array))
        )
        (§ throw new IndexOutOfBoundsException())
    )

    #_public
    (§ method Object nth(int i)
        (§ let Object[] node = arrayFor(i))
        (§ return (§ expr node[i & 0x01f]))
    )

    #_public
    (§ method Object nth(int i, Object notFound)
        (§ if (i >= 0 && i < cnt))
        (§
            (§ return (§ expr nth(i)))
        )
        (§ return (§ expr notFound))
    )

    #_public
    (§ method PersistentVector assocN(int i, Object val)
        (§ if (i >= 0 && i < cnt))
        (§
            (§ if (i >= tailoff()))
            (§
                (§ let Object[] newTail = new Object[tail.length])
                (§ call System.arraycopy(tail, 0, newTail, 0, tail.length))
                (§ ass newTail[i & 0x01f] = val)

                (§ return (§ expr new PersistentVector(meta(), cnt, shift, root, newTail)))
            )

            (§ return (§ expr new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)))
        )
        (§ if (i == cnt))
        (§
            (§ return (§ expr cons(val)))
        )
        (§ throw new IndexOutOfBoundsException())
    )

    #_private
    #_static
    (§ method Node doAssoc(int level, Node node, int i, Object val)
        (§ let Node ret = new Node(node.edit, node.array.clone()))
        (§ if (level == 0))
        (§
            (§ ass ret.array[i & 0x01f] = val)
        )
        (§ else )
        (§
            (§ let int subidx = (i >>> level) & 0x01f)
            (§ ass ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
        )
        (§ return (§ expr ret))
    )

    #_public
    (§ method int count()
        (§ return (§ expr cnt))
    )

    #_public
    (§ method PersistentVector withMeta(IPersistentMap meta)
        (§ return (§ expr new PersistentVector(meta, cnt, shift, root, tail)))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )

    #_public
    (§ method PersistentVector cons(Object val)
        ;; room in tail?
        (§ if (cnt - tailoff() < 32))
        (§
            (§ let Object[] newTail = new Object[tail.length + 1])
            (§ call System.arraycopy(tail, 0, newTail, 0, tail.length))
            (§ ass newTail[tail.length] = val)
            (§ return (§ expr new PersistentVector(meta(), cnt + 1, shift, root, newTail)))
        )
        ;; full tail, push into tree
        (§ let Node newroot)
        (§ let Node tailnode = new Node(root.edit, tail))
        (§ let int newshift = shift)
        ;; overflow root?
        (§ if ((cnt >>> 5) > (1 << shift)))
        (§
            (§ ass newroot = new Node(root.edit))
            (§ ass newroot.array[0] = root)
            (§ ass newroot.array[1] = newPath(root.edit, shift, tailnode))
            (§ ass newshift += 5)
        )
        (§ else )
        (§
            (§ ass newroot = pushTail(shift, root, tailnode))
        )
        (§ return (§ expr new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ val ))))
    )

    #_private
    (§ method Node pushTail(int level, Node parent, Node tailnode)
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (§ let int subidx = ((cnt - 1) >>> level) & 0x01f)
        (§ let Node ret = new Node(parent.edit, parent.array.clone()))
        (§ let Node nodeToInsert)
        (§ if (level == 5))
        (§
            (§ ass nodeToInsert = tailnode)
        )
        (§ else )
        (§
            (§ let Node child = (Node) parent.array[subidx])
            (§ ass nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
        )
        (§ ass ret.array[subidx] = nodeToInsert)
        (§ return (§ expr ret))
    )

    #_private
    #_static
    (§ method Node newPath(AtomicReference<Thread> edit, int level, Node node)
        (§ if (level == 0))
        (§
            (§ return (§ expr node))
        )
        (§ let Node ret = new Node(edit))
        (§ ass ret.array[0] = newPath(edit, level - 5, node))
        (§ return (§ expr ret))
    )

    #_public
    (§ method IChunkedSeq chunkedSeq()
        (§ if (count() == 0))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new ChunkedSeq(this, 0, 0)))
    )

    #_public
    (§ method ISeq seq()
        (§ return (§ expr chunkedSeq()))
    )

    (§ anno @Override)
    (§ method Iterator rangedIterator(final int start, final int end)
        (§ return (§ expr new Iterator()
        (§ inner
            (§ let int i = start)
            (§ let int base = i - (i%32))
            (§ let Object[] array = (start < count()) ? arrayFor(i) :or nil)

            #_public
            (§ method boolean hasNext()
                (§ return (§ expr (i < end)))
            )

            #_public
            (§ method Object next()
                (§ if (i < end))
                (§
                    (§ if (i - base == 32))
                    (§
                        (§ ass array = arrayFor(i))
                        (§ ass base += 32)
                    )
                    (§ return (§ expr array[i++ & 0x01f]))
                )
                (§ else )
                (§
                    (§ throw new NoSuchElementException())
                )
            )

            #_public
            (§ method void remove()
                (§ throw new UnsupportedOperationException())
            )
        )))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr rangedIterator(0, count())))
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ let Object init)
        (§ if (cnt > 0))
        (§
            (§ ass init = arrayFor(0)[0])
        )
        (§ else )
        (§
            (§ return (§ expr f.invoke()))
        )
        (§ let int step = 0)
        (§ for (int i = 0 i < cnt i += step))
        (§
            (§ let Object[] array = arrayFor(i))
            (§ for (int j = (i == 0) ? 1 :or 0 j < array.length ++j))
            (§
                (§ ass init = f.invoke(init, array[j]))
                (§ if (RT.isReduced(init)))
                (§
                    (§ return (§ expr ((IDeref)init).deref()))
                )
            )
            (§ ass step = array.length)
        )
        (§ return (§ expr init))
    )

    #_public
    (§ method Object reduce(IFn f, Object init)
        (§ let int step = 0)
        (§ for (int i = 0 i < cnt i += step))
        (§
            (§ let Object[] array = arrayFor(i))
            (§ for (int j = 0 j < array.length ++j))
            (§
                (§ ass init = f.invoke(init, array[j]))
                (§ if (RT.isReduced(init)))
                (§
                    (§ return (§ expr ((IDeref)init).deref()))
                )
            )
            (§ ass step = array.length)
        )
        (§ return (§ expr init))
    )

    #_public
    (§ method Object kvreduce(IFn f, Object init)
        (§ let int step = 0)
        (§ for (int i = 0 i < cnt i += step))
        (§
            (§ let Object[] array = arrayFor(i))
            (§ for (int j = 0 j < array.length ++j))
            (§
                (§ ass init = f.invoke(init, j + i, array[j]))
                (§ if (RT.isReduced(init)))
                (§
                    (§ return (§ expr ((IDeref)init).deref()))
                )
            )
            (§ ass step = array.length)
        )
        (§ return (§ expr init))
    )

    #_static
    #_public
    #_final
    (class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
        #_public
        #_final
        (§ field PersistentVector vec)
        #_final
        (§ field Object[] node)
        #_final
        (§ field int i)
        #_public
        #_final
        (§ field int offset)

        #_public
        (§ method ChunkedSeq(PersistentVector vec, int i, int offset)
            (§ ass this.vec = vec)
            (§ ass this.i = i)
            (§ ass this.offset = offset)
            (§ ass this.node = vec.arrayFor(i))
        )

        (§ method ChunkedSeq(IPersistentMap meta, PersistentVector vec, Object[] node, int i, int offset)
            (§ super(meta))
            (§ ass this.vec = vec)
            (§ ass this.node = node)
            (§ ass this.i = i)
            (§ ass this.offset = offset)
        )

        (§ method ChunkedSeq(PersistentVector vec, Object[] node, int i, int offset)
            (§ ass this.vec = vec)
            (§ ass this.node = node)
            (§ ass this.i = i)
            (§ ass this.offset = offset)
        )

        #_public
        (§ method IChunk chunkedFirst()
            (§ return (§ expr new ArrayChunk(node, offset)))
        )

        #_public
        (§ method ISeq chunkedNext()
            (§ if (i + node.length < vec.cnt))
            (§
                (§ return (§ expr new ChunkedSeq(vec, i + node.length, 0)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method ISeq chunkedMore()
            (§ let ISeq s = chunkedNext())
            (§ if (s == nil))
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr s))
        )

        #_public
        (§ method Obj withMeta(IPersistentMap meta)
            (§ if (meta == this._meta))
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new ChunkedSeq(meta, vec, node, i, offset)))
        )

        #_public
        (§ method Object first()
            (§ return (§ expr node[offset]))
        )

        #_public
        (§ method ISeq next()
            (§ if (offset + 1 < node.length))
            (§
                (§ return (§ expr new ChunkedSeq(vec, node, i, offset + 1)))
            )
            (§ return (§ expr chunkedNext()))
        )

        #_public
        (§ method int count()
            (§ return (§ expr vec.cnt - (i + offset)))
        )
    )

    #_public
    (§ method IPersistentCollection empty()
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    #_public
    (§ method PersistentVector pop()
        (§ if (cnt == 0))
        (§
            (§ throw new IllegalStateException("Can't pop empty vector"))
        )
        (§ if (cnt == 1))
        (§
            (§ return (§ expr EMPTY.withMeta(meta())))
        )
        (§ if (cnt - tailoff() > 1))
        (§
            (§ let Object[] newTail = new Object[tail.length - 1])
            (§ call System.arraycopy(tail, 0, newTail, 0, newTail.length))
            (§ return (§ expr new PersistentVector(meta(), cnt - 1, shift, root, newTail)))
        )
        (§ let Object[] newtail = arrayFor(cnt - 2))

        (§ let Node newroot = popTail(shift, root))
        (§ let int newshift = shift)
        (§ if (newroot == nil))
        (§
            (§ ass newroot = EMPTY_NODE)
        )
        (§ if (shift > 5 && newroot.array[1] == nil))
        (§
            (§ ass newroot = (Node) newroot.array[0])
            (§ ass newshift -= 5)
        )
        (§ return (§ expr new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail)))
    )

    #_private
    (§ method Node popTail(int level, Node node)
        (§ let int subidx = ((cnt - 2) >>> level) & 0x01f)
        (§ if (level > 5))
        (§
            (§ let Node newchild = popTail(level - 5, (Node) node.array[subidx]))
            (§ if (newchild == nil && subidx == 0))
            (§
                (§ return (§ expr nil))
            )
            (§ else )
            (§
                (§ let Node ret = new Node(root.edit, node.array.clone()))
                (§ ass ret.array[subidx] = newchild)
                (§ return (§ expr ret))
            )
        )
        (§ elseif (subidx == 0))
        (§
            (§ return (§ expr nil))
        )
        (§ else )
        (§
            (§ let Node ret = new Node(root.edit, node.array.clone()))
            (§ ass ret.array[subidx] = nil)
            (§ return (§ expr ret))
        )
    )

    #_static
    #_final
    (class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
        #_volatile
        (§ field int cnt)
        #_volatile
        (§ field int shift)
        #_volatile
        (§ field Node root)
        #_volatile
        (§ field Object[] tail)

        (§ method TransientVector(int cnt, int shift, Node root, Object[] tail)
            (§ ass this.cnt = cnt)
            (§ ass this.shift = shift)
            (§ ass this.root = root)
            (§ ass this.tail = tail)
        )

        (§ method TransientVector(PersistentVector v)
            (§ this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail)))
        )

        #_public
        (§ method int count()
            (§ call ensureEditable())
            (§ return (§ expr cnt))
        )

        (§ method Node ensureEditable(Node node)
            (§ if (node.edit == root.edit))
            (§
                (§ return (§ expr node))
            )
            (§ return (§ expr new Node(root.edit, node.array.clone())))
        )

        (§ method void ensureEditable()
            (§ if (root.edit.get() == nil))
            (§
                (§ throw new IllegalAccessError("Transient used after persistent! call"))
            )
        )

        #_static
        (§ method Node editableRoot(Node node)
            (§ return (§ expr new Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone())))
        )

        #_public
        (§ method PersistentVector persistent()
            (§ call ensureEditable())
            (§ call root.edit.set(nil))
            (§ let Object[] trimmedTail = new Object[cnt - tailoff()])
            (§ call System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length))
            (§ return (§ expr new PersistentVector(cnt, shift, root, trimmedTail)))
        )

        #_static
        (§ method Object[] editableTail(Object[] tl)
            (§ let Object[] ret = new Object[32])
            (§ call System.arraycopy(tl, 0, ret, 0, tl.length))
            (§ return (§ expr ret))
        )

        #_public
        (§ method TransientVector conj(Object val)
            (§ call ensureEditable())
            (§ let int i = cnt)
            ;; room in tail?
            (§ if (i - tailoff() < 32))
            (§
                (§ ass tail[i & 0x01f] = val)
                (§ ass ++cnt)
                (§ return (§ expr this))
            )
            ;; full tail, push into tree
            (§ let Node newroot)
            (§ let Node tailnode = new Node(root.edit, tail))
            (§ ass tail = new Object[32])
            (§ ass tail[0] = val)
            (§ let int newshift = shift)
            ;; overflow root?
            (§ if ((cnt >>> 5) > (1 << shift)))
            (§
                (§ ass newroot = new Node(root.edit))
                (§ ass newroot.array[0] = root)
                (§ ass newroot.array[1] = newPath(root.edit, shift, tailnode))
                (§ ass newshift += 5)
            )
            (§ else )
            (§
                (§ ass newroot = pushTail(shift, root, tailnode))
            )
            (§ ass root = newroot)
            (§ ass shift = newshift)
            (§ ass ++cnt)
            (§ return (§ expr this))
        )

        #_private
        (§ method Node pushTail(int level, Node parent, Node tailnode)
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            (§ ass parent = ensureEditable(parent))
            (§ let int subidx = ((cnt - 1) >>> level) & 0x01f)
            (§ let Node ret = parent)
            (§ let Node nodeToInsert)
            (§ if (level == 5))
            (§
                (§ ass nodeToInsert = tailnode)
            )
            (§ else )
            (§
                (§ let Node child = (Node) parent.array[subidx])
                (§ ass nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
            )
            (§ ass ret.array[subidx] = nodeToInsert)
            (§ return (§ expr ret))
        )

        #_final
        #_private
        (§ method int tailoff()
            (§ if (cnt < 32))
            (§
                (§ return (§ expr 0))
            )
            (§ return (§ expr ((cnt - 1) >>> 5) << 5))
        )

        #_private
        (§ method Object[] arrayFor(int i)
            (§ if (i >= 0 && i < cnt))
            (§
                (§ if (i >= tailoff()))
                (§
                    (§ return (§ expr tail))
                )
                (§ let Node node = root)
                (§ for (int level = shift level > 0 level -= 5))
                (§
                    (§ ass node = (Node) node.array[(i >>> level) & 0x01f])
                )
                (§ return (§ expr node.array))
            )
            (§ throw new IndexOutOfBoundsException())
        )

        #_private
        (§ method Object[] editableArrayFor(int i)
            (§ if (i >= 0 && i < cnt))
            (§
                (§ if (i >= tailoff()))
                (§
                    (§ return (§ expr tail))
                )
                (§ let Node node = root)
                (§ for (int level = shift level > 0 level -= 5))
                (§
                    (§ ass node = ensureEditable((Node) node.array[(i >>> level) & 0x01f]))
                )
                (§ return (§ expr node.array))
            )
            (§ throw new IndexOutOfBoundsException())
        )

        #_public
        (§ method Object valAt(Object key)
            ;; note - relies on ensureEditable in 2-arg valAt
            (§ return (§ expr valAt(key, nil)))
        )

        #_public
        (§ method Object valAt(Object key, Object notFound)
            (§ call ensureEditable())
            (§ if (Util.isInteger(key)))
            (§
                (§ let int i = ((Number) key).intValue())
                (§ if (i >= 0 && i < cnt))
                (§
                    (§ return (§ expr nth(i)))
                )
            )
            (§ return (§ expr notFound))
        )

        #_private
        #_static
        #_final
        (§ field Object NOT_FOUND = new Object())

        #_public
        #_final
        (§ method boolean containsKey(Object key)
            (§ return (§ expr (valAt(key, NOT_FOUND) != NOT_FOUND)))
        )

        #_public
        #_final
        (§ method IMapEntry entryAt(Object key)
            (§ let Object v = valAt(key, NOT_FOUND))
            (§ if (v != NOT_FOUND))
            (§
                (§ return (§ expr MapEntry.create(key, v)))
            )
            (§ return (§ expr nil))
        )

        #_public
        (§ method Object invoke(Object arg1)
            ;; note - relies on ensureEditable in nth
            (§ if (Util.isInteger(arg1)))
            (§
                (§ return (§ expr nth(((Number) arg1).intValue())))
            )
            (§ throw new IllegalArgumentException("Key must be integer"))
        )

        #_public
        (§ method Object nth(int i)
            (§ call ensureEditable())
            (§ let Object[] node = arrayFor(i))
            (§ return (§ expr node[i & 0x01f]))
        )

        #_public
        (§ method Object nth(int i, Object notFound)
            (§ if (i >= 0 && i < count()))
            (§
                (§ return (§ expr nth(i)))
            )
            (§ return (§ expr notFound))
        )

        #_public
        (§ method TransientVector assocN(int i, Object val)
            (§ call ensureEditable())
            (§ if (i >= 0 && i < cnt))
            (§
                (§ if (i >= tailoff()))
                (§
                    (§ ass tail[i & 0x01f] = val)
                    (§ return (§ expr this))
                )

                (§ ass root = doAssoc(shift, root, i, val))
                (§ return (§ expr this))
            )
            (§ if (i == cnt))
            (§
                (§ return (§ expr conj(val)))
            )
            (§ throw new IndexOutOfBoundsException())
        )

        #_public
        (§ method TransientVector assoc(Object key, Object val)
            ;; note - relies on ensureEditable in assocN
            (§ if (Util.isInteger(key)))
            (§
                (§ let int i = ((Number) key).intValue())
                (§ return (§ expr assocN(i, val)))
            )
            (§ throw new IllegalArgumentException("Key must be integer"))
        )

        #_private
        (§ method Node doAssoc(int level, Node node, int i, Object val)
            (§ ass node = ensureEditable(node))
            (§ let Node ret = node)
            (§ if (level == 0))
            (§
                (§ ass ret.array[i & 0x01f] = val)
            )
            (§ else )
            (§
                (§ let int subidx = (i >>> level) & 0x01f)
                (§ ass ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
            )
            (§ return (§ expr ret))
        )

        #_public
        (§ method TransientVector pop()
            (§ call ensureEditable())
            (§ if (cnt == 0))
            (§
                (§ throw new IllegalStateException("Can't pop empty vector"))
            )
            (§ if (cnt == 1))
            (§
                (§ ass cnt = 0)
                (§ return (§ expr this))
            )
            (§ let int i = cnt - 1)
            ;; pop in tail?
            (§ if ((i & 0x01f) > 0))
            (§
                (§ ass --cnt)
                (§ return (§ expr this))
            )

            (§ let Object[] newtail = editableArrayFor(cnt - 2))

            (§ let Node newroot = popTail(shift, root))
            (§ let int newshift = shift)
            (§ if (newroot == nil))
            (§
                (§ ass newroot = new Node(root.edit))
            )
            (§ if (shift > 5 && newroot.array[1] == nil))
            (§
                (§ ass newroot = ensureEditable((Node) newroot.array[0]))
                (§ ass newshift -= 5)
            )
            (§ ass root = newroot)
            (§ ass shift = newshift)
            (§ ass --cnt)
            (§ ass tail = newtail)
            (§ return (§ expr this))
        )

        #_private
        (§ method Node popTail(int level, Node node)
            (§ ass node = ensureEditable(node))
            (§ let int subidx = ((cnt - 2) >>> level) & 0x01f)
            (§ if (level > 5))
            (§
                (§ let Node newchild = popTail(level - 5, (Node) node.array[subidx]))
                (§ if (newchild == nil && subidx == 0))
                (§
                    (§ return (§ expr nil))
                )
                (§ else )
                (§
                    (§ let Node ret = node)
                    (§ ass ret.array[subidx] = newchild)
                    (§ return (§ expr ret))
                )
            )
            (§ elseif (subidx == 0))
            (§
                (§ return (§ expr nil))
            )
            (§ else )
            (§
                (§ let Node ret = node)
                (§ ass ret.array[subidx] = nil)
                (§ return (§ expr ret))
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

#_public
(class-ns ProxyHandler (§ implements InvocationHandler)
    ;; method-name-string->fn
    #_final
    (§ field IPersistentMap fns)

    #_public
    (§ method ProxyHandler(IPersistentMap fns)
        (§ ass this.fns = fns)
    )

    #_public
    (§ method Object invoke(Object proxy, Method method, Object[] args) (§ throws Throwable)
        (§ let Class rt = method.getReturnType())
        (§ let IFn fn = (IFn) fns.valAt(method.getName()))
        (§ if (fn == nil))
        (§
            (§ if (rt == Void.TYPE))
            (§
                (§ return (§ expr nil))
            )
            (§ elseif (method.getName().equals("equals")))
            (§
                (§ return (§ expr (proxy == args[0])))
            )
            (§ elseif (method.getName().equals("hashCode")))
            (§
                (§ return (§ expr System.identityHashCode(proxy)))
            )
            (§ elseif (method.getName().equals("toString")))
            (§
                (§ return (§ expr "Proxy: " + System.identityHashCode(proxy)))
            )
            (§ throw new UnsupportedOperationException())
        )
        (§ let Object ret = fn.applyTo(ArraySeq.create(args)))
        (§ if (rt == Void.TYPE))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (rt.isPrimitive()))
        (§
            (§ if (rt == Character.TYPE))
            (§
                (§ return (§ expr ret))
            )
            (§ elseif (rt == Integer.TYPE))
            (§
                (§ return (§ expr ((Number) ret).intValue()))
            )
            (§ elseif (rt == Long.TYPE))
            (§
                (§ return (§ expr ((Number) ret).longValue()))
            )
            (§ elseif (rt == Float.TYPE))
            (§
                (§ return (§ expr ((Number) ret).floatValue()))
            )
            (§ elseif (rt == Double.TYPE))
            (§
                (§ return (§ expr ((Number) ret).doubleValue()))
            )
            (§ elseif (rt == Boolean.TYPE && !(ret instanceof Boolean)))
            (§
                (§ return (§ expr (ret == nil) ? Boolean.FALSE :or Boolean.TRUE))
            )
            (§ elseif (rt == Byte.TYPE))
            (§
                (§ return (§ expr (byte) ((Number) ret).intValue()))
            )
            (§ elseif (rt == Short.TYPE))
            (§
                (§ return (§ expr (short) ((Number) ret).intValue()))
            )
        )
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
#_public
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    #_private
    #_static
    #_final
    (§ field int CHUNK_SIZE = 32)

    ;; Invariants guarantee this is never an "empty" seq
    #_final
    (§ field Object end)
    #_final
    (§ field Object start)
    #_final
    (§ field Object step)
    #_final
    (§ field BoundsCheck boundsCheck)

    #_private
    #_volatile
    (§ field IChunk _chunk) ;; lazy
    #_private
    #_volatile
    (§ field ISeq _chunkNext) ;; lazy
    #_private
    #_volatile
    (§ field ISeq _next) ;; cached

    #_private
    #_static
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(Object val))
    )

    #_private
    #_static
    (§ method BoundsCheck positiveStep(final Object end)
        (§ return (§ expr new BoundsCheck()
        (§ inner
            #_public
            (§ method boolean exceededBounds(Object val)
                (§ return (§ expr Numbers.gte(val, end)))
            )
        )))
    )

    #_private
    #_static
    (§ method BoundsCheck negativeStep(final Object end)
        (§ return (§ expr new BoundsCheck()
        (§ inner
            #_public
            (§ method boolean exceededBounds(Object val)
                (§ return (§ expr Numbers.lte(val, end)))
            )
        )))
    )

    #_private
    (§ method Range(Object start, Object end, Object step, BoundsCheck boundsCheck)
        (§ ass this.end = end)
        (§ ass this.start = start)
        (§ ass this.step = step)
        (§ ass this.boundsCheck = boundsCheck)
    )

    #_private
    (§ method Range(Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
        (§ ass this.end = end)
        (§ ass this.start = start)
        (§ ass this.step = step)
        (§ ass this.boundsCheck = boundsCheck)
        (§ ass this._chunk = chunk)
        (§ ass this._chunkNext = chunkNext)
    )

    #_private
    (§ method Range(IPersistentMap meta, Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
        (§ super(meta))
        (§ ass this.end = end)
        (§ ass this.start = start)
        (§ ass this.step = step)
        (§ ass this.boundsCheck = boundsCheck)
        (§ ass this._chunk = chunk)
        (§ ass this._chunkNext = chunkNext)
    )

    #_public
    #_static
    (§ method ISeq create(Object end)
        (§ if (Numbers.isPos(end)))
        (§
            (§ return (§ expr new Range(0, end, 1, positiveStep(end))))
        )
        (§ return (§ expr PersistentList.EMPTY))
    )

    #_public
    #_static
    (§ method ISeq create(Object start, Object end)
        (§ return (§ expr create(start, end, 1)))
    )

    #_public
    #_static
    (§ method ISeq create(final Object start, Object end, Object step)
        (§ if ((Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end)))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ if (Numbers.isZero(step)))
        (§
            (§ return (§ expr Repeat.create(start)))
        )
        (§ return (§ expr new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end))))
    )

    #_public
    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (meta == _meta))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext)))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr start))
    )

    #_public
    (§ method void forceChunk()
        (§ if (_chunk != nil))
        (§
            (§ return (§ expr ))
        )

        (§ let Object[] arr = new Object[CHUNK_SIZE])
        (§ let int n = 0)
        (§ let Object val = start)
        (§ while (n < CHUNK_SIZE))
        (§
            (§ ass arr[n++] = val)
            (§ ass val = Numbers.addP(val, step))
            (§ if (boundsCheck.exceededBounds(val)))
            (§
                ;; partial last chunk
                (§ ass _chunk = new ArrayChunk(arr, 0, n))
                (§ return (§ expr ))
            )
        )

        ;; full last chunk
        (§ if (boundsCheck.exceededBounds(val)))
        (§
            (§ ass _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
            (§ return (§ expr ))
        )

        ;; full intermediate chunk
        (§ ass _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
        (§ ass _chunkNext = new Range(val, end, step, boundsCheck))
    )

    #_public
    (§ method ISeq next()
        (§ if (_next != nil))
        (§
            (§ return (§ expr _next))
        )

        (§ call forceChunk())
        (§ if (_chunk.count() > 1))
        (§
            (§ let IChunk smallerChunk = _chunk.dropFirst())
            (§ ass _next = new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext))
            (§ return (§ expr _next))
        )
        (§ return (§ expr chunkedNext()))
    )

    #_public
    (§ method IChunk chunkedFirst()
        (§ call forceChunk())
        (§ return (§ expr _chunk))
    )

    #_public
    (§ method ISeq chunkedNext()
        (§ return (§ expr chunkedMore().seq()))
    )

    #_public
    (§ method ISeq chunkedMore()
        (§ call forceChunk())
        (§ if (_chunkNext == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _chunkNext))
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ let Object acc = start)
        (§ let Number i = Numbers.addP(start, step))
        (§ while (!boundsCheck.exceededBounds(i)))
        (§
            (§ ass acc = f.invoke(acc, i))
            (§ if (RT.isReduced(acc)))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            (§ ass i = Numbers.addP(i, step))
        )
        (§ return (§ expr acc))
    )

    #_public
    (§ method Object reduce(IFn f, Object val)
        (§ let Object acc = val)
        (§ let Object i = start)
        (§ while (!boundsCheck.exceededBounds(i)))
        (§
            (§ ass acc = f.invoke(acc, i))
            (§ if (RT.isReduced(acc)))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            (§ ass i = Numbers.addP(i, step))
        )
        (§ return (§ expr acc))
    )

    #_public
    (§ method Iterator iterator()
        (§ return (§ expr new RangeIterator()))
    )

    #_private
    (class-ns RangeIterator (§ implements Iterator)
        #_private
        (§ field Object next)

        #_public
        (§ method RangeIterator()
            (§ ass this.next = start)
        )

        #_public
        (§ method boolean hasNext()
            (§ return (§ expr (!boundsCheck.exceededBounds(next))))
        )

        #_public
        (§ method Object next()
            (§ if (hasNext()))
            (§
                (§ let Object ret = next)
                (§ ass next = Numbers.addP(next, step))
                (§ return (§ expr ret))
            )
            (§ else )
            (§
                (§ throw new NoSuchElementException())
            )
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

#_public
(class-ns Ratio (§ extends Number) (§ implements Comparable)
    #_final
    #_public
    (§ field BigInteger numerator)
    #_final
    #_public
    (§ field BigInteger denominator)

    #_public
    (§ method Ratio(BigInteger numerator, BigInteger denominator)
        (§ ass this.numerator = numerator)
        (§ ass this.denominator = denominator)
    )

    #_public
    (§ method boolean equals(Object arg0)
        (§ return (§ expr (arg0 != nil && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator))))
    )

    #_public
    (§ method int hashCode()
        (§ return (§ expr numerator.hashCode() :xor denominator.hashCode()))
    )

    #_public
    (§ method String toString()
        (§ return (§ expr numerator.toString() + "/" + denominator.toString()))
    )

    #_public
    (§ method int intValue()
        (§ return (§ expr (int) doubleValue()))
    )

    #_public
    (§ method long longValue()
        (§ return (§ expr bigIntegerValue().longValue()))
    )

    #_public
    (§ method float floatValue()
        (§ return (§ expr (float)doubleValue()))
    )

    #_public
    (§ method double doubleValue()
        (§ return (§ expr decimalValue(MathContext.DECIMAL64).doubleValue()))
    )

    #_public
    (§ method BigDecimal decimalValue()
        (§ return (§ expr decimalValue(MathContext.UNLIMITED)))
    )

    #_public
    (§ method BigDecimal decimalValue(MathContext mc)
        (§ let BigDecimal numerator = new BigDecimal(this.numerator))
        (§ let BigDecimal denominator = new BigDecimal(this.denominator))

        (§ return (§ expr numerator.divide(denominator, mc)))
    )

    #_public
    (§ method BigInteger bigIntegerValue()
        (§ return (§ expr numerator.divide(denominator)))
    )

    #_public
    (§ method int compareTo(Object o)
        (§ let Number other = (Number)o)
        (§ return (§ expr Numbers.compare(this, other)))
    )
)
)

(java-ns cloiure.lang.ReaderConditional

#_public
(class-ns ReaderConditional (§ implements ILookup)
    #_public
    #_static
    #_final
    (§ field Keyword FORM_KW = Keyword.intern("form"))
    #_public
    #_static
    #_final
    (§ field Keyword SPLICING_KW = Keyword.intern("splicing?"))

    #_public
    #_final
    (§ field Object form)
    #_public
    #_final
    (§ field Boolean splicing)

    #_public
    #_static
    (§ method ReaderConditional create(Object form, boolean splicing)
        (§ return (§ expr new ReaderConditional(form, splicing)))
    )

    #_private
    (§ method ReaderConditional(Object form, boolean splicing)
        (§ ass this.form = form)
        (§ ass this.splicing = splicing)
    )

    #_public
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    (§ method Object valAt(Object key, Object notFound)
        (§ if (FORM_KW.equals(key)))
        (§
            (§ return (§ expr this.form))
        )
        (§ elseif (SPLICING_KW.equals(key)))
        (§
            (§ return (§ expr this.splicing))
        )
        (§ else )
        (§
            (§ return (§ expr notFound))
        )
    )

    (§ anno @Override)
    #_public
    (§ method boolean equals(Object o)
        (§ if (this == o))
        (§
            (§ return (§ expr true))
        )
        (§ if (o == nil || getClass() != o.getClass()))
        (§
            (§ return (§ expr false))
        )

        (§ let ReaderConditional that = (ReaderConditional) o)

        (§ if ((form != nil) ? !form.equals(that.form) :or that.form != nil))
        (§
            (§ return (§ expr false))
        )
        (§ if ((splicing != nil) ? !splicing.equals(that.splicing) :or that.splicing != nil))
        (§
            (§ return (§ expr false))
        )
        (§ return (§ expr true))
    )

    (§ anno @Override)
    #_public
    (§ method int hashCode()
        (§ let int result = Util.hash(form))
        (§ ass result = 31 * result + Util.hash(splicing))
        (§ return (§ expr result))
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

#_public
#_final
(class-ns RecordIterator (§ implements Iterator)
    (§ field int i = 0)
    #_final
    (§ field int basecnt)
    #_final
    (§ field ILookup rec)
    #_final
    (§ field IPersistentVector basefields)
    #_final
    (§ field Iterator extmap)

    #_public
    (§ method RecordIterator(ILookup rec, IPersistentVector basefields, Iterator extmap)
        (§ ass this.rec = rec)
        (§ ass this.basefields = basefields)
        (§ ass this.basecnt = basefields.count())
        (§ ass this.extmap = extmap)
    )

    #_public
    (§ method boolean hasNext()
        (§ if (i < basecnt))
        (§
            (§ return (§ expr true))
        )
        (§ else )
        (§
            (§ return (§ expr extmap.hasNext()))
        )
    )

    #_public
    (§ method Object next()
        (§ if (i < basecnt))
        (§
            (§ let Object k = basefields.nth(i))
            (§ ass i++)
            (§ return (§ expr MapEntry.create(k, rec.valAt(k))))
        )
        (§ else )
        (§
            (§ return (§ expr extmap.next()))
        )
    )

    #_public
    (§ method void remove()
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.Reduced

#_public
#_final
(class-ns Reduced (§ implements IDeref)
    (§ field Object val)

    #_public
    (§ method Reduced(Object val)
        (§ ass this.val = val)
    )

    #_public
    (§ method Object deref()
        (§ return (§ expr val))
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

#_public
(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    #_public
    (§ method int compareTo(Ref ref)
        (§ if (this.id == ref.id))
        (§
            (§ return (§ expr 0))
        )
        (§ elseif (this.id < ref.id))
        (§
            (§ return (§ expr -1))
        )
        (§ else )
        (§
            (§ return (§ expr 1))
        )
    )

    #_public
    (§ method int getMinHistory()
        (§ return (§ expr minHistory))
    )

    #_public
    (§ method Ref setMinHistory(int minHistory)
        (§ ass this.minHistory = minHistory)
        (§ return (§ expr this))
    )

    #_public
    (§ method int getMaxHistory()
        (§ return (§ expr maxHistory))
    )

    #_public
    (§ method Ref setMaxHistory(int maxHistory)
        (§ ass this.maxHistory = maxHistory)
        (§ return (§ expr this))
    )

    #_public
    #_static
    (class-ns TVal
        (§ field Object val)
        (§ field long point)
        (§ field TVal prior)
        (§ field TVal next)

        (§ method TVal(Object val, long point, TVal prior)
            (§ ass this.val = val)
            (§ ass this.point = point)
            (§ ass this.prior = prior)
            (§ ass this.next = prior.next)
            (§ ass this.prior.next = this)
            (§ ass this.next.prior = this)
        )

        (§ method TVal(Object val, long point)
            (§ ass this.val = val)
            (§ ass this.point = point)
            (§ ass this.next = this)
            (§ ass this.prior = this)
        )
    )

    (§ field TVal tvals)
    #_final
    (§ field AtomicInteger faults)
    #_final
    (§ field ReentrantReadWriteLock lock)
    (§ field LockingTransaction.Info tinfo)
    #_final
    (§ field long id)

    #_volatile
    (§ field int minHistory = 0)
    #_volatile
    (§ field int maxHistory = 10)

    #_static
    #_final
    (§ field AtomicLong ids = new AtomicLong())

    #_public
    (§ method Ref(Object initVal)
        (§ this(initVal, nil))
    )

    #_public
    (§ method Ref(Object initVal, IPersistentMap meta)
        (§ super(meta))
        (§ ass this.id = ids.getAndIncrement())
        (§ ass this.faults = new AtomicInteger())
        (§ ass this.lock = new ReentrantReadWriteLock())
        (§ ass tvals = new TVal(initVal, 0))
    )

    ;; the latest val

    ;; ok out of transaction
    (§ method Object currentVal()
        (§ try )
        (§
            (§ call lock.readLock().lock())
            (§ if (tvals != nil))
            (§
                (§ return (§ expr tvals.val))
            )
            (§ throw new IllegalStateException(this.toString() + " is unbound."))
        )
        (§ finally )
        (§
            (§ call lock.readLock().unlock())
        )
    )

    #_public
    (§ method Object deref()
        (§ let LockingTransaction t = LockingTransaction.getRunning())
        (§ if (t == nil))
        (§
            (§ return (§ expr currentVal()))
        )
        (§ return (§ expr t.doGet(this)))
    )

    #_public
    (§ method Object set(Object val)
        (§ return (§ expr LockingTransaction.getEx().doSet(this, val)))
    )

    #_public
    (§ method Object commute(IFn fn, ISeq args)
        (§ return (§ expr LockingTransaction.getEx().doCommute(this, fn, args)))
    )

    #_public
    (§ method Object alter(IFn fn, ISeq args)
        (§ let LockingTransaction t = LockingTransaction.getEx())
        (§ return (§ expr t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args)))))
    )

    #_public
    (§ method void touch()
        (§ call LockingTransaction.getEx().doEnsure(this))
    )

    (§ method boolean isBound()
        (§ try )
        (§
            (§ call lock.readLock().lock())
            (§ return (§ expr (tvals != nil)))
        )
        (§ finally )
        (§
            (§ call lock.readLock().unlock())
        )
    )

    #_public
    (§ method void trimHistory()
        (§ try )
        (§
            (§ call lock.writeLock().lock())
            (§ if (tvals != nil))
            (§
                (§ ass tvals.next = tvals)
                (§ ass tvals.prior = tvals)
            )
        )
        (§ finally )
        (§
            (§ call lock.writeLock().unlock())
        )
    )

    #_public
    (§ method int getHistoryCount()
        (§ try )
        (§
            (§ call lock.writeLock().lock())
            (§ return (§ expr histCount()))
        )
        (§ finally )
        (§
            (§ call lock.writeLock().unlock())
        )
    )

    (§ method int histCount()
        (§ if (tvals == nil))
        (§
            (§ return (§ expr 0))
        )
        (§ else )
        (§
            (§ let int count = 0)
            (§ for (TVal tv = tvals.next tv != tvals tv = tv.next))
            (§
                (§ ass count++)
            )
            (§ return (§ expr count))
        )
    )

    #_final
    #_public
    (§ method IFn fn()
        (§ return (§ expr (IFn) deref()))
    )

    #_public
    (§ method Object call()
        (§ return (§ expr invoke()))
    )

    #_public
    (§ method void run()
        (§ call invoke())
    )

    #_public
    (§ method Object invoke()
        (§ return (§ expr fn().invoke()))
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ return (§ expr fn().invoke(arg1)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2)
        (§ return (§ expr fn().invoke(arg1, arg2)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ return (§ expr fn().invoke(arg1, arg2, arg3)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
          #_arg arg16)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
          #_arg arg16, arg17)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
          #_arg arg16, arg17, arg18)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
          #_arg arg16, arg17, arg18, arg19)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
          #_arg arg16, arg17, arg18, arg19, arg20)))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
      #_arg Object... args))
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
          #_arg arg16, arg17, arg18, arg19, arg20, args)))
    )

    #_public
    (§ method Object applyTo(ISeq arglist)
        (§ return (§ expr AFn.applyToHelper(this, arglist)))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_public
(class-ns Reflector
    #_public
    #_static
    (§ method Object invokeInstanceMethod(Object target, String methodName, Object[] args)
        (§ let Class c = target.getClass())
        (§ let List methods = getMethods(c, args.length, methodName, false))
        (§ return (§ expr invokeMatchingMethod(methodName, methods, target, args)))
    )

    #_private
    #_static
    (§ method Throwable getCauseOrElse(Exception e)
        (§ if (e.getCause() != nil))
        (§
            (§ return (§ expr e.getCause()))
        )
        (§ return (§ expr e))
    )

    #_private
    #_static
    (§ method RuntimeException throwCauseOrElseException(Exception e)
        (§ if (e.getCause() != nil))
        (§
            (§ throw Util.sneakyThrow(e.getCause()))
        )
        (§ throw Util.sneakyThrow(e))
    )

    #_private
    #_static
    (§ method String noMethodReport(String methodName, Object target)
        (§ return (§ expr "No matching method found: " + methodName + ((target == nil) ? "" :or " for " + target.getClass())))
    )

    #_static
    (§ method Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
        (§ let Method m = nil)
        (§ let Object[] boxedArgs = nil)
        (§ if (methods.isEmpty()))
        (§
            (§ throw new IllegalArgumentException(noMethodReport(methodName, target)))
        )
        (§ elseif (methods.size() == 1))
        (§
            (§ ass m = (Method) methods.get(0))
            (§ ass boxedArgs = boxArgs(m.getParameterTypes(), args))
        )
        (§ else ) ;; overloaded w/same arity
        (§
            (§ let Method foundm = nil)
            (§ for (Iterator i = methods.iterator() i.hasNext() ))
            (§
                (§ ass m = (Method) i.next())

                (§ let Class[] params = m.getParameterTypes())
                (§ if (isCongruent(params, args)))
                (§
                    (§ if (foundm == nil || Compiler.subsumes(params, foundm.getParameterTypes())))
                    (§
                        (§ ass foundm = m)
                        (§ ass boxedArgs = boxArgs(params, args))
                    )
                )
            )
            (§ ass m = foundm)
        )
        (§ if (m == nil))
        (§
            (§ throw new IllegalArgumentException(noMethodReport(methodName, target)))
        )

        (§ if (!Modifier.isPublic(m.getDeclaringClass().getModifiers())))
        (§
            ;; public method of non-public class, try to find it in hierarchy
            (§ let Method oldm = m)
            (§ ass m = getAsMethodOfPublicBase(target.getClass(), m))
            (§ if (m == nil))
            (§
                (§ throw new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString()))
            )
        )
        (§ try )
        (§
            (§ return (§ expr prepRet(m.getReturnType(), m.invoke(target, boxedArgs))))
        )
        (§ catch (Exception e))
        (§
            (§ throw Util.sneakyThrow(getCauseOrElse(e)))
        )
    )

    #_public
    #_static
    (§ method Method getAsMethodOfPublicBase(Class c, Method m)
        (§ for (Class iface :in c.getInterfaces()))
        (§
            (§ for (Method im :in iface.getMethods()))
            (§
                (§ if (isMatch(im, m)))
                (§
                    (§ return (§ expr im))
                )
            )
        )
        (§ let Class sc = c.getSuperclass())
        (§ if (sc == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ for (Method scm :in sc.getMethods()))
        (§
            (§ if (isMatch(scm, m)))
            (§
                (§ return (§ expr scm))
            )
        )
        (§ return (§ expr getAsMethodOfPublicBase(sc, m)))
    )

    #_public
    #_static
    (§ method boolean isMatch(Method lhs, Method rhs)
        (§ if (!lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers())))
        (§
            (§ return (§ expr false))
        )

        (§ let Class[] types1 = lhs.getParameterTypes())
        (§ let Class[] types2 = rhs.getParameterTypes())
        (§ if (types1.length != types2.length))
        (§
            (§ return (§ expr false))
        )

        (§ let boolean match = true)
        (§ for (int i = 0 i < types1.length ++i))
        (§
            (§ if (!types1[i].isAssignableFrom(types2[i])))
            (§
                (§ ass match = false)
                (§ break )
            )
        )
        (§ return (§ expr match))
    )

    #_public
    #_static
    (§ method Object invokeConstructor(Class c, Object[] args)
        (§ try )
        (§
            (§ let Constructor[] allctors = c.getConstructors())
            (§ let ArrayList ctors = new ArrayList())
            (§ for (int i = 0 i < allctors.length i++))
            (§
                (§ let Constructor ctor = allctors[i])
                (§ if (ctor.getParameterTypes().length == args.length))
                (§
                    (§ call ctors.add(ctor))
                )
            )
            (§ if (ctors.isEmpty()))
            (§
                (§ throw new IllegalArgumentException("No matching ctor found for " + c))
            )
            (§ elseif (ctors.size() == 1))
            (§
                (§ let Constructor ctor = (Constructor) ctors.get(0))
                (§ return (§ expr ctor.newInstance(boxArgs(ctor.getParameterTypes(), args))))
            )
            (§ else ) ;; overloaded w/same arity
            (§
                (§ for (Iterator iterator = ctors.iterator() iterator.hasNext() ))
                (§
                    (§ let Constructor ctor = (Constructor) iterator.next())
                    (§ let Class[] params = ctor.getParameterTypes())
                    (§ if (isCongruent(params, args)))
                    (§
                        (§ let Object[] boxedArgs = boxArgs(params, args))
                        (§ return (§ expr ctor.newInstance(boxedArgs)))
                    )
                )
                (§ throw new IllegalArgumentException("No matching ctor found for " + c))
            )
        )
        (§ catch (Exception e))
        (§
            (§ throw Util.sneakyThrow(getCauseOrElse(e)))
        )
    )

    #_public
    #_static
    (§ method Object invokeStaticMethodVariadic(String className, String methodName, Object... args)
        (§ return (§ expr invokeStaticMethod(className, methodName, args)))
    )

    #_public
    #_static
    (§ method Object invokeStaticMethod(String className, String methodName, Object[] args)
        (§ let Class c = RT.classForName(className))
        (§ return (§ expr invokeStaticMethod(c, methodName, args)))
    )

    #_public
    #_static
    (§ method Object invokeStaticMethod(Class c, String methodName, Object[] args)
        (§ if (methodName.equals("new")))
        (§
            (§ return (§ expr invokeConstructor(c, args)))
        )
        (§ let List methods = getMethods(c, args.length, methodName, true))
        (§ return (§ expr invokeMatchingMethod(methodName, methods, nil, args)))
    )

    #_public
    #_static
    (§ method Object getStaticField(String className, String fieldName)
        (§ let Class c = RT.classForName(className))
        (§ return (§ expr getStaticField(c, fieldName)))
    )

    #_public
    #_static
    (§ method Object getStaticField(Class c, String fieldName)
        (§ let Field f = getField(c, fieldName, true))
        (§ if (f != nil))
        (§
            (§ try )
            (§
                (§ return (§ expr prepRet(f.getType(), f.get(nil))))
            )
            (§ catch (IllegalAccessException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c))
    )

    #_public
    #_static
    (§ method Object setStaticField(String className, String fieldName, Object val)
        (§ let Class c = RT.classForName(className))
        (§ return (§ expr setStaticField(c, fieldName, val)))
    )

    #_public
    #_static
    (§ method Object setStaticField(Class c, String fieldName, Object val)
        (§ let Field f = getField(c, fieldName, true))
        (§ if (f != nil))
        (§
            (§ try )
            (§
                (§ call f.set(nil, boxArg(f.getType(), val)))
            )
            (§ catch (IllegalAccessException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ return (§ expr val))
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c))
    )

    #_public
    #_static
    (§ method Object getInstanceField(Object target, String fieldName)
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, fieldName, false))
        (§ if (f != nil))
        (§
            (§ try )
            (§
                (§ return (§ expr prepRet(f.getType(), f.get(target))))
            )
            (§ catch (IllegalAccessException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass()))
    )

    #_public
    #_static
    (§ method Object setInstanceField(Object target, String fieldName, Object val)
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, fieldName, false))
        (§ if (f != nil))
        (§
            (§ try )
            (§
                (§ call f.set(target, boxArg(f.getType(), val)))
            )
            (§ catch (IllegalAccessException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ return (§ expr val))
        )
        (§ throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass()))
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    #_public
    #_static
    (§ method Object invokeNoArgInstanceMember(Object target, String name)
        (§ return (§ expr invokeNoArgInstanceMember(target, name, false)))
    )

    #_public
    #_static
    (§ method Object invokeNoArgInstanceMember(Object target, String name, boolean requireField)
        (§ let Class c = target.getClass())

        (§ if (requireField))
        (§
            (§ let Field f = getField(c, name, false))
            (§ if (f != nil))
            (§
                (§ return (§ expr getInstanceField(target, name)))
            )
            (§ else )
            (§
                (§ throw new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass()))
            )
        )
        (§ else )
        (§
            (§ let List meths = getMethods(c, 0, name, false))
            (§ if (meths.size() > 0))
            (§
                (§ return (§ expr invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY)))
            )
            (§ else )
            (§
                (§ return (§ expr getInstanceField(target, name)))
            )
        )
    )

    #_public
    #_static
    (§ method Object invokeInstanceMember(Object target, String name)
        ;; check for field first
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, name, false))
        (§ if (f != nil)) ;; field get
        (§
            (§ try )
            (§
                (§ return (§ expr prepRet(f.getType(), f.get(target))))
            )
            (§ catch (IllegalAccessException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )
        (§ return (§ expr invokeInstanceMethod(target, name, RT.EMPTY_ARRAY)))
    )

    #_public
    #_static
    (§ method Object invokeInstanceMember(String name, Object target, Object arg1)
        ;; check for field first
        (§ let Class c = target.getClass())
        (§ let Field f = getField(c, name, false))
        (§ if (f != nil)) ;; field set
        (§
            (§ try )
            (§
                (§ call f.set(target, boxArg(f.getType(), arg1)))
            )
            (§ catch (IllegalAccessException e))
            (§
                (§ throw Util.sneakyThrow(e))
            )
            (§ return (§ expr arg1))
        )
        (§ return (§ expr invokeInstanceMethod(target, name, new Object[] (§ arg1 ))))
    )

    #_public
    #_static
    (§ method Object invokeInstanceMember(String name, Object target, Object... args)
        (§ return (§ expr invokeInstanceMethod(target, name, args)))
    )

    #_static
    #_public
    (§ method Field getField(Class c, String name, boolean getStatics)
        (§ let Field[] allfields = c.getFields())
        (§ for (int i = 0 i < allfields.length i++))
        (§
            (§ if (name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics))
            (§
                (§ return (§ expr allfields[i]))
            )
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method List getMethods(Class c, int arity, String name, boolean getStatics)
        (§ let Method[] allmethods = c.getMethods())
        (§ let ArrayList methods = new ArrayList())
        (§ let ArrayList bridgeMethods = new ArrayList())
        (§ for (int i = 0 i < allmethods.length i++))
        (§
            (§ let Method method = allmethods[i])
            (§ if (name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity))
            (§
                (§ try )
                (§
                    (§ if (method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method)))
                    (§
                        (§ call bridgeMethods.add(method))
                    )
                    (§ else )
                    (§
                        (§ call methods.add(method))
                    )
                )
                (§ catch (NoSuchMethodException e))
                (§
                )
            )
        )

        (§ if (methods.isEmpty()))
        (§
            (§ call methods.addAll(bridgeMethods))
        )
        (§ if (!getStatics && c.isInterface()))
        (§
            (§ ass allmethods = Object.class.getMethods())
            (§ for (int i = 0 i < allmethods.length i++))
            (§
                (§ if (name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity))
                (§
                    (§ call methods.add(allmethods[i]))
                )
            )
        )
        (§ return (§ expr methods))
    )

    #_static
    (§ method Object boxArg(Class paramType, Object arg)
        (§ if (!paramType.isPrimitive()))
        (§
            (§ return (§ expr paramType.cast(arg)))
        )
        (§ elseif (paramType == boolean.class))
        (§
            (§ return (§ expr Boolean.class.cast(arg)))
        )
        (§ elseif (paramType == char.class))
        (§
            (§ return (§ expr Character.class.cast(arg)))
        )
        (§ elseif (arg instanceof Number))
        (§
            (§ let Number n = (Number) arg)
            (§ if (paramType == int.class))
            (§
                (§ return (§ expr n.intValue()))
            )
            (§ elseif (paramType == float.class))
            (§
                (§ return (§ expr n.floatValue()))
            )
            (§ elseif (paramType == double.class))
            (§
                (§ return (§ expr n.doubleValue()))
            )
            (§ elseif (paramType == long.class))
            (§
                (§ return (§ expr n.longValue()))
            )
            (§ elseif (paramType == short.class))
            (§
                (§ return (§ expr n.shortValue()))
            )
            (§ elseif (paramType == byte.class))
            (§
                (§ return (§ expr n.byteValue()))
            )
        )
        (§ throw new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName()))
    )

    #_static
    (§ method Object[] boxArgs(Class[] params, Object[] args)
        (§ if (params.length == 0))
        (§
            (§ return (§ expr nil))
        )
        (§ let Object[] ret = new Object[params.length])
        (§ for (int i = 0 i < params.length i++))
        (§
            (§ let Object arg = args[i])
            (§ let Class paramType = params[i])
            (§ ass ret[i] = boxArg(paramType, arg))
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method boolean paramArgTypeMatch(Class paramType, Class argType)
        (§ if (argType == nil))
        (§
            (§ return (§ expr !paramType.isPrimitive()))
        )
        (§ if (paramType == argType || paramType.isAssignableFrom(argType)))
        (§
            (§ return (§ expr true))
        )
        (§ if (paramType == int.class))
        (§
            (§ return (§ expr argType == Integer.class
          #_arg || argType == long.class
          #_arg || argType == Long.class
          #_arg || argType == short.class
          #_arg || argType == byte.class))
        )
        (§ elseif (paramType == float.class))
        (§
            (§ return (§ expr argType == Float.class
          #_arg || argType == double.class))
        )
        (§ elseif (paramType == double.class))
        (§
            (§ return (§ expr argType == Double.class
          #_arg || argType == float.class))
        )
        (§ elseif (paramType == long.class))
        (§
            (§ return (§ expr argType == Long.class
          #_arg || argType == int.class
          #_arg || argType == short.class
          #_arg || argType == byte.class))
        )
        (§ elseif (paramType == char.class))
        (§
            (§ return (§ expr argType == Character.class))
        )
        (§ elseif (paramType == short.class))
        (§
            (§ return (§ expr argType == Short.class))
        )
        (§ elseif (paramType == byte.class))
        (§
            (§ return (§ expr argType == Byte.class))
        )
        (§ elseif (paramType == boolean.class))
        (§
            (§ return (§ expr argType == Boolean.class))
        )
        (§ return (§ expr false))
    )

    #_static
    (§ method boolean isCongruent(Class[] params, Object[] args)
        (§ let boolean ret = false)
        (§ if (args == nil))
        (§
            (§ return (§ expr (params.length == 0)))
        )
        (§ if (params.length == args.length))
        (§
            (§ ass ret = true)
            (§ for (int i = 0 ret && i < params.length i++))
            (§
                (§ let Object arg = args[i])
                (§ let Class argType = (arg == nil) ? nil :or arg.getClass())
                (§ let Class paramType = params[i])
                (§ ass ret = paramArgTypeMatch(paramType, argType))
            )
        )
        (§ return (§ expr ret))
    )

    #_public
    #_static
    (§ method Object prepRet(Class c, Object x)
        (§ if (!(c.isPrimitive() || c == Boolean.class)))
        (§
            (§ return (§ expr x))
        )
        (§ if (x instanceof Boolean))
        (§
            (§ return (§ expr ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE))
        )
        (§ return (§ expr x))
    )
)
)

(java-ns cloiure.lang.Repeat

#_public
(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    #_private
    #_static
    #_final
    (§ field long INFINITE = -1)

    #_private
    #_final
    (§ field long count) ;; always INFINITE or >0
    #_private
    #_final
    (§ field Object val)
    #_private
    #_volatile
    (§ field ISeq _next) ;; cached

    #_private
    (§ method Repeat(long count, Object val)
        (§ ass this.count = count)
        (§ ass this.val = val)
    )

    #_private
    (§ method Repeat(IPersistentMap meta, long count, Object val)
        (§ super(meta))
        (§ ass this.count = count)
        (§ ass this.val = val)
    )

    #_public
    #_static
    (§ method Repeat create(Object val)
        (§ return (§ expr new Repeat(INFINITE, val)))
    )

    #_public
    #_static
    (§ method ISeq create(long count, Object val)
        (§ if (count <= 0))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr new Repeat(count, val)))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr val))
    )

    #_public
    (§ method ISeq next()
        (§ if (_next == nil))
        (§
            (§ if (count > 1))
            (§
                (§ ass _next = new Repeat(count - 1, val))
            )
            (§ elseif (count == INFINITE))
            (§
                (§ ass _next = this)
            )
        )
        (§ return (§ expr _next))
    )

    #_public
    (§ method Repeat withMeta(IPersistentMap meta)
        (§ return (§ expr new Repeat(meta, count, val)))
    )

    #_public
    (§ method Object reduce(IFn f)
        (§ let Object ret = val)
        (§ if (count == INFINITE))
        (§
            (§ while (true))
            (§
                (§ ass ret = f.invoke(ret, val))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
        )
        (§ else )
        (§
            (§ for (long i = 1 i < count i++))
            (§
                (§ ass ret = f.invoke(ret, val))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )
    )

    #_public
    (§ method Object reduce(IFn f, Object start)
        (§ let Object ret = start)
        (§ if (count == INFINITE))
        (§
            (§ while (true))
            (§
                (§ ass ret = f.invoke(ret, val))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
        )
        (§ else )
        (§
            (§ for (long i = 0 i < count i++))
            (§
                (§ ass ret = f.invoke(ret, val))
                (§ if (RT.isReduced(ret)))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_public
#_abstract
(class-ns RestFn (§ extends AFunction)
    (§ abstract public int getRequiredArity())

    #_protected
    (§ method Object doInvoke(Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object args)
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object arg15, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object arg15, Object arg16, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object arg15, Object arg16, Object arg17, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
      #_arg Object args))
    (§
        (§ return (§ expr nil))
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
      #_arg Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
      #_arg Object arg20, Object args))
    (§
        (§ return (§ expr nil))
    )

    #_public
    (§ method Object applyTo(ISeq args)
        (§ if (RT.boundedLength(args, getRequiredArity()) <= getRequiredArity()))
        (§
            (§ return (§ expr AFn.applyToHelper(this, Util.ret1(args, args = nil))))
        )
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(Util.ret1(args, args = nil))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(args.first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 17)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 18)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 19)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
            (§ case 20)
            (§
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                  #_arg Util.ret1(args.next(), args = nil))))
            )
        )
        (§ return (§ expr throwArity(-1)))
    )

    #_public
    (§ method Object invoke()
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(0)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(1)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(2)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(3)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(4)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(5)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg6, arg6 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(6)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(7)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(8)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil), ArraySeq.create(Util.ret1(arg9, arg9 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(9)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil), ArraySeq.create(Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(10)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(11)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(12)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(13)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg14, arg14 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(14)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg15, arg15 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(15)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg16, arg16 = nil)))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(16)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg17, arg17 = nil)))))
            )
            (§ case 17)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil),
                  #_arg Util.ret1(arg17, arg17 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(17)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 17)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil),
                  #_arg Util.ret1(arg17, arg17 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg18, arg18 = nil)))))
            )
            (§ case 18)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil),
                  #_arg Util.ret1(arg17, arg17 = nil),
                  #_arg Util.ret1(arg18, arg18 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(18)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg ArraySeq.create(
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 17)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil),
                  #_arg Util.ret1(arg17, arg17 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 18)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil),
                  #_arg Util.ret1(arg17, arg17 = nil),
                  #_arg Util.ret1(arg18, arg18 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg19, arg19 = nil)))))
            )
            (§ case 19)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil),
                  #_arg Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil),
                  #_arg Util.ret1(arg5, arg5 = nil),
                  #_arg Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil),
                  #_arg Util.ret1(arg8, arg8 = nil),
                  #_arg Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil),
                  #_arg Util.ret1(arg11, arg11 = nil),
                  #_arg Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil),
                  #_arg Util.ret1(arg14, arg14 = nil),
                  #_arg Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil),
                  #_arg Util.ret1(arg17, arg17 = nil),
                  #_arg Util.ret1(arg18, arg18 = nil),
                  #_arg Util.ret1(arg19, arg19 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(19)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ArraySeq.create(
                      #_arg Util.ret1(arg1, arg1 = nil),
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg2, arg2 = nil),
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil),
                  #_arg Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                      #_arg Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil),
                      #_arg Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil),
                      #_arg Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), ArraySeq.create(Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), ArraySeq.create(Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), ArraySeq.create(Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), ArraySeq.create(Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), ArraySeq.create(Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), ArraySeq.create(Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 17)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), ArraySeq.create(Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 18)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                  #_arg ArraySeq.create(Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 19)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                  #_arg Util.ret1(arg19, arg19 = nil), ArraySeq.create(Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 20)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                  #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil), nil)))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(20)))
            )
        )
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args))
    (§
        (§ switch (getRequiredArity()))
        (§
            (§ case 0)
            (§
                (§ return (§ expr doInvoke(ontoArrayPrepend(args, Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 1)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ontoArrayPrepend(args, Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 2)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), ontoArrayPrepend(args, Util.ret1(arg3, arg3 = nil),
                      #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                      #_arg Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 3)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg ontoArrayPrepend(args, Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                      #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 4)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), ontoArrayPrepend(args, Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 5)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), ontoArrayPrepend(args, Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                      #_arg Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 6)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg ontoArrayPrepend(args, Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 7)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), ontoArrayPrepend(args, Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                      #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                      #_arg Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 8)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), ontoArrayPrepend(args, Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                      #_arg Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 9)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg ontoArrayPrepend(args, Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 10)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), ontoArrayPrepend(args, Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                      #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                      #_arg Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 11)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), ontoArrayPrepend(args, Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                      #_arg Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 12)
            (§
                (§ return (§ expr doInvoke(
                  #_arg Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg ontoArrayPrepend(args, Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 13)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), ontoArrayPrepend(args, Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                      #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                      #_arg Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 14)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), ontoArrayPrepend(args, Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                      #_arg Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 15)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg ontoArrayPrepend(args, Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 16)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), ontoArrayPrepend(args, Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                      #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 17)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), ontoArrayPrepend(args, Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                      #_arg Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 18)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                  #_arg ontoArrayPrepend(args, Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 19)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                  #_arg Util.ret1(arg19, arg19 = nil), ontoArrayPrepend(args, Util.ret1(arg20, arg20 = nil)))))
            )
            (§ case 20)
            (§
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                  #_arg Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                  #_arg Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                  #_arg Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                  #_arg Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                  #_arg Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                  #_arg Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil), ArraySeq.create(args))))
            )
            (§ default )
            (§
                (§ return (§ expr throwArity(21)))
            )
        )
    )

    #_protected
    #_static
    (§ method ISeq ontoArrayPrepend(Object[] array, Object... args)
        (§ let ISeq ret = ArraySeq.create(array))
        (§ for (int i = args.length - 1 i >= 0 --i))
        (§
            (§ ass ret = RT.cons(args[i], ret))
        )
        (§ return (§ expr ret))
    )

    #_protected
    #_static
    (§ method ISeq findKey(Object key, ISeq args)
        (§ while (args != nil))
        (§
            (§ if (key == args.first()))
            (§
                (§ return (§ expr args.next()))
            )
            (§ ass args = RT.next(args))
            (§ ass args = RT.next(args))
        )
        (§ return (§ expr nil))
    )
)
)

(java-ns cloiure.lang.Reversible

#_public
(§ interface Reversible
    (§ abstract ISeq rseq())
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_public
(class-ns RT
    #_static
    #_final
    #_public
    (§ field Boolean T = Boolean.TRUE)
    #_static
    #_final
    #_public
    (§ field Boolean F = Boolean.FALSE)
    #_static
    #_final
    #_public
    (§ field String LOADER_SUFFIX = "__init")

    ;; simple-symbol->class
    #_final
    #_static
    #_public
    (§ field IPersistentMap DEFAULT_IMPORTS = map(
      #_map Symbol.intern("Boolean"), Boolean.class,
      #_map Symbol.intern("Byte"), Byte.class,
      #_map Symbol.intern("Character"), Character.class,
      #_map Symbol.intern("Class"), Class.class,
      #_map Symbol.intern("ClassLoader"), ClassLoader.class,
      #_map Symbol.intern("Compiler"), Compiler.class,
      #_map Symbol.intern("Double"), Double.class,
      #_map Symbol.intern("Enum"), Enum.class,
      #_map Symbol.intern("Float"), Float.class,
      #_map Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
      #_map Symbol.intern("Integer"), Integer.class,
      #_map Symbol.intern("Long"), Long.class,
      #_map Symbol.intern("Math"), Math.class,
      #_map Symbol.intern("Number"), Number.class,
      #_map Symbol.intern("Object"), Object.class,
      #_map Symbol.intern("Package"), Package.class,
      #_map Symbol.intern("Process"), Process.class,
      #_map Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
      #_map Symbol.intern("Runtime"), Runtime.class,
      #_map Symbol.intern("RuntimePermission"), RuntimePermission.class,
      #_map Symbol.intern("SecurityManager"), SecurityManager.class,
      #_map Symbol.intern("Short"), Short.class,
      #_map Symbol.intern("StackTraceElement"), StackTraceElement.class,
      #_map Symbol.intern("StrictMath"), StrictMath.class,
      #_map Symbol.intern("String"), String.class,
      #_map Symbol.intern("StringBuffer"), StringBuffer.class,
      #_map Symbol.intern("StringBuilder"), StringBuilder.class,
      #_map Symbol.intern("System"), System.class,
      #_map Symbol.intern("Thread"), Thread.class,
      #_map Symbol.intern("ThreadGroup"), ThreadGroup.class,
      #_map Symbol.intern("ThreadLocal"), ThreadLocal.class,
      #_map Symbol.intern("Throwable"), Throwable.class,
      #_map Symbol.intern("Void"), Void.class,
      #_map Symbol.intern("Appendable"), Appendable.class,
      #_map Symbol.intern("CharSequence"), CharSequence.class,
      #_map Symbol.intern("Cloneable"), Cloneable.class,
      #_map Symbol.intern("Comparable"), Comparable.class,
      #_map Symbol.intern("Iterable"), Iterable.class,
      #_map Symbol.intern("Readable"), Readable.class,
      #_map Symbol.intern("Runnable"), Runnable.class,
      #_map Symbol.intern("Callable"), Callable.class,
      #_map Symbol.intern("BigInteger"), BigInteger.class,
      #_map Symbol.intern("BigDecimal"), BigDecimal.class,
      #_map Symbol.intern("ArithmeticException"), ArithmeticException.class,
      #_map Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
      #_map Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
      #_map Symbol.intern("ClassCastException"), ClassCastException.class,
      #_map Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
      #_map Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
      #_map Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
      #_map Symbol.intern("Exception"), Exception.class,
      #_map Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
      #_map Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
      #_map Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
      #_map Symbol.intern("IllegalStateException"), IllegalStateException.class,
      #_map Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
      #_map Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
      #_map Symbol.intern("InstantiationException"), InstantiationException.class,
      #_map Symbol.intern("InterruptedException"), InterruptedException.class,
      #_map Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
      #_map Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
      #_map Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
      #_map Symbol.intern("NullPointerException"), NullPointerException.class,
      #_map Symbol.intern("NumberFormatException"), NumberFormatException.class,
      #_map Symbol.intern("RuntimeException"), RuntimeException.class,
      #_map Symbol.intern("SecurityException"), SecurityException.class,
      #_map Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
      #_map Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
      #_map Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
      #_map Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
      #_map Symbol.intern("AssertionError"), AssertionError.class,
      #_map Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
      #_map Symbol.intern("ClassFormatError"), ClassFormatError.class,
      #_map Symbol.intern("Error"), Error.class,
      #_map Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
      #_map Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
      #_map Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
      #_map Symbol.intern("InstantiationError"), InstantiationError.class,
      #_map Symbol.intern("InternalError"), InternalError.class,
      #_map Symbol.intern("LinkageError"), LinkageError.class,
      #_map Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
      #_map Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
      #_map Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
      #_map Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
      #_map Symbol.intern("StackOverflowError"), StackOverflowError.class,
      #_map Symbol.intern("ThreadDeath"), ThreadDeath.class,
      #_map Symbol.intern("UnknownError"), UnknownError.class,
      #_map Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
      #_map Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
      #_map Symbol.intern("VerifyError"), VerifyError.class,
      #_map Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
      #_map Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
      #_map Symbol.intern("Thread$State"), Thread.State.class,
      #_map Symbol.intern("Deprecated"), Deprecated.class,
      #_map Symbol.intern("Override"), Override.class,
      #_map Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    ))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    #_static
    #_public
    (§ field Charset UTF8 = Charset.forName("UTF-8"))

    #_static
    (§ method Object readTrueFalseUnknown(String s)
        (§ if (s.equals("true")))
        (§
            (§ return (§ expr Boolean.TRUE))
        )
        (§ elseif (s.equals("false")))
        (§
            (§ return (§ expr Boolean.FALSE))
        )
        (§ return (§ expr Keyword.intern(nil, "unknown")))
    )

    #_static
    #_public
    #_final
    (§ field Namespace CLOIURE_NS = Namespace.findOrCreate(Symbol.intern("cloiure.core")))
    #_final
    #_static
    #_public
    (§ field Var OUT = Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var IN = Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var ERR = Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic())
    #_final
    #_static
    (§ field Keyword TAG_KEY = Keyword.intern(nil, "tag"))
    #_final
    #_static
    (§ field Keyword CONST_KEY = Keyword.intern(nil, "const"))
    #_final
    #_static
    #_public
    (§ field Var AGENT = Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), nil).setDynamic())
    #_static
    (§ field Object readeval = readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true")))
    #_final
    #_static
    #_public
    (§ field Var READEVAL = Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"),  readeval).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var DEFAULT_DATA_READER_FN = Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var DEFAULT_DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map()))
    #_final
    #_static
    #_public
    (§ field Var SUPPRESS_READ = Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), nil).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var ASSERT = Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic())
    #_final
    #_static
    #_public
    (§ field Var MATH_CONTEXT = Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), nil).setDynamic())
    #_static
    (§ field Keyword LINE_KEY = Keyword.intern(nil, "line"))
    #_static
    (§ field Keyword COLUMN_KEY = Keyword.intern(nil, "column"))
    #_static
    (§ field Keyword FILE_KEY = Keyword.intern(nil, "file"))
    #_static
    (§ field Keyword DECLARED_KEY = Keyword.intern(nil, "declared"))
    #_static
    (§ field Keyword DOC_KEY = Keyword.intern(nil, "doc"))
    #_final
    #_static
    #_public
    (§ field Var USE_CONTEXT_CLASSLOADER = Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic())
    ;; boolean
    #_static
    #_final
    #_public
    (§ field Var UNCHECKED_MATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic())

    #_final
    #_static
    (§ field Symbol LOAD_FILE = Symbol.intern("load-file"))
    #_final
    #_static
    (§ field Symbol IN_NAMESPACE = Symbol.intern("in-ns"))
    #_final
    #_static
    (§ field Symbol NAMESPACE = Symbol.intern("ns"))
    #_static
    #_final
    (§ field Symbol IDENTICAL = Symbol.intern("identical?"))
    #_final
    #_static
    (§ field Var CMD_LINE_ARGS = Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), nil).setDynamic())
    ;; symbol
    #_final
    #_public
    #_static
    (§ field Var CURRENT_NS = Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic())

    #_final
    #_static
    (§ field Var FLUSH_ON_NEWLINE = Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic())
    #_final
    #_static
    (§ field Var PRINT_META = Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic())
    #_final
    #_static
    (§ field Var PRINT_READABLY = Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic())
    #_final
    #_static
    (§ field Var PRINT_DUP = Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic())
    #_final
    #_static
    (§ field Var WARN_ON_REFLECTION = Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic())
    #_final
    #_static
    (§ field Var ALLOW_UNRESOLVED_VARS = Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic())
    #_final
    #_static
    (§ field Var READER_RESOLVER = Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), nil).setDynamic())

    #_final
    #_static
    (§ field Var IN_NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F))
    #_final
    #_static
    (§ field Var NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("ns"), F))
    #_final
    #_static
    (§ field Var FN_LOADER_VAR = Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), nil).setDynamic())
    #_static
    #_final
    (§ field Var PRINT_INITIALIZED = Var.intern(CLOIURE_NS, Symbol.intern("print-initialized")))
    #_static
    #_final
    (§ field Var PR_ON = Var.intern(CLOIURE_NS, Symbol.intern("pr-on")))

    #_final
    #_static
    (§ field IFn inNamespace = new AFn()
    (§ inner
        #_public
        (§ method Object invoke(Object arg1)
            (§ let Symbol nsname = (Symbol) arg1)
            (§ let Namespace ns = Namespace.findOrCreate(nsname))
            (§ call CURRENT_NS.set(ns))
            (§ return (§ expr ns))
        )
    ))

    #_final
    #_static
    (§ field IFn bootNamespace = new AFn()
    (§ inner
        #_public
        (§ method Object invoke(Object __form, Object __env, Object arg1)
            (§ let Symbol nsname = (Symbol) arg1)
            (§ let Namespace ns = Namespace.findOrCreate(nsname))
            (§ call CURRENT_NS.set(ns))
            (§ return (§ expr ns))
        )
    ))

    #_public
    #_static
    (§ method List<String> processCommandLine(String[] args)
        (§ let List<String> arglist = Arrays.asList(args))
        (§ let int split = arglist.indexOf("--"))
        (§ if (split >= 0))
        (§
            (§ call CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length))))
            (§ return (§ expr arglist.subList(0, split)))
        )
        (§ return (§ expr arglist))
    )

    ;; duck typing stderr plays nice with e.g. swank
    #_public
    #_static
    (§ method PrintWriter errPrintWriter()
        (§ let Writer w = (Writer) ERR.deref())
        (§ if (w instanceof PrintWriter))
        (§
            (§ return (§ expr (PrintWriter) w))
        )
        (§ else )
        (§
            (§ return (§ expr new PrintWriter(w)))
        )
    )

    #_static
    #_public
    #_final
    (§ field Object[] EMPTY_ARRAY = new Object[] (§))
    #_static
    #_public
    #_final
    (§ field Comparator DEFAULT_COMPARATOR = new DefaultComparator())

    #_private
    #_static
    #_final
    (class-ns DefaultComparator (§ implements Comparator)
        #_public
        (§ method int compare(Object o1, Object o2)
            (§ return (§ expr Util.compare(o1, o2)))
        )
    )

    #_static
    (§ field AtomicInteger id = new AtomicInteger(1))

    #_static
    #_public
    (§ method void addURL(Object url) (§ throws MalformedURLException)
        (§ let URL u = (url instanceof String) ? (new URL((String) url)) :or (URL) url)
        (§ let ClassLoader ccl = Thread.currentThread().getContextClassLoader())
        (§ if (ccl instanceof DynamicClassLoader))
        (§
            ((DynamicClassLoader)ccl).addURL(u)
        )
        (§ else )
        (§
            (§ throw new IllegalAccessError("Context classloader is not a DynamicClassLoader"))
        )
    )

    #_public
    #_static
    (§ field boolean checkSpecAsserts = Boolean.getBoolean("cloiure.spec.check-asserts"))
    #_public
    #_static
    (§ field boolean instrumentMacros = ! Boolean.getBoolean("cloiure.spec.skip-macros"))
    #_static
    #_volatile
    (§ field boolean CHECK_SPECS = false)

    (§ static )
    (§
        (§ let Keyword arglistskw = Keyword.intern(nil, "arglists"))
        (§ let Symbol namesym = Symbol.intern("name"))
        (§ call OUT.setTag(Symbol.intern("java.io.Writer")))
        (§ call CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace")))
        (§ call AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil")))
        (§ call AGENT.setTag(Symbol.intern("cloiure.lang.Agent")))
        (§ call MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext")))
        (§ let Var nv = Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace))
        (§ call nv.setMacro())
        (§ let Var v)
        (§ ass v = Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace))
        (§ call v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym)))))
        (§ ass v = Var.intern(CLOIURE_NS, LOAD_FILE, new AFn()
        (§ inner
            #_public
            (§ method Object invoke(Object arg1)
                (§ try )
                (§
                    (§ return (§ expr Compiler.loadFile((String) arg1)))
                )
                (§ catch (IOException e))
                (§
                    (§ throw Util.sneakyThrow(e))
                )
            )
        )))
        (§ call v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym)))))
        (§ try )
        (§
            (§ call doInit())
        )
        (§ catch (Exception e))
        (§
            (§ throw Util.sneakyThrow(e))
        )

        (§ ass CHECK_SPECS = RT.instrumentMacros)
    )

    #_static
    #_public
    (§ method Keyword keyword(String ns, String name)
        (§ return (§ expr Keyword.intern((Symbol.intern(ns, name)))))
    )

    #_static
    #_public
    (§ method Var var(String ns, String name)
        (§ return (§ expr Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name))))
    )

    #_static
    #_public
    (§ method Var var(String ns, String name, Object init)
        (§ return (§ expr Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name), init)))
    )

    #_public
    #_static
    (§ method void loadResourceScript(String name) (§ throws IOException)
        (§ call loadResourceScript(name, true))
    )

    #_public
    #_static
    (§ method void maybeLoadResourceScript(String name) (§ throws IOException)
        (§ call loadResourceScript(name, false))
    )

    #_public
    #_static
    (§ method void loadResourceScript(String name, boolean failIfNotFound) (§ throws IOException)
        (§ call loadResourceScript(RT.class, name, failIfNotFound))
    )

    #_public
    #_static
    (§ method void loadResourceScript(Class c, String name) (§ throws IOException)
        (§ call loadResourceScript(c, name, true))
    )

    #_public
    #_static
    (§ method void loadResourceScript(Class c, String name, boolean failIfNotFound) (§ throws IOException)
        (§ let int slash = name.lastIndexOf(\/))
        (§ let String file = (slash >= 0) ? name.substring(slash + 1) :or name)
        (§ let InputStream ins = resourceAsStream(baseLoader(), name))
        (§ if (ins != nil))
        (§
            (§ try )
            (§
                (§ call Compiler.load(new InputStreamReader(ins, UTF8), name, file))
            )
            (§ finally )
            (§
                (§ call ins.close())
            )
        )
        (§ elseif (failIfNotFound))
        (§
            (§ throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + name))
        )
    )

    #_static
    #_public
    (§ method void init()
        (§ call RT.errPrintWriter().println("No need to call RT.init() anymore"))
    )

    #_static
    #_public
    (§ method long lastModified(URL url, String libfile) (§ throws IOException)
        (§ let URLConnection connection = url.openConnection())
        (§ try )
        (§
            (§ if (url.getProtocol().equals("jar")))
            (§
                (§ return (§ expr ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime()))
            )
            (§ else )
            (§
                (§ return (§ expr connection.getLastModified()))
            )
        )
        (§ finally )
        (§
            (§ let InputStream ins = connection.getInputStream())
            (§ if (ins != nil))
            (§
                (§ call ins.close())
            )
        )
    )

    #_static
    (§ method void compile(String cljfile) (§ throws IOException)
        (§ let InputStream ins = resourceAsStream(baseLoader(), cljfile))
        (§ if (ins != nil))
        (§
            (§ try )
            (§
                (§ call Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/"))))
            )
            (§ finally )
            (§
                (§ call ins.close())
            )
        )
        (§ else )
        (§
            (§ throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + cljfile))
        )
    )

    #_static
    #_public
    (§ method void load(String scriptbase) (§ throws IOException, ClassNotFoundException)
        (§ call load(scriptbase, true))
    )

    #_static
    #_public
    (§ method void load(String scriptbase, boolean failIfNotFound) (§ throws IOException, ClassNotFoundException)
        (§ let String classfile = scriptbase + LOADER_SUFFIX + ".class")
        (§ let String cljfile = scriptbase + ".cli")
        (§ let String scriptfile = cljfile)
        (§ let URL classURL = getResource(baseLoader(), classfile))
        (§ let URL cljURL = getResource(baseLoader(), scriptfile))
        (§ if (cljURL == nil))
        (§
            (§ ass scriptfile = scriptbase + ".clic")
            (§ ass cljURL = getResource(baseLoader(), scriptfile))
        )
        (§ let boolean loaded = false)

        (§ if ((classURL != nil && (cljURL == nil || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == nil))
        (§
            (§ try )
            (§
                (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
                      #_map CURRENT_NS, CURRENT_NS.deref(),
                      #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                      #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                )))
                (§ ass loaded = (loadClassForName(scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil))
            )
            (§ finally )
            (§
                (§ call Var.popThreadBindings())
            )
        )
        (§ if (!loaded && cljURL != nil))
        (§
            (§ if (booleanCast(Compiler.COMPILE_FILES.deref())))
            (§
                (§ call compile(scriptfile))
            )
            (§ else )
            (§
                (§ call loadResourceScript(RT.class, scriptfile))
            )
        )
        (§ elseif (!loaded && failIfNotFound))
        (§
            (§ throw new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile, scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or "")))
        )
    )

    #_static
    (§ method void doInit() (§ throws ClassNotFoundException, IOException)
        (§ call load("cloiure/core"))

        (§ call Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map CURRENT_NS, CURRENT_NS.deref(),
              #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        )))
        (§ try )
        (§
            (§ let Symbol USER = Symbol.intern("user"))
            (§ let Symbol CLOIURE = Symbol.intern("cloiure.core"))

            (§ let Var in_ns = var("cloiure.core", "in-ns"))
            (§ let Var refer = var("cloiure.core", "refer"))
            (§ call in_ns.invoke(USER))
            (§ call refer.invoke(CLOIURE))
            (§ call maybeLoadResourceScript("user.cli"))

            ;; start socket servers
            (§ let Var require = var("cloiure.core", "require"))
            (§ let Symbol SERVER = Symbol.intern("cloiure.core.server"))
            (§ call require.invoke(SERVER))
            (§ let Var start_servers = var("cloiure.core.server", "start-servers"))
            (§ call start_servers.invoke(System.getProperties()))
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
        )
    )

    #_static
    #_public
    (§ method int nextID()
        (§ return (§ expr id.getAndIncrement()))
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    #_public
    #_static
    (§ method void loadLibrary(String libname)
        (§ call System.loadLibrary(libname))
    )

    #_private
    #_static
    #_final
    (§ field int CHUNK_SIZE = 32)

    #_public
    #_static
    (§ method ISeq chunkIteratorSeq(final Iterator iter)
        (§ if (iter.hasNext()))
        (§
            (§ return (§ expr new LazySeq(new AFn()
            (§ inner
                #_public
                (§ method Object invoke()
                    (§ let Object[] arr = new Object[CHUNK_SIZE])
                    (§ let int n = 0)
                    (§ while (iter.hasNext() && n < CHUNK_SIZE))
                    (§
                        (§ ass arr[n++] = iter.next())
                    )
                    (§ return (§ expr new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter))))
                )
            ))))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method ISeq seq(Object coll)
        (§ if (coll instanceof ASeq))
        (§
            (§ return (§ expr (ASeq) coll))
        )
        (§ elseif (coll instanceof LazySeq))
        (§
            (§ return (§ expr ((LazySeq) coll).seq()))
        )
        (§ else )
        (§
            (§ return (§ expr seqFrom(coll)))
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    #_static
    (§ method ISeq seqFrom(Object coll)
        (§ if (coll instanceof Seqable))
        (§
            (§ return (§ expr ((Seqable) coll).seq()))
        )
        (§ elseif (coll == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof Iterable))
        (§
            (§ return (§ expr chunkIteratorSeq(((Iterable) coll).iterator())))
        )
        (§ elseif (coll.getClass().isArray()))
        (§
            (§ return (§ expr ArraySeq.createFromObject(coll)))
        )
        (§ elseif (coll instanceof CharSequence))
        (§
            (§ return (§ expr StringSeq.create((CharSequence) coll)))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ return (§ expr seq(((Map) coll).entrySet())))
        )
        (§ else )
        (§
            (§ let Class c = coll.getClass())
            (§ let Class sc = c.getSuperclass())
            (§ throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName()))
        )
    )

    #_static
    #_public
    (§ method boolean canSeq(Object coll)
        (§ return (§ expr coll instanceof ISeq
      #_arg || coll instanceof Seqable
      #_arg || coll == nil
      #_arg || coll instanceof Iterable
      #_arg || coll.getClass().isArray()
      #_arg || coll instanceof CharSequence
      #_arg || coll instanceof Map))
    )

    #_static
    #_public
    (§ method Iterator iter(Object coll)
        (§ if (coll instanceof Iterable))
        (§
            (§ return (§ expr ((Iterable)coll).iterator()))
        )
        (§ elseif (coll == nil))
        (§
            (§ return (§ expr new Iterator()
            (§ inner
                #_public
                (§ method boolean hasNext()
                    (§ return (§ expr false))
                )

                #_public
                (§ method Object next()
                    (§ throw new NoSuchElementException())
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ return (§ expr ((Map)coll).entrySet().iterator()))
        )
        (§ elseif (coll instanceof String))
        (§
            (§ let final String s = (String) coll)
            (§ return (§ expr new Iterator()
            (§ inner
                (§ let int i = 0)

                #_public
                (§ method boolean hasNext()
                    (§ return (§ expr (i < s.length())))
                )

                #_public
                (§ method Object next()
                    (§ return (§ expr s.charAt(i++)))
                )

                #_public
                (§ method void remove()
                    (§ throw new UnsupportedOperationException())
                )
            )))
        )
        (§ elseif (coll.getClass().isArray()))
        (§
            (§ return (§ expr ArrayIter.createFromObject(coll)))
        )
        (§ else )
        (§
            (§ return (§ expr iter(seq(coll))))
        )
    )

    #_static
    #_public
    (§ method Object seqOrElse(Object o)
        (§ return (§ expr (seq(o) == nil) ? nil :or o))
    )

    #_static
    #_public
    (§ method ISeq keys(Object coll)
        (§ if (coll instanceof IPersistentMap))
        (§
            (§ return (§ expr APersistentMap.KeySeq.createFromMap((IPersistentMap)coll)))
        )
        (§ else )
        (§
            (§ return (§ expr APersistentMap.KeySeq.create(seq(coll))))
        )
    )

    #_static
    #_public
    (§ method ISeq vals(Object coll)
        (§ if (coll instanceof IPersistentMap))
        (§
            (§ return (§ expr APersistentMap.ValSeq.createFromMap((IPersistentMap)coll)))
        )
        (§ else )
        (§
            (§ return (§ expr APersistentMap.ValSeq.create(seq(coll))))
        )
    )

    #_static
    #_public
    (§ method IPersistentMap meta(Object x)
        (§ if (x instanceof IMeta))
        (§
            (§ return (§ expr ((IMeta) x).meta()))
        )
        (§ return (§ expr nil))
    )

    #_public
    #_static
    (§ method int count(Object o)
        (§ if (o instanceof Counted))
        (§
            (§ return (§ expr ((Counted) o).count()))
        )
        (§ return (§ expr countFrom(Util.ret1(o, o = nil))))
    )

    #_static
    (§ method int countFrom(Object o)
        (§ if (o == nil))
        (§
            (§ return (§ expr 0))
        )
        (§ elseif (o instanceof IPersistentCollection))
        (§
            (§ let ISeq s = seq(o))
            (§ ass o = nil)
            (§ let int i = 0)
            (§ for (  s != nil s = s.next()))
            (§
                (§ if (s instanceof Counted))
                (§
                    (§ return (§ expr i + s.count()))
                )
                (§ ass i++)
            )
            (§ return (§ expr i))
        )
        (§ elseif (o instanceof CharSequence))
        (§
            (§ return (§ expr ((CharSequence) o).length()))
        )
        (§ elseif (o instanceof Collection))
        (§
            (§ return (§ expr ((Collection) o).size()))
        )
        (§ elseif (o instanceof Map))
        (§
            (§ return (§ expr ((Map) o).size()))
        )
        (§ elseif (o instanceof Map.Entry))
        (§
            (§ return (§ expr 2))
        )
        (§ elseif (o.getClass().isArray()))
        (§
            (§ return (§ expr Array.getLength(o)))
        )

        (§ throw new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName()))
    )

    #_static
    #_public
    (§ method IPersistentCollection conj(IPersistentCollection coll, Object x)
        (§ if (coll == nil))
        (§
            (§ return (§ expr new PersistentList(x)))
        )
        (§ return (§ expr coll.cons(x)))
    )

    #_static
    #_public
    (§ method ISeq cons(Object x, Object coll)
        (§ if (coll == nil))
        (§
            (§ return (§ expr new PersistentList(x)))
        )
        (§ elseif (coll instanceof ISeq))
        (§
            (§ return (§ expr new Cons(x, (ISeq) coll)))
        )
        (§ else )
        (§
            (§ return (§ expr new Cons(x, seq(coll))))
        )
    )

    #_static
    #_public
    (§ method Object first(Object x)
        (§ if (x instanceof ISeq))
        (§
            (§ return (§ expr ((ISeq) x).first()))
        )
        (§ let ISeq seq = seq(x))
        (§ if (seq == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr seq.first()))
    )

    #_static
    #_public
    (§ method Object second(Object x)
        (§ return (§ expr first(next(x))))
    )

    #_static
    #_public
    (§ method Object third(Object x)
        (§ return (§ expr first(next(next(x)))))
    )

    #_static
    #_public
    (§ method Object fourth(Object x)
        (§ return (§ expr first(next(next(next(x))))))
    )

    #_static
    #_public
    (§ method ISeq next(Object x)
        (§ if (x instanceof ISeq))
        (§
            (§ return (§ expr ((ISeq) x).next()))
        )
        (§ let ISeq seq = seq(x))
        (§ if (seq == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr seq.next()))
    )

    #_static
    #_public
    (§ method ISeq more(Object x)
        (§ if (x instanceof ISeq))
        (§
            (§ return (§ expr ((ISeq) x).more()))
        )
        (§ let ISeq seq = seq(x))
        (§ if (seq == nil))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr seq.more()))
    )

    #_static
    #_public
    (§ method Object peek(Object x)
        (§ if (x == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr ((IPersistentStack) x).peek()))
    )

    #_static
    #_public
    (§ method Object pop(Object x)
        (§ if (x == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr ((IPersistentStack) x).pop()))
    )

    #_static
    #_public
    (§ method Object get(Object coll, Object key)
        (§ if (coll instanceof ILookup))
        (§
            (§ return (§ expr ((ILookup) coll).valAt(key)))
        )
        (§ return (§ expr getFrom(coll, key)))
    )

    #_static
    (§ method Object getFrom(Object coll, Object key)
        (§ if (coll == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ let Map m = (Map) coll)
            (§ return (§ expr m.get(key)))
        )
        (§ elseif (coll instanceof IPersistentSet))
        (§
            (§ let IPersistentSet set = (IPersistentSet) coll)
            (§ return (§ expr set.get(key)))
        )
        (§ elseif (key instanceof Number && (coll instanceof String || coll.getClass().isArray())))
        (§
            (§ let int n = ((Number) key).intValue())
            (§ if (n >= 0 && n < count(coll)))
            (§
                (§ return (§ expr nth(coll, n)))
            )
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof ITransientSet))
        (§
            (§ let ITransientSet set = (ITransientSet) coll)
            (§ return (§ expr set.get(key)))
        )

        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method Object get(Object coll, Object key, Object notFound)
        (§ if (coll instanceof ILookup))
        (§
            (§ return (§ expr ((ILookup) coll).valAt(key, notFound)))
        )
        (§ return (§ expr getFrom(coll, key, notFound)))
    )

    #_static
    (§ method Object getFrom(Object coll, Object key, Object notFound)
        (§ if (coll == nil))
        (§
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ let Map m = (Map) coll)
            (§ if (m.containsKey(key)))
            (§
                (§ return (§ expr m.get(key)))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof IPersistentSet))
        (§
            (§ let IPersistentSet set = (IPersistentSet) coll)
            (§ if (set.contains(key)))
            (§
                (§ return (§ expr set.get(key)))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (key instanceof Number && (coll instanceof String || coll.getClass().isArray())))
        (§
            (§ let int n = ((Number) key).intValue())
            (§ return (§ expr (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound))
        )
        (§ elseif (coll instanceof ITransientSet))
        (§
            (§ let ITransientSet set = (ITransientSet) coll)
            (§ if (set.contains(key)))
            (§
                (§ return (§ expr set.get(key)))
            )
            (§ return (§ expr notFound))
        )
        (§ return (§ expr notFound))
    )

    #_static
    #_public
    (§ method Associative assoc(Object coll, Object key, Object val)
        (§ if (coll == nil))
        (§
            (§ return (§ expr new PersistentArrayMap(new Object[] (§ key, val ))))
        )
        (§ return (§ expr ((Associative) coll).assoc(key, val)))
    )

    #_static
    #_public
    (§ method Object contains(Object coll, Object key)
        (§ if (coll == nil))
        (§
            (§ return (§ expr F))
        )
        (§ elseif (coll instanceof Associative))
        (§
            (§ return (§ expr ((Associative) coll).containsKey(key) ? T :or F))
        )
        (§ elseif (coll instanceof IPersistentSet))
        (§
            (§ return (§ expr ((IPersistentSet) coll).contains(key) ? T :or F))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ let Map m = (Map) coll)
            (§ return (§ expr m.containsKey(key) ? T :or F))
        )
        (§ elseif (coll instanceof Set))
        (§
            (§ let Set s = (Set) coll)
            (§ return (§ expr s.contains(key) ? T :or F))
        )
        (§ elseif (key instanceof Number && (coll instanceof String || coll.getClass().isArray())))
        (§
            (§ let int n = ((Number) key).intValue())
            (§ return (§ expr (n >= 0 && n < count(coll)) ? T :or F))
        )
        (§ elseif (coll instanceof ITransientSet))
        (§
            (§ return (§ expr ((ITransientSet)coll).contains(key) ? T :or F))
        )
        (§ elseif (coll instanceof ITransientAssociative2))
        (§
            (§ return (§ expr (((ITransientAssociative2)coll).containsKey(key)) ? T :or F))
        )
        (§ throw new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName()))
    )

    #_static
    #_public
    (§ method Object find(Object coll, Object key)
        (§ if (coll == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof Associative))
        (§
            (§ return (§ expr ((Associative) coll).entryAt(key)))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ let Map m = (Map) coll)
            (§ if (m.containsKey(key)))
            (§
                (§ return (§ expr MapEntry.create(key, m.get(key))))
            )
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof ITransientAssociative2))
        (§
            (§ return (§ expr ((ITransientAssociative2) coll).entryAt(key)))
        )
        (§ throw new IllegalArgumentException("find not supported on type: " + coll.getClass().getName()))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    #_static
    #_public
    (§ method ISeq findKey(Keyword key, ISeq keyvals)
        (§ while (keyvals != nil))
        (§
            (§ let ISeq r = keyvals.next())
            (§ if (r == nil))
            (§
                (§ throw Util.runtimeException("Malformed keyword argslist"))
            )
            (§ if (keyvals.first() == key))
            (§
                (§ return (§ expr r))
            )
            (§ ass keyvals = r.next())
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method Object dissoc(Object coll, Object key)
        (§ if (coll == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr ((IPersistentMap) coll).without(key)))
    )

    #_static
    #_public
    (§ method Object nth(Object coll, int n)
        (§ if (coll instanceof Indexed))
        (§
            (§ return (§ expr ((Indexed) coll).nth(n)))
        )
        (§ return (§ expr nthFrom(Util.ret1(coll, coll = nil), n)))
    )

    #_static
    (§ method Object nthFrom(Object coll, int n)
        (§ if (coll == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof CharSequence))
        (§
            (§ return (§ expr Character.valueOf(((CharSequence) coll).charAt(n))))
        )
        (§ elseif (coll.getClass().isArray()))
        (§
            (§ return (§ expr Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
        )
        (§ elseif (coll instanceof RandomAccess))
        (§
            (§ return (§ expr ((List) coll).get(n)))
        )
        (§ elseif (coll instanceof Matcher))
        (§
            (§ return (§ expr ((Matcher) coll).group(n)))
        )
        (§ elseif (coll instanceof Map.Entry))
        (§
            (§ let Map.Entry e = (Map.Entry) coll)
            (§ if (n == 0))
            (§
                (§ return (§ expr e.getKey()))
            )
            (§ elseif (n == 1))
            (§
                (§ return (§ expr e.getValue()))
            )
            (§ throw new IndexOutOfBoundsException())
        )
        (§ elseif (coll instanceof Sequential))
        (§
            (§ let ISeq seq = RT.seq(coll))
            (§ ass coll = nil)
            (§ for (int i = 0 i <= n && seq != nil ++i, seq = seq.next()))
            (§
                (§ if (i == n))
                (§
                    (§ return (§ expr seq.first()))
                )
            )
            (§ throw new IndexOutOfBoundsException())
        )
        (§ else )
        (§
            (§ throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName()))
        )
    )

    #_static
    #_public
    (§ method Object nth(Object coll, int n, Object notFound)
        (§ if (coll instanceof Indexed))
        (§
            (§ let Indexed v = (Indexed) coll)
            (§ return (§ expr v.nth(n, notFound)))
        )
        (§ return (§ expr nthFrom(coll, n, notFound)))
    )

    #_static
    (§ method Object nthFrom(Object coll, int n, Object notFound)
        (§ if (coll == nil))
        (§
            (§ return (§ expr notFound))
        )
        (§ elseif (n < 0))
        (§
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof CharSequence))
        (§
            (§ let CharSequence s = (CharSequence) coll)
            (§ if (n < s.length()))
            (§
                (§ return (§ expr Character.valueOf(s.charAt(n))))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (coll.getClass().isArray()))
        (§
            (§ if (n < Array.getLength(coll)))
            (§
                (§ return (§ expr Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof RandomAccess))
        (§
            (§ let List list = (List) coll)
            (§ if (n < list.size()))
            (§
                (§ return (§ expr list.get(n)))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof Matcher))
        (§
            (§ let Matcher m = (Matcher) coll)
            (§ if (n < m.groupCount()))
            (§
                (§ return (§ expr m.group(n)))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof Map.Entry))
        (§
            (§ let Map.Entry e = (Map.Entry) coll)
            (§ if (n == 0))
            (§
                (§ return (§ expr e.getKey()))
            )
            (§ elseif (n == 1))
            (§
                (§ return (§ expr e.getValue()))
            )
            (§ return (§ expr notFound))
        )
        (§ elseif (coll instanceof Sequential))
        (§
            (§ let ISeq seq = RT.seq(coll))
            (§ ass coll = nil)
            (§ for (int i = 0 i <= n && seq != nil ++i, seq = seq.next()))
            (§
                (§ if (i == n))
                (§
                    (§ return (§ expr seq.first()))
                )
            )
            (§ return (§ expr notFound))
        )
        (§ else )
        (§
            (§ throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName()))
        )
    )

    #_static
    #_public
    (§ method Object assocN(int n, Object val, Object coll)
        (§ if (coll == nil))
        (§
            (§ return (§ expr nil))
        )
        (§ elseif (coll instanceof IPersistentVector))
        (§
            (§ return (§ expr ((IPersistentVector) coll).assocN(n, val)))
        )
        (§ elseif (coll instanceof Object[]))
        (§
            ;; hmm... this is not persistent
            (§ let Object[] array = ((Object[]) coll))
            (§ ass array[n] = val)
            (§ return (§ expr array))
        )
        (§ else )
        (§
            (§ return (§ expr nil))
        )
    )

    #_static
    (§ method boolean hasTag(Object o, Object tag)
        (§ return (§ expr Util.equals(tag, RT.get(RT.meta(o), TAG_KEY))))
    )

    #_static
    #_public
    (§ method Object box(Object x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Character box(char x)
        (§ return (§ expr Character.valueOf(x)))
    )

    #_static
    #_public
    (§ method Object box(boolean x)
        (§ return (§ expr x ? T :or F))
    )

    #_static
    #_public
    (§ method Object box(Boolean x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Number box(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Number box(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Number box(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Number box(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Number box(float x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method Number box(double x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method char charCast(Object x)
        (§ if (x instanceof Character))
        (§
            (§ return (§ expr ((Character) x).charValue()))
        )
        (§ let long n = ((Number) x).longValue())
        (§ if (n < Character.MIN_VALUE || n > Character.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        (§ return (§ expr (char) n))
    )

    #_static
    #_public
    (§ method char charCast(byte x)
        (§ let char i = (char) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method char charCast(short x)
        (§ let char i = (char) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method char charCast(char x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method char charCast(int x)
        (§ let char i = (char) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method char charCast(long x)
        (§ let char i = (char) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for char: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method char charCast(float x)
        (§ if (x >= Character.MIN_VALUE && x <= Character.MAX_VALUE))
        (§
            (§ return (§ expr (char) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for char: " + x))
    )

    #_static
    #_public
    (§ method char charCast(double x)
        (§ if (x >= Character.MIN_VALUE && x <= Character.MAX_VALUE))
        (§
            (§ return (§ expr (char) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for char: " + x))
    )

    #_static
    #_public
    (§ method boolean booleanCast(Object x)
        (§ if (x instanceof Boolean))
        (§
            (§ return (§ expr ((Boolean) x).booleanValue()))
        )
        (§ return (§ expr (x != nil)))
    )

    #_static
    #_public
    (§ method boolean booleanCast(boolean x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method byte byteCast(Object x)
        (§ if (x instanceof Byte))
        (§
            (§ return (§ expr ((Byte) x).byteValue()))
        )
        (§ let long n = longCast(x))
        (§ if (n < Byte.MIN_VALUE || n > Byte.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        (§ return (§ expr (byte) n))
    )

    #_static
    #_public
    (§ method byte byteCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method byte byteCast(short x)
        (§ let byte i = (byte) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method byte byteCast(int x)
        (§ let byte i = (byte) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method byte byteCast(long x)
        (§ let byte i = (byte) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method byte byteCast(float x)
        (§ if (x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE))
        (§
            (§ return (§ expr (byte) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
    )

    #_static
    #_public
    (§ method byte byteCast(double x)
        (§ if (x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE))
        (§
            (§ return (§ expr (byte) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for byte: " + x))
    )

    #_static
    #_public
    (§ method short shortCast(Object x)
        (§ if (x instanceof Short))
        (§
            (§ return (§ expr ((Short) x).shortValue()))
        )
        (§ let long n = longCast(x))
        (§ if (n < Short.MIN_VALUE || n > Short.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for short: " + x))
        )
        (§ return (§ expr (short) n))
    )

    #_static
    #_public
    (§ method short shortCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method short shortCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method short shortCast(int x)
        (§ let short i = (short) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for short: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method short shortCast(long x)
        (§ let short i = (short) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for short: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method short shortCast(float x)
        (§ if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE))
        (§
            (§ return (§ expr (short) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for short: " + x))
    )

    #_static
    #_public
    (§ method short shortCast(double x)
        (§ if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE))
        (§
            (§ return (§ expr (short) x))
        )
        (§ throw new IllegalArgumentException("Value out of range for short: " + x))
    )

    #_static
    #_public
    (§ method int intCast(Object x)
        (§ if (x instanceof Integer))
        (§
            (§ return (§ expr ((Integer)x).intValue()))
        )
        (§ if (x instanceof Number))
        (§
            (§ let long n = longCast(x))
            (§ return (§ expr intCast(n)))
        )
        (§ return (§ expr ((Character) x).charValue()))
    )

    #_static
    #_public
    (§ method int intCast(char x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int intCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int intCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int intCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int intCast(float x)
        (§ if (x < Integer.MIN_VALUE || x > Integer.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for int: " + x))
        )
        (§ return (§ expr (int) x))
    )

    #_static
    #_public
    (§ method int intCast(long x)
        (§ let int i = (int) x)
        (§ if (i != x))
        (§
            (§ throw new IllegalArgumentException("Value out of range for int: " + x))
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method int intCast(double x)
        (§ if (x < Integer.MIN_VALUE || x > Integer.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for int: " + x))
        )
        (§ return (§ expr (int) x))
    )

    #_static
    #_public
    (§ method long longCast(Object x)
        (§ if (x instanceof Integer || x instanceof Long))
        (§
            (§ return (§ expr ((Number) x).longValue()))
        )
        (§ elseif (x instanceof BigInt))
        (§
            (§ let BigInt bi = (BigInt) x)
            (§ if (bi.bipart == nil))
            (§
                (§ return (§ expr bi.lpart))
            )
            (§ else )
            (§
                (§ throw new IllegalArgumentException("Value out of range for long: " + x))
            )
        )
        (§ elseif (x instanceof BigInteger))
        (§
            (§ let BigInteger bi = (BigInteger) x)
            (§ if (bi.bitLength() < 64))
            (§
                (§ return (§ expr bi.longValue()))
            )
            (§ else )
            (§
                (§ throw new IllegalArgumentException("Value out of range for long: " + x))
            )
        )
        (§ elseif (x instanceof Byte || x instanceof Short))
        (§
            (§ return (§ expr ((Number) x).longValue()))
        )
        (§ elseif (x instanceof Ratio))
        (§
            (§ return (§ expr longCast(((Ratio)x).bigIntegerValue())))
        )
        (§ elseif (x instanceof Character))
        (§
            (§ return (§ expr longCast(((Character) x).charValue())))
        )
        (§ else )
        (§
            (§ return (§ expr longCast(((Number)x).doubleValue())))
        )
    )

    #_static
    #_public
    (§ method long longCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long longCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long longCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long longCast(float x)
        (§ if (x < Long.MIN_VALUE || x > Long.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for long: " + x))
        )
        (§ return (§ expr (long) x))
    )

    #_static
    #_public
    (§ method long longCast(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long longCast(double x)
        (§ if (x < Long.MIN_VALUE || x > Long.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for long: " + x))
        )
        (§ return (§ expr (long) x))
    )

    #_static
    #_public
    (§ method float floatCast(Object x)
        (§ if (x instanceof Float))
        (§
            (§ return (§ expr ((Float) x).floatValue()))
        )
        (§ let double n = ((Number) x).doubleValue())
        (§ if (n < -Float.MAX_VALUE || n > Float.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for float: " + x))
        )
        (§ return (§ expr (float) n))
    )

    #_static
    #_public
    (§ method float floatCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float floatCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float floatCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float floatCast(float x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float floatCast(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float floatCast(double x)
        (§ if (x < -Float.MAX_VALUE || x > Float.MAX_VALUE))
        (§
            (§ throw new IllegalArgumentException("Value out of range for float: " + x))
        )
        (§ return (§ expr (float) x))
    )

    #_static
    #_public
    (§ method double doubleCast(Object x)
        (§ return (§ expr ((Number) x).doubleValue()))
    )

    #_static
    #_public
    (§ method double doubleCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double doubleCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double doubleCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double doubleCast(float x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double doubleCast(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double doubleCast(double x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(Object x)
        (§ return (§ expr ((Number) x).byteValue()))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(short x)
        (§ return (§ expr (byte) x))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(int x)
        (§ return (§ expr (byte) x))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(long x)
        (§ return (§ expr (byte) x))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(float x)
        (§ return (§ expr (byte) x))
    )

    #_static
    #_public
    (§ method byte uncheckedByteCast(double x)
        (§ return (§ expr (byte) x))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(Object x)
        (§ return (§ expr ((Number) x).shortValue()))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(int x)
        (§ return (§ expr (short) x))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(long x)
        (§ return (§ expr (short) x))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(float x)
        (§ return (§ expr (short) x))
    )

    #_static
    #_public
    (§ method short uncheckedShortCast(double x)
        (§ return (§ expr (short) x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(Object x)
        (§ if (x instanceof Character))
        (§
            (§ return (§ expr ((Character) x).charValue()))
        )
        (§ return (§ expr (char) ((Number) x).longValue()))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(byte x)
        (§ return (§ expr (char) x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(short x)
        (§ return (§ expr (char) x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(char x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(int x)
        (§ return (§ expr (char) x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(long x)
        (§ return (§ expr (char) x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(float x)
        (§ return (§ expr (char) x))
    )

    #_static
    #_public
    (§ method char uncheckedCharCast(double x)
        (§ return (§ expr (char) x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(Object x)
        (§ if (x instanceof Number))
        (§
            (§ return (§ expr ((Number)x).intValue()))
        )
        (§ return (§ expr ((Character) x).charValue()))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(char x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(long x)
        (§ return (§ expr (int) x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(float x)
        (§ return (§ expr (int) x))
    )

    #_static
    #_public
    (§ method int uncheckedIntCast(double x)
        (§ return (§ expr (int) x))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(Object x)
        (§ return (§ expr ((Number) x).longValue()))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(float x)
        (§ return (§ expr (long) x))
    )

    #_static
    #_public
    (§ method long uncheckedLongCast(double x)
        (§ return (§ expr (long) x))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(Object x)
        (§ return (§ expr ((Number) x).floatValue()))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(float x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method float uncheckedFloatCast(double x)
        (§ return (§ expr (float) x))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(Object x)
        (§ return (§ expr ((Number) x).doubleValue()))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(byte x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(short x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(int x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(long x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(float x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method double uncheckedDoubleCast(double x)
        (§ return (§ expr x))
    )

    #_static
    #_public
    (§ method IPersistentMap map(Object... init)
        (§ if (init == nil))
        (§
            (§ return (§ expr PersistentArrayMap.EMPTY))
        )
        (§ elseif (init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD))
        (§
            (§ return (§ expr PersistentArrayMap.createWithCheck(init)))
        )
        (§ return (§ expr PersistentHashMap.createWithCheck(init)))
    )

    #_static
    #_public
    (§ method IPersistentMap mapUniqueKeys(Object... init)
        (§ if (init == nil))
        (§
            (§ return (§ expr PersistentArrayMap.EMPTY))
        )
        (§ elseif (init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD))
        (§
            (§ return (§ expr new PersistentArrayMap(init)))
        )
        (§ return (§ expr PersistentHashMap.create(init)))
    )

    #_static
    #_public
    (§ method IPersistentSet set(Object... init)
        (§ return (§ expr PersistentHashSet.createWithCheck(init)))
    )

    #_static
    #_public
    (§ method IPersistentVector vector(Object... init)
        (§ return (§ expr LazilyPersistentVector.createOwning(init)))
    )

    #_static
    #_public
    (§ method IPersistentVector subvec(IPersistentVector v, int start, int end)
        (§ if (end < start || start < 0 || end > v.count()))
        (§
            (§ throw new IndexOutOfBoundsException())
        )
        (§ if (start == end))
        (§
            (§ return (§ expr PersistentVector.EMPTY))
        )
        (§ return (§ expr new APersistentVector.SubVector(nil, v, start, end)))
    )

    #_static
    #_public
    (§ method ISeq list()
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method ISeq list(Object arg1)
        (§ return (§ expr new PersistentList(arg1)))
    )

    #_static
    #_public
    (§ method ISeq list(Object arg1, Object arg2)
        (§ return (§ expr listStar(arg1, arg2, nil)))
    )

    #_static
    #_public
    (§ method ISeq list(Object arg1, Object arg2, Object arg3)
        (§ return (§ expr listStar(arg1, arg2, arg3, nil)))
    )

    #_static
    #_public
    (§ method ISeq list(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ return (§ expr listStar(arg1, arg2, arg3, arg4, nil)))
    )

    #_static
    #_public
    (§ method ISeq list(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ return (§ expr listStar(arg1, arg2, arg3, arg4, arg5, nil)))
    )

    #_static
    #_public
    (§ method ISeq listStar(Object arg1, ISeq rest)
        (§ return (§ expr (ISeq) cons(arg1, rest)))
    )

    #_static
    #_public
    (§ method ISeq listStar(Object arg1, Object arg2, ISeq rest)
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, rest))))
    )

    #_static
    #_public
    (§ method ISeq listStar(Object arg1, Object arg2, Object arg3, ISeq rest)
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, cons(arg3, rest)))))
    )

    #_static
    #_public
    (§ method ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, ISeq rest)
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest))))))
    )

    #_static
    #_public
    (§ method ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, ISeq rest)
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest)))))))
    )

    #_static
    #_public
    (§ method ISeq arrayToList(Object[] a)
        (§ let ISeq ret = nil)
        (§ for (int i = a.length - 1 i >= 0 --i))
        (§
            (§ ass ret = (ISeq) cons(a[i], ret))
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method Object[] object_array(Object sizeOrSeq)
        (§ if (sizeOrSeq instanceof Number))
        (§
            (§ return (§ expr new Object[((Number) sizeOrSeq).intValue()]))
        )
        (§ else )
        (§
            (§ let ISeq s = RT.seq(sizeOrSeq))
            (§ let int size = RT.count(s))
            (§ let Object[] ret = new Object[size])
            (§ for (int i = 0 i < size && s != nil i++, s = s.next()))
            (§
                (§ ass ret[i] = s.first())
            )
            (§ return (§ expr ret))
        )
    )

    #_static
    #_public
    (§ method Object[] toArray(Object coll)
        (§ if (coll == nil))
        (§
            (§ return (§ expr EMPTY_ARRAY))
        )
        (§ elseif (coll instanceof Object[]))
        (§
            (§ return (§ expr (Object[]) coll))
        )
        (§ elseif (coll instanceof Collection))
        (§
            (§ return (§ expr ((Collection) coll).toArray()))
        )
        (§ elseif (coll instanceof Iterable))
        (§
            (§ let ArrayList ret = new ArrayList())
            (§ for (Object o :in (Iterable)coll))
            (§
                (§ call ret.add(o))
            )
            (§ return (§ expr ret.toArray()))
        )
        (§ elseif (coll instanceof Map))
        (§
            (§ return (§ expr ((Map) coll).entrySet().toArray()))
        )
        (§ elseif (coll instanceof String))
        (§
            (§ let char[] chars = ((String) coll).toCharArray())
            (§ let Object[] ret = new Object[chars.length])
            (§ for (int i = 0 i < chars.length i++))
            (§
                (§ ass ret[i] = chars[i])
            )
            (§ return (§ expr ret))
        )
        (§ elseif (coll.getClass().isArray()))
        (§
            (§ let ISeq s = (seq(coll)))
            (§ let Object[] ret = new Object[count(s)])
            (§ for (int i = 0 i < ret.length i++, s = s.next()))
            (§
                (§ ass ret[i] = s.first())
            )
            (§ return (§ expr ret))
        )
        (§ else )
        (§
            (§ throw Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]"))
        )
    )

    #_static
    #_public
    (§ method Object[] seqToArray(ISeq seq)
        (§ let int len = length(seq))
        (§ let Object[] ret = new Object[len])
        (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
        (§
            (§ ass ret[i] = seq.first())
        )
        (§ return (§ expr ret))
    )

    ;; supports java Collection.toArray(T[])
    #_static
    #_public
    (§ method Object[] seqToPassedArray(ISeq seq, Object[] passed)
        (§ let Object[] dest = passed)
        (§ let int len = count(seq))
        (§ if (len > dest.length))
        (§
            (§ ass dest = (Object[]) Array.newInstance(passed.getClass().getComponentType(), len))
        )
        (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
        (§
            (§ ass dest[i] = seq.first())
        )
        (§ if (len < passed.length))
        (§
            (§ ass dest[len] = nil)
        )
        (§ return (§ expr dest))
    )

    #_static
    #_public
    (§ method Object seqToTypedArray(ISeq seq)
        (§ let Class type = (seq != nil && seq.first() != nil) ? seq.first().getClass() :or Object.class)
        (§ return (§ expr seqToTypedArray(type, seq)))
    )

    #_static
    #_public
    (§ method Object seqToTypedArray(Class type, ISeq seq)
        (§ let Object ret = Array.newInstance(type, length(seq)))
        (§ if (type == Integer.TYPE))
        (§
            (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
            (§
                (§ call Array.set(ret, i, intCast(seq.first())))
            )
        )
        (§ elseif (type == Byte.TYPE))
        (§
            (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
            (§
                (§ call Array.set(ret, i, byteCast(seq.first())))
            )
        )
        (§ elseif (type == Float.TYPE))
        (§
            (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
            (§
                (§ call Array.set(ret, i, floatCast(seq.first())))
            )
        )
        (§ elseif (type == Short.TYPE))
        (§
            (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
            (§
                (§ call Array.set(ret, i, shortCast(seq.first())))
            )
        )
        (§ elseif (type == Character.TYPE))
        (§
            (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
            (§
                (§ call Array.set(ret, i, charCast(seq.first())))
            )
        )
        (§ else )
        (§
            (§ for (int i = 0 seq != nil ++i, seq = seq.next()))
            (§
                (§ call Array.set(ret, i, seq.first()))
            )
        )
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method int length(ISeq list)
        (§ let int i = 0)
        (§ for (ISeq c = list c != nil c = c.next()))
        (§
            (§ ass i++)
        )
        (§ return (§ expr i))
    )

    #_static
    #_public
    (§ method int boundedLength(ISeq list, int limit)
        (§ let int i = 0)
        (§ for (ISeq c = list c != nil && i <= limit c = c.next()))
        (§
            (§ ass i++)
        )
        (§ return (§ expr i))
    )

    #_static
    (§ method Character readRet(int ret)
        (§ if (ret == -1))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr box((char) ret)))
    )

    #_static
    #_public
    (§ method Character readChar(Reader r) (§ throws IOException)
        (§ let int ret = r.read())
        (§ return (§ expr readRet(ret)))
    )

    #_static
    #_public
    (§ method Character peekChar(Reader r) (§ throws IOException)
        (§ let int ret)
        (§ if (r instanceof PushbackReader))
        (§
            (§ ass ret = r.read())
            ((PushbackReader) r).unread(ret)
        )
        (§ else )
        (§
            (§ call r.mark(1))
            (§ ass ret = r.read())
            (§ call r.reset())
        )

        (§ return (§ expr readRet(ret)))
    )

    #_static
    #_public
    (§ method int getLineNumber(Reader r)
        (§ if (r instanceof LineNumberingPushbackReader))
        (§
            (§ return (§ expr ((LineNumberingPushbackReader) r).getLineNumber()))
        )
        (§ return (§ expr 0))
    )

    #_static
    #_public
    (§ method int getColumnNumber(Reader r)
        (§ if (r instanceof LineNumberingPushbackReader))
        (§
            (§ return (§ expr ((LineNumberingPushbackReader) r).getColumnNumber()))
        )
        (§ return (§ expr 0))
    )

    #_static
    #_public
    (§ method LineNumberingPushbackReader getLineNumberingReader(Reader r)
        (§ if (isLineNumberingReader(r)))
        (§
            (§ return (§ expr (LineNumberingPushbackReader) r))
        )
        (§ return (§ expr new LineNumberingPushbackReader(r)))
    )

    #_static
    #_public
    (§ method boolean isLineNumberingReader(Reader r)
        (§ return (§ expr (r instanceof LineNumberingPushbackReader)))
    )

    #_static
    #_public
    (§ method boolean isReduced(Object r)
        (§ return (§ expr (r instanceof Reduced)))
    )

    #_static
    #_public
    (§ method String resolveClassNameInContext(String className)
        ;; todo - look up in context var
        (§ return (§ expr className))
    )

    #_static
    #_public
    (§ method boolean suppressRead()
        (§ return (§ expr booleanCast(SUPPRESS_READ.deref())))
    )

    #_static
    #_public
    (§ method String printString(Object x)
        (§ try )
        (§
            (§ let StringWriter sw = new StringWriter())
            (§ call print(x, sw))
            (§ return (§ expr sw.toString()))
        )
        (§ catch (Exception e))
        (§
            (§ throw Util.sneakyThrow(e))
        )
    )

    #_static
    #_public
    (§ method Object readString(String s)
        (§ return (§ expr readString(s, nil)))
    )

    #_static
    #_public
    (§ method Object readString(String s, Object opts)
        (§ let PushbackReader r = new PushbackReader(new StringReader(s)))
        (§ return (§ expr LispReader.read(r, opts)))
    )

    #_static
    #_public
    (§ method void print(Object x, Writer w) (§ throws IOException)
        ;; call multimethod
        (§ if (PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref())))
        (§
            (§ call PR_ON.invoke(x, w))
        )
        (§ else )
        (§
            (§ let boolean readably = booleanCast(PRINT_READABLY.deref()))
            (§ if (x instanceof Obj))
            (§
                (§ let Obj o = (Obj) x)
                (§ if (RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref()))))
                (§
                    (§ let IPersistentMap meta = o.meta())
                    (§ call w.write("#^"))
                    (§ if (meta.count() == 1 && meta.containsKey(TAG_KEY)))
                    (§
                        (§ call print(meta.valAt(TAG_KEY), w))
                    )
                    (§ else )
                    (§
                        (§ call print(meta, w))
                    )
                    (§ call w.write(\space))
                )
            )
            (§ if (x == nil))
            (§
                (§ call w.write("nil"))
            )
            (§ elseif (x instanceof ISeq || x instanceof IPersistentList))
            (§
                (§ call w.write(\())
                (§ call printInnerSeq(seq(x), w))
                (§ call w.write(\)))
            )
            (§ elseif (x instanceof String))
            (§
                (§ let String s = (String) x)
                (§ if (!readably))
                (§
                    (§ call w.write(s))
                )
                (§ else )
                (§
                    (§ call w.write(\")) ;; oops! "
                    (§ for (int i = 0 i < s.length() i++))
                    (§
                        (§ let char c = s.charAt(i))
                        (§ switch (c))
                        (§
                            (§ case \newline)
                            (§
                                (§ call w.write("\\n"))
                                (§ break )
                            )
                            (§ case \tab)
                            (§
                                (§ call w.write("\\t"))
                                (§ break )
                            )
                            (§ case \return)
                            (§
                                (§ call w.write("\\r"))
                                (§ break )
                            )
                            (§ case \")
                            (§
                                (§ call w.write("\\\""))
                                (§ break )
                            )
                            (§ case \\)
                            (§
                                (§ call w.write("\\\\"))
                                (§ break )
                            )
                            (§ case \formfeed)
                            (§
                                (§ call w.write("\\f"))
                                (§ break )
                            )
                            (§ case \backspace)
                            (§
                                (§ call w.write("\\b"))
                                (§ break )
                            )
                            (§ default )
                            (§
                                (§ call w.write(c))
                                (§ break )
                            )
                        )
                    )
                    (§ call w.write(\")) ;; oops! "
                )
            )
            (§ elseif (x instanceof IPersistentMap))
            (§
                (§ call w.write(\{))
                (§ for (ISeq s = seq(x) s != nil s = s.next()))
                (§
                    (§ let IMapEntry e = (IMapEntry) s.first())
                    (§ call print(e.key(), w))
                    (§ call w.write(\space))
                    (§ call print(e.val(), w))
                    (§ if (s.next() != nil))
                    (§
                        (§ call w.write(", "))
                    )
                )
                (§ call w.write(\}))
            )
            (§ elseif (x instanceof IPersistentVector))
            (§
                (§ let IPersistentVector a = (IPersistentVector) x)
                (§ call w.write(\[))
                (§ for (int i = 0 i < a.count() i++))
                (§
                    (§ call print(a.nth(i), w))
                    (§ if (i < a.count() - 1))
                    (§
                        (§ call w.write(\space))
                    )
                )
                (§ call w.write(\]))
            )
            (§ elseif (x instanceof IPersistentSet))
            (§
                (§ call w.write("#{"))
                (§ for (ISeq s = seq(x) s != nil s = s.next()))
                (§
                    (§ call print(s.first(), w))
                    (§ if (s.next() != nil))
                    (§
                        (§ call w.write(" "))
                    )
                )
                (§ call w.write(\}))
            )
            (§ elseif (x instanceof Character))
            (§
                (§ let char c = ((Character) x).charValue())
                (§ if (!readably))
                (§
                    (§ call w.write(c))
                )
                (§ else )
                (§
                    (§ call w.write(\\))
                    (§ switch (c))
                    (§
                        (§ case \newline)
                        (§
                            (§ call w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (§
                            (§ call w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (§
                            (§ call w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (§
                            (§ call w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (§
                            (§ call w.write("formfeed"))
                            (§ break )
                        )
                        (§ case \return)
                        (§
                            (§ call w.write("return"))
                            (§ break )
                        )
                        (§ default )
                        (§
                            (§ call w.write(c))
                            (§ break )
                        )
                    )
                )
            )
            (§ elseif (x instanceof Class))
            (§
                (§ call w.write("#="))
                (§ call w.write(((Class) x).getName()))
            )
            (§ elseif (x instanceof BigDecimal && readably))
            (§
                (§ call w.write(x.toString()))
                (§ call w.write(\M))
            )
            (§ elseif (x instanceof BigInt && readably))
            (§
                (§ call w.write(x.toString()))
                (§ call w.write(\N))
            )
            (§ elseif (x instanceof BigInteger && readably))
            (§
                (§ call w.write(x.toString()))
                (§ call w.write("BIGINT"))
            )
            (§ elseif (x instanceof Var))
            (§
                (§ let Var v = (Var) x)
                (§ call w.write("#=(var " + v.ns.name + "/" + v.sym + ")"))
            )
            (§ elseif (x instanceof Pattern))
            (§
                (§ let Pattern p = (Pattern) x)
                (§ call w.write("#\"" + p.pattern() + "\""))
            )
            (§ else )
            (§
                (§ call w.write(x.toString()))
            )
        )
    )

    #_private
    #_static
    (§ method void printInnerSeq(ISeq x, Writer w) (§ throws IOException)
        (§ for (ISeq s = x s != nil s = s.next()))
        (§
            (§ call print(s.first(), w))
            (§ if (s.next() != nil))
            (§
                (§ call w.write(\space))
            )
        )
    )

    #_static
    #_public
    (§ method void formatAesthetic(Writer w, Object obj) (§ throws IOException)
        (§ if (obj == nil))
        (§
            (§ call w.write("nil"))
        )
        (§ else )
        (§
            (§ call w.write(obj.toString()))
        )
    )

    #_static
    #_public
    (§ method void formatStandard(Writer w, Object obj) (§ throws IOException)
        (§ if (obj == nil))
        (§
            (§ call w.write("nil"))
        )
        (§ elseif (obj instanceof String))
        (§
            (§ call w.write(\")) ;; oops! "
            (§ call w.write((String) obj))
            (§ call w.write(\")) ;; oops! "
        )
        (§ elseif (obj instanceof Character))
        (§
            (§ call w.write(\\))
            (§ let char c = ((Character) obj).charValue())
            (§ switch (c))
            (§
                (§ case \newline)
                (§
                    (§ call w.write("newline"))
                    (§ break )
                )
                (§ case \tab)
                (§
                    (§ call w.write("tab"))
                    (§ break )
                )
                (§ case \space)
                (§
                    (§ call w.write("space"))
                    (§ break )
                )
                (§ case \backspace)
                (§
                    (§ call w.write("backspace"))
                    (§ break )
                )
                (§ case \formfeed)
                (§
                    (§ call w.write("formfeed"))
                    (§ break )
                )
                (§ default )
                (§
                    (§ call w.write(c))
                    (§ break )
                )
            )
        )
        (§ else )
        (§
            (§ call w.write(obj.toString()))
        )
    )

    #_static
    #_public
    (§ method Object format(Object o, String s, Object... args) (§ throws IOException)
        (§ let Writer w)
        (§ if (o == nil))
        (§
            (§ ass w = new StringWriter())
        )
        (§ elseif (Util.equals(o, T)))
        (§
            (§ ass w = (Writer) OUT.deref())
        )
        (§ else )
        (§
            (§ ass w = (Writer) o)
        )
        (§ call doFormat(w, s, ArraySeq.create(args)))
        (§ if (o == nil))
        (§
            (§ return (§ expr w.toString()))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method ISeq doFormat(Writer w, String s, ISeq args) (§ throws IOException)
        (§ for (int i = 0 i < s.length() ))
        (§
            (§ let char c = s.charAt(i++))
            (§ switch (Character.toLowerCase(c)))
            (§
                (§ case \~)
                (§
                    (§ let char d = s.charAt(i++))
                    (§ switch (Character.toLowerCase(d)))
                    (§
                        (§ case \%)
                        (§
                            (§ call w.write(\newline))
                            (§ break )
                        )
                        (§ case \t)
                        (§
                            (§ call w.write(\tab))
                            (§ break )
                        )
                        (§ case \a)
                        (§
                            (§ if (args == nil))
                            (§
                                (§ throw new IllegalArgumentException("Missing argument"))
                            )
                            (§ call RT.formatAesthetic(w, RT.first(args)))
                            (§ ass args = RT.next(args))
                            (§ break )
                        )
                        (§ case \s)
                        (§
                            (§ if (args == nil))
                            (§
                                (§ throw new IllegalArgumentException("Missing argument"))
                            )
                            (§ call RT.formatStandard(w, RT.first(args)))
                            (§ ass args = RT.next(args))
                            (§ break )
                        )
                        (§ case \{)
                        (§
                            (§ let int j = s.indexOf("~}", i)) ;; note - does not nest
                            (§ if (j == -1))
                            (§
                                (§ throw new IllegalArgumentException("Missing ~}"))
                            )
                            (§ let String subs = s.substring(i, j))
                            (§ for (ISeq sargs = RT.seq(RT.first(args)) sargs != nil ))
                            (§
                                (§ ass sargs = doFormat(w, subs, sargs))
                            )
                            (§ ass args = RT.next(args))
                            (§ ass i = j + 2) ;; skip "~}"
                            (§ break )
                        )
                        (§ case \^)
                        (§
                            (§ if (args == nil))
                            (§
                                (§ return (§ expr nil))
                            )
                            (§ break )
                        )
                        (§ case \~)
                        (§
                            (§ call w.write(\~))
                            (§ break )
                        )
                        (§ default )
                        (§
                            (§ throw new IllegalArgumentException("Unsupported ~ directive: " + d))
                        )
                    )
                    (§ break )
                )
                (§ default )
                (§
                    (§ call w.write(c))
                    (§ break )
                )
            )
        )
        (§ return (§ expr args))
    )

    #_static
    #_public
    (§ method Object[] setValues(Object... vals)
        (§ if (vals.length > 0))
        (§
            (§ return (§ expr vals))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method ClassLoader makeClassLoader()
        (§ return (§ expr (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
        (§ inner
            #_public
            (§ method Object run()
                (§ try )
                (§
                    (§ call Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T)))
                    (§ return (§ expr new DynamicClassLoader(baseLoader())))
                )
                (§ finally )
                (§
                    (§ call Var.popThreadBindings())
                )
            )
        ))))
    )

    #_static
    #_public
    (§ method ClassLoader baseLoader()
        (§ if (Compiler.LOADER.isBound()))
        (§
            (§ return (§ expr (ClassLoader) Compiler.LOADER.deref()))
        )
        (§ elseif (booleanCast(USE_CONTEXT_CLASSLOADER.deref())))
        (§
            (§ return (§ expr Thread.currentThread().getContextClassLoader()))
        )
        (§ return (§ expr Compiler.class.getClassLoader()))
    )

    #_static
    #_public
    (§ method InputStream resourceAsStream(ClassLoader loader, String name)
        (§ if (loader == nil))
        (§
            (§ return (§ expr ClassLoader.getSystemResourceAsStream(name)))
        )
        (§ else )
        (§
            (§ return (§ expr loader.getResourceAsStream(name)))
        )
    )

    #_static
    #_public
    (§ method URL getResource(ClassLoader loader, String name)
        (§ if (loader == nil))
        (§
            (§ return (§ expr ClassLoader.getSystemResource(name)))
        )
        (§ else )
        (§
            (§ return (§ expr loader.getResource(name)))
        )
    )

    #_static
    #_public
    (§ method Class classForName(String name, boolean load, ClassLoader loader)
        (§ try )
        (§
            (§ let Class c = nil)
            (§ if (!(loader instanceof DynamicClassLoader)))
            (§
                (§ ass c = DynamicClassLoader.findInMemoryClass(name))
            )
            (§ if (c != nil))
            (§
                (§ return (§ expr c))
            )
            (§ return (§ expr Class.forName(name, load, loader)))
        )
        (§ catch (ClassNotFoundException e))
        (§
            (§ throw Util.sneakyThrow(e))
        )
    )

    #_static
    #_public
    (§ method Class classForName(String name)
        (§ return (§ expr classForName(name, true, baseLoader())))
    )

    #_static
    #_public
    (§ method Class classForNameNonLoading(String name)
        (§ return (§ expr classForName(name, false, baseLoader())))
    )

    #_static
    #_public
    (§ method Class loadClassForName(String name)
        (§ try )
        (§
            (§ call classForNameNonLoading(name))
        )
        (§ catch (Exception e))
        (§
            (§ if (e instanceof ClassNotFoundException))
            (§
                (§ return (§ expr nil))
            )
            (§ else )
            (§
                (§ throw Util.sneakyThrow(e))
            )
        )
        (§ return (§ expr classForName(name)))
    )

    #_static
    #_public
    (§ method float aget(float[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method float aset(float[] xs, int i, float v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(float[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method float[] aclone(float[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method double aget(double[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method double aset(double[] xs, int i, double v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(double[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method double[] aclone(double[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method int aget(int[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method int aset(int[] xs, int i, int v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(int[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method int[] aclone(int[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method long aget(long[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method long aset(long[] xs, int i, long v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(long[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method long[] aclone(long[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method char aget(char[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method char aset(char[] xs, int i, char v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(char[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method char[] aclone(char[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method byte aget(byte[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method byte aset(byte[] xs, int i, byte v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(byte[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method byte[] aclone(byte[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method short aget(short[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method short aset(short[] xs, int i, short v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(short[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method short[] aclone(short[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method boolean aget(boolean[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method boolean aset(boolean[] xs, int i, boolean v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(boolean[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method boolean[] aclone(boolean[] xs)
        (§ return (§ expr xs.clone()))
    )

    #_static
    #_public
    (§ method Object aget(Object[] xs, int i)
        (§ return (§ expr xs[i]))
    )

    #_static
    #_public
    (§ method Object aset(Object[] xs, int i, Object v)
        (§ ass xs[i] = v)
        (§ return (§ expr v))
    )

    #_static
    #_public
    (§ method int alength(Object[] xs)
        (§ return (§ expr xs.length))
    )

    #_static
    #_public
    (§ method Object[] aclone(Object[] xs)
        (§ return (§ expr xs.clone()))
    )
)
)

(java-ns cloiure.lang.Seqable

#_public
(§ interface Seqable
    (§ abstract ISeq seq())
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

#_public
(class-ns SeqEnumeration (§ implements Enumeration)
    (§ field ISeq seq)

    #_public
    (§ method SeqEnumeration(ISeq seq)
        (§ ass this.seq = seq)
    )

    #_public
    (§ method boolean hasMoreElements()
        (§ return (§ expr (seq != nil)))
    )

    #_public
    (§ method Object nextElement()
        (§ let Object ret = RT.first(seq))
        (§ ass seq = RT.next(seq))
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_public
(class-ns SeqIterator (§ implements Iterator)
    #_static
    #_final
    (§ field Object START = new Object())

    (§ field Object seq)
    (§ field Object next)

    #_public
    (§ method SeqIterator(Object o)
        (§ ass seq = START)
        (§ ass next = o)
    )

    ;; preserved for binary compatibility
    #_public
    (§ method SeqIterator(ISeq o)
        (§ ass seq = START)
        (§ ass next = o)
    )

    #_public
    (§ method boolean hasNext()
        (§ if (seq == START))
        (§
            (§ ass seq = nil)
            (§ ass next = RT.seq(next))
        )
        (§ elseif (seq == next))
        (§
            (§ ass next = RT.next(seq))
        )
        (§ return (§ expr (next != nil)))
    )

    #_public
    (§ method Object next() (§ throws NoSuchElementException)
        (§ if (!hasNext()))
        (§
            (§ throw new NoSuchElementException())
        )
        (§ ass seq = next)
        (§ return (§ expr RT.first(next)))
    )

    #_public
    (§ method void remove()
        (§ throw new UnsupportedOperationException())
    )
)
)

(java-ns cloiure.lang.Sequential

#_public
(§ interface Sequential
)
)

(java-ns cloiure.lang.Settable

#_public
(§ interface Settable
    (§ abstract Object doSet(Object val))
    (§ abstract Object doReset(Object val))
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

#_public
(§ interface Sorted
    (§ abstract Comparator comparator())
    (§ abstract Object entryKey(Object entry))
    (§ abstract ISeq seq(boolean ascending))
    (§ abstract ISeq seqFrom(Object key, boolean ascending))
)
)

(java-ns cloiure.lang.StringSeq

#_public
(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    #_public
    #_final
    (§ field CharSequence s)
    #_public
    #_final
    (§ field int i)

    #_static
    #_public
    (§ method StringSeq create(CharSequence s)
        (§ if (s.length() == 0))
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new StringSeq(nil, s, 0)))
    )

    (§ method StringSeq(IPersistentMap meta, CharSequence s, int i)
        (§ super(meta))
        (§ ass this.s = s)
        (§ ass this.i = i)
    )

    #_public
    (§ method Obj withMeta(IPersistentMap meta)
        (§ if (meta == meta()))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new StringSeq(meta, s, i)))
    )

    #_public
    (§ method Object first()
        (§ return (§ expr Character.valueOf(s.charAt(i))))
    )

    #_public
    (§ method ISeq next()
        (§ if (i + 1 < s.length()))
        (§
            (§ return (§ expr new StringSeq(_meta, s, i + 1)))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method int index()
        (§ return (§ expr i))
    )

    #_public
    (§ method int count()
        (§ return (§ expr s.length() - i))
    )
)
)

(java-ns cloiure.lang.Symbol

#_public
(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    #_final
    (§ field String ns)
    #_final
    (§ field String name)
    #_private
    (§ field int _hasheq)
    #_final
    (§ field IPersistentMap _meta)
    #_transient
    (§ field String _str)

    #_public
    (§ method String toString()
        (§ if (_str == nil))
        (§
            (§ if (ns != nil))
            (§
                (§ ass _str = (ns + "/" + name))
            )
            (§ else )
            (§
                (§ ass _str = name)
            )
        )
        (§ return (§ expr _str))
    )

    #_public
    (§ method String getNamespace()
        (§ return (§ expr ns))
    )

    #_public
    (§ method String getName()
        (§ return (§ expr name))
    )

    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    #_static
    #_public
    (§ method Symbol create(String ns, String name)
        (§ return (§ expr Symbol.intern(ns, name)))
    )

    #_static
    #_public
    (§ method Symbol create(String nsname)
        (§ return (§ expr Symbol.intern(nsname)))
    )

    #_static
    #_public
    (§ method Symbol intern(String ns, String name)
        (§ return (§ expr new Symbol(ns, name)))
    )

    #_static
    #_public
    (§ method Symbol intern(String nsname)
        (§ let int i = nsname.indexOf(\/))
        (§ if (i == -1 || nsname.equals("/")))
        (§
            (§ return (§ expr new Symbol(nil, nsname)))
        )
        (§ else )
        (§
            (§ return (§ expr new Symbol(nsname.substring(0, i), nsname.substring(i + 1))))
        )
    )

    #_private
    (§ method Symbol(String ns_interned, String name_interned)
        (§ ass this.name = name_interned)
        (§ ass this.ns = ns_interned)
        (§ ass this._meta = nil)
    )

    #_public
    (§ method boolean equals(Object o)
        (§ if (this == o))
        (§
            (§ return (§ expr true))
        )
        (§ if (!(o instanceof Symbol)))
        (§
            (§ return (§ expr false))
        )

        (§ let Symbol symbol = (Symbol) o)

        (§ return (§ expr Util.equals(ns, symbol.ns) && name.equals(symbol.name)))
    )

    #_public
    (§ method int hashCode()
        (§ return (§ expr Util.hashCombine(name.hashCode(), Util.hash(ns))))
    )

    #_public
    (§ method int hasheq()
        (§ if (_hasheq == 0))
        (§
            (§ ass _hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns)))
        )
        (§ return (§ expr _hasheq))
    )

    #_public
    (§ method IObj withMeta(IPersistentMap meta)
        (§ return (§ expr new Symbol(meta, ns, name)))
    )

    #_private
    (§ method Symbol(IPersistentMap meta, String ns, String name)
        (§ ass this.name = name)
        (§ ass this.ns = ns)
        (§ ass this._meta = meta)
    )

    #_public
    (§ method int compareTo(Object o)
        (§ let Symbol s = (Symbol) o)
        (§ if (this.equals(o)))
        (§
            (§ return (§ expr 0))
        )
        (§ if (this.ns == nil && s.ns != nil))
        (§
            (§ return (§ expr -1))
        )
        (§ if (this.ns != nil))
        (§
            (§ if (s.ns == nil))
            (§
                (§ return (§ expr 1))
            )
            (§ let int nsc = this.ns.compareTo(s.ns))
            (§ if (nsc != 0))
            (§
                (§ return (§ expr nsc))
            )
        )
        (§ return (§ expr this.name.compareTo(s.name)))
    )

    #_public
    (§ method Object invoke(Object obj)
        (§ return (§ expr RT.get(obj, this)))
    )

    #_public
    (§ method Object invoke(Object obj, Object notFound)
        (§ return (§ expr RT.get(obj, this, notFound)))
    )

    #_public
    (§ method IPersistentMap meta()
        (§ return (§ expr _meta))
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

#_public
(class-ns TaggedLiteral (§ implements ILookup)
    #_public
    #_static
    #_final
    (§ field Keyword TAG_KW = Keyword.intern("tag"))
    #_public
    #_static
    #_final
    (§ field Keyword FORM_KW = Keyword.intern("form"))

    #_public
    #_final
    (§ field Symbol tag)
    #_public
    #_final
    (§ field Object form)

    #_public
    #_static
    (§ method TaggedLiteral create(Symbol tag, Object form)
        (§ return (§ expr new TaggedLiteral(tag, form)))
    )

    #_private
    (§ method TaggedLiteral(Symbol tag, Object form)
        (§ ass this.tag = tag)
        (§ ass this.form = form)
    )

    #_public
    (§ method Object valAt(Object key)
        (§ return (§ expr valAt(key, nil)))
    )

    #_public
    (§ method Object valAt(Object key, Object notFound)
        (§ if (FORM_KW.equals(key)))
        (§
            (§ return (§ expr this.form))
        )
        (§ elseif (TAG_KW.equals(key)))
        (§
            (§ return (§ expr this.tag))
        )
        (§ else )
        (§
            (§ return (§ expr notFound))
        )
    )

    (§ anno @Override)
    #_public
    (§ method boolean equals(Object o)
        (§ if (this == o))
        (§
            (§ return (§ expr true))
        )
        (§ if (o == nil || getClass() != o.getClass()))
        (§
            (§ return (§ expr false))
        )

        (§ let TaggedLiteral that = (TaggedLiteral) o)

        (§ if ((form != nil) ? !form.equals(that.form) :or that.form != nil))
        (§
            (§ return (§ expr false))
        )
        (§ if ((tag != nil) ? !tag.equals(that.tag) :or that.tag != nil))
        (§
            (§ return (§ expr false))
        )

        (§ return (§ expr true))
    )

    (§ anno @Override)
    #_public
    (§ method int hashCode()
        (§ let int result = Util.hash(tag))
        (§ ass result = 31 * result + Util.hash(form))
        (§ return (§ expr result))
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

#_public
(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    #_final
    (§ field Ref[] bins)

    (§ method IPersistentMap mapAt(int bin)
        (§ return (§ expr (IPersistentMap) bins[bin].deref()))
    )

    #_final
    (§ method int binFor(Object k)
        ;; spread hashes, a la Cliff Click
        (§ let int h = k.hashCode())
        (§ ass h ^= (h >>> 20) :xor (h >>> 12))
        (§ ass h ^= (h >>> 7) :xor (h >>> 4))
        (§ return (§ expr h % bins.length))
    )

    (§ method Entry entryAt(Object k)
        (§ return (§ expr mapAt(binFor(k)).entryAt(k)))
    )

    #_public
    (§ method TransactionalHashMap()
        (§ this(421))
    )

    #_public
    (§ method TransactionalHashMap(int nBins)
        (§ ass bins = new Ref[nBins])
        (§ for (int i = 0 i < nBins i++))
        (§
            (§ ass bins[i] = new Ref(PersistentHashMap.EMPTY))
        )
    )

    #_public
    (§ method TransactionalHashMap(Map<? extends K, ? extends V> m)
        (§ this(m.size()))
        (§ call putAll(m))
    )

    #_public
    (§ method int size()
        (§ let int n = 0)
        (§ for (int i = 0 i < bins.length i++))
        (§
            (§ ass n += mapAt(i).count())
        )
        (§ return (§ expr n))
    )

    #_public
    (§ method boolean isEmpty()
        (§ return (§ expr (size() == 0)))
    )

    #_public
    (§ method boolean containsKey(Object k)
        (§ return (§ expr (entryAt(k) != nil)))
    )

    #_public
    (§ method V get(Object k)
        (§ let Entry e = entryAt(k))
        (§ if (e != nil))
        (§
            (§ return (§ expr (V) e.getValue()))
        )
        (§ return (§ expr nil))
    )

    #_public
    (§ method V put(K k, V v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Object ret = map.valAt(k))
        (§ call r.set(map.assoc(k, v)))
        (§ return (§ expr (V) ret))
    )

    #_public
    (§ method V remove(Object k)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Object ret = map.valAt(k))
        (§ call r.set(map.without(k)))
        (§ return (§ expr (V) ret))
    )

    #_public
    (§ method void putAll(Map<? extends K, ? extends V> map)
        (§ for (Iterator i = map.entrySet().iterator() i.hasNext() ))
        (§
            (§ let Entry<K, V> e = (Entry) i.next())
            (§ call put(e.getKey(), e.getValue()))
        )
    )

    #_public
    (§ method void clear()
        (§ for (int i = 0 i < bins.length i++))
        (§
            (§ let Ref r = bins[i])
            (§ let IPersistentMap map = (IPersistentMap) r.deref())
            (§ if (map.count() > 0))
            (§
                (§ call r.set(PersistentHashMap.EMPTY))
            )
        )
    )

    #_public
    (§ method Set<Entry<K, V>> entrySet()
        (§ let final ArrayList<Map.Entry<K, V>> entries = new ArrayList(bins.length))
        (§ for (int i = 0 i < bins.length i++))
        (§
            (§ let IPersistentMap map = mapAt(i))
            (§ if (map.count() > 0))
            (§
                (§ call entries.addAll((Collection) RT.seq(map)))
            )
        )
        (§ return (§ expr new AbstractSet<Entry<K, V>>()
        (§
            #_public
            (§ method Iterator iterator()
                (§ return (§ expr Collections.unmodifiableList(entries).iterator()))
            )

            #_public
            (§ method int size()
                (§ return (§ expr entries.size()))
            )
        )))
    )

    #_public
    (§ method V putIfAbsent(K k, V v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (e == nil))
        (§
            (§ call r.set(map.assoc(k, v)))
            (§ return (§ expr nil))
        )
        (§ else )
        (§
            (§ return (§ expr (V) e.getValue()))
        )
    )

    #_public
    (§ method boolean remove(Object k, Object v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (e != nil && e.getValue().equals(v)))
        (§
            (§ call r.set(map.without(k)))
            (§ return (§ expr true))
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method boolean replace(K k, V oldv, V newv)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (e != nil && e.getValue().equals(oldv)))
        (§
            (§ call r.set(map.assoc(k, newv)))
            (§ return (§ expr true))
        )
        (§ return (§ expr false))
    )

    #_public
    (§ method V replace(K k, V v)
        (§ let Ref r = bins[binFor(k)])
        (§ let IPersistentMap map = (IPersistentMap) r.deref())
        (§ let Entry e = map.entryAt(k))
        (§ if (e != nil))
        (§
            (§ call r.set(map.assoc(k, v)))
            (§ return (§ expr (V) e.getValue()))
        )
        (§ return (§ expr nil))
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_public
(class-ns TransformerIterator (§ implements Iterator)
    #_private
    #_static
    #_final
    (§ field Buffer EMPTY = new Empty())
    #_private
    #_static
    #_final
    (§ field Object NONE = new Object())

    ;; Source
    #_private
    #_final
    (§ field Iterator sourceIter)
    #_private
    #_final
    (§ field IFn xf)
    #_private
    #_final
    (§ field boolean multi)

    ;; Iteration state
    #_private
    #_volatile
    (§ field Buffer buffer = EMPTY)
    #_private
    #_volatile
    (§ field Object next = NONE)
    #_private
    #_volatile
    (§ field boolean completed = false)

    #_private
    (§ method TransformerIterator(IFn xform, Iterator sourceIter, boolean multi)
        (§ ass this.sourceIter = sourceIter)
        (§ ass this.xf = (IFn) xform.invoke(new AFn()
        (§ inner
            #_public
            (§ method Object invoke()
                (§ return (§ expr nil))
            )

            #_public
            (§ method Object invoke(Object acc)
                (§ return (§ expr acc))
            )

            #_public
            (§ method Object invoke(Object acc, Object o)
                (§ ass buffer = buffer.add(o))
                (§ return (§ expr acc))
            )
        )))
        (§ ass this.multi = multi)
    )

    #_public
    #_static
    (§ method Iterator create(IFn xform, Iterator source)
        (§ return (§ expr new TransformerIterator(xform, source, false)))
    )

    #_public
    #_static
    (§ method Iterator createMulti(IFn xform, List sources)
        (§ let Iterator[] iters = new Iterator[sources.size()])
        (§ for (int i = 0 i < sources.size() i++))
        (§
            (§ ass iters[i] = (Iterator)sources.get(i))
        )
        (§ return (§ expr new TransformerIterator(xform, new MultiIterator(iters), true)))
    )

    #_private
    (§ method boolean step()
        (§ if (next != NONE))
        (§
            (§ return (§ expr true))
        )

        (§ while (next == NONE))
        (§
            (§ if (buffer.isEmpty()))
            (§
                (§ if (completed))
                (§
                    (§ return (§ expr false))
                )
                (§ elseif (sourceIter.hasNext()))
                (§
                    (§ let Object iter = nil)
                    (§ if (multi))
                    (§
                        (§ ass iter = xf.applyTo(RT.cons(nil, sourceIter.next())))
                    )
                    (§ else )
                    (§
                        (§ ass iter = xf.invoke(nil, sourceIter.next()))
                    )

                    (§ if (RT.isReduced(iter)))
                    (§
                        (§ call xf.invoke(nil))
                        (§ ass completed = true)
                    )
                )
                (§ else )
                (§
                    (§ call xf.invoke(nil))
                    (§ ass completed = true)
                )
            )
            (§ else )
            (§
                (§ ass next = buffer.remove())
            )
        )
        (§ return (§ expr true))
    )

    #_public
    (§ method boolean hasNext()
        (§ return (§ expr step()))
    )

    #_public
    (§ method Object next()
        (§ if (hasNext()))
        (§
            (§ let Object ret = next)
            (§ ass next = NONE)
            (§ return (§ expr ret))
        )
        (§ throw new NoSuchElementException())
    )

    #_public
    (§ method void remove()
        (§ throw new UnsupportedOperationException())
    )

    #_private
    #_static
    (§ interface Buffer
        (§ abstract Buffer add(Object o))
        (§ abstract Object remove())
        (§ abstract boolean isEmpty())
    )

    #_private
    #_static
    (class-ns Empty (§ implements Buffer)
        #_public
        (§ method Buffer add(Object o)
            (§ return (§ expr new Single(o)))
        )

        #_public
        (§ method Object remove()
            (§ throw new IllegalStateException("Removing object from empty buffer"))
        )

        #_public
        (§ method boolean isEmpty()
            (§ return (§ expr true))
        )

        #_public
        (§ method String toString()
            (§ return (§ expr "Empty"))
        )
    )

    #_private
    #_static
    (class-ns Single (§ implements Buffer)
        #_private
        #_volatile
        (§ field Object val)

        #_public
        (§ method Single(Object o)
            (§ ass this.val = o)
        )

        #_public
        (§ method Buffer add(Object o)
            (§ if (val == NONE))
            (§
                (§ ass val = o)
                (§ return (§ expr this))
            )
            (§ else )
            (§
                (§ return (§ expr new Many(val, o)))
            )
        )

        #_public
        (§ method Object remove()
            (§ if (val == NONE))
            (§
                (§ throw new IllegalStateException("Removing object from empty buffer"))
            )
            (§ let Object ret = val)
            (§ ass val = NONE)
            (§ return (§ expr ret))
        )

        #_public
        (§ method boolean isEmpty()
            (§ return (§ expr (val == NONE)))
        )

        #_public
        (§ method String toString()
            (§ return (§ expr "Single: " + val))
        )
    )

    #_private
    #_static
    (class-ns Many (§ implements Buffer)
        #_private
        #_final
        (§ field Queue vals = new LinkedList())

        #_public
        (§ method Many(Object o1, Object o2)
            (§ call vals.add(o1))
            (§ call vals.add(o2))
        )

        #_public
        (§ method Buffer add(Object o)
            (§ call vals.add(o))
            (§ return (§ expr this))
        )

        #_public
        (§ method Object remove()
            (§ return (§ expr vals.remove()))
        )

        #_public
        (§ method boolean isEmpty()
            (§ return (§ expr vals.isEmpty()))
        )

        #_public
        (§ method String toString()
            (§ return (§ expr "Many: " + vals.toString()))
        )
    )

    #_private
    #_static
    (class-ns MultiIterator (§ implements Iterator)
        #_private
        #_final
        (§ field Iterator[] iters)

        #_public
        (§ method MultiIterator(Iterator[] iters)
            (§ ass this.iters = iters)
        )

        #_public
        (§ method boolean hasNext()
            (§ for (Iterator iter :in iters))
            (§
                (§ if (!iter.hasNext()))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )

        #_public
        (§ method Object next()
            (§ let Object[] nexts = new Object[iters.length])
            (§ for (int i = 0 i < iters.length i++))
            (§
                (§ ass nexts[i] = iters[i].next())
            )
            (§ return (§ expr new ArraySeq(nexts, 0)))
        )

        #_public
        (§ method void remove()
            (§ throw new UnsupportedOperationException())
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_public
(class-ns Tuple
    #_static
    #_final
    (§ field int MAX_SIZE = 6)

    #_public
    #_static
    (§ method IPersistentVector create()
        (§ return (§ expr PersistentVector.EMPTY))
    )

    #_public
    #_static
    (§ method IPersistentVector create(Object v0)
        (§ return (§ expr RT.vector(v0)))
    )

    #_public
    #_static
    (§ method IPersistentVector create(Object v0, Object v1)
        (§ return (§ expr RT.vector(v0, v1)))
    )

    #_public
    #_static
    (§ method IPersistentVector create(Object v0, Object v1, Object v2)
        (§ return (§ expr RT.vector(v0, v1, v2)))
    )

    #_public
    #_static
    (§ method IPersistentVector create(Object v0, Object v1, Object v2, Object v3)
        (§ return (§ expr RT.vector(v0, v1, v2, v3)))
    )

    #_public
    #_static
    (§ method IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4)
        (§ return (§ expr RT.vector(v0, v1, v2, v3, v4)))
    )

    #_public
    #_static
    (§ method IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4, Object v5)
        (§ return (§ expr RT.vector(v0, v1, v2, v3, v4, v5)))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

#_public
(class-ns Util
    #_static
    #_public
    (§ method boolean equiv(Object k1, Object k2)
        (§ if (k1 == k2))
        (§
            (§ return (§ expr true))
        )
        (§ if (k1 != nil))
        (§
            (§ if (k1 instanceof Number && k2 instanceof Number))
            (§
                (§ return (§ expr Numbers.equal((Number)k1, (Number)k2)))
            )
            (§ elseif (k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection))
            (§
                (§ return (§ expr pcequiv(k1, k2)))
            )
            (§ return (§ expr k1.equals(k2)))
        )
        (§ return (§ expr false))
    )

    #_public
    (§ interface EquivPred
        (§ abstract boolean equiv(Object k1, Object k2))
    )

    #_static
    (§ field EquivPred equivNull = new EquivPred()
    (§ inner
        #_public
        (§ method boolean equiv(Object k1, Object k2)
            (§ return (§ expr (k2 == nil)))
        )
    ))

    #_static
    (§ field EquivPred equivEquals = new EquivPred()
    (§ inner
        #_public
        (§ method boolean equiv(Object k1, Object k2)
            (§ return (§ expr k1.equals(k2)))
        )
    ))

    #_static
    (§ field EquivPred equivNumber = new EquivPred()
    (§ inner
        #_public
        (§ method boolean equiv(Object k1, Object k2)
            (§ if (k2 instanceof Number))
            (§
                (§ return (§ expr Numbers.equal((Number) k1, (Number) k2)))
            )
            (§ return (§ expr false))
        )
    ))

    #_static
    (§ field EquivPred equivColl = new EquivPred()
    (§ inner
        #_public
        (§ method boolean equiv(Object k1, Object k2)
            (§ if (k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection))
            (§
                (§ return (§ expr pcequiv(k1, k2)))
            )
            (§ return (§ expr k1.equals(k2)))
        )
    ))

    #_static
    #_public
    (§ method EquivPred equivPred(Object k1)
        (§ if (k1 == nil))
        (§
            (§ return (§ expr equivNull))
        )
        (§ elseif (k1 instanceof Number))
        (§
            (§ return (§ expr equivNumber))
        )
        (§ elseif (k1 instanceof String || k1 instanceof Symbol))
        (§
            (§ return (§ expr equivEquals))
        )
        (§ elseif (k1 instanceof Collection || k1 instanceof Map))
        (§
            (§ return (§ expr equivColl))
        )
        (§ return (§ expr equivEquals))
    )

    #_static
    #_public
    (§ method boolean equiv(long k1, long k2)
        (§ return (§ expr (k1 == k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(Object k1, long k2)
        (§ return (§ expr equiv(k1, (Object)k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(long k1, Object k2)
        (§ return (§ expr equiv((Object)k1, k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(double k1, double k2)
        (§ return (§ expr (k1 == k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(Object k1, double k2)
        (§ return (§ expr equiv(k1, (Object)k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(double k1, Object k2)
        (§ return (§ expr equiv((Object)k1, k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(boolean k1, boolean k2)
        (§ return (§ expr (k1 == k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(Object k1, boolean k2)
        (§ return (§ expr equiv(k1, (Object)k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(boolean k1, Object k2)
        (§ return (§ expr equiv((Object)k1, k2)))
    )

    #_static
    #_public
    (§ method boolean equiv(char c1, char c2)
        (§ return (§ expr (c1 == c2)))
    )

    #_static
    #_public
    (§ method boolean pcequiv(Object k1, Object k2)
        (§ if (k1 instanceof IPersistentCollection))
        (§
            (§ return (§ expr ((IPersistentCollection)k1).equiv(k2)))
        )
        (§ return (§ expr ((IPersistentCollection)k2).equiv(k1)))
    )

    #_static
    #_public
    (§ method boolean equals(Object k1, Object k2)
        (§ if (k1 == k2))
        (§
            (§ return (§ expr true))
        )
        (§ return (§ expr (k1 != nil && k1.equals(k2))))
    )

    #_static
    #_public
    (§ method boolean identical(Object k1, Object k2)
        (§ return (§ expr (k1 == k2)))
    )

    #_static
    #_public
    (§ method Class classOf(Object x)
        (§ if (x != nil))
        (§
            (§ return (§ expr x.getClass()))
        )
        (§ return (§ expr nil))
    )

    #_static
    #_public
    (§ method int compare(Object k1, Object k2)
        (§ if (k1 == k2))
        (§
            (§ return (§ expr 0))
        )
        (§ if (k1 != nil))
        (§
            (§ if (k2 == nil))
            (§
                (§ return (§ expr 1))
            )
            (§ if (k1 instanceof Number))
            (§
                (§ return (§ expr Numbers.compare((Number) k1, (Number) k2)))
            )
            (§ return (§ expr ((Comparable) k1).compareTo(k2)))
        )
        (§ return (§ expr -1))
    )

    #_static
    #_public
    (§ method int hash(Object o)
        (§ if (o == nil))
        (§
            (§ return (§ expr 0))
        )
        (§ return (§ expr o.hashCode()))
    )

    #_public
    #_static
    (§ method int hasheq(Object o)
        (§ if (o == nil))
        (§
            (§ return (§ expr 0))
        )
        (§ if (o instanceof IHashEq))
        (§
            (§ return (§ expr dohasheq((IHashEq) o)))
        )
        (§ if (o instanceof Number))
        (§
            (§ return (§ expr Numbers.hasheq((Number)o)))
        )
        (§ if (o instanceof String))
        (§
            (§ return (§ expr Murmur3.hashInt(o.hashCode())))
        )
        (§ return (§ expr o.hashCode()))
    )

    #_private
    #_static
    (§ method int dohasheq(IHashEq o)
        (§ return (§ expr o.hasheq()))
    )

    #_static
    #_public
    (§ method int hashCombine(int seed, int hash)
        ;; a la boost
        (§ ass seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2))
        (§ return (§ expr seed))
    )

    #_static
    #_public
    (§ method boolean isPrimitive(Class c)
        (§ return (§ expr (c != nil && c.isPrimitive() && !(c == Void.TYPE))))
    )

    #_static
    #_public
    (§ method boolean isInteger(Object x)
        (§ return (§ expr (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger)))
    )

    #_static
    #_public
    (§ method Object ret1(Object ret, Object nil)
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method ISeq ret1(ISeq ret, Object nil)
        (§ return (§ expr ret))
    )

    #_static
    #_public
    (§ method <K, V> void clearCache(ReferenceQueue rq, ConcurrentHashMap<K, Reference<V>> cache)
        ;; cleanup any dead entries
        (§ if (rq.poll() != nil))
        (§
            (§ while (rq.poll() != nil))
            (§
            )
            (§ for (Map.Entry<K, Reference<V>> e :in cache.entrySet()))
            (§
                (§ let Reference<V> val = e.getValue())
                (§ if (val != nil && val.get() == nil))
                (§
                    (§ call cache.remove(e.getKey(), val))
                )
            )
        )
    )

    #_static
    #_public
    (§ method RuntimeException runtimeException(String s)
        (§ return (§ expr new RuntimeException(s)))
    )

    #_static
    #_public
    (§ method RuntimeException runtimeException(String s, Throwable e)
        (§ return (§ expr new RuntimeException(s, e)))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    #_static
    #_public
    (§ method RuntimeException sneakyThrow(Throwable t)
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (§ if (t == nil))
        (§
            (§ throw new NullPointerException())
        )
        (§ call Util.<RuntimeException>sneakyThrow0(t))
        (§ return (§ expr nil))
    )

    (§ anno @SuppressWarnings("unchecked"))
    #_static
    #_private
    (§ method <T extends Throwable> void sneakyThrow0(Throwable t) (§ throws T)
        (§ throw (T) t)
    )

    #_static
    #_public
    (§ method Object loadWithClass(String scriptbase, Class<?> loadFrom) (§ throws IOException, ClassNotFoundException)
        (§ call Var.pushThreadBindings(RT.map(new Object[] (§ Compiler.LOADER, loadFrom.getClassLoader() ))))
        (§ try )
        (§
            (§ return (§ expr RT.var("cloiure.core", "load").invoke(scriptbase)))
        )
        (§ finally )
        (§
            (§ call Var.popThreadBindings())
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

#_public
#_final
(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    #_static
    (class-ns TBox
        #_volatile
        (§ field Object val)
        #_final
        (§ field Thread thread)

        #_public
        (§ method TBox(Thread t, Object val)
            (§ ass this.thread = t)
            (§ ass this.val = val)
        )
    )

    #_static
    #_public
    (class-ns Unbound (§ extends AFn)
        #_final
        #_public
        (§ field Var v)

        #_public
        (§ method Unbound(Var v)
            (§ ass this.v = v)
        )

        #_public
        (§ method String toString()
            (§ return (§ expr "Unbound: " + v))
        )

        #_public
        (§ method Object throwArity(int n)
            (§ throw new IllegalStateException("Attempting to call unbound fn: " + v))
        )
    )

    #_static
    (class-ns Frame
        #_final
        #_static
        (§ field Frame TOP = new Frame(PersistentHashMap.EMPTY, nil))
        ;; Var->TBox
        (§ field Associative bindings)
        ;; Var->val
        (§ field Frame prev)

        #_public
        (§ method Frame(Associative bindings, Frame prev)
            (§ ass this.bindings = bindings)
            (§ ass this.prev = prev)
        )

        #_protected
        (§ method Object clone()
            (§ return (§ expr new Frame(this.bindings, nil)))
        )
    )

    #_static
    #_final
    (§ field ThreadLocal<Frame> dvals = new ThreadLocal<Frame>()
    (§ inner
        #_protected
        (§ method Frame initialValue()
            (§ return (§ expr Frame.TOP))
        )
    ))

    #_static
    #_public
    #_volatile
    (§ field int rev = 0)

    #_static
    (§ field Keyword privateKey = Keyword.intern(nil, "private"))
    #_static
    (§ field IPersistentMap privateMeta = new PersistentArrayMap(new Object[] (§ privateKey, Boolean.TRUE )))
    #_static
    (§ field Keyword macroKey = Keyword.intern(nil, "macro"))
    #_static
    (§ field Keyword nameKey = Keyword.intern(nil, "name"))
    #_static
    (§ field Keyword nsKey = Keyword.intern(nil, "ns"))

    #_volatile
    (§ field Object root)

    #_volatile
    (§ field boolean dynamic = false)
    #_transient
    #_final
    (§ field AtomicBoolean threadBound)
    #_public
    #_final
    (§ field Symbol sym)
    #_public
    #_final
    (§ field Namespace ns)

    #_public
    #_static
    (§ method Object getThreadBindingFrame()
        (§ return (§ expr dvals.get()))
    )

    #_public
    #_static
    (§ method Object cloneThreadBindingFrame()
        (§ return (§ expr dvals.get().clone()))
    )

    #_public
    #_static
    (§ method void resetThreadBindingFrame(Object frame)
        (§ call dvals.set((Frame) frame))
    )

    #_public
    (§ method Var setDynamic()
        (§ ass this.dynamic = true)
        (§ return (§ expr this))
    )

    #_public
    (§ method Var setDynamic(boolean b)
        (§ ass this.dynamic = b)
        (§ return (§ expr this))
    )

    #_public
    #_final
    (§ method boolean isDynamic()
        (§ return (§ expr dynamic))
    )

    #_public
    #_static
    (§ method Var intern(Namespace ns, Symbol sym, Object root)
        (§ return (§ expr intern(ns, sym, root, true)))
    )

    #_public
    #_static
    (§ method Var intern(Namespace ns, Symbol sym, Object root, boolean replaceRoot)
        (§ let Var dvout = ns.intern(sym))
        (§ if (!dvout.hasRoot() || replaceRoot))
        (§
            (§ call dvout.bindRoot(root))
        )
        (§ return (§ expr dvout))
    )

    #_public
    (§ method String toString()
        (§ if (ns != nil))
        (§
            (§ return (§ expr "#'" + ns.name + "/" + sym))
        )
        (§ return (§ expr "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">"))
    )

    #_public
    #_static
    (§ method Var find(Symbol nsQualifiedSym)
        (§ if (nsQualifiedSym.ns == nil))
        (§
            (§ throw new IllegalArgumentException("Symbol must be namespace-qualified"))
        )
        (§ let Namespace ns = Namespace.find(Symbol.intern(nsQualifiedSym.ns)))
        (§ if (ns == nil))
        (§
            (§ throw new IllegalArgumentException("No such namespace: " + nsQualifiedSym.ns))
        )
        (§ return (§ expr ns.findInternedVar(Symbol.intern(nsQualifiedSym.name))))
    )

    #_public
    #_static
    (§ method Var intern(Symbol nsName, Symbol sym)
        (§ let Namespace ns = Namespace.findOrCreate(nsName))
        (§ return (§ expr intern(ns, sym)))
    )

    #_public
    #_static
    (§ method Var internPrivate(String nsName, String sym)
        (§ let Namespace ns = Namespace.findOrCreate(Symbol.intern(nsName)))
        (§ let Var ret = intern(ns, Symbol.intern(sym)))
        (§ call ret.setMeta(privateMeta))
        (§ return (§ expr ret))
    )

    #_public
    #_static
    (§ method Var intern(Namespace ns, Symbol sym)
        (§ return (§ expr ns.intern(sym)))
    )

    #_public
    #_static
    (§ method Var create()
        (§ return (§ expr new Var(nil, nil)))
    )

    #_public
    #_static
    (§ method Var create(Object root)
        (§ return (§ expr new Var(nil, nil, root)))
    )

    (§ method Var(Namespace ns, Symbol sym)
        (§ ass this.ns = ns)
        (§ ass this.sym = sym)
        (§ ass this.threadBound = new AtomicBoolean(false))
        (§ ass this.root = new Unbound(this))
        (§ call setMeta(PersistentHashMap.EMPTY))
    )

    (§ method Var(Namespace ns, Symbol sym, Object root)
        (§ this(ns, sym))
        (§ ass this.root = root)
        (§ ass ++rev)
    )

    #_public
    (§ method boolean isBound()
        (§ return (§ expr (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this)))))
    )

    #_final
    #_public
    (§ method Object get()
        (§ if (!threadBound.get()))
        (§
            (§ return (§ expr root))
        )
        (§ return (§ expr deref()))
    )

    #_final
    #_public
    (§ method Object deref()
        (§ let TBox b = getThreadBinding())
        (§ if (b != nil))
        (§
            (§ return (§ expr b.val))
        )
        (§ return (§ expr root))
    )

    #_public
    (§ method void setValidator(IFn vf)
        (§ if (hasRoot()))
        (§
            (§ call validate(vf, root))
        )
        (§ ass validator = vf)
    )

    #_public
    (§ method Object alter(IFn fn, ISeq args)
        (§ call set(fn.applyTo(RT.cons(deref(), args))))
        (§ return (§ expr this))
    )

    #_public
    (§ method Object set(Object val)
        (§ call validate(getValidator(), val))
        (§ let TBox b = getThreadBinding())
        (§ if (b != nil))
        (§
            (§ if (Thread.currentThread() != b.thread))
            (§
                (§ throw new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym)))
            )
            (§ return (§ expr (b.val = val)))
        )
        (§ throw new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym)))
    )

    #_public
    (§ method Object doSet(Object val)
        (§ return (§ expr set(val)))
    )

    #_public
    (§ method Object doReset(Object val)
        (§ call bindRoot(val))
        (§ return (§ expr val))
    )

    #_public
    (§ method void setMeta(IPersistentMap m)
        ;; ensure these basis keys
        (§ call resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns)))
    )

    #_public
    (§ method void setMacro()
        (§ call alterMeta(assoc, RT.list(macroKey, RT.T)))
    )

    #_public
    (§ method boolean isMacro()
        (§ return (§ expr RT.booleanCast(meta().valAt(macroKey))))
    )

    #_public
    (§ method boolean isPublic()
        (§ return (§ expr !RT.booleanCast(meta().valAt(privateKey))))
    )

    #_final
    #_public
    (§ method Object getRawRoot()
        (§ return (§ expr root))
    )

    #_public
    (§ method Object getTag()
        (§ return (§ expr meta().valAt(RT.TAG_KEY)))
    )

    #_public
    (§ method void setTag(Symbol tag)
        (§ call alterMeta(assoc, RT.list(RT.TAG_KEY, tag)))
    )

    #_final
    #_public
    (§ method boolean hasRoot()
        (§ return (§ expr !(root instanceof Unbound)))
    )

    ;; binding root always clears macro flag
    #_synchronized
    #_public
    (§ method void bindRoot(Object root)
        (§ call validate(getValidator(), root))
        (§ let Object oldroot = this.root)
        (§ ass this.root = root)
        (§ ass ++rev)
        (§ call alterMeta(dissoc, RT.list(macroKey)))
        (§ call notifyWatches(oldroot, this.root))
    )

    #_synchronized
    (§ method void swapRoot(Object root)
        (§ call validate(getValidator(), root))
        (§ let Object oldroot = this.root)
        (§ ass this.root = root)
        (§ ass ++rev)
        (§ call notifyWatches(oldroot, root))
    )

    #_synchronized
    #_public
    (§ method void unbindRoot()
        (§ ass this.root = new Unbound(this))
        (§ ass ++rev)
    )

    #_synchronized
    #_public
    (§ method void commuteRoot(IFn fn)
        (§ let Object newRoot = fn.invoke(root))
        (§ call validate(getValidator(), newRoot))
        (§ let Object oldroot = root)
        (§ ass this.root = newRoot)
        (§ ass ++rev)
        (§ call notifyWatches(oldroot, newRoot))
    )

    #_synchronized
    #_public
    (§ method Object alterRoot(IFn fn, ISeq args)
        (§ let Object newRoot = fn.applyTo(RT.cons(root, args)))
        (§ call validate(getValidator(), newRoot))
        (§ let Object oldroot = root)
        (§ ass this.root = newRoot)
        (§ ass ++rev)
        (§ call notifyWatches(oldroot, newRoot))
        (§ return (§ expr newRoot))
    )

    #_public
    #_static
    (§ method void pushThreadBindings(Associative bindings)
        (§ let Frame f = dvals.get())
        (§ let Associative bmap = f.bindings)
        (§ for (ISeq bs = bindings.seq() bs != nil bs = bs.next()))
        (§
            (§ let IMapEntry e = (IMapEntry) bs.first())
            (§ let Var v = (Var) e.key())
            (§ if (!v.dynamic))
            (§
                (§ throw new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym)))
            )
            (§ call v.validate(v.getValidator(), e.val()))
            (§ call v.threadBound.set(true))
            (§ ass bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val())))
        )
        (§ call dvals.set(new Frame(bmap, f)))
    )

    #_public
    #_static
    (§ method void popThreadBindings()
        (§ let Frame f = dvals.get().prev)
        (§ if (f == nil))
        (§
            (§ throw new IllegalStateException("Pop without matching push"))
        )
        (§ elseif (f == Frame.TOP))
        (§
            (§ call dvals.remove())
        )
        (§ else )
        (§
            (§ call dvals.set(f))
        )
    )

    #_public
    #_static
    (§ method Associative getThreadBindings()
        (§ let Frame f = dvals.get())
        (§ let IPersistentMap ret = PersistentHashMap.EMPTY)
        (§ for (ISeq bs = f.bindings.seq() bs != nil bs = bs.next()))
        (§
            (§ let IMapEntry e = (IMapEntry) bs.first())
            (§ let Var v = (Var) e.key())
            (§ let TBox b = (TBox) e.val())
            (§ ass ret = ret.assoc(v, b.val))
        )
        (§ return (§ expr ret))
    )

    #_public
    #_final
    (§ method TBox getThreadBinding()
        (§ if (threadBound.get()))
        (§
            (§ let IMapEntry e = dvals.get().bindings.entryAt(this))
            (§ if (e != nil))
            (§
                (§ return (§ expr (TBox) e.val()))
            )
        )
        (§ return (§ expr nil))
    )

    #_final
    #_public
    (§ method IFn fn()
        (§ return (§ expr (IFn) deref()))
    )

    #_public
    (§ method Object call()
        (§ return (§ expr invoke()))
    )

    #_public
    (§ method void run()
        (§ call invoke())
    )

    #_public
    (§ method Object invoke()
        (§ return (§ expr fn().invoke()))
    )

    #_public
    (§ method Object invoke(Object arg1)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil),
          #_arg Util.ret1(arg16, arg16 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil),
          #_arg Util.ret1(arg16, arg16 = nil),
          #_arg Util.ret1(arg17, arg17 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil),
          #_arg Util.ret1(arg16, arg16 = nil),
          #_arg Util.ret1(arg17, arg17 = nil),
          #_arg Util.ret1(arg18, arg18 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil),
          #_arg Util.ret1(arg16, arg16 = nil),
          #_arg Util.ret1(arg17, arg17 = nil),
          #_arg Util.ret1(arg18, arg18 = nil),
          #_arg Util.ret1(arg19, arg19 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil),
          #_arg Util.ret1(arg16, arg16 = nil),
          #_arg Util.ret1(arg17, arg17 = nil),
          #_arg Util.ret1(arg18, arg18 = nil),
          #_arg Util.ret1(arg19, arg19 = nil),
          #_arg Util.ret1(arg20, arg20 = nil))))
    )

    #_public
    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
      #_arg Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
      #_arg Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
      #_arg Object... args))
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
          #_arg Util.ret1(arg2, arg2 = nil),
          #_arg Util.ret1(arg3, arg3 = nil),
          #_arg Util.ret1(arg4, arg4 = nil),
          #_arg Util.ret1(arg5, arg5 = nil),
          #_arg Util.ret1(arg6, arg6 = nil),
          #_arg Util.ret1(arg7, arg7 = nil),
          #_arg Util.ret1(arg8, arg8 = nil),
          #_arg Util.ret1(arg9, arg9 = nil),
          #_arg Util.ret1(arg10, arg10 = nil),
          #_arg Util.ret1(arg11, arg11 = nil),
          #_arg Util.ret1(arg12, arg12 = nil),
          #_arg Util.ret1(arg13, arg13 = nil),
          #_arg Util.ret1(arg14, arg14 = nil),
          #_arg Util.ret1(arg15, arg15 = nil),
          #_arg Util.ret1(arg16, arg16 = nil),
          #_arg Util.ret1(arg17, arg17 = nil),
          #_arg Util.ret1(arg18, arg18 = nil),
          #_arg Util.ret1(arg19, arg19 = nil),
          #_arg Util.ret1(arg20, arg20 = nil),
                (Object[])Util.ret1(args, args = nil))))
    )

    #_public
    (§ method Object applyTo(ISeq arglist)
        (§ return (§ expr fn().applyTo(arglist)))
    )

    #_static
    (§ field IFn assoc = new AFn()
    (§ inner
        (§ anno @Override)
        #_public
        (§ method Object invoke(Object m, Object k, Object v)
            (§ return (§ expr RT.assoc(m, k, v)))
        )
    ))

    #_static
    (§ field IFn dissoc = new AFn()
    (§ inner
        (§ anno @Override)
        #_public
        (§ method Object invoke(Object c, Object k)
            (§ return (§ expr RT.dissoc(c, k)))
        )
    ))
)
)

(java-ns cloiure.lang.Volatile

#_final
#_public
(class-ns Volatile (§ implements IDeref)
    #_volatile
    (§ field Object val)

    #_public
    (§ method Volatile(Object val)
        (§ ass this.val = val)
    )

    #_public
    (§ method Object deref()
        (§ return (§ expr val))
    )

    #_public
    (§ method Object reset(Object newval)
        (§ return (§ expr this.val = newval))
    )
)
)

(java-ns cloiure.lang.WarnBoxedMath

(§ import java.lang.annotation.Retention)
(§ import java.lang.annotation.RetentionPolicy)
(§ import java.lang.annotation.ElementType)
(§ import java.lang.annotation.Target)

(§ anno @Retention(RetentionPolicy.RUNTIME))
(§ anno @Target(ElementType.METHOD))
(§ @interface public @interface WarnBoxedMath)
(§
    (§ @abstract boolean value() default true)
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_public
(class-ns main
    #_final
    #_static
    #_private
    (§ field Symbol CLOIURE_MAIN = Symbol.intern("cloiure.main"))
    #_final
    #_static
    #_private
    (§ field Var REQUIRE = RT.var("cloiure.core", "require"))
    #_final
    #_static
    #_private
    (§ field Var MAIN = RT.var("cloiure.main", "main"))

    #_public
    #_static
    (§ method void main(String[] args)
        (§ call REQUIRE.invoke(CLOIURE_MAIN))
        (§ call MAIN.applyTo(RT.seq(args)))
    )
)
)
