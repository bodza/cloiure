(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

#_abstract
(class-ns AFn (§ implements IFn)
    #_method
    (§ defn #_"Object" call [this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [this]
        (ß throwArity(0))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß throwArity(1))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2]
        (ß throwArity(2))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß throwArity(3))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß throwArity(4))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß throwArity(5))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß throwArity(6))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß throwArity(7))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß throwArity(8))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß throwArity(9))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß throwArity(10))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß throwArity(11))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß throwArity(12))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß throwArity(13))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß throwArity(14))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß throwArity(15))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß throwArity(16))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß throwArity(17))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß throwArity(18))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß throwArity(19))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß throwArity(20))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß throwArity(21))
    )

    #_method
    (§ defn #_"Object" applyTo [this, #_"ISeq" arglist]
        (ß applyToHelper(this, Util.ret1(arglist, arglist = nil)))
    )

    (§ defn #_"Object" applyToHelper [#_"IFn" ifn, #_"ISeq" arglist]
        (§ switch (ß RT.boundedLength(arglist, 20))
            (§ case 0)
            (do
                (ß arglist = nil)
                (ß ifn.invoke())
            )
            (§ case 1)
            (do
                (ß ifn.invoke(Util.ret1(arglist.first(), arglist = nil)))
            )
            (§ case 2)
            (do
                (ß ifn.invoke(arglist.first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 3)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 4)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 5)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 6)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 7)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 8)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 9)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 10)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 11)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 12)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 13)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 14)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 15)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 16)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 17)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 18)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 19)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 20)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ default )
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        RT.seqToArray(Util.ret1(arglist.next(), arglist = nil))))
            )
        )
    )

    #_method
    (§ defn #_"Object" throwArity [this, #_"int" n]
        (let [#_"String" name (ß getClass().getSimpleName())]
            (throw (ß new ArityException(n, Compiler.demunge(name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    #_volatile
    (§ field #_"MethodImplCache" __methodImplCache)

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        nil
    )

    #_method
    (§ defn #_"IObj" withMeta [this, #_"IPersistentMap" meta]
        (ß new RestFn()
            (§ reify
                #_protected
                #_method
                (§ defn #_"Object" doInvoke [this, #_"Object" args]
                    (ß AFunction.this.applyTo((ISeq) args))
                )

                #_method
                (§ defn #_"IPersistentMap" meta [this]
                    meta
                )

                #_method
                (§ defn #_"IObj" withMeta [this, #_"IPersistentMap" meta]
                    (ß AFunction.this.withMeta(meta))
                )

                #_method
                (§ defn #_"int" getRequiredArity [this]
                    0
                )
            )
        )
    )

    #_method
    (§ defn #_"int" compare [this, #_"Object" o1, #_"Object" o2]
        (let [#_"Object" o (ß invoke(o1, o2))]
            (when (ß o instanceof Boolean)
                (when (ß RT.booleanCast(o))
                    (§ return -1)
                )
                (§ return (ß RT.booleanCast(invoke(o2, o1)) ? 1 :or 0))
            )

            (let [#_"Number" n (ß (Number) o)]
                (ß n.intValue())
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Agent (§ extends ARef)
    (class-ns ActionQueue
        (§ field #_"IPersistentStack" q)
        (§ field #_"Throwable" error) ;; non-null indicates fail state
        (§ def #_"ActionQueue" EMPTY (ß new ActionQueue(PersistentQueue.EMPTY, nil)))

        (§ constructor #_"ActionQueue" ActionQueue [#_"IPersistentStack" q, #_"Throwable" error]
            (ß this.q = q)
            (ß this.error = error)
            this
        )
    )

    (§ def #_"Keyword" CONTINUE (ß Keyword.intern(nil, "continue")))
    (§ def #_"Keyword" FAIL (ß Keyword.intern(nil, "fail")))

    #_volatile
    (§ field #_"Object" state)
    (§ field #_"AtomicReference<ActionQueue>" aq (ß new AtomicReference<ActionQueue>(ActionQueue.EMPTY)))

    #_volatile
    (§ field #_"Keyword" errorMode (ß CONTINUE))
    #_volatile
    (§ field #_"IFn" errorHandler (ß nil))

    (§ def- #_"AtomicLong" sendThreadPoolCounter (ß new AtomicLong(0)))

    (§ def- #_"AtomicLong" sendOffThreadPoolCounter (ß new AtomicLong(0)))

    #_volatile
    (§ def #_"ExecutorService" pooledExecutor (ß Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))))

    #_volatile
    (§ def #_"ExecutorService" soloExecutor (ß Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))))

    (§ def #_"ThreadLocal<IPersistentVector>" nested (ß new ThreadLocal<IPersistentVector>()))

    (§ defn- #_"ThreadFactory" createThreadFactory [#_"String" format, #_"AtomicLong" threadPoolCounter]
        (ß new ThreadFactory()
            (§ reify
                #_method
                (§ defn #_"Thread" newThread [this, #_"Runnable" runnable]
                    (let [#_"Thread" thread (ß new Thread(runnable))]
                        (ß thread.setName(String.format(format, threadPoolCounter.getAndIncrement())))
                        thread
                    )
                )
            )
        )
    )

    (§ defn #_"void" shutdown []
        (ß soloExecutor.shutdown())
        (ß pooledExecutor.shutdown())
        nil
    )

    (class-ns Action (§ implements Runnable)
        (§ field #_"Agent" agent)
        (§ field #_"IFn" fn)
        (§ field #_"ISeq" args)
        (§ field #_"Executor" exec)

        (§ constructor #_"Action" Action [#_"Agent" agent, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
            (ß this.agent = agent)
            (ß this.args = args)
            (ß this.fn = fn)
            (ß this.exec = exec)
            this
        )

        #_method
        (§ defn #_"void" execute [this]
            (try
                (ß exec.execute(this))
                (catch Throwable error
                    (when (ß agent.errorHandler != nil)
                        (try
                            (ß agent.errorHandler.invoke(agent, error))
                            (catch Throwable e
                                ;; ignore errorHandler errors
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn #_"void" doRun [#_"Action" action]
            (try
                (ß nested.set(PersistentVector.EMPTY))

                (let [#_"Throwable" error nil]
                    (try
                        (let [#_"Object" oldval (ß action.agent.state)]
                            (let [#_"Object" newval (ß  action.fn.applyTo(RT.cons(action.agent.state, action.args)))]
                                (ß action.agent.setState(newval))
                                (ß action.agent.notifyWatches(oldval, newval))
                            )
                        )
                        (catch Throwable e
                            (ß error = e)
                        )
                    )

                    (if (ß error == nil)
                        (do
                            (ß releasePendingSends())
                        )
                        (do
                            (ß nested.set(nil)) ;; allow errorHandler to send
                            (when (ß action.agent.errorHandler != nil)
                                (try
                                    (ß action.agent.errorHandler.invoke(action.agent, error))
                                    (catch Throwable e
                                        ;; ignore errorHandler errors
                                    )
                                )
                            )
                            (when (ß action.agent.errorMode == CONTINUE)
                                (ß error = nil)
                            )
                        )
                    )

                    (let [#_"boolean" popped false]
                        (let [#_"ActionQueue" next nil]
                            (while (ß !popped)
                                (let [#_"ActionQueue" prior (ß action.agent.aq.get())]
                                    (ß next = new ActionQueue(prior.q.pop(), error))
                                    (ß popped = action.agent.aq.compareAndSet(prior, next))
                                )
                            )

                            (when (ß error == nil && next.q.count() > 0)
                                (ß ((Action) next.q.peek()).execute())
                            )
                        )
                    )
                )
                (finally
                    (ß nested.set(nil))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" run [this]
            (ß doRun(this))
            nil
        )
    )

    (§ constructor #_"Agent" Agent [#_"Object" state]
        (§ this(state, nil))
        this
    )

    (§ constructor #_"Agent" Agent [#_"Object" state, #_"IPersistentMap" meta]
        (§ super(meta))
        (ß setState(state))
        this
    )

    #_method
    (§ defn #_"boolean" setState [this, #_"Object" newState]
        (ß validate(newState))
        (let [#_"boolean" ret (ß (state != newState))]
            (ß state = newState)
            ret
        )
    )

    #_method
    (§ defn #_"Object" deref [this]
        state
    )

    #_method
    (§ defn #_"Throwable" getError [this]
        (ß aq.get().error)
    )

    #_method
    (§ defn #_"void" setErrorMode [this, #_"Keyword" k]
        (ß errorMode = k)
        nil
    )

    #_method
    (§ defn #_"Keyword" getErrorMode [this]
        errorMode
    )

    #_method
    (§ defn #_"void" setErrorHandler [this, #_"IFn" f]
        (ß errorHandler = f)
        nil
    )

    #_method
    (§ defn #_"IFn" getErrorHandler [this]
        errorHandler
    )

    #_method
    (§ defn #_"Object" restart [this, #_"Object" newState, #_"boolean" clearActions]
        (§ sync this
            (when (ß getError() == nil)
                (throw (ß Util.runtimeException("Agent does not need a restart")))
            )
            (ß validate(newState))
            (ß state = newState)

            (if clearActions
                (do
                    (ß aq.set(ActionQueue.EMPTY))
                )
                (do
                    (let [#_"boolean" restarted false]
                        (let [#_"ActionQueue" prior nil]
                            (while (ß !restarted)
                                (ß prior = aq.get())
                                (ß restarted = aq.compareAndSet(prior, new ActionQueue(prior.q, nil)))
                            )

                            (when (ß prior.q.count() > 0)
                                (ß ((Action) prior.q.peek()).execute())
                            )
                        )
                    )
                )
            )

            newState
        )
    )

    #_method
    (§ defn #_"Object" dispatch [this, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let [#_"Throwable" error (ß getError())]
            (when (ß error != nil)
                (throw (ß Util.runtimeException("Agent is failed, needs restart", error)))
            )
            (let [#_"Action" action (ß new Action(this, fn, args, exec))]
                (ß dispatchAction(action))

                this
            )
        )
    )

    (§ defn #_"void" dispatchAction [#_"Action" action]
        (let [#_"LockingTransaction" trans (ß LockingTransaction.getRunning())]
            (cond (ß trans != nil)
                (do
                    (ß trans.enqueue(action))
                )
                (ß nested.get() != nil)
                (do
                    (ß nested.set(nested.get().cons(action)))
                )
                :else
                (do
                    (ß action.agent.enqueue(action))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" enqueue [this, #_"Action" action]
        (let [#_"boolean" queued false]
            (let [#_"ActionQueue" prior nil]
                (while (ß !queued)
                    (ß prior = aq.get())
                    (ß queued = aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error)))
                )

                (when (ß prior.q.count() == 0 && prior.error == nil)
                    (ß action.execute())
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" getQueueCount [this]
        (ß aq.get().q.count())
    )

    (§ defn #_"int" releasePendingSends []
        (let [#_"IPersistentVector" sends (ß nested.get())]
            (when (ß sends == nil)
                (§ return 0)
            )
            (loop-when-recur [(ß int i = 0)] (ß i < sends.count()) [(ß i++)]
                (let [#_"Action" a (ß (Action) sends.valAt(i))]
                    (ß a.agent.enqueue(a))
                )
            )
            (ß nested.set(PersistentVector.EMPTY))
            (ß sends.count())
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_method
    (§ defn #_"Object" nth [this, #_"int" i]
        (cond (ß i == 0)
            (do
                (ß key())
            )
            (ß i == 1)
            (do
                (ß val())
            )
            :else
            (do
                (throw (ß new IndexOutOfBoundsException()))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" asVector [this]
        (ß LazilyPersistentVector.createOwning(key(), val()))
    )

    #_method
    (§ defn #_"IPersistentVector" assocN [this, #_"int" i, #_"Object" val]
        (ß asVector().assocN(i, val))
    )

    #_method
    (§ defn #_"int" count [this]
        2
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (ß asVector().seq())
    )

    #_method
    (§ defn #_"IPersistentVector" cons [this, #_"Object" o]
        (ß asVector().cons(o))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" pop [this]
        (ß LazilyPersistentVector.createOwning(key()))
    )

    #_method
    (§ defn #_"Object" setValue [this, #_"Object" value]
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (§ field #_"int" _hash)
    (§ field #_"int" _hasheq)

    #_method
    (§ defn #_"String" toString [this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"IPersistentCollection" cons [this, #_"Object" o]
        (cond (ß o instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) o)]
                    (§ return (ß assoc(e.getKey(), e.getValue())))
                )
            )
            (ß o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
                    (when (ß v.count() != 2)
                        (throw (ß new IllegalArgumentException("Vector arg to map conj must be a pair")))
                    )
                    (§ return (ß assoc(v.nth(0), v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ret this]
            (loop-when-recur [(ß ISeq es = RT.seq(o))] (ß es != nil) [(ß es = es.next())]
                (let [(ß Map.Entry e = (Map.Entry) es.first())]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (ß mapEquals(this, obj))
    )

    (§ defn #_"boolean" mapEquals [#_"IPersistentMap" m1, #_"Object" obj]
        (when (ß m1 == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Map))
            (§ return false)
        )
        (let [#_"Map" m (ß (Map) obj)]
            (when (ß m.size() != m1.count())
                (§ return false)
            )

            (loop-when-recur [(ß ISeq s = m1.seq())] (ß s != nil) [(ß s = s.next())]
                (let [(ß Map.Entry e = (Map.Entry) s.first())]
                    (let [#_"boolean" found (ß m.containsKey(e.getKey()))]
                        (when (ß !found || !Util.equals(e.getValue(), m.get(e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (when (ß !(obj instanceof Map))
            (§ return false)
        )
        (when (ß obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
            (§ return false)
        )

        (let [#_"Map" m (ß (Map) obj)]
            (when (ß m.size() != size())
                (§ return false)
            )

            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (let [(ß Map.Entry e = (Map.Entry) s.first())]
                    (let [#_"boolean" found (ß m.containsKey(e.getKey()))]
                        (when (ß !found || !Util.equiv(e.getValue(), m.get(e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"int" cached (ß this._hash)]
            (when (ß cached == 0)
                (ß this._hash = cached = mapHash(this))
            )
            cached
        )
    )

    (§ defn #_"int" mapHash [#_"IPersistentMap" m]
        (let [#_"int" hash 0]
            (loop-when-recur [(ß ISeq s = m.seq())] (ß s != nil) [(ß s = s.next())]
                (let [(ß Map.Entry e = (Map.Entry) s.first())]
                    (ß hash += ((e.getKey() == nil) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == nil) ? 0 :or e.getValue().hashCode()))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (ß this._hasheq = cached = Murmur3.hashUnordered(this))
            )
            cached
        )
    )

    (§ defn #_"int" mapHasheq [#_"IPersistentMap" m]
        (ß Murmur3.hashUnordered(m))
    )

    (class-ns KeySeq (§ extends ASeq)
        (§ field #_"ISeq" seq)
        (§ field #_"Iterable" iterable)

        (§ defn #_"KeySeq" create [#_"ISeq" seq]
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß new KeySeq(seq, nil))
        )

        (§ defn #_"KeySeq" createFromMap [#_"IPersistentMap" map]
            (when (ß map == nil)
                (§ return nil)
            )
            (let [#_"ISeq" seq (ß map.seq())]
                (when (ß seq == nil)
                    (§ return nil)
                )
                (ß new KeySeq(seq, map))
            )
        )

        (§ constructor- #_"KeySeq" KeySeq [#_"ISeq" seq, #_"Iterable" iterable]
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ constructor- #_"KeySeq" KeySeq [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
            (§ super(meta))
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß ((Map.Entry) seq.first()).getKey())
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (ß create(seq.next()))
        )

        #_method
        (§ defn #_"KeySeq" withMeta [this, #_"IPersistentMap" meta]
            (ß new KeySeq(meta, seq, iterable))
        )

        #_method
        (§ defn #_"Iterator" iterator [this]
            (when (ß iterable == nil)
                (§ return (ß super.iterator()))
            )

            (when (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).keyIterator()))
            )

            (let [#_"Iterator" mapIter (ß iterable.iterator())]
                (ß new Iterator()
                    (§ reify
                        #_method
                        (§ defn #_"boolean" hasNext [this]
                            (ß mapIter.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [this]
                            (ß ((Map.Entry)mapIter.next()).getKey())
                        )

                        #_method
                        (§ defn #_"void" remove [this]
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
        )
    )

    (class-ns ValSeq (§ extends ASeq)
        (§ field #_"ISeq" seq)
        (§ field #_"Iterable" iterable)

        (§ defn #_"ValSeq" create [#_"ISeq" seq]
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß new ValSeq(seq, nil))
        )

        (§ defn #_"ValSeq" createFromMap [#_"IPersistentMap" map]
            (when (ß map == nil)
                (§ return nil)
            )
            (let [#_"ISeq" seq (ß map.seq())]
                (when (ß seq == nil)
                    (§ return nil)
                )
                (ß new ValSeq(seq, map))
            )
        )

        (§ constructor- #_"ValSeq" ValSeq [#_"ISeq" seq, #_"Iterable" iterable]
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ constructor- #_"ValSeq" ValSeq [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
            (§ super(meta))
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß ((Map.Entry) seq.first()).getValue())
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (ß create(seq.next()))
        )

        #_method
        (§ defn #_"ValSeq" withMeta [this, #_"IPersistentMap" meta]
            (ß new ValSeq(meta, seq, iterable))
        )

        #_method
        (§ defn #_"Iterator" iterator [this]
            (when (ß iterable == nil)
                (§ return (ß super.iterator()))
            )

            (when (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).valIterator()))
            )

            (let [#_"Iterator" mapIter (ß iterable.iterator())]
                (ß new Iterator()
                    (§ reify
                        #_method
                        (§ defn #_"boolean" hasNext [this]
                            (ß mapIter.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [this]
                            (ß ((Map.Entry)mapIter.next()).getValue())
                        )

                        #_method
                        (§ defn #_"void" remove [this]
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
        )
    )

    (§ def #_"IFn" MAKE_ENTRY (ß new AFn()
        (§ reify
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" key, #_"Object" val]
                (ß MapEntry.create(key, val))
            )
        )
    ))

    (§ def #_"IFn" MAKE_KEY (ß new AFn()
        (§ reify
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" key, #_"Object" val]
                key
            )
        )
    ))

    (§ def #_"IFn" MAKE_VAL (ß new AFn()
        (§ reify
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" key, #_"Object" val]
                val
            )
        )
    ))

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß valAt(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" notFound]
        (ß valAt(arg1, notFound))
    )

    #_method
    (§ defn #_"void" clear [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" containsValue [this, #_"Object" value]
        (ß values().contains(value))
    )

    #_method
    (§ defn #_"Set" entrySet [this]
        (ß new AbstractSet()
            (§ reify
                #_method
                (§ defn #_"Iterator" iterator [this]
                    (ß APersistentMap.this.iterator())
                )

                #_method
                (§ defn #_"int" size [this]
                    (ß count())
                )

                #_method
                (§ defn #_"int" hashCode [this]
                    (ß APersistentMap.this.hashCode())
                )

                #_method
                (§ defn #_"boolean" contains [this, #_"Object" o]
                    (when (ß o instanceof Entry)
                        (let [#_"Entry" e (ß (Entry) o)]
                            (let [#_"Entry" found (ß entryAt(e.getKey()))]
                                (when (ß found != nil && Util.equals(found.getValue(), e.getValue()))
                                    (§ return true)
                                )
                            )
                        )
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" get [this, #_"Object" key]
        (ß valAt(key))
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Set" keySet [this]
        (ß new AbstractSet()
            (§ reify
                #_method
                (§ defn #_"Iterator" iterator [this]
                    (let [#_"Iterator" mi (ß APersistentMap.this.iterator())]
                        (ß new Iterator()
                            (§ reify
                                #_method
                                (§ defn #_"boolean" hasNext [this]
                                    (ß mi.hasNext())
                                )

                                #_method
                                (§ defn #_"Object" next [this]
                                    (let [#_"Entry" e (ß (Entry) mi.next())]
                                        (ß e.getKey())
                                    )
                                )

                                #_method
                                (§ defn #_"void" remove [this]
                                    (throw (ß new UnsupportedOperationException()))
                                )
                            )
                        )
                    )
                )

                #_method
                (§ defn #_"int" size [this]
                    (ß count())
                )

                #_method
                (§ defn #_"boolean" contains [this, #_"Object" o]
                    (ß APersistentMap.this.containsKey(o))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" put [this, #_"Object" key, #_"Object" value]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" putAll [this, #_"Map" t]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"Object" remove [this, #_"Object" key]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"int" size [this]
        (ß count())
    )

    #_method
    (§ defn #_"Collection" values [this]
        (ß new AbstractCollection()
            (§ reify
                #_method
                (§ defn #_"Iterator" iterator [this]
                    (let [#_"Iterator" mi (ß APersistentMap.this.iterator())]
                        (ß new Iterator()
                            (§ reify
                                #_method
                                (§ defn #_"boolean" hasNext [this]
                                    (ß mi.hasNext())
                                )

                                #_method
                                (§ defn #_"Object" next [this]
                                    (let [#_"Entry" e (ß (Entry) mi.next())]
                                        (ß e.getValue())
                                    )
                                )

                                #_method
                                (§ defn #_"void" remove [this]
                                    (throw (ß new UnsupportedOperationException()))
                                )
                            )
                        )
                    )
                )

                #_method
                (§ defn #_"int" size [this]
                    (ß count())
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (§ field #_"int" _hash)
    (§ field #_"int" _hasheq)
    (§ field #_"IPersistentMap" impl)

    #_protected
    (§ constructor #_"APersistentSet" APersistentSet [#_"IPersistentMap" impl]
        (ß this.impl = impl)
        this
    )

    #_method
    (§ defn #_"String" toString [this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"boolean" contains [this, #_"Object" key]
        (ß impl.containsKey(key))
    )

    #_method
    (§ defn #_"Object" get [this, #_"Object" key]
        (ß impl.valAt(key))
    )

    #_method
    (§ defn #_"int" count [this]
        (ß impl.count())
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (ß RT.keys(impl))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß get(arg1))
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (ß setEquals(this, obj))
    )

    (§ defn #_"boolean" setEquals [#_"IPersistentSet" s1, #_"Object" obj]
        (when (ß s1 == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Set))
            (§ return false)
        )
        (let [#_"Set" m (ß (Set) obj)]
            (when (ß m.size() != s1.count())
                (§ return false)
            )

            (doseq [#_"Object" aM m]
                (when (ß !s1.contains(aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (when (ß !(obj instanceof Set))
            (§ return false)
        )

        (let [#_"Set" m (ß (Set) obj)]
            (when (ß m.size() != size())
                (§ return false)
            )

            (doseq [#_"Object" aM m]
                (when (ß !contains(aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                    (let [#_"Object" e (ß s.first())]
                        (ß hash +=  Util.hash(e))
                    )
                )
                (ß this._hash = hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (ß this._hasheq = cached = Murmur3.hashUnordered(this))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" remove [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" clear [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" retainAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" removeAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" containsAll [this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (if (ß impl instanceof IMapIterable)
            (do
                (ß ((IMapIterable)impl).keyIterator())
            )
            (do
                (ß new Iterator()
                    (§ reify
                        (§ field- #_"Iterator" iter (ß impl.iterator()))

                        #_method
                        (§ defn #_"boolean" hasNext [this]
                            (ß iter.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [this]
                            (ß ((IMapEntry)iter.next()).key())
                        )

                        #_method
                        (§ defn #_"void" remove [this]
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (§ field #_"int" _hash)
    (§ field #_"int" _hasheq)

    #_method
    (§ defn #_"String" toString [this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (when (ß count() > 0)
            (§ return (ß new Seq(this, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" rseq [this]
        (when (ß count() > 0)
            (§ return (ß new RSeq(this, count() - 1)))
        )
        nil
    )

    (§ defn #_"boolean" doEquals [#_"IPersistentVector" v, #_"Object" obj]
        (cond (ß obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ov (ß (IPersistentVector) obj)]
                    (when (ß ov.count() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++)]
                        (when (ß !Util.equals(v.nth(i), ov.nth(i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß obj instanceof List)
            (do
                (let [#_"Collection" ma (ß (Collection) obj)]
                    (when (ß ma.size() != v.count() || ma.hashCode() != v.hashCode())
                        (§ return false)
                    )
                    (loop-when-recur [(ß Iterator i1 = ((List) v).iterator(), i2 = ma.iterator())] (ß i1.hasNext()) [(ß )]
                        (when (ß !Util.equals(i1.next(), i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ms (ß RT.seq(obj))]
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++, ms = ms.next())]
                        (when (ß ms == nil || !Util.equals(v.nth(i), ms.first()))
                            (§ return false)
                        )
                    )
                    (when (ß ms != nil)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (§ defn #_"boolean" doEquiv [#_"IPersistentVector" v, #_"Object" obj]
        (cond (ß obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ov (ß (IPersistentVector) obj)]
                    (when (ß ov.count() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++)]
                        (when (ß !Util.equiv(v.nth(i), ov.nth(i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß obj instanceof List)
            (do
                (let [#_"Collection" ma (ß (Collection) obj)]
                    (when (ß ma.size() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(ß Iterator i1 = ((List) v).iterator(), i2 = ma.iterator())] (ß i1.hasNext()) [(ß )]
                        (when (ß !Util.equiv(i1.next(), i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ms (ß RT.seq(obj))]
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++, ms = ms.next())]
                        (when (ß ms == nil || !Util.equiv(v.nth(i), ms.first()))
                            (§ return false)
                        )
                    )
                    (when (ß ms != nil)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (when (ß obj == this)
            (§ return true)
        )
        (ß doEquals(this, obj))
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (when (ß obj == this)
            (§ return true)
        )
        (ß doEquiv(this, obj))
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (ß hash = 1)
                (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                    (let [#_"Object" obj (ß nth(i))]
                        (ß hash = 31 * hash + ((obj == nil) ? 0 :or obj.hashCode()))
                    )
                )
                (ß this._hash = hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (let [#_"int" hash (ß this._hasheq)]
            (when (ß hash == 0)
                (§ let [#_"int" n]
                    (ß hash = 1)

                    (loop-when-recur [(ß n = 0)] (ß n < count()) [(ß ++n)]
                        (ß hash = 31 * hash + Util.hasheq(nth(n)))
                    )

                    (ß this._hasheq = hash = Murmur3.mixCollHash(hash, n))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"Object" get [this, #_"int" index]
        (ß nth(index))
    )

    #_method
    (§ defn #_"Object" nth [this, #_"int" i, #_"Object" notFound]
        (when (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    #_method
    (§ defn #_"Object" remove [this, #_"int" i]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"int" indexOf [this, #_"Object" o]
        (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
            (when (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [this, #_"Object" o]
        (loop-when-recur [(ß int i = count() - 1)] (ß i >= 0) [(ß i--)]
            (when (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ListIterator" listIterator [this]
        (ß listIterator(0))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [this, #_"int" index]
        (ß new ListIterator()
            (§ reify
                (let [#_"int" nexti index]
                    #_method
                    (§ defn #_"boolean" hasNext [this]
                        (ß (nexti < count()))
                    )

                    #_method
                    (§ defn #_"Object" next [this]
                        (if (ß nexti < count())
                            (do
                                (ß nth(nexti++))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    #_method
                    (§ defn #_"boolean" hasPrevious [this]
                        (ß (nexti > 0))
                    )

                    #_method
                    (§ defn #_"Object" previous [this]
                        (if (ß nexti > 0)
                            (do
                                (ß nth(--nexti))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    #_method
                    (§ defn #_"int" nextIndex [this]
                        nexti
                    )

                    #_method
                    (§ defn #_"int" previousIndex [this]
                        (ß nexti - 1)
                    )

                    #_method
                    (§ defn #_"void" remove [this]
                        (throw (ß new UnsupportedOperationException()))
                    )

                    #_method
                    (§ defn #_"void" set [this, #_"Object" o]
                        (throw (ß new UnsupportedOperationException()))
                    )

                    #_method
                    (§ defn #_"void" add [this, #_"Object" o]
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" rangedIterator [this, #_"int" start, #_"int" end]
        (ß new Iterator()
            (§ reify
                (let [#_"int" i start]
                    #_method
                    (§ defn #_"boolean" hasNext [this]
                        (ß (i < end))
                    )

                    #_method
                    (§ defn #_"Object" next [this]
                        (if (ß i < end)
                            (do
                                (ß nth(i++))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    #_method
                    (§ defn #_"void" remove [this]
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"List" subList [this, #_"int" fromIndex, #_"int" toIndex]
        (ß (List) RT.subvec(this, fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" set [this, #_"int" i, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" add [this, #_"int" i, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"int" i, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (when (ß Util.isInteger(arg1))
            (§ return (ß nth(((Number) arg1).intValue())))
        )
        (throw (ß new IllegalArgumentException("Key must be integer")))
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        ;; todo - something more efficient
        (ß new Iterator()
            (§ reify
                (let [#_"int" i 0]
                    #_method
                    (§ defn #_"boolean" hasNext [this]
                        (ß (i < count()))
                    )

                    #_method
                    (§ defn #_"Object" next [this]
                        (if (ß i < count())
                            (do
                                (ß nth(i++))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    #_method
                    (§ defn #_"void" remove [this]
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" peek [this]
        (when (ß count() > 0)
            (§ return (ß nth(count() - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" containsKey [this, #_"Object" key]
        (when (ß !(Util.isInteger(key)))
            (§ return false)
        )
        (let [#_"int" i (ß ((Number) key).intValue())]
            (ß (i >= 0 && i < count()))
        )
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [this, #_"Object" key]
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (when (ß i >= 0 && i < count())
                    (§ return (ß (IMapEntry) MapEntry.create(key, nth(i))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentVector" assoc [this, #_"Object" key, #_"Object" val]
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (§ return (ß assocN(i, val)))
            )
        )
        (throw (ß new IllegalArgumentException("Key must be integer")))
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (when (ß i >= 0 && i < count())
                    (§ return (ß nth(i)))
                )
            )
        )
        notFound
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"Object[]" toArray [this]
        (let [#_"Object[]" ret (ß new Object[count()])]
            (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                (ß ret[i] = nth(i))
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" add [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" remove [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" clear [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" retainAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" removeAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" containsAll [this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [this, #_"Object" o]
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"int" length [this]
        (ß count())
    )

    #_method
    (§ defn #_"int" compareTo [this, #_"Object" o]
        (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
            (cond (ß count() < v.count())
                (do
                    (§ return -1)
                )
                (ß count() > v.count())
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                (let [#_"int" c (ß Util.compare(nth(i), v.nth(i)))]
                    (when (ß c != 0)
                        (§ return c)
                    )
                )
            )
            0
        )
    )

    (class-ns Seq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        ;; todo - something more efficient
        (§ field #_"IPersistentVector" v)
        (§ field #_"int" i)

        (§ constructor #_"Seq" Seq [#_"IPersistentVector" v, #_"int" i]
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ constructor #_"Seq" Seq [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
            (§ super(meta))
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß v.nth(i))
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < v.count())
                (§ return (ß new APersistentVector.Seq(v, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"int" count [this]
            (ß v.count() - i)
        )

        #_method
        (§ defn #_"APersistentVector.Seq" withMeta [this, #_"IPersistentMap" meta]
            (ß new APersistentVector.Seq(meta, v, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß v.nth(i))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < v.count()) [(ß x++)]
                    (ß ret = f.invoke(ret, v.nth(x)))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, v.nth(i)))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < v.count()) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, v.nth(x)))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )
    )

    (class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
        (§ field #_"IPersistentVector" v)
        (§ field #_"int" i)

        (§ constructor #_"RSeq" RSeq [#_"IPersistentVector" vector, #_"int" i]
            (ß this.v = vector)
            (ß this.i = i)
            this
        )

        (§ constructor #_"RSeq" RSeq [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
            (§ super(meta))
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß v.nth(i))
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i > 0)
                (§ return (ß new APersistentVector.RSeq(v, i - 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"int" count [this]
            (ß i + 1)
        )

        #_method
        (§ defn #_"APersistentVector.RSeq" withMeta [this, #_"IPersistentMap" meta]
            (ß new APersistentVector.RSeq(meta, v, i))
        )
    )

    (class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
        (§ field #_"IPersistentVector" v)
        (§ field #_"int" start)
        (§ field #_"int" end)
        (§ field #_"IPersistentMap" _meta)

        (§ constructor #_"SubVector" SubVector [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" start, #_"int" end]
            (ß this._meta = meta)

            (when (ß v instanceof APersistentVector.SubVector)
                (let [(ß APersistentVector.SubVector sv = (APersistentVector.SubVector) v)]
                    (ß start += sv.start)
                    (ß end += sv.start)
                    (ß v = sv.v)
                )
            )
            (ß this.v = v)
            (ß this.start = start)
            (ß this.end = end)
            this
        )

        #_method
        (§ defn #_"Iterator" iterator [this]
            (when (ß v instanceof APersistentVector)
                (§ return (ß ((APersistentVector)v).rangedIterator(start, end)))
            )
            (ß super.iterator())
        )

        #_method
        (§ defn #_"Object" nth [this, #_"int" i]
            (when (ß (start + i >= end) || (i < 0))
                (throw (ß new IndexOutOfBoundsException()))
            )
            (ß v.nth(start + i))
        )

        #_method
        (§ defn #_"IPersistentVector" assocN [this, #_"int" i, #_"Object" val]
            (cond (ß start + i > end)
                (do
                    (throw (ß new IndexOutOfBoundsException()))
                )
                (ß start + i == end)
                (do
                    (§ return (ß cons(val)))
                )
            )
            (ß new SubVector(_meta, v.assocN(start + i, val), start, end))
        )

        #_method
        (§ defn #_"int" count [this]
            (ß end - start)
        )

        #_method
        (§ defn #_"IPersistentVector" cons [this, #_"Object" o]
            (ß new SubVector(_meta, v.assocN(end, o), start, end + 1))
        )

        #_method
        (§ defn #_"IPersistentCollection" empty [this]
            (ß PersistentVector.EMPTY.withMeta(meta()))
        )

        #_method
        (§ defn #_"IPersistentStack" pop [this]
            (when (ß end - 1 == start)
                (§ return (ß PersistentVector.EMPTY))
            )
            (ß new SubVector(_meta, v, start, end - 1))
        )

        #_method
        (§ defn #_"SubVector" withMeta [this, #_"IPersistentMap" meta]
            (when (ß meta == _meta)
                (§ return this)
            )
            (ß new SubVector(meta, v, start, end))
        )

        #_method
        (§ defn #_"IPersistentMap" meta [this]
            (ß _meta)
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    #_protected
    #_volatile
    (§ field #_"IFn" validator (ß nil))
    #_volatile
    (§ field- #_"IPersistentMap" watches (ß PersistentHashMap.EMPTY))

    (§ constructor #_"ARef" ARef []
        (§ super())
        this
    )

    (§ constructor #_"ARef" ARef [#_"IPersistentMap" meta]
        (§ super(meta))
        this
    )

    #_method
    (§ defn #_"void" validate [this, #_"IFn" vf, #_"Object" val]
        (try
            (when (ß vf != nil && !RT.booleanCast(vf.invoke(val)))
                (throw (ß new IllegalStateException("Invalid reference state")))
            )
            (catch RuntimeException re
                (throw re)
            )
            (catch Exception e
                (throw (ß new IllegalStateException("Invalid reference state", e)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" validate [this, #_"Object" val]
        (ß validate(validator, val))
        nil
    )

    #_method
    (§ defn #_"void" setValidator [this, #_"IFn" vf]
        (ß validate(vf, deref()))
        (ß validator = vf)
        nil
    )

    #_method
    (§ defn #_"IFn" getValidator [this]
        validator
    )

    #_method
    (§ defn #_"IPersistentMap" getWatches [this]
        watches
    )

    #_method
    (§ defn #_"IRef" addWatch [this, #_"Object" key, #_"IFn" callback]
        (§ sync this
            (ß watches = watches.assoc(key, callback))
            this
        )
    )

    #_method
    (§ defn #_"IRef" removeWatch [this, #_"Object" key]
        (§ sync this
            (ß watches = watches.without(key))
            this
        )
    )

    #_method
    (§ defn #_"void" notifyWatches [this, #_"Object" oldval, #_"Object" newval]
        (let [#_"IPersistentMap" ws watches]
            (when (ß ws.count() > 0)
                (loop-when-recur [(ß ISeq s = ws.seq())] (ß s != nil) [(ß s = s.next())]
                    (let [(ß Map.Entry e = (Map.Entry) s.first())]
                        (let [#_"IFn" fn (ß (IFn) e.getValue())]
                            (when (ß fn != nil)
                                (ß fn.invoke(e.getKey(), this, oldval, newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (§ field- #_"IPersistentMap" _meta)

    (§ constructor #_"AReference" AReference []
        (§ this(nil))
        this
    )

    (§ constructor #_"AReference" AReference [#_"IPersistentMap" meta]
        (ß _meta = meta)
        this
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (§ sync this
            (ß _meta)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" alterMeta [this, #_"IFn" alter, #_"ISeq" args]
        (§ sync this
            (ß _meta = (IPersistentMap) alter.applyTo(new Cons(_meta, args)))
            (ß _meta)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" resetMeta [this, #_"IPersistentMap" m]
        (§ sync this
            (ß _meta = m)
            m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (§ field #_"int" actual)

    (§ field #_"String" name)

    (§ constructor #_"ArityException" ArityException [#_"int" actual, #_"String" name]
        (§ this(actual, name, nil))
        this
    )

    (§ constructor #_"ArityException" ArityException [#_"int" actual, #_"String" name, #_"Throwable" cause]
        (§ super("Wrong number of args (" + actual + ") passed to: " + name, cause))
        (ß this.actual = actual)
        (ß this.name = name)
        this
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (§ field #_"Object[]" array)
    (§ field #_"int" off)
    (§ field #_"int" end)

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" array]
        (§ this(array, 0, array.length))
        this
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" array, #_"int" off]
        (§ this(array, off, array.length))
        this
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" array, #_"int" off, #_"int" end]
        (ß this.array = array)
        (ß this.off = off)
        (ß this.end = end)
        this
    )

    #_method
    (§ defn #_"Object" nth [this, #_"int" i]
        (ß array[off + i])
    )

    #_method
    (§ defn #_"Object" nth [this, #_"int" i, #_"Object" notFound]
        (when (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    #_method
    (§ defn #_"int" count [this]
        (ß end - off)
    )

    #_method
    (§ defn #_"IChunk" dropFirst [this]
        (when (ß off == end)
            (throw (ß new IllegalStateException("dropFirst of empty chunk")))
        )
        (ß new ArrayChunk(array, off + 1, end))
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret (ß f.invoke(start, array[off]))]
            (when (ß RT.isReduced(ret))
                (§ return ret)
            )
            (loop-when-recur [(ß int x = off + 1)] (ß x < end) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (when (ß RT.isReduced(ret))
                    (§ return ret)
                )
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter (§ implements Iterator)
    (§ field #_"Object[]" array)
    (§ field #_"int" i)

    (§ def #_"Iterator" EMPTY_ITERATOR (ß new Iterator()
        (§ reify
            #_method
            (§ defn #_"boolean" hasNext [this]
                false
            )

            #_method
            (§ defn #_"Object" next [this]
                (throw (ß new java.util.NoSuchElementException()))
            )

            #_method
            (§ defn #_"void" remove [this]
                (throw (ß new UnsupportedOperationException("remove() not supported")))
            )
        )
    ))

    (§ defn #_"Iterator" create []
        (ß EMPTY_ITERATOR)
    )

    (§ defn #_"Iterator" create [#_"Object..." array]
        (when (ß array == nil || array.length == 0)
            (§ return (ß EMPTY_ITERATOR))
        )
        (ß new ArrayIter(array, 0))
    )

    (§ defn #_"Iterator" createFromObject [#_"Object" array]
        (when (ß array == nil || Array.getLength(array) == 0)
            (§ return (ß EMPTY_ITERATOR))
        )
        (let [#_"Class" aclass (ß array.getClass())]
            (when (ß aclass == int[].class)
                (§ return (ß new ArrayIter_int((int[]) array, 0)))
            )
            (when (ß aclass == float[].class)
                (§ return (ß new ArrayIter_float((float[]) array, 0)))
            )
            (when (ß aclass == double[].class)
                (§ return (ß new ArrayIter_double((double[]) array, 0)))
            )
            (when (ß aclass == long[].class)
                (§ return (ß new ArrayIter_long((long[]) array, 0)))
            )
            (when (ß aclass == byte[].class)
                (§ return (ß new ArrayIter_byte((byte[]) array, 0)))
            )
            (when (ß aclass == char[].class)
                (§ return (ß new ArrayIter_char((char[]) array, 0)))
            )
            (when (ß aclass == short[].class)
                (§ return (ß new ArrayIter_short((short[]) array, 0)))
            )
            (when (ß aclass == boolean[].class)
                (§ return (ß new ArrayIter_boolean((boolean[]) array, 0)))
            )
            (ß new ArrayIter(array, 0))
        )
    )

    (§ constructor #_"ArrayIter" ArrayIter [#_"Object" array, #_"int" i]
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    #_method
    (§ defn #_"boolean" hasNext [this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Object" next [this]
        (when (ß array != nil && i < array.length)
            (§ return (ß array[i++]))
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )

    (class-ns ArrayIter_int (§ implements Iterator<Long>)
        (§ field #_"int[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_int" ArrayIter_int [#_"int[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Long" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_float (§ implements Iterator<Double>)
        (§ field #_"float[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_float" ArrayIter_float [#_"float[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Double" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß Double.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_double (§ implements Iterator<Double>)
        (§ field #_"double[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_double" ArrayIter_double [#_"double[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Double" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_long (§ implements Iterator<Long>)
        (§ field #_"long[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_long" ArrayIter_long [#_"long[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Long" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_byte (§ implements Iterator<Byte>)
        (§ field #_"byte[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_byte" ArrayIter_byte [#_"byte[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Byte" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_char (§ implements Iterator<Character>)
        (§ field #_"char[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_char" ArrayIter_char [#_"char[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Character" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_short (§ implements Iterator<Long>)
        (§ field #_"short[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_short" ArrayIter_short [#_"short[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Long" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
        (§ field #_"boolean[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArrayIter_boolean" ArrayIter_boolean [#_"boolean[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (array != nil && i < array.length))
        )

        #_method
        (§ defn #_"Boolean" next [this]
            (when (ß array != nil && i < array.length)
                (§ return (ß Boolean.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ field #_"Object[]" array)
    (§ field #_"int" i)

    (§ defn #_"ArraySeq" create []
        nil
    )

    (§ defn #_"ArraySeq" create [#_"Object..." array]
        (when (ß array == nil || array.length == 0)
            (§ return nil)
        )
        (ß new ArraySeq(array, 0))
    )

    (§ defn #_"ISeq" createFromObject [#_"Object" array]
        (when (ß array == nil || Array.getLength(array) == 0)
            (§ return nil)
        )
        (let [#_"Class" aclass (ß array.getClass())]
            (when (ß aclass == int[].class)
                (§ return (ß new ArraySeq_int(nil, (int[]) array, 0)))
            )
            (when (ß aclass == float[].class)
                (§ return (ß new ArraySeq_float(nil, (float[]) array, 0)))
            )
            (when (ß aclass == double[].class)
                (§ return (ß new ArraySeq_double(nil, (double[]) array, 0)))
            )
            (when (ß aclass == long[].class)
                (§ return (ß new ArraySeq_long(nil, (long[]) array, 0)))
            )
            (when (ß aclass == byte[].class)
                (§ return (ß new ArraySeq_byte(nil, (byte[]) array, 0)))
            )
            (when (ß aclass == char[].class)
                (§ return (ß new ArraySeq_char(nil, (char[]) array, 0)))
            )
            (when (ß aclass == short[].class)
                (§ return (ß new ArraySeq_short(nil, (short[]) array, 0)))
            )
            (when (ß aclass == boolean[].class)
                (§ return (ß new ArraySeq_boolean(nil, (boolean[]) array, 0)))
            )
            (ß new ArraySeq(array, 0))
        )
    )

    (§ constructor #_"ArraySeq" ArraySeq [#_"Object" array, #_"int" i]
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ constructor #_"ArraySeq" ArraySeq [#_"IPersistentMap" meta, #_"Object" array, #_"int" i]
        (§ super(meta))
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    #_method
    (§ defn #_"Object" first [this]
        (when (ß array != nil)
            (§ return (ß array[i]))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß array != nil && i + 1 < array.length)
            (§ return (ß new ArraySeq(array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [this]
        (when (ß array != nil)
            (§ return (ß array.length - i))
        )
        0
    )

    #_method
    (§ defn #_"int" index [this]
        i
    )

    #_method
    (§ defn #_"ArraySeq" withMeta [this, #_"IPersistentMap" meta]
        (ß new ArraySeq(meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (when (ß array != nil)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                (§ return ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
        (when (ß array != nil)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (§ return ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" indexOf [this, #_"Object" o]
        (when (ß array != nil)
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß Util.equals(o, array[j]))
                    (§ return (ß j - i))
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [this, #_"Object" o]
        (when (ß array != nil)
            (if (ß o == nil)
                (do
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß array[j] == nil)
                            (§ return (ß j - i))
                        )
                    )
                )
                (do
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß o.equals(array[j]))
                            (§ return (ß j - i))
                        )
                    )
                )
            )
        )
        -1
    )

    (class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"int[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_int" ArraySeq_int [#_"IPersistentMap" meta, #_"int[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_int(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_int" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_int(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"int" k (ß ((Number) o).intValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß k == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"int" k (ß ((Number) o).intValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß k == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"float[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_float" ArraySeq_float [#_"IPersistentMap" meta, #_"float[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß Numbers.num(array[i]))
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_float(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_float" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_float(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß Numbers.num(array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, Numbers.num(array[i])))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"float" f (ß ((Number) o).floatValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß f == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"float" f (ß ((Number) o).floatValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß f == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"double[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_double" ArraySeq_double [#_"IPersistentMap" meta, #_"double[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_double(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_double" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_double(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"double" d (ß ((Number) o).doubleValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß d == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"double" d (ß ((Number) o).doubleValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß d == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"long[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_long" ArraySeq_long [#_"IPersistentMap" meta, #_"long[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß Numbers.num(array[i]))
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_long(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_long" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_long(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß Numbers.num(array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, Numbers.num(array[i])))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"long" l (ß ((Number) o).longValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß l == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Number)
                (let [#_"long" l (ß ((Number) o).longValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß l == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"byte[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_byte" ArraySeq_byte [#_"IPersistentMap" meta, #_"byte[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_byte(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_byte" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_byte(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Byte)
                (let [#_"byte" b (ß ((Byte) o).byteValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Byte)
                (let [#_"byte" b (ß ((Byte) o).byteValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"char[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_char" ArraySeq_char [#_"IPersistentMap" meta, #_"char[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_char(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_char" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_char(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Character)
                (let [#_"char" c (ß ((Character) o).charValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß c == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Character)
                (let [#_"char" c (ß ((Character) o).charValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß c == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"short[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_short" ArraySeq_short [#_"IPersistentMap" meta, #_"short[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_short(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_short" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_short(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Short)
                (let [#_"short" s (ß ((Short) o).shortValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß s == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Short)
                (let [#_"short" s (ß ((Short) o).shortValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß s == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field #_"boolean[]" array)
        (§ field #_"int" i)

        (§ constructor #_"ArraySeq_boolean" ArraySeq_boolean [#_"IPersistentMap" meta, #_"boolean[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß array[i])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_boolean(meta(), array, i + 1)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß array.length - i)
        )

        #_method
        (§ defn #_"int" index [this]
            i
        )

        #_method
        (§ defn #_"ArraySeq_boolean" withMeta [this, #_"IPersistentMap" meta]
            (ß new ArraySeq_boolean(meta, array, i))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f]
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (when (ß o instanceof Boolean)
                (let [#_"boolean" b (ß ((Boolean) o).booleanValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (when (ß o instanceof Boolean)
                (let [#_"boolean" b (ß ((Boolean) o).booleanValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    #_transient
    (§ field #_"int" _hash)
    #_transient
    (§ field #_"int" _hasheq)

    #_method
    (§ defn #_"String" toString [this]
        (ß RT.printString(this))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß PersistentList.EMPTY)
    )

    #_protected
    (§ constructor #_"ASeq" ASeq [#_"IPersistentMap" meta]
        (§ super(meta))
        this
    )

    #_protected
    (§ constructor #_"ASeq" ASeq []
        this
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (when (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (when (ß this == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equals(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (when (ß _hash == 0)
            (let [#_"int" hash 1]
                (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                    (ß hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
                )
                (ß this._hash = hash)
            )
        )
        (ß _hash)
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (when (ß _hasheq == 0)
            (ß _hasheq = Murmur3.hashOrdered(this))
        )
        (ß _hasheq)
    )

    #_method
    (§ defn #_"int" count [this]
        (let [#_"int" i 1]
            (loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next(), i++)]
                (when (ß s instanceof Counted)
                    (§ return (ß i + s.count()))
                )
            )
            i
        )
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        this
    )

    #_method
    (§ defn #_"ISeq" cons [this, #_"Object" o]
        (ß new Cons(o, this))
    )

    #_method
    (§ defn #_"ISeq" more [this]
        (let [#_"ISeq" s (ß next())]
            (when (ß s == nil)
                (§ return (ß PersistentList.EMPTY))
            )
            s
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" remove [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" clear [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" retainAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" removeAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" containsAll [this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [this, #_"Object" o]
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß new SeqIterator(this))
    )

    #_method
    (§ defn- #_"List" reify [this]
        (ß Collections.unmodifiableList(new ArrayList(this)))
    )

    #_method
    (§ defn #_"List" subList [this, #_"int" fromIndex, #_"int" toIndex]
        (ß reify().subList(fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" set [this, #_"int" index, #_"Object" element]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"Object" remove [this, #_"int" index]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"int" indexOf [this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                (when (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [this, #_"Object" o]
        (ß reify().lastIndexOf(o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [this, #_"int" index]
        (ß reify().listIterator(index))
    )

    #_method
    (§ defn #_"Object" get [this, #_"int" index]
        (ß RT.nth(this, index))
    )

    #_method
    (§ defn #_"void" add [this, #_"int" index, #_"Object" element]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"int" index, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.Associative

(§ interface Associative (§ extends IPersistentCollection, ILookup)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
    (§ abstract Associative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (§ field #_"AtomicReference" state)

    (§ constructor #_"Atom" Atom [#_"Object" state]
        (ß this.state = new AtomicReference(state))
        this
    )

    (§ constructor #_"Atom" Atom [#_"Object" state, #_"IPersistentMap" meta]
        (§ super(meta))
        (ß this.state = new AtomicReference(state))
        this
    )

    #_method
    (§ defn #_"Object" deref [this]
        (ß state.get())
    )

    #_method
    (§ defn #_"Object" swap [this, #_"IFn" f]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [this, #_"IFn" f, #_"Object" arg]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v, arg))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v, arg1, arg2))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.applyTo(RT.listStar(v, x, y, args)))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [this, #_"IFn" f]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [this, #_"IFn" f, #_"Object" arg]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv, arg))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv, arg1, arg2))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.applyTo(RT.listStar(oldv, x, y, args)))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" compareAndSet [this, #_"Object" oldv, #_"Object" newv]
        (ß validate(newv))
        (let [#_"boolean" ret (ß state.compareAndSet(oldv, newv))]
            (when ret
                (ß notifyWatches(oldv, newv))
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reset [this, #_"Object" newval]
        (let [#_"Object" oldval (ß state.get())]
            (ß validate(newval))
            (ß state.set(newval))
            (ß notifyWatches(oldval, newval))
            newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" resetVals [this, #_"Object" newv]
        (ß validate(newv))
        (while true
            (let [#_"Object" oldv (ß deref())]
                (when (ß state.compareAndSet(oldv, newv))
                    (ß notifyWatches(oldv, newv))
                    (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

(§ import cloiure.lang.PersistentHashMap.INode)

#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    (§ abstract void ensureEditable())
    (§ abstract ITransientMap doAssoc(Object key, Object val))
    (§ abstract ITransientMap doWithout(Object key))
    (§ abstract Object doValAt(Object key, Object notFound))
    (§ abstract int doCount())
    (§ abstract IPersistentMap doPersistent())

    #_method
    (§ defn #_"ITransientMap" conj [this, #_"Object" o]
        (ß ensureEditable())
        (cond (ß o instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) o)]
                    (§ return (ß assoc(e.getKey(), e.getValue())))
                )
            )
            (ß o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
                    (when (ß v.count() != 2)
                        (throw (ß new IllegalArgumentException("Vector arg to map conj must be a pair")))
                    )
                    (§ return (ß assoc(v.nth(0), v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ret this]
            (loop-when-recur [(ß ISeq es = RT.seq(o))] (ß es != nil) [(ß es = es.next())]
                (let [(ß Map.Entry e = (Map.Entry) es.first())]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß valAt(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" notFound]
        (ß valAt(arg1, notFound))
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"ITransientMap" assoc [this, #_"Object" key, #_"Object" val]
        (ß ensureEditable())
        (ß doAssoc(key, val))
    )

    #_method
    (§ defn #_"ITransientMap" without [this, #_"Object" key]
        (ß ensureEditable())
        (ß doWithout(key))
    )

    #_method
    (§ defn #_"IPersistentMap" persistent [this]
        (ß ensureEditable())
        (ß doPersistent())
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (ß ensureEditable())
        (ß doValAt(key, notFound))
    )

    (§ def- #_"Object" NOT_FOUND (ß new Object()))
    #_method
    (§ defn #_"boolean" containsKey [this, #_"Object" key]
        (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
    )
    #_method
    (§ defn #_"IMapEntry" entryAt [this, #_"Object" key]
        (let [#_"Object" v (ß valAt(key, NOT_FOUND))]
            (when (ß v != NOT_FOUND)
                (§ return (ß MapEntry.create(key, v)))
            )
            nil
        )
    )

    #_method
    (§ defn #_"int" count [this]
        (ß ensureEditable())
        (ß doCount())
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    #_volatile
    (§ field #_"ITransientMap" impl)

    (§ constructor #_"ATransientSet" ATransientSet [#_"ITransientMap" impl]
        (ß this.impl = impl)
        this
    )

    #_method
    (§ defn #_"int" count [this]
        (ß impl.count())
    )

    #_method
    (§ defn #_"ITransientSet" conj [this, #_"Object" val]
        (let [#_"ITransientMap" m (ß impl.assoc(val, val))]
            (when (ß m != impl)
                (ß this.impl = m)
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" contains [this, #_"Object" key]
        (ß (this != impl.valAt(key, this)))
    )

    #_method
    (§ defn #_"ITransientSet" disjoin [this, #_"Object" key]
        (let [#_"ITransientMap" m (ß impl.without(key))]
            (when (ß m != impl)
                (ß this.impl = m)
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" get [this, #_"Object" key]
        (ß impl.valAt(key))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" key, #_"Object" notFound]
        (ß impl.valAt(key, notFound))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" key]
        (ß impl.valAt(key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ field #_"long" lpart)
    (§ field #_"BigInteger" bipart)

    (§ def #_"BigInt" ZERO (ß new BigInt(0, nil)))
    (§ def #_"BigInt" ONE (ß new BigInt(1, nil)))

    ;; must follow Long
    #_method
    (§ defn #_"int" hashCode [this]
        (when (ß bipart == nil)
            (§ return (ß (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (ß bipart.hashCode())
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (when (ß bipart == nil)
            (§ return (ß Murmur3.hashLong(lpart)))
        )
        (ß bipart.hashCode())
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (when (ß this == obj)
            (§ return true)
        )
        (when (ß obj instanceof BigInt)
            (let [#_"BigInt" o (ß (BigInt) obj)]
                (when (ß bipart == nil)
                    (§ return (ß (o.bipart == nil && this.lpart == o.lpart)))
                )
                (§ return (ß (o.bipart != nil && this.bipart.equals(o.bipart))))
            )
        )
        false
    )

    (§ constructor- #_"BigInt" BigInt [#_"long" lpart, #_"BigInteger" bipart]
        (ß this.lpart = lpart)
        (ß this.bipart = bipart)
        this
    )

    (§ defn #_"BigInt" fromBigInteger [#_"BigInteger" val]
        (if (ß val.bitLength() < 64)
            (do
                (ß new BigInt(val.longValue(), nil))
            )
            (do
                (ß new BigInt(0, val))
            )
        )
    )

    (§ defn #_"BigInt" fromLong [#_"long" val]
        (ß new BigInt(val, nil))
    )

    #_method
    (§ defn #_"BigInteger" toBigInteger [this]
        (if (ß bipart == nil)
            (do
                (ß BigInteger.valueOf(lpart))
            )
            (do
                bipart
            )
        )
    )

    #_method
    (§ defn #_"BigDecimal" toBigDecimal [this]
        (if (ß bipart == nil)
            (do
                (ß BigDecimal.valueOf(lpart))
            )
            (do
                (ß new BigDecimal(bipart))
            )
        )
    )

    #_method
    (§ defn #_"int" intValue [this]
        (if (ß bipart == nil)
            (do
                (ß (int) lpart)
            )
            (do
                (ß bipart.intValue())
            )
        )
    )

    #_method
    (§ defn #_"long" longValue [this]
        (if (ß bipart == nil)
            (do
                lpart
            )
            (do
                (ß bipart.longValue())
            )
        )
    )

    #_method
    (§ defn #_"float" floatValue [this]
        (if (ß bipart == nil)
            (do
                lpart
            )
            (do
                (ß bipart.floatValue())
            )
        )
    )

    #_method
    (§ defn #_"double" doubleValue [this]
        (if (ß bipart == nil)
            (do
                lpart
            )
            (do
                (ß bipart.doubleValue())
            )
        )
    )

    #_method
    (§ defn #_"byte" byteValue [this]
        (if (ß bipart == nil)
            (do
                (ß (byte) lpart)
            )
            (do
                (ß bipart.byteValue())
            )
        )
    )

    #_method
    (§ defn #_"short" shortValue [this]
        (if (ß bipart == nil)
            (do
                (ß (short) lpart)
            )
            (do
                (ß bipart.shortValue())
            )
        )
    )

    (§ defn #_"BigInt" valueOf [#_"long" val]
        (ß new BigInt(val, nil))
    )

    #_method
    (§ defn #_"String" toString [this]
        (when (ß bipart == nil)
            (§ return (ß String.valueOf(lpart)))
        )
        (ß bipart.toString())
    )

    #_method
    (§ defn #_"int" bitLength [this]
        (ß toBigInteger().bitLength())
    )

    #_method
    (§ defn #_"BigInt" add [this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (let [#_"long" ret (ß lpart + y.lpart)]
                (when (ß (ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0)
                    (§ return (ß BigInt.valueOf(ret)))
                )
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" multiply [this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (let [#_"long" ret (ß lpart * y.lpart)]
                (when (ß y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE))
                    (§ return (ß BigInt.valueOf(ret)))
                )
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" quotient [this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (when (ß lpart == Long.MIN_VALUE && y.lpart == -1)
                (§ return (ß BigInt.fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (ß BigInt.valueOf(lpart / y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" remainder [this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß BigInt.valueOf(lpart % y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger())))
    )

    #_method
    (§ defn #_"boolean" lt [this, #_"BigInt" y]
        (when (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß (lpart < y.lpart)))
        )
        (ß (this.toBigInteger().compareTo(y.toBigInteger()) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (§ field #_"T" val)
    (§ field #_"Binding" rest)

    (§ constructor #_"Binding" Binding [#_"T" val]
        (ß this.val = val)
        (ß this.rest = nil)
        this
    )

    (§ constructor #_"Binding" Binding [#_"T" val, #_"Binding" rest]
        (ß this.val = val)
        (ß this.rest = rest)
        this
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (§ field #_"Object" val)

    (§ constructor #_"Box" Box [#_"Object" val]
        (ß this.val = val)
        this
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (§ field #_"Object[]" buffer)
    (§ field #_"int" end)

    (§ constructor #_"ChunkBuffer" ChunkBuffer [#_"int" capacity]
        (ß buffer = new Object[capacity])
        (ß end = 0)
        this
    )

    #_method
    (§ defn #_"void" add [this, #_"Object" o]
        (ß buffer[end++] = o)
        nil
    )

    #_method
    (§ defn #_"IChunk" chunk [this]
        (let [#_"ArrayChunk" ret (ß new ArrayChunk(buffer, 0, end))]
            (ß buffer = nil)
            ret
        )
    )

    #_method
    (§ defn #_"int" count [this]
        end
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (§ field #_"IChunk" chunk)
    (§ field #_"ISeq" _more)

    (§ constructor #_"ChunkedCons" ChunkedCons [#_"IPersistentMap" meta, #_"IChunk" chunk, #_"ISeq" more]
        (§ super(meta))
        (ß this.chunk = chunk)
        (ß this._more = more)
        this
    )

    (§ constructor #_"ChunkedCons" ChunkedCons [#_"IChunk" chunk, #_"ISeq" more]
        (§ this(nil, chunk, more))
        this
    )

    #_method
    (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
        (when (ß meta != _meta)
            (§ return (ß new ChunkedCons(meta, chunk, _more)))
        )
        this
    )

    #_method
    (§ defn #_"Object" first [this]
        (ß chunk.nth(0))
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"ISeq" more [this]
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (when (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [this]
        chunk
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [this]
        (when (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

(class-ns Compile
    (§ def- #_"String" PATH_PROP (ß "cloiure.compile.path"))
    (§ def- #_"String" REFLECTION_WARNING_PROP (ß "cloiure.compile.warn-on-reflection"))
    (§ def- #_"String" UNCHECKED_MATH_PROP (ß "cloiure.compile.unchecked-math"))

    (§ def- #_"Var" compile_path (ß RT.var("cloiure.core", "*compile-path*")))
    (§ def- #_"Var" compile (ß RT.var("cloiure.core", "compile")))
    (§ def- #_"Var" warn_on_reflection (ß RT.var("cloiure.core", "*warn-on-reflection*")))
    (§ def- #_"Var" unchecked_math (ß RT.var("cloiure.core", "*unchecked-math*")))

    (§ defn #_"void" main [#_"String[]" args] (§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" out (ß (OutputStreamWriter) RT.OUT.deref())]
            (let [#_"PrintWriter" err (ß RT.errPrintWriter())]
                (let [#_"String" path (ß System.getProperty(PATH_PROP))]
                    (let [#_"int" count (ß args.length)]
                        (when (ß path == nil)
                            (ß err.println("ERROR: Must set system property " + PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
                            (ß System.exit(1))
                        )

                        (let [#_"boolean" warnOnReflection (ß System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" uncheckedMathProp (ß System.getProperty(UNCHECKED_MATH_PROP))]
                                (let [#_"Object" uncheckedMath (ß Boolean.FALSE)]
                                    (cond (ß "true".equals(uncheckedMathProp))
                                        (do
                                            (ß uncheckedMath = Boolean.TRUE)
                                        )
                                        (ß "warn-on-boxed".equals(uncheckedMathProp))
                                        (do
                                            (ß uncheckedMath = Keyword.intern("warn-on-boxed"))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (ß RT.load("cloiure/core/specs/alpha"))

                                    (try
                                        (ß Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath)))

                                        (doseq [#_"String" lib args]
                                            (ß out.write("Compiling " + lib + " to " + path + "\n"))
                                            (ß out.flush())
                                            (ß compile.invoke(Symbol.intern(lib)))
                                        )
                                        (finally
                                            (ß Var.popThreadBindings())
                                            (try
                                                (ß out.flush())
                                                (catch IOException e
                                                    (ß e.printStackTrace(err))
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" DEF (ß Symbol.intern("def")))
    (§ def #_"Symbol" LOOP (ß Symbol.intern("loop*")))
    (§ def #_"Symbol" RECUR (ß Symbol.intern("recur")))
    (§ def #_"Symbol" IF (ß Symbol.intern("if")))
    (§ def #_"Symbol" LET (ß Symbol.intern("let*")))
    (§ def #_"Symbol" LETFN (ß Symbol.intern("letfn*")))
    (§ def #_"Symbol" DO (ß Symbol.intern("do")))
    (§ def #_"Symbol" FN (ß Symbol.intern("fn*")))
    (§ def #_"Symbol" FNONCE (ß (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(nil, "once"), RT.T))))
    (§ def #_"Symbol" QUOTE (ß Symbol.intern("quote")))
    (§ def #_"Symbol" THE_VAR (ß Symbol.intern("var")))
    (§ def #_"Symbol" DOT (ß Symbol.intern(".")))
    (§ def #_"Symbol" ASSIGN (ß Symbol.intern("set!")))
    (§ def #_"Symbol" TRY (ß Symbol.intern("try")))
    (§ def #_"Symbol" CATCH (ß Symbol.intern("catch")))
    (§ def #_"Symbol" FINALLY (ß Symbol.intern("finally")))
    (§ def #_"Symbol" THROW (ß Symbol.intern("throw")))
    (§ def #_"Symbol" MONITOR_ENTER (ß Symbol.intern("monitor-enter")))
    (§ def #_"Symbol" MONITOR_EXIT (ß Symbol.intern("monitor-exit")))
    (§ def #_"Symbol" IMPORT (ß Symbol.intern("cloiure.core", "import*")))
    (§ def #_"Symbol" DEFTYPE (ß Symbol.intern("deftype*")))
    (§ def #_"Symbol" CASE (ß Symbol.intern("case*")))

    (§ def #_"Symbol" CLASS (ß Symbol.intern("Class")))
    (§ def #_"Symbol" NEW (ß Symbol.intern("new")))
    (§ def #_"Symbol" THIS (ß Symbol.intern("this")))
    (§ def #_"Symbol" REIFY (ß Symbol.intern("reify*")))
    (§ def #_"Symbol" LIST (ß Symbol.intern("cloiure.core", "list")))
    (§ def #_"Symbol" HASHMAP (ß Symbol.intern("cloiure.core", "hash-map")))
    (§ def #_"Symbol" VECTOR (ß Symbol.intern("cloiure.core", "vector")))
    (§ def #_"Symbol" IDENTITY (ß Symbol.intern("cloiure.core", "identity")))

    (§ def #_"Symbol" _AMP_ (ß Symbol.intern("&")))
    (§ def #_"Symbol" ISEQ (ß Symbol.intern("cloiure.lang.ISeq")))

    (§ def #_"Keyword" loadNs (ß Keyword.intern(nil, "load-ns")))
    (§ def #_"Keyword" inlineKey (ß Keyword.intern(nil, "inline")))
    (§ def #_"Keyword" inlineAritiesKey (ß Keyword.intern(nil, "inline-arities")))
    (§ def #_"Keyword" staticKey (ß Keyword.intern(nil, "static")))
    (§ def #_"Keyword" arglistsKey (ß Keyword.intern(nil, "arglists")))
    (§ def #_"Symbol" INVOKE_STATIC (ß Symbol.intern("invokeStatic")))

    (§ def #_"Keyword" volatileKey (ß Keyword.intern(nil, "volatile")))
    (§ def #_"Keyword" implementsKey (ß Keyword.intern(nil, "implements")))
    (§ def #_"String" COMPILE_STUB_PREFIX (ß "compile__stub"))

    (§ def #_"Keyword" protocolKey (ß Keyword.intern(nil, "protocol")))
    (§ def #_"Keyword" onKey (ß Keyword.intern(nil, "on")))
    (§ def #_"Keyword" dynamicKey (ß Keyword.intern("dynamic")))
    (§ def #_"Keyword" redefKey (ß Keyword.intern(nil, "redef")))

    (§ def #_"Symbol" NS (ß Symbol.intern("ns")))
    (§ def #_"Symbol" IN_NS (ß Symbol.intern("in-ns")))

    (§ def #_"IPersistentMap" specials (ß PersistentHashMap.create(
  #_map DEF, new DefExpr.Parser(),
  #_map LOOP, new LetExpr.Parser(),
  #_map RECUR, new RecurExpr.Parser(),
  #_map IF, new IfExpr.Parser(),
  #_map CASE, new CaseExpr.Parser(),
  #_map LET, new LetExpr.Parser(),
  #_map LETFN, new LetFnExpr.Parser(),
  #_map DO, new BodyExpr.Parser(),
  #_map FN, nil,
  #_map QUOTE, new ConstantExpr.Parser(),
  #_map THE_VAR, new TheVarExpr.Parser(),
  #_map IMPORT, new ImportExpr.Parser(),
  #_map DOT, new HostExpr.Parser(),
  #_map ASSIGN, new AssignExpr.Parser(),
  #_map DEFTYPE, new NewInstanceExpr.DeftypeParser(),
  #_map REIFY, new NewInstanceExpr.ReifyParser(),
  #_map TRY, new TryExpr.Parser(),
  #_map THROW, new ThrowExpr.Parser(),
  #_map MONITOR_ENTER, new MonitorEnterExpr.Parser(),
  #_map MONITOR_EXIT, new MonitorExitExpr.Parser(),
  #_map CATCH, nil,
  #_map FINALLY, nil,
  #_map NEW, new NewExpr.Parser(),
  #_map _AMP_, nil
    )))

    (§ def- #_"int" MAX_POSITIONAL_ARITY (ß 20))
    (§ def- #_"Type" OBJECT_TYPE)
    (§ def- #_"Type" KEYWORD_TYPE (ß Type.getType(Keyword.class)))
    (§ def- #_"Type" VAR_TYPE (ß Type.getType(Var.class)))
    (§ def- #_"Type" SYMBOL_TYPE (ß Type.getType(Symbol.class)))
    (§ def- #_"Type" IFN_TYPE (ß Type.getType(IFn.class)))
    (§ def- #_"Type" AFUNCTION_TYPE (ß Type.getType(AFunction.class)))
    (§ def- #_"Type" RT_TYPE (ß Type.getType(RT.class)))
    (§ def- #_"Type" NUMBERS_TYPE (ß Type.getType(Numbers.class)))

    (§ def #_"Type" CLASS_TYPE (ß Type.getType(Class.class)))
    (§ def #_"Type" NS_TYPE (ß Type.getType(Namespace.class)))
    (§ def #_"Type" UTIL_TYPE (ß Type.getType(Util.class)))
    (§ def #_"Type" REFLECTOR_TYPE (ß Type.getType(Reflector.class)))
    (§ def #_"Type" THROWABLE_TYPE (ß Type.getType(Throwable.class)))
    (§ def #_"Type" BOOLEAN_OBJECT_TYPE (ß Type.getType(Boolean.class)))
    (§ def #_"Type" IPERSISTENTMAP_TYPE (ß Type.getType(IPersistentMap.class)))
    (§ def #_"Type" IOBJ_TYPE (ß Type.getType(IObj.class)))
    (§ def #_"Type" TUPLE_TYPE (ß Type.getType(Tuple.class)))

    (§ def #_"Method[]" createTupleMethods
    (§ array
        (ß Method.getMethod("cloiure.lang.IPersistentVector create()")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)"))
    ))

    (§ def- #_"Type[][]" ARG_TYPES)
    (§ def- #_"Type[]" EXCEPTION_TYPES (ß (§)))

    (§ static
        (ß OBJECT_TYPE = Type.getType(Object.class))
        (ß ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][])
        (loop-when-recur [(ß int i = 0)] (ß i <= MAX_POSITIONAL_ARITY) [(ß ++i)]
            (let [#_"Type[]" a (ß new Type[i])]
                (loop-when-recur [(ß int j = 0)] (ß j < i) [(ß j++)]
                    (ß a[j] = OBJECT_TYPE)
                )
                (ß ARG_TYPES[i] = a)
            )
        )
        (let [#_"Type[]" a (ß new Type[MAX_POSITIONAL_ARITY + 1])]
            (loop-when-recur [(ß int j = 0)] (ß j < MAX_POSITIONAL_ARITY) [(ß j++)]
                (ß a[j] = OBJECT_TYPE)
            )
            (ß a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/Object;"))
            (ß ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" LOCAL_ENV (ß Var.create(nil).setDynamic()))

    ;; vector<localbinding>
    (§ def #_"Var" LOOP_LOCALS (ß Var.create().setDynamic()))

    ;; Label
    (§ def #_"Var" LOOP_LABEL (ß Var.create().setDynamic()))

    ;; vector<object>
    (§ def #_"Var" CONSTANTS (ß Var.create().setDynamic()))

    ;; IdentityHashMap
    (§ def #_"Var" CONSTANT_IDS (ß Var.create().setDynamic()))

    ;; vector<keyword>
    (§ def #_"Var" KEYWORD_CALLSITES (ß Var.create().setDynamic()))

    ;; vector<var>
    (§ def #_"Var" PROTOCOL_CALLSITES (ß Var.create().setDynamic()))

    ;; set<var>
    (§ def #_"Var" VAR_CALLSITES (ß Var.create().setDynamic()))

    ;; keyword->constid
    (§ def #_"Var" KEYWORDS (ß Var.create().setDynamic()))

    ;; var->constid
    (§ def #_"Var" VARS (ß Var.create().setDynamic()))

    ;; FnFrame
    (§ def #_"Var" METHOD (ß Var.create(nil).setDynamic()))

    ;; nil or not
    (§ def #_"Var" IN_CATCH_FINALLY (ß Var.create(nil).setDynamic()))

    (§ def #_"Var" METHOD_RETURN_CONTEXT (ß Var.create(nil).setDynamic()))

    (§ def #_"Var" NO_RECUR (ß Var.create(nil).setDynamic()))

    ;; DynamicClassLoader
    (§ def #_"Var" LOADER (ß Var.create().setDynamic()))

    ;; String
    (§ def #_"Var" SOURCE (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic()))

    ;; String
    (§ def #_"Var" SOURCE_PATH (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic()))

    ;; String
    (§ def #_"Var" COMPILE_PATH (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), nil).setDynamic()))
    ;; boolean
    (§ def #_"Var" COMPILE_FILES (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic()))

    (§ def #_"Var" INSTANCE (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?"))))

    (§ def #_"Var" ADD_ANNOTATIONS (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations"))))

    (§ def #_"Keyword" disableLocalsClearingKey (ß Keyword.intern("disable-locals-clearing")))
    (§ def #_"Keyword" directLinkingKey (ß Keyword.intern("direct-linking")))
    (§ def #_"Keyword" elideMetaKey (ß Keyword.intern("elide-meta")))

    (§ def #_"Var" COMPILER_OPTIONS)

    (§ defn #_"Object" getCompilerOption [#_"Keyword" k]
        (ß RT.get(COMPILER_OPTIONS.deref(), k))
    )

    (§ static
        (let [#_"Object" compilerOptions nil]
            (doseq [#_"Map.Entry" e (ß System.getProperties().entrySet())]
                (let [#_"String" name (ß (String) e.getKey())]
                    (let [#_"String" v (ß (String) e.getValue())]
                        (when (ß name.startsWith("cloiure.compiler."))
                            (ß compilerOptions = RT.assoc(compilerOptions, RT.keyword(nil, name.substring(1 + name.lastIndexOf(\.))), RT.readString(v)))
                        )
                    )
                )
            )

            (ß COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic())
        )
    )

    (§ defn #_"Object" elideMeta [#_"Object" m]
        (let [#_"Collection<Object>" elides (ß (Collection<Object>) getCompilerOption(elideMetaKey))]
            (when (ß elides != nil)
                (doseq [#_"Object" k elides]
                    (ß m = RT.dissoc(m, k))
                )
            )
            m
        )
    )

    ;; Integer
    (§ def #_"Var" LINE (ß Var.create(0).setDynamic()))
    (§ def #_"Var" COLUMN (ß Var.create(0).setDynamic()))

    (§ defn #_"int" lineDeref []
        (ß ((Number)LINE.deref()).intValue())
    )

    (§ defn #_"int" columnDeref []
        (ß ((Number)COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def #_"Var" LINE_BEFORE (ß Var.create(0).setDynamic()))
    (§ def #_"Var" COLUMN_BEFORE (ß Var.create(0).setDynamic()))
    (§ def #_"Var" LINE_AFTER (ß Var.create(0).setDynamic()))
    (§ def #_"Var" COLUMN_AFTER (ß Var.create(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" NEXT_LOCAL_NUM (ß Var.create(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" RET_LOCAL_NUM (ß Var.create().setDynamic()))

    (§ def #_"Var" COMPILE_STUB_SYM (ß Var.create(nil).setDynamic()))
    (§ def #_"Var" COMPILE_STUB_CLASS (ß Var.create(nil).setDynamic()))

    ;; PathNode chain
    (§ def #_"Var" CLEAR_PATH (ß Var.create(nil).setDynamic()))

    ;; tail of PathNode chain
    (§ def #_"Var" CLEAR_ROOT (ß Var.create(nil).setDynamic()))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" CLEAR_SITES (ß Var.create(nil).setDynamic()))

    #_non-static
    (§ enum C
        (§ item STATEMENT), ;; value ignored
        (§ item EXPRESSION), ;; value required
        (§ item RETURN), ;; tail position relative to enclosing recur frame
        (§ item EVAL)
    )

    #_private
    #_non-static
    (class-ns Recur
    )

    (§ def #_"Class" RECUR_CLASS (ß Recur.class))

    #_non-static
    (§ interface Expr
        (§ abstract Object eval())
        (§ abstract void emit(C context, ObjExpr objx, GeneratorAdapter gen))
        (§ abstract boolean hasJavaClass())
        (§ abstract Class getJavaClass())
    )

    #_abstract
    (class-ns UntypedExpr (§ implements Expr)
        #_method
        (§ defn #_"Class" getJavaClass [this]
            (throw (ß new IllegalArgumentException("Has no Java class")))
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            false
        )
    )

    #_non-static
    (§ interface IParser
        (§ abstract Expr parse(C context, Object form))
    )

    (§ defn #_"boolean" isSpecial [#_"Object" sym]
        (ß specials.containsKey(sym))
    )

    (§ defn #_"boolean" inTailCall [#_"C" context]
        (ß (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil))
    )

    (§ defn #_"Symbol" resolveSymbol [#_"Symbol" sym]
        ;; already qualified or classname?
        (when (ß sym.name.indexOf(\.) > 0)
            (§ return sym)
        )
        (when (ß sym.ns != nil)
            (let [#_"Namespace" ns (ß namespaceFor(sym))]
                (when (ß ns == nil || ((ns.name.name == nil) ? (sym.ns == nil) :or ns.name.name.equals(sym.ns)))
                    (§ return sym)
                )
                (§ return (ß Symbol.intern(ns.name.name, sym.name)))
            )
        )
        (let [#_"Object" o (ß currentNS().getMapping(sym))]
            (cond (ß o == nil)
                (do
                    (§ return (ß Symbol.intern(currentNS().name.name, sym.name)))
                )
                (ß o instanceof Class)
                (do
                    (§ return (ß Symbol.intern(nil, ((Class) o).getName())))
                )
                (ß o instanceof Var)
                (do
                    (let [#_"Var" v (ß (Var) o)]
                        (§ return (ß Symbol.intern(v.ns.name.name, v.sym.name)))
                    )
                )
            )
            nil
        )
    )

    (class-ns DefExpr (§ implements Expr)
        (§ field #_"Var" var)
        (§ field #_"Expr" init)
        (§ field #_"Expr" meta)
        (§ field #_"boolean" initProvided)
        (§ field #_"boolean" isDynamic)
        (§ field #_"boolean" shadowsCoreMapping)
        (§ field #_"String" source)
        (§ field #_"int" line)
        (§ field #_"int" column)

        (§ def #_"Method" bindRootMethod (ß Method.getMethod("void bindRoot(Object)")))
        (§ def #_"Method" setTagMethod (ß Method.getMethod("void setTag(cloiure.lang.Symbol)")))
        (§ def #_"Method" setMetaMethod (ß Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)")))
        (§ def #_"Method" setDynamicMethod (ß Method.getMethod("cloiure.lang.Var setDynamic(boolean)")))
        (§ def #_"Method" symintern (ß Method.getMethod("cloiure.lang.Symbol intern(String, String)")))
        (§ def #_"Method" internVar (ß Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)")))

        (§ constructor #_"DefExpr" DefExpr [#_"String" source, #_"int" line, #_"int" column, #_"Var" var, #_"Expr" init, #_"Expr" meta, #_"boolean" initProvided, #_"boolean" isDynamic, #_"boolean" shadowsCoreMapping]
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.var = var)
            (ß this.init = init)
            (ß this.meta = meta)
            (ß this.isDynamic = isDynamic)
            (ß this.shadowsCoreMapping = shadowsCoreMapping)
            (ß this.initProvided = initProvided)
            this
        )

        #_method
        (§ defn- #_"boolean" includesExplicitMetadata [this, #_"MapExpr" expr]
            (loop-when-recur [(ß int i = 0)] (ß i < expr.keyvals.count()) [(ß i += 2)]
                (let [#_"Keyword" k (ß ((KeywordExpr) expr.keyvals.nth(i)).k)]
                    (when (ß (k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY))
                        (§ return true)
                    )
                )
            )
            false
        )

        #_method
        (§ defn #_"Object" eval [this]
            (try
                (when initProvided
                    (ß var.bindRoot(init.eval()))
                )
                (when (ß meta != nil)
                    (let [#_"IPersistentMap" metaMap (ß (IPersistentMap) meta.eval())]
                        (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                            (ß var.setMeta(metaMap))
                        )
                    )
                )
                (ß var.setDynamic(isDynamic))
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitVar(gen, var))

            (when shadowsCoreMapping
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "ns", NS_TYPE))
                (ß gen.swap())
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE))
                (ß gen.swap())
                (ß gen.invokeVirtual(NS_TYPE, internVar))
            )

            (when isDynamic
                (ß gen.push(isDynamic))
                (ß gen.invokeVirtual(VAR_TYPE, setDynamicMethod))
            )
            (when (ß meta != nil)
                (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                    (ß gen.dup())
                    (ß meta.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                    (ß gen.invokeVirtual(VAR_TYPE, setMetaMethod))
                )
            )
            (when initProvided
                (ß gen.dup())
                (if (ß init instanceof FnExpr)
                    (do
                        (ß ((FnExpr)init).emitForDefn(objx, gen))
                    )
                    (do
                        (ß init.emit(C.EXPRESSION, objx, gen))
                    )
                )
                (ß gen.invokeVirtual(VAR_TYPE, bindRootMethod))
            )

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß Var.class)
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                (let [#_"String" docstring nil]
                    (when (ß RT.count(form) == 4 && (RT.third(form) instanceof String))
                        (ß docstring = (String) RT.third(form))
                        (ß form = RT.list(RT.first(form), RT.second(form), RT.fourth(form)))
                    )
                    (cond (ß RT.count(form) > 3)
                        (do
                            (throw (ß Util.runtimeException("Too many arguments to def")))
                        )
                        (ß RT.count(form) < 2)
                        (do
                            (throw (ß Util.runtimeException("Too few arguments to def")))
                        )
                        (ß !(RT.second(form) instanceof Symbol))
                        (do
                            (throw (ß Util.runtimeException("First argument to def must be a Symbol")))
                        )
                    )
                    (let [#_"Symbol" sym (ß (Symbol) RT.second(form))]
                        (let [#_"Var" v (ß lookupVar(sym, true))]
                            (when (ß v == nil)
                                (throw (ß Util.runtimeException("Can't refer to qualified var that doesn't exist")))
                            )
                            (let [#_"boolean" shadowsCoreMapping false]
                                (when (ß !v.ns.equals(currentNS()))
                                    (if (ß sym.ns == nil)
                                        (do
                                            (ß v = currentNS().intern(sym))
                                            (ß shadowsCoreMapping = true)
                                            (ß registerVar(v))
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Can't create defs outside of current ns")))
                                        )
                                    )
                                )
                                (let [#_"IPersistentMap" mm (ß sym.meta())]
                                    (let [#_"boolean" isDynamic (ß RT.booleanCast(RT.get(mm, dynamicKey)))]
                                        (when isDynamic
                                            (ß v.setDynamic())
                                        )
                                        (when (ß !isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2)
                                            (ß RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", sym, SOURCE_PATH.get(), LINE.get()))
                                        )
                                        (when (ß RT.booleanCast(RT.get(mm, arglistsKey)))
                                            (let [#_"IPersistentMap" vm (ß v.meta())]
                                                ;; drop quote
                                                (ß vm = (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey))))
                                                (ß v.setMeta(vm))
                                            )
                                        )
                                        (let [#_"Object" source_path (ß SOURCE_PATH.get())]
                                            (ß source_path = (source_path == nil) ? "NO_SOURCE_FILE" :or source_path)
                                            (ß mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path))
                                            (when (ß docstring != nil)
                                                (ß mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring))
                                            )
                                            (ß mm = (IPersistentMap) elideMeta(mm))
                                            (let [#_"Expr" meta (ß (mm.count() == 0) ? nil :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm))]
                                                (ß new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name), meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns AssignExpr (§ implements Expr)
        (§ field #_"AssignableExpr" target)
        (§ field #_"Expr" val)

        (§ constructor #_"AssignExpr" AssignExpr [#_"AssignableExpr" target, #_"Expr" val]
            (ß this.target = target)
            (ß this.val = val)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (ß target.evalAssign(val))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß target.emitAssign(context, objx, gen, val))
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß val.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß val.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß RT.length(form) != 3)
                        (throw (ß new IllegalArgumentException("Malformed assignment, expecting (set! target val)")))
                    )
                    (let [#_"Expr" target (ß analyze(C.EXPRESSION, RT.second(form)))]
                        (when (ß !(target instanceof AssignableExpr))
                            (throw (ß new IllegalArgumentException("Invalid assignment target")))
                        )
                        (ß new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form))))
                    )
                )
            )
        )
    )

    (class-ns VarExpr (§ implements Expr, AssignableExpr)
        (§ field #_"Var" var)
        (§ field #_"Object" tag)
        (§ def #_"Method" getMethod (ß Method.getMethod("Object get()")))
        (§ def #_"Method" setMethod (ß Method.getMethod("Object set(Object)")))

        (§ field #_"Class" jc)

        (§ constructor #_"VarExpr" VarExpr [#_"Var" var, #_"Symbol" tag]
            (ß this.var = var)
            (ß this.tag = (tag != nil) ? tag :or var.getTag())
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (ß var.deref())
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitVarValue(gen, var))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )

        #_method
        (§ defn #_"Object" evalAssign [this, #_"Expr" val]
            (ß var.set(val.eval()))
        )

        #_method
        (§ defn #_"void" emitAssign [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (ß objx.emitVar(gen, var))
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeVirtual(VAR_TYPE, setMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns TheVarExpr (§ implements Expr)
        (§ field #_"Var" var)

        (§ constructor #_"TheVarExpr" TheVarExpr [#_"Var" var]
            (ß this.var = var)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            var
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitVar(gen, var))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß Var.class)
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                (let [#_"Symbol" sym (ß (Symbol) RT.second(form))]
                    (let [#_"Var" v (ß lookupVar(sym, false))]
                        (when (ß v != nil)
                            (§ return (ß new TheVarExpr(v)))
                        )
                        (throw (ß Util.runtimeException("Unable to resolve var: " + sym + " in this context")))
                    )
                )
            )
        )
    )

    (class-ns KeywordExpr (§ extends LiteralExpr)
        (§ field #_"Keyword" k)

        (§ constructor #_"KeywordExpr" KeywordExpr [#_"Keyword" k]
            (ß this.k = k)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            k
        )

        #_method
        (§ defn #_"Object" eval [this]
            k
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitKeyword(gen, k))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß Keyword.class)
        )
    )

    (class-ns ImportExpr (§ implements Expr)
        (§ field #_"String" c)

        (§ def #_"Method" forNameMethod (ß Method.getMethod("Class classForNameNonLoading(String)")))
        (§ def #_"Method" importClassMethod (ß Method.getMethod("Class importClass(Class)")))
        (§ def #_"Method" derefMethod (ß Method.getMethod("Object deref()")))

        (§ constructor #_"ImportExpr" ImportExpr [#_"String" c]
            (ß this.c = c)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"Namespace" ns (ß (Namespace) RT.CURRENT_NS.deref())]
                (ß ns.importClass(RT.classForNameNonLoading(c)))
                nil
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE))
            (ß gen.invokeVirtual(VAR_TYPE, derefMethod))
            (ß gen.checkCast(NS_TYPE))
            (ß gen.push(c))
            (ß gen.invokeStatic(RT_TYPE, forNameMethod))
            (ß gen.invokeVirtual(NS_TYPE, importClassMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            false
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (throw (ß new IllegalArgumentException("ImportExpr has no Java class")))
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                (ß new ImportExpr((String) RT.second(form)))
            )
        )
    )

    #_abstract
    (class-ns LiteralExpr (§ implements Expr)
        (§ abstract Object val())

        #_method
        (§ defn #_"Object" eval [this]
            (ß val())
        )
    )

    (§ interface AssignableExpr
        (§ abstract Object evalAssign(Expr val))
        (§ abstract void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val))
    )

    (§ interface MaybePrimitiveExpr (§ extends Expr)
        (§ abstract boolean canEmitPrimitive())
        (§ abstract void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen))
    )

    #_abstract
    (class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ def #_"Type" BOOLEAN_TYPE (ß Type.getType(Boolean.class)))
        (§ def #_"Type" CHAR_TYPE (ß Type.getType(Character.class)))
        (§ def #_"Type" INTEGER_TYPE (ß Type.getType(Integer.class)))
        (§ def #_"Type" LONG_TYPE (ß Type.getType(Long.class)))
        (§ def #_"Type" FLOAT_TYPE (ß Type.getType(Float.class)))
        (§ def #_"Type" DOUBLE_TYPE (ß Type.getType(Double.class)))
        (§ def #_"Type" SHORT_TYPE (ß Type.getType(Short.class)))
        (§ def #_"Type" BYTE_TYPE (ß Type.getType(Byte.class)))
        (§ def #_"Type" NUMBER_TYPE (ß Type.getType(Number.class)))

        (§ def #_"Method" charValueMethod (ß Method.getMethod("char charValue()")))
        (§ def #_"Method" booleanValueMethod (ß Method.getMethod("boolean booleanValue()")))

        (§ def #_"Method" charValueOfMethod (ß Method.getMethod("Character valueOf(char)")))
        (§ def #_"Method" intValueOfMethod (ß Method.getMethod("Integer valueOf(int)")))
        (§ def #_"Method" longValueOfMethod (ß Method.getMethod("Long valueOf(long)")))
        (§ def #_"Method" floatValueOfMethod (ß Method.getMethod("Float valueOf(float)")))
        (§ def #_"Method" doubleValueOfMethod (ß Method.getMethod("Double valueOf(double)")))
        (§ def #_"Method" shortValueOfMethod (ß Method.getMethod("Short valueOf(short)")))
        (§ def #_"Method" byteValueOfMethod (ß Method.getMethod("Byte valueOf(byte)")))

        (§ def #_"Method" intValueMethod (ß Method.getMethod("int intValue()")))
        (§ def #_"Method" longValueMethod (ß Method.getMethod("long longValue()")))
        (§ def #_"Method" floatValueMethod (ß Method.getMethod("float floatValue()")))
        (§ def #_"Method" doubleValueMethod (ß Method.getMethod("double doubleValue()")))
        (§ def #_"Method" byteValueMethod (ß Method.getMethod("byte byteValue()")))
        (§ def #_"Method" shortValueMethod (ß Method.getMethod("short shortValue()")))

        (§ def #_"Method" fromIntMethod (ß Method.getMethod("cloiure.lang.Num from(int)")))
        (§ def #_"Method" fromLongMethod (ß Method.getMethod("cloiure.lang.Num from(long)")))
        (§ def #_"Method" fromDoubleMethod (ß Method.getMethod("cloiure.lang.Num from(double)")))

        (§ defn #_"void" emitBoxReturn [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" returnType]
            (when (ß returnType.isPrimitive())
                (cond (ß returnType == boolean.class)
                    (do
                        (let [#_"Label" falseLabel (ß gen.newLabel())]
                            (let [#_"Label" endLabel (ß gen.newLabel())]
                                (ß gen.ifZCmp(GeneratorAdapter.EQ, falseLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.goTo(endLabel))
                                (ß gen.mark(falseLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.mark(endLabel))
                            )
                        )
                    )
                    (ß returnType == void.class)
                    (do
                        (ß NIL_EXPR.emit(C.EXPRESSION, objx, gen))
                    )
                    (ß returnType == char.class)
                    (do
                        (ß gen.invokeStatic(CHAR_TYPE, charValueOfMethod))
                    )
                    :else
                    (do
                        (cond (ß returnType == int.class)
                            (do
                                (ß gen.invokeStatic(INTEGER_TYPE, intValueOfMethod))
                            )
                            (ß returnType == float.class)
                            (do
                                (ß gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod))
                            )
                            (ß returnType == double.class)
                            (do
                                (ß gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod))
                            )
                            (ß returnType == long.class)
                            (do
                                (ß gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)")))
                            )
                            (ß returnType == byte.class)
                            (do
                                (ß gen.invokeStatic(BYTE_TYPE, byteValueOfMethod))
                            )
                            (ß returnType == short.class)
                            (do
                                (ß gen.invokeStatic(SHORT_TYPE, shortValueOfMethod))
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn #_"void" emitUnboxArg [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" paramType]
            (if (ß paramType.isPrimitive())
                (do
                    (cond (ß paramType == boolean.class)
                        (do
                            (ß gen.checkCast(BOOLEAN_TYPE))
                            (ß gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod))
                        )
                        (ß paramType == char.class)
                        (do
                            (ß gen.checkCast(CHAR_TYPE))
                            (ß gen.invokeVirtual(CHAR_TYPE, charValueMethod))
                        )
                        :else
                        (do
                            (let [#_"Method" m nil]
                                (ß gen.checkCast(NUMBER_TYPE))
                                (if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                                    (do
                                        (cond (ß paramType == int.class)
                                            (do
                                                (ß m = Method.getMethod("int uncheckedIntCast(Object)"))
                                            )
                                            (ß paramType == float.class)
                                            (do
                                                (ß m = Method.getMethod("float uncheckedFloatCast(Object)"))
                                            )
                                            (ß paramType == double.class)
                                            (do
                                                (ß m = Method.getMethod("double uncheckedDoubleCast(Object)"))
                                            )
                                            (ß paramType == long.class)
                                            (do
                                                (ß m = Method.getMethod("long uncheckedLongCast(Object)"))
                                            )
                                            (ß paramType == byte.class)
                                            (do
                                                (ß m = Method.getMethod("byte uncheckedByteCast(Object)"))
                                            )
                                            (ß paramType == short.class)
                                            (do
                                                (ß m = Method.getMethod("short uncheckedShortCast(Object)"))
                                            )
                                        )
                                    )
                                    (do
                                        (cond (ß paramType == int.class)
                                            (do
                                                (ß m = Method.getMethod("int intCast(Object)"))
                                            )
                                            (ß paramType == float.class)
                                            (do
                                                (ß m = Method.getMethod("float floatCast(Object)"))
                                            )
                                            (ß paramType == double.class)
                                            (do
                                                (ß m = Method.getMethod("double doubleCast(Object)"))
                                            )
                                            (ß paramType == long.class)
                                            (do
                                                (ß m = Method.getMethod("long longCast(Object)"))
                                            )
                                            (ß paramType == byte.class)
                                            (do
                                                (ß m = Method.getMethod("byte byteCast(Object)"))
                                            )
                                            (ß paramType == short.class)
                                            (do
                                                (ß m = Method.getMethod("short shortCast(Object)"))
                                            )
                                        )
                                    )
                                )
                                (ß gen.invokeStatic(RT_TYPE, m))
                            )
                        )
                    )
                )
                (do
                    (ß gen.checkCast(Type.getType(paramType)))
                )
            )
            nil
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (. x fieldname-sym) or
                    ;; (. x 0-ary-method)
                    ;; (. x methodname-sym args+)
                    ;; (. x (methodname-sym args?))
                    (when (ß RT.length(form) < 3)
                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (. target member ...)")))
                    )
                    ;; determine static or instance
                    ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                    (let [#_"int" line (ß lineDeref())]
                        (let [#_"int" column (ß columnDeref())]
                            (let [#_"String" source (ß (String) SOURCE.deref())]
                                (let [#_"Class" c (ß maybeClass(RT.second(form), false))]
                                    ;; at this point c will be non-null if static
                                    (let [#_"Expr" instance nil]
                                        (when (ß c == nil)
                                            (ß instance = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))
                                        )

                                        (let [#_"boolean" maybeField (ß (RT.length(form) == 3) && (RT.third(form) instanceof Symbol))]
                                            (when (ß maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == \-))
                                                (let [#_"Symbol" sym (ß (Symbol) RT.third(form))]
                                                    (cond (ß c != nil)
                                                        (do
                                                            (ß maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0)
                                                        )
                                                        (ß instance != nil && instance.hasJavaClass() && instance.getJavaClass() != nil)
                                                        (do
                                                            (ß maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0)
                                                        )
                                                    )
                                                )
                                            )

                                            (if maybeField ;; field
                                                (do
                                                    (let [#_"Symbol" sym (ß (((Symbol)RT.third(form)).name.charAt(0) == \-) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form))]
                                                        (let [#_"Symbol" tag (ß tagOf(form))]
                                                            (if (ß c != nil)
                                                                (do
                                                                    (ß new StaticFieldExpr(line, column, c, munge(sym.name), tag))
                                                                )
                                                                (do
                                                                    (ß new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == \-)))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (let [#_"ISeq" call (ß (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form))))]
                                                        (when (ß !(RT.first(call) instanceof Symbol))
                                                            (throw (ß new IllegalArgumentException("Malformed member expression")))
                                                        )
                                                        (let [#_"Symbol" sym (ß (Symbol) RT.first(call))]
                                                            (let [#_"Symbol" tag (ß tagOf(form))]
                                                                (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                                                    (let [#_"boolean" tailPosition (ß inTailCall(context))]
                                                                        (loop-when-recur [(ß ISeq s = RT.next(call))] (ß s != nil) [(ß s = s.next())]
                                                                            (ß args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                                                                        )
                                                                        (if (ß c != nil)
                                                                            (do
                                                                                (ß new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition))
                                                                            )
                                                                            (do
                                                                                (ß new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn #_"Class" maybeClass [#_"Object" form, #_"boolean" stringOk]
            (when (ß form instanceof Class)
                (§ return (ß (Class) form))
            )
            (let [#_"Class" c nil]
                (cond (ß form instanceof Symbol)
                    (do
                        (let [#_"Symbol" sym (ß (Symbol) form)]
                            (when (ß sym.ns == nil) ;; if ns-qualified can't be classname
                                (when (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                                    (§ return (ß (Class) COMPILE_STUB_CLASS.get()))
                                )
                                (if (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
                                    (do
                                        (ß c = RT.classForNameNonLoading(sym.name))
                                    )
                                    (do
                                        (let [#_"Object" o (ß currentNS().getMapping(sym))]
                                            (cond (ß o instanceof Class)
                                                (do
                                                    (ß c = (Class) o)
                                                )
                                                (ß LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form))
                                                (do
                                                    (§ return nil)
                                                )
                                                :else
                                                (do
                                                    (try
                                                        (ß c = RT.classForNameNonLoading(sym.name))
                                                        (catch Exception e
                                                            ;; aargh
                                                            ;; leave c set to nil -> return nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß stringOk && form instanceof String)
                    (do
                        (ß c = RT.classForNameNonLoading((String) form))
                    )
                )
                c
            )
        )

        (§ defn #_"Class" maybeSpecialTag [#_"Symbol" sym]
            (let [#_"Class" c (ß primClass(sym))]
                (cond (ß c != nil)
                    (do
                        (§ return c)
                    )
                    (ß sym.name.equals("objects"))
                    (do
                        (ß c = Object[].class)
                    )
                    (ß sym.name.equals("ints"))
                    (do
                        (ß c = int[].class)
                    )
                    (ß sym.name.equals("longs"))
                    (do
                        (ß c = long[].class)
                    )
                    (ß sym.name.equals("floats"))
                    (do
                        (ß c = float[].class)
                    )
                    (ß sym.name.equals("doubles"))
                    (do
                        (ß c = double[].class)
                    )
                    (ß sym.name.equals("chars"))
                    (do
                        (ß c = char[].class)
                    )
                    (ß sym.name.equals("shorts"))
                    (do
                        (ß c = short[].class)
                    )
                    (ß sym.name.equals("bytes"))
                    (do
                        (ß c = byte[].class)
                    )
                    (ß sym.name.equals("booleans"))
                    (do
                        (ß c = boolean[].class)
                    )
                )
                c
            )
        )

        (§ defn #_"Class" tagToClass [#_"Object" tag]
            (let [#_"Class" c nil]
                (when (ß tag instanceof Symbol)
                    (let [#_"Symbol" sym (ß (Symbol) tag)]
                        (when (ß sym.ns == nil) ;; if ns-qualified can't be classname
                            (ß c = maybeSpecialTag(sym))
                        )
                    )
                )
                (when (ß c == nil)
                    (ß c = maybeClass(tag, true))
                )
                (when (ß c != nil)
                    (§ return c)
                )
                (throw (ß new IllegalArgumentException("Unable to resolve classname: " + tag)))
            )
        )
    )

    #_abstract
    (class-ns FieldExpr (§ extends HostExpr)
    )

    (class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ field #_"Expr" target)
        (§ field #_"Class" targetClass)
        (§ field #_"java.lang.reflect.Field" field)
        (§ field #_"String" fieldName)
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"Symbol" tag)
        (§ field #_"boolean" requireField)

        (§ def #_"Method" invokeNoArgInstanceMember (ß Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)")))
        (§ def #_"Method" setInstanceFieldMethod (ß Method.getMethod("Object setInstanceField(Object,String,Object)")))

        (§ field #_"Class" jc)

        (§ constructor #_"InstanceFieldExpr" InstanceFieldExpr [#_"int" line, #_"int" column, #_"Expr" target, #_"String" fieldName, #_"Symbol" tag, #_"boolean" requireField]
            (ß this.target = target)
            (ß this.targetClass = target.hasJavaClass() ? target.getJavaClass() :or nil)
            (ß this.field = (targetClass != nil) ? Reflector.getField(targetClass, fieldName, false) :or nil)
            (ß this.fieldName = fieldName)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.requireField = requireField)

            (when (ß field == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (if (ß targetClass == nil)
                    (do
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName))
                    )
                    (do
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName()))
                    )
                )
            )
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (ß Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß (targetClass != nil && field != nil && Util.isPrimitive(field.getType())))
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                    (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.push(fieldName))
                    (ß gen.push(requireField))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (field != nil || tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            jc
        )

        #_method
        (§ defn #_"Object" evalAssign [this, #_"Expr" val]
            (ß Reflector.setInstanceField(target.eval(), fieldName, val.eval()))
        )

        #_method
        (§ defn #_"void" emitAssign [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß val.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.dupX1())
                    (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
                    (ß gen.putField(getType(targetClass), fieldName, Type.getType(field.getType())))
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.push(fieldName))
                    (ß val.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ field #_"String" fieldName)
        (§ field #_"Class" c)
        (§ field #_"java.lang.reflect.Field" field)
        (§ field #_"Symbol" tag)

        (§ field #_"int" line)
        (§ field #_"int" column)

        (§ field #_"Class" jc)

        (§ constructor #_"StaticFieldExpr" StaticFieldExpr [#_"int" line, #_"int" column, #_"Class" c, #_"String" fieldName, #_"Symbol" tag]
            (ß this.fieldName = fieldName)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.c = c)
            (try
                (ß field = c.getField(fieldName))
                (catch NoSuchFieldException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
            (ß this.tag = tag)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (ß Reflector.getStaticField(c, fieldName))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß Util.isPrimitive(field.getType()))
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.visitLineNumber(line, gen.mark()))

            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            jc
        )

        #_method
        (§ defn #_"Object" evalAssign [this, #_"Expr" val]
            (ß Reflector.setStaticField(c, fieldName, val.eval()))
        )

        #_method
        (§ defn #_"void" emitAssign [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.dup())
            (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
            (ß gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (§ defn #_"Class" maybePrimitiveType [#_"Expr" e]
        (when (ß e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
            (let [#_"Class" c (ß e.getJavaClass())]
                (when (ß Util.isPrimitive(c))
                    (§ return c)
                )
            )
        )
        nil
    )

    (§ defn #_"Class" maybeJavaClass [#_"Collection<Expr>" exprs]
        (let [#_"Class" match nil]
            (try
                (doseq [#_"Expr" e exprs]
                    (when (ß e instanceof ThrowExpr)
                        (§ continue )
                    )
                    (when (ß !e.hasJavaClass())
                        (§ return nil)
                    )
                    (let [#_"Class" c (ß e.getJavaClass())]
                        (cond (ß match == nil)
                            (do
                                (ß match = c)
                            )
                            (ß match != c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception e
                    (§ return nil)
                )
            )
            match
        )
    )

    #_abstract
    (class-ns MethodExpr (§ extends HostExpr)
        (§ defn #_"void" emitArgsAsArray [#_"IPersistentVector" args, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.push(args.count()))
            (ß gen.newArray(OBJECT_TYPE))
            (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (ß gen.dup())
                (ß gen.push(i))
                (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                (ß gen.arrayStore(OBJECT_TYPE))
            )
            nil
        )

        (§ defn #_"void" emitTypedArgs [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class[]" parameterTypes, #_"IPersistentVector" args]
            (loop-when-recur [(ß int i = 0)] (ß i < parameterTypes.length) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) args.nth(i))]
                    (try
                        (let [#_"Class" primc (ß maybePrimitiveType(e))]
                            (cond (ß primc == parameterTypes[i])
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                    )
                                )
                                (ß primc == int.class && parameterTypes[i] == long.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(I2L))
                                    )
                                )
                                (ß primc == long.class && parameterTypes[i] == int.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                                            (do
                                                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)")))
                                            )
                                            (do
                                                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                            )
                                        )
                                    )
                                )
                                (ß primc == float.class && parameterTypes[i] == double.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(F2D))
                                    )
                                )
                                (ß primc == double.class && parameterTypes[i] == float.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(D2F))
                                    )
                                )
                                :else
                                (do
                                    (ß e.emit(C.EXPRESSION, objx, gen))
                                    (ß HostExpr.emitUnboxArg(objx, gen, parameterTypes[i]))
                                )
                            )
                        )
                        (catch Exception e1
                            (throw (ß Util.sneakyThrow(e1)))
                        )
                    )
                )
            )
            nil
        )
    )

    (class-ns InstanceMethodExpr (§ extends MethodExpr)
        (§ field #_"Expr" target)
        (§ field #_"String" methodName)
        (§ field #_"IPersistentVector" args)
        (§ field #_"String" source)
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"Symbol" tag)
        (§ field #_"boolean" tailPosition)
        (§ field #_"java.lang.reflect.Method" method)

        (§ field #_"Class" jc)

        (§ def #_"Method" invokeInstanceMethodMethod (ß Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])")))

        (§ constructor #_"InstanceMethodExpr" InstanceMethodExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" target, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.args = args)
            (ß this.methodName = methodName)
            (ß this.target = target)
            (ß this.tag = tag)
            (ß this.tailPosition = tailPosition)
            (if (ß target.hasJavaClass() && target.getJavaClass() != nil)
                (do
                    (let [#_"List" methods (ß Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false))]
                        (if (ß methods.isEmpty())
                            (do
                                (ß method = nil)
                                (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName()))
                                )
                            )
                            (do
                                (let [#_"int" methodidx 0]
                                    (when (ß methods.size() > 1)
                                        (let [#_"ArrayList<Class[]>" params (ß new ArrayList())]
                                            (let [#_"ArrayList<Class>" rets (ß new ArrayList())]
                                                (loop-when-recur [(ß int i = 0)] (ß i < methods.size()) [(ß i++)]
                                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))]
                                                        (ß params.add(m.getParameterTypes()))
                                                        (ß rets.add(m.getReturnType()))
                                                    )
                                                )
                                                (ß methodidx = getMatchingParams(methodName, params, args, rets))
                                            )
                                        )
                                    )
                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))]
                                        (when (ß m != nil && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (ß m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m))
                                        )
                                        (ß method = m)
                                        (when (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                            (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (ß method = nil)
                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), line, column, methodName))
                    )
                )
            )
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (try
                (let [#_"Object" targetval (ß target.eval())]
                    (let [#_"Object[]" argvals (ß new Object[args.count()])]
                        (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                            (ß argvals[i] = ((Expr) args.nth(i)).eval())
                        )
                        (when (ß method != nil)
                            (let [#_"LinkedList" ms (ß new LinkedList())]
                                (ß ms.add(method))
                                (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)))
                            )
                        )
                        (ß Reflector.invokeInstanceMethod(targetval, methodName, argvals))
                    )
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß method != nil)
                (do
                    (let [#_"Type" type (ß Type.getType(method.getDeclaringClass()))]
                        (ß target.emit(C.EXPRESSION, objx, gen))
                        (ß gen.checkCast(type))
                        (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                        (ß gen.visitLineNumber(line, gen.mark()))
                        (when (ß tailPosition && !objx.canBeDirect)
                            (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                (ß method.emitClearThis(gen))
                            )
                        )
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (if (ß method.getDeclaringClass().isInterface())
                                (do
                                    (ß gen.invokeInterface(type, m))
                                )
                                (do
                                    (ß gen.invokeVirtual(type, m))
                                )
                            )
                        )
                    )
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß method != nil)
                (do
                    (let [#_"Type" type (ß Type.getType(method.getDeclaringClass()))]
                        (ß target.emit(C.EXPRESSION, objx, gen))
                        (ß gen.checkCast(type))
                        (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                        (ß gen.visitLineNumber(line, gen.mark()))
                        (when (ß context == C.RETURN)
                            (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                (ß method.emitClearLocals(gen))
                            )
                        )
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (if (ß method.getDeclaringClass().isInterface())
                                (do
                                    (ß gen.invokeInterface(type, m))
                                )
                                (do
                                    (ß gen.invokeVirtual(type, m))
                                )
                            )
                            (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                        )
                    )
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.push(methodName))
                    (ß emitArgsAsArray(args, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (method != nil || tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            jc
        )
    )

    (class-ns StaticMethodExpr (§ extends MethodExpr)
        (§ field #_"Class" c)
        (§ field #_"String" methodName)
        (§ field #_"IPersistentVector" args)
        (§ field #_"String" source)
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"java.lang.reflect.Method" method)
        (§ field #_"Symbol" tag)
        (§ field #_"boolean" tailPosition)

        (§ def #_"Method" forNameMethod (ß Method.getMethod("Class classForName(String)")))
        (§ def #_"Method" invokeStaticMethodMethod (ß Method.getMethod("Object invokeStaticMethod(Class,String,Object[])")))
        (§ def #_"Keyword" warnOnBoxedKeyword (ß Keyword.intern("warn-on-boxed")))

        (§ field #_"Class" jc)

        (§ constructor #_"StaticMethodExpr" StaticMethodExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"Class" c, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
            (ß this.c = c)
            (ß this.methodName = methodName)
            (ß this.args = args)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.tailPosition = tailPosition)

            (let [#_"List" methods (ß Reflector.getMethods(c, args.count(), methodName, true))]
                (when (ß methods.isEmpty())
                    (throw (ß new IllegalArgumentException("No matching method: " + methodName)))
                )

                (let [#_"int" methodidx 0]
                    (when (ß methods.size() > 1)
                        (let [#_"ArrayList<Class[]>" params (ß new ArrayList())]
                            (let [#_"ArrayList<Class>" rets (ß new ArrayList())]
                                (loop-when-recur [(ß int i = 0)] (ß i < methods.size()) [(ß i++)]
                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))]
                                        (ß params.add(m.getParameterTypes()))
                                        (ß rets.add(m.getReturnType()))
                                    )
                                )
                                (ß methodidx = getMatchingParams(methodName, params, args, rets))
                            )
                        )
                    )
                    (ß method = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))
                    (when (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args)))
                    )
                    (when (ß method != nil && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method))
                        (ß RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), line, column, method.toString()))
                    )
                    this
                )
            )
        )

        (§ defn #_"boolean" isBoxedMath [#_"java.lang.reflect.Method" m]
            (let [#_"Class" c (ß m.getDeclaringClass())]
                (when (ß c.equals(Numbers.class))
                    (let [#_"WarnBoxedMath" boxedMath (ß m.getAnnotation(WarnBoxedMath.class))]
                        (when (ß boxedMath != nil)
                            (§ return (ß boxedMath.value()))
                        )

                        (let [#_"Class[]" argTypes (ß m.getParameterTypes())]
                            (doseq [#_"Class" argType argTypes]
                                (when (ß argType.equals(Object.class) || argType.equals(Number.class))
                                    (§ return true)
                                )
                            )
                        )
                    )
                )
                false
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (try
                (let [#_"Object[]" argvals (ß new Object[args.count()])]
                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                        (ß argvals[i] = ((Expr) args.nth(i)).eval())
                    )
                    (when (ß method != nil)
                        (let [#_"LinkedList" ms (ß new LinkedList())]
                            (ß ms.add(method))
                            (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, nil, argvals)))
                        )
                    )
                    (ß Reflector.invokeStaticMethod(c, methodName, argvals))
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        #_method
        (§ defn #_"boolean" canEmitIntrinsicPredicate [this]
            (ß (method != nil && RT.get(Intrinsics.preds, method.toString()) != nil))
        )

        #_method
        (§ defn #_"void" emitIntrinsicPredicate [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Label" falseLabel]
            (ß gen.visitLineNumber(line, gen.mark()))
            (if (ß method != nil)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (let [#_"Object[]" predOps (ß (Object[]) RT.get(Intrinsics.preds, method.toString()))]
                        (loop-when-recur [(ß int i = 0)] (ß i < predOps.length - 1) [(ß i++)]
                            (ß gen.visitInsn((Integer)predOps[i]))
                        )
                        (ß gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel))
                    )
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß method != nil)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (let [#_"Object" ops (ß RT.get(Intrinsics.ops, method.toString()))]
                        (if (ß ops != nil)
                            (do
                                (if (ß ops instanceof Object[])
                                    (do
                                        (doseq [#_"Object" op (ß (Object[])ops)]
                                            (ß gen.visitInsn((Integer) op))
                                        )
                                    )
                                    (do
                                        (ß gen.visitInsn((Integer) ops))
                                    )
                                )
                            )
                            (do
                                (let [#_"Type" type (ß Type.getType(c))]
                                    (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                                        (ß gen.invokeStatic(type, m))
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß method != nil)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß tailPosition && !objx.canBeDirect)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearThis(gen))
                        )
                    )
                    (let [#_"Type" type (ß Type.getType(c))]
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (ß gen.invokeStatic(type, m))
                            (let [#_"Class" retClass (ß method.getReturnType())]
                                (if (ß context == C.STATEMENT)
                                    (do
                                        (cond (ß retClass == long.class || retClass == double.class)
                                            (do
                                                (ß gen.pop2())
                                            )
                                            (ß retClass != void.class)
                                            (do
                                                (ß gen.pop())
                                            )
                                        )
                                    )
                                    (do
                                        (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.push(c.getName()))
                    (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                    (ß gen.push(methodName))
                    (ß emitArgsAsArray(args, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (method != nil || tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            jc
        )
    )

    (class-ns UnresolvedVarExpr (§ implements Expr)
        (§ field #_"Symbol" symbol)

        (§ constructor #_"UnresolvedVarExpr" UnresolvedVarExpr [#_"Symbol" symbol]
            (ß this.symbol = symbol)
            this
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            false
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (throw (ß new IllegalArgumentException("UnresolvedVarExpr has no Java class")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            nil
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new IllegalArgumentException("UnresolvedVarExpr cannot be evalled")))
        )
    )

    (class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
        (§ field #_"Number" n)
        (§ field #_"int" id)

        (§ constructor #_"NumberExpr" NumberExpr [#_"Number" n]
            (ß this.n = n)
            (ß this.id = registerConstant(n))
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            n
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (when (ß context != C.STATEMENT)
                (ß objx.emitConstant(gen, id))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (cond (ß n instanceof Integer)
                (do
                    (ß long.class)
                )
                (ß n instanceof Double)
                (do
                    (ß double.class)
                )
                (ß n instanceof Long)
                (do
                    (ß long.class)
                )
                :else
                (do
                    (throw (ß new IllegalStateException("Unsupported Number type: " + n.getClass().getName())))
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            true
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (cond (ß n instanceof Integer)
                (do
                    (ß gen.push(n.longValue()))
                )
                (ß n instanceof Double)
                (do
                    (ß gen.push(n.doubleValue()))
                )
                (ß n instanceof Long)
                (do
                    (ß gen.push(n.longValue()))
                )
            )
            nil
        )

        (§ defn #_"Expr" parse [#_"Number" form]
            (if (ß form instanceof Integer || form instanceof Double || form instanceof Long)
                (do
                    (ß new NumberExpr(form))
                )
                (do
                    (ß new ConstantExpr(form))
                )
            )
        )
    )

    (class-ns ConstantExpr (§ extends LiteralExpr)
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        (§ field #_"Object" v)
        (§ field #_"int" id)

        (§ constructor #_"ConstantExpr" ConstantExpr [#_"Object" v]
            (ß this.v = v)
            (ß this.id = registerConstant(v))
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            v
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitConstant(gen, id))

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß Modifier.isPublic(v.getClass().getModifiers()))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (cond (ß v instanceof APersistentMap)
                (do
                    (ß APersistentMap.class)
                )
                (ß v instanceof APersistentSet)
                (do
                    (ß APersistentSet.class)
                )
                (ß v instanceof APersistentVector)
                (do
                    (ß APersistentVector.class)
                )
                :else
                (do
                    (ß v.getClass())
                )
            )
        )

        (class-ns Parser (§ implements IParser)
            (§ def #_"Keyword" formKey (ß Keyword.intern("form")))

            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                (let [#_"int" argCount (ß RT.count(form) - 1)]
                    (when (ß argCount != 1)
                        (let [#_"IPersistentMap" exData (ß new PersistentArrayMap(new Object[] (§ formKey, form )))]
                            (throw (ß new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData)))
                        )
                    )
                    (let [#_"Object" v (ß RT.second(form))]
                        (cond (ß v == nil)
                            (do
                                (§ return (ß NIL_EXPR))
                            )
                            (ß v == Boolean.TRUE)
                            (do
                                (§ return (ß TRUE_EXPR))
                            )
                            (ß v == Boolean.FALSE)
                            (do
                                (§ return (ß FALSE_EXPR))
                            )
                        )
                        (cond (ß v instanceof Number)
                            (do
                                (ß NumberExpr.parse((Number)v))
                            )
                            (ß v instanceof String)
                            (do
                                (ß new StringExpr((String) v))
                            )
                            (ß v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0)
                            (do
                                (ß new EmptyExpr(v))
                            )
                            :else
                            (do
                                (ß new ConstantExpr(v))
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns NilExpr (§ extends LiteralExpr)
        #_method
        (§ defn #_"Object" val [this]
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            nil
        )
    )

    (§ def #_"NilExpr" NIL_EXPR (ß new NilExpr()))

    (class-ns BooleanExpr (§ extends LiteralExpr)
        (§ field #_"boolean" val)

        (§ constructor #_"BooleanExpr" BooleanExpr [#_"boolean" val]
            (ß this.val = val)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            (ß val ? RT.T :or RT.F)
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if val
                (do
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                )
                (do
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß Boolean.class)
        )
    )

    (§ def #_"BooleanExpr" TRUE_EXPR (ß new BooleanExpr(true)))
    (§ def #_"BooleanExpr" FALSE_EXPR (ß new BooleanExpr(false)))

    (class-ns StringExpr (§ extends LiteralExpr)
        (§ field #_"String" str)

        (§ constructor #_"StringExpr" StringExpr [#_"String" str]
            (ß this.str = str)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            str
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (when (ß context != C.STATEMENT)
                (ß gen.push(str))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß String.class)
        )
    )

    (class-ns MonitorEnterExpr (§ extends UntypedExpr)
        (§ field #_"Expr" target)

        (§ constructor #_"MonitorEnterExpr" MonitorEnterExpr [#_"Expr" target]
            (ß this.target = target)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval monitor-enter")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorEnter())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                (ß new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns MonitorExitExpr (§ extends UntypedExpr)
        (§ field #_"Expr" target)

        (§ constructor #_"MonitorExitExpr" MonitorExitExpr [#_"Expr" target]
            (ß this.target = target)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval monitor-exit")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorExit())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                (ß new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns TryExpr (§ implements Expr)
        (§ field #_"Expr" tryExpr)
        (§ field #_"Expr" finallyExpr)
        (§ field #_"PersistentVector" catchExprs)
        (§ field #_"int" retLocal)
        (§ field #_"int" finallyLocal)

        (class-ns CatchClause
            (§ field #_"Class" c)
            (§ field #_"LocalBinding" lb)
            (§ field #_"Expr" handler)
            (§ field #_"Label" label)
            (§ field #_"Label" endLabel)

            (§ constructor #_"CatchClause" CatchClause [#_"Class" c, #_"LocalBinding" lb, #_"Expr" handler]
                (ß this.c = c)
                (ß this.lb = lb)
                (ß this.handler = handler)
                this
            )
        )

        (§ constructor #_"TryExpr" TryExpr [#_"Expr" tryExpr, #_"PersistentVector" catchExprs, #_"Expr" finallyExpr, #_"int" retLocal, #_"int" finallyLocal]
            (ß this.tryExpr = tryExpr)
            (ß this.catchExprs = catchExprs)
            (ß this.finallyExpr = finallyExpr)
            (ß this.retLocal = retLocal)
            (ß this.finallyLocal = finallyLocal)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval try")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" startTry (ß gen.newLabel())]
                (let [#_"Label" endTry (ß gen.newLabel())]
                    (let [#_"Label" end (ß gen.newLabel())]
                        (let [#_"Label" ret (ß gen.newLabel())]
                            (let [#_"Label" finallyLabel (ß gen.newLabel())]
                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß clause.label = gen.newLabel())
                                        (ß clause.endLabel = gen.newLabel())
                                    )
                                )

                                (ß gen.mark(startTry))
                                (ß tryExpr.emit(context, objx, gen))
                                (when (ß context != C.STATEMENT)
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                                )
                                (ß gen.mark(endTry))
                                (when (ß finallyExpr != nil)
                                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                )
                                (ß gen.goTo(ret))

                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.mark(clause.label))
                                        ;; exception should be on stack
                                        ;; put in clause local
                                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx))
                                        (ß clause.handler.emit(context, objx, gen))
                                        (when (ß context != C.STATEMENT)
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                                        )
                                        (ß gen.mark(clause.endLabel))

                                        (when (ß finallyExpr != nil)
                                            (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                        )
                                        (ß gen.goTo(ret))
                                    )
                                )
                                (when (ß finallyExpr != nil)
                                    (ß gen.mark(finallyLabel))
                                    ;; exception should be on stack
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal))
                                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal))
                                    (ß gen.throwException())
                                )
                                (ß gen.mark(ret))
                                (when (ß context != C.STATEMENT)
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal))
                                )
                                (ß gen.mark(end))
                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace(\., \/)))
                                    )
                                )
                                (when (ß finallyExpr != nil)
                                    (ß gen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))
                                    (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                        (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                            (ß gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, nil))
                                        )
                                    )
                                )
                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", nil, clause.label, clause.endLabel, clause.lb.idx))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß tryExpr.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß tryExpr.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß context != C.RETURN)
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )

                    ;; (try try-expr* catch-expr* finally-expr?)
                    ;; catch-expr: (catch class sym expr*)
                    ;; finally-expr: (finally expr*)

                    (let [#_"PersistentVector" body (ß PersistentVector.EMPTY)]
                        (let [#_"PersistentVector" catches (ß PersistentVector.EMPTY)]
                            (let [#_"Expr" bodyExpr nil]
                                (let [#_"Expr" finallyExpr nil]
                                    (let [#_"boolean" caught false]
                                        (let [#_"int" retLocal (ß getAndIncLocalNum())]
                                            (let [#_"int" finallyLocal (ß getAndIncLocalNum())]
                                                (loop-when-recur [(ß ISeq fs = form.next())] (ß fs != nil) [(ß fs = fs.next())]
                                                    (let [#_"Object" f (ß fs.first())]
                                                        (let [#_"Object" op (ß (f instanceof ISeq) ? ((ISeq) f).first() :or nil)]
                                                            (if (ß !Util.equals(op, CATCH) && !Util.equals(op, FINALLY))
                                                                (do
                                                                    (when caught
                                                                        (throw (ß Util.runtimeException("Only catch or finally clause can follow catch in try expression")))
                                                                    )
                                                                    (ß body = body.cons(f))
                                                                )
                                                                (do
                                                                    (when (ß bodyExpr == nil)
                                                                        (try
                                                                            (ß Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil)))
                                                                            (ß bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                                                                            (finally
                                                                                (ß Var.popThreadBindings())
                                                                            )
                                                                        )
                                                                    )

                                                                    (cond (ß Util.equals(op, CATCH))
                                                                        (do
                                                                            (let [#_"Class" c (ß HostExpr.maybeClass(RT.second(f), false))]
                                                                                (when (ß c == nil)
                                                                                    (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT.second(f))))
                                                                                )
                                                                                (when (ß !(RT.third(f) instanceof Symbol))
                                                                                    (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f))))
                                                                                )
                                                                                (let [#_"Symbol" sym (ß (Symbol) RT.third(f))]
                                                                                    (when (ß sym.getNamespace() != nil)
                                                                                        (throw (ß Util.runtimeException("Can't bind qualified name:" + sym)))
                                                                                    )

                                                                                    (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T))]
                                                                                        (try
                                                                                            (ß Var.pushThreadBindings(dynamicBindings))
                                                                                            (let [#_"LocalBinding" lb (ß registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or nil), nil, false))]
                                                                                                (let [#_"Expr" handler (ß (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f)))))]
                                                                                                    (ß catches = catches.cons(new CatchClause(c, lb, handler)))
                                                                                                )
                                                                                            )
                                                                                            (finally
                                                                                                (ß Var.popThreadBindings())
                                                                                            )
                                                                                        )
                                                                                        (ß caught = true)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        :else ;; finally
                                                                        (do
                                                                            (when (ß fs.next() != nil)
                                                                                (throw (ß Util.runtimeException("finally clause must be last in try expression")))
                                                                            )
                                                                            (try
                                                                                (ß Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T)))
                                                                                (ß finallyExpr = (new BodyExpr.Parser()).parse(C.STATEMENT, RT.next(f)))
                                                                                (finally
                                                                                    (ß Var.popThreadBindings())
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (when (ß bodyExpr == nil)
                                                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                                    ;; return a body expr directly
                                                    (try
                                                        (ß Var.pushThreadBindings(RT.map(NO_RECUR, true)))
                                                        (ß bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                                                        (finally
                                                            (ß Var.popThreadBindings())
                                                        )
                                                    )
                                                    (§ return bodyExpr)
                                                )

                                                (ß new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns ThrowExpr (§ extends UntypedExpr)
        (§ field #_"Expr" excExpr)

        (§ constructor #_"ThrowExpr" ThrowExpr [#_"Expr" excExpr]
            (ß this.excExpr = excExpr)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß Util.runtimeException("Can't eval throw")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß excExpr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(THROWABLE_TYPE))
            (ß gen.throwException())
            nil
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" form]
                (cond (ß context == C.EVAL)
                    (do
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )
                    (ß RT.count(form) == 1)
                    (do
                        (throw (ß Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance")))
                    )
                    (ß RT.count(form) > 2)
                    (do
                        (throw (ß Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance")))
                    )
                )
                (ß new ThrowExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (§ defn #_"boolean" subsumes [#_"Class[]" c1, #_"Class[]" c2]
        ;; presumes matching lengths
        (let [#_"Boolean" better false]
            (loop-when-recur [(ß int i = 0)] (ß i < c1.length) [(ß i++)]
                (when (ß c1[i] != c2[i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (ß !c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i]))
                        (do
                            (ß better = true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            better
        )
    )

    (§ defn #_"String" getTypeStringForArgs [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (let [#_"Expr" arg (ß (Expr) args.nth(i))]
                    (when (ß i > 0)
                        (ß sb.append(", "))
                    )
                    (ß sb.append((arg.hasJavaClass() && arg.getJavaClass() != nil) ? arg.getJavaClass().getName() :or "unknown"))
                )
            )
            (ß sb.toString())
        )
    )

    (§ defn #_"int" getMatchingParams [#_"String" methodName, #_"ArrayList<Class[]>" paramlists, #_"IPersistentVector" argexprs, #_"List<Class>" rets]
        ;; presumes matching lengths
        (let [#_"int" matchIdx -1]
            (let [#_"boolean" tied false]
                (let [#_"boolean" foundExact false]
                    (loop-when-recur [(ß int i = 0)] (ß i < paramlists.size()) [(ß i++)]
                        (let [#_"boolean" match true]
                            (let [#_"ISeq" aseq (ß argexprs.seq())]
                                (let [#_"int" exact 0]
                                    (loop-when-recur [(ß int p = 0)] (ß match && p < argexprs.count() && aseq != nil) [(ß ++p, aseq = aseq.next())]
                                        (let [#_"Expr" arg (ß (Expr) aseq.first())]
                                            (let [#_"Class" aclass (ß arg.hasJavaClass() ? arg.getJavaClass() :or Object.class)]
                                                (let [#_"Class" pclass (ß paramlists.get(i)[p])]
                                                    (if (ß arg.hasJavaClass() && aclass == pclass)
                                                        (do
                                                            (ß exact++)
                                                        )
                                                        (do
                                                            (ß match = Reflector.paramArgTypeMatch(pclass, aclass))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß exact == argexprs.count())
                                        (do
                                            (when (ß !foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                                                (ß matchIdx = i)
                                            )
                                            (ß tied = false)
                                            (ß foundExact = true)
                                        )
                                        (ß match && !foundExact)
                                        (do
                                            (if (ß matchIdx == -1)
                                                (do
                                                    (ß matchIdx = i)
                                                )
                                                (do
                                                    (cond (ß subsumes(paramlists.get(i), paramlists.get(matchIdx)))
                                                        (do
                                                            (ß matchIdx = i)
                                                            (ß tied = false)
                                                        )
                                                        (ß Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
                                                        (do
                                                            (when (ß rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                                                                (ß matchIdx = i)
                                                            )
                                                        )
                                                        (ß !(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
                                                        (do
                                                            (ß tied = true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when tied
                        (throw (ß new IllegalArgumentException("More than one matching method found: " + methodName)))
                    )

                    matchIdx
                )
            )
        )
    )

    (class-ns NewExpr (§ implements Expr)
        (§ field #_"IPersistentVector" args)
        (§ field #_"Constructor" ctor)
        (§ field #_"Class" c)

        (§ def #_"Method" invokeConstructorMethod (ß Method.getMethod("Object invokeConstructor(Class,Object[])")))
        (§ def #_"Method" forNameMethod (ß Method.getMethod("Class classForName(String)")))

        (§ constructor #_"NewExpr" NewExpr [#_"Class" c, #_"IPersistentVector" args, #_"int" line, #_"int" column]
            (ß this.args = args)
            (ß this.c = c)
            (let [#_"Constructor[]" allctors (ß c.getConstructors())]
                (let [#_"ArrayList" ctors (ß new ArrayList())]
                    (let [#_"ArrayList<Class[]>" params (ß new ArrayList())]
                        (let [#_"ArrayList<Class>" rets (ß new ArrayList())]
                            (loop-when-recur [(ß int i = 0)] (ß i < allctors.length) [(ß i++)]
                                (let [#_"Constructor" ctor (ß allctors[i])]
                                    (when (ß ctor.getParameterTypes().length == args.count())
                                        (ß ctors.add(ctor))
                                        (ß params.add(ctor.getParameterTypes()))
                                        (ß rets.add(c))
                                    )
                                )
                            )
                            (when (ß ctors.isEmpty())
                                (throw (ß new IllegalArgumentException("No matching ctor found for " + c)))
                            )

                            (let [#_"int" ctoridx 0]
                                (when (ß ctors.size() > 1)
                                    (ß ctoridx = getMatchingParams(c.getName(), params, args, rets))
                                )

                                (ß this.ctor = (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or nil)
                                (when (ß ctor == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), line, column, c.getName()))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"Object[]" argvals (ß new Object[args.count()])]
                (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß argvals[i] = ((Expr) args.nth(i)).eval())
                )
                (when (ß this.ctor != nil)
                    (try
                        (§ return (ß ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))))
                        (catch Exception e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (ß Reflector.invokeConstructor(c, argvals))
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß this.ctor != nil)
                (do
                    (let [#_"Type" type (ß getType(c))]
                        (ß gen.newInstance(type))
                        (ß gen.dup())
                        (ß MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args))
                        (ß gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor))))
                    )
                )
                (do
                    (ß gen.push(destubClassName(c.getName())))
                    (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                    (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            c
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"int" line (ß lineDeref())]
                    (let [#_"int" column (ß columnDeref())]
                        (let [#_"ISeq" form (ß (ISeq) frm)]
                            ;; (new Classname args...)
                            (when (ß form.count() < 2)
                                (throw (ß Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)")))
                            )
                            (let [#_"Class" c (ß HostExpr.maybeClass(RT.second(form), false))]
                                (when (ß c == nil)
                                    (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT.second(form))))
                                )
                                (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                    (loop-when-recur [(ß ISeq s = RT.next(RT.next(form)))] (ß s != nil) [(ß s = s.next())]
                                        (ß args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                                    )
                                    (ß new NewExpr(c, args, line, column))
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns MetaExpr (§ implements Expr)
        (§ field #_"Expr" expr)
        (§ field #_"Expr" meta)

        (§ def #_"Type" IOBJ_TYPE (ß Type.getType(IObj.class)))
        (§ def #_"Method" withMetaMethod (ß Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))

        (§ constructor #_"MetaExpr" MetaExpr [#_"Expr" expr, #_"Expr" meta]
            (ß this.expr = expr)
            (ß this.meta = meta)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (ß ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval()))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IOBJ_TYPE))
            (ß meta.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
            (ß gen.invokeInterface(IOBJ_TYPE, withMetaMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß expr.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß expr.getJavaClass())
        )
    )

    (class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"Expr" testExpr)
        (§ field #_"Expr" thenExpr)
        (§ field #_"Expr" elseExpr)
        (§ field #_"int" line)
        (§ field #_"int" column)

        (§ constructor #_"IfExpr" IfExpr [#_"int" line, #_"int" column, #_"Expr" testExpr, #_"Expr" thenExpr, #_"Expr" elseExpr]
            (ß this.testExpr = testExpr)
            (ß this.thenExpr = thenExpr)
            (ß this.elseExpr = elseExpr)
            (ß this.line = line)
            (ß this.column = column)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"Object" t (ß testExpr.eval())]
                (when (ß t != nil && t != Boolean.FALSE)
                    (§ return (ß thenExpr.eval()))
                )
                (ß elseExpr.eval())
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, false))
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, true))
            nil
        )

        #_method
        (§ defn #_"void" doEmit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
            (let [#_"Label" nullLabel (ß gen.newLabel())]
                (let [#_"Label" falseLabel (ß gen.newLabel())]
                    (let [#_"Label" endLabel (ß gen.newLabel())]
                        (ß gen.visitLineNumber(line, gen.mark()))

                        (cond (ß testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
                            (do
                                (ß ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel))
                            )
                            (ß maybePrimitiveType(testExpr) == boolean.class)
                            (do
                                (ß ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen))
                                (ß gen.ifZCmp(gen.EQ, falseLabel))
                            )
                            :else
                            (do
                                (ß testExpr.emit(C.EXPRESSION, objx, gen))
                                (ß gen.dup())
                                (ß gen.ifNull(nullLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.visitJumpInsn(IF_ACMPEQ, falseLabel))
                            )
                        )
                        (if emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen))
                            )
                            (do
                                (ß thenExpr.emit(context, objx, gen))
                            )
                        )
                        (ß gen.goTo(endLabel))
                        (ß gen.mark(nullLabel))
                        (ß gen.pop())
                        (ß gen.mark(falseLabel))
                        (if emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen))
                            )
                            (do
                                (ß elseExpr.emit(context, objx, gen))
                            )
                        )
                        (ß gen.mark(endLabel))
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß thenExpr.hasJavaClass()
                && elseExpr.hasJavaClass()
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                    || thenExpr.getJavaClass() == RECUR_CLASS
                    || elseExpr.getJavaClass() == RECUR_CLASS
                    || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
                    || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive())))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (try
                (ß thenExpr instanceof MaybePrimitiveExpr
                    && elseExpr instanceof MaybePrimitiveExpr
                    && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                            || thenExpr.getJavaClass() == RECUR_CLASS
                            || elseExpr.getJavaClass() == RECUR_CLASS)
                    && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                    && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive())
                (catch Exception e
                    false
                )
            )
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (let [#_"Class" thenClass (ß thenExpr.getJavaClass())]
                (when (ß thenClass != nil && thenClass != RECUR_CLASS)
                    (§ return thenClass)
                )
                (ß elseExpr.getJavaClass())
            )
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (if test then) or (if test then else)
                    (cond (ß form.count() > 4)
                        (do
                            (throw (ß Util.runtimeException("Too many arguments to if")))
                        )
                        (ß form.count() < 3)
                        (do
                            (throw (ß Util.runtimeException("Too few arguments to if")))
                        )
                    )
                    (let [#_"PathNode" branch (ß new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))]
                        (let [#_"Expr" testexpr (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))]
                            (let [(ß Expr thenexpr, elseexpr)]
                                (try
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                    (ß thenexpr = analyze(context, RT.third(form)))
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                                (try
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                    (ß elseexpr = analyze(context, RT.fourth(form)))
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                                (ß new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ def #_"IPersistentMap" CHAR_MAP (ß PersistentHashMap.create(
      #_map \-, "_",
      #_map \:, "_COLON_",
      #_map \+, "_PLUS_",
      #_map \>, "_GT_",
      #_map \<, "_LT_",
      #_map \=, "_EQ_",
      #_map \~, "_TILDE_",
      #_map \!, "_BANG_",
      #_map \@, "_CIRCA_",
      #_map \#, "_SHARP_",
      #_map \', "_SINGLEQUOTE_",
      #_map \", "_DOUBLEQUOTE_", ;; oops! "
      #_map \%, "_PERCENT_",
      #_map \^, "_CARET_",
      #_map \&, "_AMPERSAND_",
      #_map \*, "_STAR_",
      #_map \|, "_BAR_",
      #_map \{, "_LBRACE_",
      #_map \}, "_RBRACE_",
      #_map \[, "_LBRACK_",
      #_map \], "_RBRACK_",
      #_map \/, "_SLASH_",
      #_map \\, "_BSLASH_",
      #_map \?, "_QMARK_"
    )))

    (§ def #_"IPersistentMap" DEMUNGE_MAP)
    (§ def #_"Pattern" DEMUNGE_PATTERN)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" m (ß RT.map("$", \/))]
            (loop-when-recur [(ß ISeq s = RT.seq(CHAR_MAP))] (ß s != nil) [(ß s = s.next())]
                (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                    (let [#_"Character" origCh (ß (Character) e.key())]
                        (let [#_"String" escapeStr (ß (String) e.val())]
                            (ß m = m.assoc(escapeStr, origCh))
                        )
                    )
                )
            )
            (ß DEMUNGE_MAP = m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired.  Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" mungeStrs (ß RT.toArray(RT.keys(m)))]
                (ß Arrays.sort(mungeStrs, new Comparator()
                    (§ reify
                        #_method
                        (§ defn #_"int" compare [this, #_"Object" s1, #_"Object" s2]
                            (ß ((String) s2).length() - ((String) s1).length())
                        )
                    ))
                )
                (let [#_"StringBuilder" sb (ß new StringBuilder())]
                    (let [#_"boolean" first true]
                        (doseq [#_"Object" s mungeStrs]
                            (let [#_"String" escapeStr (ß (String) s)]
                                (when (ß !first)
                                    (ß sb.append("|"))
                                )
                                (ß first = false)
                                (ß sb.append("\\Q"))
                                (ß sb.append(escapeStr))
                                (ß sb.append("\\E"))
                            )
                        )
                        (ß DEMUNGE_PATTERN = Pattern.compile(sb.toString()))
                    )
                )
            )
        )
    )

    (§ defn #_"String" munge [#_"String" name]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (doseq [#_"char" c (ß name.toCharArray())]
                (let [#_"String" sub (ß (String) CHAR_MAP.valAt(c))]
                    (if (ß sub != nil)
                        (do
                            (ß sb.append(sub))
                        )
                        (do
                            (ß sb.append(c))
                        )
                    )
                )
            )
            (ß sb.toString())
        )
    )

    (§ defn #_"String" demunge [#_"String" mungedName]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (let [#_"Matcher" m (ß DEMUNGE_PATTERN.matcher(mungedName))]
                (let [#_"int" lastMatchEnd 0]
                    (while (ß m.find())
                        (let [#_"int" start (ß m.start())]
                            (let [#_"int" end (ß m.end())]
                                ;; Keep everything before the match
                                (ß sb.append(mungedName.substring(lastMatchEnd, start)))
                                (ß lastMatchEnd = end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" origCh (ß (Character) DEMUNGE_MAP.valAt(m.group()))]
                                    (ß sb.append(origCh))
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß sb.append(mungedName.substring(lastMatchEnd)))
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns EmptyExpr (§ implements Expr)
        (§ field #_"Object" coll)

        (§ def #_"Type" HASHMAP_TYPE (ß Type.getType(PersistentArrayMap.class)))
        (§ def #_"Type" HASHSET_TYPE (ß Type.getType(PersistentHashSet.class)))
        (§ def #_"Type" VECTOR_TYPE (ß Type.getType(PersistentVector.class)))
        (§ def #_"Type" IVECTOR_TYPE (ß Type.getType(IPersistentVector.class)))
        (§ def #_"Type" TUPLE_TYPE (ß Type.getType(Tuple.class)))
        (§ def #_"Type" LIST_TYPE (ß Type.getType(PersistentList.class)))
        (§ def #_"Type" EMPTY_LIST_TYPE (ß Type.getType(PersistentList.EmptyList.class)))

        (§ constructor #_"EmptyExpr" EmptyExpr [#_"Object" coll]
            (ß this.coll = coll)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            coll
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (cond (ß coll instanceof IPersistentList)
                (do
                    (ß gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE))
                )
                (ß coll instanceof IPersistentVector)
                (do
                    (ß gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE))
                )
                (ß coll instanceof IPersistentMap)
                (do
                    (ß gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE))
                )
                (ß coll instanceof IPersistentSet)
                (do
                    (ß gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE))
                )
                :else
                (do
                    (throw (ß new UnsupportedOperationException("Unknown Collection type")))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (cond (ß coll instanceof IPersistentList)
                (do
                    (ß IPersistentList.class)
                )
                (ß coll instanceof IPersistentVector)
                (do
                    (ß IPersistentVector.class)
                )
                (ß coll instanceof IPersistentMap)
                (do
                    (ß IPersistentMap.class)
                )
                (ß coll instanceof IPersistentSet)
                (do
                    (ß IPersistentSet.class)
                )
                :else
                (do
                    (throw (ß new UnsupportedOperationException("Unknown Collection type")))
                )
            )
        )
    )

    (class-ns ListExpr (§ implements Expr)
        (§ field #_"IPersistentVector" args)

        (§ def #_"Method" arrayToListMethod (ß Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])")))

        (§ constructor #_"ListExpr" ListExpr [#_"IPersistentVector" args]
            (ß this.args = args)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"IPersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
                )
                (ß ret.seq())
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß MethodExpr.emitArgsAsArray(args, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, arrayToListMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß IPersistentList.class)
        )
    )

    (class-ns MapExpr (§ implements Expr)
        (§ field #_"IPersistentVector" keyvals)

        (§ def #_"Method" mapMethod (ß Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
        (§ def #_"Method" mapUniqueKeysMethod (ß Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])")))

        (§ constructor #_"MapExpr" MapExpr [#_"IPersistentVector" keyvals]
            (ß this.keyvals = keyvals)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"Object[]" ret (ß new Object[keyvals.count()])]
                (loop-when-recur [(ß int i = 0)] (ß i < keyvals.count()) [(ß i++)]
                    (ß ret[i] = ((Expr) keyvals.nth(i)).eval())
                )
                (ß RT.map(ret))
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"boolean" allKeysConstant true]
                (let [#_"boolean" allConstantKeysUnique true]
                    (let [#_"IPersistentSet" constantKeys (ß PersistentHashSet.EMPTY)]
                        (loop-when-recur [(ß int i = 0)] (ß i < keyvals.count()) [(ß i+=2)]
                            (let [#_"Expr" k (ß (Expr) keyvals.nth(i))]
                                (if (ß k instanceof LiteralExpr)
                                    (do
                                        (let [#_"Object" kval (ß k.eval())]
                                            (if (ß constantKeys.contains(kval))
                                                (do
                                                    (ß allConstantKeysUnique = false)
                                                )
                                                (do
                                                    (ß constantKeys = (IPersistentSet)constantKeys.cons(kval))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (ß allKeysConstant = false)
                                    )
                                )
                            )
                        )
                        (ß MethodExpr.emitArgsAsArray(keyvals, objx, gen))
                        (if (ß (allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2))
                            (do
                                (ß gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod))
                            )
                            (do
                                (ß gen.invokeStatic(RT_TYPE, mapMethod))
                            )
                        )
                        (when (ß context == C.STATEMENT)
                            (ß gen.pop())
                        )
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß IPersistentMap.class)
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"IPersistentMap" form]
            (let [#_"IPersistentVector" keyvals (ß PersistentVector.EMPTY)]
                (let [#_"boolean" keysConstant true]
                    (let [#_"boolean" valsConstant true]
                        (let [#_"boolean" allConstantKeysUnique true]
                            (let [#_"IPersistentSet" constantKeys (ß PersistentHashSet.EMPTY)]
                                (loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                                    (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                                        (let [#_"Expr" k (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key()))]
                                            (let [#_"Expr" v (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val()))]
                                                (ß keyvals = (IPersistentVector) keyvals.cons(k))
                                                (ß keyvals = (IPersistentVector) keyvals.cons(v))
                                                (if (ß k instanceof LiteralExpr)
                                                    (do
                                                        (let [#_"Object" kval (ß k.eval())]
                                                            (if (ß constantKeys.contains(kval))
                                                                (do
                                                                    (ß allConstantKeysUnique = false)
                                                                )
                                                                (do
                                                                    (ß constantKeys = (IPersistentSet)constantKeys.cons(kval))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (do
                                                        (ß keysConstant = false)
                                                    )
                                                )
                                                (when (ß !(v instanceof LiteralExpr))
                                                    (ß valsConstant = false)
                                                )
                                            )
                                        )
                                    )
                                )

                                (let [#_"Expr" ret (ß new MapExpr(keyvals))]
                                    (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                                        (do
                                            (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                                        )
                                        keysConstant
                                        (do
                                            ;; TBD: Add more detail to exception thrown below.
                                            (when (ß !allConstantKeysUnique)
                                                (throw (ß new IllegalArgumentException("Duplicate constant keys in map")))
                                            )
                                            (if valsConstant
                                                (do
                                                    (let [#_"IPersistentMap" m (ß PersistentArrayMap.EMPTY)]
                                                        (loop-when-recur [(ß int i = 0)] (ß i < keyvals.length()) [(ß i += 2)]
                                                            (ß m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val()))
                                                        )
                                                        (ß new ConstantExpr(m))
                                                    )
                                                )
                                                (do
                                                    ret
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SetExpr (§ implements Expr)
        (§ field #_"IPersistentVector" keys)

        (§ def #_"Method" setMethod (ß Method.getMethod("cloiure.lang.IPersistentSet set(Object[])")))

        (§ constructor #_"SetExpr" SetExpr [#_"IPersistentVector" keys]
            (ß this.keys = keys)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"Object[]" ret (ß new Object[keys.count()])]
                (loop-when-recur [(ß int i = 0)] (ß i < keys.count()) [(ß i++)]
                    (ß ret[i] = ((Expr) keys.nth(i)).eval())
                )
                (ß RT.set(ret))
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß MethodExpr.emitArgsAsArray(keys, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, setMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß IPersistentSet.class)
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"IPersistentSet" form]
            (let [#_"IPersistentVector" keys (ß PersistentVector.EMPTY)]
                (let [#_"boolean" constant true]
                    (loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"Object" e (ß s.first())]
                            (let [#_"Expr" expr (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e))]
                                (ß keys = (IPersistentVector) keys.cons(expr))
                                (when (ß !(expr instanceof LiteralExpr))
                                    (ß constant = false)
                                )
                            )
                        )
                    )
                    (let [#_"Expr" ret (ß new SetExpr(keys))]
                        (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                            (do
                                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            constant
                            (do
                                (let [#_"IPersistentSet" set (ß PersistentHashSet.EMPTY)]
                                    (loop-when-recur [(ß int i = 0)] (ß i < keys.count()) [(ß i++)]
                                        (let [#_"LiteralExpr" ve (ß (LiteralExpr)keys.nth(i))]
                                            (ß set = (IPersistentSet)set.cons(ve.val()))
                                        )
                                    )
                                    (ß new ConstantExpr(set))
                                )
                            )
                            :else
                            (do
                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorExpr (§ implements Expr)
        (§ field #_"IPersistentVector" args)

        (§ def #_"Method" vectorMethod (ß Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))

        (§ constructor #_"VectorExpr" VectorExpr [#_"IPersistentVector" args]
            (ß this.args = args)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"IPersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
                )
                ret
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if (ß args.count() <= Tuple.MAX_SIZE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                        (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                    )
                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                )
                (do
                    (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                    (ß gen.invokeStatic(RT_TYPE, vectorMethod))
                )
            )

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß IPersistentVector.class)
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"IPersistentVector" form]
            (let [#_"boolean" constant true]
                (let [#_"IPersistentVector" args (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(ß int i = 0)] (ß i < form.count()) [(ß i++)]
                        (let [#_"Expr" v (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i)))]
                            (ß args = (IPersistentVector) args.cons(v))
                            (when (ß !(v instanceof LiteralExpr))
                                (ß constant = false)
                            )
                        )
                    )
                    (let [#_"Expr" ret (ß new VectorExpr(args))]
                        (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                            (do
                                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            constant
                            (do
                                (let [#_"IPersistentVector" rv (ß PersistentVector.EMPTY)]
                                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                                        (let [#_"LiteralExpr" ve (ß (LiteralExpr)args.nth(i))]
                                            (ß rv = rv.cons(ve.val()))
                                        )
                                    )
                                    (ß new ConstantExpr(rv))
                                )
                            )
                            :else
                            (do
                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns KeywordInvokeExpr (§ implements Expr)
        (§ field #_"KeywordExpr" kw)
        (§ field #_"Object" tag)
        (§ field #_"Expr" target)
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"int" siteIndex)
        (§ field #_"String" source)

        (§ def #_"Type" ILOOKUP_TYPE (ß Type.getType(ILookup.class)))

        (§ field #_"Class" jc)

        (§ constructor #_"KeywordInvokeExpr" KeywordInvokeExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"KeywordExpr" kw, #_"Expr" target]
            (ß this.source = source)
            (ß this.kw = kw)
            (ß this.target = target)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.siteIndex = registerKeywordCallsite(kw.k))
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (try
                (ß kw.k.invoke(target.eval()))
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" endLabel (ß gen.newLabel())]
                (let [#_"Label" faultLabel (ß gen.newLabel())]
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE))
                    (ß gen.dup()) ;; thunk, thunk
                    (ß target.emit(C.EXPRESSION, objx, gen)) ;; thunk, thunk, target
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.dupX2()) ;; target, thunk, thunk, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; target, thunk, result
                    (ß gen.dupX2()) ;; result, target, thunk, result
                    (ß gen.visitJumpInsn(IF_ACMPEQ, faultLabel)) ;; result, target
                    (ß gen.pop()) ;; result
                    (ß gen.goTo(endLabel))

                    (ß gen.mark(faultLabel)) ;; result, target
                    (ß gen.swap()) ;; target, result
                    (ß gen.pop()) ;; target
                    (ß gen.dup()) ;; target, target
                    (ß gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                    (ß gen.swap()) ;; target, site, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                    (ß gen.dup()) ;; target, new-thunk, new-thunk
                    (ß gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                    (ß gen.swap()) ;; new-thunk, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; result

                    (ß gen.mark(endLabel))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                    nil
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )
    )

    (class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"Expr" expr)
        (§ field #_"Class" c)

        (§ constructor #_"InstanceOfExpr" InstanceOfExpr [#_"Class" c, #_"Expr" expr]
            (ß this.expr = expr)
            (ß this.c = c)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (when (ß c.isInstance(expr.eval()))
                (§ return (ß RT.T))
            )
            (ß RT.F)
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            true
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.instanceOf(getType(c)))
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emitUnboxed(context, objx, gen))
            (ß HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß Boolean.TYPE)
        )
    )

    (class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"Type" target)
        (§ field #_"Class" retClass)
        (§ field #_"Class[]" paramclasses)
        (§ field #_"Type[]" paramtypes)
        (§ field #_"IPersistentVector" args)
        (§ field #_"boolean" variadic)
        (§ field #_"boolean" tailPosition)
        (§ field #_"Object" tag)

        (§ field #_"Class" jc)

        (§ constructor #_"StaticInvokeExpr" StaticInvokeExpr [#_"Type" target, #_"Class" retClass, #_"Class[]" paramclasses, #_"Type[]" paramtypes, #_"boolean" variadic, #_"IPersistentVector" args, #_"Object" tag, #_"boolean" tailPosition]
            (ß this.target = target)
            (ß this.retClass = retClass)
            (ß this.paramclasses = paramclasses)
            (ß this.paramtypes = paramtypes)
            (ß this.args = args)
            (ß this.variadic = variadic)
            (ß this.tailPosition = tailPosition)
            (ß this.tag = tag)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval StaticInvokeExpr")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emitUnboxed(context, objx, gen))
            (when (ß context != C.STATEMENT)
                (ß HostExpr.emitBoxReturn(objx, gen, retClass))
            )
            (when (ß context == C.STATEMENT)
                (if (ß retClass == long.class || retClass == double.class)
                    (do
                        (ß gen.pop2())
                    )
                    (do
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, retClass))
            )
            jc
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß retClass.isPrimitive())
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Method" ms (ß new Method("invokeStatic", getReturnType(), paramtypes))]
                (if variadic
                    (do
                        (loop-when-recur [(ß int i = 0)] (ß i < paramclasses.length - 1) [(ß i++)]
                            (let [#_"Expr" e (ß (Expr) args.nth(i))]
                                (if (ß maybePrimitiveType(e) == paramclasses[i])
                                    (do
                                        (ß ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen))
                                    )
                                    (do
                                        (ß e.emit(C.EXPRESSION, objx, gen))
                                        (ß HostExpr.emitUnboxArg(objx, gen, paramclasses[i]))
                                    )
                                )
                            )
                        )
                        (let [#_"IPersistentVector" restArgs (ß RT.subvec(args, paramclasses.length - 1, args.count()))]
                            (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                            (ß gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])")))
                        )
                    )
                    (do
                        (ß MethodExpr.emitTypedArgs(objx, gen, paramclasses, args))
                    )
                )

                (when (ß tailPosition && !objx.canBeDirect)
                    (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                        (ß method.emitClearThis(gen))
                    )
                )

                (ß gen.invokeStatic(target, ms))
                nil
            )
        )

        #_method
        (§ defn- #_"Type" getReturnType [this]
            (ß Type.getType(retClass))
        )

        (§ defn #_"Expr" parse [#_"Var" v, #_"ISeq" args, #_"Object" tag, #_"boolean" tailPosition]
            (when (ß !v.isBound() || v.get() == nil)
                (§ return nil)
            )
            (let [#_"Class" c (ß v.get().getClass())]
                (let [#_"String" cname (ß c.getName())]
                    (let [(ß java.lang.reflect.Method[] allmethods = c.getMethods())]
                        (let [#_"boolean" variadic false]
                            (let [#_"int" argcount (ß RT.count(args))]
                                (let [(ß java.lang.reflect.Method method = nil)]
                                    (doseq [#_"java.lang.reflect.Method" m allmethods]
                                        (when (ß Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic"))
                                            (let [#_"Class[]" params (ß m.getParameterTypes())]
                                                (cond (ß argcount == params.length)
                                                    (do
                                                        (ß method = m)
                                                        (ß variadic = (argcount > 0 && params[params.length - 1] == ISeq.class))
                                                        (§ break )
                                                    )
                                                    (ß argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class)
                                                    (do
                                                        (ß method = m)
                                                        (ß variadic = true)
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (when (ß method == nil)
                                        (§ return nil)
                                    )

                                    (let [#_"Class" retClass (ß method.getReturnType())]
                                        (let [#_"Class[]" paramClasses (ß method.getParameterTypes())]
                                            (let [#_"Type[]" paramTypes (ß new Type[paramClasses.length])]
                                                (loop-when-recur [(ß int i = 0)] (ß i < paramClasses.length) [(ß i++)]
                                                    (ß paramTypes[i] = Type.getType(paramClasses[i]))
                                                )

                                                (let [#_"Type" target (ß Type.getType(c))]
                                                    (let [#_"PersistentVector" argv (ß PersistentVector.EMPTY)]
                                                        (loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                                                            (ß argv = argv.cons(analyze(C.EXPRESSION, s.first())))
                                                        )

                                                        (ß new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns InvokeExpr (§ implements Expr)
        (§ field #_"Expr" fexpr)
        (§ field #_"Object" tag)
        (§ field #_"IPersistentVector" args)
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"boolean" tailPosition)
        (§ field #_"String" source)

        (§ field #_"boolean" isProtocol (ß false))
        (§ field #_"boolean" isDirect (ß false))
        (§ field #_"int" siteIndex (ß -1))
        (§ field #_"Class" protocolOn)
        (§ field #_"java.lang.reflect.Method" onMethod)

        (§ def #_"Keyword" onKey (ß Keyword.intern("on")))
        (§ def #_"Keyword" methodMapKey (ß Keyword.intern("method-map")))

        (§ field #_"Class" jc)

        (§ defn #_"Object" sigTag [#_"int" argcount, #_"Var" v]
            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                (let [#_"Object" sigTag nil]
                    (loop-when-recur [(ß ISeq s = RT.seq(arglists))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"APersistentVector" sig (ß (APersistentVector) s.first())]
                            (let [#_"int" restOffset (ß sig.indexOf(_AMP_))]
                                (when (ß argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))
                                    (§ return (ß tagOf(sig)))
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )

        (§ constructor #_"InvokeExpr" InvokeExpr [#_"String" source, #_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" fexpr, #_"IPersistentVector" args, #_"boolean" tailPosition]
            (ß this.source = source)
            (ß this.fexpr = fexpr)
            (ß this.args = args)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tailPosition = tailPosition)

            (when (ß fexpr instanceof VarExpr)
                (let [#_"Var" fvar (ß ((VarExpr)fexpr).var)]
                    (let [#_"Var" pvar (ß  (Var)RT.get(fvar.meta(), protocolKey))]
                        (when (ß pvar != nil && PROTOCOL_CALLSITES.isBound())
                            (ß this.isProtocol = true)
                            (ß this.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var))
                            (let [#_"Object" pon (ß RT.get(pvar.get(), onKey))]
                                (ß this.protocolOn = HostExpr.maybeClass(pon, false))
                                (when (ß this.protocolOn != nil)
                                    (let [#_"IPersistentMap" mmap (ß (IPersistentMap) RT.get(pvar.get(), methodMapKey))]
                                        (let [#_"Keyword" mmapVal (ß (Keyword) mmap.valAt(Keyword.intern(fvar.sym)))]
                                            (when (ß mmapVal == nil)
                                                (throw (ß new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" mname (ß munge(mmapVal.sym.toString()))]
                                                (let [#_"List" methods (ß Reflector.getMethods(protocolOn, args.count() - 1, mname, false))]
                                                    (when (ß methods.size() != 1)
                                                        (throw (ß new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym)))
                                                    )
                                                    (ß this.onMethod = (java.lang.reflect.Method) methods.get(0))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (ß tag != nil)
                (do
                    (ß this.tag = tag)
                )
                (ß fexpr instanceof VarExpr)
                (do
                    (let [#_"Var" v (ß ((VarExpr) fexpr).var)]
                        (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                            (let [#_"Object" sigTag (ß sigTag(args.count(), v))]
                                (ß this.tag = (sigTag == nil) ? ((VarExpr) fexpr).tag :or sigTag)
                            )
                        )
                    )
                )
                :else
                (do
                    (ß this.tag = nil)
                )
            )
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (try
                (let [#_"IFn" fn (ß (IFn) fexpr.eval())]
                    (let [#_"PersistentVector" argvs (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                            (ß argvs = argvs.cons(((Expr) args.nth(i)).eval()))
                        )
                        (ß fn.applyTo(RT.seq(Util.ret1(argvs, argvs = nil))))
                    )
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (if isProtocol
                (do
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß emitProto(context, objx, gen))
                )
                (do
                    (ß fexpr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(IFN_TYPE))
                    (ß emitArgsAndCall(0, context, objx, gen))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"void" emitProto [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" onLabel (ß gen.newLabel())]
                (let [#_"Label" callLabel (ß gen.newLabel())]
                    (let [#_"Label" endLabel (ß gen.newLabel())]
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (let [#_"Expr" e (ß (Expr) args.nth(0))]
                                (ß e.emit(C.EXPRESSION, objx, gen))
                                (ß gen.dup()) ;; target, target
                                (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
                                (ß gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target, class, cached-class
                                (ß gen.visitJumpInsn(IF_ACMPEQ, callLabel)) ;; target
                                (when (ß protocolOn != nil)
                                    (ß gen.dup()) ;; target, target
                                    (ß gen.instanceOf(Type.getType(protocolOn)))
                                    (ß gen.ifZCmp(GeneratorAdapter.NE, onLabel))
                                )

                                (ß gen.dup()) ;; target, target
                                (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
                                (ß gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target

                                (ß gen.mark(callLabel)) ;; target
                                (ß objx.emitVar(gen, v))
                                (ß gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))) ;; target, proto-fn
                                (ß gen.swap())
                                (ß emitArgsAndCall(1, context, objx, gen))
                                (ß gen.goTo(endLabel))

                                (ß gen.mark(onLabel)) ;; target
                                (when (ß protocolOn != nil)
                                    (ß gen.checkCast(Type.getType(protocolOn)))
                                    (ß MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count())))
                                    (when (ß context == C.RETURN)
                                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                            (ß method.emitClearLocals(gen))
                                        )
                                    )
                                    (let [#_"Method" m (ß new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod)))]
                                        (ß gen.invokeInterface(Type.getType(protocolOn), m))
                                        (ß HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType()))
                                    )
                                )
                                (ß gen.mark(endLabel))
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emitArgsAndCall [this, #_"int" firstArgToEmit, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(ß int i = firstArgToEmit)] (ß i < Math.min(MAX_POSITIONAL_ARITY, args.count())) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) args.nth(i))]
                    (ß e.emit(C.EXPRESSION, objx, gen))
                )
            )
            (when (ß args.count() > MAX_POSITIONAL_ARITY)
                (let [#_"PersistentVector" restArgs (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(ß int i = MAX_POSITIONAL_ARITY)] (ß i < args.count()) [(ß i++)]
                        (ß restArgs = restArgs.cons(args.nth(i)))
                    )
                    (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                )
            )
            (ß gen.visitLineNumber(line, gen.mark()))

            (when (ß tailPosition && !objx.canBeDirect)
                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                    (ß method.emitClearThis(gen))
                )
            )

            (ß gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())])))
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (tag != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"ISeq" form]
            (let [#_"boolean" tailPosition (ß inTailCall(context))]
                (when (ß context != C.EVAL)
                    (ß context = C.EXPRESSION)
                )
                (let [#_"Expr" fexpr (ß analyze(context, form.first()))]
                    (when (ß fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3)
                        (let [#_"Expr" sexpr (ß analyze(C.EXPRESSION, RT.second(form)))]
                            (when (ß sexpr instanceof ConstantExpr)
                                (let [#_"Object" val (ß ((ConstantExpr) sexpr).val())]
                                    (when (ß val instanceof Class)
                                        (§ return (ß new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))))
                                    )
                                )
                            )
                        )
                    )

                    (when (ß RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL)
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (when (ß !v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false)))
                                (let [#_"Symbol" formtag (ß tagOf(form))]
                                    (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                        (let [#_"int" arity (ß RT.count(form.next()))]
                                            (let [#_"Object" sigtag (ß sigTag(arity, v))]
                                                (let [#_"Object" vtag (ß RT.get(RT.meta(v), RT.TAG_KEY))]
                                                    (let [#_"Expr" ret (ß StaticInvokeExpr.parse(v, RT.next(form), (formtag != nil) ? formtag :or (sigtag != nil) ? sigtag :or vtag, tailPosition))]
                                                        (when (ß ret != nil)
                                                            (§ return ret)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (ß fexpr instanceof VarExpr && context != C.EVAL)
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                (let [#_"int" arity (ß RT.count(form.next()))]
                                    (loop-when-recur [(ß ISeq s = RT.seq(arglists))] (ß s != nil) [(ß s = s.next())]
                                        (let [#_"IPersistentVector" args (ß (IPersistentVector) s.first())]
                                            (when (ß args.count() == arity)
                                                (let [#_"String" primc (ß FnMethod.primInterface(args))]
                                                    (when (ß primc != nil)
                                                        (§ return (ß analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"), ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))), form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))))
                                                    )
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (ß fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound())
                        (let [#_"Expr" target (ß analyze(context, RT.second(form)))]
                            (§ return (ß new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)))
                        )
                    )
                    (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß ISeq s = RT.seq(form.next()))] (ß s != nil) [(ß s = s.next())]
                            (ß args = args.cons(analyze(context, s.first())))
                        )

                        (ß new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition))
                    )
                )
            )
        )
    )

    (class-ns SourceDebugExtensionAttribute (§ extends Attribute)
        (§ constructor #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute []
            (§ super("SourceDebugExtension"))
            this
        )

        #_method
        (§ defn #_"void" writeSMAP [this, #_"ClassWriter" cw, #_"String" smap]
            (let [#_"ByteVector" bv (ß write(cw, nil, -1, -1, -1))]
                (ß bv.putUTF8(smap))
                nil
            )
        )
    )

    (class-ns FnExpr (§ extends ObjExpr)
        (§ def #_"Type" aFnType (ß Type.getType(AFunction.class)))
        (§ def #_"Type" restFnType (ß Type.getType(RestFn.class)))

        ;; if there is a variadic overload (there can only be one) it is stored here
        (§ field #_"FnMethod" variadicMethod (ß nil))
        (§ field #_"IPersistentCollection" methods)
        (§ field- #_"boolean" hasPrimSigs)
        (§ field- #_"boolean" hasMeta)
        (§ field- #_"boolean" hasEnclosingMethod)

        (§ field #_"Class" jc)

        (§ constructor #_"FnExpr" FnExpr [#_"Object" tag]
            (§ super(tag))
            this
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"boolean" supportsMeta [this]
            hasMeta
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or AFunction.class)
            )
            jc
        )

        #_protected
        #_method
        (§ defn #_"void" emitMethods [this, #_"ClassVisitor" cv]
            ;; override of invoke/doInvoke for each method
            (loop-when-recur [(ß ISeq s = RT.seq(methods))] (ß s != nil) [(ß s = s.next())]
                (let [#_"ObjMethod" method (ß (ObjMethod) s.first())]
                    (ß method.emit(this, cv))
                )
            )

            (when (ß isVariadic())
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), nil, nil, cv))]
                    (ß gen.visitCode())
                    (ß gen.push(variadicMethod.reqParms.count()))
                    (ß gen.returnValue())
                    (ß gen.endMethod())
                )
            )
            nil
        )

        (§ defn #_"Expr" parse [#_"C" context, #_"ISeq" form, #_"String" name]
            (let [#_"ISeq" origForm form]
                (let [#_"FnExpr" fn (ß new FnExpr(tagOf(form)))]
                    (let [#_"Keyword" retkey (ß Keyword.intern(nil, "rettag"))]
                        (let [#_"Object" rettag (ß RT.get(RT.meta(form), retkey))]
                            (ß fn.src = form)
                            (let [#_"ObjMethod" enclosingMethod (ß (ObjMethod) METHOD.deref())]
                                (ß fn.hasEnclosingMethod = enclosingMethod != nil)
                                (when (ß ((IMeta) form.first()).meta() != nil)
                                    (ß fn.onceOnly = RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(nil, "once"))))
                                )

                                (let [#_"String" basename (ß ((enclosingMethod != nil) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$")]
                                    (let [#_"Symbol" nm nil]
                                        (if (ß RT.second(form) instanceof Symbol)
                                            (do
                                                (ß nm = (Symbol) RT.second(form))
                                                (ß name = nm.name + "__" + RT.nextID())
                                            )
                                            (do
                                                (cond (ß name == nil)
                                                    (do
                                                        (ß name = "fn__" + RT.nextID())
                                                    )
                                                    (ß enclosingMethod != nil)
                                                    (do
                                                        (ß name += "__" + RT.nextID())
                                                    )
                                                )
                                            )
                                        )

                                        (let [#_"String" simpleName (ß munge(name).replace(".", "_DOT_"))]
                                            (ß fn.name = basename + simpleName)
                                            (ß fn.internalName = fn.name.replace(\., \/))
                                            (ß fn.objtype = Type.getObjectType(fn.internalName))
                                            (let [#_"ArrayList<String>" prims (ß new ArrayList())]
                                                (try
                                                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                        #_map CONSTANTS, PersistentVector.EMPTY,
                                                        #_map CONSTANT_IDS, new IdentityHashMap(),
                                                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                                                        #_map VARS, PersistentHashMap.EMPTY,
                                                        #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                                                        #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                                                        #_map VAR_CALLSITES, emptyVarCallSites(),
                                                        #_map NO_RECUR, nil
                                                    )))

                                                    ;; arglist might be preceded by symbol naming this fn
                                                    (when (ß nm != nil)
                                                        (ß fn.thisName = nm.name)
                                                        (ß form = RT.cons(FN, RT.next(RT.next(form))))
                                                    )

                                                    ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                    ;; turn former into latter
                                                    (when (ß RT.second(form) instanceof IPersistentVector)
                                                        (ß form = RT.list(FN, RT.next(form)))
                                                    )
                                                    (ß fn.line = lineDeref())
                                                    (ß fn.column = columnDeref())
                                                    (let [#_"FnMethod[]" methodArray (ß new FnMethod[MAX_POSITIONAL_ARITY + 1])]
                                                        (let [#_"FnMethod" variadicMethod nil]
                                                            (let [#_"boolean" usesThis false]
                                                                (loop-when-recur [(ß ISeq s = RT.next(form))] (ß s != nil) [(ß s = RT.next(s))]
                                                                    (let [#_"FnMethod" f (ß FnMethod.parse(fn, (ISeq) RT.first(s), rettag))]
                                                                        (when (ß f.usesThis)
                                                                            (ß usesThis = true)
                                                                        )
                                                                        (cond (ß f.isVariadic())
                                                                            (do
                                                                                (if (ß variadicMethod == nil)
                                                                                    (do
                                                                                        (ß variadicMethod = f)
                                                                                    )
                                                                                    (do
                                                                                        (throw (ß Util.runtimeException("Can't have more than 1 variadic overload")))
                                                                                    )
                                                                                )
                                                                            )
                                                                            (ß methodArray[f.reqParms.count()] == nil)
                                                                            (do
                                                                                (ß methodArray[f.reqParms.count()] = f)
                                                                            )
                                                                            :else
                                                                            (do
                                                                                (throw (ß Util.runtimeException("Can't have 2 overloads with same arity")))
                                                                            )
                                                                        )
                                                                        (when (ß f.prim != nil)
                                                                            (ß prims.add(f.prim))
                                                                        )
                                                                    )
                                                                )
                                                                (when (ß variadicMethod != nil)
                                                                    (loop-when-recur [(ß int i = variadicMethod.reqParms.count() + 1)] (ß i <= MAX_POSITIONAL_ARITY) [(ß i++)]
                                                                        (when (ß methodArray[i] != nil)
                                                                            (throw (ß Util.runtimeException("Can't have fixed arity function with more params than variadic function")))
                                                                        )
                                                                    )
                                                                )

                                                                (ß fn.canBeDirect = (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis))

                                                                (let [#_"IPersistentCollection" methods nil]
                                                                    (loop-when-recur [(ß int i = 0)] (ß i < methodArray.length) [(ß i++)]
                                                                        (when (ß methodArray[i] != nil)
                                                                            (ß methods = RT.conj(methods, methodArray[i]))
                                                                        )
                                                                    )
                                                                    (when (ß variadicMethod != nil)
                                                                        (ß methods = RT.conj(methods, variadicMethod))
                                                                    )

                                                                    (when (ß fn.canBeDirect)
                                                                        (doseq [#_"FnMethod" fm (ß (Collection<FnMethod>)methods)]
                                                                            (when (ß fm.locals != nil)
                                                                                (doseq [#_"LocalBinding" lb (ß (Collection<LocalBinding>)RT.keys(fm.locals))]
                                                                                    (when (ß lb.isArg)
                                                                                        (ß lb.idx -= 1)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )

                                                                    (ß fn.methods = methods)
                                                                    (ß fn.variadicMethod = variadicMethod)
                                                                    (ß fn.keywords = (IPersistentMap) KEYWORDS.deref())
                                                                    (ß fn.vars = (IPersistentMap) VARS.deref())
                                                                    (ß fn.constants = (PersistentVector) CONSTANTS.deref())
                                                                    (ß fn.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                                                                    (ß fn.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                                                                    (ß fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())

                                                                    (ß fn.constantsID = RT.nextID())
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (finally
                                                        (ß Var.popThreadBindings())
                                                    )
                                                )
                                                (ß fn.hasPrimSigs = prims.size() > 0)
                                                (let [#_"IPersistentMap" fmeta (ß RT.meta(origForm))]
                                                    (when (ß fmeta != nil)
                                                        (ß fmeta = fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey))
                                                    )

                                                    (ß fn.hasMeta = RT.count(fmeta) > 0)

                                                    (try
                                                        (ß fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? nil :or prims.toArray(new String[prims.size()]), fn.onceOnly))
                                                        (catch IOException e
                                                            (throw (ß Util.sneakyThrow(e)))
                                                        )
                                                    )
                                                    (ß fn.getCompiledClass())

                                                    (if (ß fn.supportsMeta())
                                                        (do
                                                            (ß new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta)))
                                                        )
                                                        (do
                                                            fn
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"ObjMethod" variadicMethod [this]
            variadicMethod
        )

        #_method
        (§ defn #_"boolean" isVariadic [this]
            (ß (variadicMethod != nil))
        )

        #_method
        (§ defn #_"IPersistentCollection" methods [this]
            methods
        )

        #_method
        (§ defn #_"void" emitForDefn [this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emit(C.EXPRESSION, objx, gen))
            nil
        )
    )

    (class-ns ObjExpr (§ implements Expr)
        (§ def #_"String" CONST_PREFIX (ß "const__"))

        (§ field #_"String" name)
        (§ field #_"String" internalName)
        (§ field #_"String" thisName)
        (§ field #_"Type" objtype)
        (§ field #_"Object" tag)
        ;; localbinding->itself
        (§ field #_"IPersistentMap" closes (ß PersistentHashMap.EMPTY))
        ;; localbndingexprs
        (§ field #_"IPersistentVector" closesExprs (ß PersistentVector.EMPTY))
        ;; symbols
        (§ field #_"IPersistentSet" volatiles (ß PersistentHashSet.EMPTY))

        ;; symbol->lb
        (§ field #_"IPersistentMap" fields (ß nil))

        ;; hinted fields
        (§ field #_"IPersistentVector" hintedFields (ß PersistentVector.EMPTY))

        ;; Keyword->KeywordExpr
        (§ field #_"IPersistentMap" keywords (ß PersistentHashMap.EMPTY))
        (§ field #_"IPersistentMap" vars (ß PersistentHashMap.EMPTY))
        (§ field #_"Class" compiledClass)
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"PersistentVector" constants)
        (§ field #_"IPersistentSet" usedConstants (ß PersistentHashSet.EMPTY))

        (§ field #_"int" constantsID)
        (§ field #_"int" altCtorDrops (ß 0))

        (§ field #_"IPersistentVector" keywordCallsites)
        (§ field #_"IPersistentVector" protocolCallsites)
        (§ field #_"IPersistentSet" varCallsites)
        (§ field #_"boolean" onceOnly (ß false))

        (§ field #_"Object" src)

        (§ field #_"IPersistentMap" opts (ß PersistentHashMap.EMPTY))

        (§ def #_"Method" voidctor (ß Method.getMethod("void <init>()")))
        #_protected
        (§ field #_"IPersistentMap" classMeta)
        #_protected
        (§ field #_"boolean" canBeDirect)

        #_method
        (§ defn #_"String" name [this]
            name
        )

        #_method
        (§ defn #_"String" internalName [this]
            internalName
        )

        #_method
        (§ defn #_"String" thisName [this]
            thisName
        )

        #_method
        (§ defn #_"Type" objtype [this]
            objtype
        )

        #_method
        (§ defn #_"IPersistentMap" closes [this]
            closes
        )

        #_method
        (§ defn #_"IPersistentMap" keywords [this]
            keywords
        )

        #_method
        (§ defn #_"IPersistentMap" vars [this]
            vars
        )

        #_method
        (§ defn #_"Class" compiledClass [this]
            compiledClass
        )

        #_method
        (§ defn #_"int" line [this]
            line
        )

        #_method
        (§ defn #_"int" column [this]
            column
        )

        #_method
        (§ defn #_"PersistentVector" constants [this]
            constants
        )

        #_method
        (§ defn #_"int" constantsID [this]
            constantsID
        )

        (§ def #_"Method" kwintern (ß Method.getMethod("cloiure.lang.Keyword intern(String, String)")))
        (§ def #_"Method" symintern (ß Method.getMethod("cloiure.lang.Symbol intern(String)")))
        (§ def #_"Method" varintern (ß Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)")))

        (§ def #_"Type" DYNAMIC_CLASSLOADER_TYPE (ß Type.getType(DynamicClassLoader.class)))
        (§ def #_"Method" getClassMethod (ß Method.getMethod("Class getClass()")))
        (§ def #_"Method" getClassLoaderMethod (ß Method.getMethod("ClassLoader getClassLoader()")))
        (§ def #_"Method" getConstantsMethod (ß Method.getMethod("Object[] getConstants(int)")))
        (§ def #_"Method" readStringMethod (ß Method.getMethod("Object readString(String)")))

        (§ def #_"Type" ILOOKUP_SITE_TYPE (ß Type.getType(ILookupSite.class)))
        (§ def #_"Type" ILOOKUP_THUNK_TYPE (ß Type.getType(ILookupThunk.class)))
        (§ def #_"Type" KEYWORD_LOOKUPSITE_TYPE (ß Type.getType(KeywordLookupSite.class)))

        (§ field- #_"DynamicClassLoader" loader)
        (§ field- #_"byte[]" bytecode)

        (§ constructor #_"ObjExpr" ObjExpr [#_"Object" tag]
            (ß this.tag = tag)
            this
        )

        (§ defn #_"String" trimGenID [#_"String" name]
            (let [#_"int" i (ß name.lastIndexOf("__"))]
                (ß (i == -1) ? name :or name.substring(0, i))
            )
        )

        #_method
        (§ defn #_"Type[]" ctorTypes [this]
            (let [#_"IPersistentVector" tv (ß !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE))]
                (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                        (if (ß lb.getPrimitiveType() != nil)
                            (do
                                (ß tv = tv.cons(Type.getType(lb.getPrimitiveType())))
                            )
                            (do
                                (ß tv = tv.cons(OBJECT_TYPE))
                            )
                        )
                    )
                )
                (let [#_"Type[]" ret (ß new Type[tv.count()])]
                    (loop-when-recur [(ß int i = 0)] (ß i < tv.count()) [(ß i++)]
                        (ß ret[i] = (Type) tv.nth(i))
                    )
                    ret
                )
            )
        )

        #_method
        (§ defn #_"void" compile [this, #_"String" superName, #_"String[]" interfaceNames, #_"boolean" oneTimeUse] (§ throws IOException)
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            (let [#_"ClassWriter" cw (ß new ClassWriter(ClassWriter.COMPUTE_MAXS))]
                (let [#_"ClassVisitor" cv cw]
                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, superName, interfaceNames))
                    (let [#_"String" source (ß (String) SOURCE.deref())]
                        (let [#_"int" lineBefore (ß (Integer) LINE_BEFORE.deref())]
                            (let [#_"int" lineAfter (ß (Integer) LINE_AFTER.deref() + 1)]
                                (let [#_"int" columnBefore (ß (Integer) COLUMN_BEFORE.deref())]
                                    (let [#_"int" columnAfter (ß (Integer) COLUMN_AFTER.deref() + 1)]
                                        (when (ß source != nil && SOURCE_PATH.deref() != nil)
                                            (let [#_"String" smap
                                                    (str "SMAP\n"
                                                        (ß (source.lastIndexOf(\.) > 0) ? source.substring(0, source.lastIndexOf(\.)) :or source) ;; :or simpleName
                                                        ".java\n"
                                                        "Cloiure\n"
                                                        "*S Cloiure\n"
                                                        "*F\n"
                                                        "+ 1 " source "\n"
                                                        (ß (String) SOURCE_PATH.deref()) "\n"
                                                        "*L\n"
                                                        (ß String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore))
                                                        "*E"
                                                    )]
                                                (ß cv.visitSource(source, smap))
                                            )
                                        )
                                        (ß addAnnotation(cv, classMeta))

                                        (when (ß supportsMeta())
                                            (ß cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                        )
                                        ;; instance fields for closed-overs
                                        (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                                            (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                (if (ß isDeftype())
                                                    (do
                                                        (let [#_"int" access (ß isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL))]
                                                            (§ let [#_"FieldVisitor" fv]
                                                                (if (ß lb.getPrimitiveType() != nil)
                                                                    (do
                                                                        (ß fv = cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                                    )
                                                                    (do
                                                                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                        (ß fv = cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                                                    )
                                                                )
                                                                (ß addAnnotation(fv, RT.meta(lb.sym)))
                                                            )
                                                        )
                                                    )
                                                    (do
                                                        ;; todo - only enable this non-private+writability for letfns where we need it
                                                        (if (ß lb.getPrimitiveType() != nil)
                                                            (do
                                                                (ß cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                            )
                                                            (do
                                                                (ß cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        ;; static fields for callsites and thunks
                                        (loop-when-recur [(ß int i = 0)] (ß i < protocolCallsites.count()) [(ß i++)]
                                            (ß cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), nil, nil))
                                        )

                                        ;; ctor that takes closed-overs and inits base + fields
                                        (let [#_"Method" m (ß new Method("<init>", Type.VOID_TYPE, ctorTypes()))]
                                            (let [#_"GeneratorAdapter" ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))]
                                                (let [#_"Label" start (ß ctorgen.newLabel())]
                                                    (let [#_"Label" end (ß ctorgen.newLabel())]
                                                        (ß ctorgen.visitCode())
                                                        (ß ctorgen.visitLineNumber(line, ctorgen.mark()))
                                                        (ß ctorgen.visitLabel(start))
                                                        (ß ctorgen.loadThis())
                                                        (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))

                                                        (when (ß supportsMeta())
                                                            (ß ctorgen.loadThis())
                                                            (ß ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1))
                                                            (ß ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE))
                                                        )

                                                        (let [#_"int" a (ß supportsMeta() ? 2 :or 1)]
                                                            (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next(), ++a)]
                                                                (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                                    (ß ctorgen.loadThis())
                                                                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                                        (if (ß primc != nil)
                                                                            (do
                                                                                (ß ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a))
                                                                                (ß ctorgen.putField(objtype, lb.name, Type.getType(primc)))
                                                                                (when (ß primc == Long.TYPE || primc == Double.TYPE)
                                                                                    (ß ++a)
                                                                                )
                                                                            )
                                                                            (do
                                                                                (ß ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a))
                                                                                (ß ctorgen.putField(objtype, lb.name, OBJECT_TYPE))
                                                                            )
                                                                        )
                                                                        (ß closesExprs = closesExprs.cons(new LocalBindingExpr(lb, nil)))
                                                                    )
                                                                )
                                                            )

                                                            (ß ctorgen.visitLabel(end))

                                                            (ß ctorgen.returnValue())

                                                            (ß ctorgen.endMethod())

                                                            (when (ß altCtorDrops > 0)
                                                                ;; ctor that takes closed-overs and inits base + fields
                                                                (let [#_"Type[]" ctorTypes (ß ctorTypes())]
                                                                    (let [#_"Type[]" altCtorTypes (ß new Type[ctorTypes.length-altCtorDrops])]
                                                                        (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                                                            (ß altCtorTypes[i] = ctorTypes[i])
                                                                        )
                                                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes))]
                                                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.loadArgs())

                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())

                                                                            ;; alt ctor no __hash, __hasheq
                                                                            (ß altCtorTypes = new Type[ctorTypes.length-2])
                                                                            (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                                                                (ß altCtorTypes[i] = ctorTypes[i])
                                                                            )

                                                                            (ß alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                                                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.loadArgs())

                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())
                                                                        )
                                                                    )
                                                                )
                                                            )

                                                            (when (ß supportsMeta())
                                                                ;; ctor that takes closed-overs but not meta
                                                                (let [#_"Type[]" ctorTypes (ß ctorTypes())]
                                                                    (let [#_"Type[]" noMetaCtorTypes (ß new Type[ctorTypes.length-1])]
                                                                        (loop-when-recur [(ß int i = 1)] (ß i < ctorTypes.length) [(ß i++)]
                                                                            (ß noMetaCtorTypes[i - 1] = ctorTypes[i])
                                                                        )
                                                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes))]
                                                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; nil meta
                                                                            (ß ctorgen.loadArgs())
                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())

                                                                            ;; meta()
                                                                            (let [#_"Method" meth (ß Method.getMethod("cloiure.lang.IPersistentMap meta()"))]
                                                                                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))]
                                                                                    (ß gen.visitCode())
                                                                                    (ß gen.loadThis())
                                                                                    (ß gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE))

                                                                                    (ß gen.returnValue())
                                                                                    (ß gen.endMethod())

                                                                                    ;; withMeta()
                                                                                    (ß meth = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                                                                                    (ß gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))
                                                                                    (ß gen.visitCode())
                                                                                    (ß gen.newInstance(objtype))
                                                                                    (ß gen.dup())
                                                                                    (ß gen.loadArg(0))

                                                                                    (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next(), ++a)]
                                                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                                                            (ß gen.loadThis())
                                                                                            (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                                                                (if (ß primc != nil)
                                                                                                    (do
                                                                                                        (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                                                                                                    )
                                                                                                    (do
                                                                                                        (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )

                                                                                    (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))
                                                                                    (ß gen.returnValue())
                                                                                    (ß gen.endMethod())
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )

                                                            (ß emitStatics(cv))
                                                            (ß emitMethods(cv))

                                                            ;; static fields for constants
                                                            (loop-when-recur [(ß int i = 0)] (ß i < constants.count()) [(ß i++)]
                                                                (when (ß usedConstants.contains(i))
                                                                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), nil, nil))
                                                                )
                                                            )

                                                            ;; static fields for lookup sites
                                                            (loop-when-recur [(ß int i = 0)] (ß i < keywordCallsites.count()) [(ß i++)]
                                                                (ß cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                                (ß cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                            )

                                                            ;; static init for constants, keywords and vars
                                                            (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))]
                                                                (ß clinitgen.visitCode())
                                                                (ß clinitgen.visitLineNumber(line, clinitgen.mark()))

                                                                (when (ß constants.count() > 0)
                                                                    (ß emitConstants(clinitgen))
                                                                )

                                                                (when (ß keywordCallsites.count() > 0)
                                                                    (ß emitKeywordCallsites(clinitgen))
                                                                )

                                                                (when (ß isDeftype() && RT.booleanCast(RT.get(opts, loadNs)))
                                                                    (let [#_"String" nsname (ß ((Symbol)RT.second(src)).getNamespace())]
                                                                        (when (ß !nsname.equals("cloiure.core"))
                                                                            (ß clinitgen.push("cloiure.core"))
                                                                            (ß clinitgen.push("require"))
                                                                            (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                                                                            (ß clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")))
                                                                            (ß clinitgen.checkCast(IFN_TYPE))
                                                                            (ß clinitgen.push(nsname))
                                                                            (ß clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)")))
                                                                            (ß clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)")))
                                                                            (ß clinitgen.pop())
                                                                        )
                                                                    )
                                                                )

                                                                (ß clinitgen.returnValue())

                                                                (ß clinitgen.endMethod())

                                                                ;; end of class
                                                                (ß cv.visitEnd())

                                                                (ß bytecode = cw.toByteArray())
                                                                (when (ß RT.booleanCast(COMPILE_FILES.deref()))
                                                                    (ß writeClassFile(internalName, bytecode))
                                                                )
                                                                nil
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"void" emitKeywordCallsites [this, #_"GeneratorAdapter" clinitgen]
            (loop-when-recur [(ß int i = 0)] (ß i < keywordCallsites.count()) [(ß i++)]
                (let [#_"Keyword" k (ß (Keyword) keywordCallsites.nth(i))]
                    (ß clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE))
                    (ß clinitgen.dup())
                    (ß emitValue(k, clinitgen))
                    (ß clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)")))
                    (ß clinitgen.dup())
                    (ß clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE))
                    (ß clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE))
                )
            )
            nil
        )

        #_protected
        #_method
        (§ defn #_"void" emitStatics [this, #_"ClassVisitor" gen]
            nil
        )

        #_protected
        #_method
        (§ defn #_"void" emitMethods [this, #_"ClassVisitor" gen]
            nil
        )

        #_method
        (§ defn #_"void" emitListAsObjectArray [this, #_"Object" value, #_"GeneratorAdapter" gen]
            (ß gen.push(((List) value).size()))
            (ß gen.newArray(OBJECT_TYPE))
            (let [#_"int" i 0]
                (loop-when-recur [(ß Iterator it = ((List) value).iterator())] (ß it.hasNext()) [(ß i++)]
                    (ß gen.dup())
                    (ß gen.push(i))
                    (ß emitValue(it.next(), gen))
                    (ß gen.arrayStore(OBJECT_TYPE))
                )
                nil
            )
        )

        #_method
        (§ defn #_"void" emitValue [this, #_"Object" value, #_"GeneratorAdapter" gen]
            (let [#_"boolean" partial true]
                (cond (ß value == nil)
                    (do
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    )
                    (ß value instanceof String)
                    (do
                        (ß gen.push((String) value))
                    )
                    (ß value instanceof Boolean)
                    (do
                        (if (ß ((Boolean) value).booleanValue())
                            (do
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                            )
                            (do
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                            )
                        )
                    )
                    (ß value instanceof Integer)
                    (do
                        (ß gen.push(((Integer) value).intValue()))
                        (ß gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)")))
                    )
                    (ß value instanceof Long)
                    (do
                        (ß gen.push(((Long) value).longValue()))
                        (ß gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)")))
                    )
                    (ß value instanceof Double)
                    (do
                        (ß gen.push(((Double) value).doubleValue()))
                        (ß gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)")))
                    )
                    (ß value instanceof Character)
                    (do
                        (ß gen.push(((Character) value).charValue()))
                        (ß gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)")))
                    )
                    (ß value instanceof Class)
                    (do
                        (let [#_"Class" cc (ß (Class)value)]
                            (if (ß cc.isPrimitive())
                                (do
                                    (§ let [#_"Type" bt]
                                        (cond (ß cc == boolean.class)
                                            (do
                                                (ß bt = Type.getType(Boolean.class))
                                            )
                                            (ß cc == byte.class)
                                            (do
                                                (ß bt = Type.getType(Byte.class))
                                            )
                                            (ß cc == char.class)
                                            (do
                                                (ß bt = Type.getType(Character.class))
                                            )
                                            (ß cc == double.class)
                                            (do
                                                (ß bt = Type.getType(Double.class))
                                            )
                                            (ß cc == float.class)
                                            (do
                                                (ß bt = Type.getType(Float.class))
                                            )
                                            (ß cc == int.class)
                                            (do
                                                (ß bt = Type.getType(Integer.class))
                                            )
                                            (ß cc == long.class)
                                            (do
                                                (ß bt = Type.getType(Long.class))
                                            )
                                            (ß cc == short.class)
                                            (do
                                                (ß bt = Type.getType(Short.class))
                                            )
                                            :else
                                            (do
                                                (throw (ß Util.runtimeException("Can't embed unknown primitive in code: " + value)))
                                            )
                                        )
                                        (ß gen.getStatic(bt, "TYPE", Type.getType(Class.class)))
                                    )
                                )
                                (do
                                    (ß gen.push(destubClassName(cc.getName())))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                                )
                            )
                        )
                    )
                    (ß value instanceof Symbol)
                    (do
                        (ß gen.push(((Symbol) value).ns))
                        (ß gen.push(((Symbol) value).name))
                        (ß gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)")))
                    )
                    (ß value instanceof Keyword)
                    (do
                        (ß gen.push(((Keyword) value).sym.ns))
                        (ß gen.push(((Keyword) value).sym.name))
                        (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)")))
                    )
                    (ß value instanceof Var)
                    (do
                        (let [#_"Var" var (ß (Var) value)]
                            (ß gen.push(var.ns.name.toString()))
                            (ß gen.push(var.sym.toString()))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                        )
                    )
                    (ß value instanceof IType)
                    (do
                        (let [#_"Method" ctor (ß new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0])))]
                            (ß gen.newInstance(Type.getType(value.getClass())))
                            (ß gen.dup())
                            (let [#_"IPersistentVector" fields (ß (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§)))]
                                (loop-when-recur [(ß ISeq s = RT.seq(fields))] (ß s != nil) [(ß s = s.next())]
                                    (let [#_"Symbol" field (ß (Symbol) s.first())]
                                        (let [#_"Class" k (ß tagClass(tagOf(field)))]
                                            (let [#_"Object" val (ß Reflector.getInstanceField(value, munge(field.name)))]
                                                (ß emitValue(val, gen))

                                                (when (ß k.isPrimitive())
                                                    (let [#_"Type" b (ß Type.getType(boxClass(k)))]
                                                        (let [#_"String" p (ß Type.getType(k).getDescriptor())]
                                                            (let [#_"String" n (ß k.getName())]
                                                                (ß gen.invokeVirtual(b, new Method(n+"Value", "()"+p)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (ß gen.invokeConstructor(Type.getType(value.getClass()), ctor))
                            )
                        )
                    )
                    (ß value instanceof IRecord)
                    (do
                        (let [#_"Method" createMethod (ß Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))]
                            (ß emitValue(PersistentArrayMap.create((java.util.Map) value), gen))
                            (ß gen.invokeStatic(getType(value.getClass()), createMethod))
                        )
                    )
                    (ß value instanceof IPersistentMap)
                    (do
                        (let [#_"List" entries (ß new ArrayList())]
                            (doseq [#_"Map.Entry" entry (ß (Set<Map.Entry>) ((Map) value).entrySet())]
                                (ß entries.add(entry.getKey()))
                                (ß entries.add(entry.getValue()))
                            )
                            (ß emitListAsObjectArray(entries, gen))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                        )
                    )
                    (ß value instanceof IPersistentVector)
                    (do
                        (let [#_"IPersistentVector" args (ß (IPersistentVector) value)]
                            (if (ß args.count() <= Tuple.MAX_SIZE)
                                (do
                                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                                        (ß emitValue(args.nth(i), gen))
                                    )
                                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                                )
                                (do
                                    (ß emitListAsObjectArray(value, gen))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                                )
                            )
                        )
                    )
                    (ß value instanceof PersistentHashSet)
                    (do
                        (let [#_"ISeq" vs (ß RT.seq(value))]
                            (if (ß vs == nil)
                                (do
                                    (ß gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class)))
                                )
                                (do
                                    (ß emitListAsObjectArray(vs, gen))
                                    (ß gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                                )
                            )
                        )
                    )
                    (ß value instanceof ISeq || value instanceof IPersistentList)
                    (do
                        (ß emitListAsObjectArray(value, gen))
                        (ß gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])")))
                        (ß gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                    )
                    (ß value instanceof Pattern)
                    (do
                        (ß emitValue(value.toString(), gen))
                        (ß gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)")))
                    )
                    :else
                    (do
                        (let [#_"String" cs nil]
                            (try
                                (ß cs = RT.printString(value))
                                (catch Exception e
                                    (throw (ß Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value)))
                                )
                            )
                            (when (ß cs.length() == 0)
                                (throw (ß Util.runtimeException("Can't embed unreadable object in code: " + value)))
                            )

                            (when (ß cs.startsWith("#<"))
                                (throw (ß Util.runtimeException("Can't embed unreadable object in code: " + cs)))
                            )

                            (ß gen.push(cs))
                            (ß gen.invokeStatic(RT_TYPE, readStringMethod))
                            (ß partial = false)
                        )
                    )
                )

                (when partial
                    (when (ß value instanceof IObj && RT.count(((IObj) value).meta()) > 0)
                        (ß gen.checkCast(IOBJ_TYPE))
                        (let [#_"Object" m (ß ((IObj) value).meta())]
                            (ß emitValue(elideMeta(m), gen))
                            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                            (ß gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                        )
                    )
                )
                nil
            )
        )

        #_method
        (§ defn #_"void" emitConstants [this, #_"GeneratorAdapter" clinitgen]
            (try
                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                (loop-when-recur [(ß int i = 0)] (ß i < constants.count()) [(ß i++)]
                    (when (ß usedConstants.contains(i))
                        (ß emitValue(constants.nth(i), clinitgen))
                        (ß clinitgen.checkCast(constantType(i)))
                        (ß clinitgen.putStatic(objtype, constantName(i), constantType(i)))
                    )
                )
                (finally
                    (ß Var.popThreadBindings())
                )
            )
            nil
        )

        #_method
        (§ defn #_"boolean" isMutable [this, #_"LocalBinding" lb]
            (ß isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable"))))
        )

        #_method
        (§ defn #_"boolean" isVolatile [this, #_"LocalBinding" lb]
            (ß RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable"))))
        )

        #_method
        (§ defn #_"boolean" isDeftype [this]
            (ß (fields != nil))
        )

        #_method
        (§ defn #_"boolean" supportsMeta [this]
            (ß !isDeftype())
        )

        #_method
        (§ defn #_"void" emitClearCloses [this, #_"GeneratorAdapter" gen]
            nil
        )

        #_method
        (§ defn #_"Class" getCompiledClass [this]
            (§ sync this
                (when (ß compiledClass == nil)
                    (ß loader = (DynamicClassLoader) LOADER.deref())
                    (ß compiledClass = loader.defineClass(name, bytecode, src))
                )
                compiledClass
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (when (ß isDeftype())
                (§ return nil)
            )
            (try
                (ß getCompiledClass().newInstance())
                (catch Exception e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )

        #_method
        (§ defn #_"void" emitLetFnInits [this, #_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"IPersistentSet" letFnLocals]
            ;; objx arg is enclosing objx, not this
            (ß gen.checkCast(objtype))

            (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                    (when (ß letFnLocals.contains(lb))
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (ß gen.dup())
                            (if (ß primc != nil)
                                (do
                                    (ß objx.emitUnboxedLocal(gen, lb))
                                    (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                                )
                                (do
                                    (ß objx.emitLocal(gen, lb, false))
                                    (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                                )
                            )
                        )
                    )
                )
            )
            (ß gen.pop())
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            (if (ß isDeftype())
                (do
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                )
                (do
                    (ß gen.newInstance(objtype))
                    (ß gen.dup())
                    (when (ß supportsMeta())
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    )
                    (loop-when-recur [(ß ISeq s = RT.seq(closesExprs))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"LocalBindingExpr" lbe (ß (LocalBindingExpr) s.first())]
                            (let [#_"LocalBinding" lb (ß lbe.b)]
                                (if (ß lb.getPrimitiveType() != nil)
                                    (do
                                        (ß objx.emitUnboxedLocal(gen, lb))
                                    )
                                    (do
                                        (ß objx.emitLocal(gen, lb, lbe.shouldClear))
                                    )
                                )
                            )
                        )
                    )
                    (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes())))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        (§ field #_"Class" jc)

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr.tagToClass(tag) :or IFn.class)
            )
            jc
        )

        #_method
        (§ defn #_"void" emitAssignLocal [this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"Expr" val]
            (when (ß !isMutable(lb))
                (throw (ß new IllegalArgumentException("Cannot assign to non-mutable: " + lb.name)))
            )
            (let [#_"Class" primc (ß lb.getPrimitiveType())]
                (ß gen.loadThis())
                (if (ß primc != nil)
                    (do
                        (when (ß !(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive()))
                            (throw (ß new IllegalArgumentException("Must assign primitive to primitive mutable: " + lb.name)))
                        )
                        (let [#_"MaybePrimitiveExpr" me (ß (MaybePrimitiveExpr) val)]
                            (ß me.emitUnboxed(C.EXPRESSION, this, gen))
                            (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                        )
                    )
                    (do
                        (ß val.emit(C.EXPRESSION, this, gen))
                        (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
                nil
            )
        )

        #_method
        (§ defn- #_"void" emitLocal [this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"boolean" clear]
            (if (ß closes.containsKey(lb))
                (do
                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                        (ß gen.loadThis())
                        (if (ß primc != nil)
                            (do
                                (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                                (ß HostExpr.emitBoxReturn(this, gen, primc))
                            )
                            (do
                                (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                                (when (ß onceOnly && clear && lb.canBeCleared)
                                    (ß gen.loadThis())
                                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                    (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                                )
                            )
                        )
                    )
                )
                (do
                    (let [#_"int" argoff (ß canBeDirect ? 0 :or 1)]
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (if (ß lb.isArg)
                                (do
                                    (ß gen.loadArg(lb.idx-argoff))
                                    (cond (ß primc != nil)
                                        (do
                                            (ß HostExpr.emitBoxReturn(this, gen, primc))
                                        )
                                        (ß clear && lb.canBeCleared)
                                        (do
                                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                            (ß gen.storeArg(lb.idx - argoff))
                                        )
                                    )
                                )
                                (do
                                    (if (ß primc != nil)
                                        (do
                                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                                            (ß HostExpr.emitBoxReturn(this, gen, primc))
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx))
                                            (when (ß clear && lb.canBeCleared)
                                                (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitUnboxedLocal [this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb]
            (let [#_"int" argoff (ß canBeDirect ? 0 :or 1)]
                (let [#_"Class" primc (ß lb.getPrimitiveType())]
                    (cond (ß closes.containsKey(lb))
                        (do
                            (ß gen.loadThis())
                            (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                        )
                        (ß lb.isArg)
                        (do
                            (ß gen.loadArg(lb.idx-argoff))
                        )
                        :else
                        (do
                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                        )
                    )
                    nil
                )
            )
        )

        #_method
        (§ defn #_"void" emitVar [this, #_"GeneratorAdapter" gen, #_"Var" var]
            (let [#_"Integer" i (ß (Integer) vars.valAt(var))]
                (ß emitConstant(gen, i))
                nil
            )
        )

        (§ def #_"Method" varGetMethod (ß Method.getMethod("Object get()")))
        (§ def #_"Method" varGetRawMethod (ß Method.getMethod("Object getRawRoot()")))

        #_method
        (§ defn #_"void" emitVarValue [this, #_"GeneratorAdapter" gen, #_"Var" v]
            (let [#_"Integer" i (ß (Integer) vars.valAt(v))]
                (if (ß !v.isDynamic())
                    (do
                        (ß emitConstant(gen, i))
                        (ß gen.invokeVirtual(VAR_TYPE, varGetRawMethod))
                    )
                    (do
                        (ß emitConstant(gen, i))
                        (ß gen.invokeVirtual(VAR_TYPE, varGetMethod))
                    )
                )
                nil
            )
        )

        #_method
        (§ defn #_"void" emitKeyword [this, #_"GeneratorAdapter" gen, #_"Keyword" k]
            (let [#_"Integer" i (ß (Integer) keywords.valAt(k))]
                (ß emitConstant(gen, i))
                nil
            )
        )

        #_method
        (§ defn #_"void" emitConstant [this, #_"GeneratorAdapter" gen, #_"int" id]
            (ß usedConstants = (IPersistentSet) usedConstants.cons(id))
            (ß gen.getStatic(objtype, constantName(id), constantType(id)))
            nil
        )

        #_method
        (§ defn #_"String" constantName [this, #_"int" id]
            (ß CONST_PREFIX + id)
        )

        #_method
        (§ defn #_"String" siteName [this, #_"int" n]
            (ß "__site__" + n)
        )

        #_method
        (§ defn #_"String" siteNameStatic [this, #_"int" n]
            (ß siteName(n) + "__")
        )

        #_method
        (§ defn #_"String" thunkName [this, #_"int" n]
            (ß "__thunk__" + n)
        )

        #_method
        (§ defn #_"String" cachedClassName [this, #_"int" n]
            (ß "__cached_class__" + n)
        )

        #_method
        (§ defn #_"String" cachedVarName [this, #_"int" n]
            (ß "__cached_var__" + n)
        )

        #_method
        (§ defn #_"String" varCallsiteName [this, #_"int" n]
            (ß "__var__callsite__" + n)
        )

        #_method
        (§ defn #_"String" thunkNameStatic [this, #_"int" n]
            (ß thunkName(n) + "__")
        )

        #_method
        (§ defn #_"Type" constantType [this, #_"int" id]
            (let [#_"Object" o (ß constants.nth(id))]
                (let [#_"Class" c (ß cloiure.lang.Util.classOf(o))]
                    (when (ß c!= nil && Modifier.isPublic(c.getModifiers()))
                        ;; can't emit derived fn types due to visibility
                        (cond (ß LazySeq.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(ISeq.class)))
                            )
                            (ß c == Keyword.class)
                            (do
                                (§ return (ß Type.getType(Keyword.class)))
                            )
                            (ß RestFn.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(RestFn.class)))
                            )
                            (ß AFn.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(AFn.class)))
                            )
                            (ß c == Var.class)
                            (do
                                (§ return (ß Type.getType(Var.class)))
                            )
                            (ß c == String.class)
                            (do
                                (§ return (ß Type.getType(String.class)))
                            )
                        )
                    )
                    (ß OBJECT_TYPE)
                )
            )
        )
    )

    #_non-static
    (§ enum PATHTYPE
        (§ item PATH),
        (§ item BRANCH)
    )

    (class-ns PathNode
        (§ field #_"PATHTYPE" type)
        (§ field #_"PathNode" parent)

        (§ constructor #_"PathNode" PathNode [#_"PATHTYPE" type, #_"PathNode" parent]
            (ß this.type = type)
            (ß this.parent = parent)
            this
        )
    )

    (§ defn #_"PathNode" clearPathRoot []
        (ß (PathNode) CLEAR_ROOT.get())
    )

    #_non-static
    (§ enum PSTATE
        (§ item REQ),
        (§ item REST),
        (§ item DONE)
    )

    (class-ns FnMethod (§ extends ObjMethod)
        ;; localbinding->localbinding
        (§ field #_"PersistentVector" reqParms (ß PersistentVector.EMPTY))
        (§ field #_"LocalBinding" restParm (ß nil))
        (§ field #_"Type[]" argtypes)
        (§ field #_"Class[]" argclasses)
        (§ field #_"Class" retClass)
        (§ field #_"String" prim)

        (§ constructor #_"FnMethod" FnMethod [#_"ObjExpr" objx, #_"ObjMethod" parent]
            (§ super(objx, parent))
            this
        )

        (§ defn #_"char" classChar [#_"Object" x]
            (let [#_"Class" c nil]
                (cond (ß x instanceof Class)
                    (do
                        (ß c = (Class) x)
                    )
                    (ß x instanceof Symbol)
                    (do
                        (ß c = primClass((Symbol) x))
                    )
                )
                (when (ß c == nil || !c.isPrimitive())
                    (§ return (ß \O))
                )
                (when (ß c == long.class)
                    (§ return (ß \L))
                )
                (when (ß c == double.class)
                    (§ return (ß \D))
                )
                (throw (ß new IllegalArgumentException("Only long and double primitives are supported")))
            )
        )

        (§ defn #_"String" primInterface [#_"IPersistentVector" arglist]
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (loop-when-recur [(ß int i = 0)] (ß i < arglist.count()) [(ß i++)]
                    (ß sb.append(classChar(tagOf(arglist.nth(i)))))
                )
                (ß sb.append(classChar(tagOf(arglist))))
                (let [#_"String" ret (ß sb.toString())]
                    (let [#_"boolean" prim (ß ret.contains("L") || ret.contains("D"))]
                        (when (ß prim && arglist.count() > 4)
                            (throw (ß new IllegalArgumentException("fns taking primitives support only 4 or fewer args")))
                        )
                        (when prim
                            (§ return (ß "cloiure.lang.IFn$" + ret))
                        )
                        nil
                    )
                )
            )
        )

        (§ defn #_"FnMethod" parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Object" rettag]
            ;; ([args] body...)
            (let [#_"IPersistentVector" parms (ß (IPersistentVector) RT.first(form))]
                (let [#_"ISeq" body (ß RT.next(form))]
                    (try
                        (let [#_"FnMethod" method (ß new FnMethod(objx, (ObjMethod) METHOD.deref()))]
                            (ß method.line = lineDeref())
                            (ß method.column = columnDeref())
                            ;; register as the current method and set up a new env frame
                            (let [#_"PathNode" pnode (ß  (PathNode) CLEAR_PATH.get())]
                                (when (ß pnode == nil)
                                    (ß pnode = new PathNode(PATHTYPE.PATH, nil))
                                )
                                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                    #_map METHOD, method,
                                    #_map LOCAL_ENV, LOCAL_ENV.deref(),
                                    #_map LOOP_LOCALS, nil,
                                    #_map NEXT_LOCAL_NUM, 0,
                                    #_map CLEAR_PATH, pnode,
                                    #_map CLEAR_ROOT, pnode,
                                    #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                                    #_map METHOD_RETURN_CONTEXT, RT.T
                                )))

                                (ß method.prim = primInterface(parms))
                                (when (ß method.prim != nil)
                                    (ß method.prim = method.prim.replace(\., \/))
                                )

                                (when (ß rettag instanceof String)
                                    (ß rettag = Symbol.intern(nil, (String) rettag))
                                )
                                (when (ß !(rettag instanceof Symbol))
                                    (ß rettag = nil)
                                )
                                (when (ß rettag != nil)
                                    (let [#_"String" retstr (ß ((Symbol)rettag).getName())]
                                        (when (ß !(retstr.equals("long") || retstr.equals("double")))
                                            (ß rettag = nil)
                                        )
                                    )
                                )
                                (ß method.retClass = tagClass((tagOf(parms) != nil) ? tagOf(parms) :or rettag))
                                (if (ß method.retClass.isPrimitive())
                                    (do
                                        (when (ß !(method.retClass == double.class || method.retClass == long.class))
                                            (throw (ß new IllegalArgumentException("Only long and double primitives are supported")))
                                        )
                                    )
                                    (do
                                        (ß method.retClass = Object.class)
                                    )
                                )
                                ;; register 'this' as local 0
                                (if (ß objx.thisName != nil)
                                    (do
                                        (ß registerLocal(Symbol.intern(objx.thisName), nil, nil, false))
                                    )
                                    (do
                                        (ß getAndIncLocalNum())
                                    )
                                )
                                (let [#_"PSTATE" state (ß PSTATE.REQ)]
                                    (let [#_"PersistentVector" argLocals (ß PersistentVector.EMPTY)]
                                        (let [#_"ArrayList<Type>" argtypes (ß new ArrayList())]
                                            (let [#_"ArrayList<Class>" argclasses (ß new ArrayList())]
                                                (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                    (when (ß !(parms.nth(i) instanceof Symbol))
                                                        (throw (ß new IllegalArgumentException("fn params must be Symbols")))
                                                    )
                                                    (let [#_"Symbol" p (ß (Symbol) parms.nth(i))]
                                                        (when (ß p.getNamespace() != nil)
                                                            (throw (ß Util.runtimeException("Can't use qualified name as parameter: " + p)))
                                                        )
                                                        (if (ß p.equals(_AMP_))
                                                            (do
                                                                (if (ß state == PSTATE.REQ)
                                                                    (do
                                                                        (ß state = PSTATE.REST)
                                                                    )
                                                                    (do
                                                                        (throw (ß Util.runtimeException("Invalid parameter list")))
                                                                    )
                                                                )
                                                            )
                                                            (do
                                                                (let [#_"Class" pc (ß primClass(tagClass(tagOf(p))))]
                                                                    (when (ß pc.isPrimitive() && !(pc == double.class || pc == long.class))
                                                                        (throw (ß new IllegalArgumentException("Only long and double primitives are supported: " + p)))
                                                                    )

                                                                    (when (ß state == PSTATE.REST && tagOf(p) != nil)
                                                                        (throw (ß Util.runtimeException("& arg cannot have type hint")))
                                                                    )
                                                                    (when (ß state == PSTATE.REST && method.prim != nil)
                                                                        (throw (ß Util.runtimeException("fns taking primitives cannot be variadic")))
                                                                    )

                                                                    (when (ß state == PSTATE.REST)
                                                                        (ß pc = ISeq.class)
                                                                    )
                                                                    (ß argtypes.add(Type.getType(pc)))
                                                                    (ß argclasses.add(pc))
                                                                    (let [#_"LocalBinding" lb (ß pc.isPrimitive() ? registerLocal(p, nil, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), nil, true))]
                                                                        (ß argLocals = argLocals.cons(lb))
                                                                        (§ switch state
                                                                            (§ case REQ)
                                                                            (do
                                                                                (ß method.reqParms = method.reqParms.cons(lb))
                                                                                (§ break )
                                                                            )
                                                                            (§ case REST)
                                                                            (do
                                                                                (ß method.restParm = lb)
                                                                                (ß state = PSTATE.DONE)
                                                                                (§ break )
                                                                            )
                                                                            (§ default )
                                                                            (do
                                                                                (throw (ß Util.runtimeException("Unexpected parameter")))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (when (ß method.reqParms.count() > MAX_POSITIONAL_ARITY)
                                                    (throw (ß Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params")))
                                                )
                                                (ß LOOP_LOCALS.set(argLocals))
                                                (ß method.argLocals = argLocals)
                                                (ß method.argtypes = argtypes.toArray(new Type[argtypes.size()]))
                                                (ß method.argclasses = argclasses.toArray(new Class[argtypes.size()]))
                                                (when (ß method.prim != nil)
                                                    (loop-when-recur [(ß int i = 0)] (ß i < method.argclasses.length) [(ß i++)]
                                                        (when (ß method.argclasses[i] == long.class || method.argclasses[i] == double.class)
                                                            (ß getAndIncLocalNum())
                                                        )
                                                    )
                                                )
                                                (ß method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                                                method
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (cond (ß fn.canBeDirect)
                (do
                    (ß doEmitStatic(fn, cv))
                )
                (ß prim != nil)
                (do
                    (ß doEmitPrim(fn, cv))
                )
                :else
                (do
                    (ß doEmit(fn, cv))
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" doEmitStatic [this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (let [#_"Type" returnType (ß Type.getType(retClass))]
                (let [#_"Method" ms (ß new Method("invokeStatic", returnType, argtypes))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, ms, nil, EXCEPTION_TYPES, cv))]
                        (ß gen.visitCode())
                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                                (ß emitBody(objx, gen, retClass, body))

                                (let [#_"Label" end (ß gen.mark())]
                                    (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())

                            ;; generate the regular invoke, calling the static method
                            (let [#_"Method" m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                                ;; todo don't hardwire EXCEPTION_TYPES
                                (ß gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))
                                (ß gen.visitCode())
                                (loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                                    (ß gen.loadArg(i))
                                    (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                                    (when (ß !argclasses[i].isPrimitive())
                                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                        (ß gen.storeArg(i))
                                    )
                                )
                                (let [#_"Label" callLabel (ß gen.mark())]
                                    (ß gen.visitLineNumber(line, callLabel))
                                    (ß gen.invokeStatic(objx.objtype, ms))
                                    (ß gen.box(returnType))

                                    (ß gen.returnValue())
                                    (ß gen.endMethod())

                                    ;; generate primInvoke if prim
                                    (when (ß prim != nil)
                                        (when (ß retClass == double.class || retClass == long.class)
                                            (ß returnType = getReturnType())
                                        )
                                        (let [#_"else" returnType (ß OBJECT_TYPE)]
                                            (let [#_"Method" pm (ß new Method("invokePrim", returnType, argtypes))]
                                                ;; todo don't hardwire EXCEPTION_TYPES
                                                (ß gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, pm, nil, EXCEPTION_TYPES, cv))
                                                (ß gen.visitCode())
                                                (loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                                                    (ß gen.loadArg(i))
                                                    (when (ß !argclasses[i].isPrimitive())
                                                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                                        (ß gen.storeArg(i))
                                                    )
                                                )
                                                (ß gen.invokeStatic(objx.objtype, ms))

                                                (ß gen.returnValue())
                                                (ß gen.endMethod())
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" doEmitPrim [this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (§ let [#_"Type" returnType]
                (if (ß retClass == double.class || retClass == long.class)
                    (do
                        (ß returnType = getReturnType())
                    )
                    (do
                        (ß returnType = OBJECT_TYPE)
                    )
                )
                (let [#_"Method" ms (ß new Method("invokePrim", returnType, argtypes))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, ms, nil, EXCEPTION_TYPES, cv))]
                        (ß gen.visitCode())

                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                                (ß emitBody(objx, gen, retClass, body))

                                (let [#_"Label" end (ß gen.mark())]
                                    (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                    (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())

                            ;; generate the regular invoke, calling the prim method
                            (let [#_"Method" m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                                ;; todo don't hardwire EXCEPTION_TYPES
                                (ß gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))
                                (ß gen.visitCode())
                                (ß gen.loadThis())
                                (loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                                    (ß gen.loadArg(i))
                                    (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                                )
                                (ß gen.invokeInterface(Type.getType("L"+prim+";"), ms))
                                (ß gen.box(getReturnType()))

                                (ß gen.returnValue())
                                (ß gen.endMethod())
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" doEmit [this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))]
                    (ß gen.visitCode())

                    (let [#_"Label" loopLabel (ß gen.mark())]
                        (ß gen.visitLineNumber(line, loopLabel))
                        (try
                            (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                            (ß body.emit(C.RETURN, fn, gen))
                            (let [#_"Label" end (ß gen.mark())]
                                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                    (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                        (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )

                        (ß gen.returnValue())
                        (ß gen.endMethod())
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"PersistentVector" reqParms [this]
            reqParms
        )

        #_method
        (§ defn #_"LocalBinding" restParm [this]
            restParm
        )

        #_method
        (§ defn #_"boolean" isVariadic [this]
            (ß (restParm != nil))
        )

        #_method
        (§ defn #_"int" numParams [this]
            (ß reqParms.count() + (isVariadic() ? 1 :or 0))
        )

        #_method
        (§ defn #_"String" getMethodName [this]
            (ß isVariadic() ? "doInvoke" :or "invoke")
        )

        #_method
        (§ defn #_"Type" getReturnType [this]
            (when (ß prim != nil) ;; objx.isStatic
                (§ return (ß Type.getType(retClass)))
            )
            (ß OBJECT_TYPE)
        )

        #_method
        (§ defn #_"Type[]" getArgTypes [this]
            (when (ß isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
                (let [#_"Type[]" ret (ß new Type[MAX_POSITIONAL_ARITY + 1])]
                    (loop-when-recur [(ß int i = 0)] (ß i < MAX_POSITIONAL_ARITY + 1) [(ß i++)]
                        (ß ret[i] = OBJECT_TYPE)
                    )
                    (§ return ret)
                )
            )
            (ß ARG_TYPES[numParams()])
        )

        #_method
        (§ defn #_"void" emitClearLocals [this, #_"GeneratorAdapter" gen]
            nil
        )
    )

    #_abstract
    (class-ns ObjMethod
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        (§ field #_"ObjMethod" parent)
        ;; localbinding->localbinding
        (§ field #_"IPersistentMap" locals (ß nil))
        ;; num->localbinding
        (§ field #_"IPersistentMap" indexlocals (ß nil))
        (§ field #_"Expr" body (ß nil))
        (§ field #_"ObjExpr" objx)
        (§ field #_"PersistentVector" argLocals)
        (§ field #_"int" maxLocal (ß 0))
        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"boolean" usesThis (ß false))
        (§ field #_"PersistentHashSet" localsUsedInCatchFinally (ß PersistentHashSet.EMPTY))
        #_protected
        (§ field #_"IPersistentMap" methodMeta)

        #_method
        (§ defn #_"IPersistentMap" locals [this]
            locals
        )

        #_method
        (§ defn #_"Expr" body [this]
            body
        )

        #_method
        (§ defn #_"ObjExpr" objx [this]
            objx
        )

        #_method
        (§ defn #_"PersistentVector" argLocals [this]
            argLocals
        )

        #_method
        (§ defn #_"int" maxLocal [this]
            maxLocal
        )

        #_method
        (§ defn #_"int" line [this]
            line
        )

        #_method
        (§ defn #_"int" column [this]
            column
        )

        (§ constructor #_"ObjMethod" ObjMethod [#_"ObjExpr" objx, #_"ObjMethod" parent]
            (ß this.parent = parent)
            (ß this.objx = objx)
            this
        )

        (§ defn #_"void" emitBody [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" retClass, #_"Expr" body]
            (let [#_"MaybePrimitiveExpr" be (ß (MaybePrimitiveExpr) body)]
                (if (ß Util.isPrimitive(retClass) && be.canEmitPrimitive())
                    (do
                        (let [#_"Class" bc (ß maybePrimitiveType(be))]
                            (cond (ß bc == retClass)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                )
                                (ß retClass == long.class && bc == int.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(I2L))
                                )
                                (ß retClass == double.class && bc == float.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(F2D))
                                )
                                (ß retClass == int.class && bc == long.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                )
                                (ß retClass == float.class && bc == double.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(D2F))
                                )
                                :else
                                (do
                                    (throw (ß new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass())))
                                )
                            )
                        )
                    )
                    (do
                        (ß body.emit(C.RETURN, objx, gen))
                        (if (ß retClass == void.class)
                            (do
                                (ß gen.pop())
                            )
                            (do
                                (ß gen.unbox(Type.getType(retClass)))
                            )
                        )
                    )
                )
                nil
            )
        )

        (§ abstract int numParams())
        (§ abstract String getMethodName())
        (§ abstract Type getReturnType())
        (§ abstract Type[] getArgTypes())

        #_method
        (§ defn #_"void" emit [this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))]
                    (ß gen.visitCode())

                    (let [#_"Label" loopLabel (ß gen.mark())]
                        (ß gen.visitLineNumber(line, loopLabel))
                        (try
                            (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                            (ß body.emit(C.RETURN, fn, gen))
                            (let [#_"Label" end (ß gen.mark())]
                                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                    (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                        (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )

                        (ß gen.returnValue())
                        (ß gen.endMethod())
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"void" emitClearLocals [this, #_"GeneratorAdapter" gen]
            nil
        )

        #_method
        (§ defn #_"void" emitClearLocalsOld [this, #_"GeneratorAdapter" gen]
            (loop-when-recur [(ß int i = 0)] (ß i < argLocals.count()) [(ß i++)]
                (let [#_"LocalBinding" lb (ß (LocalBinding) argLocals.nth(i))]
                    (when (ß !localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == nil)
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.storeArg(lb.idx - 1))
                    )
                )
            )
            (loop-when-recur [(ß int i = numParams() + 1)] (ß i < maxLocal + 1) [(ß i++)]
                (when (ß !localsUsedInCatchFinally.contains(i))
                    (let [#_"LocalBinding" b (ß (LocalBinding) RT.get(indexlocals, i))]
                        (when (ß b == nil || maybePrimitiveType(b.init) == nil)
                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i))
                        )
                    )
                )
            )
            nil
        )

        #_method
        (§ defn #_"void" emitClearThis [this, #_"GeneratorAdapter" gen]
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (ß gen.visitVarInsn(Opcodes.ASTORE, 0))
            nil
        )
    )

    (class-ns LocalBinding
        (§ field #_"Symbol" sym)
        (§ field #_"Symbol" tag)
        (§ field #_"Expr" init)
        (§ field #_"int" idx)
        (§ field #_"String" name)
        (§ field #_"boolean" isArg)
        (§ field #_"PathNode" clearPathRoot)
        (§ field #_"boolean" canBeCleared (ß !RT.booleanCast(getCompilerOption(disableLocalsClearingKey))))
        (§ field #_"boolean" recurMistmatch (ß false))
        (§ field #_"boolean" used (ß false))

        (§ constructor #_"LocalBinding" LocalBinding [#_"int" num, #_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg, #_"PathNode" clearPathRoot]
            (when (ß maybePrimitiveType(init) != nil && tag != nil)
                (throw (ß new UnsupportedOperationException("Can't type hint a local with a primitive initializer")))
            )
            (ß this.idx = num)
            (ß this.sym = sym)
            (ß this.tag = tag)
            (ß this.init = init)
            (ß this.isArg = isArg)
            (ß this.clearPathRoot = clearPathRoot)
            (ß name = munge(sym.name))
            this
        )

        (§ field #_"Boolean" hjc)

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (when (ß hjc == nil)
                (if (ß init != nil && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                    (do
                        (ß hjc =  false)
                    )
                    (do
                        (ß hjc = (tag != nil || (init != nil && init.hasJavaClass())))
                    )
                )
            )
            hjc
        )

        (§ field #_"Class" jc)

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or init.getJavaClass())
            )
            jc
        )

        #_method
        (§ defn #_"Class" getPrimitiveType [this]
            (ß maybePrimitiveType(init))
        )
    )

    (class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
        (§ field #_"LocalBinding" b)
        (§ field #_"Symbol" tag)

        (§ field #_"PathNode" clearPath)
        (§ field #_"PathNode" clearRoot)
        (§ field #_"boolean" shouldClear (ß false))

        (§ constructor #_"LocalBindingExpr" LocalBindingExpr [#_"LocalBinding" b, #_"Symbol" tag]
            (when (ß b.getPrimitiveType() != nil && tag != nil)
                (throw (ß new UnsupportedOperationException("Can't type hint a primitive local")))
            )
            (ß this.b = b)
            (ß this.tag = tag)

            (ß this.clearPath = (PathNode)CLEAR_PATH.get())
            (ß this.clearRoot = (PathNode)CLEAR_ROOT.get())
            (let [#_"IPersistentCollection" sites (ß (IPersistentCollection) RT.get(CLEAR_SITES.get(), b))]
                (ß b.used = true)

                (when (ß b.idx > 0)
                    (when (ß sites != nil)
                        (loop-when-recur [(ß ISeq s = sites.seq())] (ß s != nil) [(ß s = s.next())]
                            (let [#_"LocalBindingExpr" o (ß (LocalBindingExpr) s.first())]
                                (let [#_"PathNode" common (ß commonPath(clearPath, o.clearPath))]
                                    (when (ß common != nil && common.type == PATHTYPE.PATH)
                                        (ß o.shouldClear = false)
                                    )
                                )
                            )
                        )
                    )

                    (when (ß clearRoot == b.clearPathRoot)
                        (ß this.shouldClear = true)
                        (ß sites = RT.conj(sites, this))
                        (ß CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites)))
                    )
                )
                this
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval locals")))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß (b.getPrimitiveType() != nil))
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß objx.emitUnboxedLocal(gen, b))
            nil
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (when (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, shouldClear))
            )
            nil
        )

        #_method
        (§ defn #_"Object" evalAssign [this, #_"Expr" val]
            (throw (ß new UnsupportedOperationException("Can't eval locals")))
        )

        #_method
        (§ defn #_"void" emitAssign [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
            (ß objx.emitAssignLocal(gen, b, val))
            (when (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, false))
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (tag != nil || b.hasJavaClass()))
        )

        (§ field #_"Class" jc)

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (when (ß jc == nil)
                (if (ß tag != nil)
                    (do
                        (ß jc = HostExpr.tagToClass(tag))
                    )
                    (do
                        (ß jc = b.getJavaClass())
                    )
                )
            )
            jc
        )
    )

    (class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"PersistentVector" exprs)

        #_method
        (§ defn #_"PersistentVector" exprs [this]
            exprs
        )

        (§ constructor #_"BodyExpr" BodyExpr [#_"PersistentVector" exprs]
            (ß this.exprs = exprs)
            this
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frms]
                (let [#_"ISeq" forms (ß (ISeq) frms)]
                    (when (ß Util.equals(RT.first(forms), DO))
                        (ß forms = RT.next(forms))
                    )
                    (let [#_"PersistentVector" exprs (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß )] (ß forms != nil) [(ß forms = forms.next())]
                            (let [#_"Expr" e (ß (context != C.EVAL && (context == C.STATEMENT || forms.next() != nil)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first()))]
                                (ß exprs = exprs.cons(e))
                            )
                        )
                        (when (ß exprs.count() == 0)
                            (ß exprs = exprs.cons(NIL_EXPR))
                        )
                        (ß new BodyExpr(exprs))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (let [#_"Object" ret nil]
                (doseq [#_"Object" o exprs]
                    (let [#_"Expr" e (ß (Expr) o)]
                        (ß ret = e.eval())
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive()))
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(ß int i = 0)] (ß i < exprs.count() - 1) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) exprs.nth(i))]
                    (ß e.emit(C.STATEMENT, objx, gen))
                )
            )
            (let [#_"MaybePrimitiveExpr" last (ß (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1))]
                (ß last.emitUnboxed(context, objx, gen))
                nil
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(ß int i = 0)] (ß i < exprs.count() - 1) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) exprs.nth(i))]
                    (ß e.emit(C.STATEMENT, objx, gen))
                )
            )
            (let [#_"Expr" last (ß (Expr) exprs.nth(exprs.count() - 1))]
                (ß last.emit(context, objx, gen))
                nil
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß lastExpr().hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß lastExpr().getJavaClass())
        )

        #_method
        (§ defn- #_"Expr" lastExpr [this]
            (ß (Expr) exprs.nth(exprs.count() - 1))
        )
    )

    (class-ns BindingInit
        (§ field #_"LocalBinding" binding)
        (§ field #_"Expr" init)

        #_method
        (§ defn #_"LocalBinding" binding [this]
            binding
        )

        #_method
        (§ defn #_"Expr" init [this]
            init
        )

        (§ constructor #_"BindingInit" BindingInit [#_"LocalBinding" binding, #_"Expr" init]
            (ß this.binding = binding)
            (ß this.init = init)
            this
        )
    )

    (class-ns LetFnExpr (§ implements Expr)
        (§ field #_"PersistentVector" bindingInits)
        (§ field #_"Expr" body)

        (§ constructor #_"LetFnExpr" LetFnExpr [#_"PersistentVector" bindingInits, #_"Expr" body]
            (ß this.bindingInits = bindingInits)
            (ß this.body = body)
            this
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (letfns* [var (fn [args] body) ...] body...)
                    (when (ß !(RT.second(form) instanceof IPersistentVector))
                        (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                    )

                    (let [#_"IPersistentVector" bindings (ß (IPersistentVector) RT.second(form))]
                        (when (ß (bindings.count() % 2) != 0)
                            (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                        )

                        (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                            (when (ß context == C.EVAL)
                                (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                            )

                            (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                (try
                                    (ß Var.pushThreadBindings(dynamicBindings))

                                    ;; pre-seed env (like Lisp labels)
                                    (let [#_"PersistentVector" lbs (ß PersistentVector.EMPTY)]
                                        (loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                                            (when (ß !(bindings.nth(i) instanceof Symbol))
                                                (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))))
                                            )
                                            (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                (when (ß sym.getNamespace() != nil)
                                                    (throw (ß Util.runtimeException("Can't let qualified name: " + sym)))
                                                )
                                                (let [#_"LocalBinding" lb (ß registerLocal(sym, tagOf(sym), nil, false))]
                                                    (ß lb.canBeCleared = false)
                                                    (ß lbs = lbs.cons(lb))
                                                )
                                            )
                                        )
                                        (let [#_"PersistentVector" bindingInits (ß PersistentVector.EMPTY)]
                                            (loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                                                (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                    (let [#_"Expr" init (ß analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))]
                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.nth(i / 2))]
                                                            (ß lb.init = init)
                                                            (let [#_"BindingInit" bi (ß new BindingInit(lb, init))]
                                                                (ß bindingInits = bindingInits.cons(bi))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (ß new LetFnExpr(bindingInits, (new BodyExpr.Parser()).parse(context, body)))
                                        )
                                    )
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval letfns")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                )
            )

            (let [#_"IPersistentSet" lbset (ß PersistentHashSet.EMPTY)]
                (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (ß lbset = (IPersistentSet) lbset.cons(bi.binding))
                        (ß bi.init.emit(C.EXPRESSION, objx, gen))
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                    )
                )

                (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (let [#_"ObjExpr" fe (ß (ObjExpr) bi.init)]
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx))
                            (ß fe.emitLetFnInits(gen, objx, lbset))
                        )
                    )
                )

                (let [#_"Label" loopLabel (ß gen.mark())]
                    (ß body.emit(context, objx, gen))

                    (let [#_"Label" end (ß gen.mark())]
                        (loop-when-recur [(ß ISeq bis = bindingInits.seq())] (ß bis != nil) [(ß bis = bis.next())]
                            (let [#_"BindingInit" bi (ß (BindingInit) bis.first())]
                                (let [#_"String" lname (ß bi.binding.name)]
                                    (when (ß lname.endsWith("__auto__"))
                                        (ß lname += RT.nextID())
                                    )
                                    (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                                        (if (ß primc != nil)
                                            (do
                                                (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, loopLabel, end, bi.binding.idx))
                                            )
                                            (do
                                                (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, loopLabel, end, bi.binding.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß body.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß body.getJavaClass())
        )
    )

    (class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"PersistentVector" bindingInits)
        (§ field #_"Expr" body)
        (§ field #_"boolean" isLoop)

        (§ constructor #_"LetExpr" LetExpr [#_"PersistentVector" bindingInits, #_"Expr" body, #_"boolean" isLoop]
            (ß this.bindingInits = bindingInits)
            (ß this.body = body)
            (ß this.isLoop = isLoop)
            this
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (let [var val var2 val2 ...] body...)
                    (let [#_"boolean" isLoop (ß RT.first(form).equals(LOOP))]
                        (when (ß !(RT.second(form) instanceof IPersistentVector))
                            (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                        )

                        (let [#_"IPersistentVector" bindings (ß (IPersistentVector) RT.second(form))]
                            (when (ß (bindings.count() % 2) != 0)
                                (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                            )

                            (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                                (when (ß context == C.EVAL || (context == C.EXPRESSION && isLoop))
                                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                                )

                                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                    (let [#_"IPersistentMap" backupMethodLocals (ß method.locals)]
                                        (let [#_"IPersistentMap" backupMethodIndexLocals (ß method.indexlocals)]
                                            (let [#_"IPersistentVector" recurMismatches (ß PersistentVector.EMPTY)]
                                                (loop-when-recur [(ß int i = 0)] (ß i < bindings.count() / 2) [(ß i++)]
                                                    (ß recurMismatches = recurMismatches.cons(RT.F))
                                                )

                                                ;; may repeat once for each binding with a mismatch, return breaks
                                                (while true
                                                    (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                                        (ß method.locals = backupMethodLocals)
                                                        (ß method.indexlocals = backupMethodIndexLocals)

                                                        (let [#_"PathNode" looproot (ß new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))]
                                                            (let [#_"PathNode" clearroot (ß new PathNode(PATHTYPE.PATH, looproot))]
                                                                (let [#_"PathNode" clearpath (ß new PathNode(PATHTYPE.PATH, looproot))]
                                                                    (when isLoop
                                                                        (ß dynamicBindings = dynamicBindings.assoc(LOOP_LOCALS, nil))
                                                                    )

                                                                    (try
                                                                        (ß Var.pushThreadBindings(dynamicBindings))

                                                                        (let [#_"PersistentVector" bindingInits (ß PersistentVector.EMPTY)]
                                                                            (let [#_"PersistentVector" loopLocals (ß PersistentVector.EMPTY)]
                                                                                (loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                                                                                    (when (ß !(bindings.nth(i) instanceof Symbol))
                                                                                        (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))))
                                                                                    )
                                                                                    (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                                                        (when (ß sym.getNamespace() != nil)
                                                                                            (throw (ß Util.runtimeException("Can't let qualified name: " + sym)))
                                                                                        )
                                                                                        (let [#_"Expr" init (ß analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))]
                                                                                            (when isLoop
                                                                                                (cond (ß recurMismatches != nil && RT.booleanCast(recurMismatches.nth(i / 2)))
                                                                                                    (do
                                                                                                        (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "box", RT.vector(init), false))
                                                                                                        (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                                                                            (ß RT.errPrintWriter().println("Auto-boxing loop arg: " + sym))
                                                                                                        )
                                                                                                    )
                                                                                                    (ß maybePrimitiveType(init) == int.class)
                                                                                                    (do
                                                                                                        (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "longCast", RT.vector(init), false))
                                                                                                    )
                                                                                                    (ß maybePrimitiveType(init) == float.class)
                                                                                                    (do
                                                                                                        (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "doubleCast", RT.vector(init), false))
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                            ;; sequential enhancement of env (like Lisp let*)
                                                                                            (try
                                                                                                (when isLoop
                                                                                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, nil)))
                                                                                                )
                                                                                                (let [#_"LocalBinding" lb (ß registerLocal(sym, tagOf(sym), init, false))]
                                                                                                    (let [#_"BindingInit" bi (ß new BindingInit(lb, init))]
                                                                                                        (ß bindingInits = bindingInits.cons(bi))
                                                                                                        (when isLoop
                                                                                                            (ß loopLocals = loopLocals.cons(lb))
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                                (finally
                                                                                                    (when isLoop
                                                                                                        (ß Var.popThreadBindings())
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when isLoop
                                                                                    (ß LOOP_LOCALS.set(loopLocals))
                                                                                )
                                                                                (§ let [#_"Expr" bodyExpr]
                                                                                    (let [#_"boolean" moreMismatches false]
                                                                                        (try
                                                                                            (when isLoop
                                                                                                (let [#_"Object" methodReturnContext (ß (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil)]
                                                                                                    (ß Var.pushThreadBindings(RT.map(
                                                                                                        #_map CLEAR_PATH, clearpath,
                                                                                                        #_map CLEAR_ROOT, clearroot,
                                                                                                        #_map NO_RECUR, nil,
                                                                                                        #_map METHOD_RETURN_CONTEXT, methodReturnContext
                                                                                                    )))
                                                                                                )
                                                                                            )
                                                                                            (ß bodyExpr = (new BodyExpr.Parser()).parse(isLoop ? C.RETURN :or context, body))
                                                                                            (finally
                                                                                                (when isLoop
                                                                                                    (ß Var.popThreadBindings())
                                                                                                    (loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                                                                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                                                                                                            (when (ß lb.recurMistmatch)
                                                                                                                (ß recurMismatches = (IPersistentVector)recurMismatches.assoc(i, RT.T))
                                                                                                                (ß moreMismatches = true)
                                                                                                            )
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (when (ß !moreMismatches)
                                                                                            (§ return (ß new LetExpr(bindingInits, bodyExpr, isLoop)))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (finally
                                                                            (ß Var.popThreadBindings())
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval let/loop")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, false))
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, true))
            nil
        )

        #_method
        (§ defn #_"void" doEmit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
            (let [(ß HashMap<BindingInit, Label> bindingLabels = new HashMap())]
                (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                            (if (ß primc != nil)
                                (do
                                    (ß ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen))
                                    (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx))
                                )
                                (do
                                    (ß bi.init.emit(C.EXPRESSION, objx, gen))
                                    (if (ß !bi.binding.used && bi.binding.canBeCleared)
                                        (do
                                            (ß gen.pop())
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                                        )
                                    )
                                )
                            )
                            (ß bindingLabels.put(bi, gen.mark()))
                        )
                    )
                )
                (let [#_"Label" loopLabel (ß gen.mark())]
                    (if isLoop
                        (do
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel)))
                                (if emitUnboxed
                                    (do
                                        (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                                    )
                                    (do
                                        (ß body.emit(context, objx, gen))
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )
                        )
                        (do
                            (if emitUnboxed
                                (do
                                    (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                                )
                                (do
                                    (ß body.emit(context, objx, gen))
                                )
                            )
                        )
                    )
                    (let [#_"Label" end (ß gen.mark())]
                        (loop-when-recur [(ß ISeq bis = bindingInits.seq())] (ß bis != nil) [(ß bis = bis.next())]
                            (let [#_"BindingInit" bi (ß (BindingInit) bis.first())]
                                (let [#_"String" lname (ß bi.binding.name)]
                                    (when (ß lname.endsWith("__auto__"))
                                        (ß lname += RT.nextID())
                                    )
                                    (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                                        (if (ß primc != nil)
                                            (do
                                                (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, bindingLabels.get(bi), end, bi.binding.idx))
                                            )
                                            (do
                                                (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, bindingLabels.get(bi), end, bi.binding.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß body.hasJavaClass())
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß body.getJavaClass())
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive()))
        )
    )

    (class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"IPersistentVector" args)
        (§ field #_"IPersistentVector" loopLocals)

        (§ field #_"int" line)
        (§ field #_"int" column)
        (§ field #_"String" source)

        (§ constructor #_"RecurExpr" RecurExpr [#_"IPersistentVector" loopLocals, #_"IPersistentVector" args, #_"int" line, #_"int" column, #_"String" source]
            (ß this.loopLocals = loopLocals)
            (ß this.args = args)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.source = source)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval recur")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (let [#_"Label" loopLabel (ß (Label) LOOP_LABEL.deref())]
                (when (ß loopLabel == nil)
                    (throw (ß new IllegalStateException()))
                )
                (loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                        (let [#_"Expr" arg (ß (Expr) args.nth(i))]
                            (if (ß lb.getPrimitiveType() != nil)
                                (do
                                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                        (let [#_"Class" pc (ß maybePrimitiveType(arg))]
                                            (cond (ß pc == primc)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                )
                                                (ß primc == long.class && pc == int.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(I2L))
                                                )
                                                (ß primc == double.class && pc == float.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(F2D))
                                                )
                                                (ß primc == int.class && pc == long.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                                )
                                                (ß primc == float.class && pc == double.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(D2F))
                                                )
                                                :else
                                                (do
                                                    (throw (ß new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName())))
                                                )
                                            )
                                        )
                                    )
                                )
                                (do
                                    (ß arg.emit(C.EXPRESSION, objx, gen))
                                )
                            )
                        )
                    )
                )

                (loop-when-recur [(ß int i = loopLocals.count() - 1)] (ß i >= 0) [(ß i--)]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (if (ß lb.isArg)
                                (do
                                    (ß gen.storeArg(lb.idx - (objx.canBeDirect ? 0 :or 1)))
                                )
                                (do
                                    (if (ß primc != nil)
                                        (do
                                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx))
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (ß gen.goTo(loopLabel))
                nil
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            true
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            (ß RECUR_CLASS)
        )

        (class-ns Parser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"int" line (ß lineDeref())]
                    (let [#_"int" column (ß columnDeref())]
                        (let [#_"String" source (ß (String) SOURCE.deref())]
                            (let [#_"ISeq" form (ß (ISeq) frm)]
                                (let [#_"IPersistentVector" loopLocals (ß (IPersistentVector) LOOP_LOCALS.deref())]
                                    (when (ß context != C.RETURN || loopLocals == nil)
                                        (throw (ß new UnsupportedOperationException("Can only recur from tail position")))
                                    )
                                    (when (ß NO_RECUR.deref() != nil)
                                        (throw (ß new UnsupportedOperationException("Cannot recur across try")))
                                    )
                                    (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                        (loop-when-recur [(ß ISeq s = RT.seq(form.next()))] (ß s != nil) [(ß s = s.next())]
                                            (ß args = args.cons(analyze(C.EXPRESSION, s.first())))
                                        )
                                        (when (ß args.count() != loopLocals.count())
                                            (throw (ß new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count()))))
                                        )
                                        (loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                                            (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                                                (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                    (when (ß primc != nil)
                                                        (let [#_"boolean" mismatch false]
                                                            (let [#_"Class" pc (ß maybePrimitiveType((Expr) args.nth(i)))]
                                                                (cond (ß primc == long.class)
                                                                    (do
                                                                        (when (ß !(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class))
                                                                            (ß mismatch = true)
                                                                        )
                                                                    )
                                                                    (ß primc == double.class)
                                                                    (do
                                                                        (when (ß !(pc == double.class || pc == float.class))
                                                                            (ß mismatch = true)
                                                                        )
                                                                    )
                                                                )
                                                                (when mismatch
                                                                    (ß lb.recurMistmatch = true)
                                                                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                                        (ß RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + ((pc != nil) ? pc.getName() :or "Object") + ", needed: " + primc.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (ß new RecurExpr(loopLocals, args, line, column, source))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            true
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß emit(context, objx, gen))
            nil
        )
    )

    (§ defn- #_"LocalBinding" registerLocal [#_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg]
        (let [#_"int" num (ß getAndIncLocalNum())]
            (let [#_"LocalBinding" b (ß new LocalBinding(num, sym, tag, init, isArg, clearPathRoot()))]
                (let [#_"IPersistentMap" localsMap (ß (IPersistentMap) LOCAL_ENV.deref())]
                    (ß LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b)))
                    (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                        (ß method.locals = (IPersistentMap) RT.assoc(method.locals, b, b))
                        (ß method.indexlocals = (IPersistentMap) RT.assoc(method.indexlocals, num, b))
                        b
                    )
                )
            )
        )
    )

    (§ defn- #_"int" getAndIncLocalNum []
        (let [#_"int" num (ß ((Number) NEXT_LOCAL_NUM.deref()).intValue())]
            (let [#_"ObjMethod" m (ß (ObjMethod) METHOD.deref())]
                (when (ß num > m.maxLocal)
                    (ß m.maxLocal = num)
                )
                (ß NEXT_LOCAL_NUM.set(num + 1))
                num
            )
        )
    )

    (§ defn #_"Expr" analyze [#_"C" context, #_"Object" form]
        (ß analyze(context, form, nil))
    )

    (§ defn- #_"Expr" analyze [#_"C" context, #_"Object" form, #_"String" name]
        ;; todo symbol macro expansion?
        (try
            (when (ß form instanceof LazySeq)
                (let [#_"Object" mform form]
                    (ß form = RT.seq(form))
                    (when (ß form == nil)
                        (ß form = PersistentList.EMPTY)
                    )
                    (ß form = ((IObj)form).withMeta(RT.meta(mform)))
                )
            )
            (cond (ß form == nil)
                (do
                    (§ return (ß NIL_EXPR))
                )
                (ß form == Boolean.TRUE)
                (do
                    (§ return (ß TRUE_EXPR))
                )
                (ß form == Boolean.FALSE)
                (do
                    (§ return (ß FALSE_EXPR))
                )
            )
            (let [#_"Class" fclass (ß form.getClass())]
                (cond (ß fclass == Symbol.class)
                    (do
                        (§ return (ß analyzeSymbol((Symbol) form)))
                    )
                    (ß fclass == Keyword.class)
                    (do
                        (§ return (ß registerKeyword((Keyword) form)))
                    )
                    (ß form instanceof Number)
                    (do
                        (§ return (ß NumberExpr.parse((Number) form)))
                    )
                    (ß fclass == String.class)
                    (do
                        (§ return (ß new StringExpr(((String) form).intern())))
                    )
                    (ß form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0)
                    (do
                        (let [#_"Expr" ret (ß new EmptyExpr(form))]
                            (when (ß RT.meta(form) != nil)
                                (ß ret = new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            (§ return ret)
                        )
                    )
                    (ß form instanceof ISeq)
                    (do
                        (§ return (ß analyzeSeq(context, (ISeq) form, name)))
                    )
                    (ß form instanceof IPersistentVector)
                    (do
                        (§ return (ß VectorExpr.parse(context, (IPersistentVector) form)))
                    )
                    (ß form instanceof IRecord)
                    (do
                        (§ return (ß new ConstantExpr(form)))
                    )
                    (ß form instanceof IType)
                    (do
                        (§ return (ß new ConstantExpr(form)))
                    )
                    (ß form instanceof IPersistentMap)
                    (do
                        (§ return (ß MapExpr.parse(context, (IPersistentMap) form)))
                    )
                    (ß form instanceof IPersistentSet)
                    (do
                        (§ return (ß SetExpr.parse(context, (IPersistentSet) form)))
                    )
                )

                (ß new ConstantExpr(form))
            )
            (catch Throwable e
                (if (ß !(e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                    )
                    (do
                        (throw (ß (CompilerException) e))
                    )
                )
            )
        )
    )

    (class-ns CompilerException (§ extends RuntimeException)
        (§ field #_"String" source)

        (§ field #_"int" line)

        (§ constructor #_"CompilerException" CompilerException [#_"String" source, #_"int" line, #_"int" column, #_"Throwable" cause]
            (§ super(errorMsg(source, line, column, cause.toString()), cause))
            (ß this.source = source)
            (ß this.line = line)
            this
        )

        #_method
        (§ defn #_"String" toString [this]
            (ß getMessage())
        )
    )

    (§ defn #_"Var" isMacro [#_"Object" op]
        ;; no local macros for now
        (when (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (when (ß op instanceof Symbol || op instanceof Var)
            (let [#_"Var" v (ß (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false))]
                (when (ß v != nil && v.isMacro())
                    (when (ß v.ns != currentNS() && !v.isPublic())
                        (throw (ß new IllegalStateException("var: " + v + " is not public")))
                    )
                    (§ return v)
                )
            )
        )
        nil
    )

    (§ defn #_"IFn" isInline [#_"Object" op, #_"int" arity]
        ;; no local inlines for now
        (when (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (when (ß op instanceof Symbol || op instanceof Var)
            (let [#_"Var" v (ß (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false))]
                (when (ß v != nil)
                    (when (ß v.ns != currentNS() && !v.isPublic())
                        (throw (ß new IllegalStateException("var: " + v + " is not public")))
                    )
                    (let [#_"IFn" ret (ß (IFn) RT.get(v.meta(), inlineKey))]
                        (when (ß ret != nil)
                            (let [#_"IFn" arityPred (ß (IFn) RT.get(v.meta(), inlineAritiesKey))]
                                (when (ß arityPred == nil || RT.booleanCast(arityPred.invoke(arity)))
                                    (§ return ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"boolean" namesStaticMember [#_"Symbol" sym]
        (ß (sym.ns != nil && namespaceFor(sym) == nil))
    )

    (§ defn #_"Object" preserveTag [#_"ISeq" src, #_"Object" dst]
        (let [#_"Symbol" tag (ß tagOf(src))]
            (when (ß tag != nil && dst instanceof IObj)
                (let [#_"IPersistentMap" meta (ß RT.meta(dst))]
                    (§ return (ß ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))))
                )
            )
            dst
        )
    )

    #_volatile
    (§ def- #_"Var" MACRO_CHECK (ß nil))
    #_volatile
    (§ def- #_"boolean" MACRO_CHECK_LOADING (ß false))
    (§ def- #_"Object" MACRO_CHECK_LOCK (ß new Object()))

    (§ defn- #_"Var" ensureMacroCheck [] (§ throws ClassNotFoundException, IOException)
        (when (ß MACRO_CHECK == nil)
            (§ sync (ß MACRO_CHECK_LOCK)
                (when (ß MACRO_CHECK == nil)
                    (ß MACRO_CHECK_LOADING = true)
                    (ß RT.load("cloiure/spec/alpha"))
                    (ß RT.load("cloiure/core/specs/alpha"))
                    (ß MACRO_CHECK = Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check")))
                    (ß MACRO_CHECK_LOADING = false)
                )
            )
        )
        (ß MACRO_CHECK)
    )

    (§ defn #_"void" checkSpecs [#_"Var" v, #_"ISeq" form]
        (when (ß RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
            (try
                (ß ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next()))))
                (catch Exception e
                    (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                )
            )
        )
        nil
    )

    (§ defn #_"Object" macroexpand1 [#_"Object" x]
        (when (ß x instanceof ISeq)
            (let [#_"ISeq" form (ß (ISeq) x)]
                (let [#_"Object" op (ß RT.first(form))]
                    (when (ß isSpecial(op))
                        (§ return x)
                    )
                    ;; macro expansion
                    (let [#_"Var" v (ß isMacro(op))]
                        (if (ß v != nil)
                            (do
                                (ß checkSpecs(v, form))

                                (try
                                    (let [#_"ISeq" args (ß RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next())))]
                                        (§ return (ß v.applyTo(args)))
                                    )
                                    (catch ArityException e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß new ArityException(e.actual - 2, e.name)))
                                    )
                                )
                            )
                            (do
                                (when (ß op instanceof Symbol)
                                    (let [#_"Symbol" sym (ß (Symbol) op)]
                                        (let [#_"String" sname (ß sym.name)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß sym.name.charAt(0) == \.)
                                                (do
                                                    (when (ß RT.length(form) < 2)
                                                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (.member target ...)")))
                                                    )
                                                    (let [#_"Symbol" meth (ß Symbol.intern(sname.substring(1)))]
                                                        (let [#_"Object" target (ß RT.second(form))]
                                                            (when (ß HostExpr.maybeClass(target, false) != nil)
                                                                (ß target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS)))
                                                            )
                                                            (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))))
                                                        )
                                                    )
                                                )
                                                (ß namesStaticMember(sym))
                                                (do
                                                    (let [#_"Symbol" target (ß Symbol.intern(sym.ns))]
                                                        (let [#_"Class" c (ß HostExpr.maybeClass(target, false))]
                                                            (when (ß c != nil)
                                                                (let [#_"Symbol" meth (ß Symbol.intern(sym.name))]
                                                                    (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next()))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" idx (ß sname.lastIndexOf(\.))]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß idx == sname.length() - 1)
                                                            (§ return (ß RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn #_"Object" macroexpand [#_"Object" form]
        (let [#_"Object" exf (ß macroexpand1(form))]
            (when (ß exf != form)
                (§ return (ß macroexpand(exf)))
            )
            form
        )
    )

    (§ defn- #_"Expr" analyzeSeq [#_"C" context, #_"ISeq" form, #_"String" name]
        (let [#_"Object" line (ß lineDeref())]
            (let [#_"Object" column (ß columnDeref())]
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                    (ß line = RT.meta(form).valAt(RT.LINE_KEY))
                )
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                    (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
                )
                (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
                (try
                    (let [#_"Object" me (ß macroexpand1(form))]
                        (when (ß me != form)
                            (§ return (ß analyze(context, me, name)))
                        )

                        (let [#_"Object" op (ß RT.first(form))]
                            (when (ß op == nil)
                                (throw (ß new IllegalArgumentException("Can't call nil, form: " + form)))
                            )
                            (let [#_"IFn" inline (ß isInline(op, RT.count(RT.next(form))))]
                                (when (ß inline != nil)
                                    (§ return (ß analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))))
                                )
                                (§ let [#_"IParser" p]
                                    (cond (ß op.equals(FN))
                                        (do
                                            (ß FnExpr.parse(context, form, name))
                                        )
                                        (ß (p = (IParser) specials.valAt(op)) != nil)
                                        (do
                                            (ß p.parse(context, form))
                                        )
                                        :else
                                        (do
                                            (ß InvokeExpr.parse(context, form))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable e
                        (if (ß !(e instanceof CompilerException))
                            (do
                                (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                            )
                            (do
                                (throw (ß (CompilerException) e))
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn #_"String" errorMsg [#_"String" source, #_"int" line, #_"int" column, #_"String" s]
        (ß String.format("%s, compiling:(%s:%d:%d)", s, source, line, column))
    )

    (§ defn #_"Object" eval [#_"Object" form]
        (ß eval(form, true))
    )

    (§ defn #_"Object" eval [#_"Object" form, #_"boolean" freshLoader]
        (let [#_"boolean" createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader())))
                (ß createdLoader = true)
            )
            (try
                (let [#_"Object" line (ß lineDeref())]
                    (let [#_"Object" column (ß columnDeref())]
                        (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                            (ß line = RT.meta(form).valAt(RT.LINE_KEY))
                        )
                        (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                            (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
                        )
                        (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
                        (try
                            (ß form = macroexpand(form))
                            (cond (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                                (do
                                    (let [#_"ISeq" s (ß RT.next(form))]
                                        (loop-when-recur [(ß )] (ß RT.next(s) != nil) [(ß s = RT.next(s))]
                                            (ß eval(RT.first(s), false))
                                        )
                                        (ß eval(RT.first(s), false))
                                    )
                                )
                                (ß (form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def"))))
                                (do
                                    (let [#_"ObjExpr" fexpr (ß (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID()))]
                                        (let [#_"IFn" fn (ß (IFn) fexpr.eval())]
                                            (ß fn.invoke())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" expr (ß analyze(C.EVAL, form))]
                                        (ß expr.eval())
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
                (finally
                    (when createdLoader
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn- #_"int" registerConstant [#_"Object" o]
        (when (ß !CONSTANTS.isBound())
            (§ return -1)
        )
        (let [#_"PersistentVector" v (ß (PersistentVector) CONSTANTS.deref())]
            (let [(ß IdentityHashMap<Object, Integer> ids = (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref())]
                (let [#_"Integer" i (ß ids.get(o))]
                    (when (ß i != nil)
                        (§ return i)
                    )
                    (ß CONSTANTS.set(RT.conj(v, o)))
                    (ß ids.put(o, v.count()))
                    (ß v.count())
                )
            )
        )
    )

    (§ defn- #_"KeywordExpr" registerKeyword [#_"Keyword" keyword]
        (when (ß !KEYWORDS.isBound())
            (§ return (ß new KeywordExpr(keyword)))
        )

        (let [#_"IPersistentMap" keywordsMap (ß (IPersistentMap) KEYWORDS.deref())]
            (let [#_"Object" id (ß RT.get(keywordsMap, keyword))]
                (when (ß id == nil)
                    (ß KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword))))
                )
                (ß new KeywordExpr(keyword))
            )
        )
    )

    (§ defn- #_"int" registerKeywordCallsite [#_"Keyword" keyword]
        (when (ß !KEYWORD_CALLSITES.isBound())
            (throw (ß new IllegalAccessError("KEYWORD_CALLSITES is not bound")))
        )

        (let [#_"IPersistentVector" keywordCallsites (ß (IPersistentVector) KEYWORD_CALLSITES.deref())]
            (ß keywordCallsites = keywordCallsites.cons(keyword))
            (ß KEYWORD_CALLSITES.set(keywordCallsites))
            (ß keywordCallsites.count() - 1)
        )
    )

    (§ defn- #_"int" registerProtocolCallsite [#_"Var" v]
        (when (ß !PROTOCOL_CALLSITES.isBound())
            (throw (ß new IllegalAccessError("PROTOCOL_CALLSITES is not bound")))
        )

        (let [#_"IPersistentVector" protocolCallsites (ß (IPersistentVector) PROTOCOL_CALLSITES.deref())]
            (ß protocolCallsites = protocolCallsites.cons(v))
            (ß PROTOCOL_CALLSITES.set(protocolCallsites))
            (ß protocolCallsites.count() - 1)
        )
    )

    (§ defn- #_"void" registerVarCallsite [#_"Var" v]
        (when (ß !VAR_CALLSITES.isBound())
            (throw (ß new IllegalAccessError("VAR_CALLSITES is not bound")))
        )

        (let [#_"IPersistentCollection" varCallsites (ß (IPersistentCollection) VAR_CALLSITES.deref())]
            (ß varCallsites = varCallsites.cons(v))
            (ß VAR_CALLSITES.set(varCallsites))
            nil
        )
    )

    (§ defn #_"ISeq" fwdPath [#_"PathNode" p1]
        (let [#_"ISeq" ret nil]
            (loop-when-recur [(ß )] (ß p1 != nil) [(ß p1 = p1.parent)]
                (ß ret = RT.cons(p1, ret))
            )
            ret
        )
    )

    (§ defn #_"PathNode" commonPath [#_"PathNode" n1, #_"PathNode" n2]
        (let [#_"ISeq" xp (ß fwdPath(n1))]
            (let [#_"ISeq" yp (ß fwdPath(n2))]
                (when (ß RT.first(xp) != RT.first(yp))
                    (§ return nil)
                )
                (while (ß RT.second(xp) != nil && RT.second(xp) == RT.second(yp))
                    (ß xp = xp.next())
                    (ß yp = yp.next())
                )
                (ß (PathNode) RT.first(xp))
            )
        )
    )

    (§ defn #_"void" addAnnotation [#_"Object" visitor, #_"IPersistentMap" meta]
        (when (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta))
        )
        nil
    )

    (§ defn #_"void" addParameterAnnotation [#_"Object" visitor, #_"IPersistentMap" meta, #_"int" i]
        (when (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta, i))
        )
        nil
    )

    (§ defn- #_"Expr" analyzeSymbol [#_"Symbol" sym]
        (let [#_"Symbol" tag (ß tagOf(sym))]
            (cond (ß sym.ns == nil) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" b (ß referenceLocal(sym))]
                        (when (ß b != nil)
                            (§ return (ß new LocalBindingExpr(b, tag)))
                        )
                    )
                )
                (ß namespaceFor(sym) == nil)
                (do
                    (let [#_"Symbol" nsSym (ß Symbol.intern(sym.ns))]
                        (let [#_"Class" c (ß HostExpr.maybeClass(nsSym, false))]
                            (when (ß c != nil)
                                (when (ß Reflector.getField(c, sym.name, true) != nil)
                                    (§ return (ß new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)))
                                )
                                (throw (ß Util.runtimeException("Unable to find static field: " + sym.name + " in " + c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" o (ß resolve(sym))]
                (cond (ß o instanceof Var)
                    (do
                        (let [#_"Var" v (ß (Var) o)]
                            (when (ß isMacro(v) != nil)
                                (throw (ß Util.runtimeException("Can't take value of a macro: " + v)))
                            )
                            (when (ß RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
                                (§ return (ß analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))))
                            )
                            (ß registerVar(v))
                            (§ return (ß new VarExpr(v, tag)))
                        )
                    )
                    (ß o instanceof Class)
                    (do
                        (§ return (ß new ConstantExpr(o)))
                    )
                    (ß o instanceof Symbol)
                    (do
                        (§ return (ß new UnresolvedVarExpr((Symbol) o)))
                    )
                )

                (throw (ß Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")))
            )
        )
    )

    (§ defn #_"String" destubClassName [#_"String" className]
        ;; skip over prefix + '.' or '/'
        (when (ß className.startsWith(COMPILE_STUB_PREFIX))
            (§ return (ß className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        className
    )

    (§ defn #_"Type" getType [#_"Class" c]
        (let [#_"String" descriptor (ß Type.getType(c).getDescriptor())]
            (when (ß descriptor.startsWith("L"))
                (ß descriptor = "L" + destubClassName(descriptor.substring(1)))
            )
            (ß Type.getType(descriptor))
        )
    )

    (§ defn #_"Object" resolve [#_"Symbol" sym, #_"boolean" allowPrivate]
        (ß resolveIn(currentNS(), sym, allowPrivate))
    )

    (§ defn #_"Object" resolve [#_"Symbol" sym]
        (ß resolveIn(currentNS(), sym, false))
    )

    (§ defn #_"Namespace" namespaceFor [#_"Symbol" sym]
        (ß namespaceFor(currentNS(), sym))
    )

    (§ defn #_"Namespace" namespaceFor [#_"Namespace" inns, #_"Symbol" sym]
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" nsSym (ß Symbol.intern(sym.ns))]
            (let [#_"Namespace" ns (ß inns.lookupAlias(nsSym))]
                (when (ß ns == nil)
                    ;; ...otherwise check the Namespaces map.
                    (ß ns = Namespace.find(nsSym))
                )
                ns
            )
        )
    )

    (§ defn #_"Object" resolveIn [#_"Namespace" n, #_"Symbol" sym, #_"boolean" allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond (ß sym.ns != nil)
            (do
                (let [#_"Namespace" ns (ß namespaceFor(n, sym))]
                    (when (ß ns == nil)
                        (throw (ß Util.runtimeException("No such namespace: " + sym.ns)))
                    )

                    (let [#_"Var" v (ß ns.findInternedVar(Symbol.intern(sym.name)))]
                        (cond (ß v == nil)
                            (do
                                (throw (ß Util.runtimeException("No such var: " + sym)))
                            )
                            (ß v.ns != currentNS() && !v.isPublic() && !allowPrivate)
                            (do
                                (throw (ß new IllegalStateException("var: " + sym + " is not public")))
                            )
                        )
                        v
                    )
                )
            )
            (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
            (do
                (ß RT.classForName(sym.name))
            )
            (ß sym.equals(NS))
            (do
                (ß RT.NS_VAR)
            )
            (ß sym.equals(IN_NS))
            (do
                (ß RT.IN_NS_VAR)
            )
            :else
            (do
                (when (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                    (§ return (ß COMPILE_STUB_CLASS.get()))
                )
                (let [#_"Object" o (ß n.getMapping(sym))]
                    (when (ß o == nil)
                        (if (ß RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return sym)
                            )
                            (do
                                (throw (ß Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")))
                            )
                        )
                    )
                    o
                )
            )
        )
    )

    (§ defn #_"Object" maybeResolveIn [#_"Namespace" n, #_"Symbol" sym]
        ;; note - ns-qualified vars must already exist
        (cond (ß sym.ns != nil)
            (do
                (let [#_"Namespace" ns (ß namespaceFor(n, sym))]
                    (when (ß ns == nil)
                        (§ return nil)
                    )
                    (let [#_"Var" v (ß ns.findInternedVar(Symbol.intern(sym.name)))]
                        (when (ß v == nil)
                            (§ return nil)
                        )
                        v
                    )
                )
            )
            (ß sym.name.indexOf(\.) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == \[)
            (do
                (ß RT.classForName(sym.name))
            )
            (ß sym.equals(NS))
            (do
                (ß RT.NS_VAR)
            )
            (ß sym.equals(IN_NS))
            (do
                (ß RT.IN_NS_VAR)
            )
            :else
            (do
                (let [#_"Object" o (ß n.getMapping(sym))]
                    o
                )
            )
        )
    )

    (§ defn #_"Var" lookupVar [#_"Symbol" sym, #_"boolean" internNew, #_"boolean" registerMacro]
        (let [#_"Var" var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß sym.ns != nil)
                (do
                    (let [#_"Namespace" ns (ß namespaceFor(sym))]
                        (when (ß ns == nil)
                            (§ return nil)
                        )
                        (let [#_"Symbol" name (ß Symbol.intern(sym.name))]
                            (if (ß internNew && ns == currentNS())
                                (do
                                    (ß var = currentNS().intern(name))
                                )
                                (do
                                    (ß var = ns.findInternedVar(name))
                                )
                            )
                        )
                    )
                )
                (ß sym.equals(NS))
                (do
                    (ß var = RT.NS_VAR)
                )
                (ß sym.equals(IN_NS))
                (do
                    (ß var = RT.IN_NS_VAR)
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" o (ß currentNS().getMapping(sym))]
                        (cond (ß o == nil)
                            (do
                                ;; introduce a new var in the current ns
                                (when internNew
                                    (ß var = currentNS().intern(Symbol.intern(sym.name)))
                                )
                            )
                            (ß o instanceof Var)
                            (do
                                (ß var = (Var) o)
                            )
                            :else
                            (do
                                (throw (ß Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o)))
                            )
                        )
                    )
                )
            )
            (when (ß var != nil && (!var.isMacro() || registerMacro))
                (ß registerVar(var))
            )
            var
        )
    )

    (§ defn #_"Var" lookupVar [#_"Symbol" sym, #_"boolean" internNew]
        (ß lookupVar(sym, internNew, true))
    )

    (§ defn- #_"void" registerVar [#_"Var" var]
        (when (ß !VARS.isBound())
            (§ return nil)
        )
        (let [#_"IPersistentMap" varsMap (ß (IPersistentMap) VARS.deref())]
            (let [#_"Object" id (ß RT.get(varsMap, var))]
                (when (ß id == nil)
                    (ß VARS.set(RT.assoc(varsMap, var, registerConstant(var))))
                )
                nil
            )
        )
    )

    (§ defn #_"Namespace" currentNS []
        (ß (Namespace) RT.CURRENT_NS.deref())
    )

    (§ defn #_"void" closeOver [#_"LocalBinding" b, #_"ObjMethod" method]
        (when (ß b != nil && method != nil)
            (let [#_"LocalBinding" lb (ß (LocalBinding) RT.get(method.locals, b))]
                (if (ß lb == nil)
                    (do
                        (ß method.objx.closes = (IPersistentMap) RT.assoc(method.objx.closes, b, b))
                        (ß closeOver(b, method.parent))
                    )
                    (do
                        (when (ß lb.idx == 0)
                            (ß method.usesThis = true)
                        )
                        (when (ß IN_CATCH_FINALLY.deref() != nil)
                            (ß method.localsUsedInCatchFinally = (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"LocalBinding" referenceLocal [#_"Symbol" sym]
        (when (ß !LOCAL_ENV.isBound())
            (§ return nil)
        )
        (let [#_"LocalBinding" b (ß (LocalBinding) RT.get(LOCAL_ENV.deref(), sym))]
            (when (ß b != nil)
                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                    (when (ß b.idx == 0)
                        (ß method.usesThis = true)
                    )
                    (ß closeOver(b, method))
                )
            )
            b
        )
    )

    (§ defn- #_"Symbol" tagOf [#_"Object" o]
        (let [#_"Object" tag (ß RT.get(RT.meta(o), RT.TAG_KEY))]
            (cond (ß tag instanceof Symbol)
                (do
                    (§ return (ß (Symbol) tag))
                )
                (ß tag instanceof String)
                (do
                    (§ return (ß Symbol.intern(nil, (String) tag)))
                )
            )
            nil
        )
    )

    (§ defn #_"Object" loadFile [#_"String" file] (§ throws IOException)
        (let [#_"FileInputStream" f (ß new FileInputStream(file))]
            (try
                (ß load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName()))
                (finally
                    (ß f.close())
                )
            )
        )
    )

    (§ defn #_"Object" load [#_"Reader" rdr]
        (ß load(rdr, nil, "NO_SOURCE_FILE"))
    )

    (§ defn #_"void" consumeWhitespaces [#_"LineNumberingPushbackReader" pushbackReader]
        (let [#_"int" ch (ß LispReader.read1(pushbackReader))]
            (while (ß LispReader.isWhitespace(ch))
                (ß ch = LispReader.read1(pushbackReader))
            )
            (ß LispReader.unread(pushbackReader, ch))
            nil
        )
    )

    (§ def- #_"Object" OPTS_COND_ALLOWED (ß RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW)))

    (§ defn- #_"Object" readerOpts [#_"String" sourceName]
        (if (ß sourceName != nil && sourceName.endsWith(".clic"))
            (do
                (ß OPTS_COND_ALLOWED)
            )
            (do
                nil
            )
        )
    )

    (§ defn #_"Object" load [#_"Reader" rdr, #_"String" sourcePath, #_"String" sourceName]
        (let [(ß Object EOF = new Object())]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (ß (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))]
                    (ß consumeWhitespaces(pushbackReader))
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                        #_map LOADER, RT.makeClassLoader(),
                        #_map SOURCE_PATH, sourcePath,
                        #_map SOURCE, sourceName,
                        #_map METHOD, nil,
                        #_map LOCAL_ENV, nil,
                        #_map LOOP_LOCALS, nil,
                        #_map NEXT_LOCAL_NUM, 0,
                        #_map RT.READEVAL, RT.T,
                        #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                        #_map LINE_BEFORE, pushbackReader.getLineNumber(),
                        #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                        #_map LINE_AFTER, pushbackReader.getLineNumber(),
                        #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
                        #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                        #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                        #_map RT.DATA_READERS, RT.DATA_READERS.deref()
                    )))

                    (let [#_"Object" readerOpts (ß readerOpts(sourceName))]
                        (try
                            (loop-when-recur [(ß Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))] (ß r != EOF) [(ß r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))]
                                (ß consumeWhitespaces(pushbackReader))
                                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                                (ß ret = eval(r, false))
                                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
                            )
                            (catch (ß LispReader.ReaderException) e
                                (throw (ß new CompilerException(sourcePath, e.line, e.column, e.getCause())))
                            )
                            (catch Throwable e
                                (if (ß !(e instanceof CompilerException))
                                    (do
                                        (throw (ß new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e)))
                                    )
                                    (do
                                        (throw (ß (CompilerException) e))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                        ret
                    )
                )
            )
        )
    )

    (§ defn #_"void" writeClassFile [#_"String" internalName, #_"byte[]" bytecode] (§ throws IOException)
        (let [#_"String" genPath (ß (String) COMPILE_PATH.deref())]
            (when (ß genPath == nil)
                (throw (ß Util.runtimeException("*compile-path* not set")))
            )
            (let [#_"String[]" dirs (ß internalName.split("/"))]
                (let [#_"String" p genPath]
                    (loop-when-recur [(ß int i = 0)] (ß i < dirs.length - 1) [(ß i++)]
                        (ß p += File.separator + dirs[i])
                        (ß (new File(p)).mkdir())
                    )
                    (let [#_"String" path (ß genPath + File.separator + internalName + ".class")]
                        (let [#_"File" cf (ß new File(path))]
                            (ß cf.createNewFile())
                            (let [#_"FileOutputStream" cfs (ß new FileOutputStream(cf))]
                                (try
                                    (ß cfs.write(bytecode))
                                    (ß cfs.flush())
                                    (finally
                                        (ß cfs.close())
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" pushNS []
        (ß Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil)))
        nil
    )

    (§ defn #_"void" pushNSandLoader [#_"ClassLoader" loader]
        (ß Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T)))
        nil
    )

    (§ defn #_"ILookupThunk" getLookupThunk [#_"Object" target, #_"Keyword" k]
        nil
    )

    (§ defn #_"void" compile1 [#_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"Object" form]
        (let [#_"Object" line (ß lineDeref())]
            (let [#_"Object" column (ß columnDeref())]
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                    (ß line = RT.meta(form).valAt(RT.LINE_KEY))
                )
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                    (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
                )
                (ß Var.pushThreadBindings(RT.map(
                    #_map LINE, line, COLUMN, column,
                    #_map LOADER, RT.makeClassLoader()
                )))
                (try
                    (ß form = macroexpand(form))
                    (if (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                        (do
                            (loop-when-recur [(ß ISeq s = RT.next(form))] (ß s != nil) [(ß s = RT.next(s))]
                                (ß compile1(gen, objx, RT.first(s)))
                            )
                        )
                        (do
                            (let [#_"Expr" expr (ß analyze(C.EVAL, form))]
                                (ß objx.keywords = (IPersistentMap) KEYWORDS.deref())
                                (ß objx.vars = (IPersistentMap) VARS.deref())
                                (ß objx.constants = (PersistentVector) CONSTANTS.deref())
                                (ß expr.emit(C.EXPRESSION, objx, gen))
                                (ß expr.eval())
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
                nil
            )
        )
    )

    (§ defn #_"Object" compile [#_"Reader" rdr, #_"String" sourcePath, #_"String" sourceName] (§ throws IOException)
        (when (ß COMPILE_PATH.deref() == nil)
            (throw (ß Util.runtimeException("*compile-path* not set")))
        )

        (let [(ß Object EOF = new Object())]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (ß (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))]
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                        #_map SOURCE_PATH, sourcePath,
                        #_map SOURCE, sourceName,
                        #_map METHOD, nil,
                        #_map LOCAL_ENV, nil,
                        #_map LOOP_LOCALS, nil,
                        #_map NEXT_LOCAL_NUM, 0,
                        #_map RT.READEVAL, RT.T,
                        #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                        #_map LINE_BEFORE, pushbackReader.getLineNumber(),
                        #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                        #_map LINE_AFTER, pushbackReader.getLineNumber(),
                        #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
                        #_map CONSTANTS, PersistentVector.EMPTY,
                        #_map CONSTANT_IDS, new IdentityHashMap(),
                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                        #_map VARS, PersistentHashMap.EMPTY,
                        #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                        #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                        #_map RT.DATA_READERS, RT.DATA_READERS.deref()
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" objx (ß new ObjExpr(nil))]
                            (ß objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf(\.)) + RT.LOADER_SUFFIX)

                            (ß objx.objtype = Type.getObjectType(objx.internalName))
                            (let [#_"ClassWriter" cw (ß new ClassWriter(ClassWriter.COMPUTE_MAXS))]
                                (let [#_"ClassVisitor" cv cw]
                                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), nil, nil, cv))]
                                        (ß gen.visitCode())

                                        (let [#_"Object" readerOpts (ß readerOpts(sourceName))]
                                            (loop-when-recur [(ß Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))] (ß r != EOF) [(ß r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))]
                                                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                                                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                                                (ß compile1(gen, objx, r))
                                                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                                                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
                                            )
                                            ;; end of load
                                            (ß gen.returnValue())
                                            (ß gen.endMethod())

                                            ;; static fields for constants
                                            (loop-when-recur [(ß int i = 0)] (ß i < objx.constants.count()) [(ß i++)]
                                                (when (ß objx.usedConstants.contains(i))
                                                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [(ß int INITS_PER = 100)]
                                                (let [#_"int" numInits (ß  objx.constants.count() / INITS_PER)]
                                                    (when (ß objx.constants.count() % INITS_PER != 0)
                                                        (ß ++numInits)
                                                    )

                                                    (loop-when-recur [(ß int n = 0)] (ß n < numInits) [(ß n++)]
                                                        (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), nil, nil, cv))]
                                                            (ß clinitgen.visitCode())
                                                            (try
                                                                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                                                                (loop-when-recur [(ß int i = n * INITS_PER)] (ß i < objx.constants.count() && i < (n + 1) * INITS_PER) [(ß i++)]
                                                                    (when (ß objx.usedConstants.contains(i))
                                                                        (ß objx.emitValue(objx.constants.nth(i), clinitgen))
                                                                        (ß clinitgen.checkCast(objx.constantType(i)))
                                                                        (ß clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var.popThreadBindings())
                                                                )
                                                            )
                                                            (ß clinitgen.returnValue())
                                                            (ß clinitgen.endMethod())
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))]
                                                        (ß clinitgen.visitCode())
                                                        (let [#_"Label" startTry (ß clinitgen.newLabel())]
                                                            (let [#_"Label" endTry (ß clinitgen.newLabel())]
                                                                (let [#_"Label" end (ß clinitgen.newLabel())]
                                                                    (let [#_"Label" finallyLabel (ß clinitgen.newLabel())]
                                                                        (loop-when-recur [(ß int n = 0)] (ß n < numInits) [(ß n++)]
                                                                            (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()")))
                                                                        )

                                                                        (ß clinitgen.push(objx.internalName.replace(\/, \.)))
                                                                        (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                                                                        (ß clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()")))
                                                                        (ß clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (ß clinitgen.mark(startTry))
                                                                        (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()")))
                                                                        (ß clinitgen.mark(endTry))
                                                                        (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
                                                                        (ß clinitgen.goTo(end))

                                                                        (ß clinitgen.mark(finallyLabel))
                                                                        ;; exception should be on stack
                                                                        (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
                                                                        (ß clinitgen.throwException())
                                                                        (ß clinitgen.mark(end))
                                                                        (ß clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))

                                                                        ;; end of static init
                                                                        (ß clinitgen.returnValue())
                                                                        (ß clinitgen.endMethod())

                                                                        ;; end of class
                                                                        (ß cv.visitEnd())

                                                                        (ß writeClassFile(objx.internalName, cw.toByteArray()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (catch (ß LispReader.ReaderException) e
                            (throw (ß new CompilerException(sourcePath, e.line, e.column, e.getCause())))
                        )
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                    ret
                )
            )
        )
    )

    (class-ns NewInstanceExpr (§ extends ObjExpr)
        (§ field #_"IPersistentCollection" methods)

        (§ field #_"Map<IPersistentVector, java.lang.reflect.Method>" mmap)
        (§ field #_"Map<IPersistentVector, Set<Class>>" covariants)

        (§ constructor #_"NewInstanceExpr" NewInstanceExpr [#_"Object" tag]
            (§ super(tag))
            this
        )

        (class-ns DeftypeParser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" rform (ß (ISeq) frm)]
                    ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                    (ß rform = RT.next(rform))
                    (let [#_"String" tagname (ß ((Symbol) rform.first()).getName())]
                        (ß rform = rform.next())
                        (let [#_"Symbol" classname (ß (Symbol) rform.first())]
                            (ß rform = rform.next())
                            (let [#_"IPersistentVector" fields (ß (IPersistentVector) rform.first())]
                                (ß rform = rform.next())
                                (let [#_"IPersistentMap" opts (ß PersistentHashMap.EMPTY)]
                                    (while (ß rform != nil && rform.first() instanceof Keyword)
                                        (ß opts = opts.assoc(rform.first(), RT.second(rform)))
                                        (ß rform = rform.next().next())
                                    )

                                    (let [#_"ObjExpr" ret (ß build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, nil, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts))]
                                        ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (class-ns ReifyParser (§ implements IParser)
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (let [#_"ObjMethod" enclosingMethod (ß (ObjMethod) METHOD.deref())]
                        (let [#_"String" basename (ß (enclosingMethod != nil) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$"))]
                            (let [#_"String" simpleName (ß "reify__" + RT.nextID())]
                                (let [#_"String" classname (ß basename + simpleName)]
                                    (let [#_"ISeq" rform (ß RT.next(form))]
                                        (let [#_"IPersistentVector" interfaces (ß ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj")))]
                                            (ß rform = RT.next(rform))

                                            (let [#_"ObjExpr" ret (ß build(interfaces, nil, nil, classname, Symbol.intern(classname), nil, rform, frm, nil))]
                                                (if (ß frm instanceof IObj && ((IObj) frm).meta() != nil)
                                                    (do
                                                        (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta())))
                                                    )
                                                    (do
                                                        ret
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn #_"ObjExpr" build [#_"IPersistentVector" interfaceSyms, #_"IPersistentVector" fieldSyms, #_"Symbol" thisSym, #_"String" tagName, #_"Symbol" className, #_"Symbol" typeTag, #_"ISeq" methodForms, #_"Object" frm, #_"IPersistentMap" opts]
            (let [#_"NewInstanceExpr" ret (ß new NewInstanceExpr(nil))]
                (ß ret.src = frm)
                (ß ret.name = className.toString())
                (ß ret.classMeta = RT.meta(className))
                (ß ret.internalName = ret.name.replace(\., \/))
                (ß ret.objtype = Type.getObjectType(ret.internalName))
                (ß ret.opts = opts)

                (when (ß thisSym != nil)
                    (ß ret.thisName = thisSym.name)
                )

                (when (ß fieldSyms != nil)
                    (let [#_"IPersistentMap" fmap (ß PersistentHashMap.EMPTY)]
                        (let [#_"Object[]" closesvec (ß new Object[2 * fieldSyms.count()])]
                            (loop-when-recur [(ß int i = 0)] (ß i < fieldSyms.count()) [(ß i++)]
                                (let [#_"Symbol" sym (ß (Symbol) fieldSyms.nth(i))]
                                    (let [#_"LocalBinding" lb (ß new LocalBinding(-1, sym, nil, new MethodParamExpr(tagClass(tagOf(sym))), false, nil))]
                                        (ß fmap = fmap.assoc(sym, lb))
                                        (ß closesvec[i * 2] = lb)
                                        (ß closesvec[i * 2 + 1] = lb)
                                    )
                                )
                            )

                            ;; todo - inject __meta et al into closes - when?
                            ;; use array map to preserve ctor order
                            (ß ret.closes = new PersistentArrayMap(closesvec))
                            (ß ret.fields = fmap)
                            (loop-when-recur [(ß int i = fieldSyms.count() - 1)] (ß i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq"))) [(ß --i)]
                                (ß ret.altCtorDrops++)
                            )
                        )
                    )
                )

                (let [#_"PersistentVector" interfaces (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(ß ISeq s = RT.seq(interfaceSyms))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"Class" c (ß (Class) resolve((Symbol) s.first()))]
                            (when (ß !c.isInterface())
                                (throw (ß new IllegalArgumentException("only interfaces are supported, had: " + c.getName())))
                            )
                            (ß interfaces = interfaces.cons(c))
                        )
                    )
                    (let [#_"Class" superClass (ß Object.class)]
                        (let [#_"Map[]" mc (ß gatherMethods(superClass, RT.seq(interfaces)))]
                            (let [#_"Map" overrideables (ß mc[0])]
                                (let [#_"Map" covariants (ß mc[1])]
                                    (ß ret.mmap = overrideables)
                                    (ß ret.covariants = covariants)

                                    (let [#_"String[]" inames (ß interfaceNames(interfaces))]
                                        (let [#_"Class" stub (ß compileStub(slashname(superClass), ret, inames, frm))]
                                            (let [#_"Symbol" thistag (ß Symbol.intern(nil, stub.getName()))]
                                                (try
                                                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                        #_map CONSTANTS, PersistentVector.EMPTY,
                                                        #_map CONSTANT_IDS, new IdentityHashMap(),
                                                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                                                        #_map VARS, PersistentHashMap.EMPTY,
                                                        #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                                                        #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                                                        #_map VAR_CALLSITES, emptyVarCallSites(),
                                                        #_map NO_RECUR, nil
                                                    )))
                                                    (when (ß ret.isDeftype())
                                                        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                            #_map METHOD, nil,
                                                            #_map LOCAL_ENV, ret.fields,
                                                            #_map COMPILE_STUB_SYM, Symbol.intern(nil, tagName),
                                                            #_map COMPILE_STUB_CLASS, stub
                                                        )))

                                                        (ß ret.hintedFields = RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops))
                                                    )

                                                    ;; now (methodname [args] body)*
                                                    (ß ret.line = lineDeref())
                                                    (ß ret.column = columnDeref())
                                                    (let [#_"IPersistentCollection" methods nil]
                                                        (loop-when-recur [(ß ISeq s = methodForms)] (ß s != nil) [(ß s = RT.next(s))]
                                                            (let [#_"NewInstanceMethod" m (ß NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables))]
                                                                (ß methods = RT.conj(methods, m))
                                                            )
                                                        )

                                                        (ß ret.methods = methods)
                                                        (ß ret.keywords = (IPersistentMap) KEYWORDS.deref())
                                                        (ß ret.vars = (IPersistentMap) VARS.deref())
                                                        (ß ret.constants = (PersistentVector) CONSTANTS.deref())
                                                        (ß ret.constantsID = RT.nextID())
                                                        (ß ret.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                                                        (ß ret.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                                                        (ß ret.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())
                                                    )
                                                    (finally
                                                        (when (ß ret.isDeftype())
                                                            (ß Var.popThreadBindings())
                                                        )
                                                        (ß Var.popThreadBindings())
                                                    )
                                                )

                                                (try
                                                    (ß ret.compile(slashname(superClass), inames, false))
                                                    (catch IOException e
                                                        (throw (ß Util.sneakyThrow(e)))
                                                    )
                                                )
                                                (ß ret.getCompiledClass())
                                                ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        ;;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;;
        (§ defn #_"Class" compileStub [#_"String" superName, #_"NewInstanceExpr" ret, #_"String[]" interfaceNames, #_"Object" frm]
            (let [#_"ClassWriter" cw (ß new ClassWriter(ClassWriter.COMPUTE_MAXS))]
                (let [#_"ClassVisitor" cv cw]
                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, nil, superName, interfaceNames))

                    ;; instance fields for closed-overs
                    (loop-when-recur [(ß ISeq s = RT.keys(ret.closes))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                            (let [#_"int" access (ß ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL))]
                                (if (ß lb.getPrimitiveType() != nil)
                                    (do
                                        (ß cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                    )
                                    (do
                                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                        (ß cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                    )
                                )
                            )
                        )
                    )

                    ;; ctor that takes closed-overs and does nothing
                    (let [#_"Method" m (ß new Method("<init>", Type.VOID_TYPE, ret.ctorTypes()))]
                        (let [#_"GeneratorAdapter" ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))]
                            (ß ctorgen.visitCode())
                            (ß ctorgen.loadThis())
                            (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))
                            (ß ctorgen.returnValue())
                            (ß ctorgen.endMethod())

                            (when (ß ret.altCtorDrops > 0)
                                (let [#_"Type[]" ctorTypes (ß ret.ctorTypes())]
                                    (let [#_"Type[]" altCtorTypes (ß new Type[ctorTypes.length-ret.altCtorDrops])]
                                        (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                            (ß altCtorTypes[i] = ctorTypes[i])
                                        )
                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes))]
                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                            (ß ctorgen.visitCode())
                                            (ß ctorgen.loadThis())
                                            (ß ctorgen.loadArgs())

                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                            (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                            (ß ctorgen.returnValue())
                                            (ß ctorgen.endMethod())

                                            ;; alt ctor no __hash, __hasheq
                                            (ß altCtorTypes = new Type[ctorTypes.length-2])
                                            (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                                (ß altCtorTypes[i] = ctorTypes[i])
                                            )

                                            (ß alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                            (ß ctorgen.visitCode())
                                            (ß ctorgen.loadThis())
                                            (ß ctorgen.loadArgs())

                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                            (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                            (ß ctorgen.returnValue())
                                            (ß ctorgen.endMethod())
                                        )
                                    )
                                )
                            )
                            ;; end of class
                            (ß cv.visitEnd())

                            (let [#_"byte[]" bytecode (ß cw.toByteArray())]
                                (let [#_"DynamicClassLoader" loader (ß (DynamicClassLoader) LOADER.deref())]
                                    (ß loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm))
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn #_"String[]" interfaceNames [#_"IPersistentVector" interfaces]
            (let [#_"int" icnt (ß interfaces.count())]
                (let [#_"String[]" inames (ß (icnt > 0) ? new String[icnt] :or nil)]
                    (loop-when-recur [(ß int i = 0)] (ß i < icnt) [(ß i++)]
                        (ß inames[i] = slashname((Class) interfaces.nth(i)))
                    )
                    inames
                )
            )
        )

        (§ defn #_"String" slashname [#_"Class" c]
            (ß c.getName().replace(\., \/))
        )

        #_protected
        #_method
        (§ defn #_"void" emitStatics [this, #_"ClassVisitor" cv]
            (when (ß this.isDeftype())
                ;; getBasis()
                (let [#_"Method" meth (ß Method.getMethod("cloiure.lang.IPersistentVector getBasis()"))]
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, nil, nil, cv))]
                        (ß emitValue(hintedFields, gen))
                        (ß gen.returnValue())
                        (ß gen.endMethod())

                        (when (ß this.isDeftype() && this.fields.count() > this.hintedFields.count())
                            ;; create(IPersistentMap)
                            (let [#_"String" className (ß name.replace(\., \/))]
                                (let [#_"int" i 1]
                                    (let [#_"int" fieldCount (ß hintedFields.count())]
                                        (let [#_"MethodVisitor" mv (ß cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", nil, nil))]
                                            (ß mv.visitCode())

                                            (loop-when-recur [(ß ISeq s = RT.seq(hintedFields))] (ß s != nil) [(ß s = s.next(), i++)]
                                                (let [#_"String" bName (ß ((Symbol)s.first()).name)]
                                                    (let [#_"Class" k (ß tagClass(tagOf(s.first())))]
                                                        (ß mv.visitVarInsn(ALOAD, 0))
                                                        (ß mv.visitLdcInsn(bName))
                                                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                        (ß mv.visitInsn(ACONST_NULL))
                                                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                                                        (when (ß k.isPrimitive())
                                                            (ß mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName()))
                                                        )
                                                        (ß mv.visitVarInsn(ASTORE, i))
                                                        (ß mv.visitVarInsn(ALOAD, 0))
                                                        (ß mv.visitLdcInsn(bName))
                                                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                                                        (ß mv.visitVarInsn(ASTORE, 0))
                                                    )
                                                )
                                            )

                                            (ß mv.visitTypeInsn(Opcodes.NEW, className))
                                            (ß mv.visitInsn(DUP))

                                            (let [#_"Method" ctor (ß new Method("<init>", Type.VOID_TYPE, ctorTypes()))]
                                                (when (ß hintedFields.count() > 0)
                                                    (loop-when-recur [(ß i = 1)] (ß i <= fieldCount) [(ß i++)]
                                                        (ß mv.visitVarInsn(ALOAD, i))
                                                        (let [#_"Class" k (ß tagClass(tagOf(hintedFields.nth(i - 1))))]
                                                            (when (ß k.isPrimitive())
                                                                (let [#_"String" b (ß Type.getType(boxClass(k)).getInternalName())]
                                                                    (let [#_"String" p (ß Type.getType(k).getDescriptor())]
                                                                        (let [#_"String" n (ß k.getName())]
                                                                            (ß mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )

                                                (ß mv.visitInsn(ACONST_NULL)) ;; __meta
                                                (ß mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                                                (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                                                (ß mv.visitInsn(ICONST_0)) ;; __hash
                                                (ß mv.visitInsn(ICONST_0)) ;; __hasheq
                                                (ß mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor()))
                                                (ß mv.visitInsn(ARETURN))
                                                (ß mv.visitMaxs(4 + fieldCount, 1 + fieldCount))
                                                (ß mv.visitEnd())
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        #_protected
        #_method
        (§ defn #_"void" emitMethods [this, #_"ClassVisitor" cv]
            (loop-when-recur [(ß ISeq s = RT.seq(methods))] (ß s != nil) [(ß s = s.next())]
                (let [#_"ObjMethod" method (ß (ObjMethod) s.first())]
                    (ß method.emit(this, cv))
                )
            )
            ;; emit bridge methods
            (doseq [#_"Map.Entry<IPersistentVector, Set<Class>>" (ß e covariants.entrySet())]
                (let [(ß java.lang.reflect.Method m = mmap.get(e.getKey()))]
                    (let [#_"Class[]" params (ß m.getParameterTypes())]
                        (let [#_"Type[]" argTypes (ß new Type[params.length])]
                            (loop-when-recur [(ß int i = 0)] (ß i < params.length) [(ß i++)]
                                (ß argTypes[i] = Type.getType(params[i]))
                            )

                            (let [#_"Method" target (ß new Method(m.getName(), Type.getType(m.getReturnType()), argTypes))]
                                (doseq [#_"Class" retType (ß e.getValue())]
                                    (let [#_"Method" meth (ß new Method(m.getName(), Type.getType(retType), argTypes))]
                                        ;; todo don't hardwire EXCEPTION_TYPES
                                        (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE, meth, nil, EXCEPTION_TYPES, cv))]
                                            (ß gen.visitCode())
                                            (ß gen.loadThis())
                                            (ß gen.loadArgs())
                                            (ß gen.invokeInterface(Type.getType(m.getDeclaringClass()), target))
                                            (ß gen.returnValue())
                                            (ß gen.endMethod())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn #_"IPersistentVector" msig [#_"java.lang.reflect.Method" m]
            (ß RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType()))
        )

        (§ defn #_"void" considerMethod [#_"java.lang.reflect.Method" m, #_"Map" mm]
            (let [#_"IPersistentVector" mk (ß msig(m))]
                (let [#_"int" mods (ß m.getModifiers())]
                    (when (ß !(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods)))
                        (ß mm.put(mk, m))
                    )
                    nil
                )
            )
        )

        (§ defn #_"void" gatherMethods [#_"Class" c, #_"Map" mm]
            (loop-when-recur [(ß )] (ß c != nil) [(ß c = c.getSuperclass())]
                (doseq [#_"java.lang.reflect.Method" m (ß c.getDeclaredMethods())]
                    (ß considerMethod(m, mm))
                )
                (doseq [#_"java.lang.reflect.Method" m (ß c.getMethods())]
                    (ß considerMethod(m, mm))
                )
            )
            nil
        )

        (§ defn #_"Map[]" gatherMethods [#_"Class" sc, #_"ISeq" interfaces]
            (let [#_"Map" allm (ß new HashMap())]
                (ß gatherMethods(sc, allm))
                (loop-when-recur [(ß )] (ß interfaces != nil) [(ß interfaces = interfaces.next())]
                    (ß gatherMethods((Class) interfaces.first(), allm))
                )

                (let [(ß Map<IPersistentVector, java.lang.reflect.Method> mm = new HashMap<IPersistentVector, java.lang.reflect.Method>())]
                    (let [(ß Map<IPersistentVector, Set<Class>> covariants = new HashMap<IPersistentVector, Set<Class>>())]
                        (doseq [#_"Object" o (ß allm.entrySet())]
                            (let [(ß Map.Entry e = (Map.Entry) o)]
                                (let [#_"IPersistentVector" mk (ß (IPersistentVector) e.getKey())]
                                    (ß mk = (IPersistentVector) mk.pop())
                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())]
                                        (if (ß mm.containsKey(mk)) ;; covariant return
                                            (do
                                                (let [#_"Set<Class>" cvs (ß covariants.get(mk))]
                                                    (when (ß cvs == nil)
                                                        (ß cvs = new HashSet<Class>())
                                                        (ß covariants.put(mk, cvs))
                                                    )
                                                    (let [(ß java.lang.reflect.Method om = mm.get(mk))]
                                                        (if (ß om.getReturnType().isAssignableFrom(m.getReturnType()))
                                                            (do
                                                                (ß cvs.add(om.getReturnType()))
                                                                (ß mm.put(mk, m))
                                                            )
                                                            (do
                                                                (ß cvs.add(m.getReturnType()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (do
                                                (ß mm.put(mk, m))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß new Map[] (§ mm, covariants ))
                    )
                )
            )
        )
    )

    (class-ns NewInstanceMethod (§ extends ObjMethod)
        (§ field #_"String" name)
        (§ field #_"Type[]" argTypes)
        (§ field #_"Type" retType)
        (§ field #_"Class" retClass)
        (§ field #_"Class[]" exclasses)

        (§ def #_"Symbol" dummyThis (ß Symbol.intern(nil, "dummy_this_dlskjsdfower")))
        (§ field- #_"IPersistentVector" parms)

        (§ constructor #_"NewInstanceMethod" NewInstanceMethod [#_"ObjExpr" objx, #_"ObjMethod" parent]
            (§ super(objx, parent))
            this
        )

        #_method
        (§ defn #_"int" numParams [this]
            (ß argLocals.count())
        )

        #_method
        (§ defn #_"String" getMethodName [this]
            name
        )

        #_method
        (§ defn #_"Type" getReturnType [this]
            retType
        )

        #_method
        (§ defn #_"Type[]" getArgTypes [this]
            argTypes
        )

        (§ defn #_"IPersistentVector" msig [#_"String" name, #_"Class[]" paramTypes]
            (ß RT.vector(name, RT.seq(paramTypes)))
        )

        (§ defn #_"NewInstanceMethod" parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Symbol" thistag, #_"Map" overrideables]
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            (let [#_"NewInstanceMethod" method (ß new NewInstanceMethod(objx, (ObjMethod) METHOD.deref()))]
                (let [#_"Symbol" dotname (ß (Symbol)RT.first(form))]
                    (let [#_"Symbol" name (ß (Symbol) Symbol.intern(nil, munge(dotname.name)).withMeta(RT.meta(dotname)))]
                        (let [#_"IPersistentVector" parms (ß (IPersistentVector) RT.second(form))]
                            (when (ß parms.count() == 0)
                                (throw (ß new IllegalArgumentException("Must supply at least one argument for 'this' in: " + dotname)))
                            )
                            (let [#_"Symbol" thisName (ß (Symbol) parms.nth(0))]
                                (ß parms = RT.subvec(parms, 1, parms.count()))
                                (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                                    (try
                                        (ß method.line = lineDeref())
                                        (ß method.column = columnDeref())
                                        ;; register as the current method and set up a new env frame
                                        (let [#_"PathNode" pnode (ß  new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))]
                                            (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                #_map METHOD, method,
                                                #_map LOCAL_ENV, LOCAL_ENV.deref(),
                                                #_map LOOP_LOCALS, nil,
                                                #_map NEXT_LOCAL_NUM, 0,
                                                #_map CLEAR_PATH, pnode,
                                                #_map CLEAR_ROOT, pnode,
                                                #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                                                #_map METHOD_RETURN_CONTEXT, RT.T
                                            )))

                                            ;; register 'this' as local 0
                                            (if (ß thisName != nil)
                                                (do
                                                    (ß registerLocal((thisName == nil) ? dummyThis:thisName, thistag, nil, false))
                                                )
                                                (do
                                                    (ß getAndIncLocalNum())
                                                )
                                            )

                                            (let [#_"PersistentVector" argLocals (ß PersistentVector.EMPTY)]
                                                (ß method.retClass = tagClass(tagOf(name)))
                                                (ß method.argTypes = new Type[parms.count()])
                                                (let [#_"boolean" hinted (ß tagOf(name) != nil)]
                                                    (let [#_"Class[]" pclasses (ß new Class[parms.count()])]
                                                        (let [#_"Symbol[]" psyms (ß new Symbol[parms.count()])]
                                                            (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                                (when (ß !(parms.nth(i) instanceof Symbol))
                                                                    (throw (ß new IllegalArgumentException("params must be Symbols")))
                                                                )
                                                                (let [#_"Symbol" p (ß (Symbol) parms.nth(i))]
                                                                    (let [#_"Object" tag (ß tagOf(p))]
                                                                        (when (ß tag != nil)
                                                                            (ß hinted = true)
                                                                        )
                                                                        (when (ß p.getNamespace() != nil)
                                                                            (ß p = Symbol.intern(p.name))
                                                                        )
                                                                        (let [#_"Class" pclass (ß tagClass(tag))]
                                                                            (ß pclasses[i] = pclass)
                                                                            (ß psyms[i] = p)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (let [#_"Map" matches (ß findMethodsWithNameAndArity(name.name, parms.count(), overrideables))]
                                                                (let [#_"Object" mk (ß msig(name.name, pclasses))]
                                                                    (let [(ß java.lang.reflect.Method m = nil)]
                                                                        (if (ß matches.size() > 0)
                                                                            (do
                                                                                ;; multiple methods
                                                                                (cond (ß matches.size() > 1)
                                                                                    (do
                                                                                        ;; must be hinted and match one method
                                                                                        (when (ß !hinted)
                                                                                            (throw (ß new IllegalArgumentException("Must hint overloaded method: " + name.name)))
                                                                                        )
                                                                                        (ß m = (java.lang.reflect.Method) matches.get(mk))
                                                                                        (when (ß m == nil)
                                                                                            (throw (ß new IllegalArgumentException("Can't find matching overloaded method: " + name.name)))
                                                                                        )
                                                                                        (when (ß m.getReturnType() != method.retClass)
                                                                                            (throw (ß new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())))
                                                                                        )
                                                                                    )
                                                                                    :else ;; one match
                                                                                    (do
                                                                                        ;; if hinted, validate match
                                                                                        (cond hinted
                                                                                            (do
                                                                                                (ß m = (java.lang.reflect.Method) matches.get(mk))
                                                                                                (when (ß m == nil)
                                                                                                    (throw (ß new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match.")))
                                                                                                )
                                                                                                (when (ß m.getReturnType() != method.retClass)
                                                                                                    (throw (ß new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())))
                                                                                                )
                                                                                            )
                                                                                            :else ;; adopt found method sig
                                                                                            (do
                                                                                                (ß m = (java.lang.reflect.Method) matches.values().iterator().next())
                                                                                                (ß method.retClass = m.getReturnType())
                                                                                                (ß pclasses = m.getParameterTypes())
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                            (do
                                                                                (throw (ß new IllegalArgumentException("Can't define method not in interfaces: " + name.name)))
                                                                            )
                                                                        )

                                                                        ;; validate unque name+arity among additional methods

                                                                        (ß method.retType = Type.getType(method.retClass))
                                                                        (ß method.exclasses = m.getExceptionTypes())

                                                                        (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                                            (let [#_"LocalBinding" lb (ß registerLocal(psyms[i], nil, new MethodParamExpr(pclasses[i]), true))]
                                                                                (ß argLocals = argLocals.assocN(i, lb))
                                                                                (ß method.argTypes[i] = Type.getType(pclasses[i]))
                                                                            )
                                                                        )
                                                                        (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                                            (when (ß pclasses[i] == long.class || pclasses[i] == double.class)
                                                                                (ß getAndIncLocalNum())
                                                                            )
                                                                        )
                                                                        (ß LOOP_LOCALS.set(argLocals))
                                                                        (ß method.name = name.name)
                                                                        (ß method.methodMeta = RT.meta(name))
                                                                        (ß method.parms = parms)
                                                                        (ß method.argLocals = argLocals)
                                                                        (ß method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                                                                        method
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (finally
                                            (ß Var.popThreadBindings())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn- #_"Map" findMethodsWithNameAndArity [#_"String" name, #_"int" arity, #_"Map" mm]
            (let [#_"Map" ret (ß new HashMap())]
                (doseq [#_"Object" o (ß mm.entrySet())]
                    (let [(ß Map.Entry e = (Map.Entry) o)]
                        (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())]
                            (when (ß name.equals(m.getName()) && m.getParameterTypes().length == arity)
                                (ß ret.put(e.getKey(), e.getValue()))
                            )
                        )
                    )
                )
                ret
            )
        )

        (§ defn- #_"Map" findMethodsWithName [#_"String" name, #_"Map" mm]
            (let [#_"Map" ret (ß new HashMap())]
                (doseq [#_"Object" o (ß mm.entrySet())]
                    (let [(ß Map.Entry e = (Map.Entry) o)]
                        (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())]
                            (when (ß name.equals(m.getName()))
                                (ß ret.put(e.getKey(), e.getValue()))
                            )
                        )
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"void" emit [this, #_"ObjExpr" obj, #_"ClassVisitor" cv]
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                (let [#_"Type[]" extypes nil]
                    (when (ß exclasses.length > 0)
                        (ß extypes = new Type[exclasses.length])
                        (loop-when-recur [(ß int i = 0)] (ß i < exclasses.length) [(ß i++)]
                            (ß extypes[i] = Type.getType(exclasses[i]))
                        )
                    )
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, extypes, cv))]
                        (ß addAnnotation(gen, methodMeta))
                        (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                            (let [#_"IPersistentMap" meta (ß RT.meta(parms.nth(i)))]
                                (ß addParameterAnnotation(gen, meta, i))
                            )
                        )
                        (ß gen.visitCode())

                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                                (ß emitBody(objx, gen, retClass, body))
                                (let [#_"Label" end (ß gen.mark())]
                                    (ß gen.visitLocalVariable("this", obj.objtype.getDescriptor(), nil, loopLabel, end, 0))
                                    (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())
                            nil
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" inty [#_"Class" c]
        (ß (c == int.class || c == short.class || c == byte.class || c == char.class))
    )

    (§ defn #_"Class" retType [#_"Class" tc, #_"Class" ret]
        (when (ß tc == nil)
            (§ return ret)
        )
        (when (ß ret == nil)
            (§ return tc)
        )
        (when (ß ret.isPrimitive() && tc.isPrimitive())
            (when (ß (inty(ret) && inty(tc)) || (ret == tc))
                (§ return tc)
            )
            (throw (ß new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead")))
        )
        tc
    )

    (§ defn #_"Class" primClass [#_"Symbol" sym]
        (when (ß sym == nil)
            (§ return nil)
        )
        (let [#_"Class" c nil]
            (cond (ß sym.name.equals("int"))
                (do
                    (ß c = int.class)
                )
                (ß sym.name.equals("long"))
                (do
                    (ß c = long.class)
                )
                (ß sym.name.equals("float"))
                (do
                    (ß c = float.class)
                )
                (ß sym.name.equals("double"))
                (do
                    (ß c = double.class)
                )
                (ß sym.name.equals("char"))
                (do
                    (ß c = char.class)
                )
                (ß sym.name.equals("short"))
                (do
                    (ß c = short.class)
                )
                (ß sym.name.equals("byte"))
                (do
                    (ß c = byte.class)
                )
                (ß sym.name.equals("boolean"))
                (do
                    (ß c = boolean.class)
                )
                (ß sym.name.equals("void"))
                (do
                    (ß c = void.class)
                )
            )
            c
        )
    )

    (§ defn #_"Class" tagClass [#_"Object" tag]
        (when (ß tag == nil)
            (§ return (ß Object.class))
        )
        (let [#_"Class" c nil]
            (when (ß tag instanceof Symbol)
                (ß c = primClass((Symbol) tag))
            )
            (when (ß c == nil)
                (ß c = HostExpr.tagToClass(tag))
            )
            c
        )
    )

    (§ defn #_"Class" primClass [#_"Class" c]
        (ß c.isPrimitive() ? c :or Object.class)
    )

    (§ defn #_"Class" boxClass [#_"Class" p]
        (when (ß !p.isPrimitive())
            (§ return p)
        )

        (let [#_"Class" c nil]
            (cond (ß p == Integer.TYPE)
                (do
                    (ß c = Integer.class)
                )
                (ß p == Long.TYPE)
                (do
                    (ß c = Long.class)
                )
                (ß p == Float.TYPE)
                (do
                    (ß c = Float.class)
                )
                (ß p == Double.TYPE)
                (do
                    (ß c = Double.class)
                )
                (ß p == Character.TYPE)
                (do
                    (ß c = Character.class)
                )
                (ß p == Short.TYPE)
                (do
                    (ß c = Short.class)
                )
                (ß p == Byte.TYPE)
                (do
                    (ß c = Byte.class)
                )
                (ß p == Boolean.TYPE)
                (do
                    (ß c = Boolean.class)
                )
            )

            c
        )
    )

    (class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"Class" c)

        (§ constructor #_"MethodParamExpr" MethodParamExpr [#_"Class" c]
            (ß this.c = c)
            this
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß Util.runtimeException("Can't eval")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (throw (ß Util.runtimeException("Can't emit")))
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (c != nil))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            c
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß Util.isPrimitive(c))
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (throw (ß Util.runtimeException("Can't emit")))
        )
    )

    (class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field #_"LocalBindingExpr" expr)
        (§ field #_"int" shift)
        (§ field #_"int" mask)
        (§ field #_"int" low)
        (§ field #_"int" high)
        (§ field #_"Expr" defaultExpr)
        (§ field #_"SortedMap<Integer, Expr>" tests)
        (§ field #_"HashMap<Integer, Expr>" thens)
        (§ field #_"Keyword" switchType)
        (§ field #_"Keyword" testType)
        (§ field #_"Set<Integer>" skipCheck)
        (§ field #_"Class" returnType)
        (§ field #_"int" line)
        (§ field #_"int" column)

        (§ def #_"Type" NUMBER_TYPE (ß Type.getType(Number.class)))
        (§ def #_"Method" intValueMethod (ß Method.getMethod("int intValue()")))

        (§ def #_"Method" hashMethod (ß Method.getMethod("int hash(Object)")))
        (§ def #_"Method" hashCodeMethod (ß Method.getMethod("int hashCode()")))
        (§ def #_"Method" equivMethod (ß Method.getMethod("boolean equiv(Object, Object)")))
        (§ def #_"Keyword" compactKey (ß Keyword.intern(nil, "compact")))
        (§ def #_"Keyword" sparseKey (ß Keyword.intern(nil, "sparse")))
        (§ def #_"Keyword" hashIdentityKey (ß Keyword.intern(nil, "hash-identity")))
        (§ def #_"Keyword" hashEquivKey (ß Keyword.intern(nil, "hash-equiv")))
        (§ def #_"Keyword" intKey (ß Keyword.intern(nil, "int")))

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        (§ constructor #_"CaseExpr" CaseExpr [#_"int" line, #_"int" column, #_"LocalBindingExpr" expr, #_"int" shift, #_"int" mask, #_"int" low, #_"int" high, #_"Expr" defaultExpr, #_"SortedMap<Integer, Expr>" tests, #_"HashMap<Integer, Expr>" thens, #_"Keyword" switchType, #_"Keyword" testType, #_"Set<Integer>" skipCheck]
            (ß this.expr = expr)
            (ß this.shift = shift)
            (ß this.mask = mask)
            (ß this.low = low)
            (ß this.high = high)
            (ß this.defaultExpr = defaultExpr)
            (ß this.tests = tests)
            (ß this.thens = thens)
            (ß this.line = line)
            (ß this.column = column)
            (when (ß switchType != compactKey && switchType != sparseKey)
                (throw (ß new IllegalArgumentException("Unexpected switch type: "+switchType)))
            )
            (ß this.switchType = switchType)
            (when (ß testType != intKey && testType != hashEquivKey && testType != hashIdentityKey)
                (throw (ß new IllegalArgumentException("Unexpected test type: "+switchType)))
            )
            (ß this.testType = testType)
            (ß this.skipCheck = skipCheck)
            (let [#_"Collection<Expr>" returns (ß new ArrayList(thens.values()))]
                (ß returns.add(defaultExpr))
                (ß this.returnType = maybeJavaClass(returns))
                (when (ß RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), line, column))
                )
                this
            )
        )

        #_method
        (§ defn #_"boolean" hasJavaClass [this]
            (ß (returnType != nil))
        )

        #_method
        (§ defn #_"boolean" canEmitPrimitive [this]
            (ß Util.isPrimitive(returnType))
        )

        #_method
        (§ defn #_"Class" getJavaClass [this]
            returnType
        )

        #_method
        (§ defn #_"Object" eval [this]
            (throw (ß new UnsupportedOperationException("Can't eval case")))
        )

        #_method
        (§ defn #_"void" emit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, false))
            nil
        )

        #_method
        (§ defn #_"void" emitUnboxed [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß doEmit(context, objx, gen, true))
            nil
        )

        #_method
        (§ defn #_"void" doEmit [this, #_"C" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
            (let [#_"Label" defaultLabel (ß gen.newLabel())]
                (let [#_"Label" endLabel (ß gen.newLabel())]
                    (let [(ß SortedMap<Integer, Label> labels = new TreeMap())]
                        (doseq [#_"Integer" i (ß tests.keySet())]
                            (ß labels.put(i, gen.newLabel()))
                        )

                        (ß gen.visitLineNumber(line, gen.mark()))

                        (let [#_"Class" primExprClass (ß maybePrimitiveType(expr))]
                            (let [#_"Type" primExprType (ß (primExprClass == nil) ? nil :or Type.getType(primExprClass))]
                                (if (ß testType == intKey)
                                    (do
                                        (ß emitExprForInts(objx, gen, primExprType, defaultLabel))
                                    )
                                    (do
                                        (ß emitExprForHashes(objx, gen))
                                    )
                                )

                                (if (ß switchType == sparseKey)
                                    (do
                                        (let [#_"Label[]" la (ß new Label[labels.size()])]
                                            (ß la = labels.values().toArray(la))
                                            (let [#_"int[]" ints (ß Numbers.int_array(tests.keySet()))]
                                                (ß gen.visitLookupSwitchInsn(defaultLabel, ints, la))
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Label[]" la (ß new Label[(high - low) + 1])]
                                            (loop-when-recur [(ß int i = low)] (ß i <= high) [(ß i++)]
                                                (ß la[i - low] = labels.containsKey(i) ? labels.get(i) :or defaultLabel)
                                            )
                                            (ß gen.visitTableSwitchInsn(low, high, defaultLabel, la))
                                        )
                                    )
                                )

                                (doseq [#_"Integer" i (ß labels.keySet())]
                                    (ß gen.mark(labels.get(i)))
                                    (cond (ß testType == intKey)
                                        (do
                                            (ß emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                                        )
                                        (ß RT.contains(skipCheck, i) == RT.T)
                                        (do
                                            (ß emitExpr(objx, gen, thens.get(i), emitUnboxed))
                                        )
                                        :else
                                        (do
                                            (ß emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                                        )
                                    )
                                    (ß gen.goTo(endLabel))
                                )

                                (ß gen.mark(defaultLabel))
                                (ß emitExpr(objx, gen, defaultExpr, emitUnboxed))
                                (ß gen.mark(endLabel))
                                (when (ß context == C.STATEMENT)
                                    (ß gen.pop())
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"boolean" isShiftMasked [this]
            (ß (mask != 0))
        )

        #_method
        (§ defn- #_"void" emitShiftMask [this, #_"GeneratorAdapter" gen]
            (when (ß isShiftMasked())
                (ß gen.push(shift))
                (ß gen.visitInsn(ISHR))
                (ß gen.push(mask))
                (ß gen.visitInsn(IAND))
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitExprForInts [this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Label" defaultLabel]
            (cond (ß exprType == nil)
                (do
                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column))
                    )
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.instanceOf(NUMBER_TYPE))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(NUMBER_TYPE))
                    (ß gen.invokeVirtual(NUMBER_TYPE, intValueMethod))
                    (ß emitShiftMask(gen))
                )
                (ß exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (do
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.cast(exprType, Type.INT_TYPE))
                    (ß emitShiftMask(gen))
                )
                :else
                (do
                    (ß gen.goTo(defaultLabel))
                )
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitThenForInts [this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
            (cond (ß exprType == nil)
                (do
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß test.emit(C.EXPRESSION, objx, gen))
                    (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                (ß exprType == Type.LONG_TYPE)
                (do
                    (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                (ß exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (do
                    (when (ß isShiftMasked())
                        (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.cast(exprType, Type.LONG_TYPE))
                        (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                    )
                    ;; else direct match
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                :else
                (do
                    (ß gen.goTo(defaultLabel))
                )
            )
            nil
        )

        #_method
        (§ defn- #_"void" emitExprForHashes [this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeStatic(UTIL_TYPE, hashMethod))
            (ß emitShiftMask(gen))
            nil
        )

        #_method
        (§ defn- #_"void" emitThenForHashes [this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß test.emit(C.EXPRESSION, objx, gen))
            (if (ß testType == hashIdentityKey)
                (do
                    (ß gen.visitJumpInsn(IF_ACMPNE, defaultLabel))
                )
                (do
                    (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                )
            )
            (ß emitExpr(objx, gen, then, emitUnboxed))
            nil
        )

        (§ defn- #_"void" emitExpr [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" expr, #_"boolean" emitUnboxed]
            (if (ß emitUnboxed && expr instanceof MaybePrimitiveExpr)
                (do
                    (ß ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen))
                )
                (do
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                )
            )
            nil
        )

        (class-ns Parser (§ implements IParser)
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            #_method
            (§ defn #_"Expr" parse [this, #_"C" context, #_"Object" frm]
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß context == C.EVAL)
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )
                    (let [#_"IPersistentVector" args (ß LazilyPersistentVector.create(form.next()))]
                        (let [#_"Object" exprForm (ß args.nth(0))]
                            (let [#_"int" shift (ß ((Number)args.nth(1)).intValue())]
                                (let [#_"int" mask (ß ((Number)args.nth(2)).intValue())]
                                    (let [#_"Object" defaultForm (ß args.nth(3))]
                                        (let [#_"Map" caseMap (ß (Map)args.nth(4))]
                                            (let [#_"Keyword" switchType (ß ((Keyword)args.nth(5)))]
                                                (let [#_"Keyword" testType (ß ((Keyword)args.nth(6)))]
                                                    (let [#_"Set" skipCheck (ß (RT.count(args) < 8) ? nil :or (Set)args.nth(7))]
                                                        (let [#_"ISeq" keys (ß RT.keys(caseMap))]
                                                            (let [#_"int" low (ß ((Number)RT.first(keys)).intValue())]
                                                                (let [#_"int" high (ß ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue())]
                                                                    (let [#_"LocalBindingExpr" testexpr (ß (LocalBindingExpr) analyze(C.EXPRESSION, exprForm))]
                                                                        (ß testexpr.shouldClear = false)

                                                                        (let [(ß SortedMap<Integer, Expr> tests = new TreeMap())]
                                                                            (let [(ß HashMap<Integer, Expr> thens = new HashMap())]
                                                                                (let [#_"PathNode" branch (ß new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))]
                                                                                    (doseq [#_"Object" o (ß caseMap.entrySet())]
                                                                                        (let [(ß Map.Entry e = (Map.Entry) o)]
                                                                                            (let [#_"Integer" minhash (ß ((Number)e.getKey()).intValue())]
                                                                                                (let [#_"Object" pair (ß e.getValue())] ;; [test-val then-expr]
                                                                                                    (let [#_"Expr" testExpr (ß (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair)))]
                                                                                                        (ß tests.put(minhash, testExpr))

                                                                                                        (§ let [#_"Expr" thenExpr]
                                                                                                            (try
                                                                                                                (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                                                                                                (ß thenExpr = analyze(context, RT.second(pair)))
                                                                                                                (finally
                                                                                                                    (ß Var.popThreadBindings())
                                                                                                                )
                                                                                                            )
                                                                                                            (ß thens.put(minhash, thenExpr))
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )

                                                                                    (§ let [#_"Expr" defaultExpr]
                                                                                        (try
                                                                                            (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                                                                            (ß defaultExpr = analyze(context, args.nth(3)))
                                                                                            (finally
                                                                                                (ß Var.popThreadBindings())
                                                                                            )
                                                                                        )

                                                                                        (let [#_"int" line (ß ((Number)LINE.deref()).intValue())]
                                                                                            (let [#_"int" column (ß ((Number)COLUMN.deref()).intValue())]
                                                                                                (ß new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"IPersistentCollection" emptyVarCallSites []
        (ß PersistentHashSet.EMPTY)
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (§ field- #_"Object" _first)
    (§ field- #_"ISeq" _more)

    (§ constructor #_"Cons" Cons [#_"Object" first, #_"ISeq" _more]
        (ß this._first = first)
        (ß this._more = _more)
        this
    )

    (§ constructor #_"Cons" Cons [#_"IPersistentMap" meta, #_"Object" _first, #_"ISeq" _more]
        (§ super(meta))
        (ß this._first = _first)
        (ß this._more = _more)
        this
    )

    #_method
    (§ defn #_"Object" first [this]
        (ß _first)
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (ß more().seq())
    )

    #_method
    (§ defn #_"ISeq" more [this]
        (when (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    #_method
    (§ defn #_"int" count [this]
        (ß 1 + RT.count(_more))
    )

    #_method
    (§ defn #_"Cons" withMeta [this, #_"IPersistentMap" meta]
        (ß new Cons(meta, _first, _more))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ interface Counted
    (§ abstract int count())
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (§ field- #_"ISeq" all) ;; never nil
    (§ field- #_"ISeq" prev)
    #_volatile
    (§ field- #_"ISeq" _current) ;; lazily realized
    #_volatile
    (§ field- #_"ISeq" _next) ;; cached

    (§ constructor- #_"Cycle" Cycle [#_"ISeq" all, #_"ISeq" prev, #_"ISeq" current]
        (ß this.all = all)
        (ß this.prev = prev)
        (ß this._current = current)
        this
    )

    (§ constructor- #_"Cycle" Cycle [#_"IPersistentMap" meta, #_"ISeq" all, #_"ISeq" prev, #_"ISeq" current, #_"ISeq" next]
        (§ super(meta))
        (ß this.all = all)
        (ß this.prev = prev)
        (ß this._current = current)
        (ß this._next = next)
        this
    )

    (§ defn #_"ISeq" create [#_"ISeq" vals]
        (when (ß vals == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Cycle(vals, nil, vals))
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" current [this]
        (when (ß _current == nil)
            (let [#_"ISeq" current (ß prev.next())]
                (ß _current = (current == nil) ? all :or current)
            )
        )
        (ß _current)
    )

    #_method
    (§ defn #_"boolean" isRealized [this]
        (ß (_current != nil))
    )

    #_method
    (§ defn #_"Object" first [this]
        (ß current().first())
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß _next == nil)
            (ß _next = new Cycle(all, current(), nil))
        )
        (ß _next)
    )

    #_method
    (§ defn #_"Cycle" withMeta [this, #_"IPersistentMap" meta]
        (ß new Cycle(meta, all, prev, _current, _next))
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (let [#_"ISeq" s (ß current())]
            (let [#_"Object" ret (ß s.first())]
                (while true
                    (ß s = s.next())
                    (when (ß s == nil)
                        (ß s = all)
                    )
                    (ß ret = f.invoke(ret, s.first()))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret start]
            (let [#_"ISeq" s (ß current())]
                (while true
                    (ß ret = f.invoke(ret, s.first()))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß s = s.next())
                    (when (ß s == nil)
                        (ß s = all)
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    #_volatile
    (§ field #_"Object" val)
    #_volatile
    (§ field #_"Throwable" exception)
    #_volatile
    (§ field #_"IFn" fn)

    (§ constructor #_"Delay" Delay [#_"IFn" fn]
        (ß this.fn = fn)
        (ß this.val = nil)
        (ß this.exception = nil)
        this
    )

    (§ defn #_"Object" force [#_"Object" x]
        (ß (x instanceof Delay) ? ((Delay) x).deref() :or x)
    )

    #_method
    (§ defn #_"Object" deref [this]
        (when (ß fn != nil)
            (§ sync this
                ;; double check
                (when (ß fn != nil)
                    (try
                        (ß val = fn.invoke())
                        (catch Throwable t
                            (ß exception = t)
                        )
                    )
                    (ß fn = nil)
                )
            )
        )
        (when (ß exception != nil)
            (throw (ß Util.sneakyThrow(exception)))
        )
        val
    )

    #_method
    (§ defn #_"boolean" isRealized [this]
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (§ field #_"HashMap<Integer, Object[]>" constantVals (ß new HashMap<Integer, Object[]>()))
    (§ def #_"ConcurrentHashMap<String, Reference<Class>>" classCache (ß new ConcurrentHashMap<String, Reference<Class>>()))

    (§ def #_"URL[]" EMPTY_URLS (ß new URL[] (§)))

    (§ def #_"ReferenceQueue" rq (ß new ReferenceQueue()))

    (§ constructor #_"DynamicClassLoader" DynamicClassLoader []
        ;; pseudo test in lieu of hasContextClassLoader()
        (§ super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == nil || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader()))
        this
    )

    (§ constructor #_"DynamicClassLoader" DynamicClassLoader [#_"ClassLoader" parent]
        (§ super(EMPTY_URLS, parent))
        this
    )

    #_method
    (§ defn #_"Class" defineClass [this, #_"String" name, #_"byte[]" bytes, #_"Object" srcForm]
        (ß Util.clearCache(rq, classCache))
        (let [#_"Class" c (ß defineClass(name, bytes, 0, bytes.length))]
            (ß classCache.put(name, new SoftReference(c, rq)))
            c
        )
    )

    (§ defn #_"Class<?>" findInMemoryClass [#_"String" name]
        (let [#_"Reference<Class>" cr (ß classCache.get(name))]
            (when (ß cr != nil)
                (let [#_"Class" c (ß cr.get())]
                    (if (ß c != nil)
                        (do
                            (§ return c)
                        )
                        (do
                            (ß classCache.remove(name, cr))
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" findClass [this, #_"String" name] (§ throws ClassNotFoundException)
        (let [#_"Class" c (ß findInMemoryClass(name))]
            (if (ß c != nil)
                (do
                    c
                )
                (do
                    (ß super.findClass(name))
                )
            )
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" loadClass [this, #_"String" name, #_"boolean" resolve] (§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" c (ß findLoadedClass(name))]
                (when (ß c == nil)
                    (ß c = findInMemoryClass(name))
                    (when (ß c == nil)
                        (ß c = super.loadClass(name, false))
                    )
                )
                (when resolve
                    (ß resolveClass(c))
                )
                c
            )
        )
    )

    #_method
    (§ defn #_"void" registerConstants [this, #_"int" id, #_"Object[]" val]
        (ß constantVals.put(id, val))
        nil
    )

    #_method
    (§ defn #_"Object[]" getConstants [this, #_"int" id]
        (ß constantVals.get(id))
    )

    #_method
    (§ defn #_"void" addURL [this, #_"URL" url]
        (ß super.addURL(url))
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReader
    (§ def #_"IFn[]" macros (ß new IFn[256]))
    (§ def #_"IFn[]" dispatchMacros (ß new IFn[256]))
    (§ def #_"Pattern" symbolPat (ß Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")))
    (§ def #_"Pattern" intPat (ß Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")))
    (§ def #_"Pattern" ratioPat (ß Pattern.compile("([-+]?[0-9]+)/([0-9]+)")))
    (§ def #_"Pattern" floatPat (ß Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")))

    (§ def #_"IFn" taggedReader (ß new TaggedReader()))

    (§ static
        (ß macros[\"] = new StringReader()) ;; oops! "
        (ß macros[\;] = new CommentReader())
        (ß macros[\^] = new MetaReader())
        (ß macros[\(] = new ListReader())
        (ß macros[\)] = new UnmatchedDelimiterReader())
        (ß macros[\[] = new VectorReader())
        (ß macros[\]] = new UnmatchedDelimiterReader())
        (ß macros[\{] = new MapReader())
        (ß macros[\}] = new UnmatchedDelimiterReader())
        (ß macros[\\] = new CharacterReader())
        (ß macros[\#] = new DispatchReader())

        (ß dispatchMacros[\#] = new SymbolicValueReader())
        (ß dispatchMacros[\^] = new MetaReader())
        (ß dispatchMacros[\{] = new SetReader())
        (ß dispatchMacros[\<] = new UnreadableReader())
        (ß dispatchMacros[\_] = new DiscardReader())
        (ß dispatchMacros[\:] = new NamespaceMapReader())
    )

    (§ defn #_"boolean" nonConstituent [#_"int" ch]
        (ß (ch == \@ || ch == \` || ch == \~))
    )

    (§ defn #_"Object" readString [#_"String" s, #_"IPersistentMap" opts]
        (let [#_"PushbackReader" r (ß new PushbackReader(new java.io.StringReader(s)))]
            (ß read(r, opts))
        )
    )

    (§ defn #_"boolean" isWhitespace [#_"int" ch]
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn #_"void" unread [#_"PushbackReader" r, #_"int" ch]
        (when (ß ch != -1)
            (try
                (ß r.unread(ch))
                (catch IOException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )
        nil
    )

    (class-ns ReaderException (§ extends RuntimeException)
        (§ field #_"int" line)
        (§ field #_"int" column)

        (§ constructor #_"ReaderException" ReaderException [#_"int" line, #_"int" column, #_"Throwable" cause]
            (§ super(cause))
            (ß this.line = line)
            (ß this.column = column)
            this
        )
    )

    (§ defn #_"int" read1 [#_"Reader" r]
        (try
            (ß r.read())
            (catch IOException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ def #_"Keyword" EOF (ß Keyword.intern(nil, "eof")))

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"IPersistentMap" opts]
        (ß read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts))
    )

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" opts]
        (try
            (while true
                (let [#_"int" ch (ß read1(r))]
                    (while (ß isWhitespace(ch))
                        (ß ch = read1(r))
                    )

                    (when (ß ch == -1)
                        (when eofIsError
                            (throw (ß Util.runtimeException("EOF while reading")))
                        )
                        (§ return eofValue)
                    )

                    (when (ß Character.isDigit(ch))
                        (let [#_"Object" n (ß readNumber(r, (char) ch))]
                            (when (ß RT.suppressRead())
                                (§ return nil)
                            )
                            (§ return n)
                        )
                    )

                    (let [#_"IFn" macroFn (ß getMacro(ch))]
                        (when (ß macroFn != nil)
                            (let [#_"Object" ret (ß macroFn.invoke(r, (char) ch, opts))]
                                (when (ß RT.suppressRead())
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (ß ret == r)
                                    (§ continue )
                                )
                                (§ return ret)
                            )
                        )

                        (when (ß ch == \+ || ch == \-)
                            (let [#_"int" ch2 (ß read1(r))]
                                (when (ß Character.isDigit(ch2))
                                    (ß unread(r, ch2))
                                    (let [#_"Object" n (ß readNumber(r, (char) ch))]
                                        (when (ß RT.suppressRead())
                                            (§ return nil)
                                        )
                                        (§ return n)
                                    )
                                )
                                (ß unread(r, ch2))
                            )
                        )

                        (let [#_"String" token (ß readToken(r, (char) ch, true))]
                            (when (ß RT.suppressRead())
                                (§ return nil)
                            )
                            (§ return (ß interpretToken(token)))
                        )
                    )
                )
            )
            (catch Exception e
                (when (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                    (throw (ß Util.sneakyThrow(e)))
                )
                (let [#_"LineNumberingPushbackReader" rdr (ß (LineNumberingPushbackReader) r)]
                    (throw (ß new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)))
                )
            )
        )
    )

    (§ defn- #_"String" readToken [#_"PushbackReader" r, #_"char" initch, #_"boolean" leadConstituent]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (when (ß leadConstituent && nonConstituent(initch))
                (throw (ß Util.runtimeException("Invalid leading character: " + (char)initch)))
            )

            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (cond (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (do
                            (ß unread(r, ch))
                            (§ return (ß sb.toString()))
                        )
                        (ß nonConstituent(ch))
                        (do
                            (throw (ß Util.runtimeException("Invalid constituent character: " + (char)ch)))
                        )
                    )
                    (ß sb.append((char) ch))
                )
            )
        )
    )

    (§ defn- #_"Object" readNumber [#_"PushbackReader" r, #_"char" initch]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                        (ß unread(r, ch))
                        (§ break )
                    )
                    (ß sb.append((char) ch))
                )
            )

            (let [#_"String" s (ß sb.toString())]
                (let [#_"Object" n (ß matchNumber(s))]
                    (when (ß n == nil)
                        (throw (ß new NumberFormatException("Invalid number: " + s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"String" token, #_"int" offset, #_"int" length, #_"int" base]
        (when (ß token.length() != offset + length)
            (throw (ß new IllegalArgumentException("Invalid unicode character: \\" + token)))
        )
        (let [#_"int" uc 0]
            (loop-when-recur [(ß int i = offset)] (ß i < offset + length) [(ß ++i)]
                (let [#_"int" d (ß Character.digit(token.charAt(i), base))]
                    (when (ß d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + token.charAt(i))))
                    )
                    (ß uc = uc * base + d)
                )
            )
            (ß (char) uc)
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"PushbackReader" r, #_"int" initch, #_"int" base, #_"int" length, #_"boolean" exact]
        (let [#_"int" uc (ß Character.digit(initch, base))]
            (when (ß uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) initch)))
            )
            (let [#_"int" i 1]
                (loop-when-recur [(ß )] (ß i < length) [(ß ++i)]
                    (let [#_"int" ch (ß read1(r))]
                        (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                            (ß unread(r, ch))
                            (§ break )
                        )
                        (let [#_"int" d (ß Character.digit(ch, base))]
                            (when (ß d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ch)))
                            )
                            (ß uc = uc * base + d)
                        )
                    )
                )
                (when (ß i != length && exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)))
                )
                uc
            )
        )
    )

    (§ defn- #_"Object" interpretToken [#_"String" s]
        (cond (ß s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß s.equals("true"))
            (do
                (§ return (ß RT.T))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß RT.F))
            )
        )

        (let [#_"Object" ret nil]
            (ß ret = matchSymbol(s))
            (when (ß ret != nil)
                (§ return ret)
            )

            (throw (ß Util.runtimeException("Invalid token: " + s)))
        )
    )

    (§ defn- #_"Object" matchSymbol [#_"String" s]
        (let [#_"Matcher" m (ß symbolPat.matcher(s))]
            (when (ß m.matches())
                (let [#_"int" gc (ß m.groupCount())]
                    (let [#_"String" ns (ß m.group(1))]
                        (let [#_"String" name (ß m.group(2))]
                            (when (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß s.startsWith("::"))
                                (§ return nil)
                            )
                            (let [#_"boolean" isKeyword (ß s.charAt(0) == \:)]
                                (let [#_"Symbol" sym (ß Symbol.intern(s.substring(isKeyword ? 1 :or 0)))]
                                    (when isKeyword
                                        (§ return (ß Keyword.intern(sym)))
                                    )
                                    (§ return sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- #_"Object" matchNumber [#_"String" s]
        (let [#_"Matcher" m (ß intPat.matcher(s))]
            (when (ß m.matches())
                (when (ß m.group(2) != nil)
                    (when (ß m.group(8) != nil)
                        (§ return (ß BigInt.ZERO))
                    )
                    (§ return (ß Numbers.num(0)))
                )
                (let [#_"boolean" negate (ß m.group(1).equals("-"))]
                    (§ let [#_"String" n]
                        (let [#_"int" radix 10]
                            (cond (ß (n = m.group(3)) != nil)
                                (do
                                    (ß radix = 10)
                                )
                                (ß (n = m.group(4)) != nil)
                                (do
                                    (ß radix = 16)
                                )
                                (ß (n = m.group(5)) != nil)
                                (do
                                    (ß radix = 8)
                                )
                                (ß (n = m.group(7)) != nil)
                                (do
                                    (ß radix = Integer.parseInt(m.group(6)))
                                )
                            )
                            (when (ß n == nil)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" bn (ß new BigInteger(n, radix))]
                                (when negate
                                    (ß bn = bn.negate())
                                )
                                (when (ß m.group(8) != nil)
                                    (§ return (ß BigInt.fromBigInteger(bn)))
                                )
                                (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
                            )
                        )
                    )
                )
            )
            (ß m = floatPat.matcher(s))
            (when (ß m.matches())
                (when (ß m.group(4) != nil)
                    (§ return (ß new BigDecimal(m.group(1))))
                )
                (§ return (ß Double.parseDouble(s)))
            )
            (ß m = ratioPat.matcher(s))
            (when (ß m.matches())
                (let [#_"String" numerator (ß m.group(1))]
                    (when (ß numerator.startsWith("+"))
                        (ß numerator = numerator.substring(1))
                    )

                    (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- #_"IFn" getMacro [#_"int" ch]
        (when (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- #_"boolean" isMacro [#_"int" ch]
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- #_"boolean" isTerminatingMacro [#_"int" ch]
        (ß (ch != \# && ch != \' && isMacro(ch)))
    )

    (class-ns StringReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" doublequote, #_"Object" opts]
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading string")))
                        )
                        (when (ß ch == \\) ;; escape
                            (ß ch = read1(r))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading string")))
                            )
                            (§ switch ch
                                (§ case \t)
                                (do
                                    (ß ch = \tab)
                                    (§ break )
                                )
                                (§ case \r)
                                (do
                                    (ß ch = \return)
                                    (§ break )
                                )
                                (§ case \n)
                                (do
                                    (ß ch = \newline)
                                    (§ break )
                                )
                                (§ case \\)
                                (do
                                    (§ break )
                                )
                                (§ case \") ;; oops! "
                                (do
                                    (§ break )
                                )
                                (§ case \b)
                                (do
                                    (ß ch = \backspace)
                                    (§ break )
                                )
                                (§ case \f)
                                (do
                                    (ß ch = \formfeed)
                                    (§ break )
                                )
                                (§ case \u)
                                (do
                                    (ß ch = read1(r))
                                    (when (ß Character.digit(ch, 16) == -1)
                                        (throw (ß Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)))
                                    )
                                    (ß ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (if (ß Character.isDigit(ch))
                                        (do
                                            (ß ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                            (when (ß ch > 0377)
                                                (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                            )
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Unsupported escape character: \\" + (char) ch)))
                                        )
                                    )
                                    (§ break )
                                )
                            )
                        )
                        (ß sb.append((char) ch))
                    )
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns CommentReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" semicolon, #_"Object" opts]
            (let [#_"Reader" r (ß (Reader) reader)]
                (§ let [#_"int" ch]
                    (§ loop
                        (ß ch = read1(r))
                        (§ recur-if (ch != -1 && ch != \newline && ch != \return))
                    )
                    r
                )
            )
        )
    )

    (class-ns DiscardReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" underscore, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß read(r, true, nil, true, opts))
                r
            )
        )
    )

    (class-ns NamespaceMapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" colon, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                ;; Read ns symbol
                (let [#_"Object" sym (ß read(r, true, nil, false, opts))]
                    (when (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                        (throw (ß new RuntimeException("Namespaced map must specify a valid namespace: " + sym)))
                    )
                    (let [#_"String" ns (ß ((Symbol)sym).getName())]
                        ;; Read map
                        (let [#_"int" nextChar (ß read1(r))]
                            (while (ß isWhitespace(nextChar))
                                (ß nextChar = read1(r))
                            )
                            (when (ß \{ != nextChar)
                                (throw (ß new RuntimeException("Namespaced map must specify a map")))
                            )
                            (let [#_"List" kvs (ß readDelimitedList(\}, r, true, opts))]
                                (when (ß (kvs.size() & 1) == 1)
                                    (throw (ß Util.runtimeException("Namespaced map literal must contain an even number of forms")))
                                )

                                ;; Construct output map
                                (let [#_"Object[]" a (ß new Object[kvs.size()])]
                                    (let [#_"Iterator" iter (ß kvs.iterator())]
                                        (loop-when-recur [(ß int i = 0)] (ß iter.hasNext()) [(ß i += 2)]
                                            (let [#_"Object" key (ß iter.next())]
                                                (let [#_"Object" val (ß iter.next())]
                                                    (cond (ß key instanceof Keyword)
                                                        (do
                                                            (let [#_"Keyword" kw (ß (Keyword) key)]
                                                                (cond (ß kw.getNamespace() == nil)
                                                                    (do
                                                                        (ß key = Keyword.intern(ns, kw.getName()))
                                                                    )
                                                                    (ß kw.getNamespace().equals("_"))
                                                                    (do
                                                                        (ß key = Keyword.intern(nil, kw.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (ß key instanceof Symbol)
                                                        (do
                                                            (let [#_"Symbol" s (ß (Symbol) key)]
                                                                (cond (ß s.getNamespace() == nil)
                                                                    (do
                                                                        (ß key = Symbol.intern(ns, s.getName()))
                                                                    )
                                                                    (ß s.getNamespace().equals("_"))
                                                                    (do
                                                                        (ß key = Symbol.intern(nil, s.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (ß a[i] = key)
                                                    (ß a[i + 1] = val)
                                                )
                                            )
                                        )
                                        (ß RT.map(a))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns DispatchReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" hash, #_"Object" opts]
            (let [#_"int" ch (ß read1((Reader) reader))]
                (when (ß ch == -1)
                    (throw (ß Util.runtimeException("EOF while reading character")))
                )
                (let [#_"IFn" fn (ß dispatchMacros[ch])]
                    (when (ß fn == nil)
                        ;; try tagged reader
                        (when (ß Character.isLetter(ch))
                            (ß unread((PushbackReader) reader, ch))
                            (§ return (ß taggedReader.invoke(reader, ch, opts)))
                        )

                        (throw (ß Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))))
                    )
                    (ß fn.invoke(reader, ch, opts))
                )
            )
        )
    )

    (class-ns MetaReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" caret, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (let [#_"Object" meta (ß read(r, true, nil, true, opts))]
                            (cond (ß meta instanceof Symbol || meta instanceof String)
                                (do
                                    (ß meta = RT.map(RT.TAG_KEY, meta))
                                )
                                (ß meta instanceof Keyword)
                                (do
                                    (ß meta = RT.map(meta, RT.T))
                                )
                                (ß !(meta instanceof IPersistentMap))
                                (do
                                    (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                                )
                            )

                            (let [#_"Object" o (ß read(r, true, nil, true, opts))]
                                (if (ß o instanceof IMeta)
                                    (do
                                        (when (ß line != -1 && o instanceof ISeq)
                                            (ß meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                                        )
                                        (when (ß o instanceof IReference)
                                            (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                                            (§ return o)
                                        )
                                        (let [#_"Object" ometa (ß RT.meta(o))]
                                            (loop-when-recur [(ß ISeq s = RT.seq(meta))] (ß s != nil) [(ß s = s.next())]
                                                (let [#_"IMapEntry" kv (ß (IMapEntry) s.first())]
                                                    (ß ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                                                )
                                            )
                                            (ß ((IObj) o).withMeta((IPersistentMap) ometa))
                                        )
                                    )
                                    (do
                                        (throw (ß new IllegalArgumentException("Metadata can only be applied to IMetas")))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns CharacterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" backslash, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (let [#_"String" token (ß readToken(r, (char) ch, false))]
                        (cond (ß token.length() == 1)
                            (do
                                (§ return (ß Character.valueOf(token.charAt(0))))
                            )
                            (ß token.equals("newline"))
                            (do
                                (§ return (ß \newline))
                            )
                            (ß token.equals("space"))
                            (do
                                (§ return (ß \space))
                            )
                            (ß token.equals("tab"))
                            (do
                                (§ return (ß \tab))
                            )
                            (ß token.equals("backspace"))
                            (do
                                (§ return (ß \backspace))
                            )
                            (ß token.equals("formfeed"))
                            (do
                                (§ return (ß \formfeed))
                            )
                            (ß token.equals("return"))
                            (do
                                (§ return (ß \return))
                            )
                            (ß token.startsWith("u"))
                            (do
                                (let [#_"char" c (ß (char) readUnicodeChar(token, 1, 4, 16))]
                                    (when (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                                        (throw (ß Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))))
                                    )
                                    (§ return c)
                                )
                            )
                            (ß token.startsWith("o"))
                            (do
                                (let [#_"int" len (ß token.length() - 1)]
                                    (when (ß len > 3)
                                        (throw (ß Util.runtimeException("Invalid octal escape sequence length: " + len)))
                                    )
                                    (let [#_"int" uc (ß readUnicodeChar(token, 1, len, 8))]
                                        (when (ß uc > 0377)
                                            (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                        (§ return (ß (char) uc))
                                    )
                                )
                            )
                        )
                        (throw (ß Util.runtimeException("Unsupported character: \\" + token)))
                    )
                )
            )
        )
    )

    (class-ns ListReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (let [#_"List" list (ß readDelimitedList(\), r, true, opts))]
                            (when (ß list.isEmpty())
                                (§ return (ß PersistentList.EMPTY))
                            )
                            (let [#_"IObj" s (ß (IObj) PersistentList.create(list))]
                                s
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts)))
            )
        )
    )

    (class-ns MapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object[]" a (ß readDelimitedList(\}, r, true, opts).toArray())]
                    (when (ß (a.length & 1) == 1)
                        (throw (ß Util.runtimeException("Map literal must contain an even number of forms")))
                    )
                    (ß RT.map(a))
                )
            )
        )
    )

    (class-ns SetReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftbracket, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts)))
            )
        )
    )

    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" rightdelim, #_"Object" opts]
            (throw (ß Util.runtimeException("Unmatched delimiter: " + rightdelim)))
        )
    )

    (class-ns UnreadableReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftangle, #_"Object" opts]
            (throw (ß Util.runtimeException("Unreadable form")))
        )
    )

    (class-ns SymbolicValueReader (§ extends AFn)
        (§ def #_"IPersistentMap" specials (ß PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        )))

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" quote, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts))]
                    (when (ß !(o instanceof Symbol))
                        (throw (ß Util.runtimeException("Invalid token: ##" + o)))
                    )
                    (when (ß !(specials.containsKey(o)))
                        (throw (ß Util.runtimeException("Unknown symbolic value: ##" + o)))
                    )

                    (ß specials.valAt(o))
                )
            )
        )
    )

    (§ defn #_"List" readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" opts]
        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
            (let [#_"ArrayList" a (ß new ArrayList())]
                (while true
                    (let [#_"int" ch (ß read1(r))]
                        (while (ß isWhitespace(ch))
                            (ß ch = read1(r))
                        )

                        (when (ß ch == -1)
                            (if (ß firstline < 0)
                                (do
                                    (throw (ß Util.runtimeException("EOF while reading")))
                                )
                                (do
                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                )
                            )
                        )

                        (when (ß ch == delim)
                            (§ break )
                        )

                        (let [#_"IFn" macroFn (ß getMacro(ch))]
                            (if (ß macroFn != nil)
                                (do
                                    (let [#_"Object" mret (ß macroFn.invoke(r, (char) ch, opts))]
                                        ;; no op macros return the reader
                                        (when (ß mret != r)
                                            (ß a.add(mret))
                                        )
                                    )
                                )
                                (do
                                    (ß unread(r, ch))

                                    (let [#_"Object" o (ß read(r, true, nil, isRecursive, opts))]
                                        (when (ß o != r)
                                            (ß a.add(o))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                a
            )
        )
    )

    (class-ns TaggedReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" firstChar, #_"Object" opts]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" name (ß read(r, true, nil, false, opts))]
                    (when (ß !(name instanceof Symbol))
                        (throw (ß new RuntimeException("Reader tag must be a symbol")))
                    )
                    (let [#_"Symbol" sym (ß (Symbol)name)]
                        (ß readTagged(r, sym, (IPersistentMap) opts))
                    )
                )
            )
        )

        (§ def #_"Keyword" READERS (ß Keyword.intern(nil, "readers")))
        (§ def #_"Keyword" DEFAULT (ß Keyword.intern(nil, "default")))

        #_method
        (§ defn- #_"Object" readTagged [this, #_"PushbackReader" reader, #_"Symbol" tag, #_"IPersistentMap" opts]
            (let [#_"Object" o (ß read(reader, true, nil, true, opts))]
                (let [#_"ILookup" readers (ß (ILookup)RT.get(opts, READERS))]
                    (let [#_"IFn" dataReader (ß (IFn)RT.get(readers, tag))]
                        (when (ß dataReader == nil)
                            (ß dataReader = (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag))
                        )
                        (if (ß dataReader == nil)
                            (do
                                (let [#_"IFn" defaultReader (ß (IFn)RT.get(opts, DEFAULT))]
                                    (if (ß defaultReader != nil)
                                        (do
                                            (ß defaultReader.invoke(tag, o))
                                        )
                                        (do
                                            (throw (ß new RuntimeException("No reader function for tag " + tag.toString())))
                                        )
                                    )
                                )
                            )
                            (do
                                (ß dataReader.invoke(o))
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeq (§ extends ASeq)
    (§ field #_"Enumeration" iter)
    (§ field #_"State" state)

    (class-ns State
        #_volatile
        (§ field #_"Object" val)
        #_volatile
        (§ field #_"Object" _rest)
    )

    (§ defn #_"EnumerationSeq" create [#_"Enumeration" iter]
        (when (ß iter.hasMoreElements())
            (§ return (ß new EnumerationSeq(iter)))
        )
        nil
    )

    (§ constructor #_"EnumerationSeq" EnumerationSeq [#_"Enumeration" iter]
        (ß this.iter = iter)
        (ß state = new State())
        (ß this.state.val = state)
        (ß this.state._rest = state)
        this
    )

    (§ constructor #_"EnumerationSeq" EnumerationSeq [#_"IPersistentMap" meta, #_"Enumeration" iter, #_"State" state]
        (§ super(meta))
        (ß this.iter = iter)
        (ß this.state = state)
        this
    )

    #_method
    (§ defn #_"Object" first [this]
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (ß state.val = iter.nextElement())
                )
            )
        )
        (ß state.val)
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (ß state._rest = create(iter))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    #_method
    (§ defn #_"EnumerationSeq" withMeta [this, #_"IPersistentMap" meta]
        (ß new EnumerationSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (§ field #_"IPersistentMap" data)

    (§ constructor #_"ExceptionInfo" ExceptionInfo [#_"String" s, #_"IPersistentMap" data]
        (§ this(s, data, nil))
        this
    )

    (§ constructor #_"ExceptionInfo" ExceptionInfo [#_"String" s, #_"IPersistentMap" data, #_"Throwable" throwable]
        ;; nil cause is equivalent to not passing a cause
        (§ super(s, throwable))
        (if (ß data != nil)
            (do
                (ß this.data = data)
            )
            (do
                (throw (ß new IllegalArgumentException("Additional data must be non-nil.")))
            )
        )
        this
    )

    #_method
    (§ defn #_"IPersistentMap" getData [this]
        data
    )

    #_method
    (§ defn #_"String" toString [this]
        (ß "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString())
    )
)
)

(java-ns cloiure.lang.Fn

(§ interface Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (§ field #_"Var" v)
    (§ field #_"ClassLoader" loader)
    (§ field #_"String" fnClassName)
    (§ field #_"IFn" fn)

    (§ constructor #_"FnLoaderThunk" FnLoaderThunk [#_"Var" v, #_"String" fnClassName]
        (ß this.v = v)
        (ß this.loader = (ClassLoader) RT.FN_LOADER_VAR.get())
        (ß this.fnClassName = fnClassName)
        (ß fn = nil)
        this
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß load())
        (ß fn.invoke(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2]
        (ß load())
        (ß fn.invoke(arg1, arg2))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß load())
        (ß fn.invoke(arg1, arg2, arg3))
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" args]
        (ß load())
        (ß fn.applyTo((ISeq) args))
    )

    #_method
    (§ defn- #_"void" load [this]
        (when (ß fn == nil)
            (try
                (ß fn = (IFn) Class.forName(fnClassName, true, loader).newInstance())
                (catch Exception e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
            (ß v.root = fn)
        )
        nil
    )

    #_method
    (§ defn #_"int" getRequiredArity [this]
        0
    )

    #_method
    (§ defn #_"IObj" withMeta [this, #_"IPersistentMap" meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ interface IAtom
    (§ abstract Object swap(IFn f))
    (§ abstract Object swap(IFn f, Object arg))
    (§ abstract Object swap(IFn f, Object arg1, Object arg2))
    (§ abstract Object swap(IFn f, Object x, Object y, ISeq args))
    (§ abstract boolean compareAndSet(Object oldv, Object newv))
    (§ abstract Object reset(Object newval))
)
)

(java-ns cloiure.lang.IAtom2

(§ interface IAtom2 (§ extends IAtom)
    (§ abstract IPersistentVector swapVals(IFn f))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg1, Object arg2))
    (§ abstract IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args))
    (§ abstract IPersistentVector resetVals(Object newv))
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ interface IBlockingDeref
    (§ abstract Object deref(long ms, Object timeoutValue))
)
)

(java-ns cloiure.lang.IChunk

(§ interface IChunk (§ extends Indexed)
    (§ abstract IChunk dropFirst())
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ interface IChunkedSeq (§ extends ISeq, Sequential)
    (§ abstract IChunk chunkedFirst())
    (§ abstract ISeq chunkedNext())
    (§ abstract ISeq chunkedMore())
)
)

(java-ns cloiure.lang.IDeref

(§ interface IDeref
    (§ abstract Object deref())
)
)

(java-ns cloiure.lang.IEditableCollection

(§ interface IEditableCollection
    (§ abstract ITransientCollection asTransient())
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ interface IExceptionInfo
    (§ abstract IPersistentMap getData())
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ interface IFn (§ extends Callable, Runnable)
    (§ abstract Object invoke())
    (§ abstract Object invoke(Object arg1))
    (§ abstract Object invoke(Object arg1, Object arg2))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args))

    (§ abstract Object applyTo(ISeq arglist))

    (§ interface L
        (§ abstract long invokePrim())
    )

    (§ interface D
        (§ abstract double invokePrim())
    )

    (§ interface OL
        (§ abstract long invokePrim(Object arg0))
    )

    (§ interface OD
        (§ abstract double invokePrim(Object arg0))
    )

    (§ interface LO
        (§ abstract Object invokePrim(long arg0))
    )

    (§ interface LL
        (§ abstract long invokePrim(long arg0))
    )

    (§ interface LD
        (§ abstract double invokePrim(long arg0))
    )

    (§ interface DO
        (§ abstract Object invokePrim(double arg0))
    )

    (§ interface DL
        (§ abstract long invokePrim(double arg0))
    )

    (§ interface DD
        (§ abstract double invokePrim(double arg0))
    )

    (§ interface OOL
        (§ abstract long invokePrim(Object arg0, Object arg1))
    )

    (§ interface OOD
        (§ abstract double invokePrim(Object arg0, Object arg1))
    )

    (§ interface OLO
        (§ abstract Object invokePrim(Object arg0, long arg1))
    )

    (§ interface OLL
        (§ abstract long invokePrim(Object arg0, long arg1))
    )

    (§ interface OLD
        (§ abstract double invokePrim(Object arg0, long arg1))
    )

    (§ interface ODO
        (§ abstract Object invokePrim(Object arg0, double arg1))
    )

    (§ interface ODL
        (§ abstract long invokePrim(Object arg0, double arg1))
    )

    (§ interface ODD
        (§ abstract double invokePrim(Object arg0, double arg1))
    )

    (§ interface LOO
        (§ abstract Object invokePrim(long arg0, Object arg1))
    )

    (§ interface LOL
        (§ abstract long invokePrim(long arg0, Object arg1))
    )

    (§ interface LOD
        (§ abstract double invokePrim(long arg0, Object arg1))
    )

    (§ interface LLO
        (§ abstract Object invokePrim(long arg0, long arg1))
    )

    (§ interface LLL
        (§ abstract long invokePrim(long arg0, long arg1))
    )

    (§ interface LLD
        (§ abstract double invokePrim(long arg0, long arg1))
    )

    (§ interface LDO
        (§ abstract Object invokePrim(long arg0, double arg1))
    )

    (§ interface LDL
        (§ abstract long invokePrim(long arg0, double arg1))
    )

    (§ interface LDD
        (§ abstract double invokePrim(long arg0, double arg1))
    )

    (§ interface DOO
        (§ abstract Object invokePrim(double arg0, Object arg1))
    )

    (§ interface DOL
        (§ abstract long invokePrim(double arg0, Object arg1))
    )

    (§ interface DOD
        (§ abstract double invokePrim(double arg0, Object arg1))
    )

    (§ interface DLO
        (§ abstract Object invokePrim(double arg0, long arg1))
    )

    (§ interface DLL
        (§ abstract long invokePrim(double arg0, long arg1))
    )

    (§ interface DLD
        (§ abstract double invokePrim(double arg0, long arg1))
    )

    (§ interface DDO
        (§ abstract Object invokePrim(double arg0, double arg1))
    )

    (§ interface DDL
        (§ abstract long invokePrim(double arg0, double arg1))
    )

    (§ interface DDD
        (§ abstract double invokePrim(double arg0, double arg1))
    )

    (§ interface OOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2))
    )

    (§ interface OOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2))
    )

    (§ interface OOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OODL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OODD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface OLDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface OLDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface ODOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface ODDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface ODDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface LOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LOLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LOLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LODO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LODL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LODD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LLOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LLDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LLDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LDOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface LDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface LDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface DOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DOLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DOLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DODO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DODL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DODD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DLOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DLDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DLDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DDOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface DDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface DDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface OOOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface OOOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface OOOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOODL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOODD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOLOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLOL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLOD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OOLDL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OOLDD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OODOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODOL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODOD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODLL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODLD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OODDL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OODDD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OLOOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOLO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLOLL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLOLD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLODO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLODL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLODD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLOL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLOD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLLDL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLLDD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLDOO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDOL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDOD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDLO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDLL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDLD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface OLDDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface OLDDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface ODOOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOLO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODOLL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODOLD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODODO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODODL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODODD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODLOO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLOL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLOD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLDO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODLDL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODLDD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODDOO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDOL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDOD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDLO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDLL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDLD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface ODDDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface ODDDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LOOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOOLL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOOLD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOODO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOODL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOODD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOLOO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLOL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLOD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLDO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LOLDL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LOLDD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LODOO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODOL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODOD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODLO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODLL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODLD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODDO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LODDL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LODDD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LLOOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOLO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLOLL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLOLD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLODO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLODL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLODD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLLOO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLOL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLOD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLDO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLLDL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLLDD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLDOO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDOL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDOD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDLO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDLL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDLD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LLDDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LLDDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LDOOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOLO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDOLL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDOLD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDODO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDODL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDODD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDLOO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLOL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLOD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLDO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDLDL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDLDD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDDOO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDOL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDOD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDLO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDLL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDLD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LDDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LDDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DOOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOOLL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOOLD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOODO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOODL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOODD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOLOO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLOL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLOD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLDO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DOLDL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DOLDD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DODOO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODOL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODOD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODLO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODLL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODLD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODDO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DODDL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DODDD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DLOOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOLO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLOLL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLOLD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLODO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLODL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLODD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLLOO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLOL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLOD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLDO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLLDL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLLDD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLDOO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDOL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDOD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDLO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDLL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDLD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DLDDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DLDDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DDOOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOLO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDOLL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDOLD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDODO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDODL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDODD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDLOO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLOL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLOD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLDO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDLDL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDLDD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDDOO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDOL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDOD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDLO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDLL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDLD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DDDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DDDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, double arg3))
    )
)
)

(java-ns cloiure.lang.IHashEq

(§ interface IHashEq
    (§ abstract int hasheq())
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ interface IKeywordLookup
    (§ abstract ILookupThunk getLookupThunk(Keyword k))
)
)

(java-ns cloiure.lang.IKVReduce

(§ interface IKVReduce
    (§ abstract Object kvreduce(IFn f, Object init))
)
)

(java-ns cloiure.lang.ILookup

(§ interface ILookup
    (§ abstract Object valAt(Object key))
    (§ abstract Object valAt(Object key, Object notFound))
)
)

(java-ns cloiure.lang.ILookupSite

(§ interface ILookupSite
    (§ abstract ILookupThunk fault(Object target))
)
)

(java-ns cloiure.lang.ILookupThunk

(§ interface ILookupThunk
    (§ abstract Object get(Object target))
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ interface IMapEntry (§ extends Map).Entry
    (§ abstract Object key())
    (§ abstract Object val())
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ interface IMapIterable
    (§ abstract Iterator keyIterator())
    (§ abstract Iterator valIterator())
)
)

(java-ns cloiure.lang.IMeta

(§ interface IMeta
    (§ abstract IPersistentMap meta())
)
)

(java-ns cloiure.lang.Indexed

(§ interface Indexed (§ extends Counted)
    (§ abstract Object nth(int i))
    (§ abstract Object nth(int i, Object notFound))
)
)

(java-ns cloiure.lang.IndexedSeq

(§ interface IndexedSeq (§ extends ISeq, Sequential, Counted)
    (§ abstract int index())
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

(class-ns Intrinsics (§ implements Opcodes)
    (§ defn- #_"Object[]" oa [#_"Object..." arr]
        arr
    )

    (§ def #_"IPersistentMap" ops (ß RT.map(
      #_map "public static double cloiure.lang.Numbers.add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.and(long,long)", LAND,
      #_map "public static long cloiure.lang.Numbers.or(long,long)", LOR,
      #_map "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
      #_map "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
      #_map "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
      #_map "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
      #_map "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
      #_map "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
      #_map "public static double cloiure.lang.Numbers.minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
      #_map "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
      #_map "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
      #_map "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
      #_map "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
      #_map "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
      #_map "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
      #_map "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
      #_map "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
      #_map "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

      #_map "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
      #_map "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
      #_map "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
      #_map "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
      #_map "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
      #_map "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
      #_map "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
      #_map "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
      #_map "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
      #_map "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

      #_map "public static double cloiure.lang.RT.doubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.doubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.doubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.doubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
      #_map "public static long cloiure.lang.RT.longCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.longCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(int)", I2L,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    )))

    ;; map to instructions terminated with comparator for branch to false
    (§ def #_"IPersistentMap" preds (ß RT.map(
      #_map "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
      #_map "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
      #_map "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
      #_map "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

      #_map "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    )))
)
)

(java-ns cloiure.lang.IObj

(§ interface IObj (§ extends IMeta)
    (§ abstract IObj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.IPending

(§ interface IPending
    (§ abstract boolean isRealized())
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ interface IPersistentCollection (§ extends Seqable)
    (§ abstract int count())
    (§ abstract IPersistentCollection cons(Object o))
    (§ abstract IPersistentCollection empty())
    (§ abstract boolean equiv(Object o))
)
)

(java-ns cloiure.lang.IPersistentList

(§ interface IPersistentList (§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ interface IPersistentMap (§ extends Iterable, Associative, Counted)
    (§ abstract IPersistentMap assoc(Object key, Object val))
    (§ abstract IPersistentMap assocEx(Object key, Object val))
    (§ abstract IPersistentMap without(Object key))
)
)

(java-ns cloiure.lang.IPersistentSet

(§ interface IPersistentSet (§ extends IPersistentCollection, Counted)
    (§ abstract IPersistentSet disjoin(Object key))
    (§ abstract boolean contains(Object key))
    (§ abstract Object get(Object key))
)
)

(java-ns cloiure.lang.IPersistentStack

(§ interface IPersistentStack (§ extends IPersistentCollection)
    (§ abstract Object peek())
    (§ abstract IPersistentStack pop())
)
)

(java-ns cloiure.lang.IPersistentVector

(§ interface IPersistentVector (§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    (§ abstract int length())
    (§ abstract IPersistentVector assocN(int i, Object val))
    (§ abstract IPersistentVector cons(Object o))
)
)

(java-ns cloiure.lang.IProxy

(§ interface IProxy
    (§ abstract void __initCloiureFnMappings(IPersistentMap m))
    (§ abstract void __updateCloiureFnMappings(IPersistentMap m))
    (§ abstract IPersistentMap __getCloiureFnMappings())
)
)

(java-ns cloiure.lang.IRecord

(§ interface IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ interface IReduce (§ extends IReduceInit)
    (§ abstract Object reduce(IFn f))
)
)

(java-ns cloiure.lang.IReduceInit

(§ interface IReduceInit
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IRef

(§ interface IRef (§ extends IDeref)
    (§ abstract void setValidator(IFn vf))
    (§ abstract IFn getValidator())
    (§ abstract IPersistentMap getWatches())
    (§ abstract IRef addWatch(Object key, IFn callback))
    (§ abstract IRef removeWatch(Object key))
)
)

(java-ns cloiure.lang.IReference

(§ interface IReference (§ extends IMeta)
    (§ abstract IPersistentMap alterMeta(IFn alter, ISeq args))
    (§ abstract IPersistentMap resetMeta(IPersistentMap m))
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ interface ISeq (§ extends IPersistentCollection)
    (§ abstract Object first())
    (§ abstract ISeq next())
    (§ abstract ISeq more())
    (§ abstract ISeq cons(Object o))
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (§ def- #_"Object" UNREALIZED_SEED (ß new Object()))
    (§ field- #_"IFn" f) ;; never nil
    (§ field- #_"Object" prevSeed)
    #_volatile
    (§ field- #_"Object" _seed) ;; lazily realized
    #_volatile
    (§ field- #_"ISeq" _next) ;; cached

    (§ constructor- #_"Iterate" Iterate [#_"IFn" f, #_"Object" prevSeed, #_"Object" seed]
        (ß this.f = f)
        (ß this.prevSeed = prevSeed)
        (ß this._seed = seed)
        this
    )

    (§ constructor- #_"Iterate" Iterate [#_"IPersistentMap" meta, #_"IFn" f, #_"Object" prevSeed, #_"Object" seed, #_"ISeq" next]
        (§ super(meta))
        (ß this.f = f)
        (ß this.prevSeed = prevSeed)
        (ß this._seed = seed)
        (ß this._next = next)
        this
    )

    (§ defn #_"ISeq" create [#_"IFn" f, #_"Object" seed]
        (ß new Iterate(f, nil, seed))
    )

    #_method
    (§ defn #_"boolean" isRealized [this]
        (ß (_seed != UNREALIZED_SEED))
    )

    #_method
    (§ defn #_"Object" first [this]
        (when (ß _seed == UNREALIZED_SEED)
            (ß _seed = f.invoke(prevSeed))
        )
        (ß _seed)
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß _next == nil)
            (ß _next = new Iterate(f, first(), UNREALIZED_SEED))
        )
        (ß _next)
    )

    #_method
    (§ defn #_"Iterate" withMeta [this, #_"IPersistentMap" meta]
        (ß new Iterate(meta, f, prevSeed, _seed, _next))
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" rf]
        (let [#_"Object" first (ß first())]
            (let [#_"Object" ret first]
                (let [#_"Object" v (ß f.invoke(first))]
                    (while true
                        (ß ret = rf.invoke(ret, v))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                        (ß v = f.invoke(v))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" rf, #_"Object" start]
        (let [#_"Object" ret start]
            (let [#_"Object" v (ß first())]
                (while true
                    (ß ret = rf.invoke(ret, v))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß v = f.invoke(v))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeq (§ extends ASeq)
    (§ field #_"Iterator" iter)
    (§ field #_"State" state)

    (class-ns State
        #_volatile
        (§ field #_"Object" val)
        #_volatile
        (§ field #_"Object" _rest)
    )

    (§ defn #_"IteratorSeq" create [#_"Iterator" iter]
        (when (ß iter.hasNext())
            (§ return (ß new IteratorSeq(iter)))
        )
        nil
    )

    (§ constructor #_"IteratorSeq" IteratorSeq [#_"Iterator" iter]
        (ß this.iter = iter)
        (ß state = new State())
        (ß this.state.val = state)
        (ß this.state._rest = state)
        this
    )

    (§ constructor #_"IteratorSeq" IteratorSeq [#_"IPersistentMap" meta, #_"Iterator" iter, #_"State" state]
        (§ super(meta))
        (ß this.iter = iter)
        (ß this.state = state)
        this
    )

    #_method
    (§ defn #_"Object" first [this]
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (ß state.val = iter.next())
                )
            )
        )
        (ß state.val)
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (ß state._rest = create(iter))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    #_method
    (§ defn #_"IteratorSeq" withMeta [this, #_"IPersistentMap" meta]
        (ß new IteratorSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ interface ITransientAssociative (§ extends ITransientCollection, ILookup)
    (§ abstract ITransientAssociative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ interface ITransientAssociative2 (§ extends ITransientAssociative)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
)
)

(java-ns cloiure.lang.ITransientCollection

(§ interface ITransientCollection
    (§ abstract ITransientCollection conj(Object val))
    (§ abstract IPersistentCollection persistent())
)
)

(java-ns cloiure.lang.ITransientMap

(§ interface ITransientMap (§ extends ITransientAssociative, Counted)
    (§ abstract ITransientMap assoc(Object key, Object val))
    (§ abstract ITransientMap without(Object key))
    (§ abstract IPersistentMap persistent())
)
)

(java-ns cloiure.lang.ITransientSet

(§ interface ITransientSet (§ extends ITransientCollection, Counted)
    (§ abstract ITransientSet disjoin(Object key))
    (§ abstract boolean contains(Object key))
    (§ abstract Object get(Object key))
)
)

(java-ns cloiure.lang.ITransientVector

(§ interface ITransientVector (§ extends ITransientAssociative, Indexed)
    (§ abstract ITransientVector assocN(int i, Object val))
    (§ abstract ITransientVector pop())
)
)

(java-ns cloiure.lang.IType

(§ interface IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (§ def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" table (ß new ConcurrentHashMap()))

    (§ def #_"ReferenceQueue" rq (ß new ReferenceQueue()))

    (§ field #_"Symbol" sym)
    (§ field #_"int" hasheq)
    #_transient
    (§ field #_"String" _str)

    (§ defn #_"Keyword" intern [#_"Symbol" sym]
        (let [#_"Keyword" k nil]
            (let [#_"Reference<Keyword>" existingRef (ß table.get(sym))]
                (when (ß existingRef == nil)
                    (ß Util.clearCache(rq, table))
                    (when (ß sym.meta() != nil)
                        (ß sym = (Symbol) sym.withMeta(nil))
                    )
                    (ß k = new Keyword(sym))
                    (ß existingRef = table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq)))
                )
                (when (ß existingRef == nil)
                    (§ return k)
                )
                (let [#_"Keyword" existingk (ß existingRef.get())]
                    (when (ß existingk != nil)
                        (§ return existingk)
                    )
                    ;; entry died in the interim, do over
                    (ß table.remove(sym, existingRef))
                    (ß intern(sym))
                )
            )
        )
    )

    (§ defn #_"Keyword" intern [#_"String" ns, #_"String" name]
        (ß intern(Symbol.intern(ns, name)))
    )

    (§ defn #_"Keyword" intern [#_"String" nsname]
        (ß intern(Symbol.intern(nsname)))
    )

    (§ constructor- #_"Keyword" Keyword [#_"Symbol" sym]
        (ß this.sym = sym)
        (ß hasheq = sym.hasheq() + 0x9e3779b9)
        this
    )

    (§ defn #_"Keyword" find [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" ref (ß table.get(sym))]
            (if (ß ref != nil)
                (do
                    (ß ref.get())
                )
                (do
                    nil
                )
            )
        )
    )

    (§ defn #_"Keyword" find [#_"String" ns, #_"String" name]
        (ß find(Symbol.intern(ns, name)))
    )

    (§ defn #_"Keyword" find [#_"String" nsname]
        (ß find(Symbol.intern(nsname)))
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (ß sym.hashCode() + 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" hasheq [this]
        hasheq
    )

    #_method
    (§ defn #_"String" toString [this]
        (when (ß _str == nil)
            (ß _str = (":" + sym))
        )
        (ß _str)
    )

    #_method
    (§ defn #_"Object" throwArity [this]
        (throw (ß new IllegalArgumentException("Wrong number of args passed to keyword: " + toString())))
    )

    #_method
    (§ defn #_"Object" call [this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"void" run [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"Object" invoke [this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"int" compareTo [this, #_"Object" o]
        (ß sym.compareTo(((Keyword) o).sym))
    )

    #_method
    (§ defn #_"String" getNamespace [this]
        (ß sym.getNamespace())
    )

    #_method
    (§ defn #_"String" getName [this]
        (ß sym.getName())
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_method
    (§ defn #_"Object" invoke [this, #_"Object" obj]
        (when (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this)))
        )
        (ß RT.get(obj, this))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" obj, #_"Object" notFound]
        (when (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this, notFound)))
        )
        (ß RT.get(obj, this, notFound))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" applyTo [this, #_"ISeq" arglist]
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (§ field #_"Keyword" k)

    (§ constructor #_"KeywordLookupSite" KeywordLookupSite [#_"Keyword" k]
        (ß this.k = k)
        this
    )

    #_method
    (§ defn #_"ILookupThunk" fault [this, #_"Object" target]
        (cond (ß target instanceof IKeywordLookup)
            (do
                (§ return (ß install(target)))
            )
            (ß target instanceof ILookup)
            (do
                (§ return (ß ilookupThunk(target.getClass())))
            )
        )
        this
    )

    #_method
    (§ defn #_"Object" get [this, #_"Object" target]
        (when (ß target instanceof IKeywordLookup || target instanceof ILookup)
            (§ return this)
        )
        (ß RT.get(target, k))
    )

    #_method
    (§ defn- #_"ILookupThunk" ilookupThunk [this, #_"Class" c]
        (ß new ILookupThunk()
            (§ reify
                #_method
                (§ defn #_"Object" get [this, #_"Object" target]
                    (when (ß target != nil && target.getClass() == c)
                        (§ return (ß ((ILookup) target).valAt(k)))
                    )
                    this
                )
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" install [this, #_"Object" target]
        (let [#_"ILookupThunk" t (ß ((IKeywordLookup)target).getLookupThunk(k))]
            (when (ß t != nil)
                (§ return t)
            )
            (ß ilookupThunk(target.getClass()))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(class-ns LazilyPersistentVector
    (§ defn #_"IPersistentVector" createOwning [#_"Object..." items]
        (when (ß items.length <= 32)
            (§ return (ß new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)))
        )
        (ß PersistentVector.create(items))
    )

    (§ defn #_"int" fcount [#_"Object" c]
        (when (ß c instanceof Counted)
            (§ return (ß ((Counted) c).count()))
        )
        (ß ((Collection)c).size())
    )

    (§ defn #_"IPersistentVector" create [#_"Object" obj]
        (cond (ß obj instanceof IReduceInit)
            (do
                (ß PersistentVector.create((IReduceInit) obj))
            )
            (ß obj instanceof ISeq)
            (do
                (ß PersistentVector.create(RT.seq(obj)))
            )
            (ß obj instanceof Iterable)
            (do
                (ß PersistentVector.create((Iterable)obj))
            )
            :else
            (do
                (ß createOwning(RT.toArray(obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (§ field- #_"IFn" fn)
    (§ field- #_"Object" sv)
    (§ field- #_"ISeq" s)

    (§ constructor #_"LazySeq" LazySeq [#_"IFn" fn]
        (ß this.fn = fn)
        this
    )

    (§ constructor- #_"LazySeq" LazySeq [#_"IPersistentMap" meta, #_"ISeq" s]
        (§ super(meta))
        (ß this.fn = nil)
        (ß this.s = s)
        this
    )

    #_method
    (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
        (ß new LazySeq(meta, seq()))
    )

    #_method
    (§ defn #_"Object" sval [this]
        (§ sync this
            (when (ß fn != nil)
                (ß sv = fn.invoke())
                (ß fn = nil)
            )
            (when (ß sv != nil)
                (§ return sv)
            )
            s
        )
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (§ sync this
            (ß sval())
            (when (ß sv != nil)
                (let [#_"Object" ls sv]
                    (ß sv = nil)
                    (while (ß ls instanceof LazySeq)
                        (ß ls = ((LazySeq)ls).sval())
                    )
                    (ß s = RT.seq(ls))
                )
            )
            s
        )
    )

    #_method
    (§ defn #_"int" count [this]
        (let [#_"int" c 0]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (ß ++c)
            )
            c
        )
    )

    #_method
    (§ defn #_"Object" first [this]
        (ß seq())
        (when (ß s == nil)
            (§ return nil)
        )
        (ß s.first())
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (ß seq())
        (when (ß s == nil)
            (§ return nil)
        )
        (ß s.next())
    )

    #_method
    (§ defn #_"ISeq" more [this]
        (ß seq())
        (when (ß s == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß s.more())
    )

    #_method
    (§ defn #_"ISeq" cons [this, #_"Object" o]
        (ß RT.cons(o, seq()))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß PersistentList.EMPTY)
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (if (ß s != nil)
                (do
                    (ß s.equiv(o))
                )
                (do
                    (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"ISeq" s (ß seq())]
            (when (ß s == nil)
                (§ return 1)
            )
            (ß Util.hash(s))
        )
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (ß Murmur3.hashOrdered(this))
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (if (ß s != nil)
                (do
                    (ß s.equals(o))
                )
                (do
                    (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" remove [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" clear [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" retainAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" removeAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" containsAll [this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [this, #_"Object" o]
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß new SeqIterator(this))
    )

    #_method
    (§ defn- #_"List" reify [this]
        (ß new ArrayList(this))
    )

    #_method
    (§ defn #_"List" subList [this, #_"int" fromIndex, #_"int" toIndex]
        (ß reify().subList(fromIndex, toIndex))
    )

    #_method
    (§ defn #_"Object" set [this, #_"int" index, #_"Object" element]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"Object" remove [this, #_"int" index]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"int" indexOf [this, #_"Object" o]
        (let [#_"ISeq" s (ß seq())]
            (loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                (when (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [this, #_"Object" o]
        (ß reify().lastIndexOf(o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [this, #_"int" index]
        (ß reify().listIterator(index))
    )

    #_method
    (§ defn #_"Object" get [this, #_"int" index]
        (ß RT.nth(this, index))
    )

    #_method
    (§ defn #_"void" add [this, #_"int" index, #_"Object" element]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"int" index, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" isRealized [this]
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.

    (§ def- #_"int" newline (ß (int) \newline))

    (§ field- #_"boolean" _atLineStart (ß true))
    (§ field- #_"boolean" _prev)
    (§ field- #_"int" _columnNumber (ß 1))

    (§ constructor #_"LineNumberingPushbackReader" LineNumberingPushbackReader [#_"Reader" r]
        (§ super(new LineNumberReader(r)))
        this
    )

    (§ constructor #_"LineNumberingPushbackReader" LineNumberingPushbackReader [#_"Reader" r, #_"int" size]
        (§ super(new LineNumberReader(r, size)))
        this
    )

    #_method
    (§ defn #_"int" getLineNumber [this]
        (ß ((LineNumberReader) in).getLineNumber() + 1)
    )

    #_method
    (§ defn #_"void" setLineNumber [this, #_"int" line]
        (ß ((LineNumberReader) in).setLineNumber(line - 1))
        nil
    )

    #_method
    (§ defn #_"int" getColumnNumber [this]
        (ß _columnNumber)
    )

    #_method
    (§ defn #_"int" read [this] (§ throws IOException)
        (let [#_"int" c (ß super.read())]
            (ß _prev = _atLineStart)
            (if (ß (c == newline) || (c == -1))
                (do
                    (ß _atLineStart = true)
                    (ß _columnNumber = 1)
                )
                (do
                    (ß _atLineStart = false)
                    (ß _columnNumber++)
                )
            )
            c
        )
    )

    #_method
    (§ defn #_"void" unread [this, #_"int" c] (§ throws IOException)
        (ß super.unread(c))
        (ß _atLineStart = _prev)
        (ß _columnNumber--)
        nil
    )

    #_method
    (§ defn #_"String" readLine [this] (§ throws IOException)
        (let [#_"int" c (ß read())]
            (§ let [#_"String" line]
                (§ switch c
                    (§ case -1)
                    (do
                        (ß line = nil)
                        (§ break )
                    )
                    (§ case newline)
                    (do
                        (ß line = "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" first (ß String.valueOf((char) c))]
                            (let [#_"String" rest (ß ((LineNumberReader)in).readLine())]
                                (ß line = (rest == nil) ? first :or first + rest)
                                (ß _prev = false)
                                (ß _atLineStart = true)
                                (ß _columnNumber = 1)
                                (§ break )
                            )
                        )
                    )
                )
                line
            )
        )
    )

    #_method
    (§ defn #_"boolean" atLineStart [this]
        (ß _atLineStart)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns LispReader
    (§ def #_"Symbol" QUOTE (ß Symbol.intern("quote")))
    (§ def #_"Symbol" THE_VAR (ß Symbol.intern("var")))

    (§ def #_"Symbol" UNQUOTE (ß Symbol.intern("cloiure.core", "unquote")))
    (§ def #_"Symbol" UNQUOTE_SPLICING (ß Symbol.intern("cloiure.core", "unquote-splicing")))
    (§ def #_"Symbol" CONCAT (ß Symbol.intern("cloiure.core", "concat")))
    (§ def #_"Symbol" SEQ (ß Symbol.intern("cloiure.core", "seq")))
    (§ def #_"Symbol" LIST (ß Symbol.intern("cloiure.core", "list")))
    (§ def #_"Symbol" APPLY (ß Symbol.intern("cloiure.core", "apply")))
    (§ def #_"Symbol" HASHMAP (ß Symbol.intern("cloiure.core", "hash-map")))
    (§ def #_"Symbol" HASHSET (ß Symbol.intern("cloiure.core", "hash-set")))
    (§ def #_"Symbol" VECTOR (ß Symbol.intern("cloiure.core", "vector")))
    (§ def #_"Symbol" WITH_META (ß Symbol.intern("cloiure.core", "with-meta")))
    (§ def #_"Symbol" META (ß Symbol.intern("cloiure.core", "meta")))
    (§ def #_"Symbol" DEREF (ß Symbol.intern("cloiure.core", "deref")))
    (§ def #_"Symbol" READ_COND (ß Symbol.intern("cloiure.core", "read-cond")))
    (§ def #_"Symbol" READ_COND_SPLICING (ß Symbol.intern("cloiure.core", "read-cond-splicing")))
    (§ def #_"Keyword" UNKNOWN (ß Keyword.intern(nil, "unknown")))

    (§ def #_"IFn[]" macros (ß new IFn[256]))
    (§ def #_"IFn[]" dispatchMacros (ß new IFn[256]))

    (§ def #_"Pattern" symbolPat (ß Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")))
    (§ def #_"Pattern" intPat (ß Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")))
    (§ def #_"Pattern" ratioPat (ß Pattern.compile("([-+]?[0-9]+)/([0-9]+)")))
    (§ def #_"Pattern" floatPat (ß Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")))

    ;; symbol->gensymbol
    (§ def #_"Var" GENSYM_ENV (ß Var.create(nil).setDynamic()))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" ARG_ENV (ß Var.create(nil).setDynamic()))
    (§ def #_"IFn" ctorReader (ß new CtorReader()))

    ;; Dynamic var set to true in a read-cond context
    (§ def #_"Var" READ_COND_ENV (ß Var.create(nil).setDynamic()))

    (§ static
        (ß macros[\"] = new StringReader()) ;; oops! "
        (ß macros[\;] = new CommentReader())
        (ß macros[\'] = new WrappingReader(QUOTE))
        (ß macros[\@] = new WrappingReader(DEREF))
        (ß macros[\^] = new MetaReader())
        (ß macros[\`] = new SyntaxQuoteReader())
        (ß macros[\~] = new UnquoteReader())
        (ß macros[\(] = new ListReader())
        (ß macros[\)] = new UnmatchedDelimiterReader())
        (ß macros[\[] = new VectorReader())
        (ß macros[\]] = new UnmatchedDelimiterReader())
        (ß macros[\{] = new MapReader())
        (ß macros[\}] = new UnmatchedDelimiterReader())
        (ß macros[\\] = new CharacterReader())
        (ß macros[\%] = new ArgReader())
        (ß macros[\#] = new DispatchReader())

        (ß dispatchMacros[\^] = new MetaReader())
        (ß dispatchMacros[\#] = new SymbolicValueReader())
        (ß dispatchMacros[\'] = new VarReader())
        (ß dispatchMacros[\"] = new RegexReader()) ;; oops! "
        (ß dispatchMacros[\(] = new FnReader())
        (ß dispatchMacros[\{] = new SetReader())
        (ß dispatchMacros[\=] = new EvalReader())
        (ß dispatchMacros[\!] = new CommentReader())
        (ß dispatchMacros[\<] = new UnreadableReader())
        (ß dispatchMacros[\_] = new DiscardReader())
        (ß dispatchMacros[\?] = new ConditionalReader())
        (ß dispatchMacros[\:] = new NamespaceMapReader())
    )

    (§ interface Resolver
        (§ abstract Symbol currentNS())
        (§ abstract Symbol resolveClass(Symbol sym))
        (§ abstract Symbol resolveAlias(Symbol sym))
        (§ abstract Symbol resolveVar(Symbol sym))
    )

    (§ defn #_"boolean" isWhitespace [#_"int" ch]
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn #_"void" unread [#_"PushbackReader" r, #_"int" ch]
        (when (ß ch != -1)
            (try
                (ß r.unread(ch))
                (catch IOException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )
        nil
    )

    (class-ns ReaderException (§ extends RuntimeException)
        (§ field #_"int" line)
        (§ field #_"int" column)

        (§ constructor #_"ReaderException" ReaderException [#_"int" line, #_"int" column, #_"Throwable" cause]
            (§ super(cause))
            (ß this.line = line)
            (ß this.column = column)
            this
        )
    )

    (§ defn #_"int" read1 [#_"Reader" r]
        (try
            (ß r.read())
            (catch IOException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" OPT_EOF (ß Keyword.intern(nil, "eof")))
    (§ def #_"Keyword" OPT_FEATURES (ß Keyword.intern(nil, "features")))
    (§ def #_"Keyword" OPT_READ_COND (ß Keyword.intern(nil, "read-cond")))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" EOFTHROW (ß Keyword.intern(nil, "eofthrow")))

    ;; Platform features - always installed
    (§ def- #_"Keyword" PLATFORM_KEY (ß Keyword.intern(nil, "cli")))
    (§ def- #_"Object" PLATFORM_FEATURES (ß PersistentHashSet.create(PLATFORM_KEY)))

    ;; Reader conditional options - use with :read-cond
    (§ def #_"Keyword" COND_ALLOW (ß Keyword.intern(nil, "allow")))
    (§ def #_"Keyword" COND_PRESERVE (ß Keyword.intern(nil, "preserve")))

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"Object" opts]
        (let [#_"boolean" eofIsError true]
            (let [#_"Object" eofValue nil]
                (when (ß opts != nil && opts instanceof IPersistentMap)
                    (let [#_"Object" eof (ß ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW))]
                        (when (ß !EOFTHROW.equals(eof))
                            (ß eofIsError = false)
                            (ß eofValue = eof)
                        )
                    )
                )
                (ß read(r, eofIsError, eofValue, false, opts))
            )
        )
    )

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive]
        (ß read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY))
    )

    (§ defn #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" opts]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, nil, (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" opts, #_"Object" pendingForms]
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- #_"Object" ensurePending [#_"Object" pendingForms]
        (if (ß pendingForms == nil)
            (do
                (ß new LinkedList())
            )
            (do
                pendingForms
            )
        )
    )

    (§ defn- #_"Object" installPlatformFeature [#_"Object" opts]
        (if (ß opts == nil)
            (do
                (ß RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
            )
            (do
                (let [#_"IPersistentMap" mopts (ß (IPersistentMap) opts)]
                    (let [#_"Object" features (ß mopts.valAt(OPT_FEATURES))]
                        (if (ß features == nil)
                            (do
                                (ß mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
                            )
                            (do
                                (ß mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"Object" read [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"Character" returnOn, #_"Object" returnOnValue, #_"boolean" isRecursive, #_"Object" opts, #_"Object" pendingForms, #_"Resolver" resolver]
        (when (ß RT.READEVAL.deref() == UNKNOWN)
            (throw (ß Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown")))
        )

        (ß opts = installPlatformFeature(opts))

        (try
            (while true
                (when (ß pendingForms instanceof List && !((List)pendingForms).isEmpty())
                    (§ return (ß ((List)pendingForms).remove(0)))
                )

                (let [#_"int" ch (ß read1(r))]
                    (while (ß isWhitespace(ch))
                        (ß ch = read1(r))
                    )

                    (when (ß ch == -1)
                        (when eofIsError
                            (throw (ß Util.runtimeException("EOF while reading")))
                        )
                        (§ return eofValue)
                    )

                    (when (ß returnOn != nil && (returnOn.charValue() == ch))
                        (§ return returnOnValue)
                    )

                    (when (ß Character.isDigit(ch))
                        (let [#_"Object" n (ß readNumber(r, (char) ch))]
                            (§ return n)
                        )
                    )

                    (let [#_"IFn" macroFn (ß getMacro(ch))]
                        (when (ß macroFn != nil)
                            (let [#_"Object" ret (ß macroFn.invoke(r, (char) ch, opts, pendingForms))]
                                ;; no op macros return the reader
                                (when (ß ret == r)
                                    (§ continue )
                                )
                                (§ return ret)
                            )
                        )

                        (when (ß ch == \+ || ch == \-)
                            (let [#_"int" ch2 (ß read1(r))]
                                (when (ß Character.isDigit(ch2))
                                    (ß unread(r, ch2))
                                    (let [#_"Object" n (ß readNumber(r, (char) ch))]
                                        (§ return n)
                                    )
                                )
                                (ß unread(r, ch2))
                            )
                        )

                        (let [#_"String" token (ß readToken(r, (char) ch))]
                            (§ return (ß interpretToken(token, resolver)))
                        )
                    )
                )
            )
            (catch Exception e
                (when (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                    (throw (ß Util.sneakyThrow(e)))
                )
                (let [#_"LineNumberingPushbackReader" rdr (ß (LineNumberingPushbackReader) r)]
                    (throw (ß new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)))
                )
            )
        )
    )

    (§ defn- #_"String" readToken [#_"PushbackReader" r, #_"char" initch]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (ß unread(r, ch))
                        (§ return (ß sb.toString()))
                    )
                    (ß sb.append((char) ch))
                )
            )
        )
    )

    (§ defn- #_"Object" readNumber [#_"PushbackReader" r, #_"char" initch]
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                        (ß unread(r, ch))
                        (§ break )
                    )
                    (ß sb.append((char) ch))
                )
            )

            (let [#_"String" s (ß sb.toString())]
                (let [#_"Object" n (ß matchNumber(s))]
                    (when (ß n == nil)
                        (throw (ß new NumberFormatException("Invalid number: " + s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"String" token, #_"int" offset, #_"int" length, #_"int" base]
        (when (ß token.length() != offset + length)
            (throw (ß new IllegalArgumentException("Invalid unicode character: \\" + token)))
        )
        (let [#_"int" uc 0]
            (loop-when-recur [(ß int i = offset)] (ß i < offset + length) [(ß ++i)]
                (let [#_"int" d (ß Character.digit(token.charAt(i), base))]
                    (when (ß d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + token.charAt(i))))
                    )
                    (ß uc = uc * base + d)
                )
            )
            (ß (char) uc)
        )
    )

    (§ defn- #_"int" readUnicodeChar [#_"PushbackReader" r, #_"int" initch, #_"int" base, #_"int" length, #_"boolean" exact]
        (let [#_"int" uc (ß Character.digit(initch, base))]
            (when (ß uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) initch)))
            )
            (let [#_"int" i 1]
                (loop-when-recur [(ß )] (ß i < length) [(ß ++i)]
                    (let [#_"int" ch (ß read1(r))]
                        (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                            (ß unread(r, ch))
                            (§ break )
                        )
                        (let [#_"int" d (ß Character.digit(ch, base))]
                            (when (ß d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ch)))
                            )
                            (ß uc = uc * base + d)
                        )
                    )
                )
                (when (ß i != length && exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)))
                )
                uc
            )
        )
    )

    (§ defn- #_"Object" interpretToken [#_"String" s, #_"Resolver" resolver]
        (cond (ß s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß s.equals("true"))
            (do
                (§ return (ß RT.T))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß RT.F))
            )
        )
        (let [#_"Object" ret nil]
            (ß ret = matchSymbol(s, resolver))
            (when (ß ret != nil)
                (§ return ret)
            )

            (throw (ß Util.runtimeException("Invalid token: " + s)))
        )
    )

    (§ defn- #_"Object" matchSymbol [#_"String" s, #_"Resolver" resolver]
        (let [#_"Matcher" m (ß symbolPat.matcher(s))]
            (when (ß m.matches())
                (let [#_"int" gc (ß m.groupCount())]
                    (let [#_"String" ns (ß m.group(1))]
                        (let [#_"String" name (ß m.group(2))]
                            (when (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß s.startsWith("::"))
                                (let [#_"Symbol" ks (ß Symbol.intern(s.substring(2)))]
                                    (if (ß resolver != nil)
                                        (do
                                            (§ let [#_"Symbol" nsym]
                                                (if (ß ks.ns != nil)
                                                    (do
                                                        (ß nsym = resolver.resolveAlias(Symbol.intern(ks.ns)))
                                                    )
                                                    (do
                                                        (ß nsym = resolver.currentNS())
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (ß nsym != nil)
                                                    (do
                                                        (§ return (ß Keyword.intern(nsym.name, ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" kns]
                                                (if (ß ks.ns != nil)
                                                    (do
                                                        (ß kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns)))
                                                    )
                                                    (do
                                                        (ß kns = Compiler.currentNS())
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (ß kns != nil)
                                                    (do
                                                        (§ return (ß Keyword.intern(kns.name.name, ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" isKeyword (ß (s.charAt(0) == \:))]
                                (let [#_"Symbol" sym (ß Symbol.intern(s.substring(isKeyword ? 1 :or 0)))]
                                    (when isKeyword
                                        (§ return (ß Keyword.intern(sym)))
                                    )
                                    (§ return sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- #_"Object" matchNumber [#_"String" s]
        (let [#_"Matcher" m (ß intPat.matcher(s))]
            (when (ß m.matches())
                (when (ß m.group(2) != nil)
                    (when (ß m.group(8) != nil)
                        (§ return (ß BigInt.ZERO))
                    )
                    (§ return (ß Numbers.num(0)))
                )
                (let [#_"boolean" negate (ß m.group(1).equals("-"))]
                    (§ let [#_"String" n]
                        (let [#_"int" radix 10]
                            (cond (ß (n = m.group(3)) != nil)
                                (do
                                    (ß radix = 10)
                                )
                                (ß (n = m.group(4)) != nil)
                                (do
                                    (ß radix = 16)
                                )
                                (ß (n = m.group(5)) != nil)
                                (do
                                    (ß radix = 8)
                                )
                                (ß (n = m.group(7)) != nil)
                                (do
                                    (ß radix = Integer.parseInt(m.group(6)))
                                )
                            )
                            (when (ß n == nil)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" bn (ß new BigInteger(n, radix))]
                                (when negate
                                    (ß bn = bn.negate())
                                )
                                (when (ß m.group(8) != nil)
                                    (§ return (ß BigInt.fromBigInteger(bn)))
                                )
                                (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
                            )
                        )
                    )
                )
            )
            (ß m = floatPat.matcher(s))
            (when (ß m.matches())
                (when (ß m.group(4) != nil)
                    (§ return (ß new BigDecimal(m.group(1))))
                )
                (§ return (ß Double.parseDouble(s)))
            )
            (ß m = ratioPat.matcher(s))
            (when (ß m.matches())
                (let [#_"String" numerator (ß m.group(1))]
                    (when (ß numerator.startsWith("+"))
                        (ß numerator = numerator.substring(1))
                    )
                    (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- #_"IFn" getMacro [#_"int" ch]
        (when (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- #_"boolean" isMacro [#_"int" ch]
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- #_"boolean" isTerminatingMacro [#_"int" ch]
        (ß (ch != \# && ch != \' && ch != \% && isMacro(ch)))
    )

    (class-ns RegexReader (§ extends AFn)
        (§ def #_"StringReader" stringrdr (ß new StringReader()))

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" doublequote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading regex")))
                        )
                        (ß sb.append((char) ch))
                        (when (ß ch == \\) ;; escape
                            (ß ch = read1(r))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading regex")))
                            )
                            (ß sb.append((char) ch))
                        )
                    )
                    (ß Pattern.compile(sb.toString()))
                )
            )
        )
    )

    (class-ns StringReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" doublequote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading string")))
                        )
                        (when (ß ch == \\) ;; escape
                            (ß ch = read1(r))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading string")))
                            )
                            (§ switch ch
                                (§ case \t)
                                (do
                                    (ß ch = \tab)
                                    (§ break )
                                )
                                (§ case \r)
                                (do
                                    (ß ch = \return)
                                    (§ break )
                                )
                                (§ case \n)
                                (do
                                    (ß ch = \newline)
                                    (§ break )
                                )
                                (§ case \\)
                                (do
                                    (§ break )
                                )
                                (§ case \") ;; oops! "
                                (do
                                    (§ break )
                                )
                                (§ case \b)
                                (do
                                    (ß ch = \backspace)
                                    (§ break )
                                )
                                (§ case \f)
                                (do
                                    (ß ch = \formfeed)
                                    (§ break )
                                )
                                (§ case \u)
                                (do
                                    (ß ch = read1(r))
                                    (when (ß Character.digit(ch, 16) == -1)
                                        (throw (ß Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)))
                                    )
                                    (ß ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (if (ß Character.isDigit(ch))
                                        (do
                                            (ß ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                            (when (ß ch > 0377)
                                                (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                            )
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Unsupported escape character: \\" + (char) ch)))
                                        )
                                    )
                                    (§ break )
                                )
                            )
                        )
                        (ß sb.append((char) ch))
                    )
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns CommentReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" semicolon, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"Reader" r (ß (Reader) reader)]
                (§ let [#_"int" ch]
                    (§ loop
                        (ß ch = read1(r))
                        (§ recur-if (ch != -1 && ch != \newline && ch != \return))
                    )
                    r
                )
            )
        )
    )

    (class-ns DiscardReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" underscore, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))
                r
            )
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    (class-ns NamespaceMapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" colon, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"boolean" auto false]
                    (let [#_"int" autoChar (ß read1(r))]
                        (if (ß autoChar == \:)
                            (do
                                (ß auto = true)
                            )
                            (do
                                (ß unread(r, autoChar))
                            )
                        )

                        (let [#_"Object" sym nil]
                            (let [#_"int" nextChar (ß read1(r))]
                                (cond (ß isWhitespace(nextChar)) ;; the #:: { } case or an error
                                    (do
                                        (if auto
                                            (do
                                                (while (ß isWhitespace(nextChar))
                                                    (ß nextChar = read1(r))
                                                )
                                                (when (ß nextChar != \{)
                                                    (ß unread(r, nextChar))
                                                    (throw (ß Util.runtimeException("Namespaced map must specify a namespace")))
                                                )
                                            )
                                            (do
                                                (ß unread(r, nextChar))
                                                (throw (ß Util.runtimeException("Namespaced map must specify a namespace")))
                                            )
                                        )
                                    )
                                    (ß nextChar != \{) ;; #:foo { } or #::foo { }
                                    (do
                                        (ß unread(r, nextChar))
                                        (ß sym = read(r, true, nil, false, opts, pendingForms))
                                        (ß nextChar = read1(r))
                                        (while (ß isWhitespace(nextChar))
                                            (ß nextChar = read1(r))
                                        )
                                    )
                                )
                                (when (ß nextChar != \{)
                                    (throw (ß Util.runtimeException("Namespaced map must specify a map")))
                                )

                                ;; Resolve autoresolved ns
                                (§ let [#_"String" ns]
                                    (cond auto
                                        (do
                                            (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                                                (cond (ß sym == nil)
                                                    (do
                                                        (if (ß resolver != nil)
                                                            (do
                                                                (ß ns = resolver.currentNS().name)
                                                            )
                                                            (do
                                                                (ß ns = Compiler.currentNS().getName().getName())
                                                            )
                                                        )
                                                    )
                                                    (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                                                    (do
                                                        (throw (ß Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)))
                                                    )
                                                    :else
                                                    (do
                                                        (§ let [#_"Symbol" resolvedNS]
                                                            (if (ß resolver != nil)
                                                                (do
                                                                    (ß resolvedNS = resolver.resolveAlias((Symbol) sym))
                                                                )
                                                                (do
                                                                    (let [#_"Namespace" rns (ß Compiler.currentNS().lookupAlias((Symbol)sym))]
                                                                        (ß resolvedNS = (rns != nil) ? rns.getName() :or nil)
                                                                    )
                                                                )
                                                            )

                                                            (if (ß resolvedNS == nil)
                                                                (do
                                                                    (throw (ß Util.runtimeException("Unknown auto-resolved namespace alias: " + sym)))
                                                                )
                                                                (do
                                                                    (ß ns = resolvedNS.getName())
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                                        (do
                                            (throw (ß Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)))
                                        )
                                        :else
                                        (do
                                            (ß ns = ((Symbol)sym).getName())
                                        )
                                    )

                                    ;; Read map
                                    (let [#_"List" kvs (ß readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))]
                                        (when (ß (kvs.size() & 1) == 1)
                                            (throw (ß Util.runtimeException("Namespaced map literal must contain an even number of forms")))
                                        )

                                        ;; Construct output map
                                        (let [#_"Object[]" a (ß new Object[kvs.size()])]
                                            (let [#_"Iterator" iter (ß kvs.iterator())]
                                                (loop-when-recur [(ß int i = 0)] (ß iter.hasNext()) [(ß i += 2)]
                                                    (let [#_"Object" key (ß iter.next())]
                                                        (let [#_"Object" val (ß iter.next())]
                                                            (cond (ß key instanceof Keyword)
                                                                (do
                                                                    (let [#_"Keyword" kw (ß (Keyword) key)]
                                                                        (cond (ß kw.getNamespace() == nil)
                                                                            (do
                                                                                (ß key = Keyword.intern(ns, kw.getName()))
                                                                            )
                                                                            (ß kw.getNamespace().equals("_"))
                                                                            (do
                                                                                (ß key = Keyword.intern(nil, kw.getName()))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (ß key instanceof Symbol)
                                                                (do
                                                                    (let [#_"Symbol" s (ß (Symbol) key)]
                                                                        (cond (ß s.getNamespace() == nil)
                                                                            (do
                                                                                (ß key = Symbol.intern(ns, s.getName()))
                                                                            )
                                                                            (ß s.getNamespace().equals("_"))
                                                                            (do
                                                                                (ß key = Symbol.intern(nil, s.getName()))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (ß a[i] = key)
                                                            (ß a[i + 1] = val)
                                                        )
                                                    )
                                                )
                                                (ß RT.map(a))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SymbolicValueReader (§ extends AFn)
        (§ def #_"IPersistentMap" specials (ß PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        )))

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (when (ß !(o instanceof Symbol))
                        (throw (ß Util.runtimeException("Invalid token: ##" + o)))
                    )
                    (when (ß !(specials.containsKey(o)))
                        (throw (ß Util.runtimeException("Unknown symbolic value: ##" + o)))
                    )

                    (ß specials.valAt(o))
                )
            )
        )
    )

    (class-ns WrappingReader (§ extends AFn)
        (§ field #_"Symbol" sym)

        (§ constructor #_"WrappingReader" WrappingReader [#_"Symbol" sym]
            (ß this.sym = sym)
            this
        )

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(sym, o))
                )
            )
        )
    )

    (class-ns DeprecatedWrappingReader (§ extends AFn)
        (§ field #_"Symbol" sym)
        (§ field #_"String" macro)

        (§ constructor #_"DeprecatedWrappingReader" DeprecatedWrappingReader [#_"Symbol" sym, #_"String" macro]
            (ß this.sym = sym)
            (ß this.macro = macro)
            this
        )

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (ß System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead"))
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(sym, o))
                )
            )
        )
    )

    (class-ns VarReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" quote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(THE_VAR, o))
                )
            )
        )
    )

    (class-ns DispatchReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" hash, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"int" ch (ß read1((Reader) reader))]
                (when (ß ch == -1)
                    (throw (ß Util.runtimeException("EOF while reading character")))
                )
                (let [#_"IFn" fn (ß dispatchMacros[ch])]
                    ;; Try the ctor reader first
                    (when (ß fn == nil)
                        (ß unread((PushbackReader) reader, ch))
                        (ß pendingForms = ensurePending(pendingForms))
                        (let [#_"Object" result (ß ctorReader.invoke(reader, ch, opts, pendingForms))]
                            (if (ß result != nil)
                                (do
                                    (§ return result)
                                )
                                (do
                                    (throw (ß Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))))
                                )
                            )
                        )
                    )
                    (ß fn.invoke(reader, ch, opts, pendingForms))
                )
            )
        )
    )

    (§ defn #_"Symbol" garg [#_"int" n]
        (ß Symbol.intern(nil, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#"))
    )

    (class-ns FnReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" lparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (when (ß ARG_ENV.deref() != nil)
                    (throw (ß new IllegalStateException("Nested #()s are not allowed")))
                )
                (try
                    (ß Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY)))
                    (ß unread(r, \())
                    (let [#_"Object" form (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                            (let [#_"PersistentTreeMap" argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
                                (let [#_"ISeq" rargs (ß argsyms.rseq())]
                                    (when (ß rargs != nil)
                                        (let [#_"int" higharg (ß (Integer) ((Map.Entry) rargs.first()).getKey())]
                                            (when (ß higharg > 0)
                                                (loop-when-recur [(ß int i = 1)] (ß i <= higharg) [(ß ++i)]
                                                    (let [#_"Object" sym (ß argsyms.valAt(i))]
                                                        (when (ß sym == nil)
                                                            (ß sym = garg(i))
                                                        )
                                                        (ß args = args.cons(sym))
                                                    )
                                                )
                                            )
                                            (let [#_"Object" restsym (ß argsyms.valAt(-1))]
                                                (when (ß restsym != nil)
                                                    (ß args = args.cons(Compiler._AMP_))
                                                    (ß args = args.cons(restsym))
                                                )
                                            )
                                        )
                                    )
                                    (ß RT.list(Compiler.FN, args, form))
                                )
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn #_"Symbol" registerArg [#_"int" n]
        (let [#_"PersistentTreeMap" argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
            (when (ß argsyms == nil)
                (throw (ß new IllegalStateException("arg literal not in #()")))
            )
            (let [#_"Symbol" ret (ß (Symbol) argsyms.valAt(n))]
                (when (ß ret == nil)
                    (ß ret = garg(n))
                    (ß ARG_ENV.set(argsyms.assoc(n, ret)))
                )
                ret
            )
        )
    )

    (class-ns ArgReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" pct, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (when (ß ARG_ENV.deref() == nil)
                    (§ return (ß interpretToken(readToken(r, \%), nil)))
                )
                (let [#_"int" ch (ß read1(r))]
                    (ß unread(r, ch))
                    ;; % alone is first arg
                    (when (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (§ return (ß registerArg(1)))
                    )
                    (let [#_"Object" n (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (when (ß n.equals(Compiler._AMP_))
                            (§ return (ß registerArg(-1)))
                        )
                        (when (ß !(n instanceof Number))
                            (throw (ß new IllegalStateException("arg literal must be %, %& or %integer")))
                        )
                        (ß registerArg(((Number) n).intValue()))
                    )
                )
            )
        )
    )

    (class-ns MetaReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" caret, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (ß pendingForms = ensurePending(pendingForms))
                        (let [#_"Object" meta (ß read(r, true, nil, true, opts, pendingForms))]
                            (cond (ß meta instanceof Symbol || meta instanceof String)
                                (do
                                    (ß meta = RT.map(RT.TAG_KEY, meta))
                                )
                                (ß meta instanceof Keyword)
                                (do
                                    (ß meta = RT.map(meta, RT.T))
                                )
                                (ß !(meta instanceof IPersistentMap))
                                (do
                                    (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                                )
                            )

                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (if (ß o instanceof IMeta)
                                    (do
                                        (when (ß line != -1 && o instanceof ISeq)
                                            (ß meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                                        )
                                        (when (ß o instanceof IReference)
                                            (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                                            (§ return o)
                                        )
                                        (let [#_"Object" ometa (ß RT.meta(o))]
                                            (loop-when-recur [(ß ISeq s = RT.seq(meta))] (ß s != nil) [(ß s = s.next())]
                                                (let [#_"IMapEntry" kv (ß (IMapEntry) s.first())]
                                                    (ß ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                                                )
                                            )
                                            (ß ((IObj) o).withMeta((IPersistentMap) ometa))
                                        )
                                    )
                                    (do
                                        (throw (ß new IllegalArgumentException("Metadata can only be applied to IMetas")))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SyntaxQuoteReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" backquote, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (try
                    (ß Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY)))

                    (let [#_"Object" form (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (ß syntaxQuote(form))
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )

        (§ defn #_"Object" syntaxQuote [#_"Object" form]
            (§ let [#_"Object" ret]
                (cond (ß Compiler.isSpecial(form))
                    (do
                        (ß ret = RT.list(Compiler.QUOTE, form))
                    )
                    (ß form instanceof Symbol)
                    (do
                        (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                            (let [#_"Symbol" sym (ß (Symbol) form)]
                                (cond (ß sym.ns == nil && sym.name.endsWith("#"))
                                    (do
                                        (let [#_"IPersistentMap" gmap (ß (IPersistentMap) GENSYM_ENV.deref())]
                                            (when (ß gmap == nil)
                                                (throw (ß new IllegalStateException("Gensym literal not in syntax-quote")))
                                            )
                                            (let [#_"Symbol" gs (ß (Symbol) gmap.valAt(sym))]
                                                (when (ß gs == nil)
                                                    (ß GENSYM_ENV.set(gmap.assoc(sym, gs = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__"))))
                                                )
                                                (ß sym = gs)
                                            )
                                        )
                                    )
                                    (ß sym.ns == nil && sym.name.endsWith("."))
                                    (do
                                        (let [#_"Symbol" csym (ß Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1)))]
                                            (if (ß resolver != nil)
                                                (do
                                                    (let [#_"Symbol" rc (ß resolver.resolveClass(csym))]
                                                        (when (ß rc != nil)
                                                            (ß csym = rc)
                                                        )
                                                    )
                                                )
                                                (do
                                                    (ß csym = Compiler.resolveSymbol(csym))
                                                )
                                            )
                                            (ß sym = Symbol.intern(nil, csym.name.concat(".")))
                                        )
                                    )
                                    (ß sym.ns == nil && sym.name.startsWith("."))
                                    (do
                                        ;; Simply quote method names.
                                    )
                                    (ß resolver != nil)
                                    (do
                                        (let [#_"Symbol" nsym nil]
                                            (when (ß sym.ns != nil)
                                                (let [#_"Symbol" alias (ß Symbol.intern(nil, sym.ns))]
                                                    (ß nsym = resolver.resolveClass(alias))
                                                    (when (ß nsym == nil)
                                                        (ß nsym = resolver.resolveAlias(alias))
                                                    )
                                                )
                                            )
                                            (cond (ß nsym != nil)
                                                (do
                                                    ;; Classname/foo -> package.qualified.Classname/foo
                                                    (ß sym = Symbol.intern(nsym.name, sym.name))
                                                )
                                                (ß sym.ns == nil)
                                                (do
                                                    (let [#_"Symbol" rsym (ß resolver.resolveClass(sym))]
                                                        (when (ß rsym == nil)
                                                            (ß rsym = resolver.resolveVar(sym))
                                                        )
                                                        (if (ß rsym != nil)
                                                            (do
                                                                (ß sym = rsym)
                                                            )
                                                            (do
                                                                (ß sym = Symbol.intern(resolver.currentNS().name, sym.name))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            ;; leave alone if qualified
                                        )
                                    )
                                    :else
                                    (do
                                        (let [#_"Object" maybeClass nil]
                                            (when (ß sym.ns != nil)
                                                (ß maybeClass = Compiler.currentNS().getMapping(Symbol.intern(nil, sym.ns)))
                                            )
                                            (if (ß maybeClass instanceof Class)
                                                (do
                                                    ;; Classname/foo -> package.qualified.Classname/foo
                                                    (ß sym = Symbol.intern(((Class)maybeClass).getName(), sym.name))
                                                )
                                                (do
                                                    (ß sym = Compiler.resolveSymbol(sym))
                                                )
                                            )
                                        )
                                    )
                                )
                                (ß ret = RT.list(Compiler.QUOTE, sym))
                            )
                        )
                    )
                    (ß isUnquote(form))
                    (do
                        (§ return (ß RT.second(form)))
                    )
                    (ß isUnquoteSplicing(form))
                    (do
                        (throw (ß new IllegalStateException("splice not in list")))
                    )
                    (ß form instanceof IPersistentCollection)
                    (do
                        (cond (ß form instanceof IRecord)
                            (do
                                (ß ret = form)
                            )
                            (ß form instanceof IPersistentMap)
                            (do
                                (let [#_"IPersistentVector" keyvals (ß flattenMap(form))]
                                    (ß ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq())))))
                                )
                            )
                            (ß form instanceof IPersistentVector)
                            (do
                                (ß ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq())))))
                            )
                            (ß form instanceof IPersistentSet)
                            (do
                                (ß ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq())))))
                            )
                            (ß form instanceof ISeq || form instanceof IPersistentList)
                            (do
                                (let [#_"ISeq" seq (ß RT.seq(form))]
                                    (if (ß seq == nil)
                                        (do
                                            (ß ret = RT.cons(LIST, nil))
                                        )
                                        (do
                                            (ß ret = RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq))))
                                        )
                                    )
                                )
                            )
                            :else
                            (do
                                (throw (ß new UnsupportedOperationException("Unknown Collection type")))
                            )
                        )
                    )
                    (ß form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String)
                    (do
                        (ß ret = form)
                    )
                    :else
                    (do
                        (ß ret = RT.list(Compiler.QUOTE, form))
                    )
                )

                (when (ß form instanceof IObj && RT.meta(form) != nil)
                    ;; filter line and column numbers
                    (let [#_"IPersistentMap" newMeta (ß ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY))]
                        (when (ß newMeta.count() > 0)
                            (§ return (ß RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))))
                        )
                    )
                )
                ret
            )
        )

        (§ defn- #_"ISeq" sqExpandList [#_"ISeq" seq]
            (let [#_"PersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß )] (ß seq != nil) [(ß seq = seq.next())]
                    (let [#_"Object" item (ß seq.first())]
                        (cond (ß isUnquote(item))
                            (do
                                (ß ret = ret.cons(RT.list(LIST, RT.second(item))))
                            )
                            (ß isUnquoteSplicing(item))
                            (do
                                (ß ret = ret.cons(RT.second(item)))
                            )
                            :else
                            (do
                                (ß ret = ret.cons(RT.list(LIST, syntaxQuote(item))))
                            )
                        )
                    )
                )
                (ß ret.seq())
            )
        )

        (§ defn- #_"IPersistentVector" flattenMap [#_"Object" form]
            (let [#_"IPersistentVector" keyvals (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                    (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                        (ß keyvals = (IPersistentVector) keyvals.cons(e.key()))
                        (ß keyvals = (IPersistentVector) keyvals.cons(e.val()))
                    )
                )
                keyvals
            )
        )
    )

    (§ defn #_"boolean" isUnquoteSplicing [#_"Object" form]
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING))
    )

    (§ defn #_"boolean" isUnquote [#_"Object" form]
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE))
    )

    (class-ns UnquoteReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" comma, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (ß pendingForms = ensurePending(pendingForms))
                    (if (ß ch == \@)
                        (do
                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (ß RT.list(UNQUOTE_SPLICING, o))
                            )
                        )
                        (do
                            (ß unread(r, ch))
                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (ß RT.list(UNQUOTE, o))
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns CharacterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" backslash, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (let [#_"String" token (ß readToken(r, (char) ch))]
                        (cond (ß token.length() == 1)
                            (do
                                (§ return (ß Character.valueOf(token.charAt(0))))
                            )
                            (ß token.equals("newline"))
                            (do
                                (§ return (ß \newline))
                            )
                            (ß token.equals("space"))
                            (do
                                (§ return (ß \space))
                            )
                            (ß token.equals("tab"))
                            (do
                                (§ return (ß \tab))
                            )
                            (ß token.equals("backspace"))
                            (do
                                (§ return (ß \backspace))
                            )
                            (ß token.equals("formfeed"))
                            (do
                                (§ return (ß \formfeed))
                            )
                            (ß token.equals("return"))
                            (do
                                (§ return (ß \return))
                            )
                            (ß token.startsWith("u"))
                            (do
                                (let [#_"char" c (ß (char) readUnicodeChar(token, 1, 4, 16))]
                                    (when (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                                        (throw (ß Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))))
                                    )
                                    (§ return c)
                                )
                            )
                            (ß token.startsWith("o"))
                            (do
                                (let [#_"int" len (ß token.length() - 1)]
                                    (when (ß len > 3)
                                        (throw (ß Util.runtimeException("Invalid octal escape sequence length: " + len)))
                                    )
                                    (let [#_"int" uc (ß readUnicodeChar(token, 1, len, 8))]
                                        (when (ß uc > 0377)
                                            (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                        (§ return (ß (char) uc))
                                    )
                                )
                            )
                        )
                        (throw (ß Util.runtimeException("Unsupported character: \\" + token)))
                    )
                )
            )
        )
    )

    (class-ns ListReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (let [#_"List" list (ß readDelimitedList(\), r, true, opts, ensurePending(pendingForms)))]
                            (when (ß list.isEmpty())
                                (§ return (ß PersistentList.EMPTY))
                            )
                            (let [#_"IObj" s (ß (IObj) PersistentList.create(list))]
                                (if (ß line != -1)
                                    (do
                                        (ß s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column)))
                                    )
                                    (do
                                        s
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns EvalReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" eq, #_"Object" opts, #_"Object" pendingForms]
            (when (ß !RT.booleanCast(RT.READEVAL.deref()))
                (throw (ß Util.runtimeException("EvalReader not allowed when *read-eval* is false.")))
            )

            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (cond (ß o instanceof Symbol)
                        (do
                            (ß RT.classForName(o.toString()))
                        )
                        (ß o instanceof IPersistentList)
                        (do
                            (let [#_"Symbol" fs (ß (Symbol) RT.first(o))]
                                (when (ß fs.equals(THE_VAR))
                                    (let [#_"Symbol" vs (ß (Symbol) RT.second(o))]
                                        (§ return (ß RT.var(vs.ns, vs.name)))
                                    )
                                )
                                (when (ß fs.name.endsWith("."))
                                    (let [#_"Object[]" args (ß RT.toArray(RT.next(o)))]
                                        (§ return (ß Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)))
                                    )
                                )
                                (when (ß Compiler.namesStaticMember(fs))
                                    (let [#_"Object[]" args (ß RT.toArray(RT.next(o)))]
                                        (§ return (ß Reflector.invokeStaticMethod(fs.ns, fs.name, args)))
                                    )
                                )
                                (let [#_"Object" v (ß Compiler.maybeResolveIn(Compiler.currentNS(), fs))]
                                    (when (ß v instanceof Var)
                                        (§ return (ß ((IFn) v).applyTo(RT.next(o))))
                                    )
                                    (throw (ß Util.runtimeException("Can't resolve " + fs)))
                                )
                            )
                        )
                        :else
                        (do
                            (throw (ß new IllegalArgumentException("Unsupported #= form")))
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts, ensurePending(pendingForms))))
            )
        )
    )

    (class-ns MapReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftparen, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object[]" a (ß readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)).toArray())]
                    (when (ß (a.length & 1) == 1)
                        (throw (ß Util.runtimeException("Map literal must contain an even number of forms")))
                    )
                    (ß RT.map(a))
                )
            )
        )
    )

    (class-ns SetReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftbracket, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts, ensurePending(pendingForms))))
            )
        )
    )

    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" rightdelim, #_"Object" opts, #_"Object" pendingForms]
            (throw (ß Util.runtimeException("Unmatched delimiter: " + rightdelim)))
        )
    )

    (class-ns UnreadableReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" leftangle, #_"Object" opts, #_"Object" pendingForms]
            (throw (ß Util.runtimeException("Unreadable form")))
        )
    )

    ;; Sentinel values for reading lists
    (§ def- #_"Object" READ_EOF (ß new Object()))
    (§ def- #_"Object" READ_FINISHED (ß new Object()))

    (§ defn #_"List" readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" opts, #_"Object" pendingForms]
        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
            (let [#_"ArrayList" a (ß new ArrayList())]
                (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                    (while true
                        (let [#_"Object" form (ß read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver))]
                            (cond (ß form == READ_EOF)
                                (do
                                    (if (ß firstline < 0)
                                        (do
                                            (throw (ß Util.runtimeException("EOF while reading")))
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                        )
                                    )
                                )
                                (ß form == READ_FINISHED)
                                (do
                                    (§ return a)
                                )
                            )

                            (ß a.add(form))
                        )
                    )
                )
            )
        )
    )

    (class-ns CtorReader (§ extends AFn)
        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" firstChar, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß pendingForms = ensurePending(pendingForms))
                (let [#_"Object" name (ß read(r, true, nil, false, opts, pendingForms))]
                    (when (ß !(name instanceof Symbol))
                        (throw (ß new RuntimeException("Reader tag must be a symbol")))
                    )
                    (let [#_"Symbol" sym (ß (Symbol)name)]
                        (let [#_"Object" form (ß read(r, true, nil, true, opts, pendingForms))]
                            (if (ß isPreserveReadCond(opts) || RT.suppressRead())
                                (do
                                    (ß TaggedLiteral.create(sym, form))
                                )
                                (do
                                    (ß sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms))
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"Object" readTagged [this, #_"Object" o, #_"Symbol" tag, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"ILookup" data_readers (ß (ILookup)RT.DATA_READERS.deref())]
                (let [#_"IFn" data_reader (ß (IFn)RT.get(data_readers, tag))]
                    (when (ß data_reader == nil)
                        (ß data_readers = (ILookup)RT.DEFAULT_DATA_READERS.deref())
                        (ß data_reader = (IFn)RT.get(data_readers, tag))
                        (when (ß data_reader == nil)
                            (let [#_"IFn" default_reader (ß (IFn)RT.DEFAULT_DATA_READER_FN.deref())]
                                (if (ß default_reader != nil)
                                    (do
                                        (§ return (ß default_reader.invoke(tag, o)))
                                    )
                                    (do
                                        (throw (ß new RuntimeException("No reader function for tag " + tag.toString())))
                                    )
                                )
                            )
                        )
                    )

                    (ß data_reader.invoke(o))
                )
            )
        )

        #_method
        (§ defn- #_"Object" readRecord [this, #_"Object" form, #_"Symbol" recordName, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"boolean" readeval (ß RT.booleanCast(RT.READEVAL.deref()))]
                (when (ß !readeval)
                    (throw (ß Util.runtimeException("Record construction syntax can only be used when *read-eval* == true")))
                )

                (let [#_"Class" recordClass (ß RT.classForNameNonLoading(recordName.toString()))]
                    (let [#_"boolean" shortForm true]
                        (cond (ß form instanceof IPersistentMap)
                            (do
                                (ß shortForm = false)
                            )
                            (ß form instanceof IPersistentVector)
                            (do
                                (ß shortForm = true)
                            )
                            :else
                            (do
                                (throw (ß Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\"")))
                            )
                        )

                        (let [#_"Object" ret nil]
                            (let [#_"Constructor[]" allctors (ß ((Class)recordClass).getConstructors())]
                                (if shortForm
                                    (do
                                        (let [#_"IPersistentVector" recordEntries (ß (IPersistentVector)form)]
                                            (let [#_"boolean" ctorFound false]
                                                (doseq [#_"Constructor" ctor allctors]
                                                    (when (ß ctor.getParameterTypes().length == recordEntries.count())
                                                        (ß ctorFound = true)
                                                    )
                                                )

                                                (when (ß !ctorFound)
                                                    (throw (ß Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count())))
                                                )

                                                (ß ret = Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries)))
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"IPersistentMap" vals (ß (IPersistentMap)form)]
                                            (loop-when-recur [(ß ISeq s = RT.keys(vals))] (ß s != nil) [(ß s = s.next())]
                                                (when (ß !(s.first() instanceof Keyword))
                                                    (throw (ß Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString())))
                                                )
                                            )
                                            (ß ret = Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ vals )))
                                        )
                                    )
                                )

                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" isPreserveReadCond [#_"Object" opts]
        (if (ß RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap)
            (do
                (let [#_"Object" readCond (ß ((IPersistentMap) opts).valAt(OPT_READ_COND))]
                    (ß COND_PRESERVE.equals(readCond))
                )
            )
            (do
                false
            )
        )
    )

    (class-ns ConditionalReader (§ extends AFn)
        (§ def- #_"Object" READ_STARTED (ß new Object()))
        (§ def #_"Keyword" DEFAULT_FEATURE (ß Keyword.intern(nil, "default")))
        (§ def #_"IPersistentSet" RESERVED_FEATURES (ß RT.set(Keyword.intern(nil, "else"), Keyword.intern(nil, "none"))))

        (§ defn #_"boolean" hasFeature [#_"Object" feature, #_"Object" opts]
            (when (ß !(feature instanceof Keyword))
                (throw (ß Util.runtimeException("Feature should be a keyword: " + feature)))
            )

            (when (ß DEFAULT_FEATURE.equals(feature))
                (§ return true)
            )

            (let [#_"IPersistentSet" custom (ß (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES))]
                (ß (custom != nil && custom.contains(feature)))
            )
        )

        (§ defn #_"Object" readCondDelimited [#_"PushbackReader" r, #_"boolean" splicing, #_"Object" opts, #_"Object" pendingForms]
            (let [#_"Object" result (ß READ_STARTED)]
                (§ let [#_"Object" form] ;; The most recently ready form
                    (let [#_"boolean" toplevel (ß (pendingForms == nil))]
                        (ß pendingForms = ensurePending(pendingForms))

                        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
                            (while true
                                (when (ß result == READ_STARTED)
                                    ;; Read the next feature
                                    (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, nil))

                                    (cond (ß form == READ_EOF)
                                        (do
                                            (if (ß firstline < 0)
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                )
                                            )
                                        )
                                        (ß form == READ_FINISHED)
                                        (do
                                            (§ break ) ;; read-cond form is done
                                        )
                                    )

                                    (when (ß RESERVED_FEATURES.contains(form))
                                        (throw (ß Util.runtimeException("Feature name " + form + " is reserved.")))
                                    )

                                    (when (ß hasFeature(form, opts))
                                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                        (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                                        (cond (ß form == READ_EOF)
                                            (do
                                                (if (ß firstline < 0)
                                                    (do
                                                        (throw (ß Util.runtimeException("EOF while reading")))
                                                    )
                                                    (do
                                                        (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                    )
                                                )
                                            )
                                            (ß form == READ_FINISHED)
                                            (do
                                                (if (ß firstline < 0)
                                                    (do
                                                        (throw (ß Util.runtimeException("read-cond requires an even number of forms.")))
                                                    )
                                                    (do
                                                        (throw (ß Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms")))
                                                    )
                                                )
                                            )
                                            :else
                                            (do
                                                (ß result = form)
                                            )
                                        )
                                    )
                                )

                                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                                (try
                                    (ß Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T)))
                                    (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                                    (cond (ß form == READ_EOF)
                                        (do
                                            (if (ß firstline < 0)
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                )
                                            )
                                        )
                                        (ß form == READ_FINISHED)
                                        (do
                                            (§ break )
                                        )
                                    )
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                            )

                            (when (ß result == READ_STARTED) ;; no features matched
                                (§ return r)
                            )

                            (if splicing
                                (do
                                    (when (ß !(result instanceof List))
                                        (throw (ß Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List")))
                                    )

                                    (when toplevel
                                        (throw (ß Util.runtimeException("Reader conditional splicing not allowed at the top level.")))
                                    )

                                    (ß ((List)pendingForms).addAll(0, (List)result))

                                    r
                                )
                                (do
                                    result
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn- #_"void" checkConditionalAllowed [#_"Object" opts]
            (let [#_"IPersistentMap" mopts (ß (IPersistentMap)opts)]
                (when (ß !(opts != nil && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND)))))
                    (throw (ß Util.runtimeException("Conditional read not allowed")))
                )
                nil
            )
        )

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" reader, #_"Object" mode, #_"Object" opts, #_"Object" pendingForms]
            (ß checkConditionalAllowed(opts))

            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )

                    (let [#_"boolean" splicing false]
                        (when (ß ch == \@)
                            (ß splicing = true)
                            (ß ch = read1(r))
                        )

                        (while (ß isWhitespace(ch))
                            (ß ch = read1(r))
                        )

                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading character")))
                        )

                        (when (ß ch != \()
                            (throw (ß Util.runtimeException("read-cond body must be a list")))
                        )

                        (try
                            (ß Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T)))

                            (if (ß isPreserveReadCond(opts))
                                (do
                                    (let [#_"IFn" listReader (ß getMacro(ch))] ;; should always be a list
                                        (let [#_"Object" form (ß listReader.invoke(r, ch, opts, ensurePending(pendingForms)))]
                                            (ß ReaderConditional.create(form, splicing))
                                        )
                                    )
                                )
                                (do
                                    (ß readCondDelimited(r, splicing, opts, pendingForms))
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(§ anno @SuppressWarnings((§ "SynchronizeOnNonFinalField" )))
(class-ns LockingTransaction
    (§ def #_"int" RETRY_LIMIT (ß 10000))
    (§ def #_"int" LOCK_WAIT_MSECS (ß 100))
    (§ def #_"long" BARGE_WAIT_NANOS (ß 10 * 1000000))

    (§ def #_"int" RUNNING (ß 0))
    (§ def #_"int" COMMITTING (ß 1))
    (§ def #_"int" RETRY (ß 2))
    (§ def #_"int" KILLED (ß 3))
    (§ def #_"int" COMMITTED (ß 4))

    (§ def #_"ThreadLocal<LockingTransaction>" transaction (ß new ThreadLocal<LockingTransaction>()))

    (class-ns RetryEx (§ extends Error)
    )

    (class-ns AbortException (§ extends Exception)
    )

    (class-ns Info
        (§ field #_"AtomicInteger" status)
        (§ field #_"long" startPoint)
        (§ field #_"CountDownLatch" latch)

        (§ constructor #_"Info" Info [#_"int" status, #_"long" startPoint]
            (ß this.status = new AtomicInteger(status))
            (ß this.startPoint = startPoint)
            (ß this.latch = new CountDownLatch(1))
            this
        )

        #_method
        (§ defn #_"boolean" running [this]
            (let [#_"int" s (ß status.get())]
                (ß (s == RUNNING || s == COMMITTING))
            )
        )
    )

    (class-ns CFn
        (§ field #_"IFn" fn)
        (§ field #_"ISeq" args)

        (§ constructor #_"CFn" CFn [#_"IFn" fn, #_"ISeq" args]
            (ß this.fn = fn)
            (ß this.args = args)
            this
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (§ def- #_"AtomicLong" lastPoint (ß new AtomicLong()))

    #_method
    (§ defn #_"void" getReadPoint [this]
        (ß readPoint = lastPoint.incrementAndGet())
        nil
    )

    #_method
    (§ defn #_"long" getCommitPoint [this]
        (ß lastPoint.incrementAndGet())
    )

    #_method
    (§ defn #_"void" stop [this, #_"int" status]
        (when (ß info != nil)
            (§ sync info
                (ß info.status.set(status))
                (ß info.latch.countDown())
            )
            (ß info = nil)
            (ß vals.clear())
            (ß sets.clear())
            (ß commutes.clear())
        )
        nil
    )

    (§ field #_"Info" info)
    (§ field #_"long" readPoint)
    (§ field #_"long" startPoint)
    (§ field #_"long" startTime)

    (§ field #_"RetryEx" retryex (ß new RetryEx()))
    (§ field #_"ArrayList<Agent.Action>" actions (ß new ArrayList<Agent.Action>()))
    (§ field #_"HashMap<Ref, Object>" vals (ß new HashMap<Ref, Object>()))
    (§ field #_"HashSet<Ref>" sets (ß new HashSet<Ref>()))
    (§ field #_"TreeMap<Ref, ArrayList<CFn>>" commutes (ß new TreeMap<Ref, ArrayList<CFn>>()))

    (§ field #_"HashSet<Ref>" ensures (ß new HashSet<Ref>())) ;; all hold readLock

    #_method
    (§ defn #_"void" tryWriteLock [this, #_"Ref" ref]
        (try
            (when (ß !ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
                (throw retryex)
            )
            (catch InterruptedException e
                (throw retryex)
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" lock [this, #_"Ref" ref]
        ;; can't upgrade readLock, so release it
        (ß releaseIfEnsured(ref))

        (let [#_"boolean" unlocked true]
            (try
                (ß tryWriteLock(ref))
                (ß unlocked = false)

                (when (ß ref.tvals != nil && ref.tvals.point > readPoint)
                    (throw retryex)
                )
                (let [#_"Info" refinfo (ß ref.tinfo)]
                    ;; write lock conflict
                    (when (ß refinfo != nil && refinfo != info && refinfo.running())
                        (when (ß !barge(refinfo))
                            (ß ref.lock.writeLock().unlock())
                            (ß unlocked = true)
                            (§ return (ß blockAndBail(refinfo)))
                        )
                    )
                    (ß ref.tinfo = info)
                    (ß (ref.tvals == nil) ? nil :or ref.tvals.val)
                )
                (finally
                    (when (ß !unlocked)
                        (ß ref.lock.writeLock().unlock())
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" blockAndBail [this, #_"Info" refinfo]
        ;; stop prior to blocking
        (ß stop(RETRY))
        (try
            (ß refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
            (catch InterruptedException e
                ;; ignore
            )
        )
        (throw retryex)
    )

    #_method
    (§ defn- #_"void" releaseIfEnsured [this, #_"Ref" ref]
        (when (ß ensures.contains(ref))
            (ß ensures.remove(ref))
            (ß ref.lock.readLock().unlock())
        )
        nil
    )

    #_method
    (§ defn #_"void" abort [this] (§ throws AbortException)
        (ß stop(KILLED))
        (throw (ß new AbortException()))
    )

    #_method
    (§ defn- #_"boolean" bargeTimeElapsed [this]
        (ß (System.nanoTime() - startTime > BARGE_WAIT_NANOS))
    )

    #_method
    (§ defn- #_"boolean" barge [this, #_"Info" refinfo]
        (let [#_"boolean" barged false]
            ;; if this transaction is older, try to abort the other
            (when (ß bargeTimeElapsed() && startPoint < refinfo.startPoint)
                (ß barged = refinfo.status.compareAndSet(RUNNING, KILLED))
                (when barged
                    (ß refinfo.latch.countDown())
                )
            )
            barged
        )
    )

    (§ defn #_"LockingTransaction" getEx []
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (when (ß t == nil || t.info == nil)
                (throw (ß new IllegalStateException("No transaction running")))
            )
            t
        )
    )

    (§ defn #_"boolean" isRunning []
        (ß (getRunning() != nil))
    )

    (§ defn #_"LockingTransaction" getRunning []
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (when (ß t == nil || t.info == nil)
                (§ return nil)
            )
            t
        )
    )

    (§ defn #_"Object" runInTransaction [#_"Callable" fn] (§ throws Exception)
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (§ let [#_"Object" ret]
                (if (ß t == nil)
                    (do
                        (ß transaction.set(t = new LockingTransaction()))
                        (try
                            (ß ret = t.run(fn))
                            (finally
                                (ß transaction.remove())
                            )
                        )
                    )
                    (do
                        (if (ß t.info != nil)
                            (do
                                (ß ret = fn.call())
                            )
                            (do
                                (ß ret = t.run(fn))
                            )
                        )
                    )
                )

                ret
            )
        )
    )

    (class-ns Notify
        (§ field #_"Ref" ref)
        (§ field #_"Object" oldval)
        (§ field #_"Object" newval)

        (§ constructor #_"Notify" Notify [#_"Ref" ref, #_"Object" oldval, #_"Object" newval]
            (ß this.ref = ref)
            (ß this.oldval = oldval)
            (ß this.newval = newval)
            this
        )
    )

    #_method
    (§ defn #_"Object" run [this, #_"Callable" fn] (§ throws Exception)
        (let [#_"boolean" done false]
            (let [#_"Object" ret nil]
                (let [#_"ArrayList<Ref>" locked (ß new ArrayList<Ref>())]
                    (let [#_"ArrayList<Notify>" notify (ß new ArrayList<Notify>())]
                        (loop-when-recur [(ß int i = 0)] (ß !done && i < RETRY_LIMIT) [(ß i++)]
                            (try
                                (ß getReadPoint())
                                (when (ß i == 0)
                                    (ß startPoint = readPoint)
                                    (ß startTime = System.nanoTime())
                                )
                                (ß info = new Info(RUNNING, startPoint))
                                (ß ret = fn.call())
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß info.status.compareAndSet(RUNNING, COMMITTING))
                                    (doseq [#_"Map.Entry<Ref, ArrayList<CFn>>" (ß e commutes.entrySet())]
                                        (let [#_"Ref" ref (ß e.getKey())]
                                            (when (ß sets.contains(ref))
                                                (§ continue )
                                            )

                                            (let [#_"boolean" wasEnsured (ß ensures.contains(ref))]
                                                ;; can't upgrade readLock, so release it
                                                (ß releaseIfEnsured(ref))
                                                (ß tryWriteLock(ref))
                                                (ß locked.add(ref))
                                                (when (ß wasEnsured && ref.tvals != nil && ref.tvals.point > readPoint)
                                                    (throw retryex)
                                                )

                                                (let [#_"Info" refinfo (ß ref.tinfo)]
                                                    (when (ß refinfo != nil && refinfo != info && refinfo.running())
                                                        (when (ß !barge(refinfo))
                                                            (throw retryex)
                                                        )
                                                    )
                                                    (let [#_"Object" val (ß (ref.tvals == nil) ? nil :or ref.tvals.val)]
                                                        (ß vals.put(ref, val))
                                                        (doseq [#_"CFn" f (ß e.getValue())]
                                                            (ß vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ref sets]
                                        (ß tryWriteLock(ref))
                                        (ß locked.add(ref))
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                                        (let [#_"Ref" ref (ß e.getKey())]
                                            (ß ref.validate(ref.getValidator(), e.getValue()))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" commitPoint (ß getCommitPoint())]
                                        (doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                                            (let [#_"Ref" ref (ß e.getKey())]
                                                (let [#_"Object" oldval (ß (ref.tvals == nil) ? nil :or ref.tvals.val)]
                                                    (let [#_"Object" newval (ß e.getValue())]
                                                        (let [#_"int" hcount (ß ref.histCount())]
                                                            (cond (ß ref.tvals == nil)
                                                                (do
                                                                    (ß ref.tvals = new Ref.TVal(newval, commitPoint))
                                                                )
                                                                (ß (ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory)
                                                                (do
                                                                    (ß ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals))
                                                                    (ß ref.faults.set(0))
                                                                )
                                                                :else
                                                                (do
                                                                    (ß ref.tvals = ref.tvals.next)
                                                                    (ß ref.tvals.val = newval)
                                                                    (ß ref.tvals.point = commitPoint)
                                                                )
                                                            )
                                                            (when (ß ref.getWatches().count() > 0)
                                                                (ß notify.add(new Notify(ref, oldval, newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (ß done = true)
                                        (ß info.status.set(COMMITTED))
                                    )
                                )
                                (catch RetryEx retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [(ß int k = locked.size() - 1)] (ß k >= 0) [(ß --k)]
                                        (ß locked.get(k).lock.writeLock().unlock())
                                    )
                                    (ß locked.clear())
                                    (doseq [#_"Ref" r ensures]
                                        (ß r.lock.readLock().unlock())
                                    )
                                    (ß ensures.clear())
                                    (ß stop(done ? COMMITTED :or RETRY))
                                    (try
                                        (when done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" n notify]
                                                (ß n.ref.notifyWatches(n.oldval, n.newval))
                                            )
                                            (doseq [#_"Agent.Action" action actions]
                                                (ß Agent.dispatchAction(action))
                                            )
                                        )
                                        (finally
                                            (ß notify.clear())
                                            (ß actions.clear())
                                        )
                                    )
                                )
                            )
                        )
                        (when (ß !done)
                            (throw (ß Util.runtimeException("Transaction failed after reaching retry limit")))
                        )
                        ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" enqueue [this, #_"Agent.Action" action]
        (ß actions.add(action))
        nil
    )

    #_method
    (§ defn #_"Object" doGet [this, #_"Ref" ref]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß vals.containsKey(ref))
            (§ return (ß vals.get(ref)))
        )
        (try
            (ß ref.lock.readLock().lock())
            (when (ß ref.tvals == nil)
                (throw (ß new IllegalStateException(ref.toString() + " is unbound.")))
            )
            (let [(ß Ref.TVal ver = ref.tvals)]
                (§ loop
                    (when (ß ver.point <= readPoint)
                        (§ return (ß ver.val))
                    )
                    (§ recur-if ((ver = ver.prior) != ref.tvals))
                )
            )
            (finally
                (ß ref.lock.readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (ß ref.faults.incrementAndGet())
        (throw retryex)
    )

    #_method
    (§ defn #_"Object" doSet [this, #_"Ref" ref, #_"Object" val]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß commutes.containsKey(ref))
            (throw (ß new IllegalStateException("Can't set after commute")))
        )
        (when (ß !sets.contains(ref))
            (ß sets.add(ref))
            (ß lock(ref))
        )
        (ß vals.put(ref, val))
        val
    )

    #_method
    (§ defn #_"void" doEnsure [this, #_"Ref" ref]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß ensures.contains(ref))
            (§ return nil)
        )
        (ß ref.lock.readLock().lock())

        ;; someone completed a write after our snapshot
        (when (ß ref.tvals != nil && ref.tvals.point > readPoint)
            (ß ref.lock.readLock().unlock())
            (throw retryex)
        )

        (let [#_"Info" refinfo (ß ref.tinfo)]
            ;; writer exists
            (if (ß refinfo != nil && refinfo.running())
                (do
                    (ß ref.lock.readLock().unlock())

                    (when (ß refinfo != info) ;; not us, ensure is doomed
                        (ß blockAndBail(refinfo))
                    )
                )
                (do
                    (ß ensures.add(ref))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" doCommute [this, #_"Ref" ref, #_"IFn" fn, #_"ISeq" args]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß !vals.containsKey(ref))
            (let [#_"Object" val nil]
                (try
                    (ß ref.lock.readLock().lock())
                    (ß val = (ref.tvals == nil) ? nil :or ref.tvals.val)
                    (finally
                        (ß ref.lock.readLock().unlock())
                    )
                )
                (ß vals.put(ref, val))
            )
        )
        (let [#_"ArrayList<CFn>" fns (ß commutes.get(ref))]
            (when (ß fns == nil)
                (ß commutes.put(ref, fns = new ArrayList<CFn>()))
            )
            (ß fns.add(new CFn(fn, args)))
            (let [#_"Object" ret (ß fn.applyTo(RT.cons(vals.get(ref), args)))]
                (ß vals.put(ref, ret))
                ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (§ def- #_"int" CHUNK_SIZE (ß 32))

    ;; Invariants guarantee this is never an empty or infinite seq
    (§ field #_"long" start)
    (§ field #_"long" end)
    (§ field #_"long" step)
    (§ field #_"BoundsCheck" boundsCheck)

    #_volatile
    (§ field- #_"LongChunk" _chunk) ;; lazy
    #_volatile
    (§ field- #_"ISeq" _chunkNext) ;; lazy
    #_volatile
    (§ field- #_"ISeq" _next) ;; cached

    #_private
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(long val))
    )

    (§ defn- #_"BoundsCheck" positiveStep [#_"long" end]
        (ß new BoundsCheck()
            (§ reify
                #_method
                (§ defn #_"boolean" exceededBounds [this, #_"long" val]
                    (ß (val >= end))
                )
            )
        )
    )

    (§ defn- #_"BoundsCheck" negativeStep [#_"long" end]
        (ß new BoundsCheck()
            (§ reify
                #_method
                (§ defn #_"boolean" exceededBounds [this, #_"long" val]
                    (ß (val <= end))
                )
            )
        )
    )

    (§ constructor- #_"LongRange" LongRange [#_"long" start, #_"long" end, #_"long" step, #_"BoundsCheck" boundsCheck]
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        this
    )

    (§ constructor- #_"LongRange" LongRange [#_"long" start, #_"long" end, #_"long" step, #_"BoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ constructor- #_"LongRange" LongRange [#_"IPersistentMap" meta, #_"long" start, #_"long" end, #_"long" step, #_"BoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (§ super(meta))
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ defn #_"ISeq" create [#_"long" end]
        (when (ß end > 0)
            (§ return (ß new LongRange(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn #_"ISeq" create [#_"long" start, #_"long" end]
        (when (ß start >= end)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new LongRange(start, end, 1, positiveStep(end)))
    )

    (§ defn #_"ISeq" create [#_"long" start, #_"long" end, #_"long" step]
        (cond (ß step > 0)
            (do
                (when (ß end <= start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß new LongRange(start, end, step, positiveStep(end)))
            )
            (ß step < 0)
            (do
                (when (ß end >= start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß new LongRange(start, end, step, negativeStep(end)))
            )
            :else
            (do
                (when (ß end == start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß Repeat.create(start))
            )
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
        (when (ß meta == _meta)
            (§ return this)
        )
        (ß new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext))
    )

    #_method
    (§ defn #_"Object" first [this]
        start
    )

    #_method
    (§ defn #_"void" forceChunk [this]
        (when (ß _chunk != nil)
            (§ return nil)
        )

        (§ let [#_"long" count]
            (try
                (ß count = rangeCount(start, end, step))
                (catch ArithmeticException e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (ß count = steppingCount(start, end, step))
                )
            )

            (cond (ß count > CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" nextStart (ß start + (step * CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (ß _chunkNext = new LongRange(nextStart, end, step, boundsCheck))
                        (ß _chunk = new LongChunk(start, step, CHUNK_SIZE))
                    )
                )
                :else ;; last chunk
                (do
                    (ß _chunk = new LongChunk(start, step, (int) count)) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß _next != nil)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"LongChunk" smallerChunk (ß _chunk.dropFirst())]
                (ß _next = new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext))
                (§ return (ß _next))
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [this]
        (ß forceChunk())
        (ß _chunk)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [this]
        (ß forceChunk())
        (when (ß _chunkNext == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" steppingCount [this, #_"long" start, #_"long" end, #_"long" step]
        (let [#_"long" count 1]
            (let [#_"long" s start]
                (while (ß count <= CHUNK_SIZE)
                    (try
                        (ß s = Numbers.add(s, step))
                        (if (ß boundsCheck.exceededBounds(s))
                            (do
                                (§ break )
                            )
                            (do
                                (ß count++)
                            )
                        )
                        (catch ArithmeticException e
                            (§ break )
                        )
                    )
                )
                count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" rangeCount [this, #_"long" start, #_"long" end, #_"long" step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (ß Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step)
    )

    #_method
    (§ defn #_"int" count [this]
        (try
            (let [#_"long" c (ß rangeCount(start, end, step))]
                (if (ß c > Integer.MAX_VALUE)
                    (do
                        (ß Numbers.throwIntOverflow())
                    )
                    (do
                        (ß (int) c)
                    )
                )
            )
            (catch ArithmeticException e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" iter (ß this.iterator())]
                    (let [#_"long" count 0]
                        (while (ß iter.hasNext())
                            (ß iter.next())
                            (ß count++)
                        )

                        (if (ß count > Integer.MAX_VALUE)
                            (do
                                (ß Numbers.throwIntOverflow())
                            )
                            (do
                                (ß (int)count)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (let [#_"Object" acc start]
            (let [#_"long" i (ß start + step)]
                (while (ß !boundsCheck.exceededBounds(i))
                    (ß acc = f.invoke(acc, i))
                    (when (ß acc instanceof Reduced)
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i += step)
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" val]
        (let [#_"Object" acc val]
            (let [#_"long" i start]
                (§ loop
                    (ß acc = f.invoke(acc, i))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i += step)
                    (§ recur-if (!boundsCheck.exceededBounds(i)))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß new LongRangeIterator())
    )

    #_non-static
    (class-ns LongRangeIterator (§ implements Iterator)
        (§ field- #_"long" next)
        (§ field- #_"boolean" hasNext)

        (§ constructor #_"LongRangeIterator" LongRangeIterator []
            (ß this.next = start)
            (ß this.hasNext = true)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            hasNext
        )

        #_method
        (§ defn #_"Object" next [this]
            (if hasNext
                (do
                    (let [#_"long" ret next]
                        (try
                            (ß next = Numbers.add(next, step))
                            (ß hasNext = !boundsCheck.exceededBounds(next))
                            (catch ArithmeticException e
                                (ß hasNext = false)
                            )
                        )
                        ret
                    )
                )
                (do
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )

    #_private
    (class-ns LongChunk (§ implements IChunk)
        (§ field #_"long" start)
        (§ field #_"long" step)
        (§ field #_"int" count)

        (§ constructor #_"LongChunk" LongChunk [#_"long" start, #_"long" step, #_"int" count]
            (ß this.start = start)
            (ß this.step = step)
            (ß this.count = count)
            this
        )

        #_method
        (§ defn #_"long" first [this]
            start
        )

        #_method
        (§ defn #_"Object" nth [this, #_"int" i]
            (ß start + (i * step))
        )

        #_method
        (§ defn #_"Object" nth [this, #_"int" i, #_"Object" notFound]
            (when (ß i >= 0 && i < count)
                (§ return (ß start + (i * step)))
            )
            notFound
        )

        #_method
        (§ defn #_"int" count [this]
            count
        )

        #_method
        (§ defn #_"LongChunk" dropFirst [this]
            (when (ß count <= 1)
                (throw (ß new IllegalStateException("dropFirst of empty chunk")))
            )
            (ß new LongChunk(start + step, step, count - 1))
        )

        #_method
        (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" init]
            (let [#_"long" x start]
                (let [#_"Object" ret init]
                    (loop-when-recur [(ß int i = 0)] (ß i < count) [(ß i++)]
                        (ß ret = f.invoke(ret, x))
                        (when (ß RT.isReduced(ret))
                            (§ return ret)
                        )
                        (ß x += step)
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (§ field #_"Object" _key)
    (§ field #_"Object" _val)

    (§ defn #_"MapEntry" create [#_"Object" key, #_"Object" val]
        (ß new MapEntry(key, val))
    )

    (§ constructor #_"MapEntry" MapEntry [#_"Object" key, #_"Object" val]
        (ß this._key = key)
        (ß this._val = val)
        this
    )

    #_method
    (§ defn #_"Object" key [this]
        (ß _key)
    )

    #_method
    (§ defn #_"Object" val [this]
        (ß _val)
    )

    #_method
    (§ defn #_"Object" getKey [this]
        (ß key())
    )

    #_method
    (§ defn #_"Object" getValue [this]
        (ß val())
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ interface MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns MethodImplCache
    (class-ns Entry
        (§ field #_"Class" c)
        (§ field #_"IFn" fn)

        (§ constructor #_"Entry" Entry [#_"Class" c, #_"IFn" fn]
            (ß this.c = c)
            (ß this.fn = fn)
            this
        )
    )

    (§ field #_"IPersistentMap" protocol)
    (§ field #_"Keyword" methodk)
    (§ field #_"int" shift)
    (§ field #_"int" mask)
    (§ field #_"Object[]" table) ;; [class, entry. class, entry ...]
    (§ field #_"Map" map)

    (§ field #_"Entry" mre (ß nil))

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" protocol, #_"Keyword" methodk]
        (§ this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY))
        this
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"int" shift, #_"int" mask, #_"Object[]" table]
        (ß this.protocol = protocol)
        (ß this.methodk = methodk)
        (ß this.shift = shift)
        (ß this.mask = mask)
        (ß this.table = table)
        (ß this.map = nil)
        this
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"Map" map]
        (ß this.protocol = protocol)
        (ß this.methodk = methodk)
        (ß this.shift = 0)
        (ß this.mask = 0)
        (ß this.table = nil)
        (ß this.map = map)
        this
    )

    #_method
    (§ defn #_"IFn" fnFor [this, #_"Class" c]
        (let [#_"Entry" last mre]
            (when (ß last != nil && last.c == c)
                (§ return (ß last.fn))
            )
            (ß findFnFor(c))
        )
    )

    #_method
    (§ defn #_"IFn" findFnFor [this, #_"Class" c]
        (if (ß map != nil)
            (do
                (let [#_"Entry" e (ß (Entry) map.get(c))]
                    (ß mre = e)
                    (ß (e != nil) ? e.fn :or nil)
                )
            )
            (do
                (let [#_"int" idx (ß ((Util.hash(c) >> shift) & mask) << 1)]
                    (when (ß idx < table.length && table[idx] == c)
                        (let [#_"Entry" e (ß ((Entry) table[idx + 1]))]
                            (ß mre = e)
                            (§ return (ß (e != nil) ? e.fn :or nil))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ field #_"IFn" dispatchFn)
    (§ field #_"Object" defaultDispatchVal)
    (§ field #_"IRef" hierarchy)
    (§ field #_"String" name)
    (§ field #_"ReentrantReadWriteLock" rw)

    #_volatile
    (§ field #_"IPersistentMap" methodTable)
    #_volatile
    (§ field #_"IPersistentMap" preferTable)
    #_volatile
    (§ field #_"IPersistentMap" methodCache)
    #_volatile
    (§ field #_"Object" cachedHierarchy)

    (§ def #_"Var" assoc (ß RT.var("cloiure.core", "assoc")))
    (§ def #_"Var" dissoc (ß RT.var("cloiure.core", "dissoc")))
    (§ def #_"Var" isa (ß RT.var("cloiure.core", "isa?")))
    (§ def #_"Var" parents (ß RT.var("cloiure.core", "parents")))

    (§ constructor #_"MultiFn" MultiFn [#_"String" name, #_"IFn" dispatchFn, #_"Object" defaultDispatchVal, #_"IRef" hierarchy]
        (ß this.rw = new ReentrantReadWriteLock())
        (ß this.name = name)
        (ß this.dispatchFn = dispatchFn)
        (ß this.defaultDispatchVal = defaultDispatchVal)
        (ß this.methodTable = PersistentHashMap.EMPTY)
        (ß this.methodCache = getMethodTable())
        (ß this.preferTable = PersistentHashMap.EMPTY)
        (ß this.hierarchy = hierarchy)
        (ß cachedHierarchy = nil)
        this
    )

    #_method
    (§ defn #_"MultiFn" reset [this]
        (ß rw.writeLock().lock())
        (try
            (ß methodTable = methodCache = preferTable = PersistentHashMap.EMPTY)
            (ß cachedHierarchy = nil)
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" addMethod [this, #_"Object" dispatchVal, #_"IFn" method]
        (ß rw.writeLock().lock())
        (try
            (ß methodTable = getMethodTable().assoc(dispatchVal, method))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" removeMethod [this, #_"Object" dispatchVal]
        (ß rw.writeLock().lock())
        (try
            (ß methodTable = getMethodTable().without(dispatchVal))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" preferMethod [this, #_"Object" dispatchValX, #_"Object" dispatchValY]
        (ß rw.writeLock().lock())
        (try
            (when (ß prefers(dispatchValY, dispatchValX))
                (throw (ß new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX))))
            )
            (ß preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY)))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn- #_"boolean" prefers [this, #_"Object" x, #_"Object" y]
        (let [#_"IPersistentSet" xprefs (ß (IPersistentSet) getPreferTable().valAt(x))]
            (when (ß xprefs != nil && xprefs.contains(y))
                (§ return true)
            )
            (loop-when-recur [(ß ISeq ps = RT.seq(parents.invoke(y)))] (ß ps != nil) [(ß ps = ps.next())]
                (when (ß prefers(x, ps.first()))
                    (§ return true)
                )
            )
            (loop-when-recur [(ß ISeq ps = RT.seq(parents.invoke(x)))] (ß ps != nil) [(ß ps = ps.next())]
                (when (ß prefers(ps.first(), y))
                    (§ return true)
                )
            )
            false
        )
    )

    #_method
    (§ defn- #_"boolean" isA [this, #_"Object" x, #_"Object" y]
        (ß RT.booleanCast(isa.invoke(hierarchy.deref(), x, y)))
    )

    #_method
    (§ defn- #_"boolean" dominates [this, #_"Object" x, #_"Object" y]
        (ß prefers(x, y) || isA(x, y))
    )

    #_method
    (§ defn- #_"IPersistentMap" resetCache [this]
        (ß rw.writeLock().lock())
        (try
            (ß methodCache = getMethodTable())
            (ß cachedHierarchy = hierarchy.deref())
            methodCache
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"IFn" getMethod [this, #_"Object" dispatchVal]
        (when (ß cachedHierarchy != hierarchy.deref())
            (ß resetCache())
        )
        (let [#_"IFn" targetFn (ß (IFn) methodCache.valAt(dispatchVal))]
            (when (ß targetFn != nil)
                (§ return targetFn)
            )
            (ß findAndCacheBestMethod(dispatchVal))
        )
    )

    #_method
    (§ defn- #_"IFn" getFn [this, #_"Object" dispatchVal]
        (let [#_"IFn" targetFn (ß getMethod(dispatchVal))]
            (when (ß targetFn == nil)
                (throw (ß new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal))))
            )
            targetFn
        )
    )

    #_method
    (§ defn- #_"IFn" findAndCacheBestMethod [this, #_"Object" dispatchVal]
        (ß rw.readLock().lock())
        (§ let [#_"Object" bestValue]
            (let [#_"IPersistentMap" mt methodTable]
                (let [#_"IPersistentMap" pt preferTable]
                    (let [#_"Object" ch cachedHierarchy]
                        (try
                            (let [(ß Map.Entry bestEntry = nil)]
                                (doseq [#_"Object" o (ß getMethodTable())]
                                    (let [(ß Map.Entry e = (Map.Entry) o)]
                                        (when (ß isA(dispatchVal, e.getKey()))
                                            (when (ß bestEntry == nil || dominates(e.getKey(), bestEntry.getKey()))
                                                (ß bestEntry = e)
                                            )
                                            (when (ß !dominates(bestEntry.getKey(), e.getKey()))
                                                (throw (ß new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey()))))
                                            )
                                        )
                                    )
                                )
                                (if (ß bestEntry == nil)
                                    (do
                                        (ß bestValue = methodTable.valAt(defaultDispatchVal))
                                        (when (ß bestValue == nil)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (ß bestValue = bestEntry.getValue())
                                    )
                                )
                            )
                            (finally
                                (ß rw.readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß rw.writeLock().lock())
                        (try
                            (if (ß mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
                                (do
                                    ;; place in cache
                                    (ß methodCache = methodCache.assoc(dispatchVal, bestValue))
                                    (ß (IFn) bestValue)
                                )
                                (do
                                    (ß resetCache())
                                    (ß findAndCacheBestMethod(dispatchVal))
                                )
                            )
                            (finally
                                (ß rw.writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this]
        (ß getFn(dispatchFn.invoke()).invoke())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, arg1 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2]
        (ß getFn(dispatchFn.invoke(arg1, arg2)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20, args)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                    args))
    )

    #_method
    (§ defn #_"IPersistentMap" getMethodTable [this]
        methodTable
    )

    #_method
    (§ defn #_"IPersistentMap" getPreferTable [this]
        preferTable
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
(class-ns Murmur3
    (§ def- #_"int" seed (ß 0))
    (§ def- #_"int" C1 (ß 0xcc9e2d51))
    (§ def- #_"int" C2 (ß 0x1b873593))

    (§ defn #_"int" hashInt [#_"int" input]
        (when (ß input == 0)
            (§ return 0)
        )
        (let [#_"int" k1 (ß mixK1(input))]
            (let [#_"int" h1 (ß mixH1(seed, k1))]
                (ß fmix(h1, 4))
            )
        )
    )

    (§ defn #_"int" hashLong [#_"long" input]
        (when (ß input == 0)
            (§ return 0)
        )
        (let [#_"int" low (ß (int) input)]
            (let [#_"int" high (ß (int) (input >>> 32))]
                (let [#_"int" k1 (ß mixK1(low))]
                    (let [#_"int" h1 (ß mixH1(seed, k1))]
                        (ß k1 = mixK1(high))
                        (ß h1 = mixH1(h1, k1))

                        (ß fmix(h1, 8))
                    )
                )
            )
        )
    )

    (§ defn #_"int" hashUnencodedChars [#_"CharSequence" input]
        (let [#_"int" h1 seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [(ß int i = 1)] (ß i < input.length()) [(ß i += 2)]
                (let [#_"int" k1 (ß input.charAt(i - 1) | (input.charAt(i) << 16))]
                    (ß k1 = mixK1(k1))
                    (ß h1 = mixH1(h1, k1))
                )
            )

            ;; deal with any remaining characters
            (when (ß (input.length() & 1) == 1)
                (let [#_"int" k1 (ß input.charAt(input.length() - 1))]
                    (ß k1 = mixK1(k1))
                    (ß h1 ^= k1)
                )
            )

            (ß fmix(h1, 2 * input.length()))
        )
    )

    (§ defn #_"int" mixCollHash [#_"int" hash, #_"int" count]
        (let [#_"int" h1 seed]
            (let [#_"int" k1 (ß mixK1(hash))]
                (ß h1 = mixH1(h1, k1))
                (ß fmix(h1, count))
            )
        )
    )

    (§ defn #_"int" hashOrdered [#_"Iterable" xs]
        (let [#_"int" n 0]
            (let [#_"int" hash 1]
                (doseq [#_"Object" x xs]
                    (ß hash = 31 * hash + Util.hasheq(x))
                    (ß ++n)
                )

                (ß mixCollHash(hash, n))
            )
        )
    )

    (§ defn #_"int" hashUnordered [#_"Iterable" xs]
        (let [#_"int" hash 0]
            (let [#_"int" n 0]
                (doseq [#_"Object" x xs]
                    (ß hash += Util.hasheq(x))
                    (ß ++n)
                )

                (ß mixCollHash(hash, n))
            )
        )
    )

    (§ defn- #_"int" mixK1 [#_"int" k1]
        (ß k1 *= C1)
        (ß k1 = Integer.rotateLeft(k1, 15))
        (ß k1 *= C2)
        k1
    )

    (§ defn- #_"int" mixH1 [#_"int" h1, #_"int" k1]
        (ß h1 ^= k1)
        (ß h1 = Integer.rotateLeft(h1, 13))
        (ß h1 = h1 * 5 + 0xe6546b64)
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (§ defn- #_"int" fmix [#_"int" h1, #_"int" length]
        (ß h1 ^= length)
        (ß h1 ^= h1 >>> 16)
        (ß h1 *= 0x85ebca6b)
        (ß h1 ^= h1 >>> 13)
        (ß h1 *= 0xc2b2ae35)
        (ß h1 ^= h1 >>> 16)
        h1
    )
)
)

(java-ns cloiure.lang.Named

(§ interface Named
    (§ abstract String getNamespace())
    (§ abstract String getName())
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (§ field #_"Symbol" name)

    #_transient
    (§ field #_"AtomicReference<IPersistentMap>" mappings (ß new AtomicReference<IPersistentMap>()))
    #_transient
    (§ field #_"AtomicReference<IPersistentMap>" aliases (ß new AtomicReference<IPersistentMap>()))

    (§ def #_"ConcurrentHashMap<Symbol, Namespace>" namespaces (ß new ConcurrentHashMap<Symbol, Namespace>()))

    #_method
    (§ defn #_"String" toString [this]
        (ß name.toString())
    )

    (§ constructor #_"Namespace" Namespace [#_"Symbol" name]
        (§ super(name.meta()))
        (ß this.name = name)
        (ß mappings.set(RT.DEFAULT_IMPORTS))
        (ß aliases.set(RT.map()))
        this
    )

    (§ defn #_"ISeq" all []
        (ß RT.seq(namespaces.values()))
    )

    #_method
    (§ defn #_"Symbol" getName [this]
        name
    )

    #_method
    (§ defn #_"IPersistentMap" getMappings [this]
        (ß mappings.get())
    )

    #_method
    (§ defn #_"Var" intern [this, #_"Symbol" sym]
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't intern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (§ let [#_"Object" o]
                (let [#_"Var" v nil]
                    (while (ß (o = map.valAt(sym)) == nil)
                        (when (ß v == nil)
                            (ß v = new Var(this, sym))
                        )
                        (let [#_"IPersistentMap" newMap (ß map.assoc(sym, v))]
                            (ß mappings.compareAndSet(map, newMap))
                            (ß map = getMappings())
                        )
                    )
                    (when (ß o instanceof Var && ((Var) o).ns == this)
                        (§ return (ß (Var) o))
                    )

                    (when (ß v == nil)
                        (ß v = new Var(this, sym))
                    )

                    (ß warnOrFailOnReplace(sym, o, v))

                    (while (ß !mappings.compareAndSet(map, map.assoc(sym, v)))
                        (ß map = getMappings())
                    )

                    v
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" warnOrFailOnReplace [this, #_"Symbol" sym, #_"Object" o, #_"Object" v]
        (when (ß o instanceof Var)
            (let [#_"Namespace" ns (ß ((Var)o).ns)]
                (when (ß ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOIURE_NS))
                    (§ return nil)
                )
                (when (ß ns != RT.CLOIURE_NS)
                    (throw (ß new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name)))
                )
            )
        )
        (ß RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v))
        nil
    )

    #_method
    (§ defn #_"Object" reference [this, #_"Symbol" sym, #_"Object" val]
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't intern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (§ let [#_"Object" o]
                (while (ß (o = map.valAt(sym)) == nil)
                    (let [#_"IPersistentMap" newMap (ß map.assoc(sym, val))]
                        (ß mappings.compareAndSet(map, newMap))
                        (ß map = getMappings())
                    )
                )
                (when (ß o == val)
                    (§ return o)
                )

                (ß warnOrFailOnReplace(sym, o, val))

                (while (ß !mappings.compareAndSet(map, map.assoc(sym, val)))
                    (ß map = getMappings())
                )

                val
            )
        )
    )

    (§ defn #_"boolean" areDifferentInstancesOfSameClassName [#_"Class" cls1, #_"Class" cls2]
        (ß (cls1 != cls2) && (cls1.getName().equals(cls2.getName())))
    )

    #_method
    (§ defn #_"Class" referenceClass [this, #_"Symbol" sym, #_"Class" val]
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't intern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (let [#_"Class" c (ß (Class) map.valAt(sym))]
                (while (ß (c == nil) || (areDifferentInstancesOfSameClassName(c, val)))
                    (let [#_"IPersistentMap" newMap (ß map.assoc(sym, val))]
                        (ß mappings.compareAndSet(map, newMap))
                        (ß map = getMappings())
                        (ß c = (Class) map.valAt(sym))
                    )
                )
                (when (ß c == val)
                    (§ return c)
                )

                (throw (ß new IllegalStateException(sym + " already refers to: " + c + " in namespace: " + name)))
            )
        )
    )

    #_method
    (§ defn #_"void" unmap [this, #_"Symbol" sym]
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't unintern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (while (ß map.containsKey(sym))
                (let [#_"IPersistentMap" newMap (ß map.without(sym))]
                    (ß mappings.compareAndSet(map, newMap))
                    (ß map = getMappings())
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Class" importClass [this, #_"Symbol" sym, #_"Class" c]
        (ß referenceClass(sym, c))
    )

    #_method
    (§ defn #_"Class" importClass [this, #_"Class" c]
        (let [#_"String" n (ß c.getName())]
            (ß importClass(Symbol.intern(n.substring(n.lastIndexOf(\.) + 1)), c))
        )
    )

    #_method
    (§ defn #_"Var" refer [this, #_"Symbol" sym, #_"Var" var]
        (ß (Var) reference(sym, var))
    )

    (§ defn #_"Namespace" findOrCreate [#_"Symbol" name]
        (let [#_"Namespace" ns (ß namespaces.get(name))]
            (when (ß ns != nil)
                (§ return ns)
            )
            (let [#_"Namespace" newns (ß new Namespace(name))]
                (ß ns = namespaces.putIfAbsent(name, newns))
                (ß (ns == nil) ? newns :or ns)
            )
        )
    )

    (§ defn #_"Namespace" remove [#_"Symbol" name]
        (when (ß name.equals(RT.CLOIURE_NS.name))
            (throw (ß new IllegalArgumentException("Cannot remove cloiure namespace")))
        )
        (ß namespaces.remove(name))
    )

    (§ defn #_"Namespace" find [#_"Symbol" name]
        (ß namespaces.get(name))
    )

    #_method
    (§ defn #_"Object" getMapping [this, #_"Symbol" name]
        (ß mappings.get().valAt(name))
    )

    #_method
    (§ defn #_"Var" findInternedVar [this, #_"Symbol" symbol]
        (let [#_"Object" o (ß mappings.get().valAt(symbol))]
            (when (ß o != nil && o instanceof Var && ((Var) o).ns == this)
                (§ return (ß (Var) o))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getAliases [this]
        (ß aliases.get())
    )

    #_method
    (§ defn #_"Namespace" lookupAlias [this, #_"Symbol" alias]
        (let [#_"IPersistentMap" map (ß getAliases())]
            (ß (Namespace) map.valAt(alias))
        )
    )

    #_method
    (§ defn #_"void" addAlias [this, #_"Symbol" alias, #_"Namespace" ns]
        (when (ß alias == nil || ns == nil)
            (throw (ß new NullPointerException("Expecting Symbol + Namespace")))
        )
        (let [#_"IPersistentMap" map (ß getAliases())]
            (while (ß !map.containsKey(alias))
                (let [#_"IPersistentMap" newMap (ß map.assoc(alias, ns))]
                    (ß aliases.compareAndSet(map, newMap))
                    (ß map = getAliases())
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (ß !map.valAt(alias).equals(ns))
                (throw (ß new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" removeAlias [this, #_"Symbol" alias]
        (let [#_"IPersistentMap" map (ß getAliases())]
            (while (ß map.containsKey(alias))
                (let [#_"IPersistentMap" newMap (ß map.without(alias))]
                    (ß aliases.compareAndSet(map, newMap))
                    (ß map = getAliases())
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Numbers
    (§ interface Ops
        (§ abstract Ops combine(Ops y))
        (§ abstract Ops opsWith(LongOps x))
        (§ abstract Ops opsWith(DoubleOps x))
        (§ abstract Ops opsWith(RatioOps x))
        (§ abstract Ops opsWith(BigIntOps x))
        (§ abstract Ops opsWith(BigDecimalOps x))
        (§ abstract boolean isZero(Number x))
        (§ abstract boolean isPos(Number x))
        (§ abstract boolean isNeg(Number x))
        (§ abstract Number add(Number x, Number y))
        (§ abstract Number addP(Number x, Number y))
        (§ abstract Number multiply(Number x, Number y))
        (§ abstract Number multiplyP(Number x, Number y))
        (§ abstract Number divide(Number x, Number y))
        (§ abstract Number quotient(Number x, Number y))
        (§ abstract Number remainder(Number x, Number y))
        (§ abstract boolean equiv(Number x, Number y))
        (§ abstract boolean lt(Number x, Number y))
        (§ abstract boolean lte(Number x, Number y))
        (§ abstract boolean gte(Number x, Number y))
        (§ abstract Number negate(Number x))
        (§ abstract Number negateP(Number x))
        (§ abstract Number inc(Number x))
        (§ abstract Number incP(Number x))
        (§ abstract Number dec(Number x))
        (§ abstract Number decP(Number x))
    )

    #_abstract
    (class-ns OpsP (§ implements Ops)
        #_method
        (§ defn #_"Number" addP [this, #_"Number" x, #_"Number" y]
            (ß add(x, y))
        )

        #_method
        (§ defn #_"Number" multiplyP [this, #_"Number" x, #_"Number" y]
            (ß multiply(x, y))
        )

        #_method
        (§ defn #_"Number" negateP [this, #_"Number" x]
            (ß negate(x))
        )

        #_method
        (§ defn #_"Number" incP [this, #_"Number" x]
            (ß inc(x))
        )

        #_method
        (§ defn #_"Number" decP [this, #_"Number" x]
            (ß dec(x))
        )
    )

    (§ defn #_"boolean" isZero [#_"Object" x]
        (ß ops(x).isZero((Number)x))
    )

    (§ defn #_"boolean" isPos [#_"Object" x]
        (ß ops(x).isPos((Number)x))
    )

    (§ defn #_"boolean" isNeg [#_"Object" x]
        (ß ops(x).isNeg((Number)x))
    )

    (§ defn #_"Number" minus [#_"Object" x]
        (ß ops(x).negate((Number)x))
    )

    (§ defn #_"Number" minusP [#_"Object" x]
        (ß ops(x).negateP((Number)x))
    )

    (§ defn #_"Number" inc [#_"Object" x]
        (ß ops(x).inc((Number)x))
    )

    (§ defn #_"Number" incP [#_"Object" x]
        (ß ops(x).incP((Number)x))
    )

    (§ defn #_"Number" dec [#_"Object" x]
        (ß ops(x).dec((Number)x))
    )

    (§ defn #_"Number" decP [#_"Object" x]
        (ß ops(x).decP((Number)x))
    )

    (§ defn #_"Number" add [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).add((Number)x, (Number)y))
    )

    (§ defn #_"Number" addP [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).addP((Number)x, (Number)y))
    )

    (§ defn #_"Number" minus [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (ß ops(x).combine(yops).add((Number)x, yops.negate((Number)y)))
        )
    )

    (§ defn #_"Number" minusP [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (let [#_"Number" negativeY (ß yops.negateP((Number) y))]
                (let [#_"Ops" negativeYOps (ß ops(negativeY))]
                    (ß ops(x).combine(negativeYOps).addP((Number)x, negativeY))
                )
            )
        )
    )

    (§ defn #_"Number" multiply [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).multiply((Number)x, (Number)y))
    )

    (§ defn #_"Number" multiplyP [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y))
    )

    (§ defn #_"Number" divide [#_"Object" x, #_"Object" y]
        (cond (ß isNaN(x))
            (do
                (§ return (ß (Number)x))
            )
            (ß isNaN(y))
            (do
                (§ return (ß (Number)y))
            )
        )
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number)y))
                (throw (ß new ArithmeticException("Divide by zero")))
            )
            (ß ops(x).combine(yops).divide((Number)x, (Number)y))
        )
    )

    (§ defn #_"Number" quotient [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number) y))
                (throw (ß new ArithmeticException("Divide by zero")))
            )
            (ß ops(x).combine(yops).quotient((Number)x, (Number)y))
        )
    )

    (§ defn #_"Number" remainder [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number) y))
                (throw (ß new ArithmeticException("Divide by zero")))
            )
            (ß ops(x).combine(yops).remainder((Number)x, (Number)y))
        )
    )

    (§ defn #_"double" quotient [#_"double" n, #_"double" d]
        (when (ß d == 0)
            (throw (ß new ArithmeticException("Divide by zero")))
        )

        (let [#_"double" q (ß n / d)]
            (cond (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
                (do
                    (ß (double)(long) q)
                )
                :else ;; bigint quotient
                (do
                    (ß new BigDecimal(q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (§ defn #_"double" remainder [#_"double" n, #_"double" d]
        (when (ß d == 0)
            (throw (ß new ArithmeticException("Divide by zero")))
        )

        (let [#_"double" q (ß n / d)]
            (cond (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
                (do
                    (ß (n - ((long) q) * d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" bq (ß new BigDecimal(q).toBigInteger())]
                        (ß (n - bq.doubleValue() * d))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" equiv [#_"Object" x, #_"Object" y]
        (ß equiv((Number) x, (Number) y))
    )

    (§ defn #_"boolean" equiv [#_"Number" x, #_"Number" y]
        (ß ops(x).combine(ops(y)).equiv(x, y))
    )

    (§ defn #_"boolean" equal [#_"Number" x, #_"Number" y]
        (ß (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y)))
    )

    (§ defn #_"boolean" lt [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).lt((Number)x, (Number)y))
    )

    (§ defn #_"boolean" lte [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).lte((Number)x, (Number)y))
    )

    (§ defn #_"boolean" gt [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).lt((Number)y, (Number)x))
    )

    (§ defn #_"boolean" gte [#_"Object" x, #_"Object" y]
        (ß ops(x).combine(ops(y)).gte((Number)x, (Number)y))
    )

    (§ defn #_"int" compare [#_"Number" x, #_"Number" y]
        (let [#_"Ops" ops (ß ops(x).combine(ops(y)))]
            (cond (ß ops.lt(x, y))
                (do
                    (§ return -1)
                )
                (ß ops.lt(y, x))
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"BigInt" toBigInt [#_"Object" x]
        (when (ß x instanceof BigInt)
            (§ return (ß (BigInt) x))
        )
        (if (ß x instanceof BigInteger)
            (do
                (ß BigInt.fromBigInteger((BigInteger) x))
            )
            (do
                (ß BigInt.fromLong(((Number) x).longValue()))
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"BigInteger" toBigInteger [#_"Object" x]
        (cond (ß x instanceof BigInteger)
            (do
                (ß (BigInteger) x)
            )
            (ß x instanceof BigInt)
            (do
                (ß ((BigInt) x).toBigInteger())
            )
            :else
            (do
                (ß BigInteger.valueOf(((Number) x).longValue()))
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"BigDecimal" toBigDecimal [#_"Object" x]
        (cond (ß x instanceof BigDecimal)
            (do
                (ß (BigDecimal) x)
            )
            (ß x instanceof BigInt)
            (do
                (let [#_"BigInt" bi (ß (BigInt) x)]
                    (if (ß bi.bipart == nil)
                        (do
                            (ß BigDecimal.valueOf(bi.lpart))
                        )
                        (do
                            (ß new BigDecimal(bi.bipart))
                        )
                    )
                )
            )
            (ß x instanceof BigInteger)
            (do
                (ß new BigDecimal((BigInteger) x))
            )
            (ß x instanceof Double)
            (do
                (ß new BigDecimal(((Number) x).doubleValue()))
            )
            (ß x instanceof Float)
            (do
                (ß new BigDecimal(((Number) x).doubleValue()))
            )
            (ß x instanceof Ratio)
            (do
                (let [#_"Ratio" r (ß (Ratio)x)]
                    (ß (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator))
                )
            )
            :else
            (do
                (ß BigDecimal.valueOf(((Number) x).longValue()))
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"Ratio" toRatio [#_"Object" x]
        (cond (ß x instanceof Ratio)
            (do
                (§ return (ß (Ratio) x))
            )
            (ß x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (let [#_"BigInteger" bv (ß bx.unscaledValue())]
                        (let [#_"int" scale (ß bx.scale())]
                            (if (ß scale < 0)
                                (do
                                    (§ return (ß new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)))
                                )
                                (do
                                    (§ return (ß new Ratio(bv, BigInteger.TEN.pow(scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (ß new Ratio(toBigInteger(x), BigInteger.ONE))
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"Number" rationalize [#_"Number" x]
        (cond (ß x instanceof Float || x instanceof Double)
            (do
                (§ return (ß rationalize(BigDecimal.valueOf(x.doubleValue()))))
            )
            (ß x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (let [#_"BigInteger" bv (ß bx.unscaledValue())]
                        (let [#_"int" scale (ß bx.scale())]
                            (if (ß scale < 0)
                                (do
                                    (§ return (ß BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß divide(bv, BigInteger.TEN.pow(scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"Number" reduceBigInt [#_"BigInt" val]
        (if (ß val.bipart == nil)
            (do
                (ß num(val.lpart))
            )
            (do
                (ß val.bipart)
            )
        )
    )

    (§ defn #_"Number" divide [#_"BigInteger" n, #_"BigInteger" d]
        (when (ß d.equals(BigInteger.ZERO))
            (throw (ß new ArithmeticException("Divide by zero")))
        )
        (let [#_"BigInteger" gcd (ß n.gcd(d))]
            (when (ß gcd.equals(BigInteger.ZERO))
                (§ return (ß BigInt.ZERO))
            )
            (ß n = n.divide(gcd))
            (ß d = d.divide(gcd))
            (cond (ß d.equals(BigInteger.ONE))
                (do
                    (§ return (ß BigInt.fromBigInteger(n)))
                )
                (ß d.equals(BigInteger.ONE.negate()))
                (do
                    (§ return (ß BigInt.fromBigInteger(n.negate())))
                )
            )
            (ß new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d)))
        )
    )

    (§ defn #_"int" shiftLeftInt [#_"int" x, #_"int" n]
        (ß x << n)
    )

    (§ defn #_"long" shiftLeft [#_"Object" x, #_"Object" y]
        (ß shiftLeft(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn #_"long" shiftLeft [#_"Object" x, #_"long" y]
        (ß shiftLeft(bitOpsCast(x), y))
    )
    (§ defn #_"long" shiftLeft [#_"long" x, #_"Object" y]
        (ß shiftLeft(x, bitOpsCast(y)))
    )
    (§ defn #_"long" shiftLeft [#_"long" x, #_"long" n]
        (ß x << n)
    )

    (§ defn #_"int" shiftRightInt [#_"int" x, #_"int" n]
        (ß x >> n)
    )

    (§ defn #_"long" shiftRight [#_"Object" x, #_"Object" y]
        (ß shiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn #_"long" shiftRight [#_"Object" x, #_"long" y]
        (ß shiftRight(bitOpsCast(x), y))
    )
    (§ defn #_"long" shiftRight [#_"long" x, #_"Object" y]
        (ß shiftRight(x, bitOpsCast(y)))
    )
    (§ defn #_"long" shiftRight [#_"long" x, #_"long" n]
        (ß x >> n)
    )

    (§ defn #_"int" unsignedShiftRightInt [#_"int" x, #_"int" n]
        (ß x >>> n)
    )

    (§ defn #_"long" unsignedShiftRight [#_"Object" x, #_"Object" y]
        (ß unsignedShiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn #_"long" unsignedShiftRight [#_"Object" x, #_"long" y]
        (ß unsignedShiftRight(bitOpsCast(x), y))
    )
    (§ defn #_"long" unsignedShiftRight [#_"long" x, #_"Object" y]
        (ß unsignedShiftRight(x, bitOpsCast(y)))
    )
    (§ defn #_"long" unsignedShiftRight [#_"long" x, #_"long" n]
        (ß x >>> n)
    )

    (class-ns LongOps (§ implements Ops)
        #_method
        (§ defn #_"Ops" combine [this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"DoubleOps" x]
            (ß DOUBLE_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"RatioOps" x]
            (ß RATIO_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigIntOps" x]
            (ß BIGINT_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigDecimalOps" x]
            (ß BIGDECIMAL_OPS)
        )

        #_method
        (§ defn #_"boolean" isZero [this, #_"Number" x]
            (ß (x.longValue() == 0))
        )

        #_method
        (§ defn #_"boolean" isPos [this, #_"Number" x]
            (ß (x.longValue() > 0))
        )

        #_method
        (§ defn #_"boolean" isNeg [this, #_"Number" x]
            (ß (x.longValue() < 0))
        )

        #_method
        (§ defn #_"Number" add [this, #_"Number" x, #_"Number" y]
            (ß num(Numbers.add(x.longValue(), y.longValue())))
        )

        #_method
        (§ defn #_"Number" addP [this, #_"Number" x, #_"Number" y]
            (let [#_"long" lx (ß x.longValue(), ly = y.longValue())]
                (let [#_"long" ret (ß lx + ly)]
                    (when (ß (ret :xor lx) < 0 && (ret :xor ly) < 0)
                        (§ return (ß BIGINT_OPS.add(x, y)))
                    )
                    (ß num(ret))
                )
            )
        )

        #_method
        (§ defn #_"Number" multiply [this, #_"Number" x, #_"Number" y]
            (ß num(Numbers.multiply(x.longValue(), y.longValue())))
        )

        #_method
        (§ defn #_"Number" multiplyP [this, #_"Number" x, #_"Number" y]
            (let [#_"long" lx (ß x.longValue(), ly = y.longValue())]
                (when (ß lx == Long.MIN_VALUE && ly < 0)
                    (§ return (ß BIGINT_OPS.multiply(x, y)))
                )
                (let [#_"long" ret (ß lx * ly)]
                    (when (ß ly != 0 && ret / ly != lx)
                        (§ return (ß BIGINT_OPS.multiply(x, y)))
                    )
                    (ß num(ret))
                )
            )
        )

        (§ defn #_"long" gcd [#_"long" u, #_"long" v]
            (while (ß v != 0)
                (let [#_"long" r (ß u % v)]
                    (ß u = v)
                    (ß v = r)
                )
            )
            u
        )

        #_method
        (§ defn #_"Number" divide [this, #_"Number" x, #_"Number" y]
            (let [#_"long" n (ß x.longValue())]
                (let [#_"long" val (ß y.longValue())]
                    (let [#_"long" gcd (ß gcd(n, val))]
                        (when (ß gcd == 0)
                            (§ return (ß num(0)))
                        )

                        (ß n = n / gcd)
                        (let [#_"long" d (ß val / gcd)]
                            (when (ß d == 1)
                                (§ return (ß num(n)))
                            )
                            (when (ß d < 0)
                                (ß n = -n)
                                (ß d = -d)
                            )
                            (ß new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d)))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" quotient [this, #_"Number" x, #_"Number" y]
            (ß num(x.longValue() / y.longValue()))
        )

        #_method
        (§ defn #_"Number" remainder [this, #_"Number" x, #_"Number" y]
            (ß num(x.longValue() % y.longValue()))
        )

        #_method
        (§ defn #_"boolean" equiv [this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() == y.longValue()))
        )

        #_method
        (§ defn #_"boolean" lt [this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() < y.longValue()))
        )

        #_method
        (§ defn #_"boolean" lte [this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() <= y.longValue()))
        )

        #_method
        (§ defn #_"boolean" gte [this, #_"Number" x, #_"Number" y]
            (ß (x.longValue() >= y.longValue()))
        )

        #_method
        (§ defn #_"Number" negate [this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.minus(val)))
            )
        )

        #_method
        (§ defn #_"Number" negateP [this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (when (ß val > Long.MIN_VALUE)
                    (§ return (ß num(-val)))
                )
                (ß BigInt.fromBigInteger(BigInteger.valueOf(val).negate()))
            )
        )

        #_method
        (§ defn #_"Number" inc [this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.inc(val)))
            )
        )

        #_method
        (§ defn #_"Number" incP [this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (when (ß val < Long.MAX_VALUE)
                    (§ return (ß num(val + 1)))
                )
                (ß BIGINT_OPS.inc(x))
            )
        )

        #_method
        (§ defn #_"Number" dec [this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.dec(val)))
            )
        )

        #_method
        (§ defn #_"Number" decP [this, #_"Number" x]
            (let [#_"long" val (ß x.longValue())]
                (when (ß val > Long.MIN_VALUE)
                    (§ return (ß num(val - 1)))
                )
                (ß BIGINT_OPS.dec(x))
            )
        )
    )

    (class-ns DoubleOps (§ extends OpsP)
        #_method
        (§ defn #_"Ops" combine [this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"DoubleOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"RatioOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigDecimalOps" x]
            this
        )

        #_method
        (§ defn #_"boolean" isZero [this, #_"Number" x]
            (ß (x.doubleValue() == 0))
        )

        #_method
        (§ defn #_"boolean" isPos [this, #_"Number" x]
            (ß (x.doubleValue() > 0))
        )

        #_method
        (§ defn #_"boolean" isNeg [this, #_"Number" x]
            (ß (x.doubleValue() < 0))
        )

        #_method
        (§ defn #_"Number" add [this, #_"Number" x, #_"Number" y]
            (ß Double.valueOf(x.doubleValue() + y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" multiply [this, #_"Number" x, #_"Number" y]
            (ß Double.valueOf(x.doubleValue() * y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" divide [this, #_"Number" x, #_"Number" y]
            (ß Double.valueOf(x.doubleValue() / y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" quotient [this, #_"Number" x, #_"Number" y]
            (ß Numbers.quotient(x.doubleValue(), y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" remainder [this, #_"Number" x, #_"Number" y]
            (ß Numbers.remainder(x.doubleValue(), y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" equiv [this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() == y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" lt [this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() < y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" lte [this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() <= y.doubleValue()))
        )

        #_method
        (§ defn #_"boolean" gte [this, #_"Number" x, #_"Number" y]
            (ß (x.doubleValue() >= y.doubleValue()))
        )

        #_method
        (§ defn #_"Number" negate [this, #_"Number" x]
            (ß Double.valueOf(-x.doubleValue()))
        )

        #_method
        (§ defn #_"Number" inc [this, #_"Number" x]
            (ß Double.valueOf(x.doubleValue() + 1))
        )

        #_method
        (§ defn #_"Number" dec [this, #_"Number" x]
            (ß Double.valueOf(x.doubleValue() - 1))
        )
    )

    (class-ns RatioOps (§ extends OpsP)
        #_method
        (§ defn #_"Ops" combine [this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"DoubleOps" x]
            (ß DOUBLE_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"RatioOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigDecimalOps" x]
            (ß BIGDECIMAL_OPS)
        )

        #_method
        (§ defn #_"boolean" isZero [this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() == 0))
            )
        )

        #_method
        (§ defn #_"boolean" isPos [this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() > 0))
            )
        )

        #_method
        (§ defn #_"boolean" isNeg [this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() < 0))
            )
        )

        (§ defn #_"Number" normalizeRet [#_"Number" ret, #_"Number" x, #_"Number" y]
            ret
        )

        #_method
        (§ defn #_"Number" add [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" multiply [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" divide [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" quotient [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"BigInteger" q (ß rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))]
                        (ß normalizeRet(BigInt.fromBigInteger(q), x, y))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Number" remainder [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"BigInteger" q (ß rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))]
                        (let [#_"Number" ret (ß Numbers.minus(x, Numbers.multiply(q, y)))]
                            (ß normalizeRet(ret, x, y))
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"boolean" equiv [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"boolean" lt [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"boolean" lte [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"boolean" gte [this, #_"Number" x, #_"Number" y]
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        #_method
        (§ defn #_"Number" negate [this, #_"Number" x]
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß new Ratio(r.numerator.negate(), r.denominator))
            )
        )

        #_method
        (§ defn #_"Number" inc [this, #_"Number" x]
            (ß Numbers.add(x, 1))
        )

        #_method
        (§ defn #_"Number" dec [this, #_"Number" x]
            (ß Numbers.add(x, -1))
        )
    )

    (class-ns BigIntOps (§ extends OpsP)
        #_method
        (§ defn #_"Ops" combine [this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"DoubleOps" x]
            (ß DOUBLE_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"RatioOps" x]
            (ß RATIO_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigDecimalOps" x]
            (ß BIGDECIMAL_OPS)
        )

        #_method
        (§ defn #_"boolean" isZero [this, #_"Number" x]
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart == 0)))
                )
                (ß (bx.bipart.signum() == 0))
            )
        )

        #_method
        (§ defn #_"boolean" isPos [this, #_"Number" x]
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart > 0)))
                )
                (ß (bx.bipart.signum() > 0))
            )
        )

        #_method
        (§ defn #_"boolean" isNeg [this, #_"Number" x]
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart < 0)))
                )
                (ß (bx.bipart.signum() < 0))
            )
        )

        #_method
        (§ defn #_"Number" add [this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).add(toBigInt(y)))
        )

        #_method
        (§ defn #_"Number" multiply [this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).multiply(toBigInt(y)))
        )

        #_method
        (§ defn #_"Number" divide [this, #_"Number" x, #_"Number" y]
            (ß Numbers.divide(toBigInteger(x), toBigInteger(y)))
        )

        #_method
        (§ defn #_"Number" quotient [this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).quotient(toBigInt(y)))
        )

        #_method
        (§ defn #_"Number" remainder [this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).remainder(toBigInt(y)))
        )

        #_method
        (§ defn #_"boolean" equiv [this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).equals(toBigInt(y)))
        )

        #_method
        (§ defn #_"boolean" lt [this, #_"Number" x, #_"Number" y]
            (ß toBigInt(x).lt(toBigInt(y)))
        )

        #_method
        (§ defn #_"boolean" lte [this, #_"Number" x, #_"Number" y]
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) <= 0))
        )

        #_method
        (§ defn #_"boolean" gte [this, #_"Number" x, #_"Number" y]
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) >= 0))
        )

        #_method
        (§ defn #_"Number" negate [this, #_"Number" x]
            (ß BigInt.fromBigInteger(toBigInteger(x).negate()))
        )

        #_method
        (§ defn #_"Number" inc [this, #_"Number" x]
            (let [#_"BigInteger" bx (ß toBigInteger(x))]
                (ß BigInt.fromBigInteger(bx.add(BigInteger.ONE)))
            )
        )

        #_method
        (§ defn #_"Number" dec [this, #_"Number" x]
            (let [#_"BigInteger" bx (ß toBigInteger(x))]
                (ß BigInt.fromBigInteger(bx.subtract(BigInteger.ONE)))
            )
        )
    )

    (class-ns BigDecimalOps (§ extends OpsP)
        (§ def #_"Var" MATH_CONTEXT (ß RT.MATH_CONTEXT))

        #_method
        (§ defn #_"Ops" combine [this, #_"Ops" y]
            (ß y.opsWith(this))
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"LongOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"DoubleOps" x]
            (ß DOUBLE_OPS)
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"RatioOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigIntOps" x]
            this
        )

        #_method
        (§ defn #_"Ops" opsWith [this, #_"BigDecimalOps" x]
            this
        )

        #_method
        (§ defn #_"boolean" isZero [this, #_"Number" x]
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() == 0))
            )
        )

        #_method
        (§ defn #_"boolean" isPos [this, #_"Number" x]
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() > 0))
            )
        )

        #_method
        (§ defn #_"boolean" isNeg [this, #_"Number" x]
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() < 0))
            )
        )

        #_method
        (§ defn #_"Number" add [this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" multiply [this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" divide [this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" quotient [this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"Number" remainder [this, #_"Number" x, #_"Number" y]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc))
            )
        )

        #_method
        (§ defn #_"boolean" equiv [this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0))
        )

        #_method
        (§ defn #_"boolean" lt [this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0))
        )

        #_method
        (§ defn #_"boolean" lte [this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0))
        )

        #_method
        (§ defn #_"boolean" gte [this, #_"Number" x, #_"Number" y]
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0))
        )

        #_method
        (§ defn #_"Number" negate [this, #_"Number" x]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc))
            )
        )

        #_method
        (§ defn #_"Number" inc [this, #_"Number" x]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (ß (mc == nil) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc))
                )
            )
        )

        #_method
        (§ defn #_"Number" dec [this, #_"Number" x]
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (ß (mc == nil) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc))
                )
            )
        )
    )

    (§ def #_"LongOps" LONG_OPS (ß new LongOps()))
    (§ def #_"DoubleOps" DOUBLE_OPS (ß new DoubleOps()))
    (§ def #_"RatioOps" RATIO_OPS (ß new RatioOps()))
    (§ def #_"BigIntOps" BIGINT_OPS (ß new BigIntOps()))
    (§ def #_"BigDecimalOps" BIGDECIMAL_OPS (ß new BigDecimalOps()))

    (§ enum Category
        (§ item INTEGER),
        (§ item FLOATING),
        (§ item DECIMAL),
        (§ item RATIO)
    )

    (§ defn #_"Ops" ops [#_"Object" x]
        (let [#_"Class" xc (ß x.getClass())]
            (cond (ß xc == Long.class)
                (do
                    (ß LONG_OPS)
                )
                (ß xc == Double.class)
                (do
                    (ß DOUBLE_OPS)
                )
                (ß xc == Integer.class)
                (do
                    (ß LONG_OPS)
                )
                (ß xc == Float.class)
                (do
                    (ß DOUBLE_OPS)
                )
                (ß xc == BigInt.class)
                (do
                    (ß BIGINT_OPS)
                )
                (ß xc == BigInteger.class)
                (do
                    (ß BIGINT_OPS)
                )
                (ß xc == Ratio.class)
                (do
                    (ß RATIO_OPS)
                )
                (ß xc == BigDecimal.class)
                (do
                    (ß BIGDECIMAL_OPS)
                )
                :else
                (do
                    (ß LONG_OPS)
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"int" hasheqFrom [#_"Number" x, #_"Class" xc]
        (when (ß xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE)))
            (let [#_"long" lpart (ß x.longValue())]
                (§ return (ß Murmur3.hashLong(lpart)))
            )
        )
        (when (ß xc == BigDecimal.class)
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode.  Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (ß isZero(x))
                (do
                    (§ return (ß BigDecimal.ZERO.hashCode()))
                )
                (do
                    (§ return (ß ((BigDecimal) x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (ß xc == Float.class && x.equals((§ float -0.0)))
            (§ return 0) ;; match 0.0f
        )
        (ß x.hashCode())
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"int" hasheq [#_"Number" x]
        (let [#_"Class" xc (ß x.getClass())]
            (when (ß xc == Long.class)
                (let [#_"long" lpart (ß x.longValue())]
                    (§ return (ß Murmur3.hashLong(lpart)))
                )
            )
            (when (ß xc == Double.class)
                (when (ß x.equals(-0.0))
                    (§ return 0) ;; match 0.0
                )
                (§ return (ß x.hashCode()))
            )
            (ß hasheqFrom(x, xc))
        )
    )

    (§ defn #_"Category" category [#_"Object" x]
        (let [#_"Class" xc (ß x.getClass())]
            (cond (ß xc == Integer.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Double.class)
                (do
                    (ß Category.FLOATING)
                )
                (ß xc == Long.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Float.class)
                (do
                    (ß Category.FLOATING)
                )
                (ß xc == BigInt.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Ratio.class)
                (do
                    (ß Category.RATIO)
                )
                (ß xc == BigDecimal.class)
                (do
                    (ß Category.DECIMAL)
                )
                :else
                (do
                    (ß Category.INTEGER)
                )
            )
        )
    )

    (§ defn #_"long" bitOpsCast [#_"Object" x]
        (let [#_"Class" xc (ß x.getClass())]
            (when (ß xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
                (§ return (ß RT.longCast(x)))
            )
            ;; no bignums, no decimals
            (throw (ß new IllegalArgumentException("bit operation not supported for: " + xc)))
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"float[]" float_array [#_"int" size, #_"Object" init]
        (let [#_"float[]" ret (ß new float[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"float" f (ß ((Number) init).floatValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).floatValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"float[]" float_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new float[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"float[]" ret (ß new float[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).floatValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"double[]" double_array [#_"int" size, #_"Object" init]
        (let [#_"double[]" ret (ß new double[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"double" f (ß ((Number) init).doubleValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).doubleValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"double[]" double_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new double[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"double[]" ret (ß new double[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).doubleValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"int[]" int_array [#_"int" size, #_"Object" init]
        (let [#_"int[]" ret (ß new int[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"int" f (ß ((Number) init).intValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).intValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"int[]" int_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new int[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"int[]" ret (ß new int[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).intValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"long[]" long_array [#_"int" size, #_"Object" init]
        (let [#_"long[]" ret (ß new long[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"long" f (ß ((Number) init).longValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).longValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"long[]" long_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new long[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"long[]" ret (ß new long[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).longValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"short[]" short_array [#_"int" size, #_"Object" init]
        (let [#_"short[]" ret (ß new short[size])]
            (if (ß init instanceof Short)
                (do
                    (let [#_"short" s (ß (Short) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).shortValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"short[]" short_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new short[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"short[]" ret (ß new short[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).shortValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"char[]" char_array [#_"int" size, #_"Object" init]
        (let [#_"char[]" ret (ß new char[size])]
            (if (ß init instanceof Character)
                (do
                    (let [#_"char" c (ß (Character) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = (Character) s.first())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"char[]" char_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new char[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"char[]" ret (ß new char[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = (Character) s.first())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"byte[]" byte_array [#_"int" size, #_"Object" init]
        (let [#_"byte[]" ret (ß new byte[size])]
            (if (ß init instanceof Byte)
                (do
                    (let [#_"byte" b (ß (Byte) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).byteValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"byte[]" byte_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new byte[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"byte[]" ret (ß new byte[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).byteValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"boolean[]" boolean_array [#_"int" size, #_"Object" init]
        (let [#_"boolean[]" ret (ß new boolean[size])]
            (if (ß init instanceof Boolean)
                (do
                    (let [#_"boolean" b (ß (Boolean) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = (Boolean)s.first())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"boolean[]" boolean_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new boolean[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"boolean[]" ret (ß new boolean[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = (Boolean)s.first())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"boolean[]" booleans [#_"Object" array]
        (ß (boolean[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"byte[]" bytes [#_"Object" array]
        (ß (byte[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"char[]" chars [#_"Object" array]
        (ß (char[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"short[]" shorts [#_"Object" array]
        (ß (short[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"float[]" floats [#_"Object" array]
        (ß (float[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"double[]" doubles [#_"Object" array]
        (ß (double[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"int[]" ints [#_"Object" array]
        (ß (int[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn #_"long[]" longs [#_"Object" array]
        (ß (long[]) array)
    )

    (§ defn #_"Number" num [#_"Object" x]
        (ß (Number) x)
    )

    (§ defn #_"Number" num [#_"float" x]
        (ß Float.valueOf(x))
    )

    (§ defn #_"Number" num [#_"double" x]
        (ß Double.valueOf(x))
    )

    (§ defn #_"double" add [#_"double" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"double" addP [#_"double" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"double" minus [#_"double" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"double" minusP [#_"double" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"double" minus [#_"double" x]
        (ß -x)
    )

    (§ defn #_"double" minusP [#_"double" x]
        (ß -x)
    )

    (§ defn #_"double" inc [#_"double" x]
        (ß x + 1)
    )

    (§ defn #_"double" incP [#_"double" x]
        (ß x + 1)
    )

    (§ defn #_"double" dec [#_"double" x]
        (ß x - 1)
    )

    (§ defn #_"double" decP [#_"double" x]
        (ß x - 1)
    )

    (§ defn #_"double" multiply [#_"double" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"double" multiplyP [#_"double" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"double" divide [#_"double" x, #_"double" y]
        (ß x / y)
    )

    (§ defn #_"boolean" equiv [#_"double" x, #_"double" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" lt [#_"double" x, #_"double" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lte [#_"double" x, #_"double" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" gt [#_"double" x, #_"double" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gte [#_"double" x, #_"double" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" isPos [#_"double" x]
        (ß (x > 0))
    )

    (§ defn #_"boolean" isNeg [#_"double" x]
        (ß (x < 0))
    )

    (§ defn #_"boolean" isZero [#_"double" x]
        (ß (x == 0))
    )

    (§ defn #_"int" throwIntOverflow []
        (throw (ß new ArithmeticException("integer overflow")))
    )

    (§ defn #_"int" unchecked_int_add [#_"int" x, #_"int" y]
        (ß x + y)
    )

    (§ defn #_"int" unchecked_int_subtract [#_"int" x, #_"int" y]
        (ß x - y)
    )

    (§ defn #_"int" unchecked_int_negate [#_"int" x]
        (ß -x)
    )

    (§ defn #_"int" unchecked_int_inc [#_"int" x]
        (ß x + 1)
    )

    (§ defn #_"int" unchecked_int_dec [#_"int" x]
        (ß x - 1)
    )

    (§ defn #_"int" unchecked_int_multiply [#_"int" x, #_"int" y]
        (ß x * y)
    )

    (§ defn #_"long" not [#_"Object" x]
        (ß not(bitOpsCast(x)))
    )

    (§ defn #_"long" not [#_"long" x]
        (ß ~x)
    )

    (§ defn #_"long" and [#_"Object" x, #_"Object" y]
        (ß and(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" and [#_"Object" x, #_"long" y]
        (ß and(bitOpsCast(x), y))
    )

    (§ defn #_"long" and [#_"long" x, #_"Object" y]
        (ß and(x, bitOpsCast(y)))
    )

    (§ defn #_"long" and [#_"long" x, #_"long" y]
        (ß x & y)
    )

    (§ defn #_"long" or [#_"Object" x, #_"Object" y]
        (ß or(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" or [#_"Object" x, #_"long" y]
        (ß or(bitOpsCast(x), y))
    )

    (§ defn #_"long" or [#_"long" x, #_"Object" y]
        (ß or(x, bitOpsCast(y)))
    )

    (§ defn #_"long" or [#_"long" x, #_"long" y]
        (ß x | y)
    )

    (§ defn #_"long" xor [#_"Object" x, #_"Object" y]
        (ß xor(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" xor [#_"Object" x, #_"long" y]
        (ß xor(bitOpsCast(x), y))
    )

    (§ defn #_"long" xor [#_"long" x, #_"Object" y]
        (ß xor(x, bitOpsCast(y)))
    )

    (§ defn #_"long" xor [#_"long" x, #_"long" y]
        (ß x :xor y)
    )

    (§ defn #_"long" andNot [#_"Object" x, #_"Object" y]
        (ß andNot(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" andNot [#_"Object" x, #_"long" y]
        (ß andNot(bitOpsCast(x), y))
    )

    (§ defn #_"long" andNot [#_"long" x, #_"Object" y]
        (ß andNot(x, bitOpsCast(y)))
    )

    (§ defn #_"long" andNot [#_"long" x, #_"long" y]
        (ß x & ~y)
    )

    (§ defn #_"long" clearBit [#_"Object" x, #_"Object" y]
        (ß clearBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" clearBit [#_"Object" x, #_"long" y]
        (ß clearBit(bitOpsCast(x), y))
    )

    (§ defn #_"long" clearBit [#_"long" x, #_"Object" y]
        (ß clearBit(x, bitOpsCast(y)))
    )

    (§ defn #_"long" clearBit [#_"long" x, #_"long" n]
        (ß x & ~(1 << n))
    )

    (§ defn #_"long" setBit [#_"Object" x, #_"Object" y]
        (ß setBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" setBit [#_"Object" x, #_"long" y]
        (ß setBit(bitOpsCast(x), y))
    )

    (§ defn #_"long" setBit [#_"long" x, #_"Object" y]
        (ß setBit(x, bitOpsCast(y)))
    )

    (§ defn #_"long" setBit [#_"long" x, #_"long" n]
        (ß x | (1 << n))
    )

    (§ defn #_"long" flipBit [#_"Object" x, #_"Object" y]
        (ß flipBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"long" flipBit [#_"Object" x, #_"long" y]
        (ß flipBit(bitOpsCast(x), y))
    )

    (§ defn #_"long" flipBit [#_"long" x, #_"Object" y]
        (ß flipBit(x, bitOpsCast(y)))
    )

    (§ defn #_"long" flipBit [#_"long" x, #_"long" n]
        (ß x :xor (1 << n))
    )

    (§ defn #_"boolean" testBit [#_"Object" x, #_"Object" y]
        (ß testBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn #_"boolean" testBit [#_"Object" x, #_"long" y]
        (ß testBit(bitOpsCast(x), y))
    )

    (§ defn #_"boolean" testBit [#_"long" x, #_"Object" y]
        (ß testBit(x, bitOpsCast(y)))
    )

    (§ defn #_"boolean" testBit [#_"long" x, #_"long" n]
        (ß ((x & (1 << n)) != 0))
    )

    (§ defn #_"int" unchecked_int_divide [#_"int" x, #_"int" y]
        (ß x / y)
    )

    (§ defn #_"int" unchecked_int_remainder [#_"int" x, #_"int" y]
        (ß x % y)
    )

    (§ defn #_"Number" num [#_"long" x]
        (ß Long.valueOf(x))
    )

    (§ defn #_"long" unchecked_add [#_"long" x, #_"long" y]
        (ß x + y)
    )

    (§ defn #_"long" unchecked_minus [#_"long" x, #_"long" y]
        (ß x - y)
    )

    (§ defn #_"long" unchecked_multiply [#_"long" x, #_"long" y]
        (ß x * y)
    )

    (§ defn #_"long" unchecked_minus [#_"long" x]
        (ß -x)
    )

    (§ defn #_"long" unchecked_inc [#_"long" x]
        (ß x + 1)
    )

    (§ defn #_"long" unchecked_dec [#_"long" x]
        (ß x - 1)
    )

    (§ defn #_"Number" unchecked_add [#_"Object" x, #_"Object" y]
        (ß add(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"Object" x, #_"Object" y]
        (ß minus(x, y))
    )

    (§ defn #_"Number" unchecked_multiply [#_"Object" x, #_"Object" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"Object" x]
        (ß minus(x))
    )

    (§ defn #_"Number" unchecked_inc [#_"Object" x]
        (ß inc(x))
    )

    (§ defn #_"Number" unchecked_dec [#_"Object" x]
        (ß dec(x))
    )

    (§ defn #_"double" unchecked_add [#_"double" x, #_"double" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x, #_"double" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"double" x, #_"double" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x]
        (ß minus(x))
    )

    (§ defn #_"double" unchecked_inc [#_"double" x]
        (ß inc(x))
    )

    (§ defn #_"double" unchecked_dec [#_"double" x]
        (ß dec(x))
    )

    (§ defn #_"double" unchecked_add [#_"double" x, #_"Object" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x, #_"Object" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"double" x, #_"Object" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_add [#_"Object" x, #_"double" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"Object" x, #_"double" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"Object" x, #_"double" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_add [#_"double" x, #_"long" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"double" x, #_"long" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"double" x, #_"long" y]
        (ß multiply(x, y))
    )

    (§ defn #_"double" unchecked_add [#_"long" x, #_"double" y]
        (ß add(x, y))
    )

    (§ defn #_"double" unchecked_minus [#_"long" x, #_"double" y]
        (ß minus(x, y))
    )

    (§ defn #_"double" unchecked_multiply [#_"long" x, #_"double" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" unchecked_add [#_"long" x, #_"Object" y]
        (ß add(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"long" x, #_"Object" y]
        (ß minus(x, y))
    )

    (§ defn #_"Number" unchecked_multiply [#_"long" x, #_"Object" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" unchecked_add [#_"Object" x, #_"long" y]
        (ß add(x, y))
    )

    (§ defn #_"Number" unchecked_minus [#_"Object" x, #_"long" y]
        (ß minus(x, y))
    )

    (§ defn #_"Number" unchecked_multiply [#_"Object" x, #_"long" y]
        (ß multiply(x, y))
    )

    (§ defn #_"Number" quotient [#_"double" x, #_"Object" y]
        (ß quotient((Object)x, y))
    )

    (§ defn #_"Number" quotient [#_"Object" x, #_"double" y]
        (ß quotient(x, (Object)y))
    )

    (§ defn #_"Number" quotient [#_"long" x, #_"Object" y]
        (ß quotient((Object)x, y))
    )

    (§ defn #_"Number" quotient [#_"Object" x, #_"long" y]
        (ß quotient(x, (Object)y))
    )

    (§ defn #_"double" quotient [#_"double" x, #_"long" y]
        (ß quotient(x, (double)y))
    )

    (§ defn #_"double" quotient [#_"long" x, #_"double" y]
        (ß quotient((double)x, y))
    )

    (§ defn #_"Number" remainder [#_"double" x, #_"Object" y]
        (ß remainder((Object)x, y))
    )

    (§ defn #_"Number" remainder [#_"Object" x, #_"double" y]
        (ß remainder(x, (Object)y))
    )

    (§ defn #_"Number" remainder [#_"long" x, #_"Object" y]
        (ß remainder((Object)x, y))
    )

    (§ defn #_"Number" remainder [#_"Object" x, #_"long" y]
        (ß remainder(x, (Object)y))
    )

    (§ defn #_"double" remainder [#_"double" x, #_"long" y]
        (ß remainder(x, (double)y))
    )

    (§ defn #_"double" remainder [#_"long" x, #_"double" y]
        (ß remainder((double)x, y))
    )

    (§ defn #_"long" add [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x + y)]
            (when (ß (ret :xor x) < 0 && (ret :xor y) < 0)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" addP [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x + y)]
            (when (ß (ret :xor x) < 0 && (ret :xor y) < 0)
                (§ return (ß addP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn #_"long" minus [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x - y)]
            (when (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" minusP [#_"long" x, #_"long" y]
        (let [#_"long" ret (ß x - y)]
            (when (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
                (§ return (ß minusP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn #_"long" minus [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß -x)
    )

    (§ defn #_"Number" minusP [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß BigInt.fromBigInteger(BigInteger.valueOf(x).negate())))
        )
        (ß num(-x))
    )

    (§ defn #_"long" inc [#_"long" x]
        (when (ß x == Long.MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x + 1)
    )

    (§ defn #_"Number" incP [#_"long" x]
        (when (ß x == Long.MAX_VALUE)
            (§ return (ß BIGINT_OPS.inc(x)))
        )
        (ß num(x + 1))
    )

    (§ defn #_"long" dec [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x - 1)
    )

    (§ defn #_"Number" decP [#_"long" x]
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß BIGINT_OPS.dec(x)))
        )
        (ß num(x - 1))
    )

    (§ defn #_"long" multiply [#_"long" x, #_"long" y]
        (when (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (let [#_"long" ret (ß x * y)]
            (when (ß y != 0 && ret / y != x)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" multiplyP [#_"long" x, #_"long" y]
        (when (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß multiplyP((Number)x, (Number)y)))
        )
        (let [#_"long" ret (ß x * y)]
            (when (ß y != 0 && ret / y != x)
                (§ return (ß multiplyP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn #_"long" quotient [#_"long" x, #_"long" y]
        (ß x / y)
    )

    (§ defn #_"long" remainder [#_"long" x, #_"long" y]
        (ß x % y)
    )

    (§ defn #_"boolean" equiv [#_"long" x, #_"long" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" lt [#_"long" x, #_"long" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lte [#_"long" x, #_"long" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" gt [#_"long" x, #_"long" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gte [#_"long" x, #_"long" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" isPos [#_"long" x]
        (ß (x > 0))
    )

    (§ defn #_"boolean" isNeg [#_"long" x]
        (ß (x < 0))
    )

    (§ defn #_"boolean" isZero [#_"long" x]
        (ß (x == 0))
    )

    ;; overload resolution

    (§ defn #_"Number" add [#_"long" x, #_"Object" y]
        (ß add((Object)x, y))
    )

    (§ defn #_"Number" add [#_"Object" x, #_"long" y]
        (ß add(x, (Object)y))
    )

    (§ defn #_"Number" addP [#_"long" x, #_"Object" y]
        (ß addP((Object)x, y))
    )

    (§ defn #_"Number" addP [#_"Object" x, #_"long" y]
        (ß addP(x, (Object)y))
    )

    (§ defn #_"double" add [#_"double" x, #_"Object" y]
        (ß add(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" add [#_"Object" x, #_"double" y]
        (ß add(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" add [#_"double" x, #_"long" y]
        (ß x + y)
    )

    (§ defn #_"double" add [#_"long" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"double" addP [#_"double" x, #_"Object" y]
        (ß addP(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" addP [#_"Object" x, #_"double" y]
        (ß addP(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" addP [#_"double" x, #_"long" y]
        (ß x + y)
    )

    (§ defn #_"double" addP [#_"long" x, #_"double" y]
        (ß x + y)
    )

    (§ defn #_"Number" minus [#_"long" x, #_"Object" y]
        (ß minus((Object)x, y))
    )

    (§ defn #_"Number" minus [#_"Object" x, #_"long" y]
        (ß minus(x, (Object)y))
    )

    (§ defn #_"Number" minusP [#_"long" x, #_"Object" y]
        (ß minusP((Object)x, y))
    )

    (§ defn #_"Number" minusP [#_"Object" x, #_"long" y]
        (ß minusP(x, (Object)y))
    )

    (§ defn #_"double" minus [#_"double" x, #_"Object" y]
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" minus [#_"Object" x, #_"double" y]
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" minus [#_"double" x, #_"long" y]
        (ß x - y)
    )

    (§ defn #_"double" minus [#_"long" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"double" minusP [#_"double" x, #_"Object" y]
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" minusP [#_"Object" x, #_"double" y]
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" minusP [#_"double" x, #_"long" y]
        (ß x - y)
    )

    (§ defn #_"double" minusP [#_"long" x, #_"double" y]
        (ß x - y)
    )

    (§ defn #_"Number" multiply [#_"long" x, #_"Object" y]
        (ß multiply((Object)x, y))
    )

    (§ defn #_"Number" multiply [#_"Object" x, #_"long" y]
        (ß multiply(x, (Object)y))
    )

    (§ defn #_"Number" multiplyP [#_"long" x, #_"Object" y]
        (ß multiplyP((Object)x, y))
    )

    (§ defn #_"Number" multiplyP [#_"Object" x, #_"long" y]
        (ß multiplyP(x, (Object)y))
    )

    (§ defn #_"double" multiply [#_"double" x, #_"Object" y]
        (ß multiply(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" multiply [#_"Object" x, #_"double" y]
        (ß multiply(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" multiply [#_"double" x, #_"long" y]
        (ß x * y)
    )

    (§ defn #_"double" multiply [#_"long" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"double" multiplyP [#_"double" x, #_"Object" y]
        (ß multiplyP(x, ((Number)y).doubleValue()))
    )

    (§ defn #_"double" multiplyP [#_"Object" x, #_"double" y]
        (ß multiplyP(((Number)x).doubleValue(), y))
    )

    (§ defn #_"double" multiplyP [#_"double" x, #_"long" y]
        (ß x * y)
    )

    (§ defn #_"double" multiplyP [#_"long" x, #_"double" y]
        (ß x * y)
    )

    (§ defn #_"Number" divide [#_"long" x, #_"Object" y]
        (ß divide((Object)x, y))
    )

    (§ defn #_"Number" divide [#_"Object" x, #_"long" y]
        (ß divide(x, (Object)y))
    )

    (§ defn #_"double" divide [#_"double" x, #_"Object" y]
        (ß x / ((Number)y).doubleValue())
    )

    (§ defn #_"double" divide [#_"Object" x, #_"double" y]
        (ß ((Number)x).doubleValue() / y)
    )

    (§ defn #_"double" divide [#_"double" x, #_"long" y]
        (ß x / y)
    )

    (§ defn #_"double" divide [#_"long" x, #_"double" y]
        (ß x / y)
    )

    (§ defn #_"Number" divide [#_"long" x, #_"long" y]
        (ß divide((Number)x, (Number)y))
    )

    (§ defn #_"boolean" lt [#_"long" x, #_"Object" y]
        (ß lt((Object)x, y))
    )

    (§ defn #_"boolean" lt [#_"Object" x, #_"long" y]
        (ß lt(x, (Object)y))
    )

    (§ defn #_"boolean" lt [#_"double" x, #_"Object" y]
        (ß (x < ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" lt [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() < y))
    )

    (§ defn #_"boolean" lt [#_"double" x, #_"long" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lt [#_"long" x, #_"double" y]
        (ß (x < y))
    )

    (§ defn #_"boolean" lte [#_"long" x, #_"Object" y]
        (ß lte((Object)x, y))
    )

    (§ defn #_"boolean" lte [#_"Object" x, #_"long" y]
        (ß lte(x, (Object)y))
    )

    (§ defn #_"boolean" lte [#_"double" x, #_"Object" y]
        (ß (x <= ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" lte [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() <= y))
    )

    (§ defn #_"boolean" lte [#_"double" x, #_"long" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" lte [#_"long" x, #_"double" y]
        (ß (x <= y))
    )

    (§ defn #_"boolean" gt [#_"long" x, #_"Object" y]
        (ß gt((Object)x, y))
    )

    (§ defn #_"boolean" gt [#_"Object" x, #_"long" y]
        (ß gt(x, (Object)y))
    )

    (§ defn #_"boolean" gt [#_"double" x, #_"Object" y]
        (ß (x > ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" gt [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() > y))
    )

    (§ defn #_"boolean" gt [#_"double" x, #_"long" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gt [#_"long" x, #_"double" y]
        (ß (x > y))
    )

    (§ defn #_"boolean" gte [#_"long" x, #_"Object" y]
        (ß gte((Object)x, y))
    )

    (§ defn #_"boolean" gte [#_"Object" x, #_"long" y]
        (ß gte(x, (Object)y))
    )

    (§ defn #_"boolean" gte [#_"double" x, #_"Object" y]
        (ß (x >= ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" gte [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() >= y))
    )

    (§ defn #_"boolean" gte [#_"double" x, #_"long" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" gte [#_"long" x, #_"double" y]
        (ß (x >= y))
    )

    (§ defn #_"boolean" equiv [#_"long" x, #_"Object" y]
        (ß equiv((Object)x, y))
    )

    (§ defn #_"boolean" equiv [#_"Object" x, #_"long" y]
        (ß equiv(x, (Object)y))
    )

    (§ defn #_"boolean" equiv [#_"double" x, #_"Object" y]
        (ß (x == ((Number)y).doubleValue()))
    )

    (§ defn #_"boolean" equiv [#_"Object" x, #_"double" y]
        (ß (((Number)x).doubleValue() == y))
    )

    (§ defn #_"boolean" equiv [#_"double" x, #_"long" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" equiv [#_"long" x, #_"double" y]
        (ß (x == y))
    )

    (§ defn #_"boolean" isNaN [#_"Object" x]
        (ß (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN())
    )

    (§ defn #_"double" max [#_"double" x, #_"double" y]
        (ß Math.max(x, y))
    )

    (§ defn #_"Object" max [#_"double" x, #_"long" y]
        (when (ß Double.isNaN(x))
            (§ return x)
        )
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"double" x, #_"Object" y]
        (cond (ß Double.isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß x > ((Number)y).doubleValue())
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"long" x, #_"double" y]
        (when (ß Double.isNaN(y))
            (§ return y)
        )
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"long" max [#_"long" x, #_"long" y]
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"long" x, #_"Object" y]
        (when (ß isNaN(y))
            (§ return y)
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"Object" x, #_"long" y]
        (when (ß isNaN(x))
            (§ return x)
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"Object" x, #_"double" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß Double.isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß ((Number)x).doubleValue() > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" max [#_"Object" x, #_"Object" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"double" min [#_"double" x, #_"double" y]
        (ß Math.min(x, y))
    )

    (§ defn #_"Object" min [#_"double" x, #_"long" y]
        (when (ß Double.isNaN(x))
            (§ return x)
        )
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"double" x, #_"Object" y]
        (cond (ß Double.isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß x < ((Number)y).doubleValue())
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"long" x, #_"double" y]
        (when (ß Double.isNaN(y))
            (§ return y)
        )
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"long" min [#_"long" x, #_"long" y]
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"long" x, #_"Object" y]
        (when (ß isNaN(y))
            (§ return y)
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"Object" x, #_"long" y]
        (when (ß isNaN(x))
            (§ return x)
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"Object" x, #_"double" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß Double.isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß ((Number)x).doubleValue() < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn #_"Object" min [#_"Object" x, #_"Object" y]
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (§ field #_"IPersistentMap" _meta)

    (§ constructor #_"Obj" Obj [#_"IPersistentMap" meta]
        (ß this._meta = meta)
        this
    )

    (§ constructor #_"Obj" Obj []
        (ß _meta = nil)
        this
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )

    (§ abstract Obj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ field #_"Object[]" array)
    (§ def #_"int" HASHTABLE_THRESHOLD (ß 16))

    (§ def #_"PersistentArrayMap" EMPTY (ß new PersistentArrayMap()))
    (§ field- #_"IPersistentMap" _meta)

    (§ defn #_"IPersistentMap" create [#_"Map" other]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(ß Map.Entry e = (Entry) o)]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            (ß ret.persistent())
        )
    )

    #_protected
    (§ constructor #_"PersistentArrayMap" PersistentArrayMap []
        (ß this.array = new Object[] (§))
        (ß this._meta = nil)
        this
    )

    #_method
    (§ defn #_"PersistentArrayMap" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentArrayMap(meta, array))
    )

    #_method
    (§ defn #_"PersistentArrayMap" create [this, #_"Object..." init]
        (ß new PersistentArrayMap(meta(), init))
    )

    #_method
    (§ defn #_"IPersistentMap" createHT [this, #_"Object[]" init]
        (ß PersistentHashMap.create(meta(), init))
    )

    (§ defn #_"PersistentArrayMap" createWithCheck [#_"Object[]" init]
        (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
            (loop-when-recur [(ß int j = i + 2)] (ß j < init.length) [(ß j += 2)]
                (when (ß equalKey(init[i], init[j]))
                    (throw (ß new IllegalArgumentException("Duplicate key: " + init[i])))
                )
            )
        )
        (ß new PersistentArrayMap(init))
    )

    (§ defn #_"PersistentArrayMap" createAsIfByAssoc [#_"Object[]" init]
        (when (ß (init.length & 1) == 1)
            (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1]))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" n 0]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (let [#_"boolean" duplicateKey false]
                    (loop-when-recur [(ß int j = 0)] (ß j < i) [(ß j += 2)]
                        (when (ß equalKey(init[i], init[j]))
                            (ß duplicateKey = true)
                            (§ break )
                        )
                    )
                    (when (ß !duplicateKey)
                        (ß n += 2)
                    )
                )
            )
            (when (ß n < init.length)
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key.  To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" nodups (ß new Object[n])]
                    (let [#_"int" m 0]
                        (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                            (let [#_"boolean" duplicateKey false]
                                (loop-when-recur [(ß int j = 0)] (ß j < m) [(ß j += 2)]
                                    (when (ß equalKey(init[i], nodups[j]))
                                        (ß duplicateKey = true)
                                        (§ break )
                                    )
                                )
                                (when (ß !duplicateKey)
                                    (§ let [#_"int" j]
                                        (loop-when-recur [(ß j = init.length - 2)] (ß j >= i) [(ß j -= 2)]
                                            (when (ß equalKey(init[i], init[j]))
                                                (§ break )
                                            )
                                        )
                                        (ß nodups[m] = init[i])
                                        (ß nodups[m + 1] = init[j + 1])
                                        (ß m += 2)
                                    )
                                )
                            )
                        )
                        (when (ß m != n)
                            (throw (ß new IllegalArgumentException("Internal error: m=" + m)))
                        )
                        (ß init = nodups)
                    )
                )
            )
            (ß new PersistentArrayMap(init))
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ constructor #_"PersistentArrayMap" PersistentArrayMap [#_"Object[]" init]
        (ß this.array = init)
        (ß this._meta = nil)
        this
    )

    (§ constructor #_"PersistentArrayMap" PersistentArrayMap [#_"IPersistentMap" meta, #_"Object[]" init]
        (ß this._meta = meta)
        (ß this.array = init)
        this
    )

    #_method
    (§ defn #_"int" count [this]
        (ß array.length / 2)
    )

    #_method
    (§ defn #_"boolean" containsKey [this, #_"Object" key]
        (ß (indexOf(key) >= 0))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [this, #_"Object" key]
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0)
                (§ return (ß (IMapEntry) MapEntry.create(array[i], array[i + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (ß indexOf(key))]
            (§ let [#_"Object[]" newArray]
                (cond (ß i >= 0)
                    (do
                        (throw (ß Util.runtimeException("Key already present")))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assocEx(key, val)))
                        )
                        (ß newArray = new Object[array.length + 2])
                        (when (ß array.length > 0)
                            (ß System.arraycopy(array, 0, newArray, 2, array.length))
                        )
                        (ß newArray[0] = key)
                        (ß newArray[1] = val)
                    )
                )
                (ß create(newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (ß indexOf(key))]
            (§ let [#_"Object[]" newArray]
                (cond (ß i >= 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß array[i + 1] == val) ;; no change, no op
                            (§ return this)
                        )
                        (ß newArray = array.clone())
                        (ß newArray[i + 1] = val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assoc(key, val)))
                        )
                        (ß newArray = new Object[array.length + 2])
                        (when (ß array.length > 0)
                            (ß System.arraycopy(array, 0, newArray, 0, array.length))
                        )
                        (ß newArray[newArray.length - 2] = key)
                        (ß newArray[newArray.length - 1] = val)
                    )
                )
                (ß create(newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" without [this, #_"Object" key]
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0) ;; have key, will remove
                (let [#_"int" newlen (ß array.length - 2)]
                    (when (ß newlen == 0)
                        (§ return (ß empty()))
                    )
                    (let [#_"Object[]" newArray (ß new Object[newlen])]
                        (ß System.arraycopy(array, 0, newArray, 0, i))
                        (ß System.arraycopy(array, i + 2, newArray, i, newlen - i))
                        (§ return (ß create(newArray)))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" empty [this]
        (ß (IPersistentMap) EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0)
                (§ return (ß array[i + 1]))
            )
            notFound
        )
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"int" capacity [this]
        (ß count())
    )

    #_method
    (§ defn- #_"int" indexOfObject [this, #_"Object" key]
        (let [(ß Util.EquivPred ep = Util.equivPred(key))]
            (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                (when (ß ep.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn- #_"int" indexOf [this, #_"Object" key]
        (if (ß key instanceof Keyword)
            (do
                (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                    (when (ß key == array[i])
                        (§ return i)
                    )
                )
                -1
            )
            (do
                (ß indexOfObject(key))
            )
        )
    )

    (§ defn #_"boolean" equalKey [#_"Object" k1, #_"Object" k2]
        (when (ß k1 instanceof Keyword)
            (§ return (ß (k1 == k2)))
        )
        (ß Util.equiv(k1, k2))
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß new Iter(array, APersistentMap.MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [this]
        (ß new Iter(array, APersistentMap.MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [this]
        (ß new Iter(array, APersistentMap.MAKE_VAL))
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (when (ß array.length > 0)
            (§ return (ß new Seq(array, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )

    (class-ns Seq (§ extends ASeq) (§ implements Counted)
        (§ field #_"Object[]" array)
        (§ field #_"int" i)

        (§ constructor #_"Seq" Seq [#_"Object[]" array, #_"int" i]
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ constructor #_"Seq" Seq [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß i + 2 < array.length)
                (§ return (ß new Seq(array, i + 2)))
            )
            nil
        )

        #_method
        (§ defn #_"int" count [this]
            (ß (array.length - i) / 2)
        )

        #_method
        (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
            (ß new Seq(meta, array, i))
        )
    )

    (class-ns Iter (§ implements Iterator)
        (§ field #_"IFn" f)
        (§ field #_"Object[]" array)
        (§ field #_"int" i)

        ;; for iterator
        (§ constructor #_"Iter" Iter [#_"Object[]" array, #_"IFn" f]
            (§ this(array, -2, f))
            this
        )

        ;; for entryAt
        (§ constructor #_"Iter" Iter [#_"Object[]" array, #_"int" i, #_"IFn" f]
            (ß this.array = array)
            (ß this.i = i)
            (ß this.f = f)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (i < array.length - 2))
        )

        #_method
        (§ defn #_"Object" next [this]
            (try
                (ß i += 2)
                (ß f.invoke(array[i], array[i + 1]))
                (catch IndexOutOfBoundsException e
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )

    #_method
    (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
        (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
            (ß init = f.invoke(init, array[i], array[i + 1]))
            (when (ß RT.isReduced(init))
                (§ return (ß ((IDeref)init).deref()))
            )
        )
        init
    )

    #_method
    (§ defn #_"ITransientMap" asTransient [this]
        (ß new TransientArrayMap(array))
    )

    (class-ns TransientArrayMap (§ extends ATransientMap)
        #_volatile
        (§ field #_"int" len)
        (§ field #_"Object[]" array)
        #_volatile
        (§ field #_"Thread" owner)

        (§ constructor #_"TransientArrayMap" TransientArrayMap [#_"Object[]" array]
            (ß this.owner = Thread.currentThread())
            (ß this.array = new Object[Math.max(HASHTABLE_THRESHOLD, array.length)])
            (ß System.arraycopy(array, 0, this.array, 0, array.length))
            (ß this.len = array.length)
            this
        )

        #_method
        (§ defn- #_"int" indexOf [this, #_"Object" key]
            (loop-when-recur [(ß int i = 0)] (ß i < len) [(ß i += 2)]
                (when (ß equalKey(array[i], key))
                    (§ return i)
                )
            )
            -1
        )

        #_method
        (§ defn #_"ITransientMap" doAssoc [this, #_"Object" key, #_"Object" val]
            (let [#_"int" i (ß indexOf(key))]
                (cond (ß i >= 0) ;; already have key,
                    (do
                        (when (ß array[i + 1] != val) ;; no change, no op
                            (ß array[i + 1] = val)
                        )
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß len >= array.length)
                            (§ return (ß PersistentHashMap.create(array).asTransient().assoc(key, val)))
                        )
                        (ß array[len++] = key)
                        (ß array[len++] = val)
                    )
                )
                this
            )
        )

        #_method
        (§ defn #_"ITransientMap" doWithout [this, #_"Object" key]
            (let [#_"int" i (ß indexOf(key))]
                (when (ß i >= 0) ;; have key, will remove
                    (when (ß len >= 2)
                        (ß array[i] = array[len - 2])
                        (ß array[i + 1] = array[len - 1])
                    )
                    (ß len -= 2)
                )
                this
            )
        )

        #_method
        (§ defn #_"Object" doValAt [this, #_"Object" key, #_"Object" notFound]
            (let [#_"int" i (ß indexOf(key))]
                (when (ß i >= 0)
                    (§ return (ß array[i + 1]))
                )
                notFound
            )
        )

        #_method
        (§ defn #_"int" doCount [this]
            (ß len / 2)
        )

        #_method
        (§ defn #_"IPersistentMap" doPersistent [this]
            (ß ensureEditable())
            (ß owner = nil)
            (let [#_"Object[]" a (ß new Object[len])]
                (ß System.arraycopy(array, 0, a, 0, len))
                (ß new PersistentArrayMap(a))
            )
        )

        #_method
        (§ defn #_"void" ensureEditable [this]
            (when (ß owner == nil)
                (throw (ß new IllegalAccessError("Transient used after persistent! call")))
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ field #_"int" count)
    (§ field #_"INode" root)
    (§ field #_"boolean" hasNull)
    (§ field #_"Object" nullValue)
    (§ field #_"IPersistentMap" _meta)

    (§ def #_"PersistentHashMap" EMPTY (ß new PersistentHashMap(0, nil, false, nil)))
    (§ def- #_"Object" NOT_FOUND (ß new Object()))

    (§ defn #_"IPersistentMap" create [#_"Map" other]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(ß Map.Entry e = (Entry) o)]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            (ß ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn #_"PersistentHashMap" create [#_"Object..." init]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (ß ret = ret.assoc(init[i], init[i + 1]))
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" createWithCheck [#_"Object..." init]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (ß ret = ret.assoc(init[i], init[i + 1]))
                (when (ß ret.count() != i / 2 + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + init[i])))
                )
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" create [#_"ISeq" items]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" createWithCheck [#_"ISeq" items]
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß items != nil) [(ß items = items.next().next(), ++i)]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + items.first())))
                )
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn #_"PersistentHashMap" create [#_"IPersistentMap" meta, #_"Object..." init]
        (ß create(init).withMeta(meta))
    )

    (§ constructor #_"PersistentHashMap" PersistentHashMap [#_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (ß this.count = count)
        (ß this.root = root)
        (ß this.hasNull = hasNull)
        (ß this.nullValue = nullValue)
        (ß this._meta = nil)
        this
    )

    (§ constructor #_"PersistentHashMap" PersistentHashMap [#_"IPersistentMap" meta, #_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (ß this._meta = meta)
        (ß this.count = count)
        (ß this.root = root)
        (ß this.hasNull = hasNull)
        (ß this.nullValue = nullValue)
        this
    )

    (§ defn #_"int" hash [#_"Object" k]
        (ß Util.hasheq(k))
    )

    #_method
    (§ defn #_"boolean" containsKey [this, #_"Object" key]
        (when (ß key == nil)
            (§ return hasNull)
        )
        (ß (root != nil) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false)
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [this, #_"Object" key]
        (when (ß key == nil)
            (§ return (ß hasNull ? (IMapEntry) MapEntry.create(nil, nullValue) :or nil))
        )
        (ß (root != nil) ? root.find(0, hash(key), key) :or nil)
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [this, #_"Object" key, #_"Object" val]
        (when (ß key == nil)
            (when (ß hasNull && val == nullValue)
                (§ return this)
            )
            (§ return (ß new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)))
        )
        (let [#_"Box" addedLeaf (ß new Box(nil))]
            (let [#_"INode" newroot (ß ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf))]
                (when (ß newroot == root)
                    (§ return this)
                )
                (ß new PersistentHashMap(meta(), (addedLeaf.val == nil) ? count :or count + 1, newroot, hasNull, nullValue))
            )
        )
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (when (ß key == nil)
            (§ return (ß hasNull ? nullValue :or notFound))
        )
        (ß (root != nil) ? root.find(0, hash(key), key, notFound) :or notFound)
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [this, #_"Object" key, #_"Object" val]
        (when (ß containsKey(key))
            (throw (ß Util.runtimeException("Key already present")))
        )
        (ß assoc(key, val))
    )

    #_method
    (§ defn #_"IPersistentMap" without [this, #_"Object" key]
        (when (ß key == nil)
            (§ return (ß hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        (when (ß root == nil)
            (§ return this)
        )
        (let [#_"INode" newroot (ß root.without(0, hash(key), key))]
            (when (ß newroot == root)
                (§ return this)
            )
            (ß new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue))
        )
    )

    (§ def #_"Iterator" EMPTY_ITER (ß new Iterator()
        (§ reify
            #_method
            (§ defn #_"boolean" hasNext [this]
                false
            )

            #_method
            (§ defn #_"Object" next [this]
                (throw (ß new NoSuchElementException()))
            )

            #_method
            (§ defn #_"void" remove [this]
                (throw (ß new UnsupportedOperationException()))
            )
        )
    ))

    #_method
    (§ defn- #_"Iterator" iterator [this, #_"IFn" f]
        (let [#_"Iterator" rootIter (ß (root == nil) ? EMPTY_ITER :or root.iterator(f))]
            (if hasNull
                (do
                    (ß new Iterator()
                        (§ reify
                            (§ field- #_"boolean" seen (ß false))

                            #_method
                            (§ defn #_"boolean" hasNext [this]
                                (if (ß !seen)
                                    (do
                                        true
                                    )
                                    (do
                                        (ß rootIter.hasNext())
                                    )
                                )
                            )

                            #_method
                            (§ defn #_"Object" next [this]
                                (if (ß !seen)
                                    (do
                                        (ß seen = true)
                                        (ß f.invoke(nil, nullValue))
                                    )
                                    (do
                                        (ß rootIter.next())
                                    )
                                )
                            )

                            #_method
                            (§ defn #_"void" remove [this]
                                (throw (ß new UnsupportedOperationException()))
                            )
                        )
                    )
                )
                (do
                    rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß iterator(APersistentMap.MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [this]
        (ß iterator(APersistentMap.MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [this]
        (ß iterator(APersistentMap.MAKE_VAL))
    )

    #_method
    (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
        (ß init = hasNull ? f.invoke(init, nil, nullValue) :or init)
        (when (ß RT.isReduced(init))
            (§ return (ß ((IDeref)init).deref()))
        )
        (when (ß root != nil)
            (ß init = root.kvreduce(f, init))
            (if (ß RT.isReduced(init))
                (do
                    (§ return (ß ((IDeref)init).deref()))
                )
                (do
                    (§ return init)
                )
            )
        )
        init
    )

    #_method
    (§ defn #_"Object" fold [this, #_"long" n, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjinvoke, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" top
                (ß new Callable()
                    (§ reify
                        #_method
                        (§ defn #_"Object" call [this] (§ throws Exception)
                            (let [#_"Object" ret (ß combinef.invoke())]
                                (when (ß root != nil)
                                    (ß ret = combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin)))
                                )
                                (ß hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), nil, nullValue)) :or ret)
                            )
                        )
                    )
                )]
            (ß fjinvoke.invoke(top))
        )
    )

    #_method
    (§ defn #_"int" count [this]
        count
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (let [#_"ISeq" s (ß (root != nil) ? root.nodeSeq() :or nil)]
            (ß hasNull ? new Cons(MapEntry.create(nil, nullValue), s) :or s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß EMPTY.withMeta(meta()))
    )

    (§ defn #_"int" mask [#_"int" hash, #_"int" shift]
        (ß (hash >>> shift) & 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentHashMap(meta, count, root, hasNull, nullValue))
    )

    #_method
    (§ defn #_"TransientHashMap" asTransient [this]
        (ß new TransientHashMap(this))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )

    (class-ns TransientHashMap (§ extends ATransientMap)
        (§ field #_"AtomicReference<Thread>" edit)
        #_volatile
        (§ field #_"INode" root)
        #_volatile
        (§ field #_"int" count)
        #_volatile
        (§ field #_"boolean" hasNull)
        #_volatile
        (§ field #_"Object" nullValue)
        (§ field #_"Box" leafFlag (ß new Box(nil)))

        (§ constructor #_"TransientHashMap" TransientHashMap [#_"PersistentHashMap" m]
            (§ this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue))
            this
        )

        (§ constructor #_"TransientHashMap" TransientHashMap [#_"AtomicReference<Thread>" edit, #_"INode" root, #_"int" count, #_"boolean" hasNull, #_"Object" nullValue]
            (ß this.edit = edit)
            (ß this.root = root)
            (ß this.count = count)
            (ß this.hasNull = hasNull)
            (ß this.nullValue = nullValue)
            this
        )

        #_method
        (§ defn #_"ITransientMap" doAssoc [this, #_"Object" key, #_"Object" val]
            (when (ß key == nil)
                (when (ß this.nullValue != val)
                    (ß this.nullValue = val)
                )
                (when (ß !hasNull)
                    (ß this.count++)
                    (ß this.hasNull = true)
                )
                (§ return this)
            )
            (ß leafFlag.val = nil)
            (let [#_"INode" n (ß ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag))]
                (when (ß n != this.root)
                    (ß this.root = n)
                )
                (when (ß leafFlag.val != nil)
                    (ß this.count++)
                )
                this
            )
        )

        #_method
        (§ defn #_"ITransientMap" doWithout [this, #_"Object" key]
            (when (ß key == nil)
                (when (ß !hasNull)
                    (§ return this)
                )
                (ß hasNull = false)
                (ß nullValue = nil)
                (ß this.count--)
                (§ return this)
            )
            (when (ß root == nil)
                (§ return this)
            )
            (ß leafFlag.val = nil)
            (let [#_"INode" n (ß root.without(edit, 0, hash(key), key, leafFlag))]
                (when (ß n != root)
                    (ß this.root = n)
                )
                (when (ß leafFlag.val != nil)
                    (ß this.count--)
                )
                this
            )
        )

        #_method
        (§ defn #_"IPersistentMap" doPersistent [this]
            (ß edit.set(nil))
            (ß new PersistentHashMap(count, root, hasNull, nullValue))
        )

        #_method
        (§ defn #_"Object" doValAt [this, #_"Object" key, #_"Object" notFound]
            (when (ß key == nil)
                (if hasNull
                    (do
                        (§ return nullValue)
                    )
                    (do
                        (§ return notFound)
                    )
                )
            )
            (when (ß root == nil)
                (§ return notFound)
            )
            (ß root.find(0, hash(key), key, notFound))
        )

        #_method
        (§ defn #_"int" doCount [this]
            count
        )

        #_method
        (§ defn #_"void" ensureEditable [this]
            (when (ß edit.get() == nil)
                (throw (ß new IllegalAccessError("Transient used after persistent! call")))
            )
            nil
        )
    )

    (§ interface INode
        (§ abstract INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(int shift, int hash, Object key))
        (§ abstract IMapEntry find(int shift, int hash, Object key))
        (§ abstract Object find(int shift, int hash, Object key, Object notFound))
        (§ abstract ISeq nodeSeq())
        (§ abstract INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf))
        (§ abstract Object kvreduce(IFn f, Object init))
        (§ abstract Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin))
        ;; returns the result of (f [k v]) for each iterated element
        (§ abstract Iterator iterator(IFn f))
    )

    (class-ns ArrayNode (§ implements INode)
        (§ field #_"int" count)
        (§ field #_"INode[]" array)
        (§ field #_"AtomicReference<Thread>" edit)

        (§ constructor #_"ArrayNode" ArrayNode [#_"AtomicReference<Thread>" edit, #_"int" count, #_"INode[]" array]
            (ß this.array = array)
            (ß this.edit = edit)
            (ß this.count = count)
            this
        )

        #_method
        (§ defn #_"INode" assoc [this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return (ß new ArrayNode(nil, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))))
                    )
                    (let [#_"INode" n (ß node.assoc(shift + 5, hash, key, val, addedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return this)
                    )
                    (let [#_"INode" n (ß node.without(shift + 5, hash, key))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (if (ß n == nil)
                            (do
                                (when (ß count <= 8) ;; shrink
                                    (§ return (ß pack(nil, idx)))
                                )
                                (ß new ArrayNode(nil, count - 1, cloneAndSet(array, idx, n)))
                            )
                            (do
                                (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"IMapEntry" find [this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return nil)
                    )
                    (ß node.find(shift + 5, hash, key))
                )
            )
        )

        #_method
        (§ defn #_"Object" find [this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return notFound)
                    )
                    (ß node.find(shift + 5, hash, key, notFound))
                )
            )
        )

        #_method
        (§ defn #_"ISeq" nodeSeq [this]
            (ß Seq.create(array))
        )

        #_method
        (§ defn #_"Iterator" iterator [this, #_"IFn" f]
            (ß new Iter(array, f))
        )

        #_method
        (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
            (doseq [#_"INode" node array]
                (when (ß node != nil)
                    (ß init = node.kvreduce(f, init))
                    (when (ß RT.isReduced(init))
                        (§ return init)
                    )
                )
            )
            init
        )

        #_method
        (§ defn #_"Object" fold [this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (let [#_"List<Callable>" tasks (ß new ArrayList())]
                (doseq [#_"INode" node array]
                    (when (ß node != nil)
                        (ß tasks.add(new Callable()
                            (§ reify
                                #_method
                                (§ defn #_"Object" call [this] (§ throws Exception)
                                    (ß node.fold(combinef, reducef, fjtask, fjfork, fjjoin))
                                )
                            ))
                        )
                    )
                )

                (ß foldTasks(tasks, combinef, fjtask, fjfork, fjjoin))
            )
        )

        (§ defn #_"Object" foldTasks [#_"List<Callable>" tasks, #_"IFn" combinef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (when (ß tasks.isEmpty())
                (§ return (ß combinef.invoke()))
            )

            (when (ß tasks.size() == 1)
                (let [#_"Object" ret nil]
                    (try
                        (§ return (ß tasks.get(0).call()))
                        (catch Exception e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
            )

            (let [#_"List<Callable>" t1 (ß tasks.subList(0, tasks.size() / 2))]
                (let [#_"List<Callable>" t2 (ß tasks.subList(tasks.size() / 2, tasks.size()))]
                    (let [#_"Object" forked
                            (ß fjfork.invoke(fjtask.invoke(new Callable()
                                (§ reify
                                    #_method
                                    (§ defn #_"Object" call [this] (§ throws Exception)
                                        (ß foldTasks(t2, combinef, fjtask, fjfork, fjjoin))
                                    )
                                )))
                            )]
                        (ß combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked)))
                    )
                )
            )
        )

        #_method
        (§ defn- #_"ArrayNode" ensureEditable [this, #_"AtomicReference<Thread>" edit]
            (when (ß this.edit == edit)
                (§ return this)
            )
            (ß new ArrayNode(edit, count, this.array.clone()))
        )

        #_method
        (§ defn- #_"ArrayNode" editAndSet [this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"INode" n]
            (let [#_"ArrayNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = n)
                editable
            )
        )

        #_method
        (§ defn- #_"INode" pack [this, #_"AtomicReference<Thread>" edit, #_"int" idx]
            (let [#_"Object[]" newArray (ß new Object[2 * (count - 1)])]
                (let [#_"int" j 1]
                    (let [#_"int" bitmap 0]
                        (loop-when-recur [(ß int i = 0)] (ß i < idx) [(ß i++)]
                            (when (ß array[i] != nil)
                                (ß newArray[j] = array[i])
                                (ß bitmap |= 1 << i)
                                (ß j += 2)
                            )
                        )
                        (loop-when-recur [(ß int i = idx + 1)] (ß i < array.length) [(ß i++)]
                            (when (ß array[i] != nil)
                                (ß newArray[j] = array[i])
                                (ß bitmap |= 1 << i)
                                (ß j += 2)
                            )
                        )
                        (ß new BitmapIndexedNode(edit, bitmap, newArray))
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" assoc [this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (let [#_"ArrayNode" editable (ß editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)))]
                            (ß editable.count++)
                            (§ return editable)
                        )
                    )
                    (let [#_"INode" n (ß node.assoc(edit, shift + 5, hash, key, val, addedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (ß editAndSet(edit, idx, n))
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return this)
                    )
                    (let [#_"INode" n (ß node.without(edit, shift + 5, hash, key, removedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (when (ß n == nil)
                            (when (ß count <= 8) ;; shrink
                                (§ return (ß pack(edit, idx)))
                            )
                            (let [#_"ArrayNode" editable (ß editAndSet(edit, idx, n))]
                                (ß editable.count--)
                                (§ return editable)
                            )
                        )
                        (ß editAndSet(edit, idx, n))
                    )
                )
            )
        )

        (class-ns Seq (§ extends ASeq)
            (§ field #_"INode[]" nodes)
            (§ field #_"int" i)
            (§ field #_"ISeq" s)

            (§ defn #_"ISeq" create [#_"INode[]" nodes]
                (ß create(nil, nodes, 0, nil))
            )

            (§ defn- #_"ISeq" create [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
                (when (ß s != nil)
                    (§ return (ß new Seq(meta, nodes, i, s)))
                )
                (loop-when-recur [(ß int j = i)] (ß j < nodes.length) [(ß j++)]
                    (when (ß nodes[j] != nil)
                        (let [#_"ISeq" ns (ß nodes[j].nodeSeq())]
                            (when (ß ns != nil)
                                (§ return (ß new Seq(meta, nodes, j + 1, ns)))
                            )
                        )
                    )
                )
                nil
            )

            (§ constructor- #_"Seq" Seq [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
                (§ super(meta))
                (ß this.nodes = nodes)
                (ß this.i = i)
                (ß this.s = s)
                this
            )

            #_method
            (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
                (ß new Seq(meta, nodes, i, s))
            )

            #_method
            (§ defn #_"Object" first [this]
                (ß s.first())
            )

            #_method
            (§ defn #_"ISeq" next [this]
                (ß create(nil, nodes, i, s.next()))
            )
        )

        (class-ns Iter (§ implements Iterator)
            (§ field- #_"INode[]" array)
            (§ field- #_"IFn" f)
            (§ field- #_"int" i (ß 0))
            (§ field- #_"Iterator" nestedIter)

            (§ constructor- #_"Iter" Iter [#_"INode[]" array, #_"IFn" f]
                (ß this.array = array)
                (ß this.f = f)
                this
            )

            #_method
            (§ defn #_"boolean" hasNext [this]
                (while true
                    (when (ß nestedIter != nil)
                        (if (ß nestedIter.hasNext())
                            (do
                                (§ return true)
                            )
                            (do
                                (ß nestedIter = nil)
                            )
                        )
                    )

                    (if (ß i < array.length)
                        (do
                            (let [#_"INode" node (ß array[i++])]
                                (when (ß node != nil)
                                    (ß nestedIter = node.iterator(f))
                                )
                            )
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )

            #_method
            (§ defn #_"Object" next [this]
                (if (ß hasNext())
                    (do
                        (ß nestedIter.next())
                    )
                    (do
                        (throw (ß new NoSuchElementException()))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [this]
                (throw (ß new UnsupportedOperationException()))
            )
        )
    )

    (class-ns BitmapIndexedNode (§ implements INode)
        (§ def #_"BitmapIndexedNode" EMPTY (ß new BitmapIndexedNode(nil, 0, new Object[0])))

        (§ field #_"int" bitmap)
        (§ field #_"Object[]" array)
        (§ field #_"AtomicReference<Thread>" edit)

        #_method
        (§ defn #_"int" index [this, #_"int" bit]
            (ß Integer.bitCount(bitmap & (bit - 1)))
        )

        (§ constructor #_"BitmapIndexedNode" BitmapIndexedNode [#_"AtomicReference<Thread>" edit, #_"int" bitmap, #_"Object[]" array]
            (ß this.bitmap = bitmap)
            (ß this.array = array)
            (ß this.edit = edit)
            this
        )

        #_method
        (§ defn #_"INode" assoc [this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (let [#_"int" idx (ß index(bit))]
                    (if (ß (bitmap & bit) != 0)
                        (do
                            (let [#_"Object" keyOrNull (ß array[2 * idx])]
                                (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                                    (when (ß keyOrNull == nil)
                                        (let [#_"INode" n (ß ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf))]
                                            (when (ß n == valOrNode)
                                                (§ return this)
                                            )
                                            (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                                        )
                                    )
                                    (when (ß Util.equiv(key, keyOrNull))
                                        (when (ß val == valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, val))))
                                    )
                                    (ß addedLeaf.val = addedLeaf)
                                    (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx, nil, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val))))
                                )
                            )
                        )
                        (do
                            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                                (if (ß n >= 16)
                                    (do
                                        (let [#_"INode[]" nodes (ß new INode[32])]
                                            (let [#_"int" jdx (ß mask(hash, shift))]
                                                (ß nodes[jdx] = EMPTY.assoc(shift + 5, hash, key, val, addedLeaf))
                                                (let [#_"int" j 0]
                                                    (loop-when-recur [(ß int i = 0)] (ß i < 32) [(ß i++)]
                                                        (when (ß ((bitmap >>> i) & 1) != 0)
                                                            (if (ß array[j] == nil)
                                                                (do
                                                                    (ß nodes[i] = (INode) array[j + 1])
                                                                )
                                                                (do
                                                                    (ß nodes[i] = EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                                                                )
                                                            )
                                                            (ß j += 2)
                                                        )
                                                    )
                                                    (ß new ArrayNode(nil, n + 1, nodes))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Object[]" newArray (ß new Object[2 * (n + 1)])]
                                            (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                                            (ß newArray[2 * idx] = key)
                                            (ß addedLeaf.val = addedLeaf)
                                            (ß newArray[2 * idx + 1] = val)
                                            (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                                            (ß new BitmapIndexedNode(nil, bitmap | bit, newArray))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return this)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (let [#_"INode" n (ß ((INode) valOrNode).without(shift + 5, hash, key))]
                                    (when (ß n == valOrNode)
                                        (§ return this)
                                    )
                                    (when (ß n != nil)
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                                    )
                                    (when (ß bitmap == bit)
                                        (§ return nil)
                                    )
                                    (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
                                )
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                ;; TODO: collapse
                                (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
                            )
                            this
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"IMapEntry" find [this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return nil)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key)))
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ return (ß (IMapEntry) MapEntry.create(keyOrNull, valOrNode)))
                            )
                            nil
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object" find [this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return notFound)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key, notFound)))
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ return valOrNode)
                            )
                            notFound
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"ISeq" nodeSeq [this]
            (ß NodeSeq.create(array))
        )

        #_method
        (§ defn #_"Iterator" iterator [this, #_"IFn" f]
            (ß new NodeIter(array, f))
        )

        #_method
        (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
            (ß NodeSeq.kvreduce(array, f, init))
        )

        #_method
        (§ defn #_"Object" fold [this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" ensureEditable [this, #_"AtomicReference<Thread>" edit]
            (when (ß this.edit == edit)
                (§ return this)
            )
            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                (let [#_"Object[]" newArray (ß new Object[(n >= 0) ? 2 * (n + 1) :or 4])] ;; make room for next assoc
                    (ß System.arraycopy(array, 0, newArray, 0, 2 * n))
                    (ß new BitmapIndexedNode(edit, bitmap, newArray))
                )
            )
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" editAndSet [this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                editable
            )
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" editAndSet [this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                (ß editable.array[j] = b)
                editable
            )
        )

        #_method
        (§ defn- #_"BitmapIndexedNode" editAndRemovePair [this, #_"AtomicReference<Thread>" edit, #_"int" bit, #_"int" i]
            (when (ß bitmap == bit)
                (§ return nil)
            )
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (ß editable.bitmap ^= bit)
                (ß System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1)))
                (ß editable.array[editable.array.length - 2] = nil)
                (ß editable.array[editable.array.length - 1] = nil)
                editable
            )
        )

        #_method
        (§ defn #_"INode" assoc [this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (let [#_"int" idx (ß index(bit))]
                    (if (ß (bitmap & bit) != 0)
                        (do
                            (let [#_"Object" keyOrNull (ß array[2 * idx])]
                                (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                                    (when (ß keyOrNull == nil)
                                        (let [#_"INode" n (ß ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf))]
                                            (when (ß n == valOrNode)
                                                (§ return this)
                                            )
                                            (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                                        )
                                    )
                                    (when (ß Util.equiv(key, keyOrNull))
                                        (when (ß val == valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß editAndSet(edit, 2 * idx + 1, val)))
                                    )
                                    (ß addedLeaf.val = addedLeaf)
                                    (ß editAndSet(edit, 2 * idx, nil, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val)))
                                )
                            )
                        )
                        (do
                            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                                (when (ß n * 2 < array.length)
                                    (ß addedLeaf.val = addedLeaf)
                                    (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                                        (ß System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx)))
                                        (ß editable.array[2 * idx] = key)
                                        (ß editable.array[2 * idx + 1] = val)
                                        (ß editable.bitmap |= bit)
                                        (§ return editable)
                                    )
                                )
                                (if (ß n >= 16)
                                    (do
                                        (let [#_"INode[]" nodes (ß new INode[32])]
                                            (let [#_"int" jdx (ß mask(hash, shift))]
                                                (ß nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf))
                                                (let [#_"int" j 0]
                                                    (loop-when-recur [(ß int i = 0)] (ß i < 32) [(ß i++)]
                                                        (when (ß ((bitmap >>> i) & 1) != 0)
                                                            (if (ß array[j] == nil)
                                                                (do
                                                                    (ß nodes[i] = (INode) array[j + 1])
                                                                )
                                                                (do
                                                                    (ß nodes[i] = EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                                                                )
                                                            )
                                                            (ß j += 2)
                                                        )
                                                    )
                                                    (ß new ArrayNode(edit, n + 1, nodes))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Object[]" newArray (ß new Object[2 * (n + 4)])]
                                            (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                                            (ß newArray[2 * idx] = key)
                                            (ß addedLeaf.val = addedLeaf)
                                            (ß newArray[2 * idx + 1] = val)
                                            (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                                            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                                                (ß editable.array = newArray)
                                                (ß editable.bitmap |= bit)
                                                editable
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        #_method
        (§ defn #_"INode" without [this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return this)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (let [#_"INode" n (ß ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf))]
                                    (when (ß n == valOrNode)
                                        (§ return this)
                                    )
                                    (when (ß n != nil)
                                        (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                                    )
                                    (when (ß bitmap == bit)
                                        (§ return nil)
                                    )
                                    (§ return (ß editAndRemovePair(edit, bit, idx)))
                                )
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (ß removedLeaf.val = removedLeaf)
                                ;; TODO: collapse
                                (§ return (ß editAndRemovePair(edit, bit, idx)))
                            )
                            this
                        )
                    )
                )
            )
        )
    )

    (class-ns HashCollisionNode (§ implements INode)
        (§ field #_"int" hash)
        (§ field #_"int" count)
        (§ field #_"Object[]" array)
        (§ field #_"AtomicReference<Thread>" edit)

        (§ constructor #_"HashCollisionNode" HashCollisionNode [#_"AtomicReference<Thread>" edit, #_"int" hash, #_"int" count, #_"Object..." array]
            (ß this.edit = edit)
            (ß this.hash = hash)
            (ß this.count = count)
            (ß this.array = array)
            this
        )

        #_method
        (§ defn #_"INode" assoc [this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (when (ß hash == this.hash)
                (let [#_"int" idx (ß findIndex(key))]
                    (when (ß idx != -1)
                        (when (ß array[idx + 1] == val)
                            (§ return this)
                        )
                        (§ return (ß new HashCollisionNode(nil, hash, count, cloneAndSet(array, idx + 1, val))))
                    )
                    (let [#_"Object[]" newArray (ß new Object[2 * (count + 1)])]
                        (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                        (ß newArray[2 * count] = key)
                        (ß newArray[2 * count + 1] = val)
                        (ß addedLeaf.val = addedLeaf)
                        (§ return (ß new HashCollisionNode(edit, hash, count + 1, newArray)))
                    )
                )
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(nil, bitpos(this.hash, shift), new Object[] (§ nil, this )).assoc(shift, hash, key, val, addedLeaf))
        )

        #_method
        (§ defn #_"INode" without [this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx == -1)
                    (§ return this)
                )
                (when (ß count == 1)
                    (§ return nil)
                )
                (ß new HashCollisionNode(nil, hash, count - 1, removePair(array, idx / 2)))
            )
        )

        #_method
        (§ defn #_"IMapEntry" find [this, #_"int" shift, #_"int" hash, #_"Object" key]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx < 0)
                    (§ return nil)
                )
                (when (ß Util.equiv(key, array[idx]))
                    (§ return (ß (IMapEntry) MapEntry.create(array[idx], array[idx + 1])))
                )
                nil
            )
        )

        #_method
        (§ defn #_"Object" find [this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx < 0)
                    (§ return notFound)
                )
                (when (ß Util.equiv(key, array[idx]))
                    (§ return (ß array[idx + 1]))
                )
                notFound
            )
        )

        #_method
        (§ defn #_"ISeq" nodeSeq [this]
            (ß NodeSeq.create(array))
        )

        #_method
        (§ defn #_"Iterator" iterator [this, #_"IFn" f]
            (ß new NodeIter(array, f))
        )

        #_method
        (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
            (ß NodeSeq.kvreduce(array, f, init))
        )

        #_method
        (§ defn #_"Object" fold [this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        #_method
        (§ defn #_"int" findIndex [this, #_"Object" key]
            (loop-when-recur [(ß int i = 0)] (ß i < 2 * count) [(ß i += 2)]
                (when (ß Util.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )

        #_method
        (§ defn- #_"HashCollisionNode" ensureEditable [this, #_"AtomicReference<Thread>" edit]
            (when (ß this.edit == edit)
                (§ return this)
            )
            (let [#_"Object[]" newArray (ß new Object[2 * (count + 1)])] ;; make room for next assoc
                (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                (ß new HashCollisionNode(edit, hash, count, newArray))
            )
        )

        #_method
        (§ defn- #_"HashCollisionNode" ensureEditable [this, #_"AtomicReference<Thread>" edit, #_"int" count, #_"Object[]" array]
            (when (ß this.edit == edit)
                (ß this.array = array)
                (ß this.count = count)
                (§ return this)
            )
            (ß new HashCollisionNode(edit, hash, count, array))
        )

        #_method
        (§ defn- #_"HashCollisionNode" editAndSet [this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
            (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                editable
            )
        )

        #_method
        (§ defn- #_"HashCollisionNode" editAndSet [this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
            (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                (ß editable.array[j] = b)
                editable
            )
        )

        #_method
        (§ defn #_"INode" assoc [this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
            (when (ß hash == this.hash)
                (let [#_"int" idx (ß findIndex(key))]
                    (when (ß idx != -1)
                        (when (ß array[idx + 1] == val)
                            (§ return this)
                        )
                        (§ return (ß editAndSet(edit, idx + 1, val)))
                    )
                    (when (ß array.length > 2 * count)
                        (ß addedLeaf.val = addedLeaf)
                        (let [#_"HashCollisionNode" editable (ß editAndSet(edit, 2 * count, key, 2 * count + 1, val))]
                            (ß editable.count++)
                            (§ return editable)
                        )
                    )
                    (let [#_"Object[]" newArray (ß new Object[array.length + 2])]
                        (ß System.arraycopy(array, 0, newArray, 0, array.length))
                        (ß newArray[array.length] = key)
                        (ß newArray[array.length + 1] = val)
                        (ß addedLeaf.val = addedLeaf)
                        (§ return (ß ensureEditable(edit, count + 1, newArray)))
                    )
                )
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ nil, this, nil, nil )).assoc(edit, shift, hash, key, val, addedLeaf))
        )

        #_method
        (§ defn #_"INode" without [this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx == -1)
                    (§ return this)
                )
                (ß removedLeaf.val = removedLeaf)
                (when (ß count == 1)
                    (§ return nil)
                )
                (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                    (ß editable.array[idx] = editable.array[2 * count - 2])
                    (ß editable.array[idx + 1] = editable.array[2 * count - 1])
                    (ß editable.array[2 * count - 2] = editable.array[2 * count - 1] = nil)
                    (ß editable.count--)
                    editable
                )
            )
        )
    )

    (§ defn- #_"INode[]" cloneAndSet [#_"INode[]" array, #_"int" i, #_"INode" a]
        (let [#_"INode[]" clone (ß array.clone())]
            (ß clone[i] = a)
            clone
        )
    )

    (§ defn- #_"Object[]" cloneAndSet [#_"Object[]" array, #_"int" i, #_"Object" a]
        (let [#_"Object[]" clone (ß array.clone())]
            (ß clone[i] = a)
            clone
        )
    )

    (§ defn- #_"Object[]" cloneAndSet [#_"Object[]" array, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
        (let [#_"Object[]" clone (ß array.clone())]
            (ß clone[i] = a)
            (ß clone[j] = b)
            clone
        )
    )

    (§ defn- #_"Object[]" removePair [#_"Object[]" array, #_"int" i]
        (let [#_"Object[]" newArray (ß new Object[array.length - 2])]
            (ß System.arraycopy(array, 0, newArray, 0, 2 * i))
            (ß System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i))
            newArray
        )
    )

    (§ defn- #_"INode" createNode [#_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (ß hash(key1))]
            (when (ß key1hash == key2hash)
                (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
            )
            (let [#_"Box" addedLeaf (ß new Box(nil))]
                (let [#_"AtomicReference<Thread>" edit (ß new AtomicReference<Thread>())]
                    (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
                )
            )
        )
    )

    (§ defn- #_"INode" createNode [#_"AtomicReference<Thread>" edit, #_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (ß hash(key1))]
            (when (ß key1hash == key2hash)
                (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
            )
            (let [#_"Box" addedLeaf (ß new Box(nil))]
                (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
            )
        )
    )

    (§ defn- #_"int" bitpos [#_"int" hash, #_"int" shift]
        (ß 1 << mask(hash, shift))
    )

    (class-ns NodeIter (§ implements Iterator)
        (§ def- #_"Object" NULL (ß new Object()))
        (§ field #_"Object[]" array)
        (§ field #_"IFn" f)
        (§ field- #_"int" i (ß 0))
        (§ field- #_"Object" nextEntry (ß NULL))
        (§ field- #_"Iterator" nextIter)

        (§ constructor #_"NodeIter" NodeIter [#_"Object[]" array, #_"IFn" f]
            (ß this.array = array)
            (ß this.f = f)
            this
        )

        #_method
        (§ defn- #_"boolean" advance [this]
            (while (ß i < array.length)
                (let [#_"Object" key (ß array[i])]
                    (let [#_"Object" nodeOrVal (ß array[i + 1])]
                        (ß i += 2)
                        (cond (ß key != nil)
                            (do
                                (ß nextEntry = f.invoke(key, nodeOrVal))
                                (§ return true)
                            )
                            (ß nodeOrVal != nil)
                            (do
                                (let [#_"Iterator" iter (ß ((INode) nodeOrVal).iterator(f))]
                                    (when (ß iter != nil && iter.hasNext())
                                        (ß nextIter = iter)
                                        (§ return true)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            false
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (when (ß nextEntry != NULL || nextIter != nil)
                (§ return true)
            )
            (ß advance())
        )

        #_method
        (§ defn #_"Object" next [this]
            (let [#_"Object" ret nextEntry]
                (cond (ß ret != NULL)
                    (do
                        (ß nextEntry = NULL)
                        (§ return ret)
                    )
                    (ß nextIter != nil)
                    (do
                        (ß ret = nextIter.next())
                        (when (ß !nextIter.hasNext())
                            (ß nextIter = nil)
                        )
                        (§ return ret)
                    )
                    (ß advance())
                    (do
                        (§ return (ß next()))
                    )
                )
                (throw (ß new NoSuchElementException()))
            )
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (class-ns NodeSeq (§ extends ASeq)
        (§ field #_"Object[]" array)
        (§ field #_"int" i)
        (§ field #_"ISeq" s)

        (§ constructor #_"NodeSeq" NodeSeq [#_"Object[]" array, #_"int" i]
            (§ this(nil, array, i, nil))
            this
        )

        (§ defn #_"ISeq" create [#_"Object[]" array]
            (ß create(array, 0, nil))
        )

        (§ defn #_"Object" kvreduce [#_"Object[]" array, #_"IFn" f, #_"Object" init]
            (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                (if (ß array[i] != nil)
                    (do
                        (ß init = f.invoke(init, array[i], array[i + 1]))
                    )
                    (do
                        (let [#_"INode" node (ß (INode) array[i + 1])]
                            (when (ß node != nil)
                                (ß init = node.kvreduce(f, init))
                            )
                        )
                    )
                )
                (when (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            init
        )

        (§ defn- #_"ISeq" create [#_"Object[]" array, #_"int" i, #_"ISeq" s]
            (when (ß s != nil)
                (§ return (ß new NodeSeq(nil, array, i, s)))
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j+=2)]
                (when (ß array[j] != nil)
                    (§ return (ß new NodeSeq(nil, array, j, nil)))
                )
                (let [#_"INode" node (ß (INode) array[j + 1])]
                    (when (ß node != nil)
                        (let [#_"ISeq" nodeSeq (ß node.nodeSeq())]
                            (when (ß nodeSeq != nil)
                                (§ return (ß new NodeSeq(nil, array, j + 2, nodeSeq)))
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ constructor #_"NodeSeq" NodeSeq [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i, #_"ISeq" s]
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            (ß this.s = s)
            this
        )

        #_method
        (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
            (ß new NodeSeq(meta, array, i, s))
        )

        #_method
        (§ defn #_"Object" first [this]
            (when (ß s != nil)
                (§ return (ß s.first()))
            )
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß s != nil)
                (§ return (ß create(array, i, s.next())))
            )
            (ß create(array, i + 2, nil))
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" EMPTY (ß new PersistentHashSet(nil, PersistentHashMap.EMPTY)))

    (§ field #_"IPersistentMap" _meta)

    (§ defn #_"PersistentHashSet" create [#_"Object..." init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i++)]
                (ß ret = (ITransientSet)ret.conj(init[i]))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" create [#_"List" init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (doseq [#_"Object" key init]
                (ß ret = (ITransientSet) ret.conj(key))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" create [#_"ISeq" items]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = (ITransientSet) ret.conj(items.first()))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" createWithCheck [#_"Object..." init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i++)]
                (ß ret = (ITransientSet) ret.conj(init[i]))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + init[i])))
                )
            )
            (ß (PersistentHashSet) ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" createWithCheck [#_"List" init]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (let [#_"int" i 0]
                (doseq [#_"Object" key init]
                    (ß ret = (ITransientSet) ret.conj(key))
                    (when (ß ret.count() != i + 1)
                        (throw (ß new IllegalArgumentException("Duplicate key: " + key)))
                    )
                    (ß ++i)
                )
                (ß (PersistentHashSet) ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentHashSet" createWithCheck [#_"ISeq" items]
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß items != nil) [(ß items = items.next(), ++i)]
                (ß ret = (ITransientSet) ret.conj(items.first()))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + items.first())))
                )
            )
            (ß (PersistentHashSet) ret.persistent())
        )
    )

    (§ constructor #_"PersistentHashSet" PersistentHashSet [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (§ super(impl))
        (ß this._meta = meta)
        this
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [this, #_"Object" key]
        (when (ß contains(key))
            (§ return (ß new PersistentHashSet(meta(), impl.without(key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [this, #_"Object" o]
        (when (ß contains(o))
            (§ return this)
        )
        (ß new PersistentHashSet(meta(), impl.assoc(o, o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentHashSet" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentHashSet(meta, impl))
    )

    #_method
    (§ defn #_"ITransientCollection" asTransient [this]
        (ß new TransientHashSet(((PersistentHashMap) impl).asTransient()))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )

    (class-ns TransientHashSet (§ extends ATransientSet)
        (§ constructor #_"TransientHashSet" TransientHashSet [#_"ITransientMap" impl]
            (§ super(impl))
            this
        )

        #_method
        (§ defn #_"IPersistentCollection" persistent [this]
            (ß new PersistentHashSet(nil, impl.persistent()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ field- #_"Object" _first)
    (§ field- #_"IPersistentList" _rest)
    (§ field- #_"int" _count)

    (class-ns Primordial (§ extends RestFn)
        #_method
        (§ defn #_"int" getRequiredArity [this]
            0
        )

        #_protected
        #_method
        (§ defn #_"Object" doInvoke [this, #_"Object" args]
            (when (ß args instanceof ArraySeq)
                (let [#_"Object[]" argsarray (ß ((ArraySeq) args).array)]
                    (let [#_"IPersistentList" ret (ß EMPTY)]
                        (loop-when-recur [(ß int i = argsarray.length - 1)] (ß i >= ((ArraySeq)args).i) [(ß --i)]
                            (ß ret = (IPersistentList) ret.cons(argsarray[i]))
                        )
                        (§ return ret)
                    )
                )
            )
            (let [#_"LinkedList" list (ß new LinkedList())]
                (loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                    (ß list.add(s.first()))
                )
                (ß create(list))
            )
        )

        (§ defn #_"Object" invokeStatic [#_"ISeq" args]
            (when (ß args instanceof ArraySeq)
                (let [#_"Object[]" argsarray (ß ((ArraySeq) args).array)]
                    (let [#_"IPersistentList" ret (ß EMPTY)]
                        (loop-when-recur [(ß int i = argsarray.length - 1)] (ß i >= 0) [(ß --i)]
                            (ß ret = (IPersistentList) ret.cons(argsarray[i]))
                        )
                        (§ return ret)
                    )
                )
            )
            (let [#_"LinkedList" list (ß new LinkedList())]
                (loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                    (ß list.add(s.first()))
                )
                (ß create(list))
            )
        )

        #_method
        (§ defn #_"IObj" withMeta [this, #_"IPersistentMap" meta]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"IPersistentMap" meta [this]
            nil
        )
    )

    (§ def #_"IFn" creator (ß new Primordial()))

    (§ def #_"EmptyList" EMPTY (ß new EmptyList(nil)))

    (§ constructor #_"PersistentList" PersistentList [#_"Object" first]
        (ß this._first = first)
        (ß this._rest = nil)

        (ß this._count = 1)
        this
    )

    (§ constructor #_"PersistentList" PersistentList [#_"IPersistentMap" meta, #_"Object" _first, #_"IPersistentList" _rest, #_"int" _count]
        (§ super(meta))
        (ß this._first = _first)
        (ß this._rest = _rest)
        (ß this._count = _count)
        this
    )

    (§ defn #_"IPersistentList" create [#_"List" init]
        (let [#_"IPersistentList" ret (ß EMPTY)]
            (loop-when-recur [(ß ListIterator i = init.listIterator(init.size()))] (ß i.hasPrevious()) [(ß )]
                (ß ret = (IPersistentList) ret.cons(i.previous()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" first [this]
        (ß _first)
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß _count == 1)
            (§ return nil)
        )
        (ß (ISeq) _rest)
    )

    #_method
    (§ defn #_"Object" peek [this]
        (ß first())
    )

    #_method
    (§ defn #_"IPersistentList" pop [this]
        (when (ß _rest == nil)
            (§ return (ß EMPTY.withMeta(_meta)))
        )
        (ß _rest)
    )

    #_method
    (§ defn #_"int" count [this]
        (ß _count)
    )

    #_method
    (§ defn #_"PersistentList" cons [this, #_"Object" o]
        (ß new PersistentList(meta(), o, this, _count + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentList" withMeta [this, #_"IPersistentMap" meta]
        (when (ß meta != _meta)
            (§ return (ß new PersistentList(meta, _first, _rest, _count)))
        )
        this
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (let [#_"Object" ret (ß first())]
            (loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next())]
                (ß ret = f.invoke(ret, s.first()))
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret (ß f.invoke(start, first()))]
            (loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next())]
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, s.first()))
            )
            (when (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )
    )

    (class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
        (§ def #_"int" hasheq (ß Murmur3.hashOrdered(Collections.EMPTY_LIST)))

        #_method
        (§ defn #_"int" hashCode [this]
            1
        )

        #_method
        (§ defn #_"int" hasheq [this]
            hasheq
        )

        #_method
        (§ defn #_"String" toString [this]
            (ß "()")
        )

        #_method
        (§ defn #_"boolean" equals [this, #_"Object" o]
            (ß ((o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )

        #_method
        (§ defn #_"boolean" equiv [this, #_"Object" o]
            (ß equals(o))
        )

        (§ constructor #_"EmptyList" EmptyList [#_"IPersistentMap" meta]
            (§ super(meta))
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            nil
        )

        #_method
        (§ defn #_"ISeq" next [this]
            nil
        )

        #_method
        (§ defn #_"ISeq" more [this]
            this
        )

        #_method
        (§ defn #_"PersistentList" cons [this, #_"Object" o]
            (ß new PersistentList(meta(), o, nil, 1))
        )

        #_method
        (§ defn #_"IPersistentCollection" empty [this]
            this
        )

        #_method
        (§ defn #_"EmptyList" withMeta [this, #_"IPersistentMap" meta]
            (when (ß meta != meta())
                (§ return (ß new EmptyList(meta)))
            )
            this
        )

        #_method
        (§ defn #_"Object" peek [this]
            nil
        )

        #_method
        (§ defn #_"IPersistentList" pop [this]
            (throw (ß new IllegalStateException("Can't pop empty list")))
        )

        #_method
        (§ defn #_"int" count [this]
            0
        )

        #_method
        (§ defn #_"ISeq" seq [this]
            nil
        )

        #_method
        (§ defn #_"int" size [this]
            0
        )

        #_method
        (§ defn #_"boolean" isEmpty [this]
            true
        )

        #_method
        (§ defn #_"boolean" contains [this, #_"Object" o]
            false
        )

        #_method
        (§ defn #_"Iterator" iterator [this]
            (ß new Iterator()
                (§ reify
                    #_method
                    (§ defn #_"boolean" hasNext [this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" next [this]
                        (throw (ß new NoSuchElementException()))
                    )

                    #_method
                    (§ defn #_"void" remove [this]
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )

        #_method
        (§ defn #_"Object[]" toArray [this]
            (ß RT.EMPTY_ARRAY)
        )

        #_method
        (§ defn #_"boolean" add [this, #_"Object" o]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"boolean" remove [this, #_"Object" o]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"boolean" addAll [this, #_"Collection" collection]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"void" clear [this]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"boolean" retainAll [this, #_"Collection" collection]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"boolean" removeAll [this, #_"Collection" collection]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"boolean" containsAll [this, #_"Collection" collection]
            (ß collection.isEmpty())
        )

        #_method
        (§ defn #_"Object[]" toArray [this, #_"Object[]" objects]
            (when (ß objects.length > 0)
                (ß objects[0] = nil)
            )
            objects
        )

        #_method
        (§ defn- #_"List" reify [this]
            (ß Collections.unmodifiableList(new ArrayList(this)))
        )

        #_method
        (§ defn #_"List" subList [this, #_"int" fromIndex, #_"int" toIndex]
            (ß reify().subList(fromIndex, toIndex))
        )

        #_method
        (§ defn #_"Object" set [this, #_"int" index, #_"Object" element]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"Object" remove [this, #_"int" index]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"int" indexOf [this, #_"Object" o]
            (let [#_"ISeq" s (ß seq())]
                (loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                    (when (ß Util.equiv(s.first(), o))
                        (§ return i)
                    )
                )
                -1
            )
        )

        #_method
        (§ defn #_"int" lastIndexOf [this, #_"Object" o]
            (ß reify().lastIndexOf(o))
        )

        #_method
        (§ defn #_"ListIterator" listIterator [this]
            (ß reify().listIterator())
        )

        #_method
        (§ defn #_"ListIterator" listIterator [this, #_"int" index]
            (ß reify().listIterator(index))
        )

        #_method
        (§ defn #_"Object" get [this, #_"int" index]
            (ß RT.nth(this, index))
        )

        #_method
        (§ defn #_"void" add [this, #_"int" index, #_"Object" element]
            (throw (ß new UnsupportedOperationException()))
        )

        #_method
        (§ defn #_"boolean" addAll [this, #_"int" index, #_"Collection" c]
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" EMPTY (ß new PersistentQueue(nil, 0, nil, nil)))

    (§ field #_"int" cnt)
    (§ field #_"ISeq" f)
    (§ field #_"PersistentVector" r)
    (§ field #_"int" _hash)
    (§ field #_"int" _hasheq)

    (§ constructor #_"PersistentQueue" PersistentQueue [#_"IPersistentMap" meta, #_"int" cnt, #_"ISeq" f, #_"PersistentVector" r]
        (§ super(meta))
        (ß this.cnt = cnt)
        (ß this.f = f)
        (ß this.r = r)
        this
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (when (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (when (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equals(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (ß hash = 1)
                (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                    (ß hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
                )
                (ß this._hash = hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (ß this._hasheq = cached = Murmur3.hashOrdered(this))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object" peek [this]
        (ß RT.first(f))
    )

    #_method
    (§ defn #_"PersistentQueue" pop [this]
        (when (ß f == nil) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" f1 (ß f.next())]
            (let [#_"PersistentVector" r1 r]
                (when (ß f1 == nil)
                    (ß f1 = RT.seq(r))
                    (ß r1 = nil)
                )
                (ß new PersistentQueue(meta(), cnt - 1, f1, r1))
            )
        )
    )

    #_method
    (§ defn #_"int" count [this]
        cnt
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (when (ß f == nil)
            (§ return nil)
        )
        (ß new Seq(f, RT.seq(r)))
    )

    #_method
    (§ defn #_"PersistentQueue" cons [this, #_"Object" o]
        (if (ß f == nil) ;; empty
            (do
                (ß new PersistentQueue(meta(), cnt + 1, RT.list(o), nil))
            )
            (do
                (ß new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector.EMPTY).cons(o)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentQueue" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentQueue(meta, cnt, f, r))
    )

    (class-ns Seq (§ extends ASeq)
        (§ field #_"ISeq" f)
        (§ field #_"ISeq" rseq)

        (§ constructor #_"Seq" Seq [#_"ISeq" f, #_"ISeq" rseq]
            (ß this.f = f)
            (ß this.rseq = rseq)
            this
        )

        (§ constructor #_"Seq" Seq [#_"IPersistentMap" meta, #_"ISeq" f, #_"ISeq" rseq]
            (§ super(meta))
            (ß this.f = f)
            (ß this.rseq = rseq)
            this
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß f.first())
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (let [#_"ISeq" f1 (ß f.next())]
                (let [#_"ISeq" r1 rseq]
                    (when (ß f1 == nil)
                        (when (ß rseq == nil)
                            (§ return nil)
                        )
                        (ß f1 = rseq)
                        (ß r1 = nil)
                    )
                    (ß new Seq(f1, r1))
                )
            )
        )

        #_method
        (§ defn #_"int" count [this]
            (ß RT.count(f) + RT.count(rseq))
        )

        #_method
        (§ defn #_"Seq" withMeta [this, #_"IPersistentMap" meta]
            (ß new Seq(meta, f, rseq))
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [this]
        (ß RT.seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" remove [this, #_"Object" o]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" addAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"void" clear [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" retainAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" removeAll [this, #_"Collection" c]
        (throw (ß new UnsupportedOperationException()))
    )

    #_method
    (§ defn #_"boolean" containsAll [this, #_"Collection" c]
        (doseq [#_"Object" o c]
            (when (ß contains(o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" toArray [this, #_"Object[]" a]
        (ß RT.seqToPassedArray(seq(), a))
    )

    #_method
    (§ defn #_"int" size [this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [this, #_"Object" o]
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß new Iterator()
            (§ reify
                (§ field- #_"ISeq" fseq (ß f))
                (§ field- #_"Iterator" riter (ß (r != nil) ? r.iterator() :or nil))

                #_method
                (§ defn #_"boolean" hasNext [this]
                    (ß ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext())))
                )

                #_method
                (§ defn #_"Object" next [this]
                    (cond (ß fseq != nil)
                        (do
                            (let [#_"Object" ret (ß fseq.first())]
                                (ß fseq = fseq.next())
                                ret
                            )
                        )
                        (ß riter != nil && riter.hasNext())
                        (do
                            (ß riter.next())
                        )
                        :else
                        (do
                            (throw (ß new NoSuchElementException()))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [this]
                    (throw (ß new UnsupportedOperationException()))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ field #_"Comparator" comp)
    (§ field #_"Node" tree)
    (§ field #_"int" _count)
    (§ field #_"IPersistentMap" _meta)

    (§ def #_"PersistentTreeMap" EMPTY (ß new PersistentTreeMap()))

    (§ defn #_"IPersistentMap" create [#_"Map" other]
        (let [#_"IPersistentMap" ret (ß EMPTY)]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(ß Map.Entry e = (Entry) o)]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            ret
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap []
        (§ this(RT.DEFAULT_COMPARATOR))
        this
    )

    #_method
    (§ defn #_"PersistentTreeMap" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentTreeMap(meta, comp, tree, _count))
    )

    (§ constructor- #_"PersistentTreeMap" PersistentTreeMap [#_"Comparator" comp]
        (§ this(nil, comp))
        this
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"IPersistentMap" meta, #_"Comparator" comp]
        (ß this.comp = comp)
        (ß this._meta = meta)
        (ß tree = nil)
        (ß _count = 0)
        this
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"IPersistentMap" meta, #_"Comparator" comp, #_"Node" tree, #_"int" _count]
        (ß this._meta = meta)
        (ß this.comp = comp)
        (ß this.tree = tree)
        (ß this._count = _count)
        this
    )

    (§ defn #_"PersistentTreeMap" create [#_"ISeq" items]
        (let [#_"IPersistentMap" ret (ß EMPTY)]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
            )
            (ß (PersistentTreeMap) ret)
        )
    )

    (§ defn #_"PersistentTreeMap" create [#_"Comparator" comp, #_"ISeq" items]
        (let [#_"IPersistentMap" ret (ß new PersistentTreeMap(comp))]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
            )
            (ß (PersistentTreeMap) ret)
        )
    )

    #_method
    (§ defn #_"boolean" containsKey [this, #_"Object" key]
        (ß (entryAt(key) != nil))
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (try
            (ß super.equals(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (try
            (ß super.equiv(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assocEx [this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (ß new Box(nil))]
            (let [#_"Node" t (ß add(tree, key, val, found))]
                (when (ß t == nil) ;; nil == already contains key
                    (throw (ß Util.runtimeException("Key already present")))
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assoc [this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (ß new Box(nil))]
            (let [#_"Node" t (ß add(tree, key, val, found))]
                (when (ß t == nil) ;; nil == already contains key
                    (let [#_"Node" foundNode (ß (Node) found.val)]
                        (when (ß foundNode.val() == val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())))
                    )
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" without [this, #_"Object" key]
        (let [#_"Box" found (ß new Box(nil))]
            (let [#_"Node" t (ß remove(tree, key, found))]
                (when (ß t == nil)
                    (when (ß found.val == nil) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß new PersistentTreeMap(meta(), comp)))
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count - 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (when (ß _count > 0)
            (§ return (ß Seq.create(tree, true, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß new PersistentTreeMap(meta(), comp))
    )

    #_method
    (§ defn #_"ISeq" rseq [this]
        (when (ß _count > 0)
            (§ return (ß Seq.create(tree, false, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"Comparator" comparator [this]
        comp
    )

    #_method
    (§ defn #_"Object" entryKey [this, #_"Object" entry]
        (ß ((IMapEntry) entry).key())
    )

    #_method
    (§ defn #_"ISeq" seq [this, #_"boolean" ascending]
        (when (ß _count > 0)
            (§ return (ß Seq.create(tree, ascending, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" seqFrom [this, #_"Object" key, #_"boolean" ascending]
        (when (ß _count > 0)
            (let [#_"ISeq" stack nil]
                (let [#_"Node" t tree]
                    (while (ß t != nil)
                        (let [#_"int" c (ß doCompare(key, t.key))]
                            (cond (ß c == 0)
                                (do
                                    (ß stack = RT.cons(t, stack))
                                    (§ return (ß new Seq(stack, ascending)))
                                )
                                ascending
                                (do
                                    (if (ß c < 0)
                                        (do
                                            (ß stack = RT.cons(t, stack))
                                            (ß t = t.left())
                                        )
                                        (do
                                            (ß t = t.right())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (ß c > 0)
                                        (do
                                            (ß stack = RT.cons(t, stack))
                                            (ß t = t.right())
                                        )
                                        (do
                                            (ß t = t.left())
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (ß stack != nil)
                        (§ return (ß new Seq(stack, ascending)))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"NodeIterator" iterator [this]
        (ß new NodeIterator(tree, true))
    )

    #_method
    (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
        (when (ß tree != nil)
            (ß init = tree.kvreduce(f, init))
        )
        (when (ß RT.isReduced(init))
            (ß init = ((IDeref)init).deref())
        )
        init
    )

    #_method
    (§ defn #_"NodeIterator" reverseIterator [this]
        (ß new NodeIterator(tree, false))
    )

    #_method
    (§ defn #_"Iterator" keys [this]
        (ß keys(iterator()))
    )

    #_method
    (§ defn #_"Iterator" vals [this]
        (ß vals(iterator()))
    )

    #_method
    (§ defn #_"Iterator" keys [this, #_"NodeIterator" it]
        (ß new KeyIterator(it))
    )

    #_method
    (§ defn #_"Iterator" vals [this, #_"NodeIterator" it]
        (ß new ValIterator(it))
    )

    #_method
    (§ defn #_"Object" minKey [this]
        (let [#_"Node" t (ß min())]
            (ß (t != nil) ? t.key :or nil)
        )
    )

    #_method
    (§ defn #_"Node" min [this]
        (let [#_"Node" t tree]
            (when (ß t != nil)
                (while (ß t.left() != nil)
                    (ß t = t.left())
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"Object" maxKey [this]
        (let [#_"Node" t (ß max())]
            (ß (t != nil) ? t.key :or nil)
        )
    )

    #_method
    (§ defn #_"Node" max [this]
        (let [#_"Node" t tree]
            (when (ß t != nil)
                (while (ß t.right() != nil)
                    (ß t = t.right())
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" depth [this]
        (ß depth(tree))
    )

    #_method
    (§ defn #_"int" depth [this, #_"Node" t]
        (when (ß t == nil)
            (§ return 0)
        )
        (ß 1 + Math.max(depth(t.left()), depth(t.right())))
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (let [#_"Node" n (ß entryAt(key))]
            (ß (n != nil) ? n.val() :or notFound)
        )
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"int" capacity [this]
        (ß _count)
    )

    #_method
    (§ defn #_"int" count [this]
        (ß _count)
    )

    #_method
    (§ defn #_"Node" entryAt [this, #_"Object" key]
        (let [#_"Node" t tree]
            (while (ß t != nil)
                (let [#_"int" c (ß doCompare(key, t.key))]
                    (cond (ß c == 0)
                        (do
                            (§ return t)
                        )
                        (ß c < 0)
                        (do
                            (ß t = t.left())
                        )
                        :else
                        (do
                            (ß t = t.right())
                        )
                    )
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" doCompare [this, #_"Object" k1, #_"Object" k2]
        (ß comp.compare(k1, k2))
    )

    #_method
    (§ defn #_"Node" add [this, #_"Node" t, #_"Object" key, #_"Object" val, #_"Box" found]
        (when (ß t == nil)
            (when (ß val == nil)
                (§ return (ß new Red(key)))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (let [#_"int" c (ß doCompare(key, t.key))]
            (when (ß c == 0)
                (ß found.val = t)
                (§ return nil)
            )
            (let [#_"Node" ins (ß (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found))]
                (when (ß ins == nil) ;; found below
                    (§ return nil)
                )
                (when (ß c < 0)
                    (§ return (ß t.addLeft(ins)))
                )
                (ß t.addRight(ins))
            )
        )
    )

    #_method
    (§ defn #_"Node" remove [this, #_"Node" t, #_"Object" key, #_"Box" found]
        (when (ß t == nil)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" c (ß doCompare(key, t.key))]
            (when (ß c == 0)
                (ß found.val = t)
                (§ return (ß append(t.left(), t.right())))
            )
            (let [#_"Node" del (ß (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found))]
                (when (ß del == nil && found.val == nil) ;; not found below
                    (§ return nil)
                )
                (when (ß c < 0)
                    (if (ß t.left() instanceof Black)
                        (do
                            (§ return (ß balanceLeftDel(t.key, t.val(), del, t.right())))
                        )
                        (do
                            (§ return (ß red(t.key, t.val(), del, t.right())))
                        )
                    )
                )
                (when (ß t.right() instanceof Black)
                    (§ return (ß balanceRightDel(t.key, t.val(), t.left(), del)))
                )
                (ß red(t.key, t.val(), t.left(), del))
            )
        )
    )

    (§ defn #_"Node" append [#_"Node" left, #_"Node" right]
        (cond (ß left == nil)
            (do
                right
            )
            (ß right == nil)
            (do
                left
            )
            (ß left instanceof Red)
            (do
                (if (ß right instanceof Red)
                    (do
                        (let [#_"Node" app (ß append(left.right(), right.left()))]
                            (if (ß app instanceof Red)
                                (do
                                    (ß red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right())))
                                )
                                (do
                                    (ß red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right())))
                                )
                            )
                        )
                    )
                    (do
                        (ß red(left.key, left.val(), left.left(), append(left.right(), right)))
                    )
                )
            )
            (ß right instanceof Red)
            (do
                (ß red(right.key, right.val(), append(left, right.left()), right.right()))
            )
            :else ;; black/black
            (do
                (let [#_"Node" app (ß append(left.right(), right.left()))]
                    (if (ß app instanceof Red)
                        (do
                            (ß red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right())))
                        )
                        (do
                            (ß balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right())))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Node" balanceLeftDel [#_"Object" key, #_"Object" val, #_"Node" del, #_"Node" right]
        (cond (ß del instanceof Red)
            (do
                (ß red(key, val, del.blacken(), right))
            )
            (ß right instanceof Black)
            (do
                (ß rightBalance(key, val, del, right.redden()))
            )
            (ß right instanceof Red && right.left() instanceof Black)
            (do
                (ß red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden())))
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("Invariant violation")))
            )
        )
    )

    (§ defn #_"Node" balanceRightDel [#_"Object" key, #_"Object" val, #_"Node" left, #_"Node" del]
        (cond (ß del instanceof Red)
            (do
                (ß red(key, val, left, del.blacken()))
            )
            (ß left instanceof Black)
            (do
                (ß leftBalance(key, val, left.redden(), del))
            )
            (ß left instanceof Red && left.right() instanceof Black)
            (do
                (ß red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del)))
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("Invariant violation")))
            )
        )
    )

    (§ defn #_"Node" leftBalance [#_"Object" key, #_"Object" val, #_"Node" ins, #_"Node" right]
        (cond (ß ins instanceof Red && ins.left() instanceof Red)
            (do
                (ß red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right)))
            )
            (ß ins instanceof Red && ins.right() instanceof Red)
            (do
                (ß red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right)))
            )
            :else
            (do
                (ß black(key, val, ins, right))
            )
        )
    )

    (§ defn #_"Node" rightBalance [#_"Object" key, #_"Object" val, #_"Node" left, #_"Node" ins]
        (cond (ß ins instanceof Red && ins.right() instanceof Red)
            (do
                (ß red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken()))
            )
            (ß ins instanceof Red && ins.left() instanceof Red)
            (do
                (ß red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right())))
            )
            :else
            (do
                (ß black(key, val, left, ins))
            )
        )
    )

    #_method
    (§ defn #_"Node" replace [this, #_"Node" t, #_"Object" key, #_"Object" val]
        (let [#_"int" c (ß doCompare(key, t.key))]
            (ß t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right()))
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"Comparator" comp, #_"Node" tree, #_"int" count, #_"IPersistentMap" meta]
        (ß this._meta = meta)
        (ß this.comp = comp)
        (ß this.tree = tree)
        (ß this._count = count)
        this
    )

    (§ defn #_"Red" red [#_"Object" key, #_"Object" val, #_"Node" left, #_"Node" right]
        (when (ß left == nil && right == nil)
            (when (ß val == nil)
                (§ return (ß new Red(key)))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (when (ß val == nil)
            (§ return (ß new RedBranch(key, left, right)))
        )
        (ß new RedBranchVal(key, val, left, right))
    )

    (§ defn #_"Black" black [#_"Object" key, #_"Object" val, #_"Node" left, #_"Node" right]
        (when (ß left == nil && right == nil)
            (when (ß val == nil)
                (§ return (ß new Black(key)))
            )
            (§ return (ß new BlackVal(key, val)))
        )
        (when (ß val == nil)
            (§ return (ß new BlackBranch(key, left, right)))
        )
        (ß new BlackBranchVal(key, val, left, right))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )

    #_abstract
    (class-ns Node (§ extends AMapEntry)
        (§ field #_"Object" key)

        (§ constructor #_"Node" Node [#_"Object" key]
            (ß this.key = key)
            this
        )

        #_method
        (§ defn #_"Object" key [this]
            key
        )

        #_method
        (§ defn #_"Object" val [this]
            nil
        )

        #_method
        (§ defn #_"Object" getKey [this]
            (ß key())
        )

        #_method
        (§ defn #_"Object" getValue [this]
            (ß val())
        )

        #_method
        (§ defn #_"Node" left [this]
            nil
        )

        #_method
        (§ defn #_"Node" right [this]
            nil
        )

        (§ abstract Node addLeft(Node ins))
        (§ abstract Node addRight(Node ins))
        (§ abstract Node removeLeft(Node del))
        (§ abstract Node removeRight(Node del))
        (§ abstract Node blacken())
        (§ abstract Node redden())

        #_method
        (§ defn #_"Node" balanceLeft [this, #_"Node" parent]
            (ß black(parent.key, parent.val(), this, parent.right()))
        )

        #_method
        (§ defn #_"Node" balanceRight [this, #_"Node" parent]
            (ß black(parent.key, parent.val(), parent.left(), this))
        )

        (§ abstract Node replace(Object key, Object val, Node left, Node right))

        #_method
        (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
            (when (ß left() != nil)
                (ß init = left().kvreduce(f, init))
                (when (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            (ß init = f.invoke(init, key(), val()))
            (when (ß RT.isReduced(init))
                (§ return init)
            )

            (when (ß right() != nil)
                (ß init = right().kvreduce(f, init))
            )
            init
        )
    )

    (class-ns Black (§ extends Node)
        (§ constructor #_"Black" Black [#_"Object" key]
            (§ super(key))
            this
        )

        #_method
        (§ defn #_"Node" addLeft [this, #_"Node" ins]
            (ß ins.balanceLeft(this))
        )

        #_method
        (§ defn #_"Node" addRight [this, #_"Node" ins]
            (ß ins.balanceRight(this))
        )

        #_method
        (§ defn #_"Node" removeLeft [this, #_"Node" del]
            (ß balanceLeftDel(key, val(), del, right()))
        )

        #_method
        (§ defn #_"Node" removeRight [this, #_"Node" del]
            (ß balanceRightDel(key, val(), left(), del))
        )

        #_method
        (§ defn #_"Node" blacken [this]
            this
        )

        #_method
        (§ defn #_"Node" redden [this]
            (ß new Red(key))
        )

        #_method
        (§ defn #_"Node" replace [this, #_"Object" key, #_"Object" val, #_"Node" left, #_"Node" right]
            (ß black(key, val, left, right))
        )
    )

    (class-ns BlackVal (§ extends Black)
        (§ field #_"Object" val)

        (§ constructor #_"BlackVal" BlackVal [#_"Object" key, #_"Object" val]
            (§ super(key))
            (ß this.val = val)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            val
        )

        #_method
        (§ defn #_"Node" redden [this]
            (ß new RedVal(key, val))
        )
    )

    (class-ns BlackBranch (§ extends Black)
        (§ field #_"Node" left)

        (§ field #_"Node" right)

        (§ constructor #_"BlackBranch" BlackBranch [#_"Object" key, #_"Node" left, #_"Node" right]
            (§ super(key))
            (ß this.left = left)
            (ß this.right = right)
            this
        )

        #_method
        (§ defn #_"Node" left [this]
            left
        )

        #_method
        (§ defn #_"Node" right [this]
            right
        )

        #_method
        (§ defn #_"Node" redden [this]
            (ß new RedBranch(key, left, right))
        )
    )

    (class-ns BlackBranchVal (§ extends BlackBranch)
        (§ field #_"Object" val)

        (§ constructor #_"BlackBranchVal" BlackBranchVal [#_"Object" key, #_"Object" val, #_"Node" left, #_"Node" right]
            (§ super(key, left, right))
            (ß this.val = val)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            val
        )

        #_method
        (§ defn #_"Node" redden [this]
            (ß new RedBranchVal(key, val, left, right))
        )
    )

    (class-ns Red (§ extends Node)
        (§ constructor #_"Red" Red [#_"Object" key]
            (§ super(key))
            this
        )

        #_method
        (§ defn #_"Node" addLeft [this, #_"Node" ins]
            (ß red(key, val(), ins, right()))
        )

        #_method
        (§ defn #_"Node" addRight [this, #_"Node" ins]
            (ß red(key, val(), left(), ins))
        )

        #_method
        (§ defn #_"Node" removeLeft [this, #_"Node" del]
            (ß red(key, val(), del, right()))
        )

        #_method
        (§ defn #_"Node" removeRight [this, #_"Node" del]
            (ß red(key, val(), left(), del))
        )

        #_method
        (§ defn #_"Node" blacken [this]
            (ß new Black(key))
        )

        #_method
        (§ defn #_"Node" redden [this]
            (throw (ß new UnsupportedOperationException("Invariant violation")))
        )

        #_method
        (§ defn #_"Node" replace [this, #_"Object" key, #_"Object" val, #_"Node" left, #_"Node" right]
            (ß red(key, val, left, right))
        )
    )

    (class-ns RedVal (§ extends Red)
        (§ field #_"Object" val)

        (§ constructor #_"RedVal" RedVal [#_"Object" key, #_"Object" val]
            (§ super(key))
            (ß this.val = val)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            val
        )

        #_method
        (§ defn #_"Node" blacken [this]
            (ß new BlackVal(key, val))
        )
    )

    (class-ns RedBranch (§ extends Red)
        (§ field #_"Node" left)

        (§ field #_"Node" right)

        (§ constructor #_"RedBranch" RedBranch [#_"Object" key, #_"Node" left, #_"Node" right]
            (§ super(key))
            (ß this.left = left)
            (ß this.right = right)
            this
        )

        #_method
        (§ defn #_"Node" left [this]
            left
        )

        #_method
        (§ defn #_"Node" right [this]
            right
        )

        #_method
        (§ defn #_"Node" balanceLeft [this, #_"Node" parent]
            (cond (ß left instanceof Red)
                (do
                    (ß red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right())))
                )
                (ß right instanceof Red)
                (do
                    (ß red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right())))
                )
                :else
                (do
                    (ß super.balanceLeft(parent))
                )
            )
        )

        #_method
        (§ defn #_"Node" balanceRight [this, #_"Node" parent]
            (cond (ß right instanceof Red)
                (do
                    (ß red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken()))
                )
                (ß left instanceof Red)
                (do
                    (ß red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right)))
                )
                :else
                (do
                    (ß super.balanceRight(parent))
                )
            )
        )

        #_method
        (§ defn #_"Node" blacken [this]
            (ß new BlackBranch(key, left, right))
        )
    )

    (class-ns RedBranchVal (§ extends RedBranch)
        (§ field #_"Object" val)

        (§ constructor #_"RedBranchVal" RedBranchVal [#_"Object" key, #_"Object" val, #_"Node" left, #_"Node" right]
            (§ super(key, left, right))
            (ß this.val = val)
            this
        )

        #_method
        (§ defn #_"Object" val [this]
            val
        )

        #_method
        (§ defn #_"Node" blacken [this]
            (ß new BlackBranchVal(key, val, left, right))
        )
    )

    (class-ns Seq (§ extends ASeq)
        (§ field #_"ISeq" stack)
        (§ field #_"boolean" asc)
        (§ field #_"int" cnt)

        (§ constructor #_"Seq" Seq [#_"ISeq" stack, #_"boolean" asc]
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = -1)
            this
        )

        (§ constructor #_"Seq" Seq [#_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = cnt)
            this
        )

        (§ constructor #_"Seq" Seq [#_"IPersistentMap" meta, #_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
            (§ super(meta))
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = cnt)
            this
        )

        (§ defn #_"Seq" create [#_"Node" t, #_"boolean" asc, #_"int" cnt]
            (ß new Seq(push(t, nil, asc), asc, cnt))
        )

        (§ defn #_"ISeq" push [#_"Node" t, #_"ISeq" stack, #_"boolean" asc]
            (while (ß t != nil)
                (ß stack = RT.cons(t, stack))
                (ß t = asc ? t.left() :or t.right())
            )
            stack
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß stack.first())
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (let [#_"Node" t (ß (Node) stack.first())]
                (let [#_"ISeq" nextstack (ß push(asc ? t.right() :or t.left(), stack.next(), asc))]
                    (when (ß nextstack != nil)
                        (§ return (ß new Seq(nextstack, asc, cnt - 1)))
                    )
                    nil
                )
            )
        )

        #_method
        (§ defn #_"int" count [this]
            (when (ß cnt < 0)
                (§ return (ß super.count()))
            )
            cnt
        )

        #_method
        (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
            (ß new Seq(meta, stack, asc, cnt))
        )
    )

    (class-ns NodeIterator (§ implements Iterator)
        (§ field #_"Stack" stack (ß new Stack()))
        (§ field #_"boolean" asc)

        (§ constructor #_"NodeIterator" NodeIterator [#_"Node" t, #_"boolean" asc]
            (ß this.asc = asc)
            (ß push(t))
            this
        )

        #_method
        (§ defn #_"void" push [this, #_"Node" t]
            (while (ß t != nil)
                (ß stack.push(t))
                (ß t = asc ? t.left() :or t.right())
            )
            nil
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß !stack.isEmpty())
        )

        #_method
        (§ defn #_"Object" next [this]
            (try
                (let [#_"Node" t (ß (Node) stack.pop())]
                    (ß push(asc ? t.right() :or t.left()))
                    t
                )
                (catch EmptyStackException e
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (class-ns KeyIterator (§ implements Iterator)
        (§ field #_"NodeIterator" it)

        (§ constructor #_"KeyIterator" KeyIterator [#_"NodeIterator" it]
            (ß this.it = it)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß it.hasNext())
        )

        #_method
        (§ defn #_"Object" next [this]
            (ß ((Node) it.next()).key)
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (class-ns ValIterator (§ implements Iterator)
        (§ field #_"NodeIterator" it)

        (§ constructor #_"ValIterator" ValIterator [#_"NodeIterator" it]
            (ß this.it = it)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß it.hasNext())
        )

        #_method
        (§ defn #_"Object" next [this]
            (ß ((Node) it.next()).val())
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" EMPTY (ß new PersistentTreeSet(nil, PersistentTreeMap.EMPTY)))

    (§ field #_"IPersistentMap" _meta)

    (§ defn #_"PersistentTreeSet" create [#_"ISeq" items]
        (let [#_"PersistentTreeSet" ret (ß EMPTY)]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = (PersistentTreeSet) ret.cons(items.first()))
            )
            ret
        )
    )

    (§ defn #_"PersistentTreeSet" create [#_"Comparator" comp, #_"ISeq" items]
        (let [#_"PersistentTreeSet" ret (ß new PersistentTreeSet(nil, new PersistentTreeMap(nil, comp)))]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = (PersistentTreeSet) ret.cons(items.first()))
            )
            ret
        )
    )

    (§ constructor #_"PersistentTreeSet" PersistentTreeSet [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (§ super(impl))
        (ß this._meta = meta)
        this
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" obj]
        (try
            (ß super.equals(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [this, #_"Object" obj]
        (try
            (ß super.equiv(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [this, #_"Object" key]
        (when (ß contains(key))
            (§ return (ß new PersistentTreeSet(meta(), impl.without(key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [this, #_"Object" o]
        (when (ß contains(o))
            (§ return this)
        )
        (ß new PersistentTreeSet(meta(), impl.assoc(o, o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty()))
    )

    #_method
    (§ defn #_"ISeq" rseq [this]
        (ß APersistentMap.KeySeq.create(((Reversible) impl).rseq()))
    )

    #_method
    (§ defn #_"PersistentTreeSet" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentTreeSet(meta, impl))
    )

    #_method
    (§ defn #_"Comparator" comparator [this]
        (ß ((Sorted)impl).comparator())
    )

    #_method
    (§ defn #_"Object" entryKey [this, #_"Object" entry]
        entry
    )

    #_method
    (§ defn #_"ISeq" seq [this, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (ß (PersistentTreeMap) impl)]
            (ß RT.keys(m.seq(ascending)))
        )
    )

    #_method
    (§ defn #_"ISeq" seqFrom [this, #_"Object" key, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (ß (PersistentTreeMap) impl)]
            (ß RT.keys(m.seqFrom(key, ascending)))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (class-ns Node
        #_transient
        (§ field #_"AtomicReference<Thread>" edit)
        (§ field #_"Object[]" array)

        (§ constructor #_"Node" Node [#_"AtomicReference<Thread>" edit, #_"Object[]" array]
            (ß this.edit = edit)
            (ß this.array = array)
            this
        )

        (§ constructor #_"Node" Node [#_"AtomicReference<Thread>" edit]
            (ß this.edit = edit)
            (ß this.array = new Object[32])
            this
        )
    )

    (§ def #_"AtomicReference<Thread>" NOEDIT (ß new AtomicReference<Thread>(nil)))
    (§ def #_"Node" EMPTY_NODE (ß new Node(NOEDIT, new Object[32])))

    (§ field #_"int" cnt)
    (§ field #_"int" shift)
    (§ field #_"Node" root)
    (§ field #_"Object[]" tail)
    (§ field #_"IPersistentMap" _meta)

    (§ def #_"PersistentVector" EMPTY (ß new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§))))

    (§ def- #_"IFn" TRANSIENT_VECTOR_CONJ (ß new AFn()
        (§ reify
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" coll, #_"Object" val]
                (ß ((ITransientVector)coll).conj(val))
            )
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" coll]
                coll
            )
        )
    ))

    (§ defn #_"PersistentVector" adopt [#_"Object[]" items]
        (ß new PersistentVector(items.length, 5, EMPTY_NODE, items))
    )

    (§ defn #_"PersistentVector" create [#_"IReduceInit" items]
        (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
            (ß items.reduce(TRANSIENT_VECTOR_CONJ, ret))
            (ß ret.persistent())
        )
    )

    (§ defn #_"PersistentVector" create [#_"ISeq" items]
        (let [#_"Object[]" arr (ß new Object[32])]
            (let [#_"int" i 0]
                (loop-when-recur [(ß )] (ß items != nil && i < 32) [(ß items = items.next())]
                    (ß arr[i++] = items.first())
                )

                (cond (ß items != nil) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" start (ß new PersistentVector(32, 5, EMPTY_NODE, arr))]
                            (let [#_"TransientVector" ret (ß start.asTransient())]
                                (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                                    (ß ret = ret.conj(items.first()))
                                )
                                (ß ret.persistent())
                            )
                        )
                    )
                    (ß i == 32) ;; exactly 32, skip copy
                    (do
                        (ß new PersistentVector(32, 5, EMPTY_NODE, arr))
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" arr2 (ß new Object[i])]
                            (ß System.arraycopy(arr, 0, arr2, 0, i))
                            (ß new PersistentVector(i, 5, EMPTY_NODE, arr2))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"PersistentVector" create [#_"List" list]
        (let [#_"int" size (ß list.size())]
            (when (ß size <= 32)
                (§ return (ß new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())))
            )

            (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
                (loop-when-recur [(ß int i = 0)] (ß i < size) [(ß i++)]
                    (ß ret = ret.conj(list.get(i)))
                )
                (ß ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentVector" create [#_"Iterable" items]
        ;; optimize common case
        (when (ß items instanceof ArrayList)
            (§ return (ß create((ArrayList)items)))
        )

        (let [#_"Iterator" iter (ß items.iterator())]
            (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
                (while (ß iter.hasNext())
                    (ß ret = ret.conj(iter.next()))
                )
                (ß ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentVector" create [#_"Object..." items]
        (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" item items]
                (ß ret = ret.conj(item))
            )
            (ß ret.persistent())
        )
    )

    (§ constructor #_"PersistentVector" PersistentVector [#_"int" cnt, #_"int" shift, #_"Node" root, #_"Object[]" tail]
        (ß this._meta = nil)
        (ß this.cnt = cnt)
        (ß this.shift = shift)
        (ß this.root = root)
        (ß this.tail = tail)
        this
    )

    (§ constructor #_"PersistentVector" PersistentVector [#_"IPersistentMap" meta, #_"int" cnt, #_"int" shift, #_"Node" root, #_"Object[]" tail]
        (ß this._meta = meta)
        (ß this.cnt = cnt)
        (ß this.shift = shift)
        (ß this.root = root)
        (ß this.tail = tail)
        this
    )

    #_method
    (§ defn #_"TransientVector" asTransient [this]
        (ß new TransientVector(this))
    )

    #_method
    (§ defn #_"int" tailoff [this]
        (when (ß cnt < 32)
            (§ return 0)
        )
        (ß ((cnt - 1) >>> 5) << 5)
    )

    #_method
    (§ defn #_"Object[]" arrayFor [this, #_"int" i]
        (when (ß i >= 0 && i < cnt)
            (when (ß i >= tailoff())
                (§ return tail)
            )
            (let [#_"Node" node root]
                (loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                    (ß node = (Node) node.array[(i >>> level) & 0x01f])
                )
                (§ return (ß node.array))
            )
        )
        (throw (ß new IndexOutOfBoundsException()))
    )

    #_method
    (§ defn #_"Object" nth [this, #_"int" i]
        (let [#_"Object[]" node (ß arrayFor(i))]
            (ß node[i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" nth [this, #_"int" i, #_"Object" notFound]
        (when (ß i >= 0 && i < cnt)
            (§ return (ß nth(i)))
        )
        notFound
    )

    #_method
    (§ defn #_"PersistentVector" assocN [this, #_"int" i, #_"Object" val]
        (when (ß i >= 0 && i < cnt)
            (when (ß i >= tailoff())
                (let [#_"Object[]" newTail (ß new Object[tail.length])]
                    (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                    (ß newTail[i & 0x01f] = val)

                    (§ return (ß new PersistentVector(meta(), cnt, shift, root, newTail)))
                )
            )

            (§ return (ß new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)))
        )
        (when (ß i == cnt)
            (§ return (ß cons(val)))
        )
        (throw (ß new IndexOutOfBoundsException()))
    )

    (§ defn- #_"Node" doAssoc [#_"int" level, #_"Node" node, #_"int" i, #_"Object" val]
        (let [#_"Node" ret (ß new Node(node.edit, node.array.clone()))]
            (if (ß level == 0)
                (do
                    (ß ret.array[i & 0x01f] = val)
                )
                (do
                    (let [#_"int" subidx (ß (i >>> level) & 0x01f)]
                        (ß ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
                    )
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" count [this]
        cnt
    )

    #_method
    (§ defn #_"PersistentVector" withMeta [this, #_"IPersistentMap" meta]
        (ß new PersistentVector(meta, cnt, shift, root, tail))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )

    #_method
    (§ defn #_"PersistentVector" cons [this, #_"Object" val]
        ;; room in tail?
        (when (ß cnt - tailoff() < 32)
            (let [#_"Object[]" newTail (ß new Object[tail.length + 1])]
                (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                (ß newTail[tail.length] = val)
                (§ return (ß new PersistentVector(meta(), cnt + 1, shift, root, newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"Node" newroot]
            (let [#_"Node" tailnode (ß new Node(root.edit, tail))]
                (let [#_"int" newshift shift]
                    ;; overflow root?
                    (if (ß (cnt >>> 5) > (1 << shift))
                        (do
                            (ß newroot = new Node(root.edit))
                            (ß newroot.array[0] = root)
                            (ß newroot.array[1] = newPath(root.edit, shift, tailnode))
                            (ß newshift += 5)
                        )
                        (do
                            (ß newroot = pushTail(shift, root, tailnode))
                        )
                    )
                    (ß new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ val )))
                )
            )
        )
    )

    #_method
    (§ defn- #_"Node" pushTail [this, #_"int" level, #_"Node" parent, #_"Node" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" subidx (ß ((cnt - 1) >>> level) & 0x01f)]
            (let [#_"Node" ret (ß new Node(parent.edit, parent.array.clone()))]
                (§ let [#_"Node" nodeToInsert]
                    (if (ß level == 5)
                        (do
                            (ß nodeToInsert = tailnode)
                        )
                        (do
                            (let [#_"Node" child (ß (Node) parent.array[subidx])]
                                (ß nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
                            )
                        )
                    )
                    (ß ret.array[subidx] = nodeToInsert)
                    ret
                )
            )
        )
    )

    (§ defn- #_"Node" newPath [#_"AtomicReference<Thread>" edit, #_"int" level, #_"Node" node]
        (when (ß level == 0)
            (§ return node)
        )
        (let [#_"Node" ret (ß new Node(edit))]
            (ß ret.array[0] = newPath(edit, level - 5, node))
            ret
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" chunkedSeq [this]
        (when (ß count() == 0)
            (§ return nil)
        )
        (ß new ChunkedSeq(this, 0, 0))
    )

    #_method
    (§ defn #_"ISeq" seq [this]
        (ß chunkedSeq())
    )

    (§ anno @Override)
    #_method
    (§ defn #_"Iterator" rangedIterator [this, #_"int" start, #_"int" end]
        (ß new Iterator()
            (§ reify
                (let [#_"int" i start]
                    (let [#_"int" base (ß i - (i%32))]
                        (let [#_"Object[]" array (ß (start < count()) ? arrayFor(i) :or nil)]
                            #_method
                            (§ defn #_"boolean" hasNext [this]
                                (ß (i < end))
                            )

                            #_method
                            (§ defn #_"Object" next [this]
                                (if (ß i < end)
                                    (do
                                        (when (ß i - base == 32)
                                            (ß array = arrayFor(i))
                                            (ß base += 32)
                                        )
                                        (ß array[i++ & 0x01f])
                                    )
                                    (do
                                        (throw (ß new NoSuchElementException()))
                                    )
                                )
                            )

                            #_method
                            (§ defn #_"void" remove [this]
                                (throw (ß new UnsupportedOperationException()))
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß rangedIterator(0, count()))
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (§ let [#_"Object" init]
            (if (ß cnt > 0)
                (do
                    (ß init = arrayFor(0)[0])
                )
                (do
                    (§ return (ß f.invoke()))
                )
            )
            (let [#_"int" step 0]
                (loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
                    (let [#_"Object[]" array (ß arrayFor(i))]
                        (loop-when-recur [(ß int j = (i == 0) ? 1 :or 0)] (ß j < array.length) [(ß ++j)]
                            (ß init = f.invoke(init, array[j]))
                            (when (ß RT.isReduced(init))
                                (§ return (ß ((IDeref)init).deref()))
                            )
                        )
                        (ß step = array.length)
                    )
                )
                init
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" init]
        (let [#_"int" step 0]
            (loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
                (let [#_"Object[]" array (ß arrayFor(i))]
                    (loop-when-recur [(ß int j = 0)] (ß j < array.length) [(ß ++j)]
                        (ß init = f.invoke(init, array[j]))
                        (when (ß RT.isReduced(init))
                            (§ return (ß ((IDeref)init).deref()))
                        )
                    )
                    (ß step = array.length)
                )
            )
            init
        )
    )

    #_method
    (§ defn #_"Object" kvreduce [this, #_"IFn" f, #_"Object" init]
        (let [#_"int" step 0]
            (loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
                (let [#_"Object[]" array (ß arrayFor(i))]
                    (loop-when-recur [(ß int j = 0)] (ß j < array.length) [(ß ++j)]
                        (ß init = f.invoke(init, j + i, array[j]))
                        (when (ß RT.isReduced(init))
                            (§ return (ß ((IDeref)init).deref()))
                        )
                    )
                    (ß step = array.length)
                )
            )
            init
        )
    )

    (class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
        (§ field #_"PersistentVector" vec)
        (§ field #_"Object[]" node)
        (§ field #_"int" i)
        (§ field #_"int" offset)

        (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"PersistentVector" vec, #_"int" i, #_"int" offset]
            (ß this.vec = vec)
            (ß this.i = i)
            (ß this.offset = offset)
            (ß this.node = vec.arrayFor(i))
            this
        )

        (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"IPersistentMap" meta, #_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
            (§ super(meta))
            (ß this.vec = vec)
            (ß this.node = node)
            (ß this.i = i)
            (ß this.offset = offset)
            this
        )

        (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
            (ß this.vec = vec)
            (ß this.node = node)
            (ß this.i = i)
            (ß this.offset = offset)
            this
        )

        #_method
        (§ defn #_"IChunk" chunkedFirst [this]
            (ß new ArrayChunk(node, offset))
        )

        #_method
        (§ defn #_"ISeq" chunkedNext [this]
            (when (ß i + node.length < vec.cnt)
                (§ return (ß new ChunkedSeq(vec, i + node.length, 0)))
            )
            nil
        )

        #_method
        (§ defn #_"ISeq" chunkedMore [this]
            (let [#_"ISeq" s (ß chunkedNext())]
                (when (ß s == nil)
                    (§ return (ß PersistentList.EMPTY))
                )
                s
            )
        )

        #_method
        (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
            (when (ß meta == this._meta)
                (§ return this)
            )
            (ß new ChunkedSeq(meta, vec, node, i, offset))
        )

        #_method
        (§ defn #_"Object" first [this]
            (ß node[offset])
        )

        #_method
        (§ defn #_"ISeq" next [this]
            (when (ß offset + 1 < node.length)
                (§ return (ß new ChunkedSeq(vec, node, i, offset + 1)))
            )
            (ß chunkedNext())
        )

        #_method
        (§ defn #_"int" count [this]
            (ß vec.cnt - (i + offset))
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentVector" pop [this]
        (when (ß cnt == 0)
            (throw (ß new IllegalStateException("Can't pop empty vector")))
        )
        (when (ß cnt == 1)
            (§ return (ß EMPTY.withMeta(meta())))
        )
        (when (ß cnt - tailoff() > 1)
            (let [#_"Object[]" newTail (ß new Object[tail.length - 1])]
                (ß System.arraycopy(tail, 0, newTail, 0, newTail.length))
                (§ return (ß new PersistentVector(meta(), cnt - 1, shift, root, newTail)))
            )
        )
        (let [#_"Object[]" newtail (ß arrayFor(cnt - 2))]
            (let [#_"Node" newroot (ß popTail(shift, root))]
                (let [#_"int" newshift shift]
                    (when (ß newroot == nil)
                        (ß newroot = EMPTY_NODE)
                    )
                    (when (ß shift > 5 && newroot.array[1] == nil)
                        (ß newroot = (Node) newroot.array[0])
                        (ß newshift -= 5)
                    )
                    (ß new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail))
                )
            )
        )
    )

    #_method
    (§ defn- #_"Node" popTail [this, #_"int" level, #_"Node" node]
        (let [#_"int" subidx (ß ((cnt - 2) >>> level) & 0x01f)]
            (cond (ß level > 5)
                (do
                    (let [#_"Node" newchild (ß popTail(level - 5, (Node) node.array[subidx]))]
                        (if (ß newchild == nil && subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"Node" ret (ß new Node(root.edit, node.array.clone()))]
                                    (ß ret.array[subidx] = newchild)
                                    ret
                                )
                            )
                        )
                    )
                )
                (ß subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"Node" ret (ß new Node(root.edit, node.array.clone()))]
                        (ß ret.array[subidx] = nil)
                        ret
                    )
                )
            )
        )
    )

    (class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
        #_volatile
        (§ field #_"int" cnt)
        #_volatile
        (§ field #_"int" shift)
        #_volatile
        (§ field #_"Node" root)
        #_volatile
        (§ field #_"Object[]" tail)

        (§ constructor #_"TransientVector" TransientVector [#_"int" cnt, #_"int" shift, #_"Node" root, #_"Object[]" tail]
            (ß this.cnt = cnt)
            (ß this.shift = shift)
            (ß this.root = root)
            (ß this.tail = tail)
            this
        )

        (§ constructor #_"TransientVector" TransientVector [#_"PersistentVector" v]
            (§ this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail)))
            this
        )

        #_method
        (§ defn #_"int" count [this]
            (ß ensureEditable())
            cnt
        )

        #_method
        (§ defn #_"Node" ensureEditable [this, #_"Node" node]
            (when (ß node.edit == root.edit)
                (§ return node)
            )
            (ß new Node(root.edit, node.array.clone()))
        )

        #_method
        (§ defn #_"void" ensureEditable [this]
            (when (ß root.edit.get() == nil)
                (throw (ß new IllegalAccessError("Transient used after persistent! call")))
            )
            nil
        )

        (§ defn #_"Node" editableRoot [#_"Node" node]
            (ß new Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone()))
        )

        #_method
        (§ defn #_"PersistentVector" persistent [this]
            (ß ensureEditable())
            (ß root.edit.set(nil))
            (let [#_"Object[]" trimmedTail (ß new Object[cnt - tailoff()])]
                (ß System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length))
                (ß new PersistentVector(cnt, shift, root, trimmedTail))
            )
        )

        (§ defn #_"Object[]" editableTail [#_"Object[]" tl]
            (let [#_"Object[]" ret (ß new Object[32])]
                (ß System.arraycopy(tl, 0, ret, 0, tl.length))
                ret
            )
        )

        #_method
        (§ defn #_"TransientVector" conj [this, #_"Object" val]
            (ß ensureEditable())
            (let [#_"int" i cnt]
                ;; room in tail?
                (when (ß i - tailoff() < 32)
                    (ß tail[i & 0x01f] = val)
                    (ß ++cnt)
                    (§ return this)
                )
                ;; full tail, push into tree
                (§ let [#_"Node" newroot]
                    (let [#_"Node" tailnode (ß new Node(root.edit, tail))]
                        (ß tail = new Object[32])
                        (ß tail[0] = val)
                        (let [#_"int" newshift shift]
                            ;; overflow root?
                            (if (ß (cnt >>> 5) > (1 << shift))
                                (do
                                    (ß newroot = new Node(root.edit))
                                    (ß newroot.array[0] = root)
                                    (ß newroot.array[1] = newPath(root.edit, shift, tailnode))
                                    (ß newshift += 5)
                                )
                                (do
                                    (ß newroot = pushTail(shift, root, tailnode))
                                )
                            )
                            (ß root = newroot)
                            (ß shift = newshift)
                            (ß ++cnt)
                            this
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"Node" pushTail [this, #_"int" level, #_"Node" parent, #_"Node" tailnode]
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            (ß parent = ensureEditable(parent))
            (let [#_"int" subidx (ß ((cnt - 1) >>> level) & 0x01f)]
                (let [#_"Node" ret parent]
                    (§ let [#_"Node" nodeToInsert]
                        (if (ß level == 5)
                            (do
                                (ß nodeToInsert = tailnode)
                            )
                            (do
                                (let [#_"Node" child (ß (Node) parent.array[subidx])]
                                    (ß nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
                                )
                            )
                        )
                        (ß ret.array[subidx] = nodeToInsert)
                        ret
                    )
                )
            )
        )

        #_method
        (§ defn- #_"int" tailoff [this]
            (when (ß cnt < 32)
                (§ return 0)
            )
            (ß ((cnt - 1) >>> 5) << 5)
        )

        #_method
        (§ defn- #_"Object[]" arrayFor [this, #_"int" i]
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ return tail)
                )
                (let [#_"Node" node root]
                    (loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                        (ß node = (Node) node.array[(i >>> level) & 0x01f])
                    )
                    (§ return (ß node.array))
                )
            )
            (throw (ß new IndexOutOfBoundsException()))
        )

        #_method
        (§ defn- #_"Object[]" editableArrayFor [this, #_"int" i]
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ return tail)
                )
                (let [#_"Node" node root]
                    (loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                        (ß node = ensureEditable((Node) node.array[(i >>> level) & 0x01f]))
                    )
                    (§ return (ß node.array))
                )
            )
            (throw (ß new IndexOutOfBoundsException()))
        )

        #_method
        (§ defn #_"Object" valAt [this, #_"Object" key]
            ;; note - relies on ensureEditable in 2-arg valAt
            (ß valAt(key, nil))
        )

        #_method
        (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
            (ß ensureEditable())
            (when (ß Util.isInteger(key))
                (let [#_"int" i (ß ((Number) key).intValue())]
                    (when (ß i >= 0 && i < cnt)
                        (§ return (ß nth(i)))
                    )
                )
            )
            notFound
        )

        (§ def- #_"Object" NOT_FOUND (ß new Object()))

        #_method
        (§ defn #_"boolean" containsKey [this, #_"Object" key]
            (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
        )

        #_method
        (§ defn #_"IMapEntry" entryAt [this, #_"Object" key]
            (let [#_"Object" v (ß valAt(key, NOT_FOUND))]
                (when (ß v != NOT_FOUND)
                    (§ return (ß MapEntry.create(key, v)))
                )
                nil
            )
        )

        #_method
        (§ defn #_"Object" invoke [this, #_"Object" arg1]
            ;; note - relies on ensureEditable in nth
            (when (ß Util.isInteger(arg1))
                (§ return (ß nth(((Number) arg1).intValue())))
            )
            (throw (ß new IllegalArgumentException("Key must be integer")))
        )

        #_method
        (§ defn #_"Object" nth [this, #_"int" i]
            (ß ensureEditable())
            (let [#_"Object[]" node (ß arrayFor(i))]
                (ß node[i & 0x01f])
            )
        )

        #_method
        (§ defn #_"Object" nth [this, #_"int" i, #_"Object" notFound]
            (when (ß i >= 0 && i < count())
                (§ return (ß nth(i)))
            )
            notFound
        )

        #_method
        (§ defn #_"TransientVector" assocN [this, #_"int" i, #_"Object" val]
            (ß ensureEditable())
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (ß tail[i & 0x01f] = val)
                    (§ return this)
                )

                (ß root = doAssoc(shift, root, i, val))
                (§ return this)
            )
            (when (ß i == cnt)
                (§ return (ß conj(val)))
            )
            (throw (ß new IndexOutOfBoundsException()))
        )

        #_method
        (§ defn #_"TransientVector" assoc [this, #_"Object" key, #_"Object" val]
            ;; note - relies on ensureEditable in assocN
            (when (ß Util.isInteger(key))
                (let [#_"int" i (ß ((Number) key).intValue())]
                    (§ return (ß assocN(i, val)))
                )
            )
            (throw (ß new IllegalArgumentException("Key must be integer")))
        )

        #_method
        (§ defn- #_"Node" doAssoc [this, #_"int" level, #_"Node" node, #_"int" i, #_"Object" val]
            (ß node = ensureEditable(node))
            (let [#_"Node" ret node]
                (if (ß level == 0)
                    (do
                        (ß ret.array[i & 0x01f] = val)
                    )
                    (do
                        (let [#_"int" subidx (ß (i >>> level) & 0x01f)]
                            (ß ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
                        )
                    )
                )
                ret
            )
        )

        #_method
        (§ defn #_"TransientVector" pop [this]
            (ß ensureEditable())
            (when (ß cnt == 0)
                (throw (ß new IllegalStateException("Can't pop empty vector")))
            )
            (when (ß cnt == 1)
                (ß cnt = 0)
                (§ return this)
            )
            (let [#_"int" i (ß cnt - 1)]
                ;; pop in tail?
                (when (ß (i & 0x01f) > 0)
                    (ß --cnt)
                    (§ return this)
                )

                (let [#_"Object[]" newtail (ß editableArrayFor(cnt - 2))]
                    (let [#_"Node" newroot (ß popTail(shift, root))]
                        (let [#_"int" newshift shift]
                            (when (ß newroot == nil)
                                (ß newroot = new Node(root.edit))
                            )
                            (when (ß shift > 5 && newroot.array[1] == nil)
                                (ß newroot = ensureEditable((Node) newroot.array[0]))
                                (ß newshift -= 5)
                            )
                            (ß root = newroot)
                            (ß shift = newshift)
                            (ß --cnt)
                            (ß tail = newtail)
                            this
                        )
                    )
                )
            )
        )

        #_method
        (§ defn- #_"Node" popTail [this, #_"int" level, #_"Node" node]
            (ß node = ensureEditable(node))
            (let [#_"int" subidx (ß ((cnt - 2) >>> level) & 0x01f)]
                (cond (ß level > 5)
                    (do
                        (let [#_"Node" newchild (ß popTail(level - 5, (Node) node.array[subidx]))]
                            (if (ß newchild == nil && subidx == 0)
                                (do
                                    nil
                                )
                                (do
                                    (let [#_"Node" ret node]
                                        (ß ret.array[subidx] = newchild)
                                        ret
                                    )
                                )
                            )
                        )
                    )
                    (ß subidx == 0)
                    (do
                        nil
                    )
                    :else
                    (do
                        (let [#_"Node" ret node]
                            (ß ret.array[subidx] = nil)
                            ret
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    ;; method-name-string->fn
    (§ field #_"IPersistentMap" fns)

    (§ constructor #_"ProxyHandler" ProxyHandler [#_"IPersistentMap" fns]
        (ß this.fns = fns)
        this
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" proxy, #_"Method" method, #_"Object[]" args] (§ throws Throwable)
        (let [#_"Class" rt (ß method.getReturnType())]
            (let [#_"IFn" fn (ß (IFn) fns.valAt(method.getName()))]
                (when (ß fn == nil)
                    (cond (ß rt == Void.TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß method.getName().equals("equals"))
                        (do
                            (§ return (ß (proxy == args[0])))
                        )
                        (ß method.getName().equals("hashCode"))
                        (do
                            (§ return (ß System.identityHashCode(proxy)))
                        )
                        (ß method.getName().equals("toString"))
                        (do
                            (§ return (ß "Proxy: " + System.identityHashCode(proxy)))
                        )
                    )
                    (throw (ß new UnsupportedOperationException()))
                )
                (let [#_"Object" ret (ß fn.applyTo(ArraySeq.create(args)))]
                    (cond (ß rt == Void.TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß rt.isPrimitive())
                        (do
                            (cond (ß rt == Character.TYPE)
                                (do
                                    (§ return ret)
                                )
                                (ß rt == Integer.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).intValue()))
                                )
                                (ß rt == Long.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).longValue()))
                                )
                                (ß rt == Float.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).floatValue()))
                                )
                                (ß rt == Double.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).doubleValue()))
                                )
                                (ß rt == Boolean.TYPE && !(ret instanceof Boolean))
                                (do
                                    (§ return (ß (ret == nil) ? Boolean.FALSE :or Boolean.TRUE))
                                )
                                (ß rt == Byte.TYPE)
                                (do
                                    (§ return (ß (byte) ((Number) ret).intValue()))
                                )
                                (ß rt == Short.TYPE)
                                (do
                                    (§ return (ß (short) ((Number) ret).intValue()))
                                )
                            )
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (§ def- #_"int" CHUNK_SIZE (ß 32))

    ;; Invariants guarantee this is never an "empty" seq
    (§ field #_"Object" end)
    (§ field #_"Object" start)
    (§ field #_"Object" step)
    (§ field #_"BoundsCheck" boundsCheck)

    #_volatile
    (§ field- #_"IChunk" _chunk) ;; lazy
    #_volatile
    (§ field- #_"ISeq" _chunkNext) ;; lazy
    #_volatile
    (§ field- #_"ISeq" _next) ;; cached

    #_private
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(Object val))
    )

    (§ defn- #_"BoundsCheck" positiveStep [#_"Object" end]
        (ß new BoundsCheck()
            (§ reify
                #_method
                (§ defn #_"boolean" exceededBounds [this, #_"Object" val]
                    (ß Numbers.gte(val, end))
                )
            )
        )
    )

    (§ defn- #_"BoundsCheck" negativeStep [#_"Object" end]
        (ß new BoundsCheck()
            (§ reify
                #_method
                (§ defn #_"boolean" exceededBounds [this, #_"Object" val]
                    (ß Numbers.lte(val, end))
                )
            )
        )
    )

    (§ constructor- #_"Range" Range [#_"Object" start, #_"Object" end, #_"Object" step, #_"BoundsCheck" boundsCheck]
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        this
    )

    (§ constructor- #_"Range" Range [#_"Object" start, #_"Object" end, #_"Object" step, #_"BoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ constructor- #_"Range" Range [#_"IPersistentMap" meta, #_"Object" start, #_"Object" end, #_"Object" step, #_"BoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (§ super(meta))
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ defn #_"ISeq" create [#_"Object" end]
        (when (ß Numbers.isPos(end))
            (§ return (ß new Range(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn #_"ISeq" create [#_"Object" start, #_"Object" end]
        (ß create(start, end, 1))
    )

    (§ defn #_"ISeq" create [#_"Object" start, #_"Object" end, #_"Object" step]
        (when (ß (Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end))
            (§ return (ß PersistentList.EMPTY))
        )
        (when (ß Numbers.isZero(step))
            (§ return (ß Repeat.create(start)))
        )
        (ß new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end)))
    )

    #_method
    (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
        (when (ß meta == _meta)
            (§ return this)
        )
        (ß new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext))
    )

    #_method
    (§ defn #_"Object" first [this]
        start
    )

    #_method
    (§ defn #_"void" forceChunk [this]
        (when (ß _chunk != nil)
            (§ return nil)
        )

        (let [#_"Object[]" arr (ß new Object[CHUNK_SIZE])]
            (let [#_"int" n 0]
                (let [#_"Object" val start]
                    (while (ß n < CHUNK_SIZE)
                        (ß arr[n++] = val)
                        (ß val = Numbers.addP(val, step))
                        (when (ß boundsCheck.exceededBounds(val))
                            ;; partial last chunk
                            (ß _chunk = new ArrayChunk(arr, 0, n))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (ß boundsCheck.exceededBounds(val))
                        (ß _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (ß _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
                    (ß _chunkNext = new Range(val, end, step, boundsCheck))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß _next != nil)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"IChunk" smallerChunk (ß _chunk.dropFirst())]
                (ß _next = new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext))
                (§ return (ß _next))
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [this]
        (ß forceChunk())
        (ß _chunk)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [this]
        (ß forceChunk())
        (when (ß _chunkNext == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (let [#_"Object" acc start]
            (let [#_"Number" i (ß Numbers.addP(start, step))]
                (while (ß !boundsCheck.exceededBounds(i))
                    (ß acc = f.invoke(acc, i))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i = Numbers.addP(i, step))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" val]
        (let [#_"Object" acc val]
            (let [#_"Object" i start]
                (while (ß !boundsCheck.exceededBounds(i))
                    (ß acc = f.invoke(acc, i))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i = Numbers.addP(i, step))
                )
                acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [this]
        (ß new RangeIterator())
    )

    #_private
    #_non-static
    (class-ns RangeIterator (§ implements Iterator)
        (§ field- #_"Object" next)

        (§ constructor #_"RangeIterator" RangeIterator []
            (ß this.next = start)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (ß (!boundsCheck.exceededBounds(next)))
        )

        #_method
        (§ defn #_"Object" next [this]
            (if (ß hasNext())
                (do
                    (let [#_"Object" ret next]
                        (ß next = Numbers.addP(next, step))
                        ret
                    )
                )
                (do
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (§ field #_"BigInteger" numerator)
    (§ field #_"BigInteger" denominator)

    (§ constructor #_"Ratio" Ratio [#_"BigInteger" numerator, #_"BigInteger" denominator]
        (ß this.numerator = numerator)
        (ß this.denominator = denominator)
        this
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" arg0]
        (ß (arg0 != nil && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator)))
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (ß numerator.hashCode() :xor denominator.hashCode())
    )

    #_method
    (§ defn #_"String" toString [this]
        (ß numerator.toString() + "/" + denominator.toString())
    )

    #_method
    (§ defn #_"int" intValue [this]
        (ß (int) doubleValue())
    )

    #_method
    (§ defn #_"long" longValue [this]
        (ß bigIntegerValue().longValue())
    )

    #_method
    (§ defn #_"float" floatValue [this]
        (ß (float)doubleValue())
    )

    #_method
    (§ defn #_"double" doubleValue [this]
        (ß decimalValue(MathContext.DECIMAL64).doubleValue())
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [this]
        (ß decimalValue(MathContext.UNLIMITED))
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [this, #_"MathContext" mc]
        (let [#_"BigDecimal" numerator (ß new BigDecimal(this.numerator))]
            (let [#_"BigDecimal" denominator (ß new BigDecimal(this.denominator))]
                (ß numerator.divide(denominator, mc))
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" bigIntegerValue [this]
        (ß numerator.divide(denominator))
    )

    #_method
    (§ defn #_"int" compareTo [this, #_"Object" o]
        (let [#_"Number" other (ß (Number)o)]
            (ß Numbers.compare(this, other))
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def #_"Keyword" FORM_KW (ß Keyword.intern("form")))
    (§ def #_"Keyword" SPLICING_KW (ß Keyword.intern("splicing?")))

    (§ field #_"Object" form)
    (§ field #_"Boolean" splicing)

    (§ defn #_"ReaderConditional" create [#_"Object" form, #_"boolean" splicing]
        (ß new ReaderConditional(form, splicing))
    )

    (§ constructor- #_"ReaderConditional" ReaderConditional [#_"Object" form, #_"boolean" splicing]
        (ß this.form = form)
        (ß this.splicing = splicing)
        this
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (cond (ß FORM_KW.equals(key))
            (do
                (ß this.form)
            )
            (ß SPLICING_KW.equals(key))
            (do
                (ß this.splicing)
            )
            :else
            (do
                notFound
            )
        )
    )

    (§ anno @Override)
    #_method
    (§ defn #_"boolean" equals [this, #_"Object" o]
        (when (ß this == o)
            (§ return true)
        )
        (when (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (let [#_"ReaderConditional" that (ß (ReaderConditional) o)]
            (when (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
                (§ return false)
            )
            (when (ß (splicing != nil) ? !splicing.equals(that.splicing) :or that.splicing != nil)
                (§ return false)
            )
            true
        )
    )

    (§ anno @Override)
    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"int" result (ß Util.hash(form))]
            (ß result = 31 * result + Util.hash(splicing))
            result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (§ field #_"int" i (ß 0))
    (§ field #_"int" basecnt)
    (§ field #_"ILookup" rec)
    (§ field #_"IPersistentVector" basefields)
    (§ field #_"Iterator" extmap)

    (§ constructor #_"RecordIterator" RecordIterator [#_"ILookup" rec, #_"IPersistentVector" basefields, #_"Iterator" extmap]
        (ß this.rec = rec)
        (ß this.basefields = basefields)
        (ß this.basecnt = basefields.count())
        (ß this.extmap = extmap)
        this
    )

    #_method
    (§ defn #_"boolean" hasNext [this]
        (if (ß i < basecnt)
            (do
                true
            )
            (do
                (ß extmap.hasNext())
            )
        )
    )

    #_method
    (§ defn #_"Object" next [this]
        (if (ß i < basecnt)
            (do
                (let [#_"Object" k (ß basefields.nth(i))]
                    (ß i++)
                    (ß MapEntry.create(k, rec.valAt(k)))
                )
            )
            (do
                (ß extmap.next())
            )
        )
    )

    #_method
    (§ defn #_"void" remove [this]
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (§ field #_"Object" val)

    (§ constructor #_"Reduced" Reduced [#_"Object" val]
        (ß this.val = val)
        this
    )

    #_method
    (§ defn #_"Object" deref [this]
        val
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    #_method
    (§ defn #_"int" compareTo [this, #_"Ref" ref]
        (cond (ß this.id == ref.id)
            (do
                0
            )
            (ß this.id < ref.id)
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    #_method
    (§ defn #_"int" getMinHistory [this]
        minHistory
    )

    #_method
    (§ defn #_"Ref" setMinHistory [this, #_"int" minHistory]
        (ß this.minHistory = minHistory)
        this
    )

    #_method
    (§ defn #_"int" getMaxHistory [this]
        maxHistory
    )

    #_method
    (§ defn #_"Ref" setMaxHistory [this, #_"int" maxHistory]
        (ß this.maxHistory = maxHistory)
        this
    )

    (class-ns TVal
        (§ field #_"Object" val)
        (§ field #_"long" point)
        (§ field #_"TVal" prior)
        (§ field #_"TVal" next)

        (§ constructor #_"TVal" TVal [#_"Object" val, #_"long" point, #_"TVal" prior]
            (ß this.val = val)
            (ß this.point = point)
            (ß this.prior = prior)
            (ß this.next = prior.next)
            (ß this.prior.next = this)
            (ß this.next.prior = this)
            this
        )

        (§ constructor #_"TVal" TVal [#_"Object" val, #_"long" point]
            (ß this.val = val)
            (ß this.point = point)
            (ß this.next = this)
            (ß this.prior = this)
            this
        )
    )

    (§ field #_"TVal" tvals)
    (§ field #_"AtomicInteger" faults)
    (§ field #_"ReentrantReadWriteLock" lock)
    (§ field #_"LockingTransaction.Info" tinfo)
    (§ field #_"long" id)

    #_volatile
    (§ field #_"int" minHistory (ß 0))
    #_volatile
    (§ field #_"int" maxHistory (ß 10))

    (§ def #_"AtomicLong" ids (ß new AtomicLong()))

    (§ constructor #_"Ref" Ref [#_"Object" initVal]
        (§ this(initVal, nil))
        this
    )

    (§ constructor #_"Ref" Ref [#_"Object" initVal, #_"IPersistentMap" meta]
        (§ super(meta))
        (ß this.id = ids.getAndIncrement())
        (ß this.faults = new AtomicInteger())
        (ß this.lock = new ReentrantReadWriteLock())
        (ß tvals = new TVal(initVal, 0))
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" currentVal [this]
        (try
            (ß lock.readLock().lock())
            (when (ß tvals != nil)
                (§ return (ß tvals.val))
            )
            (throw (ß new IllegalStateException(this.toString() + " is unbound.")))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"Object" deref [this]
        (let [#_"LockingTransaction" t (ß LockingTransaction.getRunning())]
            (when (ß t == nil)
                (§ return (ß currentVal()))
            )
            (ß t.doGet(this))
        )
    )

    #_method
    (§ defn #_"Object" set [this, #_"Object" val]
        (ß LockingTransaction.getEx().doSet(this, val))
    )

    #_method
    (§ defn #_"Object" commute [this, #_"IFn" fn, #_"ISeq" args]
        (ß LockingTransaction.getEx().doCommute(this, fn, args))
    )

    #_method
    (§ defn #_"Object" alter [this, #_"IFn" fn, #_"ISeq" args]
        (let [#_"LockingTransaction" t (ß LockingTransaction.getEx())]
            (ß t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args))))
        )
    )

    #_method
    (§ defn #_"void" touch [this]
        (ß LockingTransaction.getEx().doEnsure(this))
        nil
    )

    #_method
    (§ defn #_"boolean" isBound [this]
        (try
            (ß lock.readLock().lock())
            (ß (tvals != nil))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"void" trimHistory [this]
        (try
            (ß lock.writeLock().lock())
            (when (ß tvals != nil)
                (ß tvals.next = tvals)
                (ß tvals.prior = tvals)
            )
            (finally
                (ß lock.writeLock().unlock())
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" getHistoryCount [this]
        (try
            (ß lock.writeLock().lock())
            (ß histCount())
            (finally
                (ß lock.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"int" histCount [this]
        (if (ß tvals == nil)
            (do
                0
            )
            (do
                (let [#_"int" count 0]
                    (loop-when-recur [(ß TVal tv = tvals.next)] (ß tv != tvals) [(ß tv = tv.next)]
                        (ß count++)
                    )
                    count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" fn [this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß fn().invoke(arg1))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2]
        (ß fn().invoke(arg1, arg2))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß fn().invoke(arg1, arg2, arg3))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß fn().invoke(arg1, arg2, arg3, arg4))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args))
    )

    #_method
    (§ defn #_"Object" applyTo [this, #_"ISeq" arglist]
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

(class-ns Reflector
    (§ defn #_"Object" invokeInstanceMethod [#_"Object" target, #_"String" methodName, #_"Object[]" args]
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"List" methods (ß getMethods(c, args.length, methodName, false))]
                (ß invokeMatchingMethod(methodName, methods, target, args))
            )
        )
    )

    (§ defn- #_"Throwable" getCauseOrElse [#_"Exception" e]
        (when (ß e.getCause() != nil)
            (§ return (ß e.getCause()))
        )
        e
    )

    (§ defn- #_"RuntimeException" throwCauseOrElseException [#_"Exception" e]
        (when (ß e.getCause() != nil)
            (throw (ß Util.sneakyThrow(e.getCause())))
        )
        (throw (ß Util.sneakyThrow(e)))
    )

    (§ defn- #_"String" noMethodReport [#_"String" methodName, #_"Object" target]
        (ß "No matching method found: " + methodName + ((target == nil) ? "" :or " for " + target.getClass()))
    )

    (§ defn #_"Object" invokeMatchingMethod [#_"String" methodName, #_"List" methods, #_"Object" target, #_"Object[]" args]
        (let [#_"Method" m nil]
            (let [#_"Object[]" boxedArgs nil]
                (cond (ß methods.isEmpty())
                    (do
                        (throw (ß new IllegalArgumentException(noMethodReport(methodName, target))))
                    )
                    (ß methods.size() == 1)
                    (do
                        (ß m = (Method) methods.get(0))
                        (ß boxedArgs = boxArgs(m.getParameterTypes(), args))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"Method" foundm nil]
                            (loop-when-recur [(ß Iterator i = methods.iterator())] (ß i.hasNext()) [(ß )]
                                (ß m = (Method) i.next())

                                (let [#_"Class[]" params (ß m.getParameterTypes())]
                                    (when (ß isCongruent(params, args))
                                        (when (ß foundm == nil || Compiler.subsumes(params, foundm.getParameterTypes()))
                                            (ß foundm = m)
                                            (ß boxedArgs = boxArgs(params, args))
                                        )
                                    )
                                )
                            )
                            (ß m = foundm)
                        )
                    )
                )
                (when (ß m == nil)
                    (throw (ß new IllegalArgumentException(noMethodReport(methodName, target))))
                )

                (when (ß !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"Method" oldm m]
                        (ß m = getAsMethodOfPublicBase(target.getClass(), m))
                        (when (ß m == nil)
                            (throw (ß new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString())))
                        )
                    )
                )
                (try
                    (ß prepRet(m.getReturnType(), m.invoke(target, boxedArgs)))
                    (catch Exception e
                        (throw (ß Util.sneakyThrow(getCauseOrElse(e))))
                    )
                )
            )
        )
    )

    (§ defn #_"Method" getAsMethodOfPublicBase [#_"Class" c, #_"Method" m]
        (doseq [#_"Class" iface (ß c.getInterfaces())]
            (doseq [#_"Method" im (ß iface.getMethods())]
                (when (ß isMatch(im, m))
                    (§ return im)
                )
            )
        )
        (let [#_"Class" sc (ß c.getSuperclass())]
            (when (ß sc == nil)
                (§ return nil)
            )
            (doseq [#_"Method" scm (ß sc.getMethods())]
                (when (ß isMatch(scm, m))
                    (§ return scm)
                )
            )
            (ß getAsMethodOfPublicBase(sc, m))
        )
    )

    (§ defn #_"boolean" isMatch [#_"Method" lhs, #_"Method" rhs]
        (when (ß !lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers()))
            (§ return false)
        )

        (let [#_"Class[]" types1 (ß lhs.getParameterTypes())]
            (let [#_"Class[]" types2 (ß rhs.getParameterTypes())]
                (when (ß types1.length != types2.length)
                    (§ return false)
                )

                (let [#_"boolean" match true]
                    (loop-when-recur [(ß int i = 0)] (ß i < types1.length) [(ß ++i)]
                        (when (ß !types1[i].isAssignableFrom(types2[i]))
                            (ß match = false)
                            (§ break )
                        )
                    )
                    match
                )
            )
        )
    )

    (§ defn #_"Object" invokeConstructor [#_"Class" c, #_"Object[]" args]
        (try
            (let [#_"Constructor[]" allctors (ß c.getConstructors())]
                (let [#_"ArrayList" ctors (ß new ArrayList())]
                    (loop-when-recur [(ß int i = 0)] (ß i < allctors.length) [(ß i++)]
                        (let [#_"Constructor" ctor (ß allctors[i])]
                            (when (ß ctor.getParameterTypes().length == args.length)
                                (ß ctors.add(ctor))
                            )
                        )
                    )
                    (cond (ß ctors.isEmpty())
                        (do
                            (throw (ß new IllegalArgumentException("No matching ctor found for " + c)))
                        )
                        (ß ctors.size() == 1)
                        (do
                            (let [#_"Constructor" ctor (ß (Constructor) ctors.get(0))]
                                (ß ctor.newInstance(boxArgs(ctor.getParameterTypes(), args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [(ß Iterator iterator = ctors.iterator())] (ß iterator.hasNext()) [(ß )]
                                (let [#_"Constructor" ctor (ß (Constructor) iterator.next())]
                                    (let [#_"Class[]" params (ß ctor.getParameterTypes())]
                                        (when (ß isCongruent(params, args))
                                            (let [#_"Object[]" boxedArgs (ß boxArgs(params, args))]
                                                (§ return (ß ctor.newInstance(boxedArgs)))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (ß new IllegalArgumentException("No matching ctor found for " + c)))
                        )
                    )
                )
            )
            (catch Exception e
                (throw (ß Util.sneakyThrow(getCauseOrElse(e))))
            )
        )
    )

    (§ defn #_"Object" invokeStaticMethodVariadic [#_"String" className, #_"String" methodName, #_"Object..." args]
        (ß invokeStaticMethod(className, methodName, args))
    )

    (§ defn #_"Object" invokeStaticMethod [#_"String" className, #_"String" methodName, #_"Object[]" args]
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß invokeStaticMethod(c, methodName, args))
        )
    )

    (§ defn #_"Object" invokeStaticMethod [#_"Class" c, #_"String" methodName, #_"Object[]" args]
        (when (ß methodName.equals("new"))
            (§ return (ß invokeConstructor(c, args)))
        )
        (let [#_"List" methods (ß getMethods(c, args.length, methodName, true))]
            (ß invokeMatchingMethod(methodName, methods, nil, args))
        )
    )

    (§ defn #_"Object" getStaticField [#_"String" className, #_"String" fieldName]
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß getStaticField(c, fieldName))
        )
    )

    (§ defn #_"Object" getStaticField [#_"Class" c, #_"String" fieldName]
        (let [#_"Field" f (ß getField(c, fieldName, true))]
            (when (ß f != nil)
                (try
                    (§ return (ß prepRet(f.getType(), f.get(nil))))
                    (catch IllegalAccessException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
            )
            (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)))
        )
    )

    (§ defn #_"Object" setStaticField [#_"String" className, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß setStaticField(c, fieldName, val))
        )
    )

    (§ defn #_"Object" setStaticField [#_"Class" c, #_"String" fieldName, #_"Object" val]
        (let [#_"Field" f (ß getField(c, fieldName, true))]
            (when (ß f != nil)
                (try
                    (ß f.set(nil, boxArg(f.getType(), val)))
                    (catch IllegalAccessException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
                (§ return val)
            )
            (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)))
        )
    )

    (§ defn #_"Object" getInstanceField [#_"Object" target, #_"String" fieldName]
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, fieldName, false))]
                (when (ß f != nil)
                    (try
                        (§ return (ß prepRet(f.getType(), f.get(target))))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())))
            )
        )
    )

    (§ defn #_"Object" setInstanceField [#_"Object" target, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, fieldName, false))]
                (when (ß f != nil)
                    (try
                        (ß f.set(target, boxArg(f.getType(), val)))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                    (§ return val)
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (§ defn #_"Object" invokeNoArgInstanceMember [#_"Object" target, #_"String" name]
        (ß invokeNoArgInstanceMember(target, name, false))
    )

    (§ defn #_"Object" invokeNoArgInstanceMember [#_"Object" target, #_"String" name, #_"boolean" requireField]
        (let [#_"Class" c (ß target.getClass())]
            (if requireField
                (do
                    (let [#_"Field" f (ß getField(c, name, false))]
                        (if (ß f != nil)
                            (do
                                (ß getInstanceField(target, name))
                            )
                            (do
                                (throw (ß new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass())))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" meths (ß getMethods(c, 0, name, false))]
                        (if (ß meths.size() > 0)
                            (do
                                (ß invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY))
                            )
                            (do
                                (ß getInstanceField(target, name))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Object" invokeInstanceMember [#_"Object" target, #_"String" name]
        ;; check for field first
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, name, false))]
                (when (ß f != nil) ;; field get
                    (try
                        (§ return (ß prepRet(f.getType(), f.get(target))))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (ß invokeInstanceMethod(target, name, RT.EMPTY_ARRAY))
            )
        )
    )

    (§ defn #_"Object" invokeInstanceMember [#_"String" name, #_"Object" target, #_"Object" arg1]
        ;; check for field first
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, name, false))]
                (when (ß f != nil) ;; field set
                    (try
                        (ß f.set(target, boxArg(f.getType(), arg1)))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                    (§ return arg1)
                )
                (ß invokeInstanceMethod(target, name, new Object[] (§ arg1 )))
            )
        )
    )

    (§ defn #_"Object" invokeInstanceMember [#_"String" name, #_"Object" target, #_"Object..." args]
        (ß invokeInstanceMethod(target, name, args))
    )

    (§ defn #_"Field" getField [#_"Class" c, #_"String" name, #_"boolean" getStatics]
        (let [#_"Field[]" allfields (ß c.getFields())]
            (loop-when-recur [(ß int i = 0)] (ß i < allfields.length) [(ß i++)]
                (when (ß name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
                    (§ return (ß allfields[i]))
                )
            )
            nil
        )
    )

    (§ defn #_"List" getMethods [#_"Class" c, #_"int" arity, #_"String" name, #_"boolean" getStatics]
        (let [#_"Method[]" allmethods (ß c.getMethods())]
            (let [#_"ArrayList" methods (ß new ArrayList())]
                (let [#_"ArrayList" bridgeMethods (ß new ArrayList())]
                    (loop-when-recur [(ß int i = 0)] (ß i < allmethods.length) [(ß i++)]
                        (let [#_"Method" method (ß allmethods[i])]
                            (when (ß name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity)
                                (try
                                    (if (ß method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method))
                                        (do
                                            (ß bridgeMethods.add(method))
                                        )
                                        (do
                                            (ß methods.add(method))
                                        )
                                    )
                                    (catch NoSuchMethodException e
                                    )
                                )
                            )
                        )
                    )

                    (when (ß methods.isEmpty())
                        (ß methods.addAll(bridgeMethods))
                    )
                    (when (ß !getStatics && c.isInterface())
                        (ß allmethods = Object.class.getMethods())
                        (loop-when-recur [(ß int i = 0)] (ß i < allmethods.length) [(ß i++)]
                            (when (ß name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity)
                                (ß methods.add(allmethods[i]))
                            )
                        )
                    )
                    methods
                )
            )
        )
    )

    (§ defn #_"Object" boxArg [#_"Class" paramType, #_"Object" arg]
        (cond (ß !paramType.isPrimitive())
            (do
                (§ return (ß paramType.cast(arg)))
            )
            (ß paramType == boolean.class)
            (do
                (§ return (ß Boolean.class.cast(arg)))
            )
            (ß paramType == char.class)
            (do
                (§ return (ß Character.class.cast(arg)))
            )
            (ß arg instanceof Number)
            (do
                (let [#_"Number" n (ß (Number) arg)]
                    (cond (ß paramType == int.class)
                        (do
                            (§ return (ß n.intValue()))
                        )
                        (ß paramType == float.class)
                        (do
                            (§ return (ß n.floatValue()))
                        )
                        (ß paramType == double.class)
                        (do
                            (§ return (ß n.doubleValue()))
                        )
                        (ß paramType == long.class)
                        (do
                            (§ return (ß n.longValue()))
                        )
                        (ß paramType == short.class)
                        (do
                            (§ return (ß n.shortValue()))
                        )
                        (ß paramType == byte.class)
                        (do
                            (§ return (ß n.byteValue()))
                        )
                    )
                )
            )
        )
        (throw (ß new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName())))
    )

    (§ defn #_"Object[]" boxArgs [#_"Class[]" params, #_"Object[]" args]
        (when (ß params.length == 0)
            (§ return nil)
        )
        (let [#_"Object[]" ret (ß new Object[params.length])]
            (loop-when-recur [(ß int i = 0)] (ß i < params.length) [(ß i++)]
                (let [#_"Object" arg (ß args[i])]
                    (let [#_"Class" paramType (ß params[i])]
                        (ß ret[i] = boxArg(paramType, arg))
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"boolean" paramArgTypeMatch [#_"Class" paramType, #_"Class" argType]
        (when (ß argType == nil)
            (§ return (ß !paramType.isPrimitive()))
        )
        (when (ß paramType == argType || paramType.isAssignableFrom(argType))
            (§ return true)
        )
        (cond (ß paramType == int.class)
            (do
                (§ return (ß argType == Integer.class
                    || argType == long.class
                    || argType == Long.class
                    || argType == short.class
                    || argType == byte.class))
            )
            (ß paramType == float.class)
            (do
                (§ return (ß argType == Float.class
                    || argType == double.class))
            )
            (ß paramType == double.class)
            (do
                (§ return (ß argType == Double.class
                    || argType == float.class))
            )
            (ß paramType == long.class)
            (do
                (§ return (ß argType == Long.class
                    || argType == int.class
                    || argType == short.class
                    || argType == byte.class))
            )
            (ß paramType == char.class)
            (do
                (§ return (ß argType == Character.class))
            )
            (ß paramType == short.class)
            (do
                (§ return (ß argType == Short.class))
            )
            (ß paramType == byte.class)
            (do
                (§ return (ß argType == Byte.class))
            )
            (ß paramType == boolean.class)
            (do
                (§ return (ß argType == Boolean.class))
            )
        )
        false
    )

    (§ defn #_"boolean" isCongruent [#_"Class[]" params, #_"Object[]" args]
        (let [#_"boolean" ret false]
            (when (ß args == nil)
                (§ return (ß (params.length == 0)))
            )
            (when (ß params.length == args.length)
                (ß ret = true)
                (loop-when-recur [(ß int i = 0)] (ß ret && i < params.length) [(ß i++)]
                    (let [#_"Object" arg (ß args[i])]
                        (let [#_"Class" argType (ß (arg == nil) ? nil :or arg.getClass())]
                            (let [#_"Class" paramType (ß params[i])]
                                (ß ret = paramArgTypeMatch(paramType, argType))
                            )
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"Object" prepRet [#_"Class" c, #_"Object" x]
        (when (ß !(c.isPrimitive() || c == Boolean.class))
            (§ return x)
        )
        (when (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE))
        )
        x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (§ def- #_"long" INFINITE (ß -1))

    (§ field- #_"long" count) ;; always INFINITE or >0
    (§ field- #_"Object" val)
    #_volatile
    (§ field- #_"ISeq" _next) ;; cached

    (§ constructor- #_"Repeat" Repeat [#_"long" count, #_"Object" val]
        (ß this.count = count)
        (ß this.val = val)
        this
    )

    (§ constructor- #_"Repeat" Repeat [#_"IPersistentMap" meta, #_"long" count, #_"Object" val]
        (§ super(meta))
        (ß this.count = count)
        (ß this.val = val)
        this
    )

    (§ defn #_"Repeat" create [#_"Object" val]
        (ß new Repeat(INFINITE, val))
    )

    (§ defn #_"ISeq" create [#_"long" count, #_"Object" val]
        (when (ß count <= 0)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Repeat(count, val))
    )

    #_method
    (§ defn #_"Object" first [this]
        val
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß _next == nil)
            (cond (ß count > 1)
                (do
                    (ß _next = new Repeat(count - 1, val))
                )
                (ß count == INFINITE)
                (do
                    (ß _next = this)
                )
            )
        )
        (ß _next)
    )

    #_method
    (§ defn #_"Repeat" withMeta [this, #_"IPersistentMap" meta]
        (ß new Repeat(meta, count, val))
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f]
        (let [#_"Object" ret val]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(ß long i = 1)] (ß i < count) [(ß i++)]
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                    ret
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [this, #_"IFn" f, #_"Object" start]
        (let [#_"Object" ret start]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(ß long i = 0)] (ß i < count) [(ß i++)]
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_abstract
(class-ns RestFn (§ extends AFunction)
    (§ abstract int getRequiredArity())

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object" args]
        nil
    )

    #_method
    (§ defn #_"Object" applyTo [this, #_"ISeq" args]
        (when (ß RT.boundedLength(args, getRequiredArity()) <= getRequiredArity())
            (§ return (ß AFn.applyToHelper(this, Util.ret1(args, args = nil))))
        )
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (§ return (ß doInvoke(Util.ret1(args, args = nil))))
            )
            (§ case 1)
            (do
                (§ return (ß doInvoke(args.first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 2)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 3)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 4)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 5)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 6)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 7)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 8)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 9)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 10)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 11)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 12)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 13)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 14)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 15)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 16)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 17)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 18)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 19)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 20)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
        )
        (ß throwArity(-1))
    )

    #_method
    (§ defn #_"Object" invoke [this]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(nil))
            )
            (§ default )
            (do
                (ß throwArity(0))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(Util.ret1(arg1, arg1 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(1))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(2))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    ArraySeq.create(
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(3))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    ArraySeq.create(
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    ArraySeq.create(
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(4))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(5))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(6))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(7))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(8))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(9))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(10))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(11))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(12))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(13))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(14))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(15))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(16))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(17))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(18))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(19))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil),
                        Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                        ArraySeq.create(
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(20))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ontoArrayPrepend(args,
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil),
                        Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                        ArraySeq.create(args)))
            )
            (§ default )
            (do
                (ß throwArity(21))
            )
        )
    )

    #_protected
    (§ defn #_"ISeq" ontoArrayPrepend [#_"Object[]" array, #_"Object..." args]
        (let [#_"ISeq" ret (ß ArraySeq.create(array))]
            (loop-when-recur [(ß int i = args.length - 1)] (ß i >= 0) [(ß --i)]
                (ß ret = RT.cons(args[i], ret))
            )
            ret
        )
    )

    #_protected
    (§ defn #_"ISeq" findKey [#_"Object" key, #_"ISeq" args]
        (while (ß args != nil)
            (when (ß key == args.first())
                (§ return (ß args.next()))
            )
            (ß args = RT.next(args))
            (ß args = RT.next(args))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(§ interface Reversible
    (§ abstract ISeq rseq())
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

(class-ns RT
    (§ def #_"Boolean" T (ß Boolean.TRUE))
    (§ def #_"Boolean" F (ß Boolean.FALSE))
    (§ def #_"String" LOADER_SUFFIX (ß "__init"))

    ;; simple-symbol->class
    (§ def #_"IPersistentMap" DEFAULT_IMPORTS (ß map(
      #_map Symbol.intern("Boolean"), Boolean.class,
      #_map Symbol.intern("Byte"), Byte.class,
      #_map Symbol.intern("Character"), Character.class,
      #_map Symbol.intern("Class"), Class.class,
      #_map Symbol.intern("ClassLoader"), ClassLoader.class,
      #_map Symbol.intern("Compiler"), Compiler.class,
      #_map Symbol.intern("Double"), Double.class,
      #_map Symbol.intern("Enum"), Enum.class,
      #_map Symbol.intern("Float"), Float.class,
      #_map Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
      #_map Symbol.intern("Integer"), Integer.class,
      #_map Symbol.intern("Long"), Long.class,
      #_map Symbol.intern("Math"), Math.class,
      #_map Symbol.intern("Number"), Number.class,
      #_map Symbol.intern("Object"), Object.class,
      #_map Symbol.intern("Package"), Package.class,
      #_map Symbol.intern("Process"), Process.class,
      #_map Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
      #_map Symbol.intern("Runtime"), Runtime.class,
      #_map Symbol.intern("RuntimePermission"), RuntimePermission.class,
      #_map Symbol.intern("SecurityManager"), SecurityManager.class,
      #_map Symbol.intern("Short"), Short.class,
      #_map Symbol.intern("StackTraceElement"), StackTraceElement.class,
      #_map Symbol.intern("StrictMath"), StrictMath.class,
      #_map Symbol.intern("String"), String.class,
      #_map Symbol.intern("StringBuffer"), StringBuffer.class,
      #_map Symbol.intern("StringBuilder"), StringBuilder.class,
      #_map Symbol.intern("System"), System.class,
      #_map Symbol.intern("Thread"), Thread.class,
      #_map Symbol.intern("ThreadGroup"), ThreadGroup.class,
      #_map Symbol.intern("ThreadLocal"), ThreadLocal.class,
      #_map Symbol.intern("Throwable"), Throwable.class,
      #_map Symbol.intern("Void"), Void.class,
      #_map Symbol.intern("Appendable"), Appendable.class,
      #_map Symbol.intern("CharSequence"), CharSequence.class,
      #_map Symbol.intern("Cloneable"), Cloneable.class,
      #_map Symbol.intern("Comparable"), Comparable.class,
      #_map Symbol.intern("Iterable"), Iterable.class,
      #_map Symbol.intern("Readable"), Readable.class,
      #_map Symbol.intern("Runnable"), Runnable.class,
      #_map Symbol.intern("Callable"), Callable.class,
      #_map Symbol.intern("BigInteger"), BigInteger.class,
      #_map Symbol.intern("BigDecimal"), BigDecimal.class,
      #_map Symbol.intern("ArithmeticException"), ArithmeticException.class,
      #_map Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
      #_map Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
      #_map Symbol.intern("ClassCastException"), ClassCastException.class,
      #_map Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
      #_map Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
      #_map Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
      #_map Symbol.intern("Exception"), Exception.class,
      #_map Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
      #_map Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
      #_map Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
      #_map Symbol.intern("IllegalStateException"), IllegalStateException.class,
      #_map Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
      #_map Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
      #_map Symbol.intern("InstantiationException"), InstantiationException.class,
      #_map Symbol.intern("InterruptedException"), InterruptedException.class,
      #_map Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
      #_map Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
      #_map Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
      #_map Symbol.intern("NullPointerException"), NullPointerException.class,
      #_map Symbol.intern("NumberFormatException"), NumberFormatException.class,
      #_map Symbol.intern("RuntimeException"), RuntimeException.class,
      #_map Symbol.intern("SecurityException"), SecurityException.class,
      #_map Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
      #_map Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
      #_map Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
      #_map Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
      #_map Symbol.intern("AssertionError"), AssertionError.class,
      #_map Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
      #_map Symbol.intern("ClassFormatError"), ClassFormatError.class,
      #_map Symbol.intern("Error"), Error.class,
      #_map Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
      #_map Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
      #_map Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
      #_map Symbol.intern("InstantiationError"), InstantiationError.class,
      #_map Symbol.intern("InternalError"), InternalError.class,
      #_map Symbol.intern("LinkageError"), LinkageError.class,
      #_map Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
      #_map Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
      #_map Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
      #_map Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
      #_map Symbol.intern("StackOverflowError"), StackOverflowError.class,
      #_map Symbol.intern("ThreadDeath"), ThreadDeath.class,
      #_map Symbol.intern("UnknownError"), UnknownError.class,
      #_map Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
      #_map Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
      #_map Symbol.intern("VerifyError"), VerifyError.class,
      #_map Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
      #_map Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
      #_map Symbol.intern("Thread$State"), Thread.State.class,
      #_map Symbol.intern("Deprecated"), Deprecated.class,
      #_map Symbol.intern("Override"), Override.class,
      #_map Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    )))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (§ def #_"Charset" UTF8 (ß Charset.forName("UTF-8")))

    (§ defn #_"Object" readTrueFalseUnknown [#_"String" s]
        (cond (ß s.equals("true"))
            (do
                (§ return (ß Boolean.TRUE))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß Boolean.FALSE))
            )
        )
        (ß Keyword.intern(nil, "unknown"))
    )

    (§ def #_"Namespace" CLOIURE_NS (ß Namespace.findOrCreate(Symbol.intern("cloiure.core"))))
    (§ def #_"Var" OUT (ß Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic()))
    (§ def #_"Var" IN (ß Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic()))
    (§ def #_"Var" ERR (ß Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic()))
    (§ def #_"Keyword" TAG_KEY (ß Keyword.intern(nil, "tag")))
    (§ def #_"Keyword" CONST_KEY (ß Keyword.intern(nil, "const")))
    (§ def #_"Var" AGENT (ß Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), nil).setDynamic()))
    (§ def #_"Object" readeval (ß readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true"))))
    (§ def #_"Var" READEVAL (ß Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"),  readeval).setDynamic()))
    (§ def #_"Var" DATA_READERS (ß Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic()))
    (§ def #_"Var" DEFAULT_DATA_READER_FN (ß Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic()))
    (§ def #_"Var" DEFAULT_DATA_READERS (ß Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map())))
    (§ def #_"Var" SUPPRESS_READ (ß Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), nil).setDynamic()))
    (§ def #_"Var" ASSERT (ß Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic()))
    (§ def #_"Var" MATH_CONTEXT (ß Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), nil).setDynamic()))
    (§ def #_"Keyword" LINE_KEY (ß Keyword.intern(nil, "line")))
    (§ def #_"Keyword" COLUMN_KEY (ß Keyword.intern(nil, "column")))
    (§ def #_"Keyword" FILE_KEY (ß Keyword.intern(nil, "file")))
    (§ def #_"Keyword" DECLARED_KEY (ß Keyword.intern(nil, "declared")))
    (§ def #_"Keyword" DOC_KEY (ß Keyword.intern(nil, "doc")))
    (§ def #_"Var" USE_CONTEXT_CLASSLOADER (ß Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic()))
    ;; boolean
    (§ def #_"Var" UNCHECKED_MATH (ß Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic()))

    (§ def #_"Symbol" LOAD_FILE (ß Symbol.intern("load-file")))
    (§ def #_"Symbol" IN_NAMESPACE (ß Symbol.intern("in-ns")))
    (§ def #_"Symbol" NAMESPACE (ß Symbol.intern("ns")))
    (§ def #_"Symbol" IDENTICAL (ß Symbol.intern("identical?")))
    (§ def #_"Var" CMD_LINE_ARGS (ß Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), nil).setDynamic()))
    ;; symbol
    (§ def #_"Var" CURRENT_NS (ß Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic()))

    (§ def #_"Var" FLUSH_ON_NEWLINE (ß Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic()))
    (§ def #_"Var" PRINT_META (ß Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic()))
    (§ def #_"Var" PRINT_READABLY (ß Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic()))
    (§ def #_"Var" PRINT_DUP (ß Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic()))
    (§ def #_"Var" WARN_ON_REFLECTION (ß Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic()))
    (§ def #_"Var" ALLOW_UNRESOLVED_VARS (ß Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic()))
    (§ def #_"Var" READER_RESOLVER (ß Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), nil).setDynamic()))

    (§ def #_"Var" IN_NS_VAR (ß Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F)))
    (§ def #_"Var" NS_VAR (ß Var.intern(CLOIURE_NS, Symbol.intern("ns"), F)))
    (§ def #_"Var" FN_LOADER_VAR (ß Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), nil).setDynamic()))
    (§ def #_"Var" PRINT_INITIALIZED (ß Var.intern(CLOIURE_NS, Symbol.intern("print-initialized"))))
    (§ def #_"Var" PR_ON (ß Var.intern(CLOIURE_NS, Symbol.intern("pr-on"))))

    (§ def #_"IFn" inNamespace (ß new AFn()
        (§ reify
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" arg1]
                (let [#_"Symbol" nsname (ß (Symbol) arg1)]
                    (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsname))]
                        (ß CURRENT_NS.set(ns))
                        ns
                    )
                )
            )
        )
    ))

    (§ def #_"IFn" bootNamespace (ß new AFn()
        (§ reify
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" __form, #_"Object" __env, #_"Object" arg1]
                (let [#_"Symbol" nsname (ß (Symbol) arg1)]
                    (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsname))]
                        (ß CURRENT_NS.set(ns))
                        ns
                    )
                )
            )
        )
    ))

    (§ defn #_"List<String>" processCommandLine [#_"String[]" args]
        (let [#_"List<String>" arglist (ß Arrays.asList(args))]
            (let [#_"int" split (ß arglist.indexOf("--"))]
                (when (ß split >= 0)
                    (ß CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length))))
                    (§ return (ß arglist.subList(0, split)))
                )
                arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (§ defn #_"PrintWriter" errPrintWriter []
        (let [#_"Writer" w (ß (Writer) ERR.deref())]
            (if (ß w instanceof PrintWriter)
                (do
                    (ß (PrintWriter) w)
                )
                (do
                    (ß new PrintWriter(w))
                )
            )
        )
    )

    (§ def #_"Object[]" EMPTY_ARRAY (ß new Object[] (§)))
    (§ def #_"Comparator" DEFAULT_COMPARATOR (ß new DefaultComparator()))

    #_private
    (class-ns DefaultComparator (§ implements Comparator)
        #_method
        (§ defn #_"int" compare [this, #_"Object" o1, #_"Object" o2]
            (ß Util.compare(o1, o2))
        )
    )

    (§ def #_"AtomicInteger" id (ß new AtomicInteger(1)))

    (§ defn #_"void" addURL [#_"Object" url] (§ throws MalformedURLException)
        (let [#_"URL" u (ß (url instanceof String) ? (new URL((String) url)) :or (URL) url)]
            (let [#_"ClassLoader" ccl (ß Thread.currentThread().getContextClassLoader())]
                (if (ß ccl instanceof DynamicClassLoader)
                    (do
                        (ß ((DynamicClassLoader)ccl).addURL(u))
                    )
                    (do
                        (throw (ß new IllegalAccessError("Context classloader is not a DynamicClassLoader")))
                    )
                )
                nil
            )
        )
    )

    (§ def #_"boolean" checkSpecAsserts (ß Boolean.getBoolean("cloiure.spec.check-asserts")))
    (§ def #_"boolean" instrumentMacros (ß ! Boolean.getBoolean("cloiure.spec.skip-macros")))
    #_volatile
    (§ def #_"boolean" CHECK_SPECS (ß false))

    (§ static
        (let [#_"Keyword" arglistskw (ß Keyword.intern(nil, "arglists"))]
            (let [#_"Symbol" namesym (ß Symbol.intern("name"))]
                (ß OUT.setTag(Symbol.intern("java.io.Writer")))
                (ß CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace")))
                (ß AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß AGENT.setTag(Symbol.intern("cloiure.lang.Agent")))
                (ß MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext")))
                (let [#_"Var" nv (ß Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace))]
                    (ß nv.setMacro())
                    (§ let [#_"Var" v]
                        (ß v = Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace))
                        (ß v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym)))))
                        (ß v = Var.intern(CLOIURE_NS, LOAD_FILE, new AFn()
                            (§ reify
                                #_method
                                (§ defn #_"Object" invoke [this, #_"Object" arg1]
                                    (try
                                        (ß Compiler.loadFile((String) arg1))
                                        (catch IOException e
                                            (throw (ß Util.sneakyThrow(e)))
                                        )
                                    )
                                )
                            ))
                        )
                        (ß v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym)))))
                        (try
                            (ß doInit())
                            (catch Exception e
                                (throw (ß Util.sneakyThrow(e)))
                            )
                        )

                        (ß CHECK_SPECS = RT.instrumentMacros)
                    )
                )
            )
        )
    )

    (§ defn #_"Keyword" keyword [#_"String" ns, #_"String" name]
        (ß Keyword.intern((Symbol.intern(ns, name))))
    )

    (§ defn #_"Var" var [#_"String" ns, #_"String" name]
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name)))
    )

    (§ defn #_"Var" var [#_"String" ns, #_"String" name, #_"Object" init]
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name), init))
    )

    (§ defn #_"void" loadResourceScript [#_"String" name] (§ throws IOException)
        (ß loadResourceScript(name, true))
        nil
    )

    (§ defn #_"void" maybeLoadResourceScript [#_"String" name] (§ throws IOException)
        (ß loadResourceScript(name, false))
        nil
    )

    (§ defn #_"void" loadResourceScript [#_"String" name, #_"boolean" failIfNotFound] (§ throws IOException)
        (ß loadResourceScript(RT.class, name, failIfNotFound))
        nil
    )

    (§ defn #_"void" loadResourceScript [#_"Class" c, #_"String" name] (§ throws IOException)
        (ß loadResourceScript(c, name, true))
        nil
    )

    (§ defn #_"void" loadResourceScript [#_"Class" c, #_"String" name, #_"boolean" failIfNotFound] (§ throws IOException)
        (let [#_"int" slash (ß name.lastIndexOf(\/))]
            (let [#_"String" file (ß (slash >= 0) ? name.substring(slash + 1) :or name)]
                (let [#_"InputStream" ins (ß resourceAsStream(baseLoader(), name))]
                    (cond (ß ins != nil)
                        (do
                            (try
                                (ß Compiler.load(new InputStreamReader(ins, UTF8), name, file))
                                (finally
                                    (ß ins.close())
                                )
                            )
                        )
                        failIfNotFound
                        (do
                            (throw (ß new FileNotFoundException("Could not locate Cloiure resource on classpath: " + name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (§ defn #_"void" init []
        (ß RT.errPrintWriter().println("No need to call RT.init() anymore"))
        nil
    )

    (§ defn #_"long" lastModified [#_"URL" url, #_"String" libfile] (§ throws IOException)
        (let [#_"URLConnection" connection (ß url.openConnection())]
            (try
                (if (ß url.getProtocol().equals("jar"))
                    (do
                        (ß ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime())
                    )
                    (do
                        (ß connection.getLastModified())
                    )
                )
                (finally
                    (let [#_"InputStream" ins (ß connection.getInputStream())]
                        (when (ß ins != nil)
                            (ß ins.close())
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" compile [#_"String" cljfile] (§ throws IOException)
        (let [#_"InputStream" ins (ß resourceAsStream(baseLoader(), cljfile))]
            (if (ß ins != nil)
                (do
                    (try
                        (ß Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/"))))
                        (finally
                            (ß ins.close())
                        )
                    )
                )
                (do
                    (throw (ß new FileNotFoundException("Could not locate Cloiure resource on classpath: " + cljfile)))
                )
            )
            nil
        )
    )

    (§ defn #_"void" load [#_"String" scriptbase] (§ throws IOException, ClassNotFoundException)
        (ß load(scriptbase, true))
        nil
    )

    (§ defn #_"void" load [#_"String" scriptbase, #_"boolean" failIfNotFound] (§ throws IOException, ClassNotFoundException)
        (let [#_"String" classfile (ß scriptbase + LOADER_SUFFIX + ".class")]
            (let [#_"String" cljfile (ß scriptbase + ".cli")]
                (let [#_"String" scriptfile cljfile]
                    (let [#_"URL" classURL (ß getResource(baseLoader(), classfile))]
                        (let [#_"URL" cljURL (ß getResource(baseLoader(), scriptfile))]
                            (when (ß cljURL == nil)
                                (ß scriptfile = scriptbase + ".clic")
                                (ß cljURL = getResource(baseLoader(), scriptfile))
                            )
                            (let [#_"boolean" loaded false]
                                (when (ß (classURL != nil && (cljURL == nil || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == nil)
                                    (try
                                        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                            #_map CURRENT_NS, CURRENT_NS.deref(),
                                            #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                                            #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                                        )))
                                        (ß loaded = (loadClassForName(scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil))
                                        (finally
                                            (ß Var.popThreadBindings())
                                        )
                                    )
                                )
                                (cond (ß !loaded && cljURL != nil)
                                    (do
                                        (if (ß booleanCast(Compiler.COMPILE_FILES.deref()))
                                            (do
                                                (ß compile(scriptfile))
                                            )
                                            (do
                                                (ß loadResourceScript(RT.class, scriptfile))
                                            )
                                        )
                                    )
                                    (ß !loaded && failIfNotFound)
                                    (do
                                        (throw (ß new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile, scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or ""))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" doInit [] (§ throws ClassNotFoundException, IOException)
        (ß load("cloiure/core"))

        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map CURRENT_NS, CURRENT_NS.deref(),
              #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        )))
        (try
            (let [(ß Symbol USER = Symbol.intern("user"))]
                (let [(ß Symbol CLOIURE = Symbol.intern("cloiure.core"))]
                    (let [#_"Var" in_ns (ß var("cloiure.core", "in-ns"))]
                        (let [#_"Var" refer (ß var("cloiure.core", "refer"))]
                            (ß in_ns.invoke(USER))
                            (ß refer.invoke(CLOIURE))
                            (ß maybeLoadResourceScript("user.cli"))

                            ;; start socket servers
                            (let [#_"Var" require (ß var("cloiure.core", "require"))]
                                (let [(ß Symbol SERVER = Symbol.intern("cloiure.core.server"))]
                                    (ß require.invoke(SERVER))
                                    (let [#_"Var" start_servers (ß var("cloiure.core.server", "start-servers"))]
                                        (ß start_servers.invoke(System.getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (ß Var.popThreadBindings())
            )
        )
        nil
    )

    (§ defn #_"int" nextID []
        (ß id.getAndIncrement())
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (§ defn #_"void" loadLibrary [#_"String" libname]
        (ß System.loadLibrary(libname))
        nil
    )

    (§ def- #_"int" CHUNK_SIZE (ß 32))

    (§ defn #_"ISeq" chunkIteratorSeq [#_"Iterator" iter]
        (when (ß iter.hasNext())
            (§ return (ß new LazySeq(new AFn()
                (§ reify
                    #_method
                    (§ defn #_"Object" invoke [this]
                        (let [#_"Object[]" arr (ß new Object[CHUNK_SIZE])]
                            (let [#_"int" n 0]
                                (while (ß iter.hasNext() && n < CHUNK_SIZE)
                                    (ß arr[n++] = iter.next())
                                )
                                (ß new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter)))
                            )
                        )
                    )
                )))
            )
        )
        nil
    )

    (§ defn #_"ISeq" seq [#_"Object" coll]
        (cond (ß coll instanceof ASeq)
            (do
                (ß (ASeq) coll)
            )
            (ß coll instanceof LazySeq)
            (do
                (ß ((LazySeq) coll).seq())
            )
            :else
            (do
                (ß seqFrom(coll))
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (§ defn #_"ISeq" seqFrom [#_"Object" coll]
        (cond (ß coll instanceof Seqable)
            (do
                (ß ((Seqable) coll).seq())
            )
            (ß coll == nil)
            (do
                nil
            )
            (ß coll instanceof Iterable)
            (do
                (ß chunkIteratorSeq(((Iterable) coll).iterator()))
            )
            (ß coll.getClass().isArray())
            (do
                (ß ArraySeq.createFromObject(coll))
            )
            (ß coll instanceof CharSequence)
            (do
                (ß StringSeq.create((CharSequence) coll))
            )
            (ß coll instanceof Map)
            (do
                (ß seq(((Map) coll).entrySet()))
            )
            :else
            (do
                (let [#_"Class" c (ß coll.getClass())]
                    (let [#_"Class" sc (ß c.getSuperclass())]
                        (throw (ß new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName())))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" canSeq [#_"Object" coll]
        (ß coll instanceof ISeq
            || coll instanceof Seqable
            || coll == nil
            || coll instanceof Iterable
            || coll.getClass().isArray()
            || coll instanceof CharSequence
            || coll instanceof Map)
    )

    (§ defn #_"Iterator" iter [#_"Object" coll]
        (cond (ß coll instanceof Iterable)
            (do
                (ß ((Iterable)coll).iterator())
            )
            (ß coll == nil)
            (do
                (ß new Iterator()
                    (§ reify
                        #_method
                        (§ defn #_"boolean" hasNext [this]
                            false
                        )

                        #_method
                        (§ defn #_"Object" next [this]
                            (throw (ß new NoSuchElementException()))
                        )

                        #_method
                        (§ defn #_"void" remove [this]
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
            (ß coll instanceof Map)
            (do
                (ß ((Map)coll).entrySet().iterator())
            )
            (ß coll instanceof String)
            (do
                (let [#_"String" s (ß (String) coll)]
                    (ß new Iterator()
                        (§ reify
                            (let [#_"int" i 0]
                                #_method
                                (§ defn #_"boolean" hasNext [this]
                                    (ß (i < s.length()))
                                )

                                #_method
                                (§ defn #_"Object" next [this]
                                    (ß s.charAt(i++))
                                )

                                #_method
                                (§ defn #_"void" remove [this]
                                    (throw (ß new UnsupportedOperationException()))
                                )
                            )
                        )
                    )
                )
            )
            (ß coll.getClass().isArray())
            (do
                (ß ArrayIter.createFromObject(coll))
            )
            :else
            (do
                (ß iter(seq(coll)))
            )
        )
    )

    (§ defn #_"Object" seqOrElse [#_"Object" o]
        (ß (seq(o) == nil) ? nil :or o)
    )

    (§ defn #_"ISeq" keys [#_"Object" coll]
        (if (ß coll instanceof IPersistentMap)
            (do
                (ß APersistentMap.KeySeq.createFromMap((IPersistentMap)coll))
            )
            (do
                (ß APersistentMap.KeySeq.create(seq(coll)))
            )
        )
    )

    (§ defn #_"ISeq" vals [#_"Object" coll]
        (if (ß coll instanceof IPersistentMap)
            (do
                (ß APersistentMap.ValSeq.createFromMap((IPersistentMap)coll))
            )
            (do
                (ß APersistentMap.ValSeq.create(seq(coll)))
            )
        )
    )

    (§ defn #_"IPersistentMap" meta [#_"Object" x]
        (when (ß x instanceof IMeta)
            (§ return (ß ((IMeta) x).meta()))
        )
        nil
    )

    (§ defn #_"int" count [#_"Object" o]
        (when (ß o instanceof Counted)
            (§ return (ß ((Counted) o).count()))
        )
        (ß countFrom(Util.ret1(o, o = nil)))
    )

    (§ defn #_"int" countFrom [#_"Object" o]
        (cond (ß o == nil)
            (do
                (§ return 0)
            )
            (ß o instanceof IPersistentCollection)
            (do
                (let [#_"ISeq" s (ß seq(o))]
                    (ß o = nil)
                    (let [#_"int" i 0]
                        (loop-when-recur [(ß )] (ß s != nil) [(ß s = s.next())]
                            (when (ß s instanceof Counted)
                                (§ return (ß i + s.count()))
                            )
                            (ß i++)
                        )
                        (§ return i)
                    )
                )
            )
            (ß o instanceof CharSequence)
            (do
                (§ return (ß ((CharSequence) o).length()))
            )
            (ß o instanceof Collection)
            (do
                (§ return (ß ((Collection) o).size()))
            )
            (ß o instanceof Map)
            (do
                (§ return (ß ((Map) o).size()))
            )
            (ß o instanceof Map.Entry)
            (do
                (§ return 2)
            )
            (ß o.getClass().isArray())
            (do
                (§ return (ß Array.getLength(o)))
            )
        )

        (throw (ß new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName())))
    )

    (§ defn #_"IPersistentCollection" conj [#_"IPersistentCollection" coll, #_"Object" x]
        (when (ß coll == nil)
            (§ return (ß new PersistentList(x)))
        )
        (ß coll.cons(x))
    )

    (§ defn #_"ISeq" cons [#_"Object" x, #_"Object" coll]
        (cond (ß coll == nil)
            (do
                (ß new PersistentList(x))
            )
            (ß coll instanceof ISeq)
            (do
                (ß new Cons(x, (ISeq) coll))
            )
            :else
            (do
                (ß new Cons(x, seq(coll)))
            )
        )
    )

    (§ defn #_"Object" first [#_"Object" x]
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).first()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß seq.first())
        )
    )

    (§ defn #_"Object" second [#_"Object" x]
        (ß first(next(x)))
    )

    (§ defn #_"Object" third [#_"Object" x]
        (ß first(next(next(x))))
    )

    (§ defn #_"Object" fourth [#_"Object" x]
        (ß first(next(next(next(x)))))
    )

    (§ defn #_"ISeq" next [#_"Object" x]
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).next()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß seq.next())
        )
    )

    (§ defn #_"ISeq" more [#_"Object" x]
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).more()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (ß seq == nil)
                (§ return (ß PersistentList.EMPTY))
            )
            (ß seq.more())
        )
    )

    (§ defn #_"Object" peek [#_"Object" x]
        (when (ß x == nil)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).peek())
    )

    (§ defn #_"Object" pop [#_"Object" x]
        (when (ß x == nil)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).pop())
    )

    (§ defn #_"Object" get [#_"Object" coll, #_"Object" key]
        (when (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key)))
        )
        (ß getFrom(coll, key))
    )

    (§ defn #_"Object" getFrom [#_"Object" coll, #_"Object" key]
        (cond (ß coll == nil)
            (do
                (§ return nil)
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (§ return (ß m.get(key)))
                )
            )
            (ß coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" set (ß (IPersistentSet) coll)]
                    (§ return (ß set.get(key)))
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (when (ß n >= 0 && n < count(coll))
                        (§ return (ß nth(coll, n)))
                    )
                    (§ return nil)
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" set (ß (ITransientSet) coll)]
                    (§ return (ß set.get(key)))
                )
            )
        )

        nil
    )

    (§ defn #_"Object" get [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (when (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key, notFound)))
        )
        (ß getFrom(coll, key, notFound))
    )

    (§ defn #_"Object" getFrom [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (cond (ß coll == nil)
            (do
                (§ return notFound)
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (when (ß m.containsKey(key))
                        (§ return (ß m.get(key)))
                    )
                    (§ return notFound)
                )
            )
            (ß coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" set (ß (IPersistentSet) coll)]
                    (when (ß set.contains(key))
                        (§ return (ß set.get(key)))
                    )
                    (§ return notFound)
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (§ return (ß (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound))
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" set (ß (ITransientSet) coll)]
                    (when (ß set.contains(key))
                        (§ return (ß set.get(key)))
                    )
                    (§ return notFound)
                )
            )
        )
        notFound
    )

    (§ defn #_"Associative" assoc [#_"Object" coll, #_"Object" key, #_"Object" val]
        (when (ß coll == nil)
            (§ return (ß new PersistentArrayMap(new Object[] (§ key, val ))))
        )
        (ß ((Associative) coll).assoc(key, val))
    )

    (§ defn #_"Object" contains [#_"Object" coll, #_"Object" key]
        (cond (ß coll == nil)
            (do
                (§ return (ß F))
            )
            (ß coll instanceof Associative)
            (do
                (§ return (ß ((Associative) coll).containsKey(key) ? T :or F))
            )
            (ß coll instanceof IPersistentSet)
            (do
                (§ return (ß ((IPersistentSet) coll).contains(key) ? T :or F))
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (§ return (ß m.containsKey(key) ? T :or F))
                )
            )
            (ß coll instanceof Set)
            (do
                (let [#_"Set" s (ß (Set) coll)]
                    (§ return (ß s.contains(key) ? T :or F))
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (§ return (ß (n >= 0 && n < count(coll)) ? T :or F))
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (§ return (ß ((ITransientSet)coll).contains(key) ? T :or F))
            )
            (ß coll instanceof ITransientAssociative2)
            (do
                (§ return (ß (((ITransientAssociative2)coll).containsKey(key)) ? T :or F))
            )
        )
        (throw (ß new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName())))
    )

    (§ defn #_"Object" find [#_"Object" coll, #_"Object" key]
        (cond (ß coll == nil)
            (do
                (§ return nil)
            )
            (ß coll instanceof Associative)
            (do
                (§ return (ß ((Associative) coll).entryAt(key)))
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (when (ß m.containsKey(key))
                        (§ return (ß MapEntry.create(key, m.get(key))))
                    )
                    (§ return nil)
                )
            )
            (ß coll instanceof ITransientAssociative2)
            (do
                (§ return (ß ((ITransientAssociative2) coll).entryAt(key)))
            )
        )
        (throw (ß new IllegalArgumentException("find not supported on type: " + coll.getClass().getName())))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (§ defn #_"ISeq" findKey [#_"Keyword" key, #_"ISeq" keyvals]
        (while (ß keyvals != nil)
            (let [#_"ISeq" r (ß keyvals.next())]
                (when (ß r == nil)
                    (throw (ß Util.runtimeException("Malformed keyword argslist")))
                )
                (when (ß keyvals.first() == key)
                    (§ return r)
                )
                (ß keyvals = r.next())
            )
        )
        nil
    )

    (§ defn #_"Object" dissoc [#_"Object" coll, #_"Object" key]
        (when (ß coll == nil)
            (§ return nil)
        )
        (ß ((IPersistentMap) coll).without(key))
    )

    (§ defn #_"Object" nth [#_"Object" coll, #_"int" n]
        (when (ß coll instanceof Indexed)
            (§ return (ß ((Indexed) coll).nth(n)))
        )
        (ß nthFrom(Util.ret1(coll, coll = nil), n))
    )

    (§ defn #_"Object" nthFrom [#_"Object" coll, #_"int" n]
        (cond (ß coll == nil)
            (do
                nil
            )
            (ß coll instanceof CharSequence)
            (do
                (ß Character.valueOf(((CharSequence) coll).charAt(n)))
            )
            (ß coll.getClass().isArray())
            (do
                (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n)))
            )
            (ß coll instanceof RandomAccess)
            (do
                (ß ((List) coll).get(n))
            )
            (ß coll instanceof Matcher)
            (do
                (ß ((Matcher) coll).group(n))
            )
            (ß coll instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) coll)]
                    (cond (ß n == 0)
                        (do
                            (§ return (ß e.getKey()))
                        )
                        (ß n == 1)
                        (do
                            (§ return (ß e.getValue()))
                        )
                    )
                    (throw (ß new IndexOutOfBoundsException()))
                )
            )
            (ß coll instanceof Sequential)
            (do
                (let [#_"ISeq" seq (ß RT.seq(coll))]
                    (ß coll = nil)
                    (loop-when-recur [(ß int i = 0)] (ß i <= n && seq != nil) [(ß ++i, seq = seq.next())]
                        (when (ß i == n)
                            (§ return (ß seq.first()))
                        )
                    )
                    (throw (ß new IndexOutOfBoundsException()))
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn #_"Object" nth [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (when (ß coll instanceof Indexed)
            (let [#_"Indexed" v (ß (Indexed) coll)]
                (§ return (ß v.nth(n, notFound)))
            )
        )
        (ß nthFrom(coll, n, notFound))
    )

    (§ defn #_"Object" nthFrom [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (cond (ß coll == nil)
            (do
                notFound
            )
            (ß n < 0)
            (do
                notFound
            )
            (ß coll instanceof CharSequence)
            (do
                (let [#_"CharSequence" s (ß (CharSequence) coll)]
                    (when (ß n < s.length())
                        (§ return (ß Character.valueOf(s.charAt(n))))
                    )
                    notFound
                )
            )
            (ß coll.getClass().isArray())
            (do
                (when (ß n < Array.getLength(coll))
                    (§ return (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
                )
                notFound
            )
            (ß coll instanceof RandomAccess)
            (do
                (let [#_"List" list (ß (List) coll)]
                    (when (ß n < list.size())
                        (§ return (ß list.get(n)))
                    )
                    notFound
                )
            )
            (ß coll instanceof Matcher)
            (do
                (let [#_"Matcher" m (ß (Matcher) coll)]
                    (when (ß n < m.groupCount())
                        (§ return (ß m.group(n)))
                    )
                    notFound
                )
            )
            (ß coll instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) coll)]
                    (cond (ß n == 0)
                        (do
                            (§ return (ß e.getKey()))
                        )
                        (ß n == 1)
                        (do
                            (§ return (ß e.getValue()))
                        )
                    )
                    notFound
                )
            )
            (ß coll instanceof Sequential)
            (do
                (let [#_"ISeq" seq (ß RT.seq(coll))]
                    (ß coll = nil)
                    (loop-when-recur [(ß int i = 0)] (ß i <= n && seq != nil) [(ß ++i, seq = seq.next())]
                        (when (ß i == n)
                            (§ return (ß seq.first()))
                        )
                    )
                    notFound
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn #_"Object" assocN [#_"int" n, #_"Object" val, #_"Object" coll]
        (cond (ß coll == nil)
            (do
                nil
            )
            (ß coll instanceof IPersistentVector)
            (do
                (ß ((IPersistentVector) coll).assocN(n, val))
            )
            (ß coll instanceof Object[])
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" array (ß ((Object[]) coll))]
                    (ß array[n] = val)
                    array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (§ defn #_"boolean" hasTag [#_"Object" o, #_"Object" tag]
        (ß Util.equals(tag, RT.get(RT.meta(o), TAG_KEY)))
    )

    (§ defn #_"Object" box [#_"Object" x]
        x
    )

    (§ defn #_"Character" box [#_"char" x]
        (ß Character.valueOf(x))
    )

    (§ defn #_"Object" box [#_"boolean" x]
        (ß x ? T :or F)
    )

    (§ defn #_"Object" box [#_"Boolean" x]
        x
    )

    (§ defn #_"Number" box [#_"byte" x]
        x
    )

    (§ defn #_"Number" box [#_"short" x]
        x
    )

    (§ defn #_"Number" box [#_"int" x]
        x
    )

    (§ defn #_"Number" box [#_"long" x]
        x
    )

    (§ defn #_"Number" box [#_"float" x]
        x
    )

    (§ defn #_"Number" box [#_"double" x]
        x
    )

    (§ defn #_"char" charCast [#_"Object" x]
        (when (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (let [#_"long" n (ß ((Number) x).longValue())]
            (when (ß n < Character.MIN_VALUE || n > Character.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            (ß (char) n)
        )
    )

    (§ defn #_"char" charCast [#_"byte" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"short" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"char" x]
        x
    )

    (§ defn #_"char" charCast [#_"int" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"long" x]
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn #_"char" charCast [#_"float" x]
        (when (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
    )

    (§ defn #_"char" charCast [#_"double" x]
        (when (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
    )

    (§ defn #_"boolean" booleanCast [#_"Object" x]
        (when (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x).booleanValue()))
        )
        (ß (x != nil))
    )

    (§ defn #_"boolean" booleanCast [#_"boolean" x]
        x
    )

    (§ defn #_"byte" byteCast [#_"Object" x]
        (when (ß x instanceof Byte)
            (§ return (ß ((Byte) x).byteValue()))
        )
        (let [#_"long" n (ß longCast(x))]
            (when (ß n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            (ß (byte) n)
        )
    )

    (§ defn #_"byte" byteCast [#_"byte" x]
        x
    )

    (§ defn #_"byte" byteCast [#_"short" x]
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn #_"byte" byteCast [#_"int" x]
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn #_"byte" byteCast [#_"long" x]
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn #_"byte" byteCast [#_"float" x]
        (when (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
    )

    (§ defn #_"byte" byteCast [#_"double" x]
        (when (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
    )

    (§ defn #_"short" shortCast [#_"Object" x]
        (when (ß x instanceof Short)
            (§ return (ß ((Short) x).shortValue()))
        )
        (let [#_"long" n (ß longCast(x))]
            (when (ß n < Short.MIN_VALUE || n > Short.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
            )
            (ß (short) n)
        )
    )

    (§ defn #_"short" shortCast [#_"byte" x]
        x
    )

    (§ defn #_"short" shortCast [#_"short" x]
        x
    )

    (§ defn #_"short" shortCast [#_"int" x]
        (let [#_"short" i (ß (short) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
            )
            i
        )
    )

    (§ defn #_"short" shortCast [#_"long" x]
        (let [#_"short" i (ß (short) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
            )
            i
        )
    )

    (§ defn #_"short" shortCast [#_"float" x]
        (when (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
    )

    (§ defn #_"short" shortCast [#_"double" x]
        (when (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
    )

    (§ defn #_"int" intCast [#_"Object" x]
        (when (ß x instanceof Integer)
            (§ return (ß ((Integer)x).intValue()))
        )
        (when (ß x instanceof Number)
            (let [#_"long" n (ß longCast(x))]
                (§ return (ß intCast(n)))
            )
        )
        (ß ((Character) x).charValue())
    )

    (§ defn #_"int" intCast [#_"char" x]
        x
    )

    (§ defn #_"int" intCast [#_"byte" x]
        x
    )

    (§ defn #_"int" intCast [#_"short" x]
        x
    )

    (§ defn #_"int" intCast [#_"int" x]
        x
    )

    (§ defn #_"int" intCast [#_"float" x]
        (when (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for int: " + x)))
        )
        (ß (int) x)
    )

    (§ defn #_"int" intCast [#_"long" x]
        (let [#_"int" i (ß (int) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for int: " + x)))
            )
            i
        )
    )

    (§ defn #_"int" intCast [#_"double" x]
        (when (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for int: " + x)))
        )
        (ß (int) x)
    )

    (§ defn #_"long" longCast [#_"Object" x]
        (cond (ß x instanceof Integer || x instanceof Long)
            (do
                (ß ((Number) x).longValue())
            )
            (ß x instanceof BigInt)
            (do
                (let [#_"BigInt" bi (ß (BigInt) x)]
                    (if (ß bi.bipart == nil)
                        (do
                            (ß bi.lpart)
                        )
                        (do
                            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
                        )
                    )
                )
            )
            (ß x instanceof BigInteger)
            (do
                (let [#_"BigInteger" bi (ß (BigInteger) x)]
                    (if (ß bi.bitLength() < 64)
                        (do
                            (ß bi.longValue())
                        )
                        (do
                            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
                        )
                    )
                )
            )
            (ß x instanceof Byte || x instanceof Short)
            (do
                (ß ((Number) x).longValue())
            )
            (ß x instanceof Ratio)
            (do
                (ß longCast(((Ratio)x).bigIntegerValue()))
            )
            (ß x instanceof Character)
            (do
                (ß longCast(((Character) x).charValue()))
            )
            :else
            (do
                (ß longCast(((Number)x).doubleValue()))
            )
        )
    )

    (§ defn #_"long" longCast [#_"byte" x]
        x
    )

    (§ defn #_"long" longCast [#_"short" x]
        x
    )

    (§ defn #_"long" longCast [#_"int" x]
        x
    )

    (§ defn #_"long" longCast [#_"float" x]
        (when (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
        )
        (ß (long) x)
    )

    (§ defn #_"long" longCast [#_"long" x]
        x
    )

    (§ defn #_"long" longCast [#_"double" x]
        (when (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
        )
        (ß (long) x)
    )

    (§ defn #_"float" floatCast [#_"Object" x]
        (when (ß x instanceof Float)
            (§ return (ß ((Float) x).floatValue()))
        )
        (let [#_"double" n (ß ((Number) x).doubleValue())]
            (when (ß n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for float: " + x)))
            )
            (ß (float) n)
        )
    )

    (§ defn #_"float" floatCast [#_"byte" x]
        x
    )

    (§ defn #_"float" floatCast [#_"short" x]
        x
    )

    (§ defn #_"float" floatCast [#_"int" x]
        x
    )

    (§ defn #_"float" floatCast [#_"float" x]
        x
    )

    (§ defn #_"float" floatCast [#_"long" x]
        x
    )

    (§ defn #_"float" floatCast [#_"double" x]
        (when (ß x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for float: " + x)))
        )
        (ß (float) x)
    )

    (§ defn #_"double" doubleCast [#_"Object" x]
        (ß ((Number) x).doubleValue())
    )

    (§ defn #_"double" doubleCast [#_"byte" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"short" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"int" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"float" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"long" x]
        x
    )

    (§ defn #_"double" doubleCast [#_"double" x]
        x
    )

    (§ defn #_"byte" uncheckedByteCast [#_"Object" x]
        (ß ((Number) x).byteValue())
    )

    (§ defn #_"byte" uncheckedByteCast [#_"byte" x]
        x
    )

    (§ defn #_"byte" uncheckedByteCast [#_"short" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"int" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"long" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"float" x]
        (ß (byte) x)
    )

    (§ defn #_"byte" uncheckedByteCast [#_"double" x]
        (ß (byte) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"Object" x]
        (ß ((Number) x).shortValue())
    )

    (§ defn #_"short" uncheckedShortCast [#_"byte" x]
        x
    )

    (§ defn #_"short" uncheckedShortCast [#_"short" x]
        x
    )

    (§ defn #_"short" uncheckedShortCast [#_"int" x]
        (ß (short) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"long" x]
        (ß (short) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"float" x]
        (ß (short) x)
    )

    (§ defn #_"short" uncheckedShortCast [#_"double" x]
        (ß (short) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"Object" x]
        (when (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (ß (char) ((Number) x).longValue())
    )

    (§ defn #_"char" uncheckedCharCast [#_"byte" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"short" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"char" x]
        x
    )

    (§ defn #_"char" uncheckedCharCast [#_"int" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"long" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"float" x]
        (ß (char) x)
    )

    (§ defn #_"char" uncheckedCharCast [#_"double" x]
        (ß (char) x)
    )

    (§ defn #_"int" uncheckedIntCast [#_"Object" x]
        (when (ß x instanceof Number)
            (§ return (ß ((Number)x).intValue()))
        )
        (ß ((Character) x).charValue())
    )

    (§ defn #_"int" uncheckedIntCast [#_"byte" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"short" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"char" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"int" x]
        x
    )

    (§ defn #_"int" uncheckedIntCast [#_"long" x]
        (ß (int) x)
    )

    (§ defn #_"int" uncheckedIntCast [#_"float" x]
        (ß (int) x)
    )

    (§ defn #_"int" uncheckedIntCast [#_"double" x]
        (ß (int) x)
    )

    (§ defn #_"long" uncheckedLongCast [#_"Object" x]
        (ß ((Number) x).longValue())
    )

    (§ defn #_"long" uncheckedLongCast [#_"byte" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"short" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"int" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"long" x]
        x
    )

    (§ defn #_"long" uncheckedLongCast [#_"float" x]
        (ß (long) x)
    )

    (§ defn #_"long" uncheckedLongCast [#_"double" x]
        (ß (long) x)
    )

    (§ defn #_"float" uncheckedFloatCast [#_"Object" x]
        (ß ((Number) x).floatValue())
    )

    (§ defn #_"float" uncheckedFloatCast [#_"byte" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"short" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"int" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"long" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"float" x]
        x
    )

    (§ defn #_"float" uncheckedFloatCast [#_"double" x]
        (ß (float) x)
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"Object" x]
        (ß ((Number) x).doubleValue())
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"byte" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"short" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"int" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"long" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"float" x]
        x
    )

    (§ defn #_"double" uncheckedDoubleCast [#_"double" x]
        x
    )

    (§ defn #_"IPersistentMap" map [#_"Object..." init]
        (cond (ß init == nil)
            (do
                (§ return (ß PersistentArrayMap.EMPTY))
            )
            (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (do
                (§ return (ß PersistentArrayMap.createWithCheck(init)))
            )
        )
        (ß PersistentHashMap.createWithCheck(init))
    )

    (§ defn #_"IPersistentMap" mapUniqueKeys [#_"Object..." init]
        (cond (ß init == nil)
            (do
                (§ return (ß PersistentArrayMap.EMPTY))
            )
            (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (do
                (§ return (ß new PersistentArrayMap(init)))
            )
        )
        (ß PersistentHashMap.create(init))
    )

    (§ defn #_"IPersistentSet" set [#_"Object..." init]
        (ß PersistentHashSet.createWithCheck(init))
    )

    (§ defn #_"IPersistentVector" vector [#_"Object..." init]
        (ß LazilyPersistentVector.createOwning(init))
    )

    (§ defn #_"IPersistentVector" subvec [#_"IPersistentVector" v, #_"int" start, #_"int" end]
        (when (ß end < start || start < 0 || end > v.count())
            (throw (ß new IndexOutOfBoundsException()))
        )
        (when (ß start == end)
            (§ return (ß PersistentVector.EMPTY))
        )
        (ß new APersistentVector.SubVector(nil, v, start, end))
    )

    (§ defn #_"ISeq" list []
        nil
    )

    (§ defn #_"ISeq" list [#_"Object" arg1]
        (ß new PersistentList(arg1))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2]
        (ß listStar(arg1, arg2, nil))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß listStar(arg1, arg2, arg3, nil))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß listStar(arg1, arg2, arg3, arg4, nil))
    )

    (§ defn #_"ISeq" list [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß listStar(arg1, arg2, arg3, arg4, arg5, nil))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, rest))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, rest)))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, rest))))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest)))))
    )

    (§ defn #_"ISeq" listStar [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"ISeq" rest]
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest))))))
    )

    (§ defn #_"ISeq" arrayToList [#_"Object[]" a]
        (let [#_"ISeq" ret nil]
            (loop-when-recur [(ß int i = a.length - 1)] (ß i >= 0) [(ß --i)]
                (ß ret = (ISeq) cons(a[i], ret))
            )
            ret
        )
    )

    (§ defn #_"Object[]" object_array [#_"Object" sizeOrSeq]
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new Object[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"Object[]" ret (ß new Object[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = s.first())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Object[]" toArray [#_"Object" coll]
        (cond (ß coll == nil)
            (do
                (ß EMPTY_ARRAY)
            )
            (ß coll instanceof Object[])
            (do
                (ß (Object[]) coll)
            )
            (ß coll instanceof Collection)
            (do
                (ß ((Collection) coll).toArray())
            )
            (ß coll instanceof Iterable)
            (do
                (let [#_"ArrayList" ret (ß new ArrayList())]
                    (doseq [#_"Object" o (ß (Iterable)coll)]
                        (ß ret.add(o))
                    )
                    (ß ret.toArray())
                )
            )
            (ß coll instanceof Map)
            (do
                (ß ((Map) coll).entrySet().toArray())
            )
            (ß coll instanceof String)
            (do
                (let [#_"char[]" chars (ß ((String) coll).toCharArray())]
                    (let [#_"Object[]" ret (ß new Object[chars.length])]
                        (loop-when-recur [(ß int i = 0)] (ß i < chars.length) [(ß i++)]
                            (ß ret[i] = chars[i])
                        )
                        ret
                    )
                )
            )
            (ß coll.getClass().isArray())
            (do
                (let [#_"ISeq" s (ß (seq(coll)))]
                    (let [#_"Object[]" ret (ß new Object[count(s)])]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++, s = s.next())]
                            (ß ret[i] = s.first())
                        )
                        ret
                    )
                )
            )
            :else
            (do
                (throw (ß Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]")))
            )
        )
    )

    (§ defn #_"Object[]" seqToArray [#_"ISeq" seq]
        (let [#_"int" len (ß length(seq))]
            (let [#_"Object[]" ret (ß new Object[len])]
                (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                    (ß ret[i] = seq.first())
                )
                ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (§ defn #_"Object[]" seqToPassedArray [#_"ISeq" seq, #_"Object[]" passed]
        (let [#_"Object[]" dest passed]
            (let [#_"int" len (ß count(seq))]
                (when (ß len > dest.length)
                    (ß dest = (Object[]) Array.newInstance(passed.getClass().getComponentType(), len))
                )
                (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                    (ß dest[i] = seq.first())
                )
                (when (ß len < passed.length)
                    (ß dest[len] = nil)
                )
                dest
            )
        )
    )

    (§ defn #_"Object" seqToTypedArray [#_"ISeq" seq]
        (let [#_"Class" type (ß (seq != nil && seq.first() != nil) ? seq.first().getClass() :or Object.class)]
            (ß seqToTypedArray(type, seq))
        )
    )

    (§ defn #_"Object" seqToTypedArray [#_"Class" type, #_"ISeq" seq]
        (let [#_"Object" ret (ß Array.newInstance(type, length(seq)))]
            (cond (ß type == Integer.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, intCast(seq.first())))
                    )
                )
                (ß type == Byte.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, byteCast(seq.first())))
                    )
                )
                (ß type == Float.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, floatCast(seq.first())))
                    )
                )
                (ß type == Short.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, shortCast(seq.first())))
                    )
                )
                (ß type == Character.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, charCast(seq.first())))
                    )
                )
                :else
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, seq.first()))
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"int" length [#_"ISeq" list]
        (let [#_"int" i 0]
            (loop-when-recur [(ß ISeq c = list)] (ß c != nil) [(ß c = c.next())]
                (ß i++)
            )
            i
        )
    )

    (§ defn #_"int" boundedLength [#_"ISeq" list, #_"int" limit]
        (let [#_"int" i 0]
            (loop-when-recur [(ß ISeq c = list)] (ß c != nil && i <= limit) [(ß c = c.next())]
                (ß i++)
            )
            i
        )
    )

    (§ defn #_"Character" readRet [#_"int" ret]
        (when (ß ret == -1)
            (§ return nil)
        )
        (ß box((char) ret))
    )

    (§ defn #_"Character" readChar [#_"Reader" r] (§ throws IOException)
        (let [#_"int" ret (ß r.read())]
            (ß readRet(ret))
        )
    )

    (§ defn #_"Character" peekChar [#_"Reader" r] (§ throws IOException)
        (§ let [#_"int" ret]
            (if (ß r instanceof PushbackReader)
                (do
                    (ß ret = r.read())
                    (ß ((PushbackReader) r).unread(ret))
                )
                (do
                    (ß r.mark(1))
                    (ß ret = r.read())
                    (ß r.reset())
                )
            )

            (ß readRet(ret))
        )
    )

    (§ defn #_"int" getLineNumber [#_"Reader" r]
        (when (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getLineNumber()))
        )
        0
    )

    (§ defn #_"int" getColumnNumber [#_"Reader" r]
        (when (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getColumnNumber()))
        )
        0
    )

    (§ defn #_"LineNumberingPushbackReader" getLineNumberingReader [#_"Reader" r]
        (when (ß isLineNumberingReader(r))
            (§ return (ß (LineNumberingPushbackReader) r))
        )
        (ß new LineNumberingPushbackReader(r))
    )

    (§ defn #_"boolean" isLineNumberingReader [#_"Reader" r]
        (ß (r instanceof LineNumberingPushbackReader))
    )

    (§ defn #_"boolean" isReduced [#_"Object" r]
        (ß (r instanceof Reduced))
    )

    (§ defn #_"String" resolveClassNameInContext [#_"String" className]
        ;; todo - look up in context var
        className
    )

    (§ defn #_"boolean" suppressRead []
        (ß booleanCast(SUPPRESS_READ.deref()))
    )

    (§ defn #_"String" printString [#_"Object" x]
        (try
            (let [#_"StringWriter" sw (ß new StringWriter())]
                (ß print(x, sw))
                (ß sw.toString())
            )
            (catch Exception e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ defn #_"Object" readString [#_"String" s]
        (ß readString(s, nil))
    )

    (§ defn #_"Object" readString [#_"String" s, #_"Object" opts]
        (let [#_"PushbackReader" r (ß new PushbackReader(new StringReader(s)))]
            (ß LispReader.read(r, opts))
        )
    )

    (§ defn #_"void" print [#_"Object" x, #_"Writer" w] (§ throws IOException)
        ;; call multimethod
        (if (ß PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref()))
            (do
                (ß PR_ON.invoke(x, w))
            )
            (do
                (let [#_"boolean" readably (ß booleanCast(PRINT_READABLY.deref()))]
                    (when (ß x instanceof Obj)
                        (let [#_"Obj" o (ß (Obj) x)]
                            (when (ß RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                                (let [#_"IPersistentMap" meta (ß o.meta())]
                                    (ß w.write("#^"))
                                    (if (ß meta.count() == 1 && meta.containsKey(TAG_KEY))
                                        (do
                                            (ß print(meta.valAt(TAG_KEY), w))
                                        )
                                        (do
                                            (ß print(meta, w))
                                        )
                                    )
                                    (ß w.write(\space))
                                )
                            )
                        )
                    )
                    (cond (ß x == nil)
                        (do
                            (ß w.write("nil"))
                        )
                        (ß x instanceof ISeq || x instanceof IPersistentList)
                        (do
                            (ß w.write(\())
                            (ß printInnerSeq(seq(x), w))
                            (ß w.write(\)))
                        )
                        (ß x instanceof String)
                        (do
                            (let [#_"String" s (ß (String) x)]
                                (if (ß !readably)
                                    (do
                                        (ß w.write(s))
                                    )
                                    (do
                                        (ß w.write(\")) ;; oops! "
                                        (loop-when-recur [(ß int i = 0)] (ß i < s.length()) [(ß i++)]
                                            (let [#_"char" c (ß s.charAt(i))]
                                                (§ switch c
                                                    (§ case \newline)
                                                    (do
                                                        (ß w.write("\\n"))
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (ß w.write("\\t"))
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (ß w.write("\\r"))
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (ß w.write("\\\\"))
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (ß w.write("\\f"))
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (ß w.write("\\b"))
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (ß w.write(c))
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (ß x instanceof IPersistentMap)
                        (do
                            (ß w.write(\{))
                            (loop-when-recur [(ß ISeq s = seq(x))] (ß s != nil) [(ß s = s.next())]
                                (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                                    (ß print(e.key(), w))
                                    (ß w.write(\space))
                                    (ß print(e.val(), w))
                                    (when (ß s.next() != nil)
                                        (ß w.write(", "))
                                    )
                                )
                            )
                            (ß w.write(\}))
                        )
                        (ß x instanceof IPersistentVector)
                        (do
                            (let [#_"IPersistentVector" a (ß (IPersistentVector) x)]
                                (ß w.write(\[))
                                (loop-when-recur [(ß int i = 0)] (ß i < a.count()) [(ß i++)]
                                    (ß print(a.nth(i), w))
                                    (when (ß i < a.count() - 1)
                                        (ß w.write(\space))
                                    )
                                )
                                (ß w.write(\]))
                            )
                        )
                        (ß x instanceof IPersistentSet)
                        (do
                            (ß w.write("#{"))
                            (loop-when-recur [(ß ISeq s = seq(x))] (ß s != nil) [(ß s = s.next())]
                                (ß print(s.first(), w))
                                (when (ß s.next() != nil)
                                    (ß w.write(" "))
                                )
                            )
                            (ß w.write(\}))
                        )
                        (ß x instanceof Character)
                        (do
                            (let [#_"char" c (ß ((Character) x).charValue())]
                                (if (ß !readably)
                                    (do
                                        (ß w.write(c))
                                    )
                                    (do
                                        (ß w.write(\\))
                                        (§ switch c
                                            (§ case \newline)
                                            (do
                                                (ß w.write("newline"))
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (ß w.write("tab"))
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (ß w.write("space"))
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (ß w.write("backspace"))
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (ß w.write("formfeed"))
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (ß w.write("return"))
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (ß w.write(c))
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß x instanceof Class)
                        (do
                            (ß w.write("#="))
                            (ß w.write(((Class) x).getName()))
                        )
                        (ß x instanceof BigDecimal && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write(\M))
                        )
                        (ß x instanceof BigInt && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write(\N))
                        )
                        (ß x instanceof BigInteger && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write("BIGINT"))
                        )
                        (ß x instanceof Var)
                        (do
                            (let [#_"Var" v (ß (Var) x)]
                                (ß w.write("#=(var " + v.ns.name + "/" + v.sym + ")"))
                            )
                        )
                        (ß x instanceof Pattern)
                        (do
                            (let [#_"Pattern" p (ß (Pattern) x)]
                                (ß w.write("#\"" + p.pattern() + "\""))
                            )
                        )
                        :else
                        (do
                            (ß w.write(x.toString()))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" printInnerSeq [#_"ISeq" x, #_"Writer" w] (§ throws IOException)
        (loop-when-recur [(ß ISeq s = x)] (ß s != nil) [(ß s = s.next())]
            (ß print(s.first(), w))
            (when (ß s.next() != nil)
                (ß w.write(\space))
            )
        )
        nil
    )

    (§ defn #_"void" formatAesthetic [#_"Writer" w, #_"Object" obj] (§ throws IOException)
        (if (ß obj == nil)
            (do
                (ß w.write("nil"))
            )
            (do
                (ß w.write(obj.toString()))
            )
        )
        nil
    )

    (§ defn #_"void" formatStandard [#_"Writer" w, #_"Object" obj] (§ throws IOException)
        (cond (ß obj == nil)
            (do
                (ß w.write("nil"))
            )
            (ß obj instanceof String)
            (do
                (ß w.write(\")) ;; oops! "
                (ß w.write((String) obj))
                (ß w.write(\")) ;; oops! "
            )
            (ß obj instanceof Character)
            (do
                (ß w.write(\\))
                (let [#_"char" c (ß ((Character) obj).charValue())]
                    (§ switch c
                        (§ case \newline)
                        (do
                            (ß w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (ß w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (ß w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (ß w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (ß w.write("formfeed"))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (ß w.write(c))
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (ß w.write(obj.toString()))
            )
        )
        nil
    )

    (§ defn #_"Object" format [#_"Object" o, #_"String" s, #_"Object..." args] (§ throws IOException)
        (§ let [#_"Writer" w]
            (cond (ß o == nil)
                (do
                    (ß w = new StringWriter())
                )
                (ß Util.equals(o, T))
                (do
                    (ß w = (Writer) OUT.deref())
                )
                :else
                (do
                    (ß w = (Writer) o)
                )
            )
            (ß doFormat(w, s, ArraySeq.create(args)))
            (when (ß o == nil)
                (§ return (ß w.toString()))
            )
            nil
        )
    )

    (§ defn #_"ISeq" doFormat [#_"Writer" w, #_"String" s, #_"ISeq" args] (§ throws IOException)
        (loop-when-recur [(ß int i = 0)] (ß i < s.length()) [(ß )]
            (let [#_"char" c (ß s.charAt(i++))]
                (§ switch (ß Character.toLowerCase(c))
                    (§ case \~)
                    (do
                        (let [#_"char" d (ß s.charAt(i++))]
                            (§ switch (ß Character.toLowerCase(d))
                                (§ case \%)
                                (do
                                    (ß w.write(\newline))
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (ß w.write(\tab))
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (ß args == nil)
                                        (throw (ß new IllegalArgumentException("Missing argument")))
                                    )
                                    (ß RT.formatAesthetic(w, RT.first(args)))
                                    (ß args = RT.next(args))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (ß args == nil)
                                        (throw (ß new IllegalArgumentException("Missing argument")))
                                    )
                                    (ß RT.formatStandard(w, RT.first(args)))
                                    (ß args = RT.next(args))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" j (ß s.indexOf("~}", i))] ;; note - does not nest
                                        (when (ß j == -1)
                                            (throw (ß new IllegalArgumentException("Missing ~}")))
                                        )
                                        (let [#_"String" subs (ß s.substring(i, j))]
                                            (loop-when-recur [(ß ISeq sargs = RT.seq(RT.first(args)))] (ß sargs != nil) [(ß )]
                                                (ß sargs = doFormat(w, subs, sargs))
                                            )
                                            (ß args = RT.next(args))
                                            (ß i = j + 2) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (ß args == nil)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (ß new IllegalArgumentException("Unsupported ~ directive: " + d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (ß w.write(c))
                        (§ break )
                    )
                )
            )
        )
        args
    )

    (§ defn #_"Object[]" setValues [#_"Object..." vals]
        (when (ß vals.length > 0)
            (§ return vals)
        )
        nil
    )

    (§ defn #_"ClassLoader" makeClassLoader []
        (ß (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
            (§ reify
                #_method
                (§ defn #_"Object" run [this]
                    (try
                        (ß Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T)))
                        (ß new DynamicClassLoader(baseLoader()))
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                )
            ))
        )
    )

    (§ defn #_"ClassLoader" baseLoader []
        (cond (ß Compiler.LOADER.isBound())
            (do
                (§ return (ß (ClassLoader) Compiler.LOADER.deref()))
            )
            (ß booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread.currentThread().getContextClassLoader()))
            )
        )
        (ß Compiler.class.getClassLoader())
    )

    (§ defn #_"InputStream" resourceAsStream [#_"ClassLoader" loader, #_"String" name]
        (if (ß loader == nil)
            (do
                (ß ClassLoader.getSystemResourceAsStream(name))
            )
            (do
                (ß loader.getResourceAsStream(name))
            )
        )
    )

    (§ defn #_"URL" getResource [#_"ClassLoader" loader, #_"String" name]
        (if (ß loader == nil)
            (do
                (ß ClassLoader.getSystemResource(name))
            )
            (do
                (ß loader.getResource(name))
            )
        )
    )

    (§ defn #_"Class" classForName [#_"String" name, #_"boolean" load, #_"ClassLoader" loader]
        (try
            (let [#_"Class" c nil]
                (when (ß !(loader instanceof DynamicClassLoader))
                    (ß c = DynamicClassLoader.findInMemoryClass(name))
                )
                (when (ß c != nil)
                    (§ return c)
                )
                (ß Class.forName(name, load, loader))
            )
            (catch ClassNotFoundException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ defn #_"Class" classForName [#_"String" name]
        (ß classForName(name, true, baseLoader()))
    )

    (§ defn #_"Class" classForNameNonLoading [#_"String" name]
        (ß classForName(name, false, baseLoader()))
    )

    (§ defn #_"Class" loadClassForName [#_"String" name]
        (try
            (ß classForNameNonLoading(name))
            (catch Exception e
                (if (ß e instanceof ClassNotFoundException)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
            )
        )
        (ß classForName(name))
    )

    (§ defn #_"float" aget [#_"float[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"float" aset [#_"float[]" xs, #_"int" i, #_"float" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"float[]" xs]
        (ß xs.length)
    )

    (§ defn #_"float[]" aclone [#_"float[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"double" aget [#_"double[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"double" aset [#_"double[]" xs, #_"int" i, #_"double" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"double[]" xs]
        (ß xs.length)
    )

    (§ defn #_"double[]" aclone [#_"double[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"int" aget [#_"int[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"int" aset [#_"int[]" xs, #_"int" i, #_"int" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"int[]" xs]
        (ß xs.length)
    )

    (§ defn #_"int[]" aclone [#_"int[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"long" aget [#_"long[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"long" aset [#_"long[]" xs, #_"int" i, #_"long" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"long[]" xs]
        (ß xs.length)
    )

    (§ defn #_"long[]" aclone [#_"long[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"char" aget [#_"char[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"char" aset [#_"char[]" xs, #_"int" i, #_"char" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"char[]" xs]
        (ß xs.length)
    )

    (§ defn #_"char[]" aclone [#_"char[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"byte" aget [#_"byte[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"byte" aset [#_"byte[]" xs, #_"int" i, #_"byte" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"byte[]" xs]
        (ß xs.length)
    )

    (§ defn #_"byte[]" aclone [#_"byte[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"short" aget [#_"short[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"short" aset [#_"short[]" xs, #_"int" i, #_"short" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"short[]" xs]
        (ß xs.length)
    )

    (§ defn #_"short[]" aclone [#_"short[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"boolean" aget [#_"boolean[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"boolean" aset [#_"boolean[]" xs, #_"int" i, #_"boolean" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"boolean[]" xs]
        (ß xs.length)
    )

    (§ defn #_"boolean[]" aclone [#_"boolean[]" xs]
        (ß xs.clone())
    )

    (§ defn #_"Object" aget [#_"Object[]" xs, #_"int" i]
        (ß xs[i])
    )

    (§ defn #_"Object" aset [#_"Object[]" xs, #_"int" i, #_"Object" v]
        (ß xs[i] = v)
        v
    )

    (§ defn #_"int" alength [#_"Object[]" xs]
        (ß xs.length)
    )

    (§ defn #_"Object[]" aclone [#_"Object[]" xs]
        (ß xs.clone())
    )
)
)

(java-ns cloiure.lang.Seqable

(§ interface Seqable
    (§ abstract ISeq seq())
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (§ field #_"ISeq" seq)

    (§ constructor #_"SeqEnumeration" SeqEnumeration [#_"ISeq" seq]
        (ß this.seq = seq)
        this
    )

    #_method
    (§ defn #_"boolean" hasMoreElements [this]
        (ß (seq != nil))
    )

    #_method
    (§ defn #_"Object" nextElement [this]
        (let [#_"Object" ret (ß RT.first(seq))]
            (ß seq = RT.next(seq))
            ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (§ def #_"Object" START (ß new Object()))

    (§ field #_"Object" seq)
    (§ field #_"Object" next)

    (§ constructor #_"SeqIterator" SeqIterator [#_"Object" o]
        (ß seq = START)
        (ß next = o)
        this
    )

    ;; preserved for binary compatibility
    (§ constructor #_"SeqIterator" SeqIterator [#_"ISeq" o]
        (ß seq = START)
        (ß next = o)
        this
    )

    #_method
    (§ defn #_"boolean" hasNext [this]
        (cond (ß seq == START)
            (do
                (ß seq = nil)
                (ß next = RT.seq(next))
            )
            (ß seq == next)
            (do
                (ß next = RT.next(seq))
            )
        )
        (ß (next != nil))
    )

    #_method
    (§ defn #_"Object" next [this] (§ throws NoSuchElementException)
        (when (ß !hasNext())
            (throw (ß new NoSuchElementException()))
        )
        (ß seq = next)
        (ß RT.first(next))
    )

    #_method
    (§ defn #_"void" remove [this]
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.Sequential

(§ interface Sequential
)
)

(java-ns cloiure.lang.Settable

(§ interface Settable
    (§ abstract Object doSet(Object val))
    (§ abstract Object doReset(Object val))
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ interface Sorted
    (§ abstract Comparator comparator())
    (§ abstract Object entryKey(Object entry))
    (§ abstract ISeq seq(boolean ascending))
    (§ abstract ISeq seqFrom(Object key, boolean ascending))
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (§ field #_"CharSequence" s)
    (§ field #_"int" i)

    (§ defn #_"StringSeq" create [#_"CharSequence" s]
        (when (ß s.length() == 0)
            (§ return nil)
        )
        (ß new StringSeq(nil, s, 0))
    )

    (§ constructor #_"StringSeq" StringSeq [#_"IPersistentMap" meta, #_"CharSequence" s, #_"int" i]
        (§ super(meta))
        (ß this.s = s)
        (ß this.i = i)
        this
    )

    #_method
    (§ defn #_"Obj" withMeta [this, #_"IPersistentMap" meta]
        (when (ß meta == meta())
            (§ return this)
        )
        (ß new StringSeq(meta, s, i))
    )

    #_method
    (§ defn #_"Object" first [this]
        (ß Character.valueOf(s.charAt(i)))
    )

    #_method
    (§ defn #_"ISeq" next [this]
        (when (ß i + 1 < s.length())
            (§ return (ß new StringSeq(_meta, s, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [this]
        i
    )

    #_method
    (§ defn #_"int" count [this]
        (ß s.length() - i)
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    (§ field #_"String" ns)
    (§ field #_"String" name)
    (§ field- #_"int" _hasheq)
    (§ field #_"IPersistentMap" _meta)
    #_transient
    (§ field #_"String" _str)

    #_method
    (§ defn #_"String" toString [this]
        (when (ß _str == nil)
            (if (ß ns != nil)
                (do
                    (ß _str = (ns + "/" + name))
                )
                (do
                    (ß _str = name)
                )
            )
        )
        (ß _str)
    )

    #_method
    (§ defn #_"String" getNamespace [this]
        ns
    )

    #_method
    (§ defn #_"String" getName [this]
        name
    )

    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (§ defn #_"Symbol" create [#_"String" ns, #_"String" name]
        (ß Symbol.intern(ns, name))
    )

    (§ defn #_"Symbol" create [#_"String" nsname]
        (ß Symbol.intern(nsname))
    )

    (§ defn #_"Symbol" intern [#_"String" ns, #_"String" name]
        (ß new Symbol(ns, name))
    )

    (§ defn #_"Symbol" intern [#_"String" nsname]
        (let [#_"int" i (ß nsname.indexOf(\/))]
            (if (ß i == -1 || nsname.equals("/"))
                (do
                    (ß new Symbol(nil, nsname))
                )
                (do
                    (ß new Symbol(nsname.substring(0, i), nsname.substring(i + 1)))
                )
            )
        )
    )

    (§ constructor- #_"Symbol" Symbol [#_"String" ns_interned, #_"String" name_interned]
        (ß this.name = name_interned)
        (ß this.ns = ns_interned)
        (ß this._meta = nil)
        this
    )

    #_method
    (§ defn #_"boolean" equals [this, #_"Object" o]
        (when (ß this == o)
            (§ return true)
        )
        (when (ß !(o instanceof Symbol))
            (§ return false)
        )

        (let [#_"Symbol" symbol (ß (Symbol) o)]
            (ß Util.equals(ns, symbol.ns) && name.equals(symbol.name))
        )
    )

    #_method
    (§ defn #_"int" hashCode [this]
        (ß Util.hashCombine(name.hashCode(), Util.hash(ns)))
    )

    #_method
    (§ defn #_"int" hasheq [this]
        (when (ß _hasheq == 0)
            (ß _hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns)))
        )
        (ß _hasheq)
    )

    #_method
    (§ defn #_"IObj" withMeta [this, #_"IPersistentMap" meta]
        (ß new Symbol(meta, ns, name))
    )

    (§ constructor- #_"Symbol" Symbol [#_"IPersistentMap" meta, #_"String" ns, #_"String" name]
        (ß this.name = name)
        (ß this.ns = ns)
        (ß this._meta = meta)
        this
    )

    #_method
    (§ defn #_"int" compareTo [this, #_"Object" o]
        (let [#_"Symbol" s (ß (Symbol) o)]
            (when (ß this.equals(o))
                (§ return 0)
            )
            (when (ß this.ns == nil && s.ns != nil)
                (§ return -1)
            )
            (when (ß this.ns != nil)
                (when (ß s.ns == nil)
                    (§ return 1)
                )
                (let [#_"int" nsc (ß this.ns.compareTo(s.ns))]
                    (when (ß nsc != 0)
                        (§ return nsc)
                    )
                )
            )
            (ß this.name.compareTo(s.name))
        )
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" obj]
        (ß RT.get(obj, this))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" obj, #_"Object" notFound]
        (ß RT.get(obj, this, notFound))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [this]
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def #_"Keyword" TAG_KW (ß Keyword.intern("tag")))
    (§ def #_"Keyword" FORM_KW (ß Keyword.intern("form")))

    (§ field #_"Symbol" tag)
    (§ field #_"Object" form)

    (§ defn #_"TaggedLiteral" create [#_"Symbol" tag, #_"Object" form]
        (ß new TaggedLiteral(tag, form))
    )

    (§ constructor- #_"TaggedLiteral" TaggedLiteral [#_"Symbol" tag, #_"Object" form]
        (ß this.tag = tag)
        (ß this.form = form)
        this
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key]
        (ß valAt(key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [this, #_"Object" key, #_"Object" notFound]
        (cond (ß FORM_KW.equals(key))
            (do
                (ß this.form)
            )
            (ß TAG_KW.equals(key))
            (do
                (ß this.tag)
            )
            :else
            (do
                notFound
            )
        )
    )

    (§ anno @Override)
    #_method
    (§ defn #_"boolean" equals [this, #_"Object" o]
        (when (ß this == o)
            (§ return true)
        )
        (when (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (let [#_"TaggedLiteral" that (ß (TaggedLiteral) o)]
            (when (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
                (§ return false)
            )
            (when (ß (tag != nil) ? !tag.equals(that.tag) :or that.tag != nil)
                (§ return false)
            )

            true
        )
    )

    (§ anno @Override)
    #_method
    (§ defn #_"int" hashCode [this]
        (let [#_"int" result (ß Util.hash(tag))]
            (ß result = 31 * result + Util.hash(form))
            result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (§ field #_"Ref[]" bins)

    #_method
    (§ defn #_"IPersistentMap" mapAt [this, #_"int" bin]
        (ß (IPersistentMap) bins[bin].deref())
    )

    #_method
    (§ defn #_"int" binFor [this, #_"Object" k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" h (ß k.hashCode())]
            (ß h ^= (h >>> 20) :xor (h >>> 12))
            (ß h ^= (h >>> 7) :xor (h >>> 4))
            (ß h % bins.length)
        )
    )

    #_method
    (§ defn #_"Entry" entryAt [this, #_"Object" k]
        (ß mapAt(binFor(k)).entryAt(k))
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap []
        (§ this(421))
        this
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap [#_"int" nBins]
        (ß bins = new Ref[nBins])
        (loop-when-recur [(ß int i = 0)] (ß i < nBins) [(ß i++)]
            (ß bins[i] = new Ref(PersistentHashMap.EMPTY))
        )
        this
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap [#_"Map<? extends K, ? extends V>" m]
        (§ this(m.size()))
        (ß putAll(m))
        this
    )

    #_method
    (§ defn #_"int" size [this]
        (let [#_"int" n 0]
            (loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
                (ß n += mapAt(i).count())
            )
            n
        )
    )

    #_method
    (§ defn #_"boolean" isEmpty [this]
        (ß (size() == 0))
    )

    #_method
    (§ defn #_"boolean" containsKey [this, #_"Object" k]
        (ß (entryAt(k) != nil))
    )

    #_method
    (§ defn #_"V" get [this, #_"Object" k]
        (let [#_"Entry" e (ß entryAt(k))]
            (when (ß e != nil)
                (§ return (ß (V) e.getValue()))
            )
            nil
        )
    )

    #_method
    (§ defn #_"V" put [this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Object" ret (ß map.valAt(k))]
                    (ß r.set(map.assoc(k, v)))
                    (ß (V) ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" remove [this, #_"Object" k]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Object" ret (ß map.valAt(k))]
                    (ß r.set(map.without(k)))
                    (ß (V) ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" putAll [this, #_"Map<? extends K, ? extends V>" map]
        (loop-when-recur [(ß Iterator i = map.entrySet().iterator())] (ß i.hasNext()) [(ß )]
            (let [(ß Entry<K, V> e = (Entry) i.next())]
                (ß put(e.getKey(), e.getValue()))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" clear [this]
        (loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
            (let [#_"Ref" r (ß bins[i])]
                (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                    (when (ß map.count() > 0)
                        (ß r.set(PersistentHashMap.EMPTY))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" entrySet [this]
        (let [(ß ArrayList<Map.Entry<K, V>> entries = new ArrayList(bins.length))]
            (loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
                (let [#_"IPersistentMap" map (ß mapAt(i))]
                    (when (ß map.count() > 0)
                        (ß entries.addAll((Collection) RT.seq(map)))
                    )
                )
            )
            (ß new AbstractSet<Entry<K, V>>()
                (§ reify
                    #_method
                    (§ defn #_"Iterator" iterator [this]
                        (ß Collections.unmodifiableList(entries).iterator())
                    )

                    #_method
                    (§ defn #_"int" size [this]
                        (ß entries.size())
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"V" putIfAbsent [this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (if (ß e == nil)
                        (do
                            (ß r.set(map.assoc(k, v)))
                            nil
                        )
                        (do
                            (ß (V) e.getValue())
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" remove [this, #_"Object" k, #_"Object" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil && e.getValue().equals(v))
                        (ß r.set(map.without(k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" replace [this, #_"K" k, #_"V" oldv, #_"V" newv]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil && e.getValue().equals(oldv))
                        (ß r.set(map.assoc(k, newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"V" replace [this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil)
                        (ß r.set(map.assoc(k, v)))
                        (§ return (ß (V) e.getValue()))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

(class-ns TransformerIterator (§ implements Iterator)
    (§ def- #_"Buffer" EMPTY (ß new Empty()))
    (§ def- #_"Object" NONE (ß new Object()))

    ;; Source
    (§ field- #_"Iterator" sourceIter)
    (§ field- #_"IFn" xf)
    (§ field- #_"boolean" multi)

    ;; Iteration state
    #_volatile
    (§ field- #_"Buffer" buffer (ß EMPTY))
    #_volatile
    (§ field- #_"Object" next (ß NONE))
    #_volatile
    (§ field- #_"boolean" completed (ß false))

    (§ constructor- #_"TransformerIterator" TransformerIterator [#_"IFn" xform, #_"Iterator" sourceIter, #_"boolean" multi]
        (ß this.sourceIter = sourceIter)
        (ß this.xf = (IFn) xform.invoke(new AFn()
            (§ reify
                #_method
                (§ defn #_"Object" invoke [this]
                    nil
                )

                #_method
                (§ defn #_"Object" invoke [this, #_"Object" acc]
                    acc
                )

                #_method
                (§ defn #_"Object" invoke [this, #_"Object" acc, #_"Object" o]
                    (ß buffer = buffer.add(o))
                    acc
                )
            ))
        )
        (ß this.multi = multi)
        this
    )

    (§ defn #_"Iterator" create [#_"IFn" xform, #_"Iterator" source]
        (ß new TransformerIterator(xform, source, false))
    )

    (§ defn #_"Iterator" createMulti [#_"IFn" xform, #_"List" sources]
        (let [#_"Iterator[]" iters (ß new Iterator[sources.size()])]
            (loop-when-recur [(ß int i = 0)] (ß i < sources.size()) [(ß i++)]
                (ß iters[i] = (Iterator)sources.get(i))
            )
            (ß new TransformerIterator(xform, new MultiIterator(iters), true))
        )
    )

    #_method
    (§ defn- #_"boolean" step [this]
        (when (ß next != NONE)
            (§ return true)
        )

        (while (ß next == NONE)
            (if (ß buffer.isEmpty())
                (do
                    (cond completed
                        (do
                            (§ return false)
                        )
                        (ß sourceIter.hasNext())
                        (do
                            (let [#_"Object" iter nil]
                                (if multi
                                    (do
                                        (ß iter = xf.applyTo(RT.cons(nil, sourceIter.next())))
                                    )
                                    (do
                                        (ß iter = xf.invoke(nil, sourceIter.next()))
                                    )
                                )

                                (when (ß RT.isReduced(iter))
                                    (ß xf.invoke(nil))
                                    (ß completed = true)
                                )
                            )
                        )
                        :else
                        (do
                            (ß xf.invoke(nil))
                            (ß completed = true)
                        )
                    )
                )
                (do
                    (ß next = buffer.remove())
                )
            )
        )
        true
    )

    #_method
    (§ defn #_"boolean" hasNext [this]
        (ß step())
    )

    #_method
    (§ defn #_"Object" next [this]
        (when (ß hasNext())
            (let [#_"Object" ret next]
                (ß next = NONE)
                (§ return ret)
            )
        )
        (throw (ß new NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [this]
        (throw (ß new UnsupportedOperationException()))
    )

    #_private
    (§ interface Buffer
        (§ abstract Buffer add(Object o))
        (§ abstract Object remove())
        (§ abstract boolean isEmpty())
    )

    #_private
    (class-ns Empty (§ implements Buffer)
        #_method
        (§ defn #_"Buffer" add [this, #_"Object" o]
            (ß new Single(o))
        )

        #_method
        (§ defn #_"Object" remove [this]
            (throw (ß new IllegalStateException("Removing object from empty buffer")))
        )

        #_method
        (§ defn #_"boolean" isEmpty [this]
            true
        )

        #_method
        (§ defn #_"String" toString [this]
            (ß "Empty")
        )
    )

    #_private
    (class-ns Single (§ implements Buffer)
        #_volatile
        (§ field- #_"Object" val)

        (§ constructor #_"Single" Single [#_"Object" o]
            (ß this.val = o)
            this
        )

        #_method
        (§ defn #_"Buffer" add [this, #_"Object" o]
            (if (ß val == NONE)
                (do
                    (ß val = o)
                    this
                )
                (do
                    (ß new Many(val, o))
                )
            )
        )

        #_method
        (§ defn #_"Object" remove [this]
            (when (ß val == NONE)
                (throw (ß new IllegalStateException("Removing object from empty buffer")))
            )
            (let [#_"Object" ret val]
                (ß val = NONE)
                ret
            )
        )

        #_method
        (§ defn #_"boolean" isEmpty [this]
            (ß (val == NONE))
        )

        #_method
        (§ defn #_"String" toString [this]
            (ß "Single: " + val)
        )
    )

    #_private
    (class-ns Many (§ implements Buffer)
        (§ field- #_"Queue" vals (ß new LinkedList()))

        (§ constructor #_"Many" Many [#_"Object" o1, #_"Object" o2]
            (ß vals.add(o1))
            (ß vals.add(o2))
            this
        )

        #_method
        (§ defn #_"Buffer" add [this, #_"Object" o]
            (ß vals.add(o))
            this
        )

        #_method
        (§ defn #_"Object" remove [this]
            (ß vals.remove())
        )

        #_method
        (§ defn #_"boolean" isEmpty [this]
            (ß vals.isEmpty())
        )

        #_method
        (§ defn #_"String" toString [this]
            (ß "Many: " + vals.toString())
        )
    )

    #_private
    (class-ns MultiIterator (§ implements Iterator)
        (§ field- #_"Iterator[]" iters)

        (§ constructor #_"MultiIterator" MultiIterator [#_"Iterator[]" iters]
            (ß this.iters = iters)
            this
        )

        #_method
        (§ defn #_"boolean" hasNext [this]
            (doseq [#_"Iterator" iter iters]
                (when (ß !iter.hasNext())
                    (§ return false)
                )
            )
            true
        )

        #_method
        (§ defn #_"Object" next [this]
            (let [#_"Object[]" nexts (ß new Object[iters.length])]
                (loop-when-recur [(ß int i = 0)] (ß i < iters.length) [(ß i++)]
                    (ß nexts[i] = iters[i].next())
                )
                (ß new ArraySeq(nexts, 0))
            )
        )

        #_method
        (§ defn #_"void" remove [this]
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(class-ns Tuple
    (§ def #_"int" MAX_SIZE (ß 6))

    (§ defn #_"IPersistentVector" create []
        (ß PersistentVector.EMPTY)
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0]
        (ß RT.vector(v0))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1]
        (ß RT.vector(v0, v1))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2]
        (ß RT.vector(v0, v1, v2))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3]
        (ß RT.vector(v0, v1, v2, v3))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4]
        (ß RT.vector(v0, v1, v2, v3, v4))
    )

    (§ defn #_"IPersistentVector" create [#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4, #_"Object" v5]
        (ß RT.vector(v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(class-ns Util
    (§ defn #_"boolean" equiv [#_"Object" k1, #_"Object" k2]
        (when (ß k1 == k2)
            (§ return true)
        )
        (when (ß k1 != nil)
            (cond (ß k1 instanceof Number && k2 instanceof Number)
                (do
                    (§ return (ß Numbers.equal((Number)k1, (Number)k2)))
                )
                (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                (do
                    (§ return (ß pcequiv(k1, k2)))
                )
            )
            (§ return (ß k1.equals(k2)))
        )
        false
    )

    #_non-static
    (§ interface EquivPred
        (§ abstract boolean equiv(Object k1, Object k2))
    )

    (§ def #_"EquivPred" equivNull (ß new EquivPred()
        (§ reify
            #_method
            (§ defn #_"boolean" equiv [this, #_"Object" k1, #_"Object" k2]
                (ß (k2 == nil))
            )
        )
    ))

    (§ def #_"EquivPred" equivEquals (ß new EquivPred()
        (§ reify
            #_method
            (§ defn #_"boolean" equiv [this, #_"Object" k1, #_"Object" k2]
                (ß k1.equals(k2))
            )
        )
    ))

    (§ def #_"EquivPred" equivNumber (ß new EquivPred()
        (§ reify
            #_method
            (§ defn #_"boolean" equiv [this, #_"Object" k1, #_"Object" k2]
                (when (ß k2 instanceof Number)
                    (§ return (ß Numbers.equal((Number) k1, (Number) k2)))
                )
                false
            )
        )
    ))

    (§ def #_"EquivPred" equivColl (ß new EquivPred()
        (§ reify
            #_method
            (§ defn #_"boolean" equiv [this, #_"Object" k1, #_"Object" k2]
                (when (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(k1, k2)))
                )
                (ß k1.equals(k2))
            )
        )
    ))

    (§ defn #_"EquivPred" equivPred [#_"Object" k1]
        (cond (ß k1 == nil)
            (do
                (§ return equivNull)
            )
            (ß k1 instanceof Number)
            (do
                (§ return equivNumber)
            )
            (ß k1 instanceof String || k1 instanceof Symbol)
            (do
                (§ return equivEquals)
            )
            (ß k1 instanceof Collection || k1 instanceof Map)
            (do
                (§ return equivColl)
            )
        )
        equivEquals
    )

    (§ defn #_"boolean" equiv [#_"long" k1, #_"long" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"boolean" equiv [#_"Object" k1, #_"long" k2]
        (ß equiv(k1, (Object)k2))
    )

    (§ defn #_"boolean" equiv [#_"long" k1, #_"Object" k2]
        (ß equiv((Object)k1, k2))
    )

    (§ defn #_"boolean" equiv [#_"double" k1, #_"double" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"boolean" equiv [#_"Object" k1, #_"double" k2]
        (ß equiv(k1, (Object)k2))
    )

    (§ defn #_"boolean" equiv [#_"double" k1, #_"Object" k2]
        (ß equiv((Object)k1, k2))
    )

    (§ defn #_"boolean" equiv [#_"boolean" k1, #_"boolean" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"boolean" equiv [#_"Object" k1, #_"boolean" k2]
        (ß equiv(k1, (Object)k2))
    )

    (§ defn #_"boolean" equiv [#_"boolean" k1, #_"Object" k2]
        (ß equiv((Object)k1, k2))
    )

    (§ defn #_"boolean" equiv [#_"char" c1, #_"char" c2]
        (ß (c1 == c2))
    )

    (§ defn #_"boolean" pcequiv [#_"Object" k1, #_"Object" k2]
        (when (ß k1 instanceof IPersistentCollection)
            (§ return (ß ((IPersistentCollection)k1).equiv(k2)))
        )
        (ß ((IPersistentCollection)k2).equiv(k1))
    )

    (§ defn #_"boolean" equals [#_"Object" k1, #_"Object" k2]
        (when (ß k1 == k2)
            (§ return true)
        )
        (ß (k1 != nil && k1.equals(k2)))
    )

    (§ defn #_"boolean" identical [#_"Object" k1, #_"Object" k2]
        (ß (k1 == k2))
    )

    (§ defn #_"Class" classOf [#_"Object" x]
        (when (ß x != nil)
            (§ return (ß x.getClass()))
        )
        nil
    )

    (§ defn #_"int" compare [#_"Object" k1, #_"Object" k2]
        (when (ß k1 == k2)
            (§ return 0)
        )
        (when (ß k1 != nil)
            (when (ß k2 == nil)
                (§ return 1)
            )
            (when (ß k1 instanceof Number)
                (§ return (ß Numbers.compare((Number) k1, (Number) k2)))
            )
            (§ return (ß ((Comparable) k1).compareTo(k2)))
        )
        -1
    )

    (§ defn #_"int" hash [#_"Object" o]
        (when (ß o == nil)
            (§ return 0)
        )
        (ß o.hashCode())
    )

    (§ defn #_"int" hasheq [#_"Object" o]
        (when (ß o == nil)
            (§ return 0)
        )
        (when (ß o instanceof IHashEq)
            (§ return (ß dohasheq((IHashEq) o)))
        )
        (when (ß o instanceof Number)
            (§ return (ß Numbers.hasheq((Number)o)))
        )
        (when (ß o instanceof String)
            (§ return (ß Murmur3.hashInt(o.hashCode())))
        )
        (ß o.hashCode())
    )

    (§ defn- #_"int" dohasheq [#_"IHashEq" o]
        (ß o.hasheq())
    )

    (§ defn #_"int" hashCombine [#_"int" seed, #_"int" hash]
        ;; a la boost
        (ß seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2))
        seed
    )

    (§ defn #_"boolean" isPrimitive [#_"Class" c]
        (ß (c != nil && c.isPrimitive() && !(c == Void.TYPE)))
    )

    (§ defn #_"boolean" isInteger [#_"Object" x]
        (ß (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger))
    )

    (§ defn #_"Object" ret1 [#_"Object" ret, #_"Object" nil]
        ret
    )

    (§ defn #_"ISeq" ret1 [#_"ISeq" ret, #_"Object" nil]
        ret
    )

    (§ defn #_"<K, V> void" clearCache [#_"ReferenceQueue" rq, #_"ConcurrentHashMap<K, Reference<V>>" cache]
        ;; cleanup any dead entries
        (when (ß rq.poll() != nil)
            (while (ß rq.poll() != nil)
            )
            (doseq [#_"Map.Entry<K, Reference<V>>" (ß e cache.entrySet())]
                (let [#_"Reference<V>" val (ß e.getValue())]
                    (when (ß val != nil && val.get() == nil)
                        (ß cache.remove(e.getKey(), val))
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"RuntimeException" runtimeException [#_"String" s]
        (ß new RuntimeException(s))
    )

    (§ defn #_"RuntimeException" runtimeException [#_"String" s, #_"Throwable" e]
        (ß new RuntimeException(s, e))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (§ defn #_"RuntimeException" sneakyThrow [#_"Throwable" t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (ß t == nil)
            (throw (ß new NullPointerException()))
        )
        (ß Util.<RuntimeException>sneakyThrow0(t))
        nil
    )

    (§ anno @SuppressWarnings("unchecked"))
    (§ defn- #_"<T extends Throwable> void" sneakyThrow0 [#_"Throwable" t] (§ throws T)
        (throw (ß (T) t))
    )

    (§ defn #_"Object" loadWithClass [#_"String" scriptbase, #_"Class<?>" loadFrom] (§ throws IOException, ClassNotFoundException)
        (ß Var.pushThreadBindings(RT.map(new Object[] (§ Compiler.LOADER, loadFrom.getClassLoader() ))))
        (try
            (ß RT.var("cloiure.core", "load").invoke(scriptbase))
            (finally
                (ß Var.popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (class-ns TBox
        #_volatile
        (§ field #_"Object" val)
        (§ field #_"Thread" thread)

        (§ constructor #_"TBox" TBox [#_"Thread" t, #_"Object" val]
            (ß this.thread = t)
            (ß this.val = val)
            this
        )
    )

    (class-ns Unbound (§ extends AFn)
        (§ field #_"Var" v)

        (§ constructor #_"Unbound" Unbound [#_"Var" v]
            (ß this.v = v)
            this
        )

        #_method
        (§ defn #_"String" toString [this]
            (ß "Unbound: " + v)
        )

        #_method
        (§ defn #_"Object" throwArity [this, #_"int" n]
            (throw (ß new IllegalStateException("Attempting to call unbound fn: " + v)))
        )
    )

    (class-ns Frame
        (§ def #_"Frame" TOP (ß new Frame(PersistentHashMap.EMPTY, nil)))
        ;; Var->TBox
        (§ field #_"Associative" bindings)
        ;; Var->val
        (§ field #_"Frame" prev)

        (§ constructor #_"Frame" Frame [#_"Associative" bindings, #_"Frame" prev]
            (ß this.bindings = bindings)
            (ß this.prev = prev)
            this
        )

        #_protected
        #_method
        (§ defn #_"Object" clone [this]
            (ß new Frame(this.bindings, nil))
        )
    )

    (§ def #_"ThreadLocal<Frame>" dvals (ß new ThreadLocal<Frame>()
        (§ reify
            #_protected
            #_method
            (§ defn #_"Frame" initialValue [this]
                (ß Frame.TOP)
            )
        )
    ))

    #_volatile
    (§ def #_"int" rev (ß 0))

    (§ def #_"Keyword" privateKey (ß Keyword.intern(nil, "private")))
    (§ def #_"IPersistentMap" privateMeta (ß new PersistentArrayMap(new Object[] (§ privateKey, Boolean.TRUE ))))
    (§ def #_"Keyword" macroKey (ß Keyword.intern(nil, "macro")))
    (§ def #_"Keyword" nameKey (ß Keyword.intern(nil, "name")))
    (§ def #_"Keyword" nsKey (ß Keyword.intern(nil, "ns")))

    #_volatile
    (§ field #_"Object" root)

    #_volatile
    (§ field #_"boolean" dynamic (ß false))
    #_transient
    (§ field #_"AtomicBoolean" threadBound)
    (§ field #_"Symbol" sym)
    (§ field #_"Namespace" ns)

    (§ defn #_"Object" getThreadBindingFrame []
        (ß dvals.get())
    )

    (§ defn #_"Object" cloneThreadBindingFrame []
        (ß dvals.get().clone())
    )

    (§ defn #_"void" resetThreadBindingFrame [#_"Object" frame]
        (ß dvals.set((Frame) frame))
        nil
    )

    #_method
    (§ defn #_"Var" setDynamic [this]
        (ß this.dynamic = true)
        this
    )

    #_method
    (§ defn #_"Var" setDynamic [this, #_"boolean" b]
        (ß this.dynamic = b)
        this
    )

    #_method
    (§ defn #_"boolean" isDynamic [this]
        dynamic
    )

    (§ defn #_"Var" intern [#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
        (ß intern(ns, sym, root, true))
    )

    (§ defn #_"Var" intern [#_"Namespace" ns, #_"Symbol" sym, #_"Object" root, #_"boolean" replaceRoot]
        (let [#_"Var" dvout (ß ns.intern(sym))]
            (when (ß !dvout.hasRoot() || replaceRoot)
                (ß dvout.bindRoot(root))
            )
            dvout
        )
    )

    #_method
    (§ defn #_"String" toString [this]
        (when (ß ns != nil)
            (§ return (ß "#'" + ns.name + "/" + sym))
        )
        (ß "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">")
    )

    (§ defn #_"Var" find [#_"Symbol" nsQualifiedSym]
        (when (ß nsQualifiedSym.ns == nil)
            (throw (ß new IllegalArgumentException("Symbol must be namespace-qualified")))
        )
        (let [#_"Namespace" ns (ß Namespace.find(Symbol.intern(nsQualifiedSym.ns)))]
            (when (ß ns == nil)
                (throw (ß new IllegalArgumentException("No such namespace: " + nsQualifiedSym.ns)))
            )
            (ß ns.findInternedVar(Symbol.intern(nsQualifiedSym.name)))
        )
    )

    (§ defn #_"Var" intern [#_"Symbol" nsName, #_"Symbol" sym]
        (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsName))]
            (ß intern(ns, sym))
        )
    )

    (§ defn #_"Var" internPrivate [#_"String" nsName, #_"String" sym]
        (let [#_"Namespace" ns (ß Namespace.findOrCreate(Symbol.intern(nsName)))]
            (let [#_"Var" ret (ß intern(ns, Symbol.intern(sym)))]
                (ß ret.setMeta(privateMeta))
                ret
            )
        )
    )

    (§ defn #_"Var" intern [#_"Namespace" ns, #_"Symbol" sym]
        (ß ns.intern(sym))
    )

    (§ defn #_"Var" create []
        (ß new Var(nil, nil))
    )

    (§ defn #_"Var" create [#_"Object" root]
        (ß new Var(nil, nil, root))
    )

    (§ constructor #_"Var" Var [#_"Namespace" ns, #_"Symbol" sym]
        (ß this.ns = ns)
        (ß this.sym = sym)
        (ß this.threadBound = new AtomicBoolean(false))
        (ß this.root = new Unbound(this))
        (ß setMeta(PersistentHashMap.EMPTY))
        this
    )

    (§ constructor #_"Var" Var [#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
        (§ this(ns, sym))
        (ß this.root = root)
        (ß ++rev)
        this
    )

    #_method
    (§ defn #_"boolean" isBound [this]
        (ß (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this))))
    )

    #_method
    (§ defn #_"Object" get [this]
        (when (ß !threadBound.get())
            (§ return root)
        )
        (ß deref())
    )

    #_method
    (§ defn #_"Object" deref [this]
        (let [#_"TBox" b (ß getThreadBinding())]
            (when (ß b != nil)
                (§ return (ß b.val))
            )
            root
        )
    )

    #_method
    (§ defn #_"void" setValidator [this, #_"IFn" vf]
        (when (ß hasRoot())
            (ß validate(vf, root))
        )
        (ß validator = vf)
        nil
    )

    #_method
    (§ defn #_"Object" alter [this, #_"IFn" fn, #_"ISeq" args]
        (ß set(fn.applyTo(RT.cons(deref(), args))))
        this
    )

    #_method
    (§ defn #_"Object" set [this, #_"Object" val]
        (ß validate(getValidator(), val))
        (let [#_"TBox" b (ß getThreadBinding())]
            (when (ß b != nil)
                (when (ß Thread.currentThread() != b.thread)
                    (throw (ß new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym))))
                )
                (§ return (ß (b.val = val)))
            )
            (throw (ß new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym))))
        )
    )

    #_method
    (§ defn #_"Object" doSet [this, #_"Object" val]
        (ß set(val))
    )

    #_method
    (§ defn #_"Object" doReset [this, #_"Object" val]
        (ß bindRoot(val))
        val
    )

    #_method
    (§ defn #_"void" setMeta [this, #_"IPersistentMap" m]
        ;; ensure these basis keys
        (ß resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns)))
        nil
    )

    #_method
    (§ defn #_"void" setMacro [this]
        (ß alterMeta(assoc, RT.list(macroKey, RT.T)))
        nil
    )

    #_method
    (§ defn #_"boolean" isMacro [this]
        (ß RT.booleanCast(meta().valAt(macroKey)))
    )

    #_method
    (§ defn #_"boolean" isPublic [this]
        (ß !RT.booleanCast(meta().valAt(privateKey)))
    )

    #_method
    (§ defn #_"Object" getRawRoot [this]
        root
    )

    #_method
    (§ defn #_"Object" getTag [this]
        (ß meta().valAt(RT.TAG_KEY))
    )

    #_method
    (§ defn #_"void" setTag [this, #_"Symbol" tag]
        (ß alterMeta(assoc, RT.list(RT.TAG_KEY, tag)))
        nil
    )

    #_method
    (§ defn #_"boolean" hasRoot [this]
        (ß !(root instanceof Unbound))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" bindRoot [this, #_"Object" root]
        (§ sync this
            (ß validate(getValidator(), root))
            (let [#_"Object" oldroot (ß this.root)]
                (ß this.root = root)
                (ß ++rev)
                (ß alterMeta(dissoc, RT.list(macroKey)))
                (ß notifyWatches(oldroot, this.root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" swapRoot [this, #_"Object" root]
        (§ sync this
            (ß validate(getValidator(), root))
            (let [#_"Object" oldroot (ß this.root)]
                (ß this.root = root)
                (ß ++rev)
                (ß notifyWatches(oldroot, root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" unbindRoot [this]
        (§ sync this
            (ß this.root = new Unbound(this))
            (ß ++rev)
        )
        nil
    )

    #_method
    (§ defn #_"void" commuteRoot [this, #_"IFn" fn]
        (§ sync this
            (let [#_"Object" newRoot (ß fn.invoke(root))]
                (ß validate(getValidator(), newRoot))
                (let [#_"Object" oldroot root]
                    (ß this.root = newRoot)
                    (ß ++rev)
                    (ß notifyWatches(oldroot, newRoot))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" alterRoot [this, #_"IFn" fn, #_"ISeq" args]
        (§ sync this
            (let [#_"Object" newRoot (ß fn.applyTo(RT.cons(root, args)))]
                (ß validate(getValidator(), newRoot))
                (let [#_"Object" oldroot root]
                    (ß this.root = newRoot)
                    (ß ++rev)
                    (ß notifyWatches(oldroot, newRoot))
                    newRoot
                )
            )
        )
    )

    (§ defn #_"void" pushThreadBindings [#_"Associative" bindings]
        (let [#_"Frame" f (ß dvals.get())]
            (let [#_"Associative" bmap (ß f.bindings)]
                (loop-when-recur [(ß ISeq bs = bindings.seq())] (ß bs != nil) [(ß bs = bs.next())]
                    (let [#_"IMapEntry" e (ß (IMapEntry) bs.first())]
                        (let [#_"Var" v (ß (Var) e.key())]
                            (when (ß !v.dynamic)
                                (throw (ß new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym))))
                            )
                            (ß v.validate(v.getValidator(), e.val()))
                            (ß v.threadBound.set(true))
                            (ß bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val())))
                        )
                    )
                )
                (ß dvals.set(new Frame(bmap, f)))
                nil
            )
        )
    )

    (§ defn #_"void" popThreadBindings []
        (let [#_"Frame" f (ß dvals.get().prev)]
            (cond (ß f == nil)
                (do
                    (throw (ß new IllegalStateException("Pop without matching push")))
                )
                (ß f == Frame.TOP)
                (do
                    (ß dvals.remove())
                )
                :else
                (do
                    (ß dvals.set(f))
                )
            )
            nil
        )
    )

    (§ defn #_"Associative" getThreadBindings []
        (let [#_"Frame" f (ß dvals.get())]
            (let [#_"IPersistentMap" ret (ß PersistentHashMap.EMPTY)]
                (loop-when-recur [(ß ISeq bs = f.bindings.seq())] (ß bs != nil) [(ß bs = bs.next())]
                    (let [#_"IMapEntry" e (ß (IMapEntry) bs.first())]
                        (let [#_"Var" v (ß (Var) e.key())]
                            (let [#_"TBox" b (ß (TBox) e.val())]
                                (ß ret = ret.assoc(v, b.val))
                            )
                        )
                    )
                )
                ret
            )
        )
    )

    #_method
    (§ defn #_"TBox" getThreadBinding [this]
        (when (ß threadBound.get())
            (let [#_"IMapEntry" e (ß dvals.get().bindings.entryAt(this))]
                (when (ß e != nil)
                    (§ return (ß (TBox) e.val()))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IFn" fn [this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil)))
    )

    #_method
    (§ defn #_"Object" invoke [this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object..." args]
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil),
                (Object[])Util.ret1(args, args = nil)))
    )

    #_method
    (§ defn #_"Object" applyTo [this, #_"ISeq" arglist]
        (ß fn().applyTo(arglist))
    )

    (§ def #_"IFn" assoc (ß new AFn()
        (§ reify
            (§ anno @Override)
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" m, #_"Object" k, #_"Object" v]
                (ß RT.assoc(m, k, v))
            )
        )
    ))

    (§ def #_"IFn" dissoc (ß new AFn()
        (§ reify
            (§ anno @Override)
            #_method
            (§ defn #_"Object" invoke [this, #_"Object" c, #_"Object" k]
                (ß RT.dissoc(c, k))
            )
        )
    ))
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    #_volatile
    (§ field #_"Object" val)

    (§ constructor #_"Volatile" Volatile [#_"Object" val]
        (ß this.val = val)
        this
    )

    #_method
    (§ defn #_"Object" deref [this]
        val
    )

    #_method
    (§ defn #_"Object" reset [this, #_"Object" newval]
        (ß this.val = newval)
    )
)
)

(java-ns cloiure.lang.WarnBoxedMath

(§ import java.lang.annotation.Retention)
(§ import java.lang.annotation.RetentionPolicy)
(§ import java.lang.annotation.ElementType)
(§ import java.lang.annotation.Target)

(§ anno @Retention(RetentionPolicy.RUNTIME))
(§ anno @Target(ElementType.METHOD))
(§ @interface WarnBoxedMath)
    (§ @abstract boolean value() default true)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

(class-ns main
    (§ def- #_"Symbol" CLOIURE_MAIN (ß Symbol.intern("cloiure.main")))
    (§ def- #_"Var" REQUIRE (ß RT.var("cloiure.core", "require")))
    (§ def- #_"Var" MAIN (ß RT.var("cloiure.main", "main")))

    (§ defn #_"void" main [#_"String[]" args]
        (ß REQUIRE.invoke(CLOIURE_MAIN))
        (ß MAIN.applyTo(RT.seq(args)))
        nil
    )
)
)
