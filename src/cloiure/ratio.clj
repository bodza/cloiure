(ns cloiure.ratio
    (:refer-clojure :only [* *ns* + - < <= = aget alength and assoc bit-not cond cons dec declare defmacro defn first if-not import inc let letfn loop next not or second some? symbol? vary-meta vec vector? while])
)

(defmacro § [& _])
(defmacro ß [& _])

(defmacro java-ns  [_ & s] (cons 'do s))
(defmacro class-ns [_ & s] (cons 'do s))

(clojure.core/doseq [% (clojure.core/keys (clojure.core/ns-imports *ns*))] (clojure.core/ns-unmap *ns* %))

(import
    [java.lang Long RuntimeException String]
)

(import
    [java.util Arrays Random]
    [java.util.concurrent ThreadLocalRandom]
)

(defmacro throw! [^String s] `(throw (RuntimeException. ~s)))

(defmacro def-      [x & s] `(def      ~(vary-meta x assoc :private true) ~@s))
(defmacro defn-     [x & s] `(defn     ~(vary-meta x assoc :private true) ~@s))
(defmacro defmacro- [x & s] `(defmacro ~(vary-meta x assoc :private true) ~@s))

(letfn [(=> [s] (if (= '=> (first s)) (next s) (cons nil s)))]
    (defmacro     when       [? & s] (let [[e & s] (=> s)]               `(if     ~? (do ~@s) ~e)))
    (defmacro     when-not   [? & s] (let [[e & s] (=> s)]               `(if-not ~? (do ~@s) ~e)))
    (defmacro let-when     [v ? & s] (let [[e & s] (=> s)] `(let ~(vec v) (if     ~? (do ~@s) ~e))))
    (defmacro let-when-not [v ? & s] (let [[e & s] (=> s)] `(let ~(vec v) (if-not ~? (do ~@s) ~e))))
)

(letfn [(v' [v] (cond (vector? v) v (symbol? v) [v v] :else [`_# v]))
        (r' [r] (cond (vector? r) `((recur ~@r)) (some? r) `((recur ~r))))
        (=> [s] (if (= '=> (first s)) (next s) (cons nil s)))
        (l' [v ? r s] (let [r (r' r) [e & s] (=> s)] `(loop ~(v' v) (if ~? (do ~@s ~@r) ~e))))]
    (defmacro loop-when [v ? & s] (l' v ? nil s))
    (defmacro loop-when-recur [v ? r & s] (l' v ? r s))
)

(letfn [(r' [r] (cond (vector? r) `(recur ~@r) (some? r) `(recur ~r)))
        (=> [s] (if (= '=> (first s)) (second s)))]
    (defmacro recur-if [? r & s] `(if ~? ~(r' r) ~(=> s)))
)

(java-ns cloiure.math.BigInteger

(declare BigInteger'LONG_MASK)

;;;
 ; A simple bit sieve used for finding prime number candidates. Allows setting
 ; and clearing of bits in a storage array. The size of the sieve is assumed to
 ; be constant to reduce overhead. All the bits of a new bitSieve are zero, and
 ; bits are removed from it by setting them.
 ;
 ; To reduce storage space and increase efficiency, no even numbers are
 ; represented in the sieve (each bit in the sieve represents an odd number).
 ; The relationship between the index of a bit and the number it represents is
 ; given by
 ; N = offset + (2*index + 1);
 ; Where N is the integer represented by a bit in the sieve, offset is some
 ; even integer offset indicating where the sieve begins, and index is the
 ; index of a bit in the sieve array.
 ;;

(class-ns BitSieve
    ;;;
     ; Stores the bits in this bitSieve.
     ;;
    (§ field- #_"long[]" :bits)

    ;;;
     ; Length is how many bits this sieve holds.
     ;;
    (§ field- #_"int" :length)

    (declare BitSieve'new)

    ;;;
     ; A small sieve used to filter out multiples of small primes in a search sieve.
     ;;
    (def- #_"BitSieve" BitSieve'smallSieve (§ soon BitSieve'new))

    (declare BitSieve''set)
    (declare BitSieve''sieveSearch)

    ;;;
     ; Construct a "small sieve" with a base of 0. This constructor is
     ; used internally to generate the set of "small primes" whose multiples
     ; are excluded from sieves generated by the main (package private)
     ; constructor, BitSieve(BigInteger base, int searchLen). The length
     ; of the sieve generated by this constructor was chosen for performance;
     ; it controls a tradeoff between how much time is spent constructing
     ; other sieves, and how much time is wasted testing composite candidates
     ; for primality. The length was chosen experimentally to yield good
     ; performance.
     ;;
    (defn- #_"BitSieve" BitSieve'new []
        (let [this (§ new)
        ]
            (§ ass (:length this) (* 150 64))
            (§ ass (:bits this) (ß new long[(BitSieve'unitIndex(this.length - 1) + 1)]))

            ;; mark 1 as composite
            (BitSieve''set this, 0)
            (let [
                  #_"int" nextIndex 1
                  #_"int" nextPrime 3
            ]
                ;; find primes and remove their multiples from sieve
                (loop []
                    (ß BitSieve''sieveSingle(this, this.length, nextIndex + nextPrime, nextPrime))
                    (§ ass nextIndex (ß BitSieve''sieveSearch(this, this.length, nextIndex + 1)))
                    (§ ass nextPrime (ß 2 * nextIndex + 1))
                    (recur-if (and (ß nextIndex > 0) (ß nextPrime < this.length)) [])
                )
                this
            )
        )
    )

    (declare MutableBigInteger'new)

    ;;;
     ; Construct a bit sieve of searchLen bits used for finding prime number candidates.
     ; The new sieve begins at the specified base, which must be even.
     ;;
    (defn #_"BitSieve" BitSieve'new [#_"BigInteger" base, #_"int" searchLen]
        ;;
         ; Candidates are indicated by clear bits in the sieve. As a candidates
         ; nonprimality is calculated, a bit is set in the sieve to eliminate
         ; it. To reduce storage space and increase efficiency, no even numbers
         ; are represented in the sieve (each bit in the sieve represents an
         ; odd number).
         ;;
        (let [this (§ new)
        ]
            (§ ass (:bits this) (ß new long[(BitSieve'unitIndex(searchLen - 1) + 1)]))
            (§ ass (:length this) searchLen)
            ;; construct the large sieve at an even offset specified by base
            (let [
                  #_"MutableBigInteger" b (MutableBigInteger'new base)
                  #_"MutableBigInteger" q (MutableBigInteger'new)
                  #_"int" start 0
                  #_"int" step (BitSieve''sieveSearch BitSieve'smallSieve, (alength BitSieve'smallSieve), start)
                  #_"int" convertedStep (ß (step * 2) + 1)
            ]
                (loop []
                    ;; calculate base mod convertedStep
                    (§ ass start (MutableBigInteger''divideOneWord b, convertedStep, q))

                    ;; take each multiple of step out of sieve
                    (§ ass start (- convertedStep start))
                    (when (ß start % 2 == 0)
                        (§ ass start (+ start convertedStep))
                    )
                    (ß BitSieve''sieveSingle(this, searchLen, (start - 1) / 2, convertedStep))

                    ;; find next prime from small sieve
                    (§ ass step (BitSieve''sieveSearch BitSieve'smallSieve, (alength BitSieve'smallSieve), (inc step)))
                    (§ ass convertedStep (ß (step * 2) + 1))
                    (recur-if (< 0 step) [])
                )
                this
            )
        )
    )

    ;;;
     ; Given a bit index return unit index containing it.
     ;;
    (defn- #_"int" BitSieve'unitIndex [#_"int" bitIndex]
        (ß bitIndex >>> 6)
    )

    ;;;
     ; Return a unit that masks the specified bit in its unit.
     ;;
    (defn- #_"long" BitSieve'bit [#_"int" bitIndex]
        (ß 1 << (bitIndex & ((1 << 6) - 1)))
    )

    ;;;
     ; Get the value of the bit at the specified index.
     ;;
    #_method
    (defn- #_"boolean" BitSieve''get [#_"BitSieve" this, #_"int" bitIndex]
        (let [
              #_"int" unitIndex (BitSieve'unitIndex bitIndex)
        ]
            (ß ((this.bits[unitIndex] & BitSieve'bit(bitIndex)) != 0))
        )
    )

    ;;;
     ; Set the bit at the specified index.
     ;;
    #_method
    (defn- #_"void" BitSieve''set [#_"BitSieve" this, #_"int" bitIndex]
        (let [
              #_"int" unitIndex (BitSieve'unitIndex bitIndex)
        ]
            (§ ass (ß this.bits[unitIndex]) (ß (ß this.bits[unitIndex] | BitSieve'bit(bitIndex))))
        )
        nil
    )

    ;;;
     ; This method returns the index of the first clear bit in the search
     ; array that occurs at or after start. It will not search past the
     ; specified limit. It returns -1 if there is no such clear bit.
     ;;
    #_method
    (defn- #_"int" BitSieve''sieveSearch [#_"BitSieve" this, #_"int" limit, #_"int" start]
        (when (<= limit start)
            (§ return -1)
        )

        (let [
              #_"int" index start
        ]
            (loop []
                (when (ß !BitSieve''get(this, index))
                    (§ return index)
                )
                (§ ass index (inc index))
                (recur-if (ß index < limit - 1) [])
            )
            -1
        )
    )

    ;;;
     ; Sieve a single set of multiples out of the sieve. Begin to remove
     ; multiples of the specified step starting at the specified start index,
     ; up to the specified limit.
     ;;
    #_method
    (defn- #_"void" BitSieve''sieveSingle [#_"BitSieve" this, #_"int" limit, #_"int" start, #_"int" step]
        (while (< start limit)
            (BitSieve''set this, start)
            (§ ass start (+ start step))
        )
        nil
    )

    (declare BigInteger''primeToCertainty)

    ;;;
     ; Test probable primes in the sieve and return successful candidates.
     ;;
    #_method
    (defn #_"BigInteger" BitSieve''retrieve [#_"BitSieve" this, #_"BigInteger" initValue, #_"int" certainty, #_"Random" random]
        ;; examine the sieve one long at a time to find possible primes
        (let [
              #_"int" offset 1
        ]
            (loop-when-recur [#_"int" i 0] (ß i < this.bits.length) [(inc i)]
                (let [
                      #_"long" nextLong (ß (§ bit-not)this.bits[i])
                ]
                    (loop-when-recur [#_"int" j 0] (< j 64) [(inc j)]
                        (when (ß (nextLong & 1) == 1)
                            (let [
                                  #_"BigInteger" candidate (ß BigInteger''add(initValue, BigInteger'valueOf-l(offset)))
                            ]
                                (when (BigInteger''primeToCertainty candidate, certainty, random)
                                    (§ return candidate)
                                )
                            )
                        )
                        (§ ass nextLong (ß nextLong >>> 1))
                        (§ ass offset (+ offset 2))
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; A class used to represent multiprecision integers that makes efficient
 ; use of allocated space by allowing a number to occupy only part of
 ; an array so that the arrays do not have to be reallocated as often.
 ; When performing an operation with many iterations the array used to
 ; hold a number is only reallocated when necessary and does not have to
 ; be the same size as the number it represents. A mutable number allows
 ; calculations to occur on the same number without having to create
 ; a new number for every step of the calculation as occurs with
 ; BigIntegers.
 ;;

(class-ns MutableBigInteger
    ;;;
     ; Holds the magnitude of this MutableBigInteger in big endian order.
     ; The magnitude may start at an offset into the value array, and it may
     ; end before the length of the value array.
     ;;
    (§ field #_"int[]" :value nil)

    ;;;
     ; The number of ints of the value array that are currently used
     ; to hold the magnitude of this MutableBigInteger. The magnitude starts
     ; at an offset and offset + intLen may be less than value.length.
     ;;
    (§ field #_"int" :intLen 0)

    ;;;
     ; The offset into the value array where the magnitude of this
     ; MutableBigInteger begins.
     ;;
    (§ field #_"int" :offset 0)

    ;; constants

    ;;;
     ; MutableBigInteger with one element value array with the value 1. Use
     ; this constant only when the method is not going to modify this object.
     ;;
    (def #_"MutableBigInteger" MutableBigInteger'ONE (§ soon MutableBigInteger'new 1))

    ;;;
     ; The minimum {@code intLen} for cancelling powers of two before dividing.
     ; If the number of ints is less than this threshold,
     ; {@code divideKnuth} does not eliminate common powers of two from
     ; the dividend and divisor.
     ;;
    (def #_"int" MutableBigInteger'KNUTH_POW2_THRESH_LEN 6)

    ;;;
     ; The minimum number of trailing zero ints for cancelling powers of two before dividing.
     ; If the dividend and divisor don't share at least this many zero ints at the end,
     ; {@code divideKnuth} does not eliminate common powers of two from the dividend and divisor.
     ;;
    (def #_"int" MutableBigInteger'KNUTH_POW2_THRESH_ZEROS 3)

    ;; constructors

    ;;;
     ; The default constructor. An empty MutableBigInteger is created with a one word capacity.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'new []
        (let [this (§ new)
        ]
            (§ ass (:value this) (ß new int[1]))
            (§ ass (:intLen this) 0)
            this
        )
    )

    ;;;
     ; Construct a new MutableBigInteger with a magnitude specified by the int val.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'new [#_"int" val]
        (let [this (§ new)
        ]
            (§ ass (:value this) (ß new int[1]))
            (§ ass (:intLen this) 1)
            (§ ass (ß this.value[0]) val)
            this
        )
    )

    ;;;
     ; Construct a new MutableBigInteger with the specified value array
     ; up to the length of the array supplied.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'new [#_"int[]" val]
        (let [this (§ new)
        ]
            (§ ass (:value this) val)
            (§ ass (:intLen this) (ß val.length))
            this
        )
    )

    ;;;
     ; Construct a new MutableBigInteger with a magnitude equal to the
     ; specified BigInteger.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'new [#_"BigInteger" b]
        (let [this (§ new)
        ]
            (§ ass (:intLen this) (ß b.mag.length))
            (§ ass (:value this) (ß Arrays/copyOf(b.mag, b.mag.length)))
            this
        )
    )

    ;;;
     ; Construct a new MutableBigInteger with a magnitude equal to the
     ; specified MutableBigInteger.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'new [#_"MutableBigInteger" val]
        (let [this (§ new)
        ]
            (§ ass (:intLen this) (ß val.intLen))
            (§ ass (:value this) (ß Arrays/copyOfRange(val.value, val.offset, val.offset + val.intLen)))
            this
        )
    )

    ;;;
     ; Internal helper method to return the magnitude array. The caller is not
     ; supposed to modify the returned array.
     ;;
    #_method
    (defn- #_"int[]" MutableBigInteger''getMagnitudeArray [#_"MutableBigInteger" this]
        (when (or (ß this.offset > 0) (ß this.value.length != this.intLen))
            (§ return (ß Arrays/copyOfRange(this.value, this.offset, this.offset + this.intLen)))
        )
        (:value this)
    )

    ;;;
     ; Convert this MutableBigInteger to a long value. The caller has to make
     ; sure this MutableBigInteger can be fit into long.
     ;;
    #_method
    (defn- #_"long" MutableBigInteger''toLong [#_"MutableBigInteger" this]
        (when (ß this.intLen > 2)
            (throw! "exceeds the range of long")
        )
        (when (ß this.intLen == 0)
            (§ return 0)
        )
        (let [
              #_"long" d (ß this.value[this.offset] & BigInteger'LONG_MASK)
        ]
            (if (ß this.intLen == 2) (ß d << 32 | (this.value[this.offset + 1] & BigInteger'LONG_MASK)) d)
        )
    )

    ;;;
     ; Convert this MutableBigInteger to a BigInteger object.
     ;;
    #_method
    (defn #_"BigInteger" MutableBigInteger''toBigInteger-2 [#_"MutableBigInteger" this, #_"int" sign]
        (when (or (ß this.intLen == 0) (ß sign == 0))
            (§ return (ß BigInteger'ZERO))
        )
        (ß BigInteger'new(MutableBigInteger''getMagnitudeArray(this), sign))
    )

    (declare MutableBigInteger''normalize)

    ;;;
     ; Converts this number to a nonnegative {@code BigInteger}.
     ;;
    #_method
    (defn #_"BigInteger" MutableBigInteger''toBigInteger-1 [#_"MutableBigInteger" this]
        (MutableBigInteger''normalize this)
        (ß MutableBigInteger''toBigInteger-2(this, (if (MutableBigInteger''isZero this) 0 1)))
    )

    ;;;
     ; Clear out a MutableBigInteger for reuse.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''clear [#_"MutableBigInteger" this]
        (§ ass (:intLen this) 0)
        (§ ass (:offset this) 0)
        (let [
              #_"int" n (ß this.value.length)
        ]
            (loop-when-recur [#_"int" i 0] (< i n) [(inc i)]
                (§ ass (ß this.value[i]) 0)
            )
        )
        nil
    )

    ;;;
     ; Set a MutableBigInteger to zero, removing its offset.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''reset [#_"MutableBigInteger" this]
        (§ ass (:intLen this) 0)
        (§ ass (:offset this) 0)
        nil
    )

    ;;;
     ; Compare the magnitude of two MutableBigIntegers. Returns -1, 0 or 1
     ; as this MutableBigInteger is numerically less than, equal to, or
     ; greater than <tt>b</tt>.
     ;;
    #_method
    (defn #_"int" MutableBigInteger''compare [#_"MutableBigInteger" this, #_"MutableBigInteger" b]
        (let [
              #_"int" blen (:intLen b)
        ]
            (when (ß this.intLen < blen)
                (§ return -1)
            )
            (when (ß this.intLen > blen)
                (§ return 1)
            )

            ;; Add Integer.MIN_VALUE to make the comparison act as unsigned integer comparison.
            (let [
                  #_"int[]" bval (:value b)
            ]
                (loop-when-recur [#_"int" i (:offset this) #_"int" j (:offset b)] (ß i < this.intLen + this.offset) [(inc i) (inc j)]
                    (let [
                          #_"int" b1 (ß this.value[i] + 0x80000000)
                          #_"int" b2 (ß bval[j] + 0x80000000)
                    ]
                        (when (< b1 b2)
                            (§ return -1)
                        )
                        (when (< b2 b1)
                            (§ return 1)
                        )
                    )
                )
                0
            )
        )
    )

    ;;;
     ; Return the index of the lowest set bit in this MutableBigInteger.
     ; If the magnitude of this MutableBigInteger is zero, -1 is returned.
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''getLowestSetBit [#_"MutableBigInteger" this]
        (when (ß this.intLen == 0)
            (§ return -1)
        )
        (ß #_"int" j, b)
        (loop-when-recur [j (dec (:intLen this))] (and (ß j > 0) (ß this.value[j + this.offset] == 0)) [(dec j)]
        )
        (§ ass b (ß this.value[j + this.offset]))
        (when (ß b == 0)
            (§ return -1)
        )
        (ß ((this.intLen - 1 - j) << 5) + Integer/numberOfTrailingZeros(b))
    )

    ;;;
     ; Return the int in use in this MutableBigInteger at the specified index.
     ; This method is not used because it is not inlined on all platforms.
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''getInt [#_"MutableBigInteger" this, #_"int" index]
        (ß this.value[this.offset + index])
    )

    ;;;
     ; Return a long which is equal to the unsigned value of the int in
     ; use in this MutableBigInteger at the specified index. This method is
     ; not used because it is not inlined on all platforms.
     ;;
    #_method
    (defn- #_"long" MutableBigInteger''getLong [#_"MutableBigInteger" this, #_"int" index]
        (ß this.value[this.offset + index] & BigInteger'LONG_MASK)
    )

    ;;;
     ; Ensure that the MutableBigInteger is in normal form, specifically
     ; making sure that there are no leading zeros, and that if the
     ; magnitude is zero, then intLen is zero.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''normalize [#_"MutableBigInteger" this]
        (when (ß this.intLen == 0)
            (§ ass (:offset this) 0)
            (§ return nil)
        )

        (let [
              #_"int" index (:offset this)
        ]
            (when (ß this.value[index] != 0)
                (§ return nil)
            )

            (let [
                  #_"int" indexBound (ß index + this.intLen)
            ]
                (loop []
                    (§ ass index (inc index))
                    (recur-if (and (ß index < indexBound) (ß this.value[index] == 0)) [])
                )

                (let [
                      #_"int" numZeros (ß index - this.offset)
                ]
                    (§ ass (:intLen this) (ß this.intLen - numZeros))
                    (§ ass (:offset this) (if (ß this.intLen == 0) 0 (ß this.offset + numZeros)))
                )
            )
        )
        nil
    )

    ;;;
     ; If this MutableBigInteger cannot hold len words, increase the size
     ; of the value array to len words.
     ;;
    #_method
    (defn- #_"void" MutableBigInteger''ensureCapacity [#_"MutableBigInteger" this, #_"int" len]
        (when (ß this.value.length < len)
            (§ ass (:value this) (ß new int[len]))
            (§ ass (:offset this) 0)
            (§ ass (:intLen this) len)
        )
        nil
    )

    ;;;
     ; Convert this MutableBigInteger into an int array with no leading
     ; zeros, of a length that is equal to this MutableBigInteger's intLen.
     ;;
    #_method
    (defn #_"int[]" MutableBigInteger''toIntArray [#_"MutableBigInteger" this]
        (let [
              #_"int[]" result (ß new int[this.intLen])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < this.intLen) [(inc i)]
                (§ ass (aget result i) (ß this.value[this.offset + i]))
            )
            result
        )
    )

    ;;;
     ; Sets the int at index+offset in this MutableBigInteger to val.
     ; This does not get inlined on all platforms so it is not used
     ; as often as originally intended.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''setInt [#_"MutableBigInteger" this, #_"int" index, #_"int" val]
        (let [
        ]
            (§ ass (ß this.value[this.offset + index]) val)
        )
        nil
    )

    ;;;
     ; Sets this MutableBigInteger's value array to the specified array.
     ; The intLen is set to the specified length.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''setValue [#_"MutableBigInteger" this, #_"int[]" val, #_"int" length]
        (let [
        ]
            (§ ass (:value this) val)
            (§ ass (:intLen this) length)
            (§ ass (:offset this) 0)
        )
        nil
    )

    ;;;
     ; Sets this MutableBigInteger's value array to a copy of the specified array.
     ; The intLen is set to the length of the new array.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''copyValue-m [#_"MutableBigInteger" this, #_"MutableBigInteger" src]
        (let [
              #_"int" len (ß src.intLen)
        ]
            (when (ß this.value.length < len)
                (§ ass (:value this) (ß new int[len]))
            )
            (ß System/arraycopy(src.value, src.offset, this.value, 0, len))
            (§ ass (:intLen this) len)
            (§ ass (:offset this) 0)
        )
        nil
    )

    ;;;
     ; Sets this MutableBigInteger's value array to a copy of the specified array.
     ; The intLen is set to the length of the specified array.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''copyValue-a [#_"MutableBigInteger" this, #_"int[]" val]
        (let [
              #_"int" len (ß val.length)
        ]
            (when (ß this.value.length < len)
                (§ ass (:value this) (ß new int[len]))
            )
            (ß System/arraycopy(val, 0, this.value, 0, len))
            (§ ass (:intLen this) len)
            (§ ass (:offset this) 0)
        )
        nil
    )

    ;;;
     ; Returns true iff this MutableBigInteger has a value of one.
     ;;
    #_method
    (defn #_"boolean" MutableBigInteger''isOne [#_"MutableBigInteger" this]
        (and (ß this.intLen == 1) (ß this.value[this.offset] == 1))
    )

    ;;;
     ; Returns true iff this MutableBigInteger has a value of zero.
     ;;
    #_method
    (defn #_"boolean" MutableBigInteger''isZero [#_"MutableBigInteger" this]
        (ß (this.intLen == 0))
    )

    ;;;
     ; Returns true iff this MutableBigInteger is even.
     ;;
    #_method
    (defn #_"boolean" MutableBigInteger''isEven [#_"MutableBigInteger" this]
        (or (ß this.intLen == 0) (ß (this.value[this.offset + this.intLen - 1] & 1) == 0))
    )

    ;;;
     ; Returns true iff this MutableBigInteger is odd.
     ;;
    #_method
    (defn #_"boolean" MutableBigInteger''isOdd [#_"MutableBigInteger" this]
        (if (MutableBigInteger''isZero this) false (ß (this.value[this.offset + this.intLen - 1] & 1) == 1))
    )

    ;;;
     ; Returns true iff this MutableBigInteger is in normal form.
     ; A MutableBigInteger is in normal form if it has no leading zeros
     ; after the offset, and intLen + offset <= value.length.
     ;;
    #_method
    (defn #_"boolean" MutableBigInteger''isNormal [#_"MutableBigInteger" this]
        (when (ß this.intLen + this.offset > this.value.length)
            (§ return false)
        )
        (when (ß this.intLen == 0)
            (§ return true)
        )
        (ß (this.value[this.offset] != 0))
    )

    ;;;
     ; Returns a String representation of this MutableBigInteger in radix 10.
     ;;
    #_foreign
    (defn #_"String" toString---MutableBigInteger [#_"MutableBigInteger" this]
        (let [
              #_"BigInteger" b (MutableBigInteger''toBigInteger-2 this, 1)
        ]
            (ß b.toString())
        )
    )

    (declare MutableBigInteger''primitiveLeftShift)
    (declare MutableBigInteger''primitiveRightShift)

    ;;;
     ; Right shift this MutableBigInteger n bits.
     ; The MutableBigInteger is left in normal form.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''rightShift [#_"MutableBigInteger" this, #_"int" n]
        (when (ß this.intLen == 0)
            (§ return nil)
        )
        (let [
              #_"int" nInts (ß n >>> 5)
              #_"int" nBits (ß n & 0x1f)
        ]
            (§ ass (:intLen this) (ß this.intLen - nInts))
            (when (ß nBits == 0)
                (§ return nil)
            )
            (let [
                  #_"int" bitsInHighWord (ß BigInteger'bitLengthForInt(this.value[this.offset]))
            ]
                (cond (<= bitsInHighWord nBits)
                    (do
                        (MutableBigInteger''primitiveLeftShift this, (- 32 nBits))
                        (§ ass (:intLen this) (ß this.intLen - 1))
                    )
                    :else
                    (do
                        (MutableBigInteger''primitiveRightShift this, nBits)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Left shift this MutableBigInteger n bits.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''leftShift [#_"MutableBigInteger" this, #_"int" n]
        ;;
         ; If there is enough storage space in this MutableBigInteger already
         ; the available space will be used. Space to the right of the used
         ; ints in the value array is faster to utilize, so the extra space
         ; will be taken from the right if possible.
         ;;
        (when (ß this.intLen == 0)
            (§ return nil)
        )
        (let [
              #_"int" nInts (ß n >>> 5)
              #_"int" nBits (ß n & 0x1f)
              #_"int" bitsInHighWord (ß BigInteger'bitLengthForInt(this.value[this.offset]))
        ]
            ;; if shift can be done without moving words, do so
            (when (ß n <= (32 - bitsInHighWord))
                (MutableBigInteger''primitiveLeftShift this, nBits)
                (§ return nil)
            )

            (let [
                  #_"int" newLen (ß this.intLen + nInts +1)
            ]
                (when (ß nBits <= (32 - bitsInHighWord))
                    (§ ass newLen (dec newLen))
                )
                (cond (ß this.value.length < newLen) ;; the array must grow
                    (let [
                          #_"int[]" result (ß new int[newLen])
                    ]
                        (loop-when-recur [#_"int" i 0] (ß i < this.intLen) [(inc i)]
                            (§ ass (aget result i) (ß this.value[this.offset + i]))
                        )
                        (MutableBigInteger''setValue this, result, newLen)
                    )
                    (ß this.value.length - this.offset >= newLen) ;; use space on right
                    (do
                        (loop-when-recur [#_"int" i 0] (ß i < newLen - this.intLen) [(inc i)]
                            (§ ass (ß this.value[this.offset + this.intLen + i]) 0)
                        )
                    )
                    :else ;; must use space on left
                    (do
                        (loop-when-recur [#_"int" i 0] (ß i < this.intLen) [(inc i)]
                            (§ ass (ß this.value[i]) (ß this.value[this.offset + i]))
                        )
                        (loop-when-recur [#_"int" i (:intLen this)] (< i newLen) [(inc i)]
                            (§ ass (ß this.value[i]) 0)
                        )
                        (§ ass (:offset this) 0)
                    )
                )
                (§ ass (:intLen this) newLen)
                (when (ß nBits == 0)
                    (§ return nil)
                )
                (if (ß nBits <= (32 - bitsInHighWord))
                    (MutableBigInteger''primitiveLeftShift this, nBits)
                    (MutableBigInteger''primitiveRightShift this, (- 32 nBits))
                )
            )
        )
        nil
    )

    ;;;
     ; A primitive used for division. This method adds in one multiple of the
     ; divisor a back to the dividend result at a specified offset. It is used
     ; when qhat was estimated too large, and must be adjusted.
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''divadd [#_"MutableBigInteger" this, #_"int[]" a, #_"int[]" result, #_"int" offset]
        (let [
              #_"long" carry 0
        ]
            (loop-when-recur [#_"int" j (ß a.length - 1)] (<= 0 j) [(dec j)]
                (let [
                      #_"long" sum (ß (a[j] & BigInteger'LONG_MASK) + (result[j + offset] & BigInteger'LONG_MASK) + carry)
                ]
                    (§ ass (aget result (+ j offset)) (ß (int)sum))
                    (§ ass carry (ß sum >>> 32))
                )
            )
            (ß (int)carry)
        )
    )

    ;;;
     ; This method is used for division. It multiplies an n word input a by one
     ; word input x, and subtracts the n word product from q. This is needed
     ; when subtracting qhat*divisor from dividend.
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''mulsub [#_"MutableBigInteger" this, #_"int[]" q, #_"int[]" a, #_"int" x, #_"int" len, #_"int" offset]
        (let [
              #_"long" xLong (ß x & BigInteger'LONG_MASK)
              #_"long" carry 0
              _ (§ ass offset (+ offset len))
        ]
            (loop-when-recur [#_"int" j (dec len)] (<= 0 j) [(dec j)]
                (let [
                      #_"long" product (ß (a[j] & BigInteger'LONG_MASK) * xLong + carry)
                      #_"long" difference (ß q[offset] - product)
                ]
                    (§ ass (aget q offset) (ß (int)difference))
                    (§ ass offset (dec offset))
                    (§ ass carry (ß (product >>> 32) + (if (ß (difference & BigInteger'LONG_MASK) > ((((§ bit-not)(int)product) & BigInteger'LONG_MASK))) 1 0)))
                )
            )
            (ß (int)carry)
        )
    )

    ;;;
     ; The method is the same as mulsun, except the fact that q array is not
     ; updated, the only result of the method is borrow flag.
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''mulsubBorrow [#_"MutableBigInteger" this, #_"int[]" q, #_"int[]" a, #_"int" x, #_"int" len, #_"int" offset]
        (let [
              #_"long" xLong (ß x & BigInteger'LONG_MASK)
              #_"long" carry 0
              _ (§ ass offset (+ offset len))
        ]
            (loop-when-recur [#_"int" j (dec len)] (<= 0 j) [(dec j)]
                (let [
                      #_"long" product (ß (a[j] & BigInteger'LONG_MASK) * xLong + carry)
                      #_"long" difference (ß q[offset] - product)
                ]
                    (§ ass offset (dec offset))
                    (§ ass carry (ß (product >>> 32) + (if (ß (difference & BigInteger'LONG_MASK) > ((((§ bit-not)(int)product) & BigInteger'LONG_MASK))) 1 0)))
                )
            )
            (ß (int)carry)
        )
    )

    ;;;
     ; Right shift this MutableBigInteger n bits, where n is less than 32.
     ; Assumes that intLen > 0 and n > 0 for speed.
     ;;
    #_method
    (defn- #_"void" MutableBigInteger''primitiveRightShift [#_"MutableBigInteger" this, #_"int" n]
        (let [
              #_"int[]" val (:value this)
              #_"int" n2 (- 32 n)
        ]
            (loop-when-recur [#_"int" i (ß this.offset + this.intLen - 1) #_"int" c (aget val i)] (ß i > this.offset) [(dec i) c]
                (let [
                      #_"int" b c
                ]
                    (§ ass c (aget val (dec i)))
                    (§ ass (aget val i) (ß (c << n2) | (b >>> n)))
                )
            )
            (§ ass (aget val (ß this.offset)) (ß val[this.offset] >>> n))
        )
        nil
    )

    ;;;
     ; Left shift this MutableBigInteger n bits, where n is less than 32.
     ; Assumes that intLen > 0 and n > 0 for speed.
     ;;
    #_method
    (defn- #_"void" MutableBigInteger''primitiveLeftShift [#_"MutableBigInteger" this, #_"int" n]
        (let [
              #_"int[]" val (:value this)
              #_"int" n2 (- 32 n)
        ]
            (loop-when-recur [#_"int" i (:offset this) #_"int" c (aget val i) #_"int" m (ß i + this.intLen - 1)] (< i m) [(inc i) c m]
                (let [
                      #_"int" b c
                ]
                    (§ ass c (aget val (inc i)))
                    (§ ass (aget val i) (ß (b << n) | (c >>> n2)))
                )
            )
            (§ ass (aget val (ß this.offset + this.intLen - 1)) (ß val[this.offset + this.intLen - 1] << n))
        )
        nil
    )

    ;;;
     ; Adds the contents of two MutableBigInteger objects.
     ; The result is placed within this MutableBigInteger.
     ; The contents of the addend are not changed.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''add [#_"MutableBigInteger" this, #_"MutableBigInteger" addend]
        (let [
              #_"int" x (:intLen this)
              #_"int" y (ß addend.intLen)
              #_"int" resultLen (if (ß this.intLen > addend.intLen) (:intLen this) (ß addend.intLen))
              #_"int[]" result (if (ß this.value.length < resultLen) (ß new int[resultLen]) (:value this))
              #_"int" rstart (ß result.length - 1)
              #_"long" sum (ß )
              #_"long" carry 0

        ]
            ;; add common parts of both numbers
            (while (and (ß x > 0) (ß y > 0))
                (§ ass x (dec x))
                (§ ass y (dec y))
                (§ ass sum (ß (this.value[x + this.offset] & BigInteger'LONG_MASK) + (addend.value[y + addend.offset] & BigInteger'LONG_MASK) + carry))
                (§ ass (aget result rstart) (ß (int)sum))
                (§ ass rstart (dec rstart))
                (§ ass carry (ß sum >>> 32))
            )

            ;; add remainder of the longer number
            (while (< 0 x)
                (let [
                ]
                    (§ ass x (dec x))
                    (when (and (ß carry == 0) (ß result == this.value) (ß rstart == (x + this.offset)))
                        (§ return nil)
                    )
                    (§ ass sum (ß (this.value[x + this.offset] & BigInteger'LONG_MASK) + carry))
                    (§ ass (aget result rstart) (ß (int)sum))
                    (§ ass rstart (dec rstart))
                    (§ ass carry (ß sum >>> 32))
                )
            )
            (while (< 0 y)
                (§ ass y (dec y))
                (§ ass sum (ß (addend.value[y + addend.offset] & BigInteger'LONG_MASK) + carry))
                (§ ass (aget result rstart) (ß (int)sum))
                (§ ass rstart (dec rstart))
                (§ ass carry (ß sum >>> 32))
            )

            (when (< 0 carry) ;; result must grow in length
                (let [
                ]
                    (§ ass resultLen (inc resultLen))
                    (cond (ß result.length < resultLen)
                        (let [
                              #_"int[]" temp (ß new int[resultLen])
                        ]
                            ;; result one word longer from carry-out,
                            ;; copy low-order bits into new result
                            (ß System/arraycopy(result, 0, temp, 1, result.length))
                            (§ ass (aget temp 0) 1)
                            (§ ass result temp)
                        )
                        :else
                        (do
                            (§ ass (aget result rstart) 1)
                            (§ ass rstart (dec rstart))
                        )
                    )
                )
            )

            (§ ass (:value this) result)
            (§ ass (:intLen this) resultLen)
            (§ ass (:offset this) (ß result.length - resultLen))
        )
        nil
    )

    ;;;
     ; Subtracts the smaller of this and b from the larger and places the
     ; result into this MutableBigInteger.
     ;;
    #_method
    (defn #_"int" MutableBigInteger''subtract [#_"MutableBigInteger" this, #_"MutableBigInteger" b]
        (let [
              #_"MutableBigInteger" a this
              #_"int[]" result (:value this)
              #_"int" sign (MutableBigInteger''compare a, b)
        ]
            (when (ß sign == 0)
                (MutableBigInteger''reset this)
                (§ return 0)
            )
            (when (< sign 0)
                (let [
                      #_"MutableBigInteger" tmp a
                ]
                    (§ ass a b)
                    (§ ass b tmp)
                )
            )

            (let [
                  #_"int" resultLen (:intLen a)
            ]
                (when (ß result.length < resultLen)
                    (§ ass result (ß new int[resultLen]))
                )

                (let [
                      #_"long" diff 0
                      #_"int" x (:intLen a)
                      #_"int" y (:intLen b)
                      #_"int" rstart (ß result.length - 1)
                ]
                    ;; subtract common parts of both numbers
                    (while (< 0 y)
                        (§ ass x (dec x))
                        (§ ass y (dec y))
                        (§ ass diff (ß (a.value[x + a.offset] & BigInteger'LONG_MASK) - (b.value[y + b.offset] & BigInteger'LONG_MASK) - ((int)-(diff >> 32))))
                        (§ ass (aget result rstart) (ß (int)diff))
                        (§ ass rstart (dec rstart))
                    )
                    ;; subtract remainder of longer number
                    (while (< 0 x)
                        (§ ass x (dec x))
                        (§ ass diff (ß (a.value[x + a.offset] & BigInteger'LONG_MASK) - ((int)-(diff >> 32))))
                        (§ ass (aget result rstart) (ß (int)diff))
                        (§ ass rstart (dec rstart))
                    )

                    (§ ass (:value this) result)
                    (§ ass (:intLen this) resultLen)
                    (§ ass (:offset this) (ß this.value.length - resultLen))
                    (MutableBigInteger''normalize this)
                    sign
                )
            )
        )
    )

    ;;;
     ; Subtracts the smaller of a and b from the larger and places the result into the larger.
     ; Returns 1 if the answer is in a, -1 if in b, 0 if no operation was performed.
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''difference [#_"MutableBigInteger" this, #_"MutableBigInteger" b]
        (let [
              #_"MutableBigInteger" a this
              #_"int" sign (MutableBigInteger''compare a, b)
        ]
            (when (ß sign == 0)
                (§ return 0)
            )
            (when (< sign 0)
                (let [
                      #_"MutableBigInteger" tmp a
                ]
                    (§ ass a b)
                    (§ ass b tmp)
                )
            )

            (let [
                  #_"long" diff 0
                  #_"int" x (:intLen a)
                  #_"int" y (:intLen b)
            ]
                ;; subtract common parts of both numbers
                (while (< 0 y)
                    (§ ass x (dec x))
                    (§ ass y (dec y))
                    (§ ass diff (ß (a.value[a.offset + x] & BigInteger'LONG_MASK) - (b.value[b.offset + y] & BigInteger'LONG_MASK) - ((int)-(diff >> 32))))
                    (§ ass (ß a.value[a.offset + x]) (ß (int)diff))
                )
                ;; subtract remainder of longer number
                (while (< 0 x)
                    (§ ass x (dec x))
                    (§ ass diff (ß (a.value[a.offset + x] & BigInteger'LONG_MASK) - ((int)-(diff >> 32))))
                    (§ ass (ß a.value[a.offset + x]) (ß (int)diff))
                )

                (MutableBigInteger''normalize a)
                sign
            )
        )
    )

    ;;;
     ; Multiply the contents of two MutableBigInteger objects. The result is
     ; placed into MutableBigInteger z. The contents of y are not changed.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''multiply [#_"MutableBigInteger" this, #_"MutableBigInteger" y, #_"MutableBigInteger" z]
        (let [
              #_"int" xLen (:intLen this)
              #_"int" yLen (:intLen y)
              #_"int" newLen (+ xLen yLen)
        ]
            ;; put z into an appropriate state to receive product
            (when (ß z.value.length < newLen)
                (§ ass (:value z) (ß new int[newLen]))
            )
            (§ ass (:offset z) 0)
            (§ ass (:intLen z) newLen)

            ;; the first iteration is hoisted out of the loop to avoid extra add
            (let [
                  #_"long" carry 0
            ]
                (loop-when-recur [#_"int" j (dec yLen) #_"int" k (ß yLen + xLen - 1)] (<= 0 j) [(dec j) (dec k)]
                    (let [
                          #_"long" product (ß (y.value[j + y.offset] & BigInteger'LONG_MASK) * (this.value[xLen - 1 + this.offset] & BigInteger'LONG_MASK) + carry)
                    ]
                        (§ ass (ß z.value[k]) (ß (int)product))
                        (§ ass carry (ß product >>> 32))
                    )
                )
                (§ ass (ß z.value[xLen - 1]) (ß (int)carry))

                ;; perform the multiplication word by word
                (loop-when-recur [#_"int" i (- xLen 2)] (<= 0 i) [(dec i)]
                    (let [
                    ]
                        (§ ass carry 0)
                        (loop-when-recur [#_"int" j (dec yLen) #_"int" k (+ yLen i)] (<= 0 j) [(dec j) (dec k)]
                            (let [
                                  #_"long" product (ß (y.value[j + y.offset] & BigInteger'LONG_MASK) * (this.value[i + this.offset] & BigInteger'LONG_MASK) + (z.value[k] & BigInteger'LONG_MASK) + carry)
                            ]
                                (§ ass (ß z.value[k]) (ß (int)product))
                                (§ ass carry (ß product >>> 32))
                            )
                        )
                        (§ ass (ß z.value[i]) (ß (int)carry))
                    )
                )

                ;; remove leading zeros from product
                (MutableBigInteger''normalize z)
            )
        )
        nil
    )

    ;;;
     ; Multiply the contents of this MutableBigInteger by the word y.
     ; The result is placed into z.
     ;;
    #_method
    (defn #_"void" MutableBigInteger''mul [#_"MutableBigInteger" this, #_"int" y, #_"MutableBigInteger" z]
        (when (ß y == 1)
            (MutableBigInteger''copyValue-m z, this)
            (§ return nil)
        )

        (when (ß y == 0)
            (MutableBigInteger''clear z)
            (§ return nil)
        )

        ;; perform the multiplication word by word
        (let [
              #_"long" ylong (ß y & BigInteger'LONG_MASK)
              #_"int[]" zval (if (ß z.value.length < this.intLen + 1) (ß new int[this.intLen + 1]) (:value z))
              #_"long" carry 0
        ]
            (loop-when-recur [#_"int" i (ß this.intLen - 1)] (<= 0 i) [(dec i)]
                (let [
                      #_"long" product (ß ylong * (this.value[i + this.offset] & BigInteger'LONG_MASK) + carry)
                ]
                    (§ ass (aget zval (inc i)) (ß (int)product))
                    (§ ass carry (ß product >>> 32))
                )
            )

            (cond (ß carry == 0)
                (do
                    (§ ass (:offset z) 1)
                    (§ ass (:intLen z) (:intLen this))
                )
                :else
                (do
                    (§ ass (:offset z) 0)
                    (§ ass (:intLen z) (ß this.intLen + 1))
                    (§ ass (aget zval 0) (ß (int)carry))
                )
            )
            (§ ass (:value z) zval)
            nil
        )
    )

    (declare MutableBigInteger'divWord)

    ;;;
     ; This method is used for division of an n word dividend by a one word divisor.
     ; The quotient is placed into quotient. The one word divisor is specified by divisor.
     ;
     ; @return the remainder of the division is returned.
     ;;
    #_method
    (defn #_"int" MutableBigInteger''divideOneWord [#_"MutableBigInteger" this, #_"int" divisor, #_"MutableBigInteger" quotient]
        (let [
              #_"long" divisorLong (ß divisor & BigInteger'LONG_MASK)
        ]
            ;; special case of one word dividend
            (when (ß this.intLen == 1)
                (let [
                      #_"long" dividendValue (ß this.value[this.offset] & BigInteger'LONG_MASK)
                      #_"int" q (ß (int) (dividendValue / divisorLong))
                      #_"int" r (ß (int) (dividendValue - q * divisorLong))
                ]
                    (§ ass (ß quotient.value[0]) q)
                    (§ ass (ß quotient.intLen) (if (ß q == 0) 0 1))
                    (§ ass (ß quotient.offset) 0)
                    (§ return r)
                )
            )

            (when (ß quotient.value.length < this.intLen)
                (§ ass (ß quotient.value) (ß new int[this.intLen]))
            )
            (§ ass (ß quotient.offset) 0)
            (§ ass (ß quotient.intLen) (:intLen this))

            ;; normalize the divisor
            (let [
                  #_"int" shift (ß Integer/numberOfLeadingZeros(divisor))
                  #_"int" rem (ß this.value[this.offset])
                  #_"long" remLong (ß rem & BigInteger'LONG_MASK)
            ]
                (cond (< remLong divisorLong)
                    (do
                        (§ ass (ß quotient.value[0]) 0)
                    )
                    :else
                    (do
                        (§ ass (ß quotient.value[0]) (ß (int)(remLong / divisorLong)))
                        (§ ass rem (ß (int) (remLong - (quotient.value[0] * divisorLong))))
                        (§ ass remLong (ß rem & BigInteger'LONG_MASK))
                    )
                )
                (let [
                      #_"int" xlen (:intLen this)
                ]
                    (loop-when-recur [xlen (dec xlen)] (< 0 xlen) [(dec xlen)]
                        (let [
                              #_"long" dividendEstimate (ß (remLong << 32) | (this.value[this.offset + this.intLen - xlen] & BigInteger'LONG_MASK))
                        ]
                            (ß #_"int" q)
                            (cond (<= 0 dividendEstimate)
                                (do
                                    (§ ass q (ß (int) (dividendEstimate / divisorLong)))
                                    (§ ass rem (ß (int) (dividendEstimate - q * divisorLong)))
                                )
                                :else
                                (let [
                                      #_"long" tmp (MutableBigInteger'divWord dividendEstimate, divisor)
                                ]
                                    (§ ass q (ß (int) (tmp & BigInteger'LONG_MASK)))
                                    (§ ass rem (ß (int) (tmp >>> 32)))
                                )
                            )
                            (§ ass (ß quotient.value[this.intLen - xlen]) q)
                            (§ ass remLong (ß rem & BigInteger'LONG_MASK))
                        )
                    )

                    (MutableBigInteger''normalize quotient)
                    ;; unnormalize
                    (cond (< 0 shift)
                        (do
                            (§ return (ß rem % divisor))
                        )
                        :else
                        (do
                            (§ return rem)
                        )
                    )
                )
            )
        )
    )

    (declare MutableBigInteger''divide-4)

    ;;;
     ; Calculates the quotient of this div b and places the quotient in the
     ; provided MutableBigInteger objects and the remainder object is returned.
     ;;
    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''divide-3 [#_"MutableBigInteger" this, #_"MutableBigInteger" b, #_"MutableBigInteger" quotient]
        (MutableBigInteger''divide-4 this, b, quotient, true)
    )

    (declare MutableBigInteger''divideKnuth-4)

    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''divide-4 [#_"MutableBigInteger" this, #_"MutableBigInteger" b, #_"MutableBigInteger" quotient, #_"boolean" needRemainder]
        (MutableBigInteger''divideKnuth-4 this, b, quotient, needRemainder)
    )

    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''divideKnuth [#_"MutableBigInteger" this, #_"MutableBigInteger" b, #_"MutableBigInteger" quotient]
        (MutableBigInteger''divideKnuth-4 this, b, quotient, true)
    )

    (declare MutableBigInteger''divideKnuth-3)
    (declare MutableBigInteger''divideMagnitude)

    ;;;
     ; Calculates the quotient of this div b and places the quotient in the
     ; provided MutableBigInteger objects and the remainder object is returned.
     ;
     ; Uses Algorithm D in Knuth section 4.3.1.
     ; Many optimizations to that algorithm have been adapted from the Colin Plumb C library.
     ; It special cases one word divisors for speed. The content of b is not changed.
     ;;
    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''divideKnuth [#_"MutableBigInteger" this, #_"MutableBigInteger" b, #_"MutableBigInteger" quotient, #_"boolean" needRemainder]
        (when (ß b.intLen == 0)
            (throw! "divide by zero")
        )

        ;; dividend is zero
        (when (ß this.intLen == 0)
            (§ ass (ß quotient.offset) 0)
            (§ ass (ß quotient.intLen) 0)
            (§ return (when needRemainder (MutableBigInteger'new)))
        )

        (let [
              #_"int" cmp (MutableBigInteger''compare this, b)
        ]
            ;; dividend less than divisor
            (when (< cmp 0)
                (§ ass (ß quotient.offset) 0)
                (§ ass (ß quotient.intLen) 0)
                (§ return (when needRemainder (MutableBigInteger'new this)))
            )
            ;; dividend equal to divisor
            (when (ß cmp == 0)
                (§ ass (ß quotient.offset) 0)
                (§ ass (ß quotient.value[0]) 1)
                (§ ass (ß quotient.intLen) 1)
                (§ return (when needRemainder (MutableBigInteger'new)))
            )

            (MutableBigInteger''clear quotient)
            ;; special case one word divisor
            (when (ß b.intLen == 1)
                (let [
                      #_"int" r (ß MutableBigInteger''divideOneWord(this, b.value[b.offset], quotient))
                ]
                    (cond needRemainder
                        (do
                            (when (ß r == 0)
                                (§ return (MutableBigInteger'new))
                            )
                            (§ return (MutableBigInteger'new r))
                        )
                        :else
                        (do
                            (§ return nil)
                        )
                    )
                )
            )

            ;; cancel common powers of two if we're above the KNUTH_POW2_* thresholds
            (when (ß this.intLen >= MutableBigInteger'KNUTH_POW2_THRESH_LEN)
                (let [
                      #_"int" trailingZeroBits (ß Math/min(MutableBigInteger''getLowestSetBit(this), MutableBigInteger''getLowestSetBit(b)))
                ]
                    (when (ß trailingZeroBits >= MutableBigInteger'KNUTH_POW2_THRESH_ZEROS * 32)
                        (let [
                              #_"MutableBigInteger" a (MutableBigInteger'new this)
                        ]
                            (§ ass b (MutableBigInteger'new b))
                            (MutableBigInteger''rightShift a, trailingZeroBits)
                            (MutableBigInteger''rightShift b, trailingZeroBits)
                            (let [
                                  #_"MutableBigInteger" r (MutableBigInteger''divideKnuth-3 a, b, quotient)
                            ]
                                (MutableBigInteger''leftShift r, trailingZeroBits)
                                (§ return r)
                            )
                        )
                    )
                )
            )

            (MutableBigInteger''divideMagnitude this, b, quotient, needRemainder)
        )
    )

    #_method
    (defn #_"long" MutableBigInteger''bitLength [#_"MutableBigInteger" this]
        (when (ß this.intLen == 0)
            (§ return 0)
        )
        (ß this.intLen * 32 - Integer/numberOfLeadingZeros(this.value[this.offset]))
    )

    (defn- #_"void" MutableBigInteger'copyAndShift [#_"int[]" src, #_"int" srcFrom, #_"int" srcLen, #_"int[]" dst, #_"int" dstFrom, #_"int" shift]
        (let [
              #_"int" n2 (- 32 shift)
              #_"int" c (aget src srcFrom)
        ]
            (loop-when-recur [#_"int" i 0] (ß i < srcLen - 1) [(inc i)]
                (let [
                      #_"int" b c
                ]
                    (§ ass srcFrom (inc srcFrom))
                    (§ ass c (aget src srcFrom))
                    (§ ass (aget dst (+ dstFrom i)) (ß (b << shift) | (c >>> n2)))
                )
            )
            (§ ass (aget dst (ß dstFrom + srcLen - 1)) (ß c << shift))
        )
        nil
    )

    (declare MutableBigInteger''unsignedLongCompare)

    ;;;
     ; Divide this MutableBigInteger by the divisor.
     ; The quotient will be placed into the provided quotient object &
     ; the remainder object is returned.
     ;;
    #_method
    (defn- #_"MutableBigInteger" MutableBigInteger''divideMagnitude [#_"MutableBigInteger" this, #_"MutableBigInteger" div, #_"MutableBigInteger" quotient, #_"boolean" needRemainder]
        (when (< (ß div.intLen) 2)
            (throw! "(< (ß div.intLen) 2)")
        )
        ;; D1 normalize the divisor
        (let [
              #_"int" shift (ß Integer/numberOfLeadingZeros(div.value[div.offset]))
              ;; copy divisor value to protect divisor
              #_"int" dlen (ß div.intLen)
              #_"int[]" divisor (ß )
              ;; remainder starts as dividend with space for a leading zero
              #_"MutableBigInteger" rem (ß )
        ]
            (cond (< 0 shift)
                (do
                    (§ ass divisor (ß new int[dlen]))
                    (ß MutableBigInteger'copyAndShift(div.value, div.offset, dlen, divisor, 0, shift))
                    (cond (ß Integer/numberOfLeadingZeros(this.value[this.offset]) >= shift)
                        (let [
                              #_"int[]" remarr (ß new int[this.intLen + 1])
                        ]
                            (§ ass rem (MutableBigInteger'new remarr))
                            (§ ass (ß rem.intLen) (:intLen this))
                            (§ ass (ß rem.offset) 1)
                            (ß MutableBigInteger'copyAndShift(this.value, this.offset, this.intLen, remarr, 1, shift))
                        )
                        :else
                        (let [
                              #_"int[]" remarr (ß new int[this.intLen + 2])
                        ]
                            (§ ass rem (MutableBigInteger'new remarr))
                            (§ ass (ß rem.intLen) (ß this.intLen + 1))
                            (§ ass (ß rem.offset) 1)
                            (let [
                                  #_"int" c 0
                                  #_"int" n2 (- 32 shift)
                            ]
                                (loop-when-recur [#_"int" rFrom (:offset this) #_"int" i 1] (ß i < this.intLen + 1) [(inc rFrom) (inc i)]
                                    (let [
                                          #_"int" b c
                                    ]
                                        (§ ass c (ß this.value[rFrom]))
                                        (§ ass (aget remarr i) (ß (b << shift) | (c >>> n2)))
                                    )
                                )
                                (§ ass (aget remarr (ß this.intLen + 1)) (ß c << shift))
                            )
                        )
                    )
                )
                :else
                (do
                    (§ ass divisor (ß Arrays/copyOfRange(div.value, div.offset, div.offset + div.intLen)))
                    (§ ass rem (ß MutableBigInteger'new(new int[this.intLen + 1])))
                    (ß System/arraycopy(this.value, this.offset, rem.value, 1, this.intLen))
                    (§ ass (ß rem.intLen) (:intLen this))
                    (§ ass (ß rem.offset) 1)
                )
            )

            (let [
                  #_"int" nlen (ß rem.intLen)
                  ;; set the quotient size
                  #_"int" limit (ß nlen - dlen + 1)
            ]
                (when (ß quotient.value.length < limit)
                    (§ ass (ß quotient.value) (ß new int[limit]))
                    (§ ass (ß quotient.offset) 0)
                )
                (§ ass (ß quotient.intLen) limit)
                (let [
                      #_"int[]" q (ß quotient.value)
                ]
                    ;; must insert leading 0 in rem if its length did not change
                    (when (ß rem.intLen == nlen)
                        (§ ass (ß rem.offset) 0)
                        (§ ass (ß rem.value[0]) 0)
                        (§ ass (ß rem.intLen) (ß rem.intLen + 1))
                    )

                    (let [
                          #_"int" dh (§ soon aget divisor 0)
                          #_"long" dhLong (ß dh & BigInteger'LONG_MASK)
                          #_"int" dl (§ soon aget divisor 1)
                    ]
                        ;; D2 Initialize j
                        (loop-when-recur [#_"int" j 0] (ß j < limit - 1) [(inc j)]
                            ;; D3 Calculate qhat
                            ;; estimate qhat
                            (let [
                                  #_"int" qhat 0
                                  #_"int" qrem 0
                                  #_"boolean" skipCorrection false
                                  #_"int" nh (ß rem.value[j + rem.offset])
                                  #_"int" nh2 (+ nh 0x80000000)
                                  #_"int" nm (ß rem.value[j + 1 + rem.offset])
                            ]
                                (cond (ß nh == dh)
                                    (do
                                        (§ ass qhat (ß (§ bit-not)0))
                                        (§ ass qrem (+ nh nm))
                                        (§ ass skipCorrection (ß qrem + 0x80000000 < nh2))
                                    )
                                    :else
                                    (let [
                                          #_"long" nChunk (ß (((long)nh) << 32) | (nm & BigInteger'LONG_MASK))
                                    ]
                                        (cond (<= 0 nChunk)
                                            (do
                                                (§ ass qhat (ß (int) (nChunk / dhLong)))
                                                (§ ass qrem (ß (int) (nChunk - (qhat * dhLong))))
                                            )
                                            :else
                                            (let [
                                                  #_"long" tmp (MutableBigInteger'divWord nChunk, dh)
                                            ]
                                                (§ ass qhat (ß (int) (tmp & BigInteger'LONG_MASK)))
                                                (§ ass qrem (ß (int) (tmp >>> 32)))
                                            )
                                        )
                                    )
                                )

                                (when (ß qhat == 0)
                                    (§ continue)
                                )

                                (when (ß !skipCorrection) ;; correct qhat
                                    (let [
                                          #_"long" nl (ß rem.value[j + 2 + rem.offset] & BigInteger'LONG_MASK)
                                          #_"long" rs (ß ((qrem & BigInteger'LONG_MASK) << 32) | nl)
                                          #_"long" estProduct (ß (dl & BigInteger'LONG_MASK) * (qhat & BigInteger'LONG_MASK))

                                    ]
                                        (when (MutableBigInteger''unsignedLongCompare this, estProduct, rs)
                                            (§ ass qhat (dec qhat))
                                            (§ ass qrem (ß (int)((qrem & BigInteger'LONG_MASK) + dhLong)))
                                            (when (ß (qrem & BigInteger'LONG_MASK) >= dhLong)
                                                (§ ass estProduct (ß estProduct - (dl & BigInteger'LONG_MASK)))
                                                (§ ass rs (ß ((qrem & BigInteger'LONG_MASK) << 32) | nl))
                                                (when (MutableBigInteger''unsignedLongCompare this, estProduct, rs)
                                                    (§ ass qhat (dec qhat))
                                                )
                                            )
                                        )
                                    )
                                )

                                ;; D4 Multiply and subtract
                                (§ ass (ß rem.value[j + rem.offset]) 0)
                                (let [
                                      #_"int" borrow (ß MutableBigInteger''mulsub(this, rem.value, divisor, qhat, dlen, j + rem.offset))
                                ]
                                    ;; D5 Test remainder
                                    (when (ß borrow + 0x80000000 > nh2)
                                        ;; D6 Add back
                                        (ß MutableBigInteger''divadd(this, divisor, rem.value, j + 1 + rem.offset))
                                        (§ ass qhat (dec qhat))
                                    )

                                    ;; store the quotient digit
                                    (§ ass (aget q j) qhat)
                                )
                            )
                        ) ;; D7 loop on j
                        ;; D3 Calculate qhat
                        ;; estimate qhat
                        (let [
                              #_"int" qhat 0
                              #_"int" qrem 0
                              #_"boolean" skipCorrection false
                              #_"int" nh (ß rem.value[limit - 1 + rem.offset])
                              #_"int" nh2 (+ nh 0x80000000)
                              #_"int" nm (ß rem.value[limit + rem.offset])
                        ]
                            (cond (ß nh == dh)
                                (do
                                    (§ ass qhat (ß (§ bit-not)0))
                                    (§ ass qrem (+ nh nm))
                                    (§ ass skipCorrection (ß qrem + 0x80000000 < nh2))
                                )
                                :else
                                (let [
                                      #_"long" nChunk (ß (((long) nh) << 32) | (nm & BigInteger'LONG_MASK))
                                ]
                                    (cond (<= 0 nChunk)
                                        (do
                                            (§ ass qhat (ß (int) (nChunk / dhLong)))
                                            (§ ass qrem (ß (int) (nChunk - (qhat * dhLong))))
                                        )
                                        :else
                                        (let [
                                              #_"long" tmp (MutableBigInteger'divWord nChunk, dh)
                                        ]
                                            (§ ass qhat (ß (int) (tmp & BigInteger'LONG_MASK)))
                                            (§ ass qrem (ß (int) (tmp >>> 32)))
                                        )
                                    )
                                )
                            )
                            (when (ß qhat != 0)
                                (when (ß !skipCorrection) ;; correct qhat
                                    (let [
                                          #_"long" nl (ß rem.value[limit + 1 + rem.offset] & BigInteger'LONG_MASK)
                                          #_"long" rs (ß ((qrem & BigInteger'LONG_MASK) << 32) | nl)
                                          #_"long" estProduct (ß (dl & BigInteger'LONG_MASK) * (qhat & BigInteger'LONG_MASK))
                                    ]
                                        (when (MutableBigInteger''unsignedLongCompare this, estProduct, rs)
                                            (§ ass qhat (dec qhat))
                                            (§ ass qrem (ß (int) ((qrem & BigInteger'LONG_MASK) + dhLong)))
                                            (when (ß (qrem & BigInteger'LONG_MASK) >= dhLong)
                                                (§ ass estProduct (ß estProduct - (dl & BigInteger'LONG_MASK)))
                                                (§ ass rs (ß ((qrem & BigInteger'LONG_MASK) << 32) | nl))
                                                (when (MutableBigInteger''unsignedLongCompare this, estProduct, rs)
                                                    (§ ass qhat (dec qhat))
                                                )
                                            )
                                        )
                                    )
                                )

                                ;; D4 Multiply and subtract
                                (ß #_"int" borrow)
                                (§ ass (ß rem.value[limit - 1 + rem.offset]) 0)
                                (cond needRemainder
                                    (do
                                        (§ ass borrow (ß MutableBigInteger''mulsub(this, rem.value, divisor, qhat, dlen, limit - 1 + rem.offset)))
                                    )
                                    :else
                                    (do
                                        (§ ass borrow (ß MutableBigInteger''mulsubBorrow(this, rem.value, divisor, qhat, dlen, limit - 1 + rem.offset)))
                                    )
                                )

                                ;; D5 Test remainder
                                (when (ß borrow + 0x80000000 > nh2)
                                    ;; D6 Add back
                                    (when needRemainder
                                        (ß MutableBigInteger''divadd(this, divisor, rem.value, limit - 1 + 1 + rem.offset))
                                    )
                                    (§ ass qhat (dec qhat))
                                )

                                ;; store the quotient digit
                                (§ ass (aget q (dec limit)) qhat)
                            )

                            (when needRemainder
                                ;; D8 Unnormalize
                                (when (< 0 shift)
                                    (MutableBigInteger''rightShift rem, shift)
                                )
                                (MutableBigInteger''normalize rem)
                            )
                            (MutableBigInteger''normalize quotient)
                            (when needRemainder rem)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; A primitive used for division by long.
     ; Specialized version of the method divadd.
     ; dh is a high part of the divisor, dl is a low part
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''divaddLong [#_"MutableBigInteger" this, #_"int" dh, #_"int" dl, #_"int[]" result, #_"int" offset]
        (let [
              #_"long" carry 0
              #_"long" sum (ß (dl & BigInteger'LONG_MASK) + (result[1 + offset] & BigInteger'LONG_MASK))
        ]
            (§ ass (aget result (+ 1 offset)) (ß (int)sum))

            (§ ass sum (ß (dh & BigInteger'LONG_MASK) + (result[offset] & BigInteger'LONG_MASK) + carry))
            (§ ass (aget result offset) (ß (int)sum))
            (§ ass carry (ß sum >>> 32))
            (ß (int)carry)
        )
    )

    ;;;
     ; This method is used for division by long.
     ; Specialized version of the method sulsub.
     ; dh is a high part of the divisor, dl is a low part
     ;;
    #_method
    (defn- #_"int" MutableBigInteger''mulsubLong [#_"MutableBigInteger" this, #_"int[]" q, #_"int" dh, #_"int" dl, #_"int" x, #_"int" offset]
        (let [
              #_"long" xLong (ß x & BigInteger'LONG_MASK)
              _ (§ ass offset (+ offset 2))
              #_"long" product (ß (dl & BigInteger'LONG_MASK) * xLong)
              #_"long" difference (ß q[offset] - product)
        ]
            (§ ass (aget q offset) (ß (int)difference))
            (§ ass offset (dec offset))
            (let [
                  #_"long" carry (ß (product >>> 32) + (if (ß (difference & BigInteger'LONG_MASK) > ((((§ bit-not)(int)product) & BigInteger'LONG_MASK))) 1 0))
            ]
                (§ ass product (ß (dh & BigInteger'LONG_MASK) * xLong + carry))
                (§ ass difference (ß q[offset] - product))
                (§ ass (aget q offset) (ß (int)difference))
                (§ ass offset (dec offset))
                (§ ass carry (ß (product >>> 32) + (if (ß (difference & BigInteger'LONG_MASK) > ((((§ bit-not)(int)product) & BigInteger'LONG_MASK))) 1 0)))
                (ß (int)carry)
            )
        )
    )

    ;;;
     ; Compare two longs as if they were unsigned.
     ; Returns true iff one is bigger than two.
     ;;
    #_method
    (defn- #_"boolean" MutableBigInteger''unsignedLongCompare [#_"MutableBigInteger" this, #_"long" one, #_"long" two]
        (ß (one + Long/MIN_VALUE) > (two + Long/MIN_VALUE))
    )

    ;;;
     ; This method divides a long quantity by an int to estimate
     ; qhat for two multi precision numbers.
     ; It is used when the signed value of n is less than zero.
     ; Returns long value where high 32 bits contain remainder
     ; value and low 32 bits contain quotient value.
     ;;
    (defn #_"long" MutableBigInteger'divWord [#_"long" n, #_"int" d]
        (let [
              #_"long" dLong (ß d & BigInteger'LONG_MASK)
              #_"long" r (ß )
              #_"long" q (ß )
        ]
            (when (ß dLong == 1)
                (§ ass q (ß (int)n))
                (§ ass r 0)
                (§ return (ß (r << 32) | (q & BigInteger'LONG_MASK)))
            )

            ;; approximate the quotient and remainder
            (§ ass q (ß (n >>> 1) / (dLong >>> 1)))
            (§ ass r (ß n - q * dLong))

            ;; correct the approximation
            (while (< r 0)
                (§ ass r (+ r dLong))
                (§ ass q (dec q))
            )
            (while (<= dLong r)
                (§ ass r (- r dLong))
                (§ ass q (inc q))
            )
            ;; n - q*dlong == r && 0 <= r < dLong, hence we're done.
            (ß (r << 32) | (q & BigInteger'LONG_MASK))
        )
    )

    ;;;
     ; Calculate GCD of this and b. This and b are changed by the computation.
     ;;
    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''hybridGCD [#_"MutableBigInteger" this, #_"MutableBigInteger" b]
        ;; Use Euclid's algorithm until the numbers are approximately the
        ;; same length, then use the binary GCD algorithm to find the GCD.
        (let [
              #_"MutableBigInteger" a this
              #_"MutableBigInteger" q (MutableBigInteger'new)
        ]
            (while (ß b.intLen != 0)
                (when (ß Math/abs(a.intLen - b.intLen) < 2)
                    (§ return (MutableBigInteger''binaryGCD a, b))
                )

                (let [
                      #_"MutableBigInteger" r (MutableBigInteger''divide-3 a, b, q)
                      _ (§ ass a b)
                      _ (§ ass b r)
                ]
                )
            )
            a
        )
    )

    ;;;
     ; Calculate GCD of this and v.
     ; Assumes that this and v are not zero.
     ;;
    #_method
    (defn- #_"MutableBigInteger" MutableBigInteger''binaryGCD [#_"MutableBigInteger" this, #_"MutableBigInteger" v]
        ;; algorithm B from Knuth section 4.5.2
        (let [
              #_"MutableBigInteger" u this
              #_"MutableBigInteger" r (MutableBigInteger'new)
              ;; step B1
              #_"int" s1 (MutableBigInteger''getLowestSetBit u)
              #_"int" s2 (MutableBigInteger''getLowestSetBit v)
              #_"int" k (if (< s1 s2) s1 s2)
        ]
            (when (ß k != 0)
                (MutableBigInteger''rightShift u, k)
                (MutableBigInteger''rightShift v, k)
            )

            ;; step B2
            (let [
                  #_"boolean" uOdd (ß (k == s1))
                  #_"MutableBigInteger" t (if uOdd v u)
                  #_"int" tsign (if uOdd -1 1)
            ]
                (loop []
                    (let-when [#_"int" lb (MutableBigInteger''getLowestSetBit t)] (<= 0 lb)
                        ;; steps B3 and B4
                        (MutableBigInteger''rightShift t, lb)
                        ;; step B5
                        (cond (< 0 tsign)
                            (do
                                (§ ass u t)
                            )
                            :else
                            (do
                                (§ ass v t)
                            )
                        )

                        ;; special case one word numbers
                        (when (and (ß u.intLen < 2) (ß v.intLen < 2))
                            (let [
                                  #_"int" x (ß u.value[u.offset])
                                  #_"int" y (ß v.value[v.offset])
                            ]
                                (§ ass x (MutableBigInteger'binaryGcd x, y))
                                (§ ass (ß r.value[0]) x)
                                (§ ass (:intLen r) 1)
                                (§ ass (:offset r) 0)
                                (when (< 0 k)
                                    (MutableBigInteger''leftShift r, k)
                                )
                                (§ return r)
                            )
                        )

                        ;; step B6
                        (§ ass tsign (MutableBigInteger''difference u, v))
                        (when (ß tsign == 0)
                            (§ break)
                        )
                        (§ ass t (if (<= 0 tsign) u v))
                        (recur)
                    )
                )

                (when (< 0 k)
                    (MutableBigInteger''leftShift u, k)
                )
                u
            )
        )
    )

    ;;;
     ; Calculate GCD of a and b interpreted as unsigned integers.
     ;;
    (defn #_"int" MutableBigInteger'binaryGcd [#_"int" a, #_"int" b]
        (when (ß b == 0)
            (§ return a)
        )
        (when (ß a == 0)
            (§ return b)
        )

        ;; right shift a & b till their last bits equal to 1
        (let [
              #_"int" aZeros (ß Integer/numberOfTrailingZeros(a))
              #_"int" bZeros (ß Integer/numberOfTrailingZeros(b))
        ]
            (§ ass a (ß a >>> aZeros))
            (§ ass b (ß b >>> bZeros))

            (let [
                  #_"int" t (if (< aZeros bZeros) aZeros bZeros)
            ]
                (while (ß a != b)
                    (cond (ß (a + 0x80000000) > (b + 0x80000000)) ;; a > b as unsigned
                        (do
                            (§ ass a (- a b))
                            (§ ass a (ß a >>> Integer/numberOfTrailingZeros(a)))
                        )
                        :else
                        (do
                            (§ ass b (- b a))
                            (§ ass b (ß b >>> Integer/numberOfTrailingZeros(b)))
                        )
                    )
                )
                (ß a << t)
            )
        )
    )

    (declare MutableBigInteger''modInverse)
    (declare MutableBigInteger''modInverseMP2)
    (declare MutableBigInteger'modInverseBP2)

    ;;;
     ; Returns the modInverse of this mod p.
     ; This and p are not affected by the operation.
     ;;
    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''mutableModInverse [#_"MutableBigInteger" this, #_"MutableBigInteger" p]
        ;; modulus is odd, use Schroeppel's algorithm
        (when (MutableBigInteger''isOdd p)
            (§ return (MutableBigInteger''modInverse this, p))
        )

        ;; base and modulus are even, throw exception
        (when (MutableBigInteger''isEven this)
            (throw! "not invertible")
        )

        ;; get even part of modulus expressed as a power of 2
        (let [
              #_"int" powersOf2 (MutableBigInteger''getLowestSetBit p)

              ;; construct odd part of modulus
              #_"MutableBigInteger" oddMod (MutableBigInteger'new p)
        ]
            (MutableBigInteger''rightShift oddMod, powersOf2)

            (when (MutableBigInteger''isOne oddMod)
                (§ return (MutableBigInteger''modInverseMP2 this, powersOf2))
            )

            (let [
                  ;; calculate 1/a mod oddMod
                  #_"MutableBigInteger" oddPart (MutableBigInteger''modInverse this, oddMod)
                  ;; calculate 1/a mod evenMod
                  #_"MutableBigInteger" evenPart (MutableBigInteger''modInverseMP2 this, powersOf2)
                  ;; combine the results using Chinese Remainder Theorem
                  #_"MutableBigInteger" y1 (MutableBigInteger'modInverseBP2 oddMod, powersOf2)
                  #_"MutableBigInteger" y2 (MutableBigInteger''modInverseMP2 oddMod, powersOf2)
                  #_"MutableBigInteger" temp1 (MutableBigInteger'new)
                  #_"MutableBigInteger" temp2 (MutableBigInteger'new)
                  #_"MutableBigInteger" result (MutableBigInteger'new)
            ]
                (MutableBigInteger''leftShift oddPart, powersOf2)
                (MutableBigInteger''multiply oddPart, y1, result)

                (MutableBigInteger''multiply evenPart, oddMod, temp1)
                (MutableBigInteger''multiply temp1, y2, temp2)

                (MutableBigInteger''add result, temp2)
                (MutableBigInteger''divide-3 result, p, temp1)
            )
        )
    )

    ;;
     ; Calculate the multiplicative inverse of this mod 2^k.
     ;;
    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''modInverseMP2 [#_"MutableBigInteger" this, #_"int" k]
        (when (MutableBigInteger''isEven this)
            (throw! "not invertible (not= gcd 1)")
        )

        (when (< 64 k)
            (§ return (MutableBigInteger''euclidModInverse this, k))
        )

        (let [
              #_"int" t (ß MutableBigInteger'inverseMod32(this.value[this.offset + this.intLen - 1]))
        ]
            (when (< k 33)
                (§ ass t (if (ß k == 32) t (ß t & ((1 << k) - 1))))
                (§ return (MutableBigInteger'new t))
            )

            (let [
                  #_"long" pLong (ß (this.value[this.offset + this.intLen - 1] & BigInteger'LONG_MASK))
            ]
                (when (ß this.intLen > 1)
                    (§ ass pLong (ß pLong | ((long)this.value[this.offset + this.intLen - 2] << 32)))
                )
                (let [
                      #_"long" tLong (ß t & BigInteger'LONG_MASK)
                      _ (§ ass tLong (ß tLong * (2 - pLong * tLong))) ;; 1 more Newton iter step
                      _ (§ ass tLong (if (ß k == 64) tLong (ß tLong & ((1 << k) - 1))))
                      #_"MutableBigInteger" result (ß MutableBigInteger'new(new int[2]))
                ]
                    (§ ass (ß result.value[0]) (ß (int)(tLong >>> 32)))
                    (§ ass (ß result.value[1]) (ß (int)tLong))
                    (§ ass (ß result.intLen) 2)
                    (MutableBigInteger''normalize result)
                    result
                )
            )
        )
    )

    ;;;
     ; Returns the multiplicative inverse of val mod 2^32. Assumes val is odd.
     ;;
    (defn #_"int" MutableBigInteger'inverseMod32 [#_"int" val]
        ;; Newton's iteration!
        (let [
              #_"int" t val
        ]
            (§ ass t (ß t * 2 - val * t))
            (§ ass t (ß t * 2 - val * t))
            (§ ass t (ß t * 2 - val * t))
            (§ ass t (ß t * 2 - val * t))
            t
        )
    )

    ;;;
     ; Calculate the multiplicative inverse of 2^k mod mod, where mod is odd.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'modInverseBP2 [#_"MutableBigInteger" mod, #_"int" k]
        ;; copy the mod to protect original
        (ß MutableBigInteger'fixup(MutableBigInteger'new(1), MutableBigInteger'new(mod), k))
    )

    (declare SignedMutableBigInteger'new)
    (declare SignedMutableBigInteger''signedSubtract-s)
    (declare SignedMutableBigInteger''signedAdd-s)
    (declare SignedMutableBigInteger''signedAdd-m)
    (declare MutableBigInteger'fixup)

    ;;;
     ; Calculate the multiplicative inverse of this mod mod, where mod is odd.
     ; This and mod are not changed by the calculation.
     ;
     ; This method implements an algorithm due to Richard Schroeppel, that
     ; uses the same intermediate representation as Montgomery Reduction
     ; ("Montgomery Form"). The algorithm is described in an unpublished
     ; manuscript entitled "Fast Modular Reciprocals."
     ;;
    #_method
    (defn- #_"MutableBigInteger" MutableBigInteger''modInverse [#_"MutableBigInteger" this, #_"MutableBigInteger" mod]
        (let [
              #_"MutableBigInteger" p (MutableBigInteger'new mod)
              #_"MutableBigInteger" f (MutableBigInteger'new this)
              #_"MutableBigInteger" g (MutableBigInteger'new p)
              #_"SignedMutableBigInteger" c (SignedMutableBigInteger'new 1)
              #_"SignedMutableBigInteger" d (SignedMutableBigInteger'new)
              #_"MutableBigInteger" temp nil
              #_"SignedMutableBigInteger" sTemp nil
              #_"int" k 0
        ]
            ;; right shift f k times until odd, left shift d k times
            (when (MutableBigInteger''isEven f)
                (let [
                      #_"int" trailingZeros (MutableBigInteger''getLowestSetBit f)
                ]
                    (MutableBigInteger''rightShift f, trailingZeros)
                    (MutableBigInteger''leftShift d, trailingZeros)
                    (§ ass k trailingZeros)
                )
            )

            ;; the Almost Inverse Algorithm
            (while (ß !MutableBigInteger''isOne(f))
                ;; if gcd(f, g) != 1, number is not invertible modulo mod
                (when (MutableBigInteger''isZero f)
                    (throw! "not invertible")
                )

                ;; if f < g exchange f, g and c, d
                (when (ß MutableBigInteger''compare(f, g) < 0)
                    (§ ass temp f)
                    (§ ass f g)
                    (§ ass g temp)
                    (§ ass sTemp d)
                    (§ ass d c)
                    (§ ass c sTemp)
                )

                ;; if f == g (mod 4)
                (cond (ß ((f.value[f.offset + f.intLen - 1] (§ bit-xor) g.value[g.offset + g.intLen - 1]) & 3) == 0)
                    (do
                        (MutableBigInteger''subtract f, g)
                        (SignedMutableBigInteger''signedSubtract-s c, d)
                    )
                    :else ;; if f != g (mod 4)
                    (do
                        (MutableBigInteger''add f, g)
                        (SignedMutableBigInteger''signedAdd-s c, d)
                    )
                )

                ;; right shift f k times until odd, left shift d k times
                (let [
                      #_"int" trailingZeros (MutableBigInteger''getLowestSetBit f)
                ]
                    (MutableBigInteger''rightShift f, trailingZeros)
                    (MutableBigInteger''leftShift d, trailingZeros)
                    (§ ass k (+ k trailingZeros))
                )
            )

            (while (ß c.sign < 0)
                (SignedMutableBigInteger''signedAdd-m c, p)
            )

            (MutableBigInteger'fixup c, p, k)
        )
    )

    ;;;
     ; The Fixup Algorithm
     ; Calculates X such that X = C * 2^(-k) (mod P)
     ; Assumes C<P and P is odd.
     ;;
    (defn #_"MutableBigInteger" MutableBigInteger'fixup [#_"MutableBigInteger" c, #_"MutableBigInteger" p, #_"int" k]
        (let [
              #_"MutableBigInteger" temp (MutableBigInteger'new)
              ;; set r to the multiplicative inverse of p mod 2^32
              #_"int" r (- (ß MutableBigInteger'inverseMod32(p.value[p.offset + p.intLen - 1])))
              #_"int" numWords (ß k >> 5)
        ]
            (loop-when-recur [#_"int" i 0] (< i numWords) [(inc i)]
                ;; V = R * c (mod 2^j)
                (let [
                      #_"int" v (ß r * c.value[c.offset + c.intLen - 1])
                ]
                    ;; c = c + (v * p)
                    (MutableBigInteger''mul p, v, temp)
                    (MutableBigInteger''add c, temp)
                    ;; c = c / 2^j
                    (§ ass (:intLen c) (ß c.intLen - 1))
                )
            )
            (let [
                  #_"int" numBits (ß k & 0x1f)
            ]
                (when (ß numBits != 0)
                    ;; V = R * c (mod 2^j)
                    (let [
                          #_"int" v (ß r * c.value[c.offset + c.intLen - 1])
                    ]
                        (§ ass v (ß v & ((1 << numBits) - 1)))
                        ;; c = c + (v * p)
                        (MutableBigInteger''mul p, v, temp)
                        (MutableBigInteger''add c, temp)
                        ;; c = c / 2^j
                        (MutableBigInteger''rightShift c, numBits)
                    )
                )

                ;; In theory, c may be greater than p at this point (Very rare!)
                (while (ß MutableBigInteger''compare(c, p) >= 0)
                    (MutableBigInteger''subtract c, p)
                )

                c
            )
        )
    )

    ;;;
     ; Uses the extended Euclidean algorithm to compute the modInverse of base
     ; mod a modulus that is a power of 2. The modulus is 2^k.
     ;;
    #_method
    (defn #_"MutableBigInteger" MutableBigInteger''euclidModInverse [#_"MutableBigInteger" this, #_"int" k]
        (let [
              #_"MutableBigInteger" b (MutableBigInteger'new 1)
        ]
            (MutableBigInteger''leftShift b, k)

            (let [
                  #_"MutableBigInteger" mod (MutableBigInteger'new b)
                  #_"MutableBigInteger" a (MutableBigInteger'new this)
                  #_"MutableBigInteger" q (MutableBigInteger'new)
                  #_"MutableBigInteger" r (MutableBigInteger''divide-3 b, a, q)
                  ;; swap b & r
                  #_"MutableBigInteger" swapper b b r r swapper
                  #_"MutableBigInteger" t1 (MutableBigInteger'new q)
                  #_"MutableBigInteger" t0 (MutableBigInteger'new 1)
                  #_"MutableBigInteger" temp (MutableBigInteger'new)
            ]
                (while (ß !MutableBigInteger''isOne(b))
                    (let [
                    ]
                        (§ ass r (MutableBigInteger''divide-3 a, b, q))

                        (when (ß r.intLen == 0)
                            (throw! "not invertible")
                        )

                        (§ ass swapper r)
                        (§ ass a swapper)

                        (cond (ß q.intLen == 1)
                            (do
                                (ß MutableBigInteger''mul(t1, q.value[q.offset], temp))
                            )
                            :else
                            (do
                                (MutableBigInteger''multiply q, t1, temp)
                            )
                        )
                        (§ ass swapper q)
                        (§ ass q temp)
                        (§ ass temp swapper)
                        (MutableBigInteger''add t0, q)

                        (when (MutableBigInteger''isOne a)
                            (§ return t0)
                        )

                        (§ ass r (MutableBigInteger''divide-3 b, a, q))

                        (when (ß r.intLen == 0)
                            (throw! "not invertible")
                        )

                        (§ ass swapper b)
                        (§ ass b r)

                        (cond (ß q.intLen == 1)
                            (do
                                (ß MutableBigInteger''mul(t0, q.value[q.offset], temp))
                            )
                            :else
                            (do
                                (MutableBigInteger''multiply q, t0, temp)
                            )
                        )
                        (§ ass swapper q)
                        (§ ass q temp)
                        (§ ass temp swapper)

                        (MutableBigInteger''add t1, q)
                    )
                )
                (MutableBigInteger''subtract mod, t1)
                mod
            )
        )
    )
)

;;;
 ; A class used to represent multiprecision integers that makes efficient
 ; use of allocated space by allowing a number to occupy only part of
 ; an array so that the arrays do not have to be reallocated as often.
 ;
 ; When performing an operation with many iterations the array used to
 ; hold a number is only increased when necessary and does not have to
 ; be the same size as the number it represents. A mutable number allows
 ; calculations to occur on the same number without having to create
 ; a new number for every step of the calculation as occurs with
 ; BigIntegers.
 ;
 ; Note that SignedMutableBigIntegers only support signed addition and
 ; subtraction. All other operations occur as with MutableBigIntegers.
 ;;

(class-ns SignedMutableBigInteger (§ extends #_"MutableBigInteger")
    ;;;
     ; The sign of this MutableBigInteger.
     ;;
    (§ field #_"int" :sign 1)

    ;; constructors

    ;;;
     ; The default constructor. An empty MutableBigInteger is created with
     ; a one word capacity.
     ;;
    (defn #_"SignedMutableBigInteger" SignedMutableBigInteger'new []
        (let [this (§ new)
        ]
            (ß super())
            this
        )
    )

    ;;;
     ; Construct a new MutableBigInteger with a magnitude specified by
     ; the int val.
     ;;
    (defn #_"SignedMutableBigInteger" SignedMutableBigInteger'new [#_"int" val]
        (let [this (§ new)
        ]
            (ß super(val))
            this
        )
    )

    ;;;
     ; Construct a new MutableBigInteger with a magnitude equal to the
     ; specified MutableBigInteger.
     ;;
    (defn #_"SignedMutableBigInteger" SignedMutableBigInteger'new [#_"MutableBigInteger" val]
        (let [this (§ new)
        ]
            (ß super(val))
            this
        )
    )

    ;; arithmetic operations

    ;;;
     ; Signed addition built upon unsigned add and subtract.
     ;;
    #_method
    (defn #_"void" SignedMutableBigInteger''signedAdd-s [#_"SignedMutableBigInteger" this, #_"SignedMutableBigInteger" addend]
        (cond (ß this.sign == addend.sign)
            (do
                (MutableBigInteger''add this, addend)
            )
            :else
            (do
                (§ ass (:sign this) (ß this.sign * MutableBigInteger''subtract(this, addend)))
            )
        )
        nil
    )

    ;;;
     ; Signed addition built upon unsigned add and subtract.
     ;;
    #_method
    (defn #_"void" SignedMutableBigInteger''signedAdd-m [#_"SignedMutableBigInteger" this, #_"MutableBigInteger" addend]
        (cond (ß this.sign == 1)
            (do
                (MutableBigInteger''add this, addend)
            )
            :else
            (do
                (§ ass (:sign this) (ß this.sign * MutableBigInteger''subtract(this, addend)))
            )
        )
        nil
    )

    ;;;
     ; Signed subtraction built upon unsigned add and subtract.
     ;;
    #_method
    (defn #_"void" SignedMutableBigInteger''signedSubtract-s [#_"SignedMutableBigInteger" this, #_"SignedMutableBigInteger" addend]
        (cond (ß this.sign == addend.sign)
            (do
                (§ ass (:sign this) (ß this.sign * MutableBigInteger''subtract(this, addend)))
            )
            :else
            (do
                (MutableBigInteger''add this, addend)
            )
        )
        nil
    )

    ;;;
     ; Signed subtraction built upon unsigned add and subtract.
     ;;
    #_method
    (defn #_"void" SignedMutableBigInteger''signedSubtract-m [#_"SignedMutableBigInteger" this, #_"MutableBigInteger" addend]
        (cond (ß this.sign == 1)
            (do
                (§ ass (:sign this) (ß this.sign * MutableBigInteger''subtract(this, addend)))
            )
            :else
            (do
                (MutableBigInteger''add this, addend)
            )
        )
        (when (ß this.intLen == 0)
            (§ ass (:sign this) 1)
        )
        nil
    )

    ;;;
     ; Print out the first intLen ints of this MutableBigInteger's value
     ; array starting at offset.
     ;;
    #_foreign
    (defn #_"String" toString---SignedMutableBigInteger [#_"SignedMutableBigInteger" this]
        (ß MutableBigInteger''toBigInteger-2(this, this.sign).toString())
    )
)

;;;
 ; Immutable arbitrary-precision integers. All operations behave as if
 ; BigIntegers were represented in two's-complement notation (like Java's
 ; primitive integer types). BigInteger provides analogues to all of Java's
 ; primitive integer operators, and all relevant methods from java.lang.Math.
 ; Additionally, BigInteger provides operations for modular arithmetic, GCD
 ; calculation, primality testing, prime generation, bit manipulation,
 ; and a few other miscellaneous operations.
 ;
 ; Semantics of arithmetic operations exactly mimic those of Java's integer
 ; arithmetic operators, as defined in <i>The Java Language Specification</i>.
 ; For example, division by zero throws an {@code ArithmeticException}, and
 ; division of a negative by a positive yields a negative (or zero) remainder.
 ; All of the details in the Spec concerning overflow are ignored, as
 ; BigIntegers are made as large as necessary to accommodate the results of an
 ; operation.
 ;
 ; Semantics of shift operations extend those of Java's shift operators
 ; to allow for negative shift distances. A right-shift with a negative
 ; shift distance results in a left shift, and vice-versa. The unsigned
 ; right shift operator ({@code >>>}) is omitted, as this operation makes
 ; little sense in combination with the "infinite word size" abstraction
 ; provided by this class.
 ;
 ; Semantics of bitwise logical operations exactly mimic those of Java's
 ; bitwise integer operators. The binary operators ({@code and},
 ; {@code or}, {@code xor}) implicitly perform sign extension on the shorter
 ; of the two operands prior to performing the operation.
 ;
 ; Comparison operations perform signed integer comparisons, analogous to
 ; those performed by Java's relational and equality operators.
 ;
 ; Modular arithmetic operations are provided to compute residues, perform
 ; exponentiation, and compute multiplicative inverses. These methods always
 ; return a non-negative result, between {@code 0} and {@code (modulus - 1)},
 ; inclusive.
 ;
 ; Bit operations operate on a single bit of the two's-complement
 ; representation of their operand. If necessary, the operand is sign-
 ; extended so that it contains the designated bit. None of the single-bit
 ; operations can produce a BigInteger with a different sign from the
 ; BigInteger being operated on, as they affect only a single bit, and the
 ; "infinite word size" abstraction provided by this class ensures that there
 ; are infinitely many "virtual sign bits" preceding each BigInteger.
 ;
 ; For the sake of brevity and clarity, pseudo-code is used throughout the
 ; descriptions of BigInteger methods. The pseudo-code expression
 ; {@code (i + j)} is shorthand for "a BigInteger whose value is
 ; that of the BigInteger {@code i} plus that of the BigInteger {@code j}."
 ; The pseudo-code expression {@code (i == j)} is shorthand for
 ; "{@code true} if and only if the BigInteger {@code i} represents the same
 ; value as the BigInteger {@code j}." Other pseudo-code expressions are
 ; interpreted similarly.
 ;
 ; All methods and constructors in this class throw
 ; {@code NullPointerException} when passed
 ; a null object reference for any input parameter.
 ;
 ; BigInteger must support values in the range
 ; -2<sup>{@code Integer.MAX_VALUE}</sup> (exclusive) to
 ; +2<sup>{@code Integer.MAX_VALUE}</sup> (exclusive)
 ; and may support values outside of that range.
 ;
 ; The range of probable prime values is limited and may be less than
 ; the full supported positive range of {@code BigInteger}.
 ; The range must be at least 1 to 2<sup>500000000</sup>.
 ;
 ; @implNote
 ; BigInteger constructors and operations throw {@code ArithmeticException} when
 ; the result is out of the supported range of
 ; -2<sup>{@code Integer.MAX_VALUE}</sup> (exclusive) to
 ; +2<sup>{@code Integer.MAX_VALUE}</sup> (exclusive).
 ;;

(class-ns BigInteger (§ extends #_"Number") (§ implements #_"Comparable<BigInteger>")
    ;;;
     ; The signum of this BigInteger: -1 for negative, 0 for zero, or
     ; 1 for positive. Note that the BigInteger zero <i>must</i> have
     ; a signum of 0. This is necessary to ensures that there is exactly one
     ; representation for each BigInteger value.
     ;;
    #_final
    (§ field #_"int" :signum 0)

    ;;;
     ; The magnitude of this BigInteger, in <i>big-endian</i> order: the
     ; zeroth element of this array is the most-significant int of the
     ; magnitude. The magnitude must be "minimal" in that the most-significant
     ; int ({@code mag[0]}) must be non-zero. This is necessary to
     ; ensure that there is exactly one representation for each BigInteger
     ; value. Note that this implies that the BigInteger zero has a
     ; zero-length mag array.
     ;;
    #_final
    (§ field #_"int[]" :mag nil)

    ;; These "redundant fields" are initialized with recognizable nonsense
    ;; values, and cached the first time they are needed (or never, if they
    ;; aren't needed).

    ;;;
     ; One plus the bitCount of this BigInteger. Zeros means unitialized.
     ;
     ; @deprecated Deprecated since logical value is offset from stored
     ; value and correction factor is applied in accessor method.
     ;;
    #_deprecated
    (§ field- #_"int" :bitCount)

    ;;;
     ; One plus the bitLength of this BigInteger. Zeros means unitialized.
     ; (either value is acceptable).
     ;
     ; @deprecated Deprecated since logical value is offset from stored
     ; value and correction factor is applied in accessor method.
     ;;
    #_deprecated
    (§ field- #_"int" :bitLength)

    ;;;
     ; Two plus the lowest set bit of this BigInteger, as returned by
     ; getLowestSetBit().
     ;
     ; @deprecated Deprecated since logical value is offset from stored
     ; value and correction factor is applied in accessor method.
     ;;
    #_deprecated
    (§ field- #_"int" :lowestSetBit)

    ;;;
     ; Two plus the index of the lowest-order int in the magnitude of this
     ; BigInteger that contains a nonzero int, or -2 (either value is acceptable).
     ; The least significant int has int-number 0, the next int in order of
     ; increasing significance has int-number 1, and so forth.
     ; @deprecated Deprecated since logical value is offset from stored
     ; value and correction factor is applied in accessor method.
     ;;
    #_deprecated
    (§ field- #_"int" :firstNonzeroIntNum)

    ;;;
     ; This mask is used to obtain the value of an int as if it were unsigned.
     ;;
    (def #_"long" BigInteger'LONG_MASK 0xffffffff)

    ;;;
     ; This constant limits {@code mag.length} of BigIntegers to the supported
     ; range.
     ;;
    (def- #_"int" BigInteger'MAX_MAG_LENGTH 64)

    ;;;
     ; Bit lengths larger than this constant can cause overflow in searchLen
     ; calculation and in BitSieve.singleSearch method.
     ;;
    (def- #_"int" BigInteger'PRIME_SEARCH_BIT_LENGTH_LIMIT 500000000)

    ;;;
     ; The threshold value for using Schoenhage recursive base conversion.
     ; If the number of ints in the number are larger than this value,
     ; the Schoenhage algorithm will be used. In practice, it appears that the
     ; Schoenhage routine is faster for any threshold down to 2, and is
     ; relatively flat for thresholds between 2-25, so this choice may be
     ; varied within this range for very small effect.
     ;;
    (def- #_"int" BigInteger'SCHOENHAGE_BASE_CONVERSION_THRESHOLD 20)

    ;; constructors

    (declare BigInteger''checkRange)

    ;;;
     ; Translates a byte array containing the two's-complement binary representation
     ; of a BigInteger into a BigInteger. The input array is assumed to be in
     ; <i>big-endian</i> byte-order: the most significant byte is in the zeroth element.
     ;
     ; @param  val big-endian two's-complement binary representation of BigInteger.
     ; @throws NumberFormatException {@code val} is zero bytes long.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"byte[]" val]
        (let [this (§ new)
        ]
            (when (ß val.length == 0)
                (throw! "zero length")
            )

            (cond (ß val[0] < 0)
                (do
                    (§ ass (:mag this) (BigInteger'makePositive-b val))
                    (§ ass (:signum this) -1)
                )
                :else
                (do
                    (§ ass (:mag this) (BigInteger'stripLeadingZeroBytes val))
                    (§ ass (:signum this) (if (ß this.mag.length == 0) 0 1))
                )
            )
            (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                (BigInteger''checkRange this)
            )
            this
        )
    )

    ;;;
     ; This private constructor translates an int array containing the
     ; two's-complement binary representation of a BigInteger into a
     ; BigInteger. The input array is assumed to be in <i>big-endian</i>
     ; int-order: the most significant int is in the zeroth element.
     ;;
    (defn- #_"BigInteger" BigInteger'new [#_"int[]" val]
        (let [this (§ new)
        ]
            (when (ß val.length == 0)
                (throw! "zero length")
            )

            (cond (ß val[0] < 0)
                (do
                    (§ ass (:mag this) (BigInteger'makePositive-i val))
                    (§ ass (:signum this) -1)
                )
                :else
                (do
                    (§ ass (:mag this) (BigInteger'trustedStripLeadingZeroInts val))
                    (§ ass (:signum this) (if (ß this.mag.length == 0) 0 1))
                )
            )
            (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                (BigInteger''checkRange this)
            )
            this
        )
    )

    ;;;
     ; Translates the sign-magnitude representation of a BigInteger into a
     ; BigInteger. The sign is represented as an integer signum value: -1 for
     ; negative, 0 for zero, or 1 for positive. The magnitude is a byte array
     ; in <i>big-endian</i> byte-order: the most significant byte is in the
     ; zeroth element. A zero-length magnitude array is permissible, and will
     ; result in a BigInteger value of 0, whether signum is -1, 0 or 1.
     ;
     ; @param  signum signum of the number (-1 for negative, 0 for zero, 1 for positive).
     ; @param  magnitude big-endian binary representation of the magnitude of the number.
     ; @throws NumberFormatException {@code signum} is not one of the three
     ;         legal values (-1, 0, and 1), or {@code signum} is 0 and
     ;         {@code magnitude} contains one or more non-zero bytes.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"int" signum, #_"byte[]" magnitude]
        (let [this (§ new)
        ]
            (§ ass (:mag this) (BigInteger'stripLeadingZeroBytes magnitude))

            (when (or (ß signum < -1) (ß signum > 1))
                (throw! "invalid signum value")
            )

            (cond (ß this.mag.length == 0)
                (do
                    (§ ass (:signum this) 0)
                )
                :else
                (do
                    (when (ß signum == 0)
                        (throw! "signum-magnitude mismatch")
                    )
                    (§ ass (:signum this) signum)
                )
            )
            (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                (BigInteger''checkRange this)
            )
            this
        )
    )

    ;;;
     ; A constructor for internal use that translates the sign-magnitude
     ; representation of a BigInteger into a BigInteger. It checks the
     ; arguments and copies the magnitude so this constructor would be
     ; safe for external use.
     ;;
    (defn- #_"BigInteger" BigInteger'new [#_"int" signum, #_"int[]" magnitude]
        (let [this (§ new)
        ]
            (§ ass (:mag this) (BigInteger'stripLeadingZeroInts magnitude))

            (when (or (ß signum < -1) (ß signum > 1))
                (throw! "invalid signum value")
            )

            (cond (ß this.mag.length == 0)
                (do
                    (§ ass (:signum this) 0)
                )
                :else
                (do
                    (when (ß signum == 0)
                        (throw! "signum-magnitude mismatch")
                    )
                    (§ ass (:signum this) signum)
                )
            )
            (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                (BigInteger''checkRange this)
            )
            this
        )
    )

    (declare BigInteger'destructiveMulAdd)

    ;;;
     ; Translates the String representation of a BigInteger in the
     ; specified radix into a BigInteger. The String representation
     ; consists of an optional minus or plus sign followed by a sequence
     ; of one or more digits in the specified radix. The character-to-digit
     ; mapping is provided by {@code Character.digit}. The String may
     ; not contain any extraneous characters (whitespace, for example).
     ;
     ; @param val String representation of BigInteger.
     ; @param radix radix to be used in interpreting {@code val}.
     ; @throws NumberFormatException {@code val} is not a valid representation
     ;         of a BigInteger in the specified radix, or {@code radix} is
     ;         outside the range from {@link Character#MIN_RADIX} to
     ;         {@link Character#MAX_RADIX}, inclusive.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"String" val, #_"int" radix]
        (let [this (§ new)
              #_"int" cursor (ß 0, numDigits)
              #_"int" len (ß val.length())
        ]
            (when (or (ß radix < Character/MIN_RADIX) (ß radix > Character/MAX_RADIX))
                (throw! "radix out of range")
            )
            (when (ß len == 0)
                (throw! "zero length")
            )

            ;; check for at most one leading sign
            (let [
                  #_"int" sign 1
                  #_"int" index1 (ß val.lastIndexOf((§ char "-")))
                  #_"int" index2 (ß val.lastIndexOf((§ char "+")))
            ]
                (cond (<= 0 index1)
                    (do
                        (when (or (ß index1 != 0) (ß index2 >= 0))
                            (throw! "illegal embedded sign character")
                        )
                        (§ ass sign -1)
                        (§ ass cursor 1)
                    )
                    (<= 0 index2)
                    (do
                        (when (ß index2 != 0)
                            (throw! "illegal embedded sign character")
                        )
                        (§ ass cursor 1)
                    )
                )
                (when (ß cursor == len)
                    (throw! "zero length")
                )

                ;; skip leading zeros and compute number of digits in magnitude
                (while (and (ß cursor < len) (ß Character/digit(val.charAt(cursor), radix) == 0))
                    (§ ass cursor (inc cursor))
                )

                (when (ß cursor == len)
                    (§ ass (:signum this) 0)
                    (§ ass (:mag this) (:mag BigInteger'ZERO))
                    (§ return this)
                )

                (§ ass numDigits (- len cursor))
                (§ ass (:signum this) sign)

                ;; Pre-allocate array of expected size. May be too large but can
                ;; never be too small. Typically exact.
                (let [
                      #_"long" numBits (ß ((numDigits * BigInteger'bitsPerDigit[radix]) >>> 10) + 1)
                ]
                    (when (ß numBits + 31 >= (1 << 32))
                        (throw! "magnitude overflow")
                    )
                    (let [
                          #_"int" numWords (ß (int) (numBits + 31) >>> 5)
                          #_"int[]" magnitude (ß new int[numWords])
                          ;; process first (potentially short) digit group
                          #_"int" firstGroupLen (ß numDigits % BigInteger'digitsPerInt[radix])
                    ]
                        (when (ß firstGroupLen == 0)
                            (§ ass firstGroupLen (ß BigInteger'digitsPerInt[radix]))
                        )
                        (let [
                              #_"String" group (ß val.substring(cursor, cursor + firstGroupLen))
                              _ (§ ass cursor (+ cursor firstGroupLen))
                        ]
                            (§ ass (aget magnitude (dec numWords)) (ß Integer/parseInt(group, radix)))
                            (when (ß magnitude[numWords - 1] < 0)
                                (throw! "illegal digit")
                            )

                            ;; process remaining digit groups
                            (let [
                                  #_"int" superRadix (ß BigInteger'intRadix[radix])
                                  #_"int" groupVal 0
                            ]
                                (while (< cursor len)
                                    (let [
                                    ]
                                        (§ ass group (ß val.substring(cursor, cursor + BigInteger'digitsPerInt[radix])))
                                        (§ ass cursor (ß cursor + BigInteger'digitsPerInt[radix]))
                                        (§ ass groupVal (ß Integer/parseInt(group, radix)))
                                        (when (< groupVal 0)
                                            (throw! "illegal digit")
                                        )
                                        (BigInteger'destructiveMulAdd magnitude, superRadix, groupVal)
                                    )
                                )
                                ;; required for cases where the array was overallocated
                                (§ ass (:mag this) (BigInteger'trustedStripLeadingZeroInts magnitude))
                                (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                                    (BigInteger''checkRange this)
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    ;;
     ; Constructs a new BigInteger using a char array with radix=10.
     ; Sign is precalculated outside and not allowed in the val.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"char[]" val, #_"int" sign, #_"int" len]
        (let [this (§ new)
              #_"int" cursor (ß 0, numDigits)
        ]
            ;; skip leading zeros and compute number of digits in magnitude
            (while (and (ß cursor < len) (ß Character/digit(val[cursor], 10) == 0))
                (§ ass cursor (inc cursor))
            )
            (when (ß cursor == len)
                (§ ass (:signum this) 0)
                (§ ass (:mag this) (:mag BigInteger'ZERO))
                (§ return this)
            )

            (§ ass numDigits (- len cursor))
            (§ ass (:signum this) sign)
            ;; pre-allocate array of expected size
            (ß #_"int" numWords)
            (cond (< len 10)
                (do
                    (§ ass numWords 1)
                )
                :else
                (let [
                      #_"long" numBits (ß ((numDigits * BigInteger'bitsPerDigit[10]) >>> 10) + 1)
                ]
                    (when (ß numBits + 31 >= (1 << 32))
                        (throw! "magnitude overflow")
                    )
                    (§ ass numWords (ß (int) (numBits + 31) >>> 5))
                )
            )
            (let [
                  #_"int[]" magnitude (ß new int[numWords])
                  ;; process first (potentially short) digit group
                  #_"int" firstGroupLen (ß numDigits % BigInteger'digitsPerInt[10])
            ]
                (when (ß firstGroupLen == 0)
                    (§ ass firstGroupLen (ß BigInteger'digitsPerInt[10]))
                )
                (§ ass (aget magnitude (dec numWords)) (ß BigInteger''parseInt(this, val, cursor, cursor + firstGroupLen)))
                (§ ass cursor (+ cursor firstGroupLen))

                ;; process remaining digit groups
                (while (< cursor len)
                    (let [
                          #_"int" groupVal (ß BigInteger''parseInt(this, val, cursor, cursor + BigInteger'digitsPerInt[10]))
                    ]
                        (§ ass cursor (ß cursor + BigInteger'digitsPerInt[10]))
                        (ß BigInteger'destructiveMulAdd(magnitude, BigInteger'intRadix[10], groupVal))
                    )
                )
                (§ ass (:mag this) (BigInteger'trustedStripLeadingZeroInts magnitude))
                (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                    (BigInteger''checkRange this)
                )
                this
            )
        )
    )

    ;; Create an integer with the digits between the two indexes.
    ;; Assumes start < end. The result may be negative, but it
    ;; is to be treated as an unsigned value.
    #_method
    (defn- #_"int" BigInteger''parseInt [#_"BigInteger" this, #_"char[]" source, #_"int" start, #_"int" end]
        (let [
              #_"int" result (ß Character/digit(source[start], 10))
              _ (§ ass start (inc start))
        ]
            (when (ß result == -1)
                (throw! (String. source))
            )

            (loop-when-recur [#_"int" index start] (< index end) [(inc index)]
                (let [
                      #_"int" nextVal (ß Character/digit(source[index], 10))
                ]
                    (when (ß nextVal == -1)
                        (throw! (String. source))
                    )
                    (§ ass result (ß 10 * result + nextVal))
                )
            )

            result
        )
    )

    ;; bitsPerDigit in the given radix times 1024
    ;; Rounded up to avoid underallocation.
    (def- #_"long[]" BigInteger'bitsPerDigit
        (§
            0, 0,
            1024, 1624, 2048, 2378, 2648, 2875, 3072, 3247, 3402, 3543, 3672,
            3790, 3899, 4001, 4096, 4186, 4271, 4350, 4426, 4498, 4567, 4633,
            4696, 4756, 4814, 4870, 4923, 4975, 5025, 5074, 5120, 5166, 5210,
            5253, 5295
        )
    )

    ;; multiply x array times word y in place, and add word z
    (defn- #_"void" BigInteger'destructiveMulAdd [#_"int[]" x, #_"int" y, #_"int" z]
        (let [
              ;; perform the multiplication word by word
              #_"long" ylong (ß y & BigInteger'LONG_MASK)
              #_"long" zlong (ß z & BigInteger'LONG_MASK)
              #_"int" len (:length x)

              #_"long" product 0
              #_"long" carry 0
        ]
            (loop-when-recur [#_"int" i (dec len)] (<= 0 i) [(dec i)]
                (§ ass product (ß ylong * (x[i] & BigInteger'LONG_MASK) + carry))
                (§ ass (aget x i) (ß (int)product))
                (§ ass carry (ß product >>> 32))
            )

            ;; perform the addition
            (let [
                  #_"long" sum (ß (x[len - 1] & BigInteger'LONG_MASK) + zlong)
            ]
                (§ ass (aget x (dec len)) (ß (int)sum))
                (§ ass carry (ß sum >>> 32))
                (loop-when-recur [#_"int" i (- len 2)] (<= 0 i) [(dec i)]
                    (§ ass sum (ß (x[i] & BigInteger'LONG_MASK) + carry))
                    (§ ass (aget x i) (ß (int)sum))
                    (§ ass carry (ß sum >>> 32))
                )
            )
        )
        nil
    )

    ;;;
     ; Translates the decimal String representation of a BigInteger into a
     ; BigInteger. The String representation consists of an optional minus
     ; sign followed by a sequence of one or more decimal digits. The
     ; character-to-digit mapping is provided by {@code Character.digit}.
     ; The String may not contain any extraneous characters (whitespace, for
     ; example).
     ;
     ; @param val decimal String representation of BigInteger.
     ; @throws NumberFormatException {@code val} is not a valid representation
     ;         of a BigInteger.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"String" val]
        (BigInteger'new val, 10)
    )

    (declare BigInteger'randomBits)

    ;;;
     ; Constructs a randomly generated BigInteger, uniformly distributed over
     ; the range 0 to (2<sup>{@code numBits}</sup> - 1), inclusive.
     ; The uniformity of the distribution assumes that a fair source of random
     ; bits is provided in {@code rnd}. Note that this constructor always
     ; constructs a non-negative BigInteger.
     ;
     ; @param  numBits maximum bitLength of the new BigInteger.
     ; @param  rnd source of randomness to be used in computing the new BigInteger.
     ; @throws IllegalArgumentException {@code numBits} is negative.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"int" numBits, #_"Random" rnd]
        (BigInteger'new 1, (BigInteger'randomBits numBits, rnd))
    )

    (defn- #_"byte[]" BigInteger'randomBits [#_"int" numBits, #_"Random" rnd]
        (when (< numBits 0)
            (throw! "numBits must be non-negative")
        )

        (let [
              #_"int" numBytes (ß (int)(((long)numBits + 7) / 8)) ;; avoid overflow
              #_"byte[]" randomBits (ß new byte[numBytes])
        ]
            ;; generate random bytes and mask out any excess bits
            (when (< 0 numBytes)
                (ß rnd.nextBytes(randomBits))
                (let [
                      #_"int" excessBits (ß 8 * numBytes - numBits)
                ]
                    (§ ass (aget randomBits 0) (ß (ß randomBits[0] & ((1 << (8 - excessBits)) - 1))))
                )
            )
            randomBits
        )
    )

    ;; Minimum size in bits that the requested prime number has
    ;; before we use the large prime number generating algorithms.
    ;; The cutoff of 95 was chosen empirically for best performance.
    (def- #_"int" BigInteger'SMALL_PRIME_THRESHOLD 95)

    ;; certainty required to meet the spec of probablePrime
    (def- #_"int" BigInteger'DEFAULT_PRIME_CERTAINTY 100)

    (declare BigInteger'smallPrime)
    (declare BigInteger'largePrime)

    ;;;
     ; Constructs a randomly generated positive BigInteger that is probably
     ; prime, with the specified bitLength.
     ;
     ; It is recommended that the {@link #probablePrime probablePrime}
     ; method be used in preference to this constructor unless there
     ; is a compelling need to specify a certainty.
     ;
     ; @param  bitLength bitLength of the returned BigInteger.
     ; @param  certainty a measure of the uncertainty that the caller is willing to tolerate.
     ;         The probability that the new BigInteger represents a prime number will exceed
     ;         (1 - 1/2<sup>{@code certainty}</sup>). The execution time of
     ;         this constructor is proportional to the value of this parameter.
     ; @param  rnd source of random bits used to select candidates to be tested for primality.
     ; @throws ArithmeticException {@code bitLength < 2} or {@code bitLength} is too large.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"int" bitLength, #_"int" certainty, #_"Random" rnd]
        (when (< bitLength 2)
            (throw! "(< bitLength 2)")
        )

        (let [this (§ new)
              #_"BigInteger" prime (if (< bitLength BigInteger'SMALL_PRIME_THRESHOLD) (BigInteger'smallPrime bitLength, certainty, rnd) (BigInteger'largePrime bitLength, certainty, rnd))
        ]
            (§ ass (:signum this) 1)
            (§ ass (:mag this) (:mag prime))
            this
        )
    )

    ;;;
     ; Returns a positive BigInteger that is probably prime, with the
     ; specified bitLength. The probability that a BigInteger returned
     ; by this method is composite does not exceed 2<sup>-100</sup>.
     ;
     ; @param  bitLength bitLength of the returned BigInteger.
     ; @param  rnd source of random bits used to select candidates to be tested for primality.
     ; @return a BigInteger of {@code bitLength} bits that is probably prime.
     ; @throws ArithmeticException {@code bitLength < 2} or {@code bitLength} is too large.
     ;;
    (defn #_"BigInteger" BigInteger'probablePrime [#_"int" bitLength, #_"Random" rnd]
        (when (< bitLength 2)
            (throw! "(< bitLength 2)")
        )

        (if (< bitLength BigInteger'SMALL_PRIME_THRESHOLD) (ß BigInteger'smallPrime(bitLength, BigInteger'DEFAULT_PRIME_CERTAINTY, rnd)) (ß BigInteger'largePrime(bitLength, BigInteger'DEFAULT_PRIME_CERTAINTY, rnd)))
    )

    (def- #_"BigInteger" BigInteger'SMALL_PRIME_PRODUCT (ß BigInteger'valueOf-l(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41)))

    ;;;
     ; Find a random number of the specified bitLength that is probably prime.
     ; This method is used for smaller primes, its performance degrades on larger bitlengths.
     ;
     ; This method assumes bitLength > 1.
     ;;
    (defn- #_"BigInteger" BigInteger'smallPrime [#_"int" bitLength, #_"int" certainty, #_"Random" rnd]
        (let [
              #_"int" magLen (ß (bitLength + 31) >>> 5)
              #_"int[]" temp (ß new int[magLen])
              #_"int" highBit (ß 1 << ((bitLength + 31) & 0x1f)) ;; high bit of high int
              #_"int" highMask (ß (highBit << 1) - 1) ;; bits to keep in high int
        ]
            (§ while true
                ;; construct a candidate
                (loop-when-recur [#_"int" i 0] (< i magLen) [(inc i)]
                    (§ ass (aget temp i) (ß rnd.nextInt()))
                )
                (§ ass (aget temp 0) (ß (temp[0] & highMask) | highBit)) ;; ensure exact length
                (when (< 2 bitLength)
                    (§ ass (aget temp (dec magLen)) (ß (ß temp[magLen - 1] | 1))) ;; make odd if bitlen > 2
                )

                (let [
                      #_"BigInteger" p (BigInteger'new temp, 1)
                ]
                    ;; do cheap "pre-test" if applicable
                    (when (< 6 bitLength)
                        (let [
                              #_"long" r (ß BigInteger''remainder(p, BigInteger'SMALL_PRIME_PRODUCT).longValue())
                        ]
                            (when (or (ß r % 3 == 0) (ß r % 5 == 0) (ß r % 7 == 0) (ß r % 11 == 0) (ß r % 13 == 0) (ß r % 17 == 0) (ß r % 19 == 0) (ß r % 23 == 0) (ß r % 29 == 0) (ß r % 31 == 0) (ß r % 37 == 0) (ß r % 41 == 0))
                                (§ continue) ;; candidate is composite; try another
                            )
                        )
                    )

                    ;; all candidates of bitLength 2 and 3 are prime by this point
                    (when (< bitLength 4)
                        (§ return p)
                    )

                    ;; do expensive test if we survive pre-test (or it's inapplicable)
                    (when (BigInteger''primeToCertainty p, certainty, rnd)
                        (§ return p)
                    )
                )
            )
        )
    )

    (declare BigInteger'getPrimeSearchLen)

    ;;;
     ; Find a random number of the specified bitLength that is probably prime.
     ; This method is more appropriate for larger bitlengths since it uses
     ; a sieve to eliminate most composites before using a more expensive test.
     ;;
    (defn- #_"BigInteger" BigInteger'largePrime [#_"int" bitLength, #_"int" certainty, #_"Random" rnd]
        (let [
              #_"BigInteger" p (ß BigInteger'new(bitLength, rnd).BigInteger''setBit((§ pipe), bitLength - 1))
        ]
            (§ ass (ß p.mag[p.mag.length - 1]) (ß (ß p.mag[p.mag.length - 1] & 0xfffffffe)))

            ;; use a sieve length likely to contain the next prime number
            (let [
                  #_"int" searchLen (BigInteger'getPrimeSearchLen bitLength)
                  #_"BitSieve" searchSieve (BitSieve'new p, searchLen)
                  #_"BigInteger" candidate (BitSieve''retrieve searchSieve, p, certainty, rnd)
            ]
                (while (or (ß candidate == nil) (ß BigInteger''bitLength(candidate) != bitLength))
                    (let [
                    ]
                        (§ ass p (ß BigInteger''add(p, BigInteger'valueOf-l(2 * searchLen))))
                        (when (ß BigInteger''bitLength(p) != bitLength)
                            (§ ass p (ß BigInteger'new(bitLength, rnd).BigInteger''setBit((§ pipe), bitLength - 1)))
                        )
                        (§ ass (ß p.mag[p.mag.length - 1]) (ß (ß p.mag[p.mag.length - 1] & 0xfffffffe)))
                        (§ ass searchSieve (BitSieve'new p, searchLen))
                        (§ ass candidate (BitSieve''retrieve searchSieve, p, certainty, rnd))
                    )
                )
                candidate
            )
        )
    )

    (declare BigInteger''bitLength)
    (declare BigInteger''testBit)

    ;;;
     ; Returns the first integer greater than this {@code BigInteger} that
     ; is probably prime. The probability that the number returned by this
     ; method is composite does not exceed 2<sup>-100</sup>. This method will
     ; never skip over a prime when searching: if it returns {@code p}, there
     ; is no prime {@code q} such that {@code this < q < p}.
     ;
     ; @return the first integer greater than this {@code BigInteger} that is probably prime.
     ; @throws ArithmeticException {@code this < 0} or {@code this} is too large.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''nextProbablePrime [#_"BigInteger" this]
        (when (ß this.signum < 0)
            (throw! "negative start")
        )

        ;; handle trivial cases
        (when (or (ß this.signum == 0) (ß this.equals(BigInteger'ONE)))
            (§ return (ß BigInteger'TWO))
        )

        (let [
              #_"BigInteger" result (ß BigInteger''add(this, BigInteger'ONE))
        ]
            ;; fastpath for small numbers
            (when (ß BigInteger''bitLength(result) < BigInteger'SMALL_PRIME_THRESHOLD)
                ;; ensure an odd number
                (when (ß !BigInteger''testBit(result, 0))
                    (§ ass result (ß BigInteger''add(result, BigInteger'ONE)))
                )

                (§ while true
                    ;; do cheap "pre-test" if applicable
                    (when (ß BigInteger''bitLength(result) > 6)
                        (let [
                              #_"long" r (ß BigInteger''remainder(result, BigInteger'SMALL_PRIME_PRODUCT).longValue())
                        ]
                            (when (or (ß r % 3 == 0) (ß r % 5 == 0) (ß r % 7 == 0) (ß r % 11 == 0) (ß r % 13 == 0) (ß r % 17 == 0) (ß r % 19 == 0) (ß r % 23 == 0) (ß r % 29 == 0) (ß r % 31 == 0) (ß r % 37 == 0) (ß r % 41 == 0))
                                (§ ass result (ß BigInteger''add(result, BigInteger'TWO)))
                                (§ continue) ;; candidate is composite; try another
                            )
                        )
                    )

                    ;; all candidates of bitLength 2 and 3 are prime by this point
                    (when (ß BigInteger''bitLength(result) < 4)
                        (§ return result)
                    )

                    ;; the expensive test
                    (when (ß BigInteger''primeToCertainty(result, BigInteger'DEFAULT_PRIME_CERTAINTY, nil))
                        (§ return result)
                    )

                    (§ ass result (ß BigInteger''add(result, BigInteger'TWO)))
                )
            )

            ;; start at previous even number
            (when (BigInteger''testBit result, 0)
                (§ ass result (ß BigInteger''subtract(result, BigInteger'ONE)))
            )

            ;; looking for the next large prime
            (let [
                  #_"int" searchLen (ß BigInteger'getPrimeSearchLen(BigInteger''bitLength(result)))
            ]
                (§ while true
                    (let [
                          #_"BitSieve" searchSieve (BitSieve'new result, searchLen)
                          #_"BigInteger" candidate (ß BitSieve''retrieve(searchSieve, result, BigInteger'DEFAULT_PRIME_CERTAINTY, nil))
                    ]
                        (when (ß candidate != nil)
                            (§ return candidate)
                        )
                        (§ ass result (ß BigInteger''add(result, BigInteger'valueOf-l(2 * searchLen))))
                    )
                )
            )
        )
    )

    (defn- #_"int" BigInteger'getPrimeSearchLen [#_"int" bitLength]
        (when (ß bitLength > BigInteger'PRIME_SEARCH_BIT_LENGTH_LIMIT + 1)
            (throw! "prime search implementation restriction on bitLength")
        )
        (ß bitLength / 20 * 64)
    )

    ;;;
     ; Returns {@code true} if this BigInteger is probably prime,
     ; {@code false} if it's definitely composite.
     ;
     ; This method assumes bitLength > 2.
     ;
     ; @param  certainty a measure of the uncertainty that the caller is
     ;         willing to tolerate: if the call returns {@code true}
     ;         the probability that this BigInteger is prime exceeds
     ;         {@code (1 - 1/2<sup>certainty</sup>)}. The execution time of
     ;         this method is proportional to the value of this parameter.
     ; @return {@code true} if this BigInteger is probably prime,
     ;         {@code false} if it's definitely composite.
     ;;
    #_method
    (defn #_"boolean" BigInteger''primeToCertainty [#_"BigInteger" this, #_"int" certainty, #_"Random" random]
        (let [
              #_"int" rounds 0
              #_"int" n (ß (Math/min(certainty, Integer/MAX_VALUE - 1) + 1) / 2)
              ;; The relationship between the certainty and the number of rounds we perform is given in the draft
              ;; standard ANSI X9.80, "PRIME NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES".
              #_"int" sizeInBits (BigInteger''bitLength this)
        ]
            (when (< sizeInBits 100)
                (§ ass rounds 50)
                (§ ass rounds (if (< n rounds) n rounds))
                (§ return (BigInteger''passesMillerRabin this, rounds, random))
            )

            (cond (< sizeInBits 256)
                (do
                    (§ ass rounds 27)
                )
                (< sizeInBits 512)
                (do
                    (§ ass rounds 15)
                )
                (< sizeInBits 768)
                (do
                    (§ ass rounds 8)
                )
                (< sizeInBits 1024)
                (do
                    (§ ass rounds 4)
                )
                :else
                (do
                    (§ ass rounds 2)
                )
            )
            (§ ass rounds (if (< n rounds) n rounds))

            (and (ß BigInteger''passesMillerRabin(this, rounds, random)) (ß BigInteger''passesLucasLehmer(this)))
        )
    )

    (declare BigInteger'lucasLehmerSequence)

    ;;;
     ; Returns true iff this BigInteger is a Lucas-Lehmer probable prime.
     ;
     ; The following assumptions are made:
     ; This BigInteger is a positive, odd number.
     ;;
    #_method
    (defn- #_"boolean" BigInteger''passesLucasLehmer [#_"BigInteger" this]
        (let [
              #_"BigInteger" thisPlusOne (ß BigInteger''add(this, BigInteger'ONE))
              ;; step 1
              #_"int" d 5
        ]
            (while (ß BigInteger'jacobiSymbol(d, this) != -1)
                ;; 5, -7, 9, -11, ...
                (§ ass d (if (< d 0) (+ (Math/abs d) 2) (- (+ d 2))))
            )

            ;; step 2
            (let [
                  #_"BigInteger" u (BigInteger'lucasLehmerSequence d, thisPlusOne, this)
            ]
                ;; step 3
                (ß BigInteger''mod(u, this).equals(BigInteger'ZERO))
            )
        )
    )

    (declare BigInteger'valueOf-l)

    ;;;
     ; Computes Jacobi(p,n).
     ; Assumes n positive, odd, n>=3.
     ;;
    (defn- #_"int" BigInteger'jacobiSymbol [#_"int" p, #_"BigInteger" n]
        (when (ß p == 0)
            (§ return 0)
        )

        ;; Algorithm and comments adapted from Colin Plumb's C library.
        (let [
              #_"int" j 1
              #_"int" u (ß n.mag[n.mag.length - 1])
        ]
            ;; make p positive
            (when (< p 0)
                (§ ass p (- p))
                (let [
                      #_"int" n8 (ß u & 7)
                ]
                    (when (or (ß n8 == 3) (ß n8 == 7))
                        (§ ass j (- j)) ;; 3 (011) or 7 (111) mod 8
                    )
                )
            )

            ;; get rid of factors of 2 in p
            (while (ß (p & 3) == 0)
                (§ ass p (ß p >> 2))
            )
            (when (ß (p & 1) == 0)
                (§ ass p (ß p >> 1))
                (when (ß ((u (§ bit-xor) (u >> 1)) & 2) != 0)
                    (§ ass j (- j)) ;; 3 (011) or 5 (101) mod 8
                )
            )
            (when (ß p == 1)
                (§ return j)
            )
            ;; then, apply quadratic reciprocity
            (when (ß (p & u & 2) != 0) ;; p = u = 3 (mod 4)?
                (§ ass j (- j))
            )
            ;; and reduce u mod p
            (§ ass u (ß BigInteger''mod(n, BigInteger'valueOf-l(p)).intValue()))

            ;; now compute Jacobi(u,p), u < p
            (while (ß u != 0)
                (while (ß (u & 3) == 0)
                    (§ ass u (ß u >> 2))
                )
                (when (ß (u & 1) == 0)
                    (§ ass u (ß u >> 1))
                    (when (ß ((p (§ bit-xor) (p >> 1)) & 2) != 0)
                        (§ ass j (- j)) ;; 3 (011) or 5 (101) mod 8
                    )
                )
                (when (ß u == 1)
                    (§ return j)
                )
                ;; now both u and p are odd, so use quadratic reciprocity
                (when-not (< u p)
                    (throw! "(not (< u p))")
                )
                (let [
                      #_"int" t u
                      u p
                      p t
                ]
                    (when (ß (u & p & 2) != 0) ;; u = p = 3 (mod 4)?
                        (§ ass j (- j))
                    )
                    ;; now u >= p, so it can be reduced
                    (§ ass u (ß u % p))
                )
            )
            0
        )
    )

    (defn- #_"BigInteger" BigInteger'lucasLehmerSequence [#_"int" z, #_"BigInteger" k, #_"BigInteger" n]
        (let [
              #_"BigInteger" d (BigInteger'valueOf-l z)
              #_"BigInteger" u (ß BigInteger'ONE)
              #_"BigInteger" u2 (ß )
              #_"BigInteger" v (ß BigInteger'ONE)
              #_"BigInteger" v2 (ß )
        ]
            (loop-when-recur [#_"int" i (ß BigInteger''bitLength(k) - 2)] (<= 0 i) [(dec i)]
                (§ ass u2 (ß BigInteger''multiply(u, v).BigInteger''mod((§ pipe), n)))

                (§ ass v2 (ß BigInteger''square(v).BigInteger''add((§ pipe), BigInteger''multiply(d, BigInteger''square(u))).BigInteger''mod((§ pipe), n)))
                (when (BigInteger''testBit v2, 0)
                    (§ ass v2 (BigInteger''subtract v2, n))
                )

                (§ ass v2 (BigInteger''shiftRight v2, 1))

                (§ ass u u2)
                (§ ass v v2)
                (when (BigInteger''testBit k, i)
                    (§ ass u2 (ß BigInteger''add(u, v).BigInteger''mod((§ pipe), n)))
                    (when (BigInteger''testBit u2, 0)
                        (§ ass u2 (BigInteger''subtract u2, n))
                    )

                    (§ ass u2 (BigInteger''shiftRight u2, 1))
                    (§ ass v2 (ß BigInteger''add(v, BigInteger''multiply(d, u)).BigInteger''mod((§ pipe), n)))
                    (when (BigInteger''testBit v2, 0)
                        (§ ass v2 (BigInteger''subtract v2, n))
                    )
                    (§ ass v2 (BigInteger''shiftRight v2, 1))

                    (§ ass u u2)
                    (§ ass v v2)
                )
            )
            u
        )
    )

    (declare BigInteger''getLowestSetBit)
    (declare BigInteger''modPow)

    ;;;
     ; Returns true iff this BigInteger passes the specified number of Miller-Rabin tests.
     ; This test is taken from the DSA spec (NIST FIPS 186-2).
     ;
     ; The following assumptions are made:
     ; This BigInteger is a positive, odd number greater than 2.
     ; iterations<=50.
     ;;
    #_method
    (defn- #_"boolean" BigInteger''passesMillerRabin [#_"BigInteger" this, #_"int" iterations, #_"Random" rnd]
        ;; find a and m such that m is odd and this == 1 + 2**a * m
        (let [
              #_"BigInteger" thisMinusOne (ß BigInteger''subtract(this, BigInteger'ONE))
              #_"BigInteger" m thisMinusOne
              #_"int" a (BigInteger''getLowestSetBit m)
              _ (§ ass m (BigInteger''shiftRight m, a))
        ]
            ;; do the tests
            (when (ß rnd == nil)
                (§ ass rnd (ß ThreadLocalRandom/current()))
            )
            (loop-when-recur [#_"int" i 0] (< i iterations) [(inc i)]
                ;; generate a uniform random on (1, this)
                (let [
                      #_"BigInteger" b (ß )
                ]
                    (loop []
                        (§ ass b (ß BigInteger'new(BigInteger''bitLength(this), rnd)))
                        (recur-if (or (ß b.compareTo(BigInteger'ONE) <= 0) (ß b.compareTo(this) >= 0)) [])
                    )

                    (let [
                        #_"int" j 0
                        #_"BigInteger" z (BigInteger''modPow b, m, this)
                    ]
                        (while (not (or (and (ß j == 0) (ß z.equals(BigInteger'ONE))) (ß z.equals(thisMinusOne))))
                            (when (and (ß j > 0) (ß z.equals(BigInteger'ONE)))
                                (§ return false)
                            )
                            (§ ass j (inc j))
                            (when (ß j == a)
                                (§ return false)
                            )
                            (§ ass z (ß BigInteger''modPow(z, BigInteger'TWO, this)))
                        )
                    )
                )
            )
            true
        )
    )

    ;;;
     ; This internal constructor differs from its public cousin
     ; with the arguments reversed in two ways: it assumes that its
     ; arguments are correct, and it doesn't copy the magnitude array.
     ;;
    (defn #_"BigInteger" BigInteger'new [#_"int[]" magnitude, #_"int" signum]
        (let [this (§ new)
        ]
            (§ ass (:signum this) (if (ß magnitude.length == 0) 0 signum))
            (§ ass (:mag this) magnitude)
            (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                (BigInteger''checkRange this)
            )
            this
        )
    )

    ;;;
     ; This private constructor is for internal use and assumes that its
     ; arguments are correct.
     ;;
    (defn- #_"BigInteger" BigInteger'new [#_"byte[]" magnitude, #_"int" signum]
        (let [this (§ new)
        ]
            (§ ass (:signum this) (if (ß magnitude.length == 0) 0 signum))
            (§ ass (:mag this) (BigInteger'stripLeadingZeroBytes magnitude))
            (when (ß this.mag.length >= BigInteger'MAX_MAG_LENGTH)
                (BigInteger''checkRange this)
            )
            this
        )
    )

    ;;;
     ; Throws an {@code ArithmeticException} if the {@code BigInteger} would be
     ; out of the supported range.
     ;
     ; @throws ArithmeticException if {@code this} exceeds the supported range.
     ;;
    #_method
    (defn- #_"void" BigInteger''checkRange [#_"BigInteger" this]
        (when (or (ß this.mag.length > BigInteger'MAX_MAG_LENGTH) (and (ß this.mag.length == BigInteger'MAX_MAG_LENGTH) (ß this.mag[0] < 0)))
            (throw! "magnitude overflow")
        )
        nil
    )

    ;; static factory methods

    ;;;
     ; Returns a BigInteger whose value is equal to that of the specified {@code long}.
     ; This "static factory method" is provided in preference to a ({@code long}) constructor
     ; because it allows for reuse of frequently used BigIntegers.
     ;
     ; @param  val value of the BigInteger to return.
     ; @return a BigInteger with the specified value.
     ;;
    (defn #_"BigInteger" BigInteger'valueOf [#_"long" val]
        ;; if -MAX_CONSTANT < val < MAX_CONSTANT, return stashed constant
        (when (ß val == 0)
            (§ return (ß BigInteger'ZERO))
        )
        (cond (and (ß val > 0) (ß val <= BigInteger'MAX_CONSTANT))
            (do
                (§ return (ß BigInteger'posConst[(int) val]))
            )
            (and (ß val < 0) (ß val >= (- BigInteger'MAX_CONSTANT)))
            (do
                (§ return (ß BigInteger'negConst[(int) (- val)]))
            )
        )

        (BigInteger'new val)
    )

    ;;;
     ; Constructs a BigInteger with the specified value, which may not be zero.
     ;;
    (defn- #_"BigInteger" BigInteger'new [#_"long" val]
        (let [this (§ new)
        ]
            (cond (< val 0)
                (do
                    (§ ass val (- val))
                    (§ ass (:signum this) -1)
                )
                :else
                (do
                    (§ ass (:signum this) 1)
                )
            )

            (let [
                #_"int" highWord (ß (int)(val >>> 32))
            ]
                (cond (ß highWord == 0)
                    (do
                        (§ ass (:mag this) (ß new int[1]))
                        (§ ass (ß this.mag[0]) (ß (int)val))
                    )
                    :else
                    (do
                        (§ ass (:mag this) (ß new int[2]))
                        (§ ass (ß this.mag[0]) highWord)
                        (§ ass (ß this.mag[1]) (ß (int)val))
                    )
                )
                this
            )
        )
    )

    ;;;
     ; Returns a BigInteger with the given two's complement representation.
     ; Assumes that the input array will not be modified (the returned
     ; BigInteger will reference the input array if feasible).
     ;;
    (defn- #_"BigInteger" BigInteger'valueOf [#_"int[]" val]
        (if (ß val[0] > 0) (BigInteger'new val, 1) (BigInteger'new val))
    )

    ;; constants

    (def- #_"int" BigInteger'MAX_CONSTANT 16)

    (def- #_"BigInteger[]" BigInteger'posConst (ß new BigInteger[BigInteger'MAX_CONSTANT + 1]))
    (def- #_"BigInteger[]" BigInteger'negConst (ß new BigInteger[BigInteger'MAX_CONSTANT + 1]))

    #_static
    (§
        ;;;
         ; Initialize static constant array when class is loaded.
         ;;
        (loop-when-recur [#_"int" i 1] (<= i BigInteger'MAX_CONSTANT) [(inc i)]
            (let [
                  #_"int[]" magnitude (ß new int[1])
            ]
                (§ ass (aget magnitude 0) i)
                (§ ass (ß BigInteger'posConst[i]) (BigInteger'new magnitude,  1))
                (§ ass (ß BigInteger'negConst[i]) (BigInteger'new magnitude, -1))
            )
        )
    )

    ;;;
     ; The cache of powers of each radix. This allows us to not have to
     ; recalculate powers of radix^(2^n) more than once. This speeds
     ; Schoenhage recursive base conversion significantly.
     ;;
    #_volatile
    (def- #_"BigInteger[][]" BigInteger'powerCache (ß new BigInteger[Character/MAX_RADIX + 1][]))

    ;;;
     ; The cache of logarithms of radices for base conversion.
     ;;
    (def- #_"double[]" BigInteger'logCache (ß new double[Character/MAX_RADIX + 1]))

    ;;;
     ; The natural log of 2. This is used in computing cache indices.
     ;;
    (def- #_"double" BigInteger'LOG_TWO (ß Math/log(2.0)))

    #_static
    (§
        ;;
         ; Initialize the cache of radix^(2^x) values used for base conversion with
         ; just the very first value. Additional values will be created on demand.
         ;;
        (loop-when-recur [#_"int" i (ß Character/MIN_RADIX)] (ß i <= Character/MAX_RADIX) [(inc i)]
            (§ ass (ß BigInteger'powerCache[i]) (ß new BigInteger[] (§ init BigInteger'valueOf-l(i) )))
            (§ ass (ß BigInteger'logCache[i]) (ß Math/log(i)))
        )
    )

    ;;;
     ; The BigInteger constant zero.
     ;;
    (def #_"BigInteger" BigInteger'ZERO (ß BigInteger'new(new int[0], 0)))

    ;;;
     ; The BigInteger constant one.
     ;;
    (def #_"BigInteger" BigInteger'ONE (§ soon BigInteger'valueOf-l 1))

    ;;;
     ; The BigInteger constant two. (Not exported.)
     ;;
    (def- #_"BigInteger" BigInteger'TWO (§ soon BigInteger'valueOf-l 2))

    ;;;
     ; The BigInteger constant -1. (Not exported.)
     ;;
    (def- #_"BigInteger" BigInteger'NEGATIVE_ONE (§ soon BigInteger'valueOf-l -1))

    ;;;
     ; The BigInteger constant ten.
     ;;
    (def #_"BigInteger" BigInteger'TEN (§ soon BigInteger'valueOf-l 10))

    ;; arithmetic operations

    (declare BigInteger''compareMagnitude-i)

    ;;;
     ; Returns a BigInteger whose value is {@code (this + val)}.
     ;
     ; @param  val value to be added to this BigInteger.
     ; @return {@code this + val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''add [#_"BigInteger" this, #_"BigInteger" val]
        (when (ß val.signum == 0)
            (§ return this)
        )
        (when (ß this.signum == 0)
            (§ return val)
        )
        (when (ß val.signum == this.signum)
            (§ return (ß BigInteger'new(BigInteger'add(this.mag, val.mag), this.signum)))
        )

        (let [
              #_"int" cmp (BigInteger''compareMagnitude-i this, val)
        ]
            (when (ß cmp == 0)
                (§ return (ß BigInteger'ZERO))
            )
            (let [
                  #_"int[]" resultMag (if (< 0 cmp) (ß BigInteger'subtract(this.mag, val.mag)) (ß BigInteger'subtract(val.mag, this.mag)))
                  _ (§ ass resultMag (BigInteger'trustedStripLeadingZeroInts resultMag))
            ]
                (ß BigInteger'new(resultMag, (if (ß cmp == this.signum) 1 -1)))
            )
        )
    )

    ;;;
     ; Adds the contents of the int arrays x and y. This method allocates a
     ; new int array to hold the answer and returns a reference to that array.
     ;;
    (defn- #_"int[]" BigInteger'add [#_"int[]" x, #_"int[]" y]
        ;; if x is shorter, swap the two arrays
        (when (ß x.length < y.length)
            (let [
                  #_"int[]" tmp x
            ]
                (§ ass x y)
                (§ ass y tmp)
            )
        )

        (let [
              #_"int" xIndex (:length x)
              #_"int" yIndex (:length y)
              #_"int[]" result (ß new int[xIndex])
              #_"long" sum 0
        ]
            (cond (ß yIndex == 1)
                (do
                    (§ ass xIndex (dec xIndex))
                    (§ ass sum (ß (x[xIndex] & BigInteger'LONG_MASK) + (y[0] & BigInteger'LONG_MASK)))
                    (§ ass (aget result xIndex) (ß (int)sum))
                )
                :else
                (do
                    ;; add common parts of both numbers
                    (while (< 0 yIndex)
                        (§ ass xIndex (dec xIndex))
                        (§ ass yIndex (dec yIndex))
                        (§ ass sum (ß (x[xIndex] & BigInteger'LONG_MASK) + (y[yIndex] & BigInteger'LONG_MASK) + (sum >>> 32)))
                        (§ ass (aget result xIndex) (ß (int)sum))
                    )
                )
            )
            ;; copy remainder of longer number while carry propagation is required
            (let [
                  #_"boolean" carry (ß (sum >>> 32 != 0))
            ]
                (while (and (ß xIndex > 0) carry)
                    (§ ass xIndex (dec xIndex))
                    (§ ass (aget result xIndex) (ß x[xIndex] + 1))
                    (§ ass carry (ß (result[xIndex] == 0)))
                )

                ;; copy remainder of longer number
                (while (< 0 xIndex)
                    (§ ass xIndex (dec xIndex))
                    (§ ass (aget result xIndex) (aget x xIndex))
                )

                ;; grow result if necessary
                (when carry
                    (let [
                          #_"int[]" bigger (ß new int[result.length + 1])
                    ]
                        (ß System/arraycopy(result, 0, bigger, 1, result.length))
                        (§ ass (aget bigger 0) 0x01)
                        (§ return bigger)
                    )
                )
                result
            )
        )
    )

    (defn- #_"int[]" BigInteger'subtract [#_"long" val, #_"int[]" little]
        (let [
              #_"int" highWord (ß (int)(val >>> 32))
        ]
            (cond (ß highWord == 0)
                (let [
                      #_"int[]" result (ß new int[1])
                ]
                    (§ ass (aget result 0) (ß (int)(val - (little[0] & BigInteger'LONG_MASK))))
                    (§ return result)
                )
                :else
                (let [
                      #_"int[]" result (ß new int[2])
                ]
                    (cond (ß little.length == 1)
                        (let [
                              #_"long" difference (ß ((int)val & BigInteger'LONG_MASK) - (little[0] & BigInteger'LONG_MASK))
                        ]
                            (§ ass (aget result 1) (ß (int)difference))
                            ;; subtract remainder of longer number while borrow propagates
                            (let [
                                  #_"boolean" borrow (ß (difference >> 32 != 0))
                            ]
                                (cond borrow
                                    (do
                                        (§ ass (aget result 0) (dec highWord))
                                    )
                                    :else ;; copy remainder of longer number
                                    (do
                                        (§ ass (aget result 0) highWord)
                                    )
                                )
                                (§ return result)
                            )
                        )
                        :else ;; little.length == 2
                        (let [
                              #_"long" difference (ß ((int)val & BigInteger'LONG_MASK) - (little[1] & BigInteger'LONG_MASK))
                        ]
                            (§ ass (aget result 1) (ß (int)difference))
                            (§ ass difference (ß (highWord & BigInteger'LONG_MASK) - (little[0] & BigInteger'LONG_MASK) + (difference >> 32)))
                            (§ ass (aget result 0) (ß (int)difference))
                            (§ return result)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Subtracts the contents of the second argument (val) from the first (big).
     ; The first int array (big) must represent a larger number than the second.
     ; This method allocates the space necessary to hold the answer.
     ; assumes val >= 0
     ;;
    (defn- #_"int[]" BigInteger'subtract [#_"int[]" big, #_"long" val]
        (let [
              #_"int" highWord (ß (int)(val >>> 32))
              #_"int" bigIndex (ß big.length)
              #_"int[]" result (ß new int[bigIndex])
              #_"long" difference 0
        ]
            (cond (ß highWord == 0)
                (do
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass difference (ß (big[bigIndex] & BigInteger'LONG_MASK) - val))
                    (§ ass (aget result bigIndex) (ß (int)difference))
                )
                :else
                (do
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass difference (ß (big[bigIndex] & BigInteger'LONG_MASK) - (val & BigInteger'LONG_MASK)))
                    (§ ass (aget result bigIndex) (ß (int)difference))
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass difference (ß (big[bigIndex] & BigInteger'LONG_MASK) - (highWord & BigInteger'LONG_MASK) + (difference >> 32)))
                    (§ ass (aget result bigIndex) (ß (int)difference))
                )
            )

            ;; subtract remainder of longer number while borrow propagates
            (let [
                  #_"boolean" borrow (ß (difference >> 32 != 0))
            ]
                (while (and (ß bigIndex > 0) borrow)
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass (aget result bigIndex) (ß big[bigIndex] - 1))
                    (§ ass borrow (ß (result[bigIndex] == -1)))
                )

                ;; copy remainder of longer number
                (while (< 0 bigIndex)
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass (aget result bigIndex) (aget big bigIndex))
                )

                result
            )
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this - val)}.
     ;
     ; @param  val value to be subtracted from this BigInteger.
     ; @return {@code this - val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''subtract [#_"BigInteger" this, #_"BigInteger" val]
        (when (ß val.signum == 0)
            (§ return this)
        )
        (when (ß this.signum == 0)
            (§ return (BigInteger''negate val))
        )
        (when (ß val.signum != this.signum)
            (§ return (ß BigInteger'new(BigInteger'add(this.mag, val.mag), this.signum)))
        )

        (let [
              #_"int" cmp (BigInteger''compareMagnitude-i this, val)
        ]
            (when (ß cmp == 0)
                (§ return (ß BigInteger'ZERO))
            )
            (let [
                  #_"int[]" resultMag (if (< 0 cmp) (ß BigInteger'subtract(this.mag, val.mag)) (ß BigInteger'subtract(val.mag, this.mag)))
                  _ (§ ass resultMag (BigInteger'trustedStripLeadingZeroInts resultMag))
            ]
                (ß BigInteger'new(resultMag, (if (ß cmp == this.signum) 1 -1)))
            )
        )
    )

    ;;;
     ; Subtracts the contents of the second int arrays (little) from the first (big).
     ; The first int array (big) must represent a larger number than the second.
     ; This method allocates the space necessary to hold the answer.
     ;;
    (defn- #_"int[]" BigInteger'subtract [#_"int[]" big, #_"int[]" little]
        (let [
              #_"int" bigIndex (ß big.length)
              #_"int[]" result (ß new int[bigIndex])
              #_"int" littleIndex (ß little.length)
              #_"long" difference 0
        ]
            ;; subtract common parts of both numbers
            (while (< 0 littleIndex)
                (§ ass bigIndex (dec bigIndex))
                (§ ass littleIndex (dec littleIndex))
                (§ ass difference (ß (big[bigIndex] & BigInteger'LONG_MASK) - (little[littleIndex] & BigInteger'LONG_MASK) + (difference >> 32)))
                (§ ass (aget result bigIndex) (ß (int)difference))
            )

            ;; subtract remainder of longer number while borrow propagates
            (let [
                  #_"boolean" borrow (ß (difference >> 32 != 0))
            ]
                (while (and (ß bigIndex > 0) borrow)
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass (aget result bigIndex) (ß big[bigIndex] - 1))
                    (§ ass borrow (ß (result[bigIndex] == -1)))
                )

                ;; copy remainder of longer number
                (while (< 0 bigIndex)
                    (§ ass bigIndex (dec bigIndex))
                    (§ ass (aget result bigIndex) (aget big bigIndex))
                )

                result
            )
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this * val)}.
     ;
     ; @param  val value to be multiplied by this BigInteger.
     ; @return {@code this * val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''multiply [#_"BigInteger" this, #_"BigInteger" val]
        (when (or (ß val.signum == 0) (ß this.signum == 0))
            (§ return (ß BigInteger'ZERO))
        )

        (let [
              #_"int" xlen (ß this.mag.length)
              #_"int" ylen (ß val.mag.length)
              #_"int" resultSign (if (ß this.signum == val.signum) 1 -1)
        ]
            (when (ß val.mag.length == 1)
                (§ return (ß BigInteger'multiplyByInt(this.mag, val.mag[0], resultSign)))
            )
            (when (ß this.mag.length == 1)
                (§ return (ß BigInteger'multiplyByInt(val.mag, this.mag[0], resultSign)))
            )
            (let [
                  #_"int[]" result (ß BigInteger''multiplyToLen(this, this.mag, xlen, val.mag, ylen, nil))
                  _ (§ ass result (BigInteger'trustedStripLeadingZeroInts result))
            ]
                (BigInteger'new result, resultSign)
            )
        )
    )

    (defn- #_"BigInteger" BigInteger'multiplyByInt [#_"int[]" x, #_"int" y, #_"int" sign]
        (when (ß Integer/bitCount(y) == 1)
            (§ return (ß BigInteger'new(BigInteger'shiftLeft(x, Integer/numberOfTrailingZeros(y)), sign)))
        )
        (let [
              #_"int" xlen (:length x)
              #_"int[]" rmag (ß new int[xlen + 1])
              #_"long" carry 0
              #_"long" yl (ß y & BigInteger'LONG_MASK)
              #_"int" rstart (ß rmag.length - 1)
        ]
            (loop-when-recur [#_"int" i (dec xlen)] (<= 0 i) [(dec i)]
                (let [
                      #_"long" product (ß (x[i] & BigInteger'LONG_MASK) * yl + carry)
                ]
                    (§ ass (aget rmag rstart) (ß (int)product))
                    (§ ass rstart (dec rstart))
                    (§ ass carry (ß product >>> 32))
                )
            )
            (cond (ß carry == 0)
                (do
                    (§ ass rmag (ß Arrays/copyOfRange(rmag, 1, rmag.length)))
                )
                :else
                (do
                    (§ ass (aget rmag rstart) (ß (int)carry))
                )
            )
            (BigInteger'new rmag, sign)
        )
    )

    ;;;
     ; Multiplies int arrays x and y to the specified lengths and places the
     ; result into z. There will be no leading zeros in the resultant array.
     ;;
    #_method
    (defn- #_"int[]" BigInteger''multiplyToLen [#_"BigInteger" this, #_"int[]" x, #_"int" xlen, #_"int[]" y, #_"int" ylen, #_"int[]" z]
        (let [
              #_"int" xstart (dec xlen)
              #_"int" ystart (dec ylen)
        ]
            (when (or (ß z == nil) (ß z.length < (xlen + ylen)))
                (§ ass z (ß new int[xlen + ylen]))
            )

            (let [
                  #_"long" carry 0
            ]
                (loop-when-recur [#_"int" j ystart #_"int" k (ß ystart + 1 + xstart)] (<= 0 j) [(dec j) (dec k)]
                    (let [
                          #_"long" product (ß (y[j] & BigInteger'LONG_MASK) * (x[xstart] & BigInteger'LONG_MASK) + carry)
                    ]
                        (§ ass (aget z k) (ß (int)product))
                        (§ ass carry (ß product >>> 32))
                    )
                )
                (§ ass (aget z xstart) (ß (int)carry))

                (loop-when-recur [#_"int" i (dec xstart)] (<= 0 i) [(dec i)]
                    (let [
                    ]
                        (§ ass carry 0)
                        (loop-when-recur [#_"int" j ystart #_"int" k (ß ystart + 1 + i)] (<= 0 j) [(dec j) (dec k)]
                            (let [
                                  #_"long" product (ß (y[j] & BigInteger'LONG_MASK) * (x[i] & BigInteger'LONG_MASK) + (z[k] & BigInteger'LONG_MASK) + carry)
                            ]
                                (§ ass (aget z k) (ß (int)product))
                                (§ ass carry (ß product >>> 32))
                            )
                        )
                        (§ ass (aget z i) (ß (int)carry))
                    )
                )
                z
            )
        )
    )

    ;; squaring

    ;;;
     ; Returns a BigInteger whose value is {@code (this<sup>2</sup>)}.
     ;
     ; @return {@code this<sup>2</sup>}
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''square [#_"BigInteger" this]
        (when (ß this.signum == 0)
            (§ return (ß BigInteger'ZERO))
        )

        (let [
              #_"int[]" z (ß BigInteger'squareToLen(this.mag, this.mag.length, nil))
        ]
            (ß BigInteger'new(BigInteger'trustedStripLeadingZeroInts(z), 1))
        )
    )

    (declare BigInteger'addOne)
    (declare BigInteger'primitiveLeftShift)

    ;;;
     ; Squares the contents of the int array x. The result is placed into the
     ; int array z. The contents of x are not changed.
     ;
     ; The algorithm used here is adapted from Colin Plumb's C library.
     ; Technique: Consider the partial products in the multiplication
     ; of "abcde" by itself:
     ;
     ;               a  b  c  d  e
     ;            *  a  b  c  d  e
     ;          ==================
     ;              ae be ce de ee
     ;           ad bd cd dd de
     ;        ac bc cc cd ce
     ;     ab bb bc bd be
     ;  aa ab ac ad ae
     ;
     ; Note that everything above the main diagonal:
     ;              ae be ce de = (abcd) * e
     ;           ad bd cd       = (abc) * d
     ;        ac bc             = (ab) * c
     ;     ab                   = (a) * b
     ;
     ; is a copy of everything below the main diagonal:
     ;                       de
     ;                 cd ce
     ;           bc bd be
     ;     ab ac ad ae
     ;
     ; Thus, the sum is 2 * (off the diagonal) + diagonal.
     ;
     ; This is accumulated beginning with the diagonal (which
     ; consist of the squares of the digits of the input), which is then
     ; divided by two, the off-diagonal added, and multiplied by two
     ; again. The low bit is simply a copy of the low bit of the
     ; input, so it doesn't need special care.
     ;;
    (defn- #_"int[]" BigInteger'squareToLen [#_"int[]" x, #_"int" len, #_"int[]" z]
        (let [
              #_"int" zlen (ß len << 1)
        ]
            (when (or (ß z == nil) (ß z.length < zlen))
                (§ ass z (ß new int[zlen]))
            )

            ;; store the squares, right shifted one bit (i.e., divided by 2)
            (let [
                  #_"int" lastProductLowWord 0
            ]
                (loop-when-recur [#_"int" i 0 #_"int" j 0] (< j len) [i (inc j)]
                    (let [
                          #_"long" piece (ß (x[j] & BigInteger'LONG_MASK))
                          #_"long" product (* piece piece)
                    ]
                        (§ ass (aget z i) (ß (lastProductLowWord << 31) | (int)(product >>> 33)))
                        (§ ass i (inc i))
                        (§ ass (aget z i) (ß (int)(product >>> 1)))
                        (§ ass i (inc i))
                        (§ ass lastProductLowWord (ß (int)product))
                    )
                )

                ;; add in off-diagonal sums
                (loop-when-recur [#_"int" i len #_"int" offset 1] (< 0 i) [(dec i) (+ offset 2)]
                    (let [
                          #_"int" t (aget x (dec i))
                    ]
                        (§ ass t (BigInteger'mulAdd z, x, offset, (dec i), t))
                        (BigInteger'addOne z, (dec offset), i, t)
                    )
                )

                ;; shift back up and set low bit
                (BigInteger'primitiveLeftShift z, zlen, 1)
                (§ ass (aget z (dec zlen)) (ß (ß z[zlen - 1] | (x[len - 1] & 1))))

                z
            )
        )
    )

    ;; division

    (declare BigInteger''divideKnuth)

    ;;;
     ; Returns a BigInteger whose value is {@code (this / val)}.
     ;
     ; @param  val value by which this BigInteger is to be divided.
     ; @return {@code this / val}
     ; @throws ArithmeticException if {@code val} is zero.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''divide [#_"BigInteger" this, #_"BigInteger" val]
        (BigInteger''divideKnuth this, val)
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this / val)} using an O(n^2) algorithm from Knuth.
     ;
     ; @param  val value by which this BigInteger is to be divided.
     ; @return {@code this / val}
     ; @throws ArithmeticException if {@code val} is zero.
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''divideKnuth [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"MutableBigInteger" q (MutableBigInteger'new)
              #_"MutableBigInteger" a (ß MutableBigInteger'new(this.mag))
              #_"MutableBigInteger" b (ß MutableBigInteger'new(val.mag))
        ]
            (MutableBigInteger''divideKnuth-4 a, b, q, false)
            (ß MutableBigInteger''toBigInteger-2(q, this.signum * val.signum))
        )
    )

    (declare BigInteger''divideAndRemainderKnuth)

    ;;;
     ; Returns an array of two BigIntegers containing {@code (this / val)}
     ; followed by {@code (this % val)}.
     ;
     ; @param  val value by which this BigInteger is to be divided, and the
     ;         remainder computed.
     ; @return an array of two BigIntegers: the quotient {@code (this / val)}
     ;         is the initial element, and the remainder {@code (this % val)}
     ;         is the final element.
     ; @throws ArithmeticException if {@code val} is zero.
     ;;
    #_method
    (defn #_"BigInteger[]" BigInteger''divideAndRemainder [#_"BigInteger" this, #_"BigInteger" val]
        (BigInteger''divideAndRemainderKnuth this, val)
    )

    ;;;
     ; Long division.
     ;;
    #_method
    (defn- #_"BigInteger[]" BigInteger''divideAndRemainderKnuth [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"BigInteger[]" result (ß new BigInteger[2])
              #_"MutableBigInteger" q (MutableBigInteger'new)
              #_"MutableBigInteger" a (ß MutableBigInteger'new(this.mag))
              #_"MutableBigInteger" b (ß MutableBigInteger'new(val.mag))
              #_"MutableBigInteger" r (MutableBigInteger''divideKnuth-3 a, b, q)
        ]
            (§ ass (aget result 0) (ß MutableBigInteger''toBigInteger-2(q, (if (ß this.signum == val.signum) 1 -1))))
            (§ ass (aget result 1) (ß MutableBigInteger''toBigInteger-2(r, this.signum)))
            result
        )
    )

    (declare BigInteger''remainderKnuth)

    ;;;
     ; Returns a BigInteger whose value is {@code (this % val)}.
     ;
     ; @param  val value by which this BigInteger is to be divided, and the remainder computed.
     ; @return {@code this % val}
     ; @throws ArithmeticException if {@code val} is zero.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''remainder [#_"BigInteger" this, #_"BigInteger" val]
        (BigInteger''remainderKnuth this, val)
    )

    ;;;
     ; Long division.
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''remainderKnuth [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"MutableBigInteger" q (MutableBigInteger'new)
              #_"MutableBigInteger" a (ß MutableBigInteger'new(this.mag))
              #_"MutableBigInteger" b (ß MutableBigInteger'new(val.mag))
        ]
            (ß MutableBigInteger''divideKnuth-3(a, b, q).MutableBigInteger''toBigInteger-2((§ pipe), this.signum))
        )
    )

    (declare BigInteger''abs)
    (declare BigInteger''negate)
    (declare BigInteger''shiftRight)

    ;;;
     ; Returns a BigInteger whose value is <tt>(this<sup>exponent</sup>)</tt>.
     ; Note that {@code exponent} is an integer rather than a BigInteger.
     ;
     ; @param  exponent exponent to which this BigInteger is to be raised.
     ; @return <tt>this<sup>exponent</sup></tt>
     ; @throws ArithmeticException {@code exponent} is negative. (This would
     ;         cause the operation to yield a non-integer value.)
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''pow [#_"BigInteger" this, #_"int" exponent]
        (when (< exponent 0)
            (throw! "negative exponent")
        )
        (when (ß this.signum == 0)
            (§ return (if (ß exponent == 0) BigInteger'ONE this))
        )

        (let [
              #_"BigInteger" partToSquare (BigInteger''abs this)
              ;; Factor out powers of two from the base, as the exponentiation of these can be done by left shifts only.
              ;; The remaining part can then be exponentiated faster.
              ;; The powers of two will be multiplied back at the end.
              #_"int" powersOfTwo (BigInteger''getLowestSetBit partToSquare)
              #_"long" bitsToShift (ß (long)powersOfTwo * exponent)
        ]
            (when (ß bitsToShift > Integer/MAX_VALUE)
                (throw! "magnitude overflow")
            )

            (ß #_"int" remainingBits)

            ;; Factor the powers of two out quickly by shifting right, if needed.
            (cond (< 0 powersOfTwo)
                (let [
                ]
                    (§ ass partToSquare (BigInteger''shiftRight partToSquare, powersOfTwo))
                    (§ ass remainingBits (BigInteger''bitLength partToSquare))
                    (when (ß remainingBits == 1) ;; Nothing left but +/- 1?
                        (cond (and (ß this.signum < 0) (ß (exponent & 1) == 1))
                            (do
                                (§ return (ß BigInteger''shiftLeft(BigInteger'NEGATIVE_ONE, powersOfTwo * exponent)))
                            )
                            :else
                            (do
                                (§ return (ß BigInteger''shiftLeft(BigInteger'ONE, powersOfTwo * exponent)))
                            )
                        )
                    )
                )
                :else
                (let [
                ]
                    (§ ass remainingBits (BigInteger''bitLength partToSquare))
                    (when (ß remainingBits == 1) ;; Nothing left but +/- 1?
                        (cond (and (ß this.signum < 0) (ß (exponent & 1) == 1))
                            (do
                                (§ return (ß BigInteger'NEGATIVE_ONE))
                            )
                            :else
                            (do
                                (§ return (ß BigInteger'ONE))
                            )
                        )
                    )
                )
            )

            ;; This is a quick way to approximate the size of the result,
            ;; similar to doing log2[n] * exponent. This will give an upper bound
            ;; of how big the result can be, and which algorithm to use.
            (let [
                  #_"long" scaleFactor (ß (long)remainingBits * exponent)
            ]
                ;; Use slightly different algorithms for small and large operands.
                ;; See if the result will safely fit into a long. (Largest 2^63-1)
                (cond (and (ß (alength (:mag partToSquare)) == 1) (<= scaleFactor 62))
                    ;; Small number algorithm. Everything fits into a long.
                    (let [
                          #_"int" newSign (if (and (ß this.signum < 0) (ß (exponent & 1) == 1)) -1 1)
                          #_"long" result 1
                          #_"long" baseToPow2 (ß (aget (:mag partToSquare) 0) & BigInteger'LONG_MASK)
                          #_"int" workingExponent exponent
                    ]
                        ;; perform exponentiation using repeated squaring trick
                        (while (ß workingExponent != 0)
                            (when (ß (workingExponent & 1) == 1)
                                (§ ass result (* result baseToPow2))
                            )

                            (§ ass workingExponent (ß workingExponent >>> 1))
                            (when (ß workingExponent != 0)
                                (§ ass baseToPow2 (* baseToPow2 baseToPow2))
                            )
                        )

                        ;; multiply back the powers of two (quickly, by shifting left)
                        (cond (< 0 powersOfTwo)
                            (do
                                (cond (ß bitsToShift + scaleFactor <= 62) ;; Fits in long?
                                    (do
                                        (§ return (ß BigInteger'valueOf-l((result << bitsToShift) * newSign)))
                                    )
                                    :else
                                    (do
                                        (§ return (ß BigInteger'valueOf-l(result * newSign).BigInteger''shiftLeft((§ pipe), (int)bitsToShift)))
                                    )
                                )
                            )
                            :else
                            (do
                                (§ return (ß BigInteger'valueOf-l(result * newSign)))
                            )
                        )
                    )
                    :else
                    ;; Large number algorithm. This is basically identical to
                    ;; the algorithm above, but calls multiply() and square()
                    ;; which may use more efficient algorithms for large numbers.
                    (let [
                          #_"BigInteger" answer (ß BigInteger'ONE)
                          #_"int" workingExponent exponent
                    ]
                        ;; perform exponentiation using repeated squaring trick
                        (while (ß workingExponent != 0)
                            (when (ß (workingExponent & 1) == 1)
                                (§ ass answer (BigInteger''multiply answer, partToSquare))
                            )

                            (§ ass workingExponent (ß workingExponent >>> 1))
                            (when (ß workingExponent != 0)
                                (§ ass partToSquare (BigInteger''square partToSquare))
                            )
                        )
                        ;; multiply back the (exponentiated) powers of two (quickly, by shifting left)
                        (when (< 0 powersOfTwo)
                            (§ ass answer (ß BigInteger''shiftLeft(answer, powersOfTwo * exponent)))
                        )

                        (cond (and (ß this.signum < 0) (ß (exponent & 1) == 1))
                            (do
                                (§ return (BigInteger''negate answer))
                            )
                            :else
                            (do
                                (§ return answer)
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Returns a BigInteger whose value is the greatest common divisor
     ; of {@code abs(this)} and {@code abs(val)}.
     ; Returns 0 if {@code this == 0 && val == 0}.
     ;
     ; @param  val value with which the GCD is to be computed.
     ; @return {@code GCD(abs(this), abs(val))}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''gcd [#_"BigInteger" this, #_"BigInteger" val]
        (cond (ß val.signum == 0)
            (do
                (§ return (BigInteger''abs this))
            )
            (ß this.signum == 0)
            (do
                (§ return (BigInteger''abs val))
            )
        )

        (let [
              #_"MutableBigInteger" a (MutableBigInteger'new this)
              #_"MutableBigInteger" b (MutableBigInteger'new val)
              #_"MutableBigInteger" result (MutableBigInteger''hybridGCD a, b)
        ]
            (MutableBigInteger''toBigInteger-2 result, 1)
        )
    )

    ;;;
     ; Package private method to return bit length for an integer.
     ;;
    (defn #_"int" BigInteger'bitLengthForInt [#_"int" n]
        (ß 32 - Integer/numberOfLeadingZeros(n))
    )

    ;;;
     ; Left shift int array a up to len by n bits. Returns the array that
     ; results from the shift since space may have to be reallocated.
     ;;
    (defn- #_"int[]" BigInteger'leftShift [#_"int[]" a, #_"int" len, #_"int" n]
        (let [
              #_"int" nInts (ß n >>> 5)
              #_"int" nBits (ß n & 0x1f)
              #_"int" bitsInHighWord (ß BigInteger'bitLengthForInt(a[0]))
        ]
            ;; if shift can be done without recopy, do so
            (cond (ß n <= (32 - bitsInHighWord))
                (do
                    (BigInteger'primitiveLeftShift a, len, nBits)
                    (§ return a)
                )
                :else ;; array must be resized
                (do
                    (cond (ß nBits <= (32 - bitsInHighWord))
                        (let [
                              #_"int[]" result (ß new int[nInts + len])
                        ]
                            (ß System/arraycopy(a, 0, result, 0, len))
                            (ß BigInteger'primitiveLeftShift(result, result.length, nBits))
                            (§ return result)
                        )
                        :else
                        (let [
                              #_"int[]" result (ß new int[nInts + len + 1])
                        ]
                            (ß System/arraycopy(a, 0, result, 0, len))
                            (ß BigInteger'primitiveRightShift(result, result.length, 32 - nBits))
                            (§ return result)
                        )
                    )
                )
            )
        )
    )

    ;; shifts a up to len right n bits assumes no leading zeros, 0 < n < 32
    (defn #_"void" BigInteger'primitiveRightShift [#_"int[]" a, #_"int" len, #_"int" n]
        (let [
              #_"int" n2 (- 32 n)
        ]
            (loop-when-recur [#_"int" i (dec len) #_"int" c (aget a i)] (< 0 i) [(dec i) c]
                (let [
                      #_"int" b c
                ]
                    (§ ass c (aget a (dec i)))
                    (§ ass (aget a i) (ß (c << n2) | (b >>> n)))
                )
            )
            (§ ass (aget a 0) (ß a[0] >>> n))
        )
        nil
    )

    ;; shifts a up to len left n bits assumes no leading zeros, 0 <= n < 32
    (defn #_"void" BigInteger'primitiveLeftShift [#_"int[]" a, #_"int" len, #_"int" n]
        (when (or (ß len == 0) (ß n == 0))
            (§ return nil)
        )

        (let [
              #_"int" n2 (- 32 n)
        ]
            (loop-when-recur [#_"int" i 0 #_"int" c (aget a i) #_"int" m (ß i + len - 1)] (< i m) [(inc i) c m]
                (let [
                      #_"int" b c
                ]
                    (§ ass c (aget a (inc i)))
                    (§ ass (aget a i) (ß (b << n) | (c >>> n2)))
                )
            )
            (§ ass (aget a (dec len)) (ß a[len - 1] << n))
        )
        nil
    )

    ;;;
     ; Calculate bitlength of contents of the first len elements an int array,
     ; assuming there are no leading zero ints.
     ;;
    (defn- #_"int" BigInteger'bitLength [#_"int[]" val, #_"int" len]
        (when (ß len == 0)
            (§ return 0)
        )
        (ß ((len - 1) << 5) + BigInteger'bitLengthForInt(val[0]))
    )

    ;;;
     ; Returns a BigInteger whose value is the absolute value of this BigInteger.
     ;
     ; @return {@code abs(this)}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''abs [#_"BigInteger" this]
        (if (ß this.signum >= 0) this (BigInteger''negate this))
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (-this)}.
     ;
     ; @return {@code -this}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''negate [#_"BigInteger" this]
        (BigInteger'new (:mag this), (- (:signum this)))
    )

    ;;;
     ; Returns the signum function of this BigInteger.
     ;
     ; @return -1, 0 or 1 as the value of this BigInteger is negative, zero or positive.
     ;;
    #_method
    (defn #_"int" BigInteger''signum [#_"BigInteger" this]
        (:signum this)
    )

    ;; modular arithmetic operations

    ;;;
     ; Returns a BigInteger whose value is {@code (this mod m}).
     ; This method differs from {@code remainder} in that it always returns
     ; a <i>non-negative</i> BigInteger.
     ;
     ; @param  m the modulus.
     ; @return {@code this mod m}
     ; @throws ArithmeticException {@code m} <= 0
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''mod [#_"BigInteger" this, #_"BigInteger" m]
        (when (ß m.signum <= 0)
            (throw! "modulus not positive")
        )

        (let [
              #_"BigInteger" result (BigInteger''remainder this, m)
        ]
            (if (ß result.signum >= 0) result (BigInteger''add result, m))
        )
    )

    (declare BigInteger''oddModPow)
    (declare BigInteger''modPow2)
    (declare BigInteger''modInverse)

    ;;;
     ; Returns a BigInteger whose value is <tt>(this<sup>exponent</sup> mod m)</tt>.
     ; (Unlike {@code pow}, this method permits negative exponents.)
     ;
     ; @param  exponent the exponent.
     ; @param  m the modulus.
     ; @return <tt>this<sup>exponent</sup> mod m</tt>
     ; @throws ArithmeticException {@code m} <= 0 or the exponent is negative
     ;         and this BigInteger is not <i>relatively prime</i> to {@code m}.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''modPow [#_"BigInteger" this, #_"BigInteger" exponent, #_"BigInteger" m]
        (when (ß m.signum <= 0)
            (throw! "modulus not positive")
        )

        ;; trivial cases
        (when (ß exponent.signum == 0)
            (§ return (if (ß m.equals(BigInteger'ONE)) BigInteger'ZERO BigInteger'ONE))
        )

        (when (ß this.equals(BigInteger'ONE))
            (§ return (if (ß m.equals(BigInteger'ONE)) BigInteger'ZERO BigInteger'ONE))
        )

        (when (and (ß this.equals(BigInteger'ZERO)) (ß exponent.signum >= 0))
            (§ return (ß BigInteger'ZERO))
        )

        (when (and (ß this.equals(BigInteger'negConst[1])) (ß !BigInteger''testBit(exponent, 0)))
            (§ return (if (ß m.equals(BigInteger'ONE)) BigInteger'ZERO BigInteger'ONE))
        )

        (let [
              #_"boolean" invertResult (ß (exponent.signum < 0))
        ]
            (when invertResult
                (§ ass exponent (BigInteger''negate exponent))
            )

            (let [
                  #_"BigInteger" base (if (or (ß this.signum < 0) (ß this.compareTo(m) >= 0)) (BigInteger''mod this, m) this)
                  #_"BigInteger" result (ß )
            ]
                (cond (BigInteger''testBit m, 0) ;; odd modulus
                    (do
                        (§ ass result (BigInteger''oddModPow base, exponent, m))
                    )
                    :else
                    ;;
                     ; Even modulus. Tear it into an "odd part" (m1) and power of two (m2),
                     ; exponentiate mod m1, manually exponentiate mod m2, and use
                     ; Chinese Remainder Theorem to combine results.
                     ;;
                    (let [
                          ;; tear m apart into odd part (m1) and power of 2 (m2)
                          #_"int" p (BigInteger''getLowestSetBit m) ;; max pow of 2 that divides m
                          #_"BigInteger" m1 (BigInteger''shiftRight m, p) ;; m/2**p
                          #_"BigInteger" m2 (ß BigInteger''shiftLeft(BigInteger'ONE, p)) ;; 2**p
                          ;; calculate new base from m1
                          #_"BigInteger" base2 (if (or (ß this.signum < 0) (ß this.compareTo(m1) >= 0)) (BigInteger''mod this, m1) this)
                          ;; caculate (base ** exponent) mod m1
                          #_"BigInteger" a1 (if (ß m1.equals(BigInteger'ONE)) BigInteger'ZERO (BigInteger''oddModPow base2, exponent, m1))
                          ;; calculate (this ** exponent) mod m2
                          #_"BigInteger" a2 (BigInteger''modPow2 base, exponent, p)
                          ;; combine results using Chinese Remainder Theorem
                          #_"BigInteger" y1 (BigInteger''modInverse m2, m1)
                          #_"BigInteger" y2 (BigInteger''modInverse m1, m2)
                    ]
                        (cond (ß m.mag.length < BigInteger'MAX_MAG_LENGTH / 2)
                            (do
                                (§ ass result (ß BigInteger''multiply(a1, m2).BigInteger''multiply((§ pipe), y1).BigInteger''add((§ pipe), BigInteger''multiply(a2, m1).BigInteger''multiply((§ pipe), y2)).BigInteger''mod((§ pipe), m)))
                            )
                            :else
                            (let [
                                  #_"MutableBigInteger" t1 (MutableBigInteger'new)
                                  #_"MutableBigInteger" t2 (MutableBigInteger'new)
                            ]
                                (ß MutableBigInteger'new(BigInteger''multiply(a1, m2)).MutableBigInteger''multiply((§ pipe), MutableBigInteger'new(y1), t1))
                                (ß MutableBigInteger'new(BigInteger''multiply(a2, m1)).MutableBigInteger''multiply((§ pipe), MutableBigInteger'new(y2), t2))
                                (MutableBigInteger''add t1, t2)
                                (let [
                                      #_"MutableBigInteger" q (MutableBigInteger'new)
                                ]
                                    (§ ass result (ß MutableBigInteger''divide-3(t1, MutableBigInteger'new(m), q).MutableBigInteger''toBigInteger-1((§ pipe), )))
                                )
                            )
                        )
                    )
                )

                (if invertResult (BigInteger''modInverse result, m) result)
            )
        )
    )

    (def #_"int[]" BigInteger'bnExpModThreshTable (§ init 7, 25, 81, 241, 673, 1793, Integer/MAX_VALUE )) ;; sentinel

    ;;;
     ; Returns a BigInteger whose value is x to the power of y mod z.
     ; Assumes: z is odd && x < z.
     ;
     ; The algorithm is adapted from Colin Plumb's C library.
     ;
     ; The window algorithm:
     ; The idea is to keep a running product of b1 = n^(high-order bits of exp)
     ; and then keep appending exponent bits to it. The following patterns
     ; apply to a 3-bit window (k = 3):
     ; To append   0: square
     ; To append   1: square, multiply by n^1
     ; To append  10: square, multiply by n^1, square
     ; To append  11: square, square, multiply by n^3
     ; To append 100: square, multiply by n^1, square, square
     ; To append 101: square, square, square, multiply by n^5
     ; To append 110: square, square, multiply by n^3, square
     ; To append 111: square, square, square, multiply by n^7
     ;
     ; Since each pattern involves only one multiply, the longer the pattern
     ; the better, except that a 0 (no multiplies) can be appended directly.
     ; We precompute a table of odd powers of n, up to 2^k, and can then
     ; multiply k bits of exponent at a time. Actually, assuming random
     ; exponents, there is on average one zero bit between needs to
     ; multiply (1/2 of the time there's none, 1/4 of the time there's 1,
     ; 1/8 of the time, there's 2, 1/32 of the time, there's 3, etc.), so
     ; you have to do one multiply per k+1 bits of exponent.
     ;
     ; The loop walks down the exponent, squaring the result buffer as
     ; it goes. There is a wbits+1 bit lookahead buffer, buf, that is
     ; filled with the upcoming exponent bits. (What is read after the
     ; end of the exponent is unimportant, but it is filled with zero here.)
     ; When the most-significant bit of this buffer becomes set, i.e.
     ; (buf & tblmask) != 0, we have to decide what pattern to multiply
     ; by, and when to do it. We decide, remember to do it in future
     ; after a suitable number of squarings have passed (e.g. a pattern
     ; of "100" in the buffer requires that we multiply by n^1 immediately;
     ; a pattern of "110" calls for multiplying by n^3 after one more
     ; squaring), clear the buffer, and continue.
     ;
     ; When we start, there is one more optimization: the result buffer
     ; is implcitly one, so squaring it or multiplying by it can be
     ; optimized away. Further, if we start with a pattern like "100"
     ; in the lookahead window, rather than placing n into the buffer
     ; and then starting to square it, we have already computed n^2
     ; to compute the odd-powers table, so we can place that into
     ; the buffer and save a squaring.
     ;
     ; This means that if you have a k-bit window, to compute n^z,
     ; where z is the high k bits of the exponent, 1/2 of the time
     ; it requires no squarings. 1/4 of the time, it requires 1
     ; squaring, ... 1/2^(k-1) of the time, it reqires k-2 squarings.
     ; And the remaining 1/2^(k-1) of the time, the top k bits are a
     ; 1 followed by k-1 0 bits, so it again only requires k-2
     ; squarings, not k-1. The average of these is 1. Add that
     ; to the one squaring we have to do to compute the table,
     ; and you'll see that a k-bit window saves k-2 squarings
     ; as well as reducing the multiplies. (It actually doesn't
     ; hurt in the case k = 1, either.)
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''oddModPow [#_"BigInteger" this, #_"BigInteger" y, #_"BigInteger" z]
        ;; special case for exponent of one
        (when (ß y.equals(BigInteger'ONE))
            (§ return this)
        )

        ;; special case for base of zero
        (when (ß this.signum == 0)
            (§ return (ß BigInteger'ZERO))
        )

        (let [
              #_"int[]" base (ß this.mag.clone())
              #_"int[]" exp (:mag y)
              #_"int[]" mod (:mag z)
              #_"int" modLen (ß mod.length)
              ;; select an appropriate window size
              #_"int" wbits 0
              #_"int" ebits (ß BigInteger'bitLength(exp, exp.length))
        ]
            ;; if exponent is 65537 (0x10001), use minimum window size
            (when (or (ß ebits != 17) (ß exp[0] != 65537))
                (while (ß ebits > BigInteger'bnExpModThreshTable[wbits])
                    (§ ass wbits (inc wbits))
                )
            )

            ;; calculate appropriate table size
            (let [
                  #_"int" tblmask (ß 1 << wbits)
                  ;; allocate table for precomputed odd powers of base in Montgomery form
                  #_"int[][]" table (ß new int[tblmask][])
            ]
                (loop-when-recur [#_"int" i 0] (< i tblmask) [(inc i)]
                    (§ ass (aget table i) (ß new int[modLen]))
                )

                ;; compute the modular inverse
                (let [
                      #_"int" inv (- (ß MutableBigInteger'inverseMod32(mod[modLen - 1])))
                      ;; convert base to Montgomery form
                      #_"int[]" a (ß BigInteger'leftShift(base, base.length, modLen << 5))
                      #_"MutableBigInteger" q (MutableBigInteger'new)
                      #_"MutableBigInteger" a2 (MutableBigInteger'new a)
                      #_"MutableBigInteger" b2 (MutableBigInteger'new mod)
                      #_"MutableBigInteger" r (MutableBigInteger''divide-3 a2, b2, q)
                ]
                    (§ ass (aget table 0) (MutableBigInteger''toIntArray r))

                    ;; pad table[0] with leading zeros so its length is at least modLen
                    (when (ß table[0].length < modLen)
                        (let [
                              #_"int" offset (ß modLen - table[0].length)
                              #_"int[]" t2 (ß new int[modLen])
                        ]
                            (loop-when-recur [#_"int" i 0] (ß i < table[0].length) [(inc i)]
                                (§ ass (ß t2[i + offset]) (ß table[0][i]))
                            )
                            (§ ass (aget table 0) t2)
                        )
                    )

                    ;; set b to the square of the base
                    (let [
                          #_"int[]" b (ß BigInteger'squareToLen(table[0], modLen, nil))
                          _ (§ ass b (BigInteger'montReduce b, mod, modLen, inv))
                          ;; set t to high half of b
                          #_"int[]" t (ß Arrays/copyOf(b, modLen))
                    ]

                        ;; fill in the table with odd powers of the base
                        (loop-when-recur [#_"int" i 1] (< i tblmask) [(inc i)]
                            (let [
                                  #_"int[]" prod (ß BigInteger''multiplyToLen(this, t, modLen, table[i - 1], modLen, nil))
                            ]
                                (§ ass (aget table i) (BigInteger'montReduce prod, mod, modLen, inv))
                            )
                        )

                        (let [
                              ;; pre load the window that slides over the exponent
                              #_"int" bitpos (ß 1 << ((ebits - 1) & (32 - 1)))
                              #_"int" buf 0
                              #_"int" elen (ß exp.length)
                              #_"int" eIndex 0
                        ]
                            (loop-when-recur [#_"int" i 0] (<= i wbits) [(inc i)]
                                (let [
                                ]
                                    (§ ass buf (ß (buf << 1) | (if (ß (exp[eIndex] & bitpos) != 0) 1 0)))
                                    (§ ass bitpos (ß bitpos >>> 1))
                                    (when (ß bitpos == 0)
                                        (§ ass eIndex (inc eIndex))
                                        (§ ass bitpos (ß 1 << (32 - 1)))
                                        (§ ass elen (dec elen))
                                    )
                                )
                            )

                            (let [
                                  #_"int" multpos ebits
                                  ;; the first iteration, which is hoisted out of the main loop
                                  _ (§ ass ebits (dec ebits))
                                  #_"boolean" isone true
                                  _ (§ ass multpos (- ebits wbits))
                            ]
                                (while (ß (buf & 1) == 0)
                                    (§ ass buf (ß buf >>> 1))
                                    (§ ass multpos (inc multpos))
                                )

                                (let [
                                      #_"int[]" mult (§ soon aget table (ß buf >>> 1))
                                ]
                                    (§ ass buf 0)
                                    (when (ß multpos == ebits)
                                        (§ ass isone false)
                                    )

                                    ;; the main loop
                                    (§ while true
                                        (let [
                                        ]
                                            (§ ass ebits (dec ebits))
                                            ;; advance the window
                                            (§ ass buf (ß buf << 1))

                                            (when (ß elen != 0)
                                                (§ ass buf (ß buf | (if (ß (exp[eIndex] & bitpos) != 0) 1 0)))
                                                (§ ass bitpos (ß bitpos >>> 1))
                                                (when (ß bitpos == 0)
                                                    (§ ass eIndex (inc eIndex))
                                                    (§ ass bitpos (ß 1 << (32 - 1)))
                                                    (§ ass elen (dec elen))
                                                )
                                            )

                                            ;; examine the window for pending multiplies
                                            (when (ß (buf & tblmask) != 0)
                                                (let [
                                                ]
                                                    (§ ass multpos (- ebits wbits))
                                                    (while (ß (buf & 1) == 0)
                                                        (§ ass buf (ß buf >>> 1))
                                                        (§ ass multpos (inc multpos))
                                                    )
                                                    (§ ass mult (aget table (ß buf >>> 1)))
                                                    (§ ass buf 0)
                                                )
                                            )

                                            ;; perform multiply
                                            (when (ß ebits == multpos)
                                                (cond isone
                                                    (do
                                                        (§ ass b (ß mult.clone()))
                                                        (§ ass isone false)
                                                    )
                                                    :else
                                                    (do
                                                        (§ ass t b)
                                                        (§ ass a (BigInteger''multiplyToLen this, t, modLen, mult, modLen, a))
                                                        (§ ass a (BigInteger'montReduce a, mod, modLen, inv))
                                                        (§ ass t a)
                                                        (§ ass a b)
                                                        (§ ass b t)
                                                    )
                                                )
                                            )

                                            ;; check if done
                                            (when (ß ebits == 0)
                                                (§ break)
                                            )

                                            ;; square the input
                                            (when (ß !isone)
                                                (§ ass t b)
                                                (§ ass a (BigInteger'squareToLen t, modLen, a))
                                                (§ ass a (BigInteger'montReduce a, mod, modLen, inv))
                                                (§ ass t a)
                                                (§ ass a b)
                                                (§ ass b t)
                                            )
                                        )
                                    )

                                    ;; convert result out of Montgomery form and return
                                    (let [
                                          #_"int[]" t2 (ß new int[2 * modLen])
                                    ]
                                        (ß System/arraycopy(b, 0, t2, modLen, modLen))

                                        (§ ass b (BigInteger'montReduce t2, mod, modLen, inv))

                                        (§ ass t2 (ß Arrays/copyOf(b, modLen)))

                                        (BigInteger'new 1, t2)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (declare BigInteger'subN)

    ;;;
     ; Montgomery reduce n, modulo mod. This reduces modulo mod and divides
     ; by 2^(32*mlen). Adapted from Colin Plumb's C library.
     ;;
    (defn- #_"int[]" BigInteger'montReduce [#_"int[]" n, #_"int[]" mod, #_"int" mlen, #_"int" inv]
        (let [
              #_"int" c 0
              #_"int" len mlen
              #_"int" offset 0
        ]
            (loop []
                (let [
                      #_"int" nEnd (aget n (ß n.length - 1 - offset))
                      #_"int" carry (ß BigInteger'mulAdd(n, mod, offset, mlen, inv * nEnd))
                ]
                    (§ ass c (ß c + BigInteger'addOne(n, offset, mlen, carry)))
                    (§ ass offset (inc offset))
                    (§ ass len (dec len))
                    (recur-if (< 0 len) [])
                )
            )

            (while (< 0 c)
                (§ ass c (ß c + BigInteger'subN(n, mod, mlen)))
            )

            (while (ß BigInteger'intArrayCmpToLen(n, mod, mlen) >= 0)
                (BigInteger'subN n, mod, mlen)
            )

            n
        )
    )

    ;;
     ; Returns -1, 0 or +1 as big-endian unsigned int array arg1 is less than,
     ; equal to, or greater than arg2 up to length len.
     ;;
    (defn- #_"int" BigInteger'intArrayCmpToLen [#_"int[]" arg1, #_"int[]" arg2, #_"int" len]
        (let [
        ]
            (loop-when-recur [#_"int" i 0] (< i len) [(inc i)]
                (let [
                      #_"long" b1 (ß arg1[i] & BigInteger'LONG_MASK)
                      #_"long" b2 (ß arg2[i] & BigInteger'LONG_MASK)
                ]
                    (when (< b1 b2)
                        (§ return -1)
                    )
                    (when (< b2 b1)
                        (§ return 1)
                    )
                )
            )
            0
        )
    )

    ;;;
     ; Subtracts two numbers of same length, returning borrow.
     ;;
    (defn- #_"int" BigInteger'subN [#_"int[]" a, #_"int[]" b, #_"int" len]
        (let [
              #_"long" sum 0
        ]
            (loop-when-recur [len (dec len)] (<= 0 len) [(dec len)]
                (§ ass sum (ß (a[len] & BigInteger'LONG_MASK) - (b[len] & BigInteger'LONG_MASK) + (sum >> 32)))
                (§ ass (aget a len) (ß (int)sum))
            )

            (ß (int)(sum >> 32))
        )
    )

    ;;;
     ; Multiply an array by one word k and add to result, return the carry.
     ;;
    (defn #_"int" BigInteger'mulAdd [#_"int[]" out, #_"int[]" in, #_"int" offset, #_"int" len, #_"int" k]
        (let [
              #_"long" kLong (ß k & BigInteger'LONG_MASK)
              #_"long" carry 0
        ]
            (§ ass offset (ß out.length - offset - 1))
            (loop-when-recur [#_"int" j (dec len)] (<= 0 j) [(dec j)]
                (let [
                      #_"long" product (ß (in[j] & BigInteger'LONG_MASK) * kLong + (out[offset] & BigInteger'LONG_MASK) + carry)
                ]
                    (§ ass (aget out offset) (ß (int)product))
                    (§ ass offset (dec offset))
                    (§ ass carry (ß product >>> 32))
                )
            )
            (ß (int)carry)
        )
    )

    ;;;
     ; Add one word to the number a mlen words into a.
     ; Return the resulting carry.
     ;;
    (defn #_"int" BigInteger'addOne [#_"int[]" a, #_"int" offset, #_"int" mlen, #_"int" carry]
        (let [
              _ (§ ass offset (ß a.length - 1 - mlen - offset))
              #_"long" t (ß (a[offset] & BigInteger'LONG_MASK) + (carry & BigInteger'LONG_MASK))
        ]
            (§ ass (aget a offset) (ß (int)t))
            (when (ß (t >>> 32) == 0)
                (§ return 0)
            )
            (loop-when-recur [mlen (dec mlen)] (<= 0 mlen) [(dec mlen)]
                (let [
                ]
                    (§ ass offset (dec offset))
                    (cond (< offset 0) ;; carry out of number
                        (do
                            (§ return 1)
                        )
                        :else
                        (do
                            (§ ass (aget a offset) (ß a[offset] + 1))
                            (when (ß a[offset] != 0)
                                (§ return 0)
                            )
                        )
                    )
                )
            )
            1
        )
    )

    (declare BigInteger''mod2)

    ;;;
     ; Returns a BigInteger whose value is (this ** exponent) mod (2**p)
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''modPow2 [#_"BigInteger" this, #_"BigInteger" exponent, #_"int" p]
        ;;
         ; Perform exponentiation using repeated squaring trick, chopping off
         ; high order bits as indicated by modulus.
         ;;
        (let [
              #_"BigInteger" result (ß BigInteger'ONE)
              #_"BigInteger" baseToPow2 (BigInteger''mod2 this, p)
              #_"int" expOffset 0
              #_"int" limit (BigInteger''bitLength exponent)
        ]
            (when (BigInteger''testBit this, 0)
                (§ ass limit (if (ß (p - 1) < limit) (dec p) limit))
            )

            (while (< expOffset limit)
                (when (BigInteger''testBit exponent, expOffset)
                    (§ ass result (ß BigInteger''multiply(result, baseToPow2).BigInteger''mod2((§ pipe), p)))
                )
                (§ ass expOffset (inc expOffset))
                (when (< expOffset limit)
                    (§ ass baseToPow2 (ß BigInteger''square(baseToPow2).BigInteger''mod2((§ pipe), p)))
                )
            )

            result
        )
    )

    ;;;
     ; Returns a BigInteger whose value is this mod(2**p).
     ; Assumes that this {@code BigInteger >= 0} and {@code p > 0}.
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''mod2 [#_"BigInteger" this, #_"int" p]
        (when (ß BigInteger''bitLength(this) <= p)
            (§ return this)
        )

        ;; copy remaining ints of mag
        (let [
              #_"int" numInts (ß (p + 31) >>> 5)
              #_"int[]" mag (ß new int[numInts])
        ]
            (ß System/arraycopy(this.mag, this.mag.length - numInts, mag, 0, numInts))

            ;; mask out any excess bits
            (let [
                  #_"int" excessBits (ß (numInts << 5) - p)
            ]
                (§ ass (aget mag 0) (ß (ß mag[0] & ((1 << (32 - excessBits)) - 1))))

                (if (ß mag[0] == 0) (BigInteger'new 1, mag) (BigInteger'new mag, 1))
            )
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this}<sup>-1</sup> {@code mod m)}.
     ;
     ; @param  m the modulus.
     ; @return {@code this}<sup>-1</sup> {@code mod m}.
     ; @throws ArithmeticException {@code m} <= 0, or this BigInteger
     ;         has no multiplicative inverse mod m (that is, this BigInteger
     ;         is not <i>relatively prime</i> to m).
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''modInverse [#_"BigInteger" this, #_"BigInteger" m]
        (when (ß m.signum != 1)
            (throw! "modulus not positive")
        )

        (when (ß m.equals(BigInteger'ONE))
            (§ return (ß BigInteger'ZERO))
        )

        ;; calculate (this mod m)
        (let [
              #_"BigInteger" modVal this
        ]
            (when (or (ß this.signum < 0) (ß BigInteger''compareMagnitude-i(this, m) >= 0))
                (§ ass modVal (BigInteger''mod this, m))
            )

            (when (ß modVal.equals(BigInteger'ONE))
                (§ return (ß BigInteger'ONE))
            )

            (let [
                  #_"MutableBigInteger" a (MutableBigInteger'new modVal)
                  #_"MutableBigInteger" b (MutableBigInteger'new m)
                  #_"MutableBigInteger" result (MutableBigInteger''mutableModInverse a, b)
            ]
                (MutableBigInteger''toBigInteger-2 result, 1)
            )
        )
    )

    ;; shift operations

    (declare BigInteger''shiftRightImpl)

    ;;;
     ; Returns a BigInteger whose value is {@code (this << n)}.
     ; The shift distance, {@code n}, may be negative, in which case
     ; this method performs a right shift.
     ; (Computes <tt>floor(this * 2<sup>n</sup>)</tt>.)
     ;
     ; @param  n shift distance, in bits.
     ; @return {@code this << n}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''shiftLeft [#_"BigInteger" this, #_"int" n]
        (when (ß this.signum == 0)
            (§ return (ß BigInteger'ZERO))
        )
        (cond (< 0 n)
            (do
                (§ return (ß BigInteger'new(BigInteger'shiftLeft(this.mag, n), this.signum)))
            )
            (ß n == 0)
            (do
                (§ return this)
            )
            :else
            (do
                ;; Possible int overflow in (-n) is not a trouble,
                ;; because shiftRightImpl considers its argument unsigned.
                (§ return (BigInteger''shiftRightImpl this, (- n)))
            )
        )
    )

    ;;;
     ; Returns a magnitude array whose value is {@code (mag << n)}.
     ; The shift distance, {@code n}, is considered unnsigned.
     ; (Computes <tt>this * 2<sup>n</sup></tt>.)
     ;
     ; @param mag magnitude, the most-significant int ({@code mag[0]}) must be non-zero.
     ; @param  n unsigned shift distance, in bits.
     ; @return {@code mag << n}
     ;;
    (defn- #_"int[]" BigInteger'shiftLeft [#_"int[]" mag, #_"int" n]
        (let [
              #_"int" nInts (ß n >>> 5)
              #_"int" nBits (ß n & 0x1f)
              #_"int" magLen (ß mag.length)
              #_"int[]" newMag nil
        ]
            (cond (ß nBits == 0)
                (do
                    (§ ass newMag (ß new int[magLen + nInts]))
                    (ß System/arraycopy(mag, 0, newMag, 0, magLen))
                )
                :else
                (let [
                      #_"int" i 0
                      #_"int" nBits2 (- 32 nBits)
                      #_"int" highBits (ß mag[0] >>> nBits2)
                ]
                    (cond (ß highBits != 0)
                        (do
                            (§ ass newMag (ß new int[magLen + nInts + 1]))
                            (§ ass (aget newMag i) highBits)
                            (§ ass i (inc i))
                        )
                        :else
                        (do
                            (§ ass newMag (ß new int[magLen + nInts]))
                        )
                    )
                    (let [
                          #_"int" j 0
                    ]
                        (while (ß j < magLen - 1)
                            (§ ass (aget newMag i) (ß mag[j] << nBits | mag[j + 1] >>> nBits2))
                            (§ ass i (inc i))
                            (§ ass j (inc j))
                        )
                        (§ ass (aget newMag i) (ß mag[j] << nBits))
                    )
                )
            )
            newMag
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this >> n)}. Sign
     ; extension is performed. The shift distance, {@code n}, may be
     ; negative, in which case this method performs a left shift.
     ; (Computes <tt>floor(this / 2<sup>n</sup>)</tt>.)
     ;
     ; @param  n shift distance, in bits.
     ; @return {@code this >> n}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''shiftRight [#_"BigInteger" this, #_"int" n]
        (when (ß this.signum == 0)
            (§ return (ß BigInteger'ZERO))
        )
        (cond (< 0 n)
            (do
                (BigInteger''shiftRightImpl this, n)
            )
            (ß n == 0)
            (do
                this
            )
            :else
            (do
                ;; Possible int overflow in {@code -n} is not a trouble,
                ;; because shiftLeft considers its argument unsigned.
                (BigInteger'new (BigInteger'shiftLeft (:mag this), (- n)), (:signum this))
            )
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this >> n)}.
     ; The shift distance, {@code n}, is considered unsigned.
     ; (Computes <tt>floor(this * 2<sup>-n</sup>)</tt>.)
     ;
     ; @param  n unsigned shift distance, in bits.
     ; @return {@code this >> n}
     ;;
    #_method
    (defn- #_"BigInteger" BigInteger''shiftRightImpl [#_"BigInteger" this, #_"int" n]
        (let [
              #_"int" nInts (ß n >>> 5)
              #_"int" nBits (ß n & 0x1f)
              #_"int" magLen (ß this.mag.length)
              #_"int[]" newMag nil
        ]
            ;; special case: entire contents shifted off the end
            (when (<= magLen nInts)
                (§ return (if (ß this.signum >= 0) BigInteger'ZERO (ß BigInteger'negConst[1])))
            )

            (cond (ß nBits == 0)
                (let [
                      #_"int" newMagLen (- magLen nInts)
                ]
                    (§ ass newMag (ß Arrays/copyOf(this.mag, newMagLen)))
                )
                :else
                (let [
                      #_"int" i 0
                      #_"int" highBits (ß this.mag[0] >>> nBits)
                ]
                    (cond (ß highBits != 0)
                        (do
                            (§ ass newMag (ß new int[magLen - nInts]))
                            (§ ass (aget newMag i) highBits)
                            (§ ass i (inc i))
                        )
                        :else
                        (do
                            (§ ass newMag (ß new int[magLen - nInts -1]))
                        )
                    )

                    (let [
                          #_"int" nBits2 (- 32 nBits)
                          #_"int" j 0
                    ]
                        (while (ß j < magLen - nInts - 1)
                            (§ ass (aget newMag i) (ß (this.mag[j] << nBits2) | (this.mag[j + 1] >>> nBits)))
                            (§ ass i (inc i))
                            (§ ass j (inc j))
                        )
                    )
                )
            )

            (when (ß this.signum < 0)
                ;; Find out whether any one-bits were shifted off the end.
                (let [
                      #_"int" j (- magLen nInts)
                      #_"boolean" onesLost false
                ]
                    (loop-when-recur [#_"int" i (dec magLen)] (and (ß i >= j) (ß !onesLost)) [(dec i)]
                        (§ ass onesLost (ß (this.mag[i] != 0)))
                    )
                    (when (and (ß !onesLost) (ß nBits != 0))
                        (§ ass onesLost (ß (this.mag[magLen - nInts - 1] << (32 - nBits) != 0)))
                    )

                    (when onesLost
                        (§ ass newMag (BigInteger''javaIncrement this, newMag))
                    )
                )
            )

            (ß BigInteger'new(newMag, this.signum))
        )
    )

    #_method
    (defn #_"int[]" BigInteger''javaIncrement [#_"BigInteger" this, #_"int[]" val]
        (let [
              #_"int" lastSum 0
        ]
            (loop-when-recur [#_"int" i (ß val.length - 1)] (and (ß i >= 0) (ß lastSum == 0)) [(dec i)]
                (§ ass (aget val i) (ß val[i] + 1))
                (§ ass lastSum (aget val i))
            )
            (when (ß lastSum == 0)
                (§ ass val (ß new int[val.length + 1]))
                (§ ass (aget val 0) 1)
            )
            val
        )
    )

    ;; bitwise operations

    (declare BigInteger'valueOf-i)

    ;;;
     ; Returns a BigInteger whose value is {@code (this & val)}.
     ; (This method returns a negative BigInteger if and only if this and val are both negative.)
     ;
     ; @param val value to be AND'ed with this BigInteger.
     ; @return {@code this & val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''and [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), BigInteger''intLength(val))])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result i) (ß (BigInteger''getInt(this, result.length - i - 1) & BigInteger''getInt(val, result.length - i - 1))))
            )

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this | val)}.
     ; (This method returns a negative BigInteger if and only if either this or val is negative.)
     ;
     ; @param val value to be OR'ed with this BigInteger.
     ; @return {@code this | val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''or [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), BigInteger''intLength(val))])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result i) (ß (BigInteger''getInt(this, result.length - i - 1) | BigInteger''getInt(val, result.length - i - 1))))
            )

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this ^ val)}.
     ; (This method returns a negative BigInteger if and only if exactly one of this and val are negative.)
     ;
     ; @param val value to be XOR'ed with this BigInteger.
     ; @return {@code this ^ val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''xor [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), BigInteger''intLength(val))])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result i) (ß (BigInteger''getInt(this, result.length - i - 1) (§ bit-xor) BigInteger''getInt(val, result.length - i - 1))))
            )

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (~this)}.
     ; (This method returns a negative value if and only if this BigInteger is non-negative.)
     ;
     ; @return {@code ~this}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''not [#_"BigInteger" this]
        (let [
              #_"int[]" result (ß new int[this.BigInteger''intLength((§ pipe))])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result i) (ß (§ bit-not)this.BigInteger''getInt((§ pipe), result.length - i - 1)))
            )

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns a BigInteger whose value is {@code (this & ~val)}.
     ; This method, which is equivalent to {@code and(val.not())}, is provided as a
     ; convenience for masking operations. (This method returns a negative BigInteger
     ; if and only if {@code this} is negative and {@code val} is positive.)
     ;
     ; @param val value to be complemented and AND'ed with this BigInteger.
     ; @return {@code this & ~val}
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''andNot [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), BigInteger''intLength(val))])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result i) (ß (BigInteger''getInt(this, result.length - i - 1) & (§ bit-not)val.BigInteger''getInt((§ pipe), result.length - i - 1))))
            )

            (BigInteger'valueOf-i result)
        )
    )

    ;; single bit operations

    ;;;
     ; Returns {@code true} if and only if the designated bit is set.
     ; (Computes {@code ((this & (1<<n)) != 0)}.)
     ;
     ; @param  n index of bit to test.
     ; @return {@code true} if and only if the designated bit is set.
     ; @throws ArithmeticException {@code n} is negative.
     ;;
    #_method
    (defn #_"boolean" BigInteger''testBit [#_"BigInteger" this, #_"int" n]
        (when (< n 0)
            (throw! "negative bit address")
        )

        (ß (BigInteger''getInt(this, n >>> 5) & (1 << (n & 31))) != 0)
    )

    ;;;
     ; Returns a BigInteger whose value is equivalent to this BigInteger
     ; with the designated bit set. (Computes {@code (this | (1<<n))}.)
     ;
     ; @param  n index of bit to set.
     ; @return {@code this | (1<<n)}
     ; @throws ArithmeticException {@code n} is negative.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''setBit [#_"BigInteger" this, #_"int" n]
        (when (< n 0)
            (throw! "negative bit address")
        )

        (let [
              #_"int" intNum (ß n >>> 5)
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), intNum + 2)])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result (ß result.length - i - 1)) (BigInteger''getInt this, i))
            )

            (§ ass (aget result (ß result.length - intNum - 1)) (ß (ß result[result.length - intNum - 1] | (1 << (n & 31)))))

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit cleared.
     ; (Computes {@code (this & ~(1<<n))}.)
     ;
     ; @param  n index of bit to clear.
     ; @return {@code this & ~(1<<n)}
     ; @throws ArithmeticException {@code n} is negative.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''clearBit [#_"BigInteger" this, #_"int" n]
        (when (< n 0)
            (throw! "negative bit address")
        )

        (let [
              #_"int" intNum (ß n >>> 5)
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), ((n + 1) >>> 5) + 1)])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result (ß result.length - i - 1)) (BigInteger''getInt this, i))
            )

            (§ ass (aget result (ß result.length - intNum - 1)) (ß (ß result[result.length - intNum - 1] & ((§ bit-not)(1 << (n & 31))))))

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit flipped.
     ; (Computes {@code (this ^ (1<<n))}.)
     ;
     ; @param  n index of bit to flip.
     ; @return {@code this ^ (1<<n)}
     ; @throws ArithmeticException {@code n} is negative.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''flipBit [#_"BigInteger" this, #_"int" n]
        (when (< n 0)
            (throw! "negative bit address")
        )

        (let [
              #_"int" intNum (ß n >>> 5)
              #_"int[]" result (ß new int[Math/max(BigInteger''intLength(this), intNum + 2)])
        ]
            (loop-when-recur [#_"int" i 0] (ß i < result.length) [(inc i)]
                (§ ass (aget result (ß result.length - i - 1)) (BigInteger''getInt this, i))
            )

            (ß result[result.length - intNum - 1] (§ bit-xor)= (1 << (n & 31)))

            (BigInteger'valueOf-i result)
        )
    )

    ;;;
     ; Returns the index of the rightmost (lowest-order) one bit in this
     ; BigInteger (the number of zero bits to the right of the rightmost
     ; one bit). Returns -1 if this BigInteger contains no one bits.
     ; (Computes {@code (this == 0? -1 : log2(this & -this))}.)
     ;
     ; @return index of the rightmost one bit in this BigInteger.
     ;;
    #_method
    (defn #_"int" BigInteger''getLowestSetBit [#_"BigInteger" this]
        (let [
              #_"int" lsb (ß this.lowestSetBit - 2)
        ]
            (when (ß lsb == -2) ;; lowestSetBit not initialized yet
                (let [
                      _ (§ ass lsb 0)
                ]
                    (cond (ß this.signum == 0)
                        (do
                            (§ ass lsb (dec lsb))
                        )
                        :else
                        ;; search for lowest order nonzero int
                        (let [
                              #_"int" i (ß )
                              #_"int" b (ß )
                        ]
                            (loop [i 0]
                                (let-when [_ (§ ass b (BigInteger''getInt this, i))] (ß b == 0)
                                    (recur (inc i))
                                )
                            )
                            (§ ass lsb (ß lsb + (i << 5) + Integer/numberOfTrailingZeros(b)))
                        )
                    )
                    (§ ass (:lowestSetBit this) (+ lsb 2))
                )
            )
            lsb
        )
    )

    ;; miscellaneous bit operations

    ;;;
     ; Returns the number of bits in the minimal two's-complement
     ; representation of this BigInteger, <i>excluding</i> a sign bit.
     ; For positive BigIntegers, this is equivalent to the number of bits
     ; in the ordinary binary representation.
     ; (Computes {@code (ceil(log2(this < 0 ? -this : this + 1)))}.)
     ;
     ; @return number of bits in the minimal two's-complement representation
     ;         of this BigInteger, <i>excluding</i> a sign bit.
     ;;
    #_method
    (defn #_"int" BigInteger''bitLength [#_"BigInteger" this]
        (let [
              #_"int" n (ß this.bitLength - 1)
        ]
            (when (ß n == -1) ;; bitLength not initialized yet
                (let [
                      #_"int[]" m (:mag this)
                      #_"int" len (:length m)
                ]
                    (cond (ß len == 0)
                        (do
                            (§ ass n 0) ;; offset by one to initialize
                        )
                        :else
                        (let [
                              ;; calculate the bit length of the magnitude
                              #_"int" magBitLength (ß ((len - 1) << 5) + BigInteger'bitLengthForInt(this.mag[0]))
                        ]
                            (cond (ß this.signum < 0)
                                (let [
                                      ;; check if magnitude is a power of two
                                      #_"boolean" pow2 (ß (Integer/bitCount(this.mag[0]) == 1))
                                ]
                                    (loop-when-recur [#_"int" i 1] (and (ß i < len) pow2) [(inc i)]
                                        (§ ass pow2 (ß (this.mag[i] == 0)))
                                    )

                                    (§ ass n (if pow2 (dec magBitLength) magBitLength))
                                )
                                :else
                                (do
                                    (§ ass n magBitLength)
                                )
                            )
                        )
                    )
                    (§ ass (:bitLength this) (inc n))
                )
            )
            n
        )
    )

    ;;;
     ; Returns the number of bits in the two's complement representation
     ; of this BigInteger that differ from its sign bit. This method is
     ; useful when implementing bit-vector style sets atop BigIntegers.
     ;
     ; @return number of bits in the two's complement representation
     ;         of this BigInteger that differ from its sign bit.
     ;;
    #_method
    (defn #_"int" BigInteger''bitCount [#_"BigInteger" this]
        (let [
              #_"int" bc (ß this.bitCount - 1)
        ]
            (when (ß bc == -1) ;; bitCount not initialized yet
                (let [
                ]
                    (§ ass bc 0) ;; offset by one to initialize
                    ;; count the bits in the magnitude
                    (loop-when-recur [#_"int" i 0] (ß i < this.mag.length) [(inc i)]
                        (§ ass bc (ß bc + Integer/bitCount(this.mag[i])))
                    )
                    (when (ß this.signum < 0)
                        ;; count the trailing zeros in the magnitude
                        (let [
                              #_"int" magTrailingZeroCount (ß 0, j)
                        ]
                            (loop-when-recur [j (ß this.mag.length - 1)] (ß this.mag[j] == 0) [(dec j)]
                                (§ ass magTrailingZeroCount (+ magTrailingZeroCount 32))
                            )
                            (§ ass magTrailingZeroCount (ß magTrailingZeroCount + Integer/numberOfTrailingZeros(this.mag[j])))
                            (§ ass bc (ß bc + magTrailingZeroCount - 1))
                        )
                    )
                    (§ ass (:bitCount this) (inc bc))
                )
            )
            bc
        )
    )

    ;; primality testing

    ;;;
     ; Returns {@code true} if this BigInteger is probably prime,
     ; {@code false} if it's definitely composite.
     ; If {@code certainty} is <= 0, {@code true} is returned.
     ;
     ; @param  certainty a measure of the uncertainty that the caller is
     ;         willing to tolerate: if the call returns {@code true}
     ;         the probability that this BigInteger is prime exceeds
     ;         (1 - 1/2<sup>{@code certainty}</sup>). The execution time of
     ;         this method is proportional to the value of this parameter.
     ; @return {@code true} if this BigInteger is probably prime,
     ;         {@code false} if it's definitely composite.
     ;;
    #_method
    (defn #_"boolean" BigInteger''isProbablePrime [#_"BigInteger" this, #_"int" certainty]
        (when (<= certainty 0)
            (§ return true)
        )
        (let [
              #_"BigInteger" w (BigInteger''abs this)
        ]
            (when (ß w.equals(BigInteger'TWO))
                (§ return true)
            )
            (when (or (ß !BigInteger''testBit(w, 0)) (ß w.equals(BigInteger'ONE)))
                (§ return false)
            )

            (BigInteger''primeToCertainty w, certainty, nil)
        )
    )

    ;; comparison operations

    ;;;
     ; Compares this BigInteger with the specified BigInteger.
     ; This method is provided in preference to individual methods for
     ; each of the six boolean comparison operators ({@literal <}, ==,
     ; {@literal >}, {@literal >=}, !=, {@literal <=}). The suggested
     ; idiom for performing these comparisons is: {@code
     ; (x.compareTo(y)} &lt;<i>op</i>&gt; {@code 0)}, where
     ; &lt;<i>op</i>&gt; is one of the six comparison operators.
     ;
     ; @param  val BigInteger to which this BigInteger is to be compared.
     ; @return -1, 0 or 1 as this BigInteger is numerically less than, equal
     ;         to, or greater than {@code val}.
     ;;
    #_foreign
    (defn #_"int" compareTo---BigInteger [#_"BigInteger" this, #_"BigInteger" val]
        (when (ß this.signum == val.signum)
            (§ switch (:signum this)
                (§ case 1
                    (§ return (BigInteger''compareMagnitude-i this, val))
                )
                (§ case -1
                    (§ return (BigInteger''compareMagnitude-i val, this))
                )
                (§ default
                    (§ return 0)
                )
            )
        )
        (if (ß this.signum > val.signum) 1 -1)
    )

    ;;;
     ; Compares the magnitude array of this BigInteger with the specified
     ; BigInteger's. This is the version of compareTo ignoring sign.
     ;
     ; @param val BigInteger whose magnitude array to be compared.
     ; @return -1, 0 or 1 as this magnitude array is less than, equal to or
     ;         greater than the magnitude aray for the specified BigInteger's.
     ;;
    #_method
    (defn #_"int" BigInteger''compareMagnitude-i [#_"BigInteger" this, #_"BigInteger" val]
        (let [
              #_"int[]" m1 (:mag this)
              #_"int" len1 (ß m1.length)
              #_"int[]" m2 (ß val.mag)
              #_"int" len2 (ß m2.length)
        ]
            (when (< len1 len2)
                (§ return -1)
            )
            (when (< len2 len1)
                (§ return 1)
            )
            (loop-when-recur [#_"int" i 0] (< i len1) [(inc i)]
                (let [
                      #_"int" a (ß m1[i])
                      #_"int" b (ß m2[i])
                ]
                    (when (ß a != b)
                        (§ return (if (ß (a & BigInteger'LONG_MASK) < (b & BigInteger'LONG_MASK)) -1 1))
                    )
                )
            )
            0
        )
    )

    ;;;
     ; Version of compareMagnitude that compares magnitude with long value.
     ; val can't be Long/MIN_VALUE.
     ;;
    #_method
    (defn #_"int" BigInteger''compareMagnitude-l [#_"BigInteger" this, #_"long" val]
        (when (= val Long/MIN_VALUE)
            (throw! "(= val Long/MIN_VALUE)")
        )
        (let [
              #_"int[]" m1 (:mag this)
              #_"int" len (ß m1.length)
        ]
            (when (< 2 len)
                (§ return 1)
            )
            (when (< val 0)
                (§ ass val (- val))
            )
            (let [
                  #_"int" highWord (ß (int)(val >>> 32))
            ]
                (cond (ß highWord == 0)
                    (do
                        (when (< len 1)
                            (§ return -1)
                        )
                        (when (< 1 len)
                            (§ return 1)
                        )
                        (let [
                              #_"int" a (ß m1[0])
                              #_"int" b (ß (int)val)
                        ]
                            (when (ß a != b)
                                (§ return (if (ß (a & BigInteger'LONG_MASK) < (b & BigInteger'LONG_MASK)) -1 1))
                            )
                            (§ return 0)
                        )
                    )
                    :else
                    (do
                        (when (< len 2)
                            (§ return -1)
                        )
                        (let [
                              #_"int" a (ß m1[0])
                              #_"int" b highWord
                        ]
                            (when (ß a != b)
                                (§ return (if (ß (a & BigInteger'LONG_MASK) < (b & BigInteger'LONG_MASK)) -1 1))
                            )
                            (§ ass a (ß m1[1]))
                            (§ ass b (ß (int)val))
                            (when (ß a != b)
                                (§ return (if (ß (a & BigInteger'LONG_MASK) < (b & BigInteger'LONG_MASK)) -1 1))
                            )
                            (§ return 0)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Compares this BigInteger with the specified Object for equality.
     ;
     ; @param  x Object to which this BigInteger is to be compared.
     ; @return {@code true} if and only if the specified Object is a
     ;         BigInteger whose value is numerically equal to this BigInteger.
     ;;
    #_foreign
    (defn #_"boolean" equals---BigInteger [#_"BigInteger" this, #_"Object" x]
        ;; this test is just an optimization, which may or may not help
        (when (ß x == this)
            (§ return true)
        )

        (when (ß !(x instanceof BigInteger))
            (§ return false)
        )

        (let [
              #_"BigInteger" xInt (ß (BigInteger) x)
        ]
            (when (ß (:signum xInt) != (:signum this))
                (§ return false)
            )

            (let [
                  #_"int[]" m (:mag this)
                  #_"int" len (:length m)
                  #_"int[]" xm (:mag xInt)
            ]
                (when (ß len != xm.length)
                    (§ return false)
                )

                (loop-when-recur [#_"int" i 0] (< i len) [(inc i)]
                    (when (ß xm[i] != m[i])
                        (§ return false)
                    )
                )

                true
            )
        )
    )

    ;;;
     ; Returns the minimum of this BigInteger and {@code val}.
     ;
     ; @param  val value with which the minimum is to be computed.
     ; @return the BigInteger whose value is the lesser of this BigInteger and
     ;         {@code val}. If they are equal, either may be returned.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''min [#_"BigInteger" this, #_"BigInteger" val]
        (if (ß compareTo(val) < 0) this val)
    )

    ;;;
     ; Returns the maximum of this BigInteger and {@code val}.
     ;
     ; @param  val value with which the maximum is to be computed.
     ; @return the BigInteger whose value is the greater of this and
     ;         {@code val}. If they are equal, either may be returned.
     ;;
    #_method
    (defn #_"BigInteger" BigInteger''max [#_"BigInteger" this, #_"BigInteger" val]
        (if (ß compareTo(val) > 0) this val)
    )

    ;; hash function

    ;;;
     ; Returns the hash code for this BigInteger.
     ;
     ; @return hash code for this BigInteger.
     ;;
    #_foreign
    (defn #_"int" hashCode---BigInteger [#_"BigInteger" this]
        (let [
              #_"int" hashCode 0
        ]
            (loop-when-recur [#_"int" i 0] (ß i < this.mag.length) [(inc i)]
                (§ ass hashCode (ß (int)(31 * hashCode + (this.mag[i] & BigInteger'LONG_MASK))))
            )

            (ß hashCode * this.signum)
        )
    )

    (declare BigInteger'toString)

    ;;;
     ; Returns the String representation of this BigInteger in the given radix.
     ; If the radix is outside the range from {@link Character#MIN_RADIX}
     ; to {@link Character#MAX_RADIX} inclusive, it will default to 10 (as is
     ; the case for {@code Integer.toString}). The digit-to-character mapping
     ; provided by {@code Character.forDigit} is used, and a minus
     ; sign is prepended if appropriate. (This representation is compatible with
     ; the {@link #BigInteger(String, int) (String, int)} constructor.)
     ;
     ; @param  radix  radix of the String representation.
     ; @return String representation of this BigInteger in the given radix.
     ;;
    #_method
    (defn #_"String" BigInteger''toString [#_"BigInteger" this, #_"int" radix]
        (when (ß this.signum == 0)
            (§ return "0")
        )
        (when (or (ß radix < Character/MIN_RADIX) (ß radix > Character/MAX_RADIX))
            (§ ass radix 10)
        )

        ;; If it's small enough, use smallToString.
        (when (ß this.mag.length <= BigInteger'SCHOENHAGE_BASE_CONVERSION_THRESHOLD)
            (§ return (BigInteger''smallToString this, radix))
        )

        ;; Otherwise use recursive toString, which requires positive arguments.
        ;; The results will be concatenated into this StringBuilder.
        (let [
              #_"StringBuilder" sb (ß new StringBuilder())
        ]
            (cond (ß this.signum < 0)
                (do
                    (ß BigInteger'toString(BigInteger''negate(this), sb, radix, 0))
                    (ß sb.insert(0, (§ char "-")))
                )
                :else
                (do
                    (BigInteger'toString this, sb, radix, 0)
                )
            )

            (ß sb.toString())
        )
    )

    ;;;
     ; This method is used to perform toString when arguments are small.
     ;;
    #_method
    (defn- #_"String" BigInteger''smallToString [#_"BigInteger" this, #_"int" radix]
        (when (ß this.signum == 0)
            (§ return "0")
        )

        ;; compute upper bound on number of digit groups and allocate space
        (let [
              #_"int" maxNumDigitGroups (ß (4 * this.mag.length + 6) / 7)
              #_"String[]" digitGroup (ß new String[maxNumDigitGroups])

              ;; translate number to string, a digit group at a time
              #_"BigInteger" tmp (BigInteger''abs this)
              #_"int" numGroups 0
        ]
            (while (ß tmp.signum != 0)
                (let [
                      #_"BigInteger" d (ß BigInteger'longRadix[radix])
                      #_"MutableBigInteger" q (MutableBigInteger'new)
                      #_"MutableBigInteger" a (ß MutableBigInteger'new(tmp.mag))
                      #_"MutableBigInteger" b (ß MutableBigInteger'new(d.mag))
                      #_"MutableBigInteger" r (MutableBigInteger''divide-3 a, b, q)
                      #_"BigInteger" q2 (ß MutableBigInteger''toBigInteger-2(q, tmp.signum * d.signum))
                      #_"BigInteger" r2 (ß MutableBigInteger''toBigInteger-2(r, tmp.signum * d.signum))
                ]
                    (§ ass (aget digitGroup numGroups) (ß Long/toString(r2.longValue(), radix)))
                    (§ ass numGroups (inc numGroups))
                    (§ ass tmp q2)
                )
            )

            ;; put sign (if any) and first digit group into result buffer
            (let [
                  #_"StringBuilder" buf (ß new StringBuilder(numGroups * BigInteger'digitsPerLong[radix] + 1))
            ]
                (when (ß this.signum < 0)
                    (ß buf.append((§ char "-")))
                )
                (ß buf.append(digitGroup[numGroups - 1]))

                ;; append remaining digit groups padded with leading zeros
                (loop-when-recur [#_"int" i (- numGroups 2)] (<= 0 i) [(dec i)]
                    ;; prepend (any) leading zeros for this digit group
                    (let [
                          #_"int" numLeadingZeros (ß BigInteger'digitsPerLong[radix] - digitGroup[i].length())
                    ]
                        (when (ß numLeadingZeros != 0)
                            (ß buf.append(BigInteger'zeros[numLeadingZeros]))
                        )
                        (ß buf.append(digitGroup[i]))
                    )
                )
                (ß buf.toString())
            )
        )
    )

    (declare BigInteger'getRadixConversionCache)

    ;;;
     ; Converts the specified BigInteger to a string and appends to {@code sb}.
     ; This implements the recursive Schoenhage algorithm for base conversions.
     ;
     ; See Knuth, Donald, _The Art of Computer Programming_, Vol. 2,
     ; Answers to Exercises (4.4) Question 14.
     ;
     ; @param u      The number to convert to a string.
     ; @param sb     The StringBuilder that will be appended to in place.
     ; @param radix  The base to convert to.
     ; @param digits The minimum number of digits to pad to.
     ;;
    (defn- #_"void" BigInteger'toString [#_"BigInteger" u, #_"StringBuilder" sb, #_"int" radix, #_"int" digits]
        ;; If we're smaller than a certain threshold, use the smallToString method,
        ;; padding with leading zeroes when necessary.
        (when (ß u.mag.length <= BigInteger'SCHOENHAGE_BASE_CONVERSION_THRESHOLD)
            (let [
                  #_"String" s (BigInteger''smallToString u, radix)
            ]
                ;; Pad with internal zeros if necessary.
                ;; Don't pad if we're at the beginning of the string.
                (when (and (ß s.length() < digits) (ß sb.length() > 0))
                    (loop-when-recur [#_"int" i (ß s.length())] (< i digits) [(inc i)] ;; May be a faster way to do this?
                        (ß sb.append((§ char "0")))
                    )
                )

                (ß sb.append(s))
                (§ return nil)
            )
        )

        (let [
              #_"int" b (BigInteger''bitLength u)
              ;; Calculate a value for n in the equation radix^(2^n) = u
              ;; and subtract 1 from that value. This is used to find the
              ;; cache index that contains the best value to divide u.
              #_"int" n (ß (int) Math/round(Math/log(b * BigInteger'LOG_TWO / BigInteger'logCache[radix]) / BigInteger'LOG_TWO - 1.0))
              #_"BigInteger" v (BigInteger'getRadixConversionCache radix, n)
              #_"BigInteger[]" results (BigInteger''divideAndRemainder u, v)
              #_"int" expectedDigits (ß 1 << n)
        ]
            ;; Now recursively build the two halves of each number.
            (ß BigInteger'toString(results[0], sb, radix, digits - expectedDigits))
            (ß BigInteger'toString(results[1], sb, radix, expectedDigits))
        )
        nil
    )

    ;;;
     ; Returns the value radix^(2^exponent) from the cache.
     ; If this value doesn't already exist in the cache, it is added.
     ;
     ; This could be changed to a more complicated caching method using {@code Future}.
     ;;
    (defn- #_"BigInteger" BigInteger'getRadixConversionCache [#_"int" radix, #_"int" exponent]
        (let [
              #_"BigInteger[]" cacheLine (ß BigInteger'powerCache[radix]) ;; volatile read
        ]
            (when (< exponent (§ soon alength cacheLine))
                (§ return (aget cacheLine exponent))
            )

            (let [
                  #_"int" oldLength (§ soon alength cacheLine)
                  _ (§ ass cacheLine (ß Arrays/copyOf(cacheLine, exponent + 1)))
            ]
                (loop-when-recur [#_"int" i oldLength] (<= i exponent) [(inc i)]
                    (§ ass (aget cacheLine i) (ß BigInteger''pow(cacheLine[i - 1], 2)))
                )

                (let [
                      #_"BigInteger[][]" pc (ß BigInteger'powerCache) ;; volatile read again
                ]
                    (when (ß exponent >= pc[radix].length)
                        (§ ass pc (ß pc.clone()))
                        (§ ass (aget pc radix) cacheLine)
                        (§ ass BigInteger'powerCache pc) ;; volatile write, publish
                    )
                    (§ soon aget cacheLine exponent)
                )
            )
        )
    )

    ;; zero[i] is a string of i consecutive zeros
    (def- #_"String[]" BigInteger'zeros (ß new String[64]))

    #_static
    (§
        (§ ass (ß BigInteger'zeros[63]) "000000000000000000000000000000000000000000000000000000000000000")
        (loop-when-recur [#_"int" i 0] (< i 63) [(inc i)]
            (§ ass (ß BigInteger'zeros[i]) (ß BigInteger'zeros[63].substring(0, i)))
        )
    )

    ;;;
     ; Returns the decimal String representation of this BigInteger.
     ; The digit-to-character mapping provided by {@code Character.forDigit}
     ; is used, and a minus sign is prepended if appropriate.
     ; (This representation is compatible with the {@link #BigInteger(String) (String)}
     ; constructor, and allows for String concatenation with Java's + operator.)
     ;
     ; @return decimal String representation of this BigInteger.
     ;;
    #_foreign
    (defn #_"String" toString---BigInteger [#_"BigInteger" this]
        (BigInteger''toString this, 10)
    )

    (declare BigInteger''getInt)

    ;;;
     ; Returns a byte array containing the two's-complement representation of this BigInteger.
     ; The byte array will be in <i>big-endian</i> byte-order: the most significant byte is in the
     ; zeroth element. The array will contain the minimum number of bytes required to represent this
     ; BigInteger, including at least one sign bit, which is {@code (ceil((this.bitLength() + 1)/8))}.
     ; (This representation is compatible with the {@link #BigInteger(byte[]) (byte[])} constructor.)
     ;
     ; @return a byte array containing the two's-complement representation of this BigInteger.
     ;;
    #_method
    (defn #_"byte[]" BigInteger''toByteArray [#_"BigInteger" this]
        (let [
              #_"int" byteLen (ß BigInteger''bitLength(this) / 8 + 1)
              #_"byte[]" byteArray (ß new byte[byteLen])
        ]
            (loop-when-recur [#_"int" bytesCopied 4 #_"int" nextInt 0 #_"int" intIndex 0 #_"int" i (dec byteLen)] (<= 0 i) [bytesCopied nextInt intIndex (dec i)]
                (cond (ß bytesCopied == 4)
                    (do
                        (§ ass nextInt (BigInteger''getInt this, intIndex))
                        (§ ass intIndex (inc intIndex))
                        (§ ass bytesCopied 1)
                    )
                    :else
                    (do
                        (§ ass nextInt (ß nextInt >>> 8))
                        (§ ass bytesCopied (inc bytesCopied))
                    )
                )
                (§ ass (aget byteArray i) (ß (byte)nextInt))
            )
            byteArray
        )
    )

    ;;;
     ; Converts this BigInteger to an {@code int}.
     ; This conversion is analogous to a <i>narrowing primitive conversion</i>
     ; from {@code long} to {@code int} as defined in section 5.1.3 of
     ; <cite>The Java Language Specification</cite>: if this BigInteger
     ; is too big to fit in an {@code int}, only the low-order 32 bits are returned.
     ; Note that this conversion can lose information about the overall magnitude
     ; of the BigInteger value as well as return a result with the opposite sign.
     ;
     ; @return this BigInteger converted to an {@code int}.
     ;;
    #_foreign
    (defn #_"int" intValue---BigInteger [#_"BigInteger" this]
        (BigInteger''getInt this, 0)
    )

    ;;;
     ; Converts this BigInteger to a {@code long}.
     ; This conversion is analogous to a <i>narrowing primitive conversion</i>
     ; from {@code long} to {@code int} as defined in section 5.1.3 of
     ; <cite>The Java Language Specification</cite>: if this BigInteger
     ; is too big to fit in a {@code long}, only the low-order 64 bits are returned.
     ; Note that this conversion can lose information about the overall magnitude
     ; of the BigInteger value as well as return a result with the opposite sign.
     ;
     ; @return this BigInteger converted to a {@code long}.
     ;;
    #_foreign
    (defn #_"long" longValue---BigInteger [#_"BigInteger" this]
        (let [
              #_"long" result 0
        ]
            (loop-when-recur [#_"int" i 1] (<= 0 i) [(dec i)]
                (§ ass result (ß (result << 32) + (BigInteger''getInt(this, i) & BigInteger'LONG_MASK)))
            )
            result
        )
    )

    ;;;
     ; Returns a copy of the input array stripped of any leading zero bytes.
     ;;
    (defn- #_"int[]" BigInteger'stripLeadingZeroInts [#_"int[]" val]
        (let [
              #_"int" vlen (ß val.length)
        ]
            (ß #_"int" keep)

            ;; find first nonzero byte
            (loop-when-recur [keep 0] (and (ß keep < vlen) (ß val[keep] == 0)) [(inc keep)]
            )
            (ß Arrays/copyOfRange(val, keep, vlen))
        )
    )

    ;;;
     ; Returns the input array stripped of any leading zero bytes.
     ; Since the source is trusted the copying may be skipped.
     ;;
    (defn- #_"int[]" BigInteger'trustedStripLeadingZeroInts [#_"int[]" val]
        (let [
              #_"int" vlen (ß val.length)
        ]
            (ß #_"int" keep)

            ;; find first nonzero byte
            (loop-when-recur [keep 0] (and (ß keep < vlen) (ß val[keep] == 0)) [(inc keep)]
            )
            (if (ß keep == 0) val (ß Arrays/copyOfRange(val, keep, vlen)))
        )
    )

    ;;;
     ; Returns a copy of the input array stripped of any leading zero bytes.
     ;;
    (defn- #_"int[]" BigInteger'stripLeadingZeroBytes [#_"byte[]" a]
        (let [
              #_"int" byteLength (:length a)
        ]
            (ß #_"int" keep)

            ;; find first nonzero byte
            (loop-when-recur [keep 0] (and (ß keep < byteLength) (ß a[keep] == 0)) [(inc keep)]
            )

            ;; allocate new array and copy relevant part of input array
            (let [
                  #_"int" intLength (ß ((byteLength - keep) + 3) >>> 2)
                  #_"int[]" result (ß new int[intLength])
                  #_"int" b (dec byteLength)
            ]
                (loop-when-recur [#_"int" i (dec intLength)] (<= 0 i) [(dec i)]
                    (§ ass (aget result i) (ß a[b] & 0xff))
                    (§ ass b (dec b))
                    (let [
                          #_"int" bytesRemaining (ß b - keep + 1)
                          #_"int" bytesToTransfer (ß Math/min(3, bytesRemaining))
                    ]
                        (loop-when-recur [#_"int" j 8] (ß j <= (bytesToTransfer << 3)) [(+ j 8)]
                            (§ ass (aget result i) (ß (ß result[i] | ((a[b] & 0xff) << j))))
                            (§ ass b (dec b))
                        )
                    )
                )
                result
            )
        )
    )

    ;;;
     ; Takes an array a representing a negative 2's-complement number and
     ; returns the minimal (no leading zero bytes) unsigned whose value is -a.
     ;;
    (defn- #_"int[]" BigInteger'makePositive-b [#_"byte[]" a]
        (let [
              #_"int" keep (ß )
              #_"int" k (ß )
              #_"int" byteLength (:length a)
        ]
            ;; find first non-sign (0xff) byte of input
            (loop-when-recur [keep 0] (and (ß keep < byteLength) (ß a[keep] == -1)) [(inc keep)]
            )

            ;; Allocate output array. If all non-sign bytes are 0x00,
            ;; we must allocate space for one extra output byte.
            (loop-when-recur [k keep] (and (ß k < byteLength) (ß a[k] == 0)) [(inc k)]
            )

            (let [
                  #_"int" extraByte (if (ß k == byteLength) 1 0)
                  #_"int" intLength (ß ((byteLength - keep + extraByte) + 3) >>> 2)
                  #_"int[]" result (ß new int[intLength])
                  ;; copy one's complement of input into output,
                  ;; leaving extra byte (if it exists) == 0x00
                 #_"int" b (dec byteLength)
            ]
                (loop-when-recur [#_"int" i (dec intLength)] (<= 0 i) [(dec i)]
                    (§ ass (aget result i) (ß a[b] & 0xff))
                    (§ ass b (dec b))
                    (let [
                          #_"int" numBytesToTransfer (ß Math/min(3, b - keep + 1))
                    ]
                        (when (< numBytesToTransfer 0)
                            (§ ass numBytesToTransfer 0)
                        )
                        (loop-when-recur [#_"int" j 8] (ß j <= 8 * numBytesToTransfer) [(+ j 8)]
                            (§ ass (aget result i) (ß (ß result[i] | ((a[b] & 0xff) << j))))
                            (§ ass b (dec b))
                        )

                        ;; mask indicates which bits must be complemented
                        (let [
                              #_"int" mask (ß -1 >>> (8 * (3 - numBytesToTransfer)))
                        ]
                            (§ ass (aget result i) (ß (§ bit-not)result[i] & mask))
                        )
                    )
                )

                ;; add one to one's complement to generate two's complement
                (loop-when-recur [#_"int" i (ß result.length - 1)] (<= 0 i) [(dec i)]
                    (§ ass (aget result i) (ß (int)((result[i] & BigInteger'LONG_MASK) + 1)))
                    (when (ß result[i] != 0)
                        (§ break)
                    )
                )

                result
            )
        )
    )

    ;;;
     ; Takes an array a representing a negative 2's-complement number and
     ; returns the minimal (no leading zero ints) unsigned whose value is -a.
     ;;
    (defn- #_"int[]" BigInteger'makePositive-i [#_"int[]" a]
        (let [
              #_"int" keep (ß )
              #_"int" j (ß )
        ]
            ;; find first non-sign (0xffffffff) int of input
            (loop-when-recur [keep 0] (and (ß keep < a.length) (ß a[keep] == -1)) [(inc keep)]
            )

            ;; Allocate output array. If all non-sign ints are 0x00,
            ;; we must allocate space for one extra output int.
            (loop-when-recur [j keep] (and (ß j < a.length) (ß a[j] == 0)) [(inc j)]
            )
            (let [
                  #_"int" extraInt (if (ß j == a.length) 1 0)
                  #_"int[]" result (ß new int[a.length - keep + extraInt])
            ]
                ;; copy one's complement of input into output,
                ;; leaving extra int (if it exists) == 0x00
                (loop-when-recur [#_"int" i keep] (ß i < a.length) [(inc i)]
                    (§ ass (aget result (ß i - keep + extraInt)) (ß (§ bit-not)a[i]))
                )

                ;; add one to one's complement to generate two's complement
                (loop [#_"int" i (ß result.length - 1)]
                    (let-when [_ (§ ass (aget result i) (ß result[i] + 1))] (ß result[i] == 0)
                        (recur (dec i))
                    )
                )

                result
            )
        )
    )

    ;;
     ; The following two arrays are used for fast String conversions. Both
     ; are indexed by radix. The first is the number of digits of the given
     ; radix that can fit in a Java long without "going negative", i.e., the
     ; highest integer n such that radix**n < 2**63. The second is the
     ; "long radix" that tears each number into "long digits", each of which
     ; consists of the number of digits in the corresponding element in
     ; digitsPerLong (longRadix[i] = i**digitPerLong[i]). Both arrays have
     ; nonsense values in their 0 and 1 elements, as radixes 0 and 1 are not
     ; used.
     ;;
    (def- #_"int[]" BigInteger'digitsPerLong
        (§
            0, 0,
            62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14,
            14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12
        )
    )

    (def- #_"BigInteger[]" BigInteger'longRadix
        (§
            nil, nil,
            BigInteger'valueOf-l(0x4000000000000000), BigInteger'valueOf-l(0x383d9170b85ff80b),
            BigInteger'valueOf-l(0x4000000000000000), BigInteger'valueOf-l(0x6765c793fa10079d),
            BigInteger'valueOf-l(0x41c21cb8e1000000), BigInteger'valueOf-l(0x3642798750226111),
            BigInteger'valueOf-l(0x1000000000000000), BigInteger'valueOf-l(0x12bf307ae81ffd59),
            BigInteger'valueOf-l(0x0de0b6b3a7640000), BigInteger'valueOf-l(0x4d28cb56c33fa539),
            BigInteger'valueOf-l(0x1eca170c00000000), BigInteger'valueOf-l(0x780c7372621bd74d),
            BigInteger'valueOf-l(0x1e39a5057d810000), BigInteger'valueOf-l(0x5b27ac993df97701),
            BigInteger'valueOf-l(0x1000000000000000), BigInteger'valueOf-l(0x27b95e997e21d9f1),
            BigInteger'valueOf-l(0x5da0e1e53c5c8000), BigInteger'valueOf-l(0x0b16a458ef403f19),
            BigInteger'valueOf-l(0x16bcc41e90000000), BigInteger'valueOf-l(0x2d04b7fdd9c0ef49),
            BigInteger'valueOf-l(0x5658597bcaa24000), BigInteger'valueOf-l(0x06feb266931a75b7),
            BigInteger'valueOf-l(0x0c29e98000000000), BigInteger'valueOf-l(0x14adf4b7320334b9),
            BigInteger'valueOf-l(0x226ed36478bfa000), BigInteger'valueOf-l(0x383d9170b85ff80b),
            BigInteger'valueOf-l(0x5a3c23e39c000000), BigInteger'valueOf-l(0x04e900abb53e6b71),
            BigInteger'valueOf-l(0x07600ec618141000), BigInteger'valueOf-l(0x0aee5720ee830681),
            BigInteger'valueOf-l(0x1000000000000000), BigInteger'valueOf-l(0x172588ad4f5f0981),
            BigInteger'valueOf-l(0x211e44f7d02c1000), BigInteger'valueOf-l(0x2ee56725f06e5c71),
            BigInteger'valueOf-l(0x41c21cb8e1000000)
        )
    )

    ;;
     ; These two arrays are the integer analogue of above.
     ;;
    (def- #_"int[]" BigInteger'digitsPerInt
        (§
            0, 0, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5
        )
    )

    (def- #_"int[]" BigInteger'intRadix
        (§
            0, 0,
            0x40000000, 0x4546b3db, 0x40000000, 0x48c27395, 0x159fd800,
            0x75db9c97, 0x40000000, 0x17179149, 0x3b9aca00, 0x0cc6db61,
            0x19a10000, 0x309f1021, 0x57f6c100, 0x0a2f1b6f, 0x10000000,
            0x18754571, 0x247dbc80, 0x3547667b, 0x4c4b4000, 0x6b5a6e1d,
            0x06c20a40, 0x08d2d931, 0x0b640000, 0x0e8d4a51, 0x1269ae40,
            0x17179149, 0x1cb91000, 0x23744899, 0x2b73a840, 0x34e63b41,
            0x40000000, 0x4cfa3cc1, 0x5c13d840, 0x6d91b519, 0x039aa400
        )
    )

    ;;;
     ; These routines provide access to the two's complement representation of BigIntegers.
     ;;

    ;;;
     ; Returns the length of the two's complement representation in ints,
     ; including space for at least one sign bit.
     ;;
    #_method
    (defn- #_"int" BigInteger''intLength [#_"BigInteger" this]
        (ß (BigInteger''bitLength(this) >>> 5) + 1)
    )

    ;;; Returns sign bit.
    #_method
    (defn- #_"int" BigInteger''signBit [#_"BigInteger" this]
        (if (ß this.signum < 0) 1 0)
    )

    ;;; Returns an int of sign bits.
    #_method
    (defn- #_"int" BigInteger''signInt [#_"BigInteger" this]
        (if (ß this.signum < 0) -1 0)
    )

    ;;;
     ; Returns the specified int of the little-endian two's complement representation
     ; (int 0 is the least significant). The int number can be arbitrarily high
     ; (values are logically preceded by infinitely many sign ints).
     ;;
    #_method
    (defn- #_"int" BigInteger''getInt [#_"BigInteger" this, #_"int" n]
        (when (< n 0)
            (§ return 0)
        )
        (when (ß n >= this.mag.length)
            (§ return (BigInteger''signInt this))
        )

        (let [
              #_"int" magInt (ß this.mag[this.mag.length - n - 1])
        ]
            (cond (ß this.signum >= 0) magInt (ß n <= BigInteger''firstNonzeroIntNum(this)) (- magInt) :else (bit-not magInt))
        )
    )

    ;;;
     ; Returns the index of the int that contains the first nonzero int in the
     ; little-endian binary representation of the magnitude (int 0 is the
     ; least significant). If the magnitude is zero, return value is undefined.
     ;;
    #_method
    (defn- #_"int" BigInteger''firstNonzeroIntNum [#_"BigInteger" this]
        (let [
              #_"int" fn (ß this.firstNonzeroIntNum - 2)
        ]
            (when (ß fn == -2) ;; firstNonzeroIntNum not initialized yet
                ;; search for the first nonzero int
                (let [
                      #_"int" mlen (ß this.mag.length)
                      #_"int" i (loop-when-recur [i (dec mlen)] (and (ß i >= 0) (ß this.mag[i] == 0)) [(dec i)] => i)
                ]
                    (§ ass fn (ß mlen - i - 1))
                    (§ ass (:firstNonzeroIntNum this) (+ fn 2)) ;; offset by two to initialize
                )
            )
            fn
        )
    )

    #_foreign
    (defn #_"float" floatValue---BigInteger [#_"BigInteger" this]
        (throw! "no floating loathing")
    )

    #_foreign
    (defn #_"double" doubleValue---BigInteger [#_"BigInteger" this]
        (throw! "no double bubble")
    )
)
)
