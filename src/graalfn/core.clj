(ns graalfn.core
    (:refer-clojure :only [* *ns* + - -> ->> / < <= = > >= aget and apply aset assoc bit-and bit-not bit-or bit-shift-left bit-shift-right bit-xor boolean boolean-array byte byte-array case char comp compare cond condp conj cons contains? count dec declare defmacro defn defprotocol defrecord dissoc doseq dotimes double double-array empty? extend-protocol extend-type filter first fn get hash-map hash-set if-not import inc instance? int int-array into into-array iterate iterator-seq key keys let letfn list locking long long-array loop make-array map mapcat max merge min neg? next nil? not not= ns-imports ns-unmap nth object-array or peek pop pos? quot reduce reify rem remove repeat rest reverse run! satisfies? second seq sequential? short some some? sort-by sorted-map str subvec symbol symbol? take-while unsigned-bit-shift-right update update-in val vals vary-meta vec vector vector? volatile! vreset! vswap! when-some while zero?])
)

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro defp [p & s] (let [i (symbol (str p "'iface"))] `(do (defprotocol ~p ~@s) (def ~i (:on-interface ~p)) ~p)))
(defmacro defr [r & s] (let [c (symbol (str r "'class"))] `(do (defrecord ~c [])    (extend-type ~c ~r ~@s)     ~c)))
(defmacro defm [r p & s] (let [i (:on r)]                 `(do                      (extend-type ~i ~p ~@s)     ~i)))

(defmacro class-ns [r [& s] & z] `(do (defr ~r ~@s) ~@z))
(defmacro value-ns [_ & z] (cons 'do z))

(doseq [% (keys (ns-imports *ns*))] (ns-unmap *ns* %))

(import
    [java.lang
        ArithmeticException Boolean Byte Character Class ClassLoader Double Error Float IllegalArgumentException IllegalStateException
        IncompatibleClassChangeError IndexOutOfBoundsException Integer Iterable Long Math Module NoClassDefFoundError NoSuchFieldError
        NoSuchMethodError Object Short String StringBuilder System Throwable UnsupportedClassVersionError Void
    ]
)

(defmacro import-as [sym sig]
    (let [m (.getDeclaredMethod clojure.lang.Namespace, "referenceClass", (into-array Class [ clojure.lang.Symbol Class ]))]
        (.setAccessible m, true)
        (.invoke m, *ns*, (object-array [ sym (Class/forName sig) ]))
    )
)

(import-as boolean'array "[Z")
(import-as byte'array    "[B")
(import-as char'array    "[C")
(import-as double'array  "[D")
(import-as float'array   "[F")
(import-as int'array     "[I")
(import-as long'array    "[J")
(import-as short'array   "[S")

(import-as Object'array "[Ljava.lang.Object;")

(def boolean'class Boolean/TYPE)
(def byte'class    Byte/TYPE)
(def char'class    Character/TYPE)
(def double'class  Double/TYPE)
(def float'class   Float/TYPE)
(def int'class     Integer/TYPE)
(def long'class    Long/TYPE)
(def short'class   Short/TYPE)

(def void'class Void/TYPE)

(defmacro throw! [^String s] `(throw (Error. ~s)))

(defmacro def-      [x & s] `(def      ~(vary-meta x assoc :private true) ~@s))
(defmacro defn-     [x & s] `(defn     ~(vary-meta x assoc :private true) ~@s))
(defmacro defmacro- [x & s] `(defmacro ~(vary-meta x assoc :private true) ~@s))

(letfn [(=> [s] (if (= '=> (first s)) (next s) (cons nil s)))]
    (defmacro     when       [? & s] (let [[e & s] (=> s)]               `(if     ~? (do ~@s) ~e)))
    (defmacro     when-not   [? & s] (let [[e & s] (=> s)]               `(if-not ~? (do ~@s) ~e)))
    (defmacro let-when     [v ? & s] (let [[e & s] (=> s)] `(let ~(vec v) (if     ~? (do ~@s) ~e))))
    (defmacro let-when-not [v ? & s] (let [[e & s] (=> s)] `(let ~(vec v) (if-not ~? (do ~@s) ~e))))
)

(letfn [(v' [v] (cond (vector? v) v (symbol? v) [v v] :else [`_# v]))
        (r' [r] (cond (vector? r) `((recur ~@r)) (some? r) `((recur ~r))))
        (=> [s] (if (= '=> (first s)) (next s) (cons nil s)))
        (l' [v ? r s] (let [r (r' r) [e & s] (=> s)] `(loop ~(v' v) (if ~? (do ~@s ~@r) ~e))))]
    (defmacro loop-when [v ? & s] (l' v ? nil s))
    (defmacro loop-when-recur [v ? r & s] (l' v ? r s))
)

(letfn [(r' [r] (cond (vector? r) `(recur ~@r) (some? r) `(recur ~r)))
        (=> [s] (if (= '=> (first s)) (second s)))]
    (defmacro recur-if [? r & s] `(if ~? ~(r' r) ~(=> s)))
)

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & s] `(let [f# ~f x# ~x] (or (f# x# ~y) (any f# x# ~@s))))
)

(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & s] (=? x (cons y s)))
)

(defmacro aswap [a i f & s] `(let [a# ~a i# ~i] (aset a# i# (~f (aget a# i#) ~@s))))

(def % rem)

(def & bit-and)
(def | bit-or)

(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defn abs [a] (if (neg? a) (- a) a))

(import
    [java.io DataInputStream IOException InputStream]
    [java.lang.annotation Annotation]
    [java.lang.ref #_Reference]
    [java.lang.reflect AnnotatedElement Constructor Field Method Modifier]
    [java.nio ByteBuffer ByteOrder]
    [java.util
        AbstractList ArrayDeque ArrayList Arrays BitSet Collection Collections Comparator ConcurrentModificationException
        Deque EnumMap EnumSet HashMap Iterator LinkedList List ListIterator Map Map$Entry NoSuchElementException PriorityQueue
        Queue Set SortedSet TreeSet
    ]
    [java.util.stream Stream Stream$Builder]

    [jdk.vm.ci.amd64 AMD64 AMD64$CPUFeature AMD64Kind]
    [jdk.vm.ci.code
        Architecture BytecodeFrame CallingConvention CodeCacheProvider CodeUtil InstalledCode MemoryBarriers Register
        RegisterArray RegisterAttributes RegisterConfig RegisterValue StackSlot TargetDescription ValueKindFactory
    ]
    [jdk.vm.ci.code.site ConstantReference DataPatch DataSectionReference Mark #_Reference Site]
    [jdk.vm.ci.hotspot
        HotSpotCallingConventionType HotSpotCompiledCode HotSpotCompressedNullConstant HotSpotConstant
        HotSpotConstantReflectionProvider HotSpotJVMCIRuntime HotSpotMemoryAccessProvider HotSpotMetaspaceConstant
        HotSpotObjectConstant HotSpotResolvedJavaField HotSpotResolvedJavaMethod HotSpotResolvedObjectType
        HotSpotVMConfigAccess
    ]
    [jdk.vm.ci.meta
        AllocatableValue Constant ConstantPool ConstantReflectionProvider DeoptimizationAction DeoptimizationReason
        InvokeTarget JavaConstant JavaField JavaKind JavaMethod JavaType MemoryAccessProvider MetaAccessProvider
        PlatformKind PrimitiveConstant RawConstant ResolvedJavaField ResolvedJavaMethod ResolvedJavaType Signature
        TriState VMConstant Value ValueKind
    ]
    [jdk.vm.ci.runtime JVMCIBackend]

    [org.graalvm.collections EconomicMap EconomicSet MapCursor Pair UnmodifiableEconomicMap UnmodifiableMapCursor]

    [sun.misc Unsafe]
)

(declare
Alive
BarrierType
BoxingSnippets
Def
Flags
GraalDirectives'UNLIKELY_PROBABILITY
GuardPriority
GuardsStage''ordinal-1
InjectedNodeParameter
Input
InputType
InstanceOfSnippets
MetaspaceOperation
MetaspaceOperation''opcode-1
MonitorSnippets
NewObjectSnippets
NodeEvent
OperandFlag
Optimization'values-0
OptionalInput
RegisterPriority''ordinal-1
Snippet
SpillState''ordinal-1
Successor
Temp
UnsafeLoadSnippets
Use
WordFactoryOperation
WordFactoryOperation''opcode-1
WordOperation
WordOperation''condition-1
WordOperation''node-1
WordOperation''opcode-1
WordOperation''rightOperandIsInt-1
WriteBarrierSnippets
)

(declare
AcquiredCASLockNode'mark-1
ArrayPlaceholder'piArrayCastToSnippetReplaceeStamp-2
BeginLockScopeNode'beginLockScope-1
ClassGetHubNode'readClass-1
ComputeObjectAddressNode'get-2
CurrentLockNode'currentLock-1
DeoptimizeCallerNode'deopt-2
DeoptimizeNode'deopt-2
EndLockScopeNode'endLockScope-0
ExplodeLoopNode'explodeLoop-0
FastAcquireBiasedLockNode'mark-1
FixedValueAnchorNode'getObject-1
LoadHubNode'loadHubIntrinsic-1
MembarNode'memoryBarrier-1
MembarNode'memoryBarrier-2
NullCheckNode'nullCheck-1
OffsetAddressNode'address-2
PiNode'piCastNonNull-2
Placeholder'piCastToSnippetReplaceeStamp-1
PrefetchAllocateNode'prefetch-1
RawLoadNode'loadKlassFromObjectIntrinsic-4
RawLoadNode'loadWordFromObjectIntrinsic-4
ReadRegisterNode'registerAsWord-3
SnippetAnchorNode'anchor-0
StoreHubNode'write-2
StubForeignCallNode'g1PostBarrier-3
StubForeignCallNode'g1PreBarrier-3
StubForeignCallNode'monitorenter-4
StubForeignCallNode'monitorexit-4
StubForeignCallNode'newArray-4
StubForeignCallNode'newInstance-3
VMConfigNode'areConfigValuesConstant-0
VMConfigNode'loadIntConfigValue-1
VMConfigNode'loadLongConfigValue-1
)

(declare
Word''compareAndSwapInt-5
Word''compareAndSwapLong-5
Word''compareAndSwapObject-5
Word''compareAndSwapWord-5
Word''klassPointerAsWord-1
Word''klassPointerIsNull-1
Word''klassPointersEqual-2
Word''klassPointersNotEqual-2
Word''logicCompareAndSwapWord-5
Word''readKlassPointer-3
Word''readObject-2
Word''readObject-3w
Word''readObject-3w
Word''toObject-1
Word''toObjectNonNull-1
Word''writeKlassPointer-4
Word''writeObject-3
Word''writeObject-4
Word'fromAddress-1
Word'klassPointerFromWord-1
Word'objectToTrackedPointer-1
)

(declare
AMD64Address'new-1
AMD64Address'new-2
AMD64Address'new-3
AMD64Address'new-4
AMD64Address'new-5
AMD64AddressNode''canonicalizeIndex-2
AMD64AddressNode''setBase-2
AMD64AddressNode''setDisplacement-2
AMD64AddressNode''setIndex-2
AMD64AddressNode''setScale-2
AMD64AddressNode'new-2
AMD64AddressValue''isValidImplicitNullCheckFor-3
AMD64AddressValue''toAddress-1
AMD64AddressValue'new-3
AMD64AddressValue'new-5
AMD64ByteSwapOp'new-2
AMD64CCall'new-3
AMD64Call'directCall-4
AMD64Call'directConditionalJmp-3
AMD64Call'directJmp-2
AMD64ClearRegisterOp'new-2
AMD64ControlFlow'cmove-4
AMD64ControlFlow'intCond-1
AMD64ControlFlow'setcc-3
AMD64DeoptimizeOp'new-0
AMD64HotSpotRestoreRbpOp'PLACEHOLDER
AMD64HotSpotReturnOp'new-3
AMD64HotSpotStrategySwitchOp'new-5
AMD64ImmOp''emitImmediate-4
AMD64ImmOp''immediateSize-2
AMD64ImmOp'new-5
AMD64LFenceOp'new-0
AMD64MIOp''emit-5a
AMD64MIOp''emit-5r
AMD64MIOp'MOV
AMD64MIOp'MOVB
AMD64MIOp'TEST
AMD64MIOp'new-1
AMD64MIOp'new-3
AMD64MIOp'new-4
AMD64MIOp'new-5
AMD64MOp''emit-4a
AMD64MOp''emit-4r
AMD64MOp'DEC
AMD64MOp'DIV
AMD64MOp'IDIV
AMD64MOp'IMUL
AMD64MOp'INC
AMD64MOp'MUL
AMD64MOp'NEG
AMD64MOp'NOT
AMD64MOp'POP
AMD64MOp'PUSH
AMD64MOp'new-2
AMD64MROp''emit-5
AMD64MROp'MOV
AMD64MROp'MOVB
AMD64MROp'new-1
AMD64MROp'new-3
AMD64Move'canMoveConst2Stack-1
AMD64Move'const2reg-3
AMD64Move'const2stack-3
AMD64Move'move-3
AMD64Move'move-4
AMD64Move'reg2stack-4
AMD64Move'stack2reg-4
AMD64MulDivOp'new-5
AMD64MulDivOp'new-6
AMD64MultiStackMove'new-4
AMD64Op''emitOpcode-6
AMD64Op'new-6
AMD64PrefetchOp'new-2
AMD64PushPopStackMove'new-3
AMD64RMIOp''emit-6a
AMD64RMIOp''emit-6r
AMD64RMIOp'IMUL
AMD64RMIOp'IMUL_SX
AMD64RMIOp'new-2
AMD64RMOp''emit-5
AMD64RMOp'BSF
AMD64RMOp'BSR
AMD64RMOp'IMUL
AMD64RMOp'LZCNT
AMD64RMOp'MOV
AMD64RMOp'MOVB
AMD64RMOp'MOVSX
AMD64RMOp'MOVSXB
AMD64RMOp'MOVSXD
AMD64RMOp'MOVZX
AMD64RMOp'MOVZXB
AMD64RMOp'POPCNT
AMD64RMOp'TEST
AMD64RMOp'TESTB
AMD64RMOp'TZCNT
AMD64RMOp'new-1
AMD64RMOp'new-2
AMD64RMOp'new-3
AMD64RMOp'new-4b
AMD64RMOp'new-4f
AMD64RROp'new-6
AMD64RestoreRegistersOp'new-2
AMD64SaveRegistersOp'new-2
AMD64Shift'RCL
AMD64Shift'RCR
AMD64Shift'ROL
AMD64Shift'ROR
AMD64Shift'SAR
AMD64Shift'SHL
AMD64Shift'SHR
AMD64ShiftOp'new-5
AMD64SignExtendOp'new-3
AMD64StackMove'new-4
AMD64SwitchClosure'new-3
AMD64TailcallOp'new-2
Abs'new-0
AbstractAddress'new-0
AbstractBeginNode''getBlockNodes-1
AbstractBeginNode''guards-1
AbstractBeginNode''prepareDelete-1
AbstractBeginNode'new-0
AbstractBeginNode'new-1
AbstractBeginNode'prevBegin-1
AbstractCompareAndSwapNode''getNewValue-1
AbstractCompareAndSwapNode'new-6
AbstractDeoptimizeNode'new-1
AbstractEndNode'new-0
AbstractFixedGuardNode''lowerToIf-1
AbstractFixedGuardNode'new-5
AbstractInlineInfo'inline-4
AbstractInlineInfo'new-1
AbstractLocalNode''index-1
AbstractLocalNode'new-2
AbstractMemoryCheckpoint'new-1
AbstractMemoryCheckpoint'new-2
AbstractMergeNode''addForwardEnd-2
AbstractMergeNode''forwardEndAt-2
AbstractMergeNode''forwardEndCount-1
AbstractMergeNode''forwardEndIndex-2
AbstractMergeNode''isPhiAtMerge-2
AbstractMergeNode''memoryPhis-1
AbstractMergeNode''phis-1
AbstractMergeNode''removeEnd-2
AbstractMergeNode''valuePhis-1
AbstractMergeNode'new-0
AbstractMoveOp'new-1
AbstractNewObjectNode'new-1
AbstractObjectStamp''isExactType-1
AbstractObjectStamp'isConcreteType-1
AbstractObjectStamp'new-4
AbstractPointerStamp''asAlwaysNull-1
AbstractPointerStamp''asMaybeNull-1
AbstractPointerStamp''asNonNull-1
AbstractPointerStamp''defaultPointerJoin-2
AbstractPointerStamp'new-2
AbstractStateSplit'new-2
AbstractTemplates'new-0
AbstractTemplates'snippet-3*
AbstractWriteNode'new-4
AccessArrayNode'new-2
AccessFieldNode''isStatic-1
AccessFieldNode''isVolatile-1
AccessFieldNode'new-3
AccessIndexedNode''index-1
AccessIndexedNode'new-4
AccessMonitorNode'new-2
AcquiredCASLockNode'new-1
Add'new-2
AddNode'create-2
AddNode'new-2
AddressLowering''improve-5
AddressLowering''improveUncompression-4
AddressLowering''lower-3
AddressLowering'new-1
AddressLowering'postProcess-1
AddressLowering'preProcess-1
AddressLowering'updateDisplacement-3
AddressLoweringPhase'new-1
AddressNode'new-0
AllocatableRegisters'new-3
AllocatedObjectNode''setCommit-2
AllocatedObjectNode'new-1
Allocator''allocate-1
Allocator'new-2
And'new-2
AndNode'create-2
AndNode'new-2
Arguments'new-4*
ArithmeticOp'new-1
ArithmeticOpTable'EMPTY
ArithmeticOpTable'forStamp-1
ArithmeticOpTable'new-19
ArithmeticStamp'new-1
ArrayLengthNode'create-1
ArrayLengthNode'new-1
ArrayLengthNode'readArrayLength-1
ArrayPlaceholder'new-2
Assembler''addl-3ai
Assembler''addl-3ri
Assembler''addl-3rr
Assembler''addq-3ai
Assembler''addq-3ar
Assembler''addq-3ri
Assembler''addq-3rr
Assembler''align-2
Assembler''andl-3ri
Assembler''andl-3rr
Assembler''andq-3
Assembler''asAddress-2
Assembler''asLongConstRef-2
Assembler''assemble-1
Assembler''bind-2
Assembler''bsfq-3
Assembler''bsrl-3
Assembler''bsrq-3
Assembler''bswapl-2
Assembler''bswapq-2
Assembler''btrq-3
Assembler''call-1
Assembler''call-2
Assembler''cdql-1
Assembler''cdqq-1
Assembler''close-2
Assembler''cmovl-4ra
Assembler''cmovl-4rr
Assembler''cmovq-4ra
Assembler''cmovq-4rr
Assembler''cmpl-3ai
Assembler''cmpl-3ra
Assembler''cmpl-3ri
Assembler''cmpl-3rr
Assembler''cmpptr-3ra
Assembler''cmpptr-3rr
Assembler''cmpq-3ra
Assembler''cmpq-3ri
Assembler''cmpq-3rr
Assembler''cmpxchgl-3
Assembler''cmpxchgq-3
Assembler''decl-2a
Assembler''decl-2r
Assembler''decq-2a
Assembler''decq-2r
Assembler''decrementl-2
Assembler''decrementl-3a
Assembler''decrementl-3r
Assembler''decrementq-3a
Assembler''decrementq-3r
Assembler''emitByte-2
Assembler''emitByte-3
Assembler''emitInt-2
Assembler''emitInt-3
Assembler''emitLong-2
Assembler''emitLong-3
Assembler''emitModRM-3ir
Assembler''emitModRM-3rr
Assembler''emitOperandHelper-4i
Assembler''emitOperandHelper-4r
Assembler''emitOperandHelper-5i
Assembler''emitOperandHelper-5r
Assembler''emitShort-2
Assembler''emitShort-3
Assembler''ensureUniquePC-1
Assembler''finish-1
Assembler''getByte-2
Assembler''getInt-2
Assembler''getShort-2
Assembler''hlt-1
Assembler''illegal-1
Assembler''imull-4
Assembler''imulq-3
Assembler''incl-2a
Assembler''incl-2r
Assembler''incq-2a
Assembler''incq-2r
Assembler''incrementl-3a
Assembler''incrementl-3r
Assembler''incrementq-3a
Assembler''incrementq-3r
Assembler''isSuccessorEdge-2
Assembler''jcc-3
Assembler''jcc-4
Assembler''jccb-3
Assembler''jmp-2a
Assembler''jmp-2l
Assembler''jmp-2r
Assembler''jmp-3
Assembler''jmpb-2
Assembler''lead-3
Assembler''leaq-3
Assembler''leave-1
Assembler''lfence-1
Assembler''lock-1
Assembler''membar-2
Assembler''movb-3ai
Assembler''movb-3ar
Assembler''movl-3ai
Assembler''movl-3ar
Assembler''movl-3ra
Assembler''movl-3ri
Assembler''movl-3rr
Assembler''movl-4
Assembler''movlong-3
Assembler''movptr-3ai
Assembler''movptr-3ar
Assembler''movptr-3ra
Assembler''movq-3ar
Assembler''movq-3ra
Assembler''movq-3rl
Assembler''movq-3rr
Assembler''movq-4
Assembler''movsbl-3ra
Assembler''movsbl-3rr
Assembler''movsbq-3ra
Assembler''movsbq-3rr
Assembler''movslq-3ai
Assembler''movslq-3ra
Assembler''movslq-3ri
Assembler''movslq-3rr
Assembler''movswl-3
Assembler''movw-3ai
Assembler''movw-3ar
Assembler''movzbl-3ra
Assembler''movzbl-3rr
Assembler''movzbq-3
Assembler''movzwl-3
Assembler''negl-2
Assembler''negq-2
Assembler''nop-1
Assembler''nop-2
Assembler''notl-2
Assembler''notq-2
Assembler''nullCheck-2
Assembler''orl-3ri
Assembler''orl-3rr
Assembler''orq-3
Assembler''patchJumpTarget-3
Assembler''pop-2
Assembler''position-1
Assembler''prefetchnta-2
Assembler''prefetchr-2
Assembler''prefetcht0-2
Assembler''prefetcht1-2
Assembler''prefetcht2-2
Assembler''prefetchw-2
Assembler''push-2
Assembler''rdtsc-1
Assembler''recordDataReferenceInCode-3a
Assembler''recordDataReferenceInCode-3c
Assembler''recordDataReferenceInCode-3d
Assembler''recordDataSectionReference-2
Assembler''recordInlineDataInCode-2
Assembler''recordMark-2
Assembler''ret-2
Assembler''sarl-3
Assembler''sbbq-3
Assembler''setb-3
Assembler''setl-3
Assembler''setq-3
Assembler''shll-2
Assembler''shll-3
Assembler''shlq-2
Assembler''shlq-3
Assembler''shrl-2
Assembler''shrl-3
Assembler''shrq-2
Assembler''shrq-3
Assembler''subl-3ai
Assembler''subl-3ri
Assembler''subl-3rr
Assembler''subq-3ai
Assembler''subq-3ri
Assembler''subq-3rr
Assembler''subqWide-3
Assembler''testl-3ra
Assembler''testl-3ri
Assembler''testl-3rr
Assembler''testq-3
Assembler''xaddl-3
Assembler''xaddq-3
Assembler''xchgl-3
Assembler''xchgq-3
Assembler''xorl-3
Assembler'createPlaceholder-1
Assembler'getRXB-2ra
Assembler'getRXB-2rr
Assembler'new-1
AtomicReadAndAddNode'new-3
AtomicReadAndAddOp'new-4
AtomicReadAndWriteNode'new-5
AtomicReadAndWriteOp'new-4
BarrierType'IMPRECISE
BarrierType'NONE
BarrierType'PRECISE
BaseSwitchClosure'new-3
BasicInductionVariable'new-5
BciBlock''addSuccessor-2
BciBlock''clearSucccessors-1
BciBlock''endsWithRet-1
BciBlock''getJsrAlternatives-1
BciBlock''getJsrReturnBci-1
BciBlock''getJsrScope-1
BciBlock''getJsrSuccessor-1
BciBlock''getRetSuccessor-1
BciBlock''getSuccessor-2
BciBlock''initJsrAlternatives-1
BciBlock''setEndsWithRet-1
BciBlock''setId-2
BciBlock''setJsrReturnBci-2
BciBlock''setJsrScope-2
BciBlock''setJsrSuccessor-2
BciBlock''setRetSuccessor-2
BciBlock'copy-1
BciBlock'new-1
BciBlockMapping''build-2
BciBlockMapping'create-2
BeginLockScopeNode'new-1
BeginLockScopeNode'new-2
BeginNode'begin-1
BeginNode'new-0
BeginNode'new-1
BeginStateSplitNode'new-0
BeginStateSplitNode'new-1
BelowOp'new-0
BinaryArithmetic''getMIOpcode-3
BinaryArithmetic''getMROpcode-2
BinaryArithmetic''getRMOpcode-2
BinaryArithmetic'ADC
BinaryArithmetic'ADD
BinaryArithmetic'AND
BinaryArithmetic'CMP
BinaryArithmetic'OR
BinaryArithmetic'SBB
BinaryArithmetic'SUB
BinaryArithmetic'XOR
BinaryArithmeticNode''getOp-3
BinaryArithmeticNode''shouldSwapInputs-2
BinaryArithmeticNode'add-2
BinaryArithmeticNode'add-3
BinaryArithmeticNode'mul-2
BinaryArithmeticNode'mul-3
BinaryArithmeticNode'new-3
BinaryArithmeticNode'reassociate-4
BinaryArithmeticNode'sub-2
BinaryArithmeticNode'sub-3
BinaryArithmeticNode'tryConstantFold-4
BinaryNode'new-3
BinaryOp''isAssociative-1
BinaryOp''isCommutative-1
BinaryOp'new-3
BinaryOpLogicNode'new-2
BinaryStrategy'new-2
BindToRegisterNode'new-1
BindToRegisterOp'new-1
BitCountNode'computeStamp-2
BitCountNode'new-1
BitMap2D''at-3
BitMap2D''clearBit-3
BitMap2D''setBit-3
BitMap2D'new-2
BlackholeNode'new-1
BlackholeOp'new-1
Block''canKill-2
Block''canKillBetweenThisAndDominator-2
Block''delete-1
Block''getDominator-2
Block''getFirstPredecessor-1
Block''getFirstSuccessor-1
Block''getKillLocations-1
Block''getLoopDepth-1
Block''getLoopExit-1
Block''getNodes-1
Block''isLoopEnd-1
Block''isLoopHeader-1
Block''setAlign-2
Block''setDominatedSibling-2
Block''setDominator-2
Block''setDominatorNumber-2
Block''setFirstDominated-2
Block''setId-2
Block''setLinearScanNumber-2
Block''setLoop-2
Block''setMaxChildDomNumber-2
Block''setPostDominator-2
Block''setPredecessors-2
Block''setProbability-2
Block''setSuccessors-2
Block'EMPTY_ARRAY
Block'new-1
BlockClosure''addRegisterHint-6
BlockClosure''processInstructionBottomUp-2
BlockClosure'new-2
BlockData'new-0
BlockLoopInfo'new-2
BlockMap''get-2
BlockMap''put-3
BlockMap'new-1
BlockOrderComparator'new-0
BlockScope''doBlockStart-1
BlockScope'new-2
BlockStates'new-1
BoxNode''createVirtualBoxingNode-1
BoxNode'new-3
BoxingSnippets'canonicalizeBoxing-1
BoxingTemplates''lower-3b
BoxingTemplates''lower-3u
BoxingTemplates'new-0
BranchOp''jcc-4
BranchOp'new-4
BranchOp'new-4c
BranchOp'new-4f
BytecodeLookupSwitch'new-2
BytecodeParser''add-2
BytecodeParser''addPush-3
BytecodeParser''append-2
BytecodeParser''appendConstant-2
BytecodeParser''appendInvoke-4
BytecodeParser''bci-1
BytecodeParser''build-3
BytecodeParser''buildRootMethod-1
BytecodeParser''cleanupFinalGraph-1
BytecodeParser''createInvoke-4
BytecodeParser''createNonInlinedInvoke-7
BytecodeParser''emitCheckForInvokeSuperSpecial-2
BytecodeParser''genGoto-1
BytecodeParser''genIf-4
BytecodeParser''genIf-5
BytecodeParser''genIntegerSwitch-6
BytecodeParser''genInvokeDynamic-2
BytecodeParser''genInvokeDynamic-3
BytecodeParser''genInvokeInterface-2
BytecodeParser''genInvokeInterface-3
BytecodeParser''genInvokeSpecial-2
BytecodeParser''genInvokeSpecial-3
BytecodeParser''genInvokeStatic-2
BytecodeParser''genInvokeStatic-3
BytecodeParser''genInvokeVirtual-2
BytecodeParser''genInvokeVirtual-3
BytecodeParser''genJsr-2
BytecodeParser''genLoadField-3
BytecodeParser''genMonitorEnter-3
BytecodeParser''genMonitorExit-4
BytecodeParser''genRet-2
BytecodeParser''genReturn-3
BytecodeParser''genStoreField-4
BytecodeParser''genStoreIndexed-5
BytecodeParser''genUnique-2l
BytecodeParser''genUnique-2v
BytecodeParser''getInvokeKind-1
BytecodeParser''getInvokeReturnStamp-1
BytecodeParser''getInvokeReturnType-1
BytecodeParser''getNonIntrinsicAncestor-1
BytecodeParser''handleUnresolvedCheckCast-3
BytecodeParser''handleUnresolvedInstanceOf-3
BytecodeParser''handleUnresolvedInvoke-3
BytecodeParser''handleUnresolvedLoadConstant-2
BytecodeParser''handleUnresolvedLoadField-3
BytecodeParser''handleUnresolvedNewInstance-2
BytecodeParser''handleUnresolvedNewObjectArray-3
BytecodeParser''handleUnresolvedStoreField-4
BytecodeParser''isNeverExecutedCode-2
BytecodeParser''iterateBytecodesForBlock-2
BytecodeParser''loadLocal-3
BytecodeParser''loadLocalObject-2
BytecodeParser'notifyAfterInline-1
BytecodeParser'notifyBeforeInline-1
BytecodeParser''nullCheckedValue-2
BytecodeParser''nullCheckedValue-3
BytecodeParser''parseAndInlineCallee-4
BytecodeParser''parsingIntrinsic-1
BytecodeParser''processBlock-2
BytecodeParser''processBytecode-3
BytecodeParser''push-3
BytecodeParser''setCurrentFrameState-2
BytecodeParser''setStateAfter-2
BytecodeParser''storeLocal-3
BytecodeParser'new-5
BytecodeStream''currentBC-1
BytecodeStream''endBCI-1
BytecodeStream''next-1
BytecodeStream''readBranchDest-1
BytecodeStream''readByte-1
BytecodeStream''readCPI-1
BytecodeStream''readCPI4-1
BytecodeStream''readIncrement-1
BytecodeStream''readInt-2
BytecodeStream''readLocalIndex-1
BytecodeStream''readShort-1
BytecodeStream''readUByte-2
BytecodeStream''setBCI-2
BytecodeStream'new-1
BytecodeSwitch''defaultOffset-1
BytecodeSwitch''defaultTarget-1
BytecodeSwitch''targetAt-2
BytecodeSwitch'new-2
BytecodeTableSwitch''highKey-1
BytecodeTableSwitch''lowKey-1
BytecodeTableSwitch'new-2
Bytecodes'AALOAD
Bytecodes'AASTORE
Bytecodes'ACONST_NULL
Bytecodes'ALOAD
Bytecodes'ALOAD_0
Bytecodes'ALOAD_1
Bytecodes'ALOAD_2
Bytecodes'ALOAD_3
Bytecodes'ANEWARRAY
Bytecodes'ARETURN
Bytecodes'ARRAYLENGTH
Bytecodes'ASTORE
Bytecodes'ASTORE_0
Bytecodes'ASTORE_1
Bytecodes'ASTORE_2
Bytecodes'ASTORE_3
Bytecodes'BALOAD
Bytecodes'BASTORE
Bytecodes'BIPUSH
Bytecodes'CALOAD
Bytecodes'CASTORE
Bytecodes'CHECKCAST
Bytecodes'DUP
Bytecodes'DUP2
Bytecodes'DUP2_X1
Bytecodes'DUP2_X2
Bytecodes'DUP_X1
Bytecodes'DUP_X2
Bytecodes'END
Bytecodes'GETFIELD
Bytecodes'GETSTATIC
Bytecodes'GOTO
Bytecodes'GOTO_W
Bytecodes'I2B
Bytecodes'I2C
Bytecodes'I2L
Bytecodes'I2S
Bytecodes'IADD
Bytecodes'IALOAD
Bytecodes'IAND
Bytecodes'IASTORE
Bytecodes'ICONST_0
Bytecodes'ICONST_1
Bytecodes'ICONST_2
Bytecodes'ICONST_3
Bytecodes'ICONST_4
Bytecodes'ICONST_5
Bytecodes'ICONST_M1
Bytecodes'IDIV
Bytecodes'IFEQ
Bytecodes'IFGE
Bytecodes'IFGT
Bytecodes'IFLE
Bytecodes'IFLT
Bytecodes'IFNE
Bytecodes'IFNONNULL
Bytecodes'IFNULL
Bytecodes'IF_ACMPEQ
Bytecodes'IF_ACMPNE
Bytecodes'IF_ICMPEQ
Bytecodes'IF_ICMPGE
Bytecodes'IF_ICMPGT
Bytecodes'IF_ICMPLE
Bytecodes'IF_ICMPLT
Bytecodes'IF_ICMPNE
Bytecodes'IINC
Bytecodes'ILOAD
Bytecodes'ILOAD_0
Bytecodes'ILOAD_1
Bytecodes'ILOAD_2
Bytecodes'ILOAD_3
Bytecodes'IMUL
Bytecodes'INEG
Bytecodes'INSTANCEOF
Bytecodes'INVOKEDYNAMIC
Bytecodes'INVOKEINTERFACE
Bytecodes'INVOKESPECIAL
Bytecodes'INVOKESTATIC
Bytecodes'INVOKEVIRTUAL
Bytecodes'IOR
Bytecodes'IREM
Bytecodes'IRETURN
Bytecodes'ISHL
Bytecodes'ISHR
Bytecodes'ISTORE
Bytecodes'ISTORE_0
Bytecodes'ISTORE_1
Bytecodes'ISTORE_2
Bytecodes'ISTORE_3
Bytecodes'ISUB
Bytecodes'IUSHR
Bytecodes'IXOR
Bytecodes'JSR
Bytecodes'JSR_W
Bytecodes'L2I
Bytecodes'LADD
Bytecodes'LALOAD
Bytecodes'LAND
Bytecodes'LASTORE
Bytecodes'LCMP
Bytecodes'LCONST_0
Bytecodes'LCONST_1
Bytecodes'LDC
Bytecodes'LDC2_W
Bytecodes'LDC_W
Bytecodes'LDIV
Bytecodes'LLOAD
Bytecodes'LLOAD_0
Bytecodes'LLOAD_1
Bytecodes'LLOAD_2
Bytecodes'LLOAD_3
Bytecodes'LMUL
Bytecodes'LNEG
Bytecodes'LOOKUPSWITCH
Bytecodes'LOR
Bytecodes'LREM
Bytecodes'LRETURN
Bytecodes'LSHL
Bytecodes'LSHR
Bytecodes'LSTORE
Bytecodes'LSTORE_0
Bytecodes'LSTORE_1
Bytecodes'LSTORE_2
Bytecodes'LSTORE_3
Bytecodes'LSUB
Bytecodes'LUSHR
Bytecodes'LXOR
Bytecodes'MONITORENTER
Bytecodes'MONITOREXIT
Bytecodes'NEW
Bytecodes'NEWARRAY
Bytecodes'NOP
Bytecodes'POP
Bytecodes'POP2
Bytecodes'PUTFIELD
Bytecodes'PUTSTATIC
Bytecodes'RET
Bytecodes'RETURN
Bytecodes'SALOAD
Bytecodes'SASTORE
Bytecodes'SIPUSH
Bytecodes'SWAP
Bytecodes'TABLESWITCH
Bytecodes'WIDE
Bytecodes'lengthOf-1
Bytes'beS1-2
Bytes'beS2-2
Bytes'beS4-2
Bytes'beU1-2
Bytes'beU2-2
CFOptimizer''deleteEmptyBlocks-2
CFOptimizer'new-1
CLOptimization''apply-1
CLOptimization'new-2
CRuntimeCallEpilogueOp'new-4
CRuntimeCallPrologueOp'new-2
CacheEntry'new-2
CallOp'new-3
CallTargetNode''setInvokeKind-2
CallTargetNode''setTargetMethod-2
CallTargetNode'new-4
CallsiteHolder''computeProbabilities-1
CallsiteHolder''invokeProbability-2
CallsiteHolder''invokeRelevance-2
CallsiteHolder''popInvoke-1
CallsiteHolder''pushInvoke-2
CallsiteHolder'new-4
CanonicalCondition'BT
CanonicalCondition'EQ
CanonicalCondition'LT
CanonicalizableLocation'foldIndirection-3
CanonicalizableLocation'new-1
CanonicalizerInstance''tryCanonicalize-3
CanonicalizerInstance'new-3
CanonicalizerPhase''applyIncremental-3i
CanonicalizerPhase''applyIncremental-3m
CanonicalizerPhase'new-0
ChainedNodeEventListener'new-2
ClassGetHubNode'canonical-4
ClassGetHubNode'create-2
ClassGetHubNode'intrinsify-3
ClassGetHubNode'new-1
ClassRef''resolve-2
ClassRef'new-1
Classfile''getCode-3
Classfile'new-3
Classfile'skipFully-2
ClassfileBytecode'new-3
ClassfileBytecodeProvider''findField-5
ClassfileBytecodeProvider''findMethod-5
ClassfileBytecodeProvider''resolveToClass-2
ClassfileBytecodeProvider'new-0
ClassfileConstant'CONSTANT_Class
ClassfileConstant'CONSTANT_Double
ClassfileConstant'CONSTANT_Dynamic
ClassfileConstant'CONSTANT_Fieldref
ClassfileConstant'CONSTANT_Float
ClassfileConstant'CONSTANT_Integer
ClassfileConstant'CONSTANT_InterfaceMethodref
ClassfileConstant'CONSTANT_InvokeDynamic
ClassfileConstant'CONSTANT_Long
ClassfileConstant'CONSTANT_MethodHandle
ClassfileConstant'CONSTANT_MethodType
ClassfileConstant'CONSTANT_Methodref
ClassfileConstant'CONSTANT_NameAndType
ClassfileConstant'CONSTANT_String
ClassfileConstant'CONSTANT_Utf8
ClassfileConstant'new-1
ClassfileConstant'resolveField-5
ClassfileConstant'resolveMethod-5
ClassfileConstantPool''get-3
ClassfileConstantPool'new-2
CodeBuffer''close-2
CodeBuffer''emitByte-2
CodeBuffer''emitByte-3
CodeBuffer''emitInt-2
CodeBuffer''emitInt-3
CodeBuffer''emitLong-2
CodeBuffer''emitLong-3
CodeBuffer''emitShort-2
CodeBuffer''emitShort-3
CodeBuffer''getByte-2
CodeBuffer''getInt-2
CodeBuffer''getShort-2
CodeBuffer''position-1
CodeBuffer'InitialSize
CodeBuffer'new-1
CollectVirtualObjectsClosure'new-4
CommitAllocationNode''addLocks-2
CommitAllocationNode''getLocks-2
CommitAllocationNode'new-0
CommutativeTwoOp'new-5
CompareAndSwapOp'new-5
CompareNode''isIdentityComparison-1
CompareNode'createCompareNode-3
CompareNode'createCompareNode-4g
CompareNode'createCompareNode-4i
CompareNode'createCompareNode-5
CompareNode'new-3
CompareNode'tryConstantFold-3
CompareNode'tryConstantFoldPrimitive-3
CompareOp'new-0
CompilationContext'INLINE_AFTER_PARSING
CompilationContext'INLINE_DURING_PARSING
CompilationContext'ROOT_COMPILATION
CompilationResult''close-1
CompilationResult''recordDataPatch-3
CompilationResult''recordMark-3
CompilationResult''setTargetCode-3
CompilationResult'new-1
Compiler'compileGraph-1
Compiler'compileMethod-1
Compiler'createCompiledCode-1
Compiler'createInstalledCode-4
Compiler'emitBackEnd-2
Compiler'emitFrontEnd-3
Compiler'emitLIR-2
Compiler'emitLowLevel-3
Compiler'emitStackOverflowCheck-1
CompositeValue'new-1
CompressEncoding''hasBase-1
CompressEncoding''hasShift-1
CompressEncoding'new-2
CompressPointerOp'new-5
CompressionNode''getEncoding-1
CompressionNode'new-4
CompressionOp'Compress
CompressionOp'Uncompress
ComputeBlockOrder'computeCodeEmittingOrder-1
ComputeBlockOrder'computeLinearScanOrder-1
ComputeInliningRelevance''compute-1
ComputeInliningRelevance''getRelevance-2
ComputeInliningRelevance'new-2
ComputeLoopFrequenciesClosure'PHASE_INSTANCE
ComputeLoopFrequenciesClosure'compute-1
ComputeLoopFrequencyPhase'new-0
ComputeObjectAddressNode'new-2
CondMoveOp'new-4
CondSetOp'new-2
Condition''canonicalize-1
Condition''foldCondition-3c
Condition''foldCondition-3p
Condition''implies-2
Condition''isCanonical-1
Condition''isCommutative-1
Condition''isUnsigned-1
Condition''join-2
Condition''meet-2
Condition''mirror-1
Condition''negate-1
Condition'AE
Condition'AT
Condition'BE
Condition'BT
Condition'EQ
Condition'GE
Condition'GT
Condition'LE
Condition'LT
Condition'NE
ConditionAnchorNode'new-1
ConditionAnchorNode'new-2
ConditionFlag''negate-1
ConditionFlag'Above
ConditionFlag'AboveEqual
ConditionFlag'Below
ConditionFlag'BelowEqual
ConditionFlag'CarryClear
ConditionFlag'CarrySet
ConditionFlag'Equal
ConditionFlag'Greater
ConditionFlag'GreaterEqual
ConditionFlag'Less
ConditionFlag'LessEqual
ConditionFlag'Negative
ConditionFlag'NoOverflow
ConditionFlag'NoParity
ConditionFlag'NotEqual
ConditionFlag'NotZero
ConditionFlag'Overflow
ConditionFlag'Parity
ConditionFlag'Positive
ConditionFlag'Zero
ConditionalEliminationInstance'new-3
ConditionalEliminationPhase'new-1
ConditionalNode'canonicalizeConditional-4
ConditionalNode'create-1
ConditionalNode'create-3
ConditionalNode'new-1
ConditionalNode'new-3
ConditionalNode'new-4
ConstOp'new-5a
ConstOp'new-5b
ConstantFields'isFinalField-1
ConstantFields'isFinalFieldValueConstant-3
ConstantFields'isStableField-1
ConstantFields'isStableFieldValueConstant-3
ConstantFields'isStaticFieldConstant-1
ConstantFields'readConstantField-2
ConstantFields'tryConstantFold-2
ConstantLoadOptimization'new-0
ConstantNode'defaultForKind-1
ConstantNode'defaultForKind-2
ConstantNode'forBoolean-1
ConstantNode'forBoolean-2
ConstantNode'forByte-2
ConstantNode'forChar-2
ConstantNode'forConstant-1
ConstantNode'forConstant-2c
ConstantNode'forConstant-2s
ConstantNode'forConstant-3c
ConstantNode'forConstant-3s
ConstantNode'forConstant-4
ConstantNode'forInt-1
ConstantNode'forInt-2
ConstantNode'forIntegerBits-2l
ConstantNode'forIntegerBits-3l
ConstantNode'forIntegerKind-2
ConstantNode'forIntegerKind-3
ConstantNode'forIntegerStamp-2
ConstantNode'forIntegerStamp-3
ConstantNode'forLong-1
ConstantNode'forLong-2
ConstantNode'forPrimitive-1
ConstantNode'forPrimitive-2c
ConstantNode'forPrimitive-2s
ConstantNode'forPrimitive-3
ConstantNode'forShort-2
ConstantNode'new-2
ConstantTree''getOrInitCost-2
ConstantTree''getUsages-2
ConstantTree''isLeafBlock-2
ConstantTree''isMarked-2
ConstantTree''markBlocks-1
ConstantTree''traverseTreeWhileTrue-3
ConstantTree'new-2
ConstantTreeAnalyzer'analyze-2
ConstantValue'new-2
ConsumerConstOp'new-4
ConsumerConstOp'new-4a
ConsumerConstOp'new-4b
ConsumerOp'new-4
ControlFlowAnchorNode'new-0
ControlFlowGraph''blockFor-2
ControlFlowGraph''computePostdominators-1
ControlFlowGraph''getStartBlock-1
ControlFlowGraph''setNodeToBlock-2
ControlFlowGraph''visitDominatorTree-3
ControlFlowGraph''visitDominatorTreeDefault-2
ControlFlowGraph''visitDominatorTreeDeferLoopExits-2
ControlFlowGraph'BLOCK_ID_INITIAL
ControlFlowGraph'BLOCK_ID_VISITED
ControlFlowGraph'MAX_PROBABILITY
ControlFlowGraph'MIN_PROBABILITY
ControlFlowGraph'commonDominator-2
ControlFlowGraph'compute-5
ControlFlowGraph'dominates-2
ControlFlowGraph'isDominatedBy-2
ControlFlowGraph'isDominatorTreeLoopExit-1
ControlFlowGraph'multiplyProbabilities-2
ControlFlowGraph'strictlyDominates-2
ControlFlowOptimizer'new-0
ControlSinkNode'new-1
ControlSplitNode'new-1
ConvertDeoptimizeToGuardPhase'new-0
CountLeadingZerosNode'new-1
CountLeadingZerosNode'tryFold-1
CountTrailingZerosNode'computeStamp-2
CountTrailingZerosNode'new-1
CountTrailingZerosNode'tryFold-1
CountedLoopInfo''constantExactTripCount-1
CountedLoopInfo''constantMaxTripCount-1
CountedLoopInfo''createOverFlowGuard-1
CountedLoopInfo''exactTripCountNode-1
CountedLoopInfo''getOverFlowGuard-1
CountedLoopInfo''getStamp-1
CountedLoopInfo''getStart-1
CountedLoopInfo''isConstantExactTripCount-1
CountedLoopInfo''isConstantMaxTripCount-1
CountedLoopInfo''isExactTripCount-1
CountedLoopInfo''maxTripCountNode-1
CountedLoopInfo''maxTripCountNode-2
CountedLoopInfo'new-6
CurrentInvoke'new-3
CurrentLockNode'new-1
Data''updateAlignment-2
Data'new-2
DataBuilder'createDataItem-1
DataOp'new-4
DataOp'new-5
DataSection''buildDataSection-3
DataSection''close-1
DataSection''getSectionAlignment-1
DataSection''getSectionSize-1
DataSection''insertData-2
DataSection'lcm-2
DataSection'new-0
DataTwoOp'new-5
DataTwoOp'new-6
DeadCodeEliminationPhase'new-0
DeadCodeEliminationPhase'new-1
DefUseTree''addUsage-4
DefUseTree''getConstant-1
DefUseTree''getVariable-1
DefUseTree''usageCount-1
DefUseTree'new-2
DefaultLoopPolicies'new-0
DefaultSimplifierTool'new-0
DeferredExit'new-2
DeoptimizationGroupingPhase'new-0
DeoptimizeCallerNode'new-2
DeoptimizeCallerOp'new-0
DeoptimizeNode'DEFAULT_DEBUG_ID
DeoptimizeNode'new-2
DeoptimizeNode'new-3
DeoptimizeNode'new-5
DeoptimizingFixedWithNextNode'new-1
DerivedConvertedInductionVariable'new-4
DerivedInductionVariable''getBase-1
DerivedInductionVariable'new-2
DerivedOffsetInductionVariable'new-4
DerivedScaledInductionVariable'new-3
DerivedScaledInductionVariable'new-4
DirectCallOp''emitCall-2
DirectCallOp'new-4
DirectCallTargetNode'new-6
DirectFarForeignCallOp'new-4
DirectNearForeignCallOp'new-4
DirectStaticCallOp'new-5
DirectVirtualCallOp'new-5
Direction''opposite-1
Div'new-2
DivRemOp'DIV
DivRemOp'REM
DominatorOptimizationProblem''get-3
DominatorOptimizationProblem''getCost-2
DominatorOptimizationProblem''set-3
DominatorOptimizationProblem''setCost-3
DominatorOptimizationProblem''setDominatorPath-3
DominatorOptimizationProblem'new-2
DummyGuardHandle'new-1
DynamicDeoptimizeNode'new-2
EMOptimizer''optimizeMovesAtBlockBegin-2
EMOptimizer''optimizeMovesAtBlockEnd-2
EMOptimizer'new-1
EarlyReadEliminationPhase'new-1
EdgeInfo'new-4
EdgeMoveOptimizer'new-0
Edges''copy-3
Edges''getPositions-2
Edges''initializeList-4
Edges''initializeLists-3
Edges''initializeNode-4
Edges''setNode-4
Edges'getNode-3
Edges'getNodeList-3
Edges'getNodeListUnsafe-2
Edges'getNodeUnsafe-2
Edges'new-3
Edges'putNodeListUnsafe-3
Edges'putNodeUnsafe-3
Edges'translateInto-2
EdgesType'Inputs
EdgesType'Successors
EffectList''add-3
EffectList''addAll-2
EffectList''apply-4
EffectList''insertAll-3
EffectList''isEmpty-1
EffectList''size-1
EffectList'new-0
EffectsBlockState''isDead-1
EffectsBlockState''markAsDead-1
EffectsBlockState'copy-1
EffectsBlockState'isSubMapOf-2
EffectsBlockState'new-0
EffectsClosure''addScalarAlias-3
EffectsClosure''getScalarAlias-2
EffectsClosure''hasScalarReplacedInputs-2
EffectsClosure'new-2
EffectsPhase''postIteration-3
EffectsPhase''runAnalysis-2
EffectsPhase'new-2
EffectsPhase'new-3
EffortClosure''getAverageEffort-1
EffortClosure'new-2
EndLockScopeNode'new-0
EndNode'new-0
EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2
EpilogueBlockEndOp'new-0
EscapeObjectState'new-1
ExactInlineInfo'new-2
ExecutableRef''resolve-3
ExecutableRef'new-2
ExpandLogicPhase'new-0
ExplodeLoopNode''findLoopBegin-1
ExplodeLoopNode'new-0
FastAcquireBiasedLockNode'new-1
FieldInfo'new-4
FieldKey'new-2
FieldLocationIdentity'new-1
FieldRef''resolve-3
FieldRef'new-1
Fields''copy-3
Fields''getBoolean-3
Fields''getByte-3
Fields''getChar-3
Fields''getDeclaringClass-2
Fields''getInt-3
Fields''getLong-3
Fields''getName-2
Fields''getObject-3
Fields''getShort-3
Fields''getType-2
Fields''isSame-3
Fields''putObject-4
Fields'new-1
Fields'translateInto-2
FieldsCache''lookup-5
FieldsCache'new-0
FieldsScanner''scan-3
FieldsScanner'new-0
FinalClosure'new-1
FinalFieldBarrierNode'new-1
FinalState'copy-1
FinalState'new-0
FixPointIntervalBuilder''build-1
FixPointIntervalBuilder''getOrCreateInterval-2
FixPointIntervalBuilder'new-3
FixReadsClosure'new-0
FixReadsPhase'new-1
FixedAccessNode''setNullCheck-2
FixedAccessNode'new-4
FixedBinaryNode'new-3
FixedGuardNode'new-3
FixedGuardNode'new-4
FixedGuardNode'new-5
FixedNode'new-1
FixedNodeProbabilityCache''applyAsDouble-2
FixedNodeProbabilityCache'new-0
FixedTarget'new-2
FixedValueAnchorNode'new-1
FixedWithNextNode''setNext-2
FixedWithNextNode'new-1
Flags'CANDIDATE
Flags'HAS_USAGE
Flags'IN_SUBTREE
Flags'MATERIALIZE
FloatableAccessNode''canFloat-1
FloatableAccessNode''setForceFixed-2
FloatableAccessNode'new-4
FloatingAccessNode'new-5
FloatingAnchoredNode''getAnchor-1
FloatingAnchoredNode'new-2
FloatingGuardedNode'new-2
FloatingNode'new-1
FloatingReadClosure'new-3
FloatingReadNode'new-4
FloatingReadNode'new-5
FloatingReadNode'new-6
FloatingReadPhase'mergeMemoryMaps-2
FloatingReadPhase'new-0
FloatingReadPhase'new-2
ForeignCallDescriptor'DEOPTIMIZATION_HANDLER
ForeignCallDescriptor'G1WBPOSTCALL
ForeignCallDescriptor'G1WBPRECALL
ForeignCallDescriptor'MONITORENTER
ForeignCallDescriptor'MONITOREXIT
ForeignCallDescriptor'NEW_ARRAY
ForeignCallDescriptor'NEW_INSTANCE
ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER
ForeignCallDescriptor'new-2*
ForeignCallLinkage''destroysRegisters-1
ForeignCallLinkage''getMaxCallTargetOffset-1
ForeignCallLinkage''isGuaranteedSafepoint-1
ForeignCallLinkage''needsJavaFrameAnchor-1
ForeignCallLinkage'create-8*
ForeignCallLinkage'createCallingConvention-2
ForeignCallLinkage'new-8*
ForeignCallOp'new-4
ForeignCalls''getKilledLocations-2
ForeignCalls''isGuaranteedSafepoint-2
ForeignCalls''isReexecutable-2
ForeignCalls''lookupForeignCall-2
ForeignCalls'nativeABICallerSaveRegisters
ForeignCalls'new-0
FrameContext''enter-2
FrameContext''leave-2
FrameContext'PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE
FrameContext'new-1
FrameMap''allocateNewSpillSlot-3
FrameMap''allocateRBPSpillSlot-1
FrameMap''allocateSpillSlot-2
FrameMap''allocateStackSlots-3
FrameMap''callsMethod-2
FrameMap''currentFrameSize-1
FrameMap''finish-1
FrameMap''frameNeedsAllocating-1
FrameMap''freeRBPSpillSlot-1
FrameMap''offsetForStackSlot-2
FrameMap''reserveOutgoing-2
FrameMap'RETURN_ADDRESS_SIZE
FrameMap'spillSlotSize-1
FrameMap''totalFrameSize-1
FrameMap'new-0
FrameMapBuilder''allocateSpillSlot-2
FrameMapBuilder''buildFrameMap-2
FrameMapBuilder''callsMethod-2
FrameMapBuilder''allocateRBPSpillSlot-1
FrameMapBuilder''freeRBPSpillSlot-1
FrameMapBuilder'new-0
FrameState''addVirtualObjectMapping-2
FrameState''duplicate-1
FrameState''duplicate-2
FrameState''duplicateModified-4
FrameState''duplicateModified-7
FrameState''duplicateModifiedBeforeCall-5
FrameState''duplicateModifiedDuringCall-3
FrameState''getMethod-1
FrameState''localAt-2
FrameState''lockAt-2
FrameState''locksSize-1
FrameState''monitorIdAt-2
FrameState''nestedLockDepth-1
FrameState''setOuterFrameState-2
FrameState''stackAt-2
FrameState''virtualObjectMappingAt-2
FrameState''virtualObjectMappingCount-1
FrameState'TWO_SLOT_MARKER
FrameState'new-1
FrameState'new-2
FrameState'new-9a
FrameState'new-9i
FrameState'new-9l
FrameStateAssignmentClosure'new-0
FrameStateAssignmentPhase'new-0
FrameStateBuilder''clearNonLiveLocals-4
FrameStateBuilder''clearStack-1
FrameStateBuilder''contains-2
FrameStateBuilder''create-3
FrameStateBuilder''create-6
FrameStateBuilder''getMethod-1
FrameStateBuilder''inferPhiStamps-2
FrameStateBuilder''initializeForMethodStart-1
FrameStateBuilder''initializeFromArgumentsArray-2
FrameStateBuilder''insertLoopPhis-6
FrameStateBuilder''insertLoopProxies-3
FrameStateBuilder''isCompatibleWith-2
FrameStateBuilder''loadLocal-3
FrameStateBuilder''lockDepth-2
FrameStateBuilder''merge-3
FrameStateBuilder''peekMonitorId-1
FrameStateBuilder''pop-2
FrameStateBuilder''popArguments-2
FrameStateBuilder''popLock-1
FrameStateBuilder''push-3
FrameStateBuilder''pushLock-3
FrameStateBuilder''pushReturn-3
FrameStateBuilder''stackOp-2
FrameStateBuilder''storeLocal-4
FrameStateBuilder'copy-1
FrameStateBuilder'new-3c
FrameStateBuilder'new-3m
G1PostWriteBarrier'new-4
G1PreWriteBarrier'new-4
G1ReferentFieldReadBarrier''getExpectedObject-1
G1ReferentFieldReadBarrier'new-3
GetClassNode'new-2
GetClassNode'tryFold-1
GetObjectAddressNode'new-1
GraalOptions'canOmitFrame
GraalOptions'conditionalElimination
GraalOptions'escapeAnalysisIterations
GraalOptions'escapeAnalysisLoopCutoff
GraalOptions'exactFullUnrollMaxNodes
GraalOptions'exactPartialUnrollMaxNodes
GraalOptions'fullUnroll
GraalOptions'fullUnrollMaxIterations
GraalOptions'fullUnrollMaxNodes
GraalOptions'genLoopSafepoints
GraalOptions'guardPriorities
GraalOptions'inline
GraalOptions'inlineDuringParsing
GraalOptions'inlineDuringParsingMaxDepth
GraalOptions'inlineEverything
GraalOptions'inlinePartialIntrinsicExitDuringParsing
GraalOptions'limitInlinedInvokes
GraalOptions'lirOptLSRAEliminateSpillMoves
GraalOptions'lirOptLSRAOptimizeSpillPosition
GraalOptions'lirOptimization
GraalOptions'loopMaxUnswitch
GraalOptions'loopPeeling
GraalOptions'loopUnswitch
GraalOptions'loopUnswitchFrequencyBoost
GraalOptions'loopUnswitchMaxIncrease
GraalOptions'loopUnswitchTrivial
GraalOptions'lsraOptSplitOnly
GraalOptions'lsraOptimization
GraalOptions'maximumDesiredSize
GraalOptions'maximumEscapeAnalysisArrayLength
GraalOptions'maximumInliningSize
GraalOptions'maximumRecursiveInlining
GraalOptions'methodInlineBailoutLimit
GraalOptions'minimumPeelProbability
GraalOptions'mitigateSpeculativeExecutionAttacks
GraalOptions'optClearNonLiveLocals
GraalOptions'optConvertDeoptsToGuards
GraalOptions'optDeoptimizationGrouping
GraalOptions'optDevirtualizeInvokesOptimistically
GraalOptions'optEarlyReadElimination
GraalOptions'optEliminateGuards
GraalOptions'optFloatingReads
GraalOptions'optImplicitNullChecks
GraalOptions'optLoopTransform
GraalOptions'optReadElimination
GraalOptions'optScheduleOutOfLoops
GraalOptions'partialEscapeAnalysis
GraalOptions'partialUnroll
GraalOptions'rawConditionalElimination
GraalOptions'readEliminationMaxLoopVisits
GraalOptions'reassociateInvariants
GraalOptions'reduceDCE
GraalOptions'removeNeverExecutedCode
GraalOptions'replaceInputsWithConstantsBasedOnStamps
GraalOptions'resolveClassBeforeStaticInvoke
GraalOptions'simpleFastInflatedLocking
GraalOptions'stressTestEarlyReads
GraalOptions'trivialInliningSize
GraalOptions'trustFinalDefaultFields
GraalOptions'unrollMaxIterations
GraalOptions'useLoopLimitChecks
GraalOptions'useTrappingNullChecks
GraalOptions'zapStackOnMethodEntry
Graph''add-2
Graph''addAfterFixed-3
Graph''addBeforeFixed-3
Graph''addDuplicates-5m
Graph''addDuplicates-5r
Graph''addOrUniqueWithInputs-2
Graph''freeze-1
Graph''getInvokes-1
Graph''getMark-1
Graph''getNodeCount-1
Graph''getNodes-1
Graph''getNodes-2
Graph''getNodesSince-2
Graph''getParameter-2
Graph''getReturnStamp-1
Graph''hasLoops-1
Graph''hasVirtualizableAllocation-1
Graph''isFrozen-1
Graph''maybeAddOrUnique-2
Graph''reduceDegenerateLoopBegin-2
Graph''reduceTrivialMerge-2
Graph''register-2
Graph''removeFixed-2
Graph''removeSplit-3
Graph''removeSplitPropagate-3
Graph''replaceFixed-3
Graph''replaceFixedWithFixed-3
Graph''replaceFixedWithFloating-3
Graph''replaceSplit-4
Graph''replaceSplitWithFixed-4
Graph''replaceSplitWithFloating-4
Graph''setAfterExpandLogic-1
Graph''setAfterFixReadPhase-2
Graph''setAfterFloatingReadPhase-2
Graph''setGuardsStage-2
Graph''setHasValueProxies-2
Graph''setLastSchedule-2
Graph''setStart-2
Graph''trackNodeEvents-2
Graph''unregister-2
Graph'copy-1
Graph'new-1
GraphBuilderInstance'new-2
GraphBuilderPhase'new-0
GraphEffectList''addFixedNodeBefore-3
GraphEffectList''addFloatingNode-3
GraphEffectList''addVirtualMapping-3
GraphEffectList''addVirtualizationDelta-2
GraphEffectList''deleteNode-2
GraphEffectList''initializePhiInput-4
GraphEffectList''killIfBranch-3
GraphEffectList''replaceAtUsages-4
GraphEffectList''replaceFirstInput-4
GraphEffectList''replaceWithSink-3
GraphEffectList'new-0
GraphUtil'arrayLength-1
GraphUtil'checkRedundantPhi-1
GraphUtil'checkRedundantProxy-1
GraphUtil'isFloatingNode-1
GraphUtil'killCFG-1
GraphUtil'killWithUnusedFloatingInputs-1
GraphUtil'killWithUnusedFloatingInputs-2
GraphUtil'normalizeLoops-1
GraphUtil'originalValue-1
GraphUtil'removeFixedWithUnusedInputs-1
GraphUtil'skipPi-1
GraphUtil'skipPiWhileNonNull-1
GraphUtil'tryKillUnused-1
GraphUtil'unlinkFixedNode-1
GraphUtil'unproxify-1n
GraphUtil'unproxify-1p
GuardLoweringPhase'new-0
GuardNode'new-6
GuardOrder'resortGuards-2
GuardPhiNode'new-1
GuardPriority'None
GuardPriority'Profile
GuardPriority'Speculation
GuardPriority'highest-0
GuardPriority'isHigherPriorityThan-2
GuardPriority'isLowerPriorityThan-2
GuardProxyNode'new-2
GuardsStage'AFTER_FSA
GuardsStage'FIXED_DEOPTS
GuardsStage'FLOATING_GUARDS
GuardsStage'allowsFloatingGuards-1
GuardsStage'areDeoptsFixed-1
GuardsStage'areFrameStatesAtDeopts-1
GuardsStage'areFrameStatesAtSideEffects-1
HashSetNodeEventListener''exclude-2
HashSetNodeEventListener'new-0
HashSetNodeEventListener'new-1
HeapBaseNode'new-1
HighTier'new-0
HotSpot'ageMaskInPlace
HotSpot'allocateInstancePrefetchLines
HotSpot'allocatePrefetchDistance
HotSpot'allocatePrefetchInstr
HotSpot'allocatePrefetchLines
HotSpot'allocatePrefetchStepSize
HotSpot'allocatePrefetchStyle
HotSpot'arrayBaseOffset-1
HotSpot'arrayClassElementOffset
HotSpot'arrayIndexScale-1
HotSpot'arrayLengthOffset
HotSpot'arrayOopDescSize
HotSpot'biasedLockMaskInPlace
HotSpot'biasedLockPattern
HotSpot'cardTableAddress
HotSpot'cardTableAddressMark
HotSpot'cardTableShift
HotSpot'classMirrorOffset
HotSpot'codeCache
HotSpot'codeCacheHighBound
HotSpot'codeCacheLowBound
HotSpot'codeEntryAlignment
HotSpot'config
HotSpot'constantReflection
HotSpot'defaultBytecodeProvider
HotSpot'deoptHandlerEntryMark
HotSpot'dirtyCardValue
HotSpot'epochMaskInPlace
HotSpot'foldStableValues
HotSpot'foreignCalls
HotSpot'g1CardQueueBufferOffset
HotSpot'g1CardQueueIndexOffset
HotSpot'g1SATBQueueBufferOffset
HotSpot'g1SATBQueueIndexOffset
HotSpot'g1SATBQueueMarkingOffset
HotSpot'g1YoungCardValue
HotSpot'graphBuilderSuite
HotSpot'handleDeoptStub
HotSpot'heapBaseRegister
HotSpot'heapWordSize
HotSpot'hubOffset
HotSpot'invokeinterfaceMark
HotSpot'invokespecialMark
HotSpot'invokestaticMark
HotSpot'invokevirtualMark
HotSpot'javaThreadAnchorOffset
HotSpot'javaThreadDirtyCardQueueOffset
HotSpot'javaThreadSatbMarkQueueOffset
HotSpot'klassEncoding
HotSpot'klassOffset
HotSpot'lockDisplacedMarkOffset
HotSpot'logOfHeapRegionGrainBytes
HotSpot'logOfHeapRegionGrainBytesMark
HotSpot'markOffset
HotSpot'metaAccess
HotSpot'metaspaceArrayBaseOffset
HotSpot'metaspaceArrayLengthOffset
HotSpot'monitorMask
HotSpot'monitorenterAddress
HotSpot'monitorexitAddress
HotSpot'narrowKlassBase
HotSpot'narrowKlassShift
HotSpot'narrowKlassSize
HotSpot'narrowOopBase
HotSpot'narrowOopShift
HotSpot'newArrayAddress
HotSpot'newInstanceAddress
HotSpot'nonOopBits
HotSpot'objectAlignment
HotSpot'objectMonitorCxqOffset
HotSpot'objectMonitorEntryListOffset
HotSpot'objectMonitorOwnerOffset
HotSpot'objectMonitorRecursionsOffset
HotSpot'objectResultOffset
HotSpot'oopEncoding
HotSpot'pendingDeoptimizationOffset
HotSpot'pendingExceptionOffset
HotSpot'pendingFailedSpeculationOffset
HotSpot'plugins
HotSpot'pollFarMark
HotSpot'pollNearMark
HotSpot'pollReturnFarMark
HotSpot'pollReturnNearMark
HotSpot'prototypeMarkWordOffset
HotSpot'registerConfig
HotSpot'replacements
HotSpot'safepointPollingAddress
HotSpot'secondarySuperCacheOffset
HotSpot'secondarySupersOffset
HotSpot'stackBias
HotSpot'stackPointerRegister
HotSpot'stackShadowPages
HotSpot'superCheckOffsetOffset
HotSpot'target
HotSpot'threadLastJavaFpOffset
HotSpot'threadLastJavaPcOffset
HotSpot'threadLastJavaSpOffset
HotSpot'threadLocalHandshakes
HotSpot'threadPollingPageOffset
HotSpot'threadRegister
HotSpot'threadTlabEndOffset
HotSpot'threadTlabOffset
HotSpot'threadTlabTopOffset
HotSpot'uncommonTrapStub
HotSpot'unlockedMask
HotSpot'unsafe
HotSpot'useBiasedLocking
HotSpot'useCompressedClassPointers
HotSpot'useCompressedOops
HotSpot'useDeferredInitBarriers
HotSpot'useFastLocking
HotSpot'useG1GC
HotSpot'useStackBanging
HotSpot'useTLAB
HotSpot'valueKindFactory
HotSpot'verifiedEntryMark
HotSpot'vmPageSize
HotSpot'writeBarrierPostAddress
HotSpot'writeBarrierPreAddress
HotSpotCompressionNode'compress-2
HotSpotCompressionNode'new-3
HotSpotCompressionNode'uncompress-2
HotSpotDirectCallTargetNode'new-6
HotSpotNarrowOopStamp'compressed-2
HotSpotNarrowOopStamp'mkStamp-3
HotSpotNodePlugin'new-1
HotSpotSwitchClosure'new-3
HubGetClassNode'new-1
IfNode''eliminateNegation-1
IfNode''getSuccessor-2
IfNode''setCondition-2
IfNode''setFalseSuccessor-2
IfNode''setTrueSuccessor-2
IfNode''setTrueSuccessorProbability-2
IfNode'new-4b
IfNode'new-4f
IllegalStamp'instance
IncrementalCanonicalizerPhase'new-1
IncrementalCanonicalizerPhase'new-2
InductionVariable'new-1
InfoElement'new-4
InlineDuringParsingPlugin'new-0
InlineInvokeInfo''allowsInlining-1
InlineInvokeInfo'createIntrinsicInlineInfo-1
InlineInvokeInfo'createStandardInlineInfo-1
InlineableGraph'new-4
InliningData''countRecursiveInlining-2
InliningData''hasUnprocessedGraphs-1
InliningData''inliningDepth-1
InliningData''moveForward-1
InliningData'isFreshInstantiation-1
InliningData'new-3
InliningIterator''apply-1
InliningIterator'new-1
InliningPhase'new-1
InliningPolicy'CapInheritedRelevance
InliningPolicy'RelevanceCapForInlining
InliningPolicy'continueInlining-1
InliningPolicy'isWorthInlining-3
InliningUtil'checkInvokeConditions-1
InliningUtil'inline-4
InliningUtil'inlineForCanonicalization-4
InliningUtil'nonNullReceiver-1
InliningUtil'processFrameState-8
InliningUtil'processFrameStates-4
InliningUtil'processMonitorId-2
InputEdges''getInputType-2
InputEdges''isOptional-2
InputEdges'new-2
InputEdges'translateInto-2
InputInfo'new-6
InputType'Anchor
InputType'Guard
InputType'Memory
InputType'Value
InstanceOfDynamicNode''isHub-1
InstanceOfDynamicNode''isMirror-1
InstanceOfDynamicNode''setMirror-2
InstanceOfDynamicNode'create-3
InstanceOfDynamicNode'create-4
InstanceOfDynamicNode'new-4
InstanceOfNode''allowsNull-1
InstanceOfNode''type-1
InstanceOfNode'create-2
InstanceOfNode'create-3
InstanceOfNode'createAllowNull-2
InstanceOfNode'createHelper-3
InstanceOfNode'findSynonym-2
InstanceOfNode'new-3
InstanceOfSnippetsTemplates''lower-3
InstanceOfSnippetsTemplates''makeArguments-3
InstanceOfSnippetsTemplates'new-0
InstanceOfTemplates'new-0
InstanceOfUsageReplacer'new-4
Instantiation''asCondition-2
Instantiation''asMaterialization-4
Instantiation''initialize-4
Instantiation''isInitialized-1
Instantiation'new-0
IntList''add-2
IntList''get-2
IntList''set-3
IntList''setSize-2
IntList'copy-3
IntList'copy-4
IntList'new-1
IntList'new-2
IntegerAddExactNode'new-2
IntegerAddExactSplitNode'new-5
IntegerBelowNode'create-2
IntegerBelowNode'create-3
IntegerBelowNode'new-2
IntegerConvertNode''getInputBits-1
IntegerConvertNode''getOp-2
IntegerConvertNode''getResultBits-1
IntegerConvertNode'convert-2
IntegerConvertNode'convert-3b
IntegerConvertNode'convert-3g
IntegerConvertNode'convertUnsigned-2
IntegerConvertNode'convertUnsigned-3
IntegerConvertNode'findSynonym-5
IntegerConvertNode'new-5
IntegerConvertOp'new-1
IntegerDivRemNode''getType-1
IntegerDivRemNode'new-5
IntegerEqualsNode'create-2
IntegerEqualsNode'create-3
IntegerEqualsNode'new-2
IntegerEqualsOp'new-0
IntegerExactArithmeticSplitNode''getNext-1
IntegerExactArithmeticSplitNode'lower-2
IntegerExactArithmeticSplitNode'new-5
IntegerLessThanNode'OP
IntegerLessThanNode'create-2
IntegerLessThanNode'create-3
IntegerLessThanNode'new-2
IntegerLessThanNode'subtractMayOverflow-3
IntegerLessThanNode'subtractMayUnderflow-3
IntegerLowerThanNode'new-3
IntegerMulExactNode'new-2
IntegerMulExactSplitNode'new-5
IntegerMulHighNode'new-2
IntegerStamp''canBeNegative-1
IntegerStamp''canBePositive-1
IntegerStamp''contains-2
IntegerStamp''isNegative-1
IntegerStamp''isPositive-1
IntegerStamp''isStrictlyNegative-1
IntegerStamp''isStrictlyPositive-1
IntegerStamp''unsignedLowerBound-1
IntegerStamp''unsignedUpperBound-1
IntegerStamp'OPS
IntegerStamp'addCanOverflow-2
IntegerStamp'addOverflowsNegatively-3
IntegerStamp'addOverflowsPositively-3
IntegerStamp'carryBits-2
IntegerStamp'create-3
IntegerStamp'create-5
IntegerStamp'multiplicationCanOverflow-2
IntegerStamp'multiplicationOverflows-3
IntegerStamp'sameSign-2
IntegerStamp'stampForMask-3
IntegerStamp'subtractionCanOverflow-2
IntegerStamp'subtractionOverflows-3
IntegerSubExactNode'new-2
IntegerSubExactSplitNode'new-5
IntegerSwitchNode''tryRemoveUnreachableKeys-3
IntegerSwitchNode'new-5a
IntegerSwitchNode'new-5i
IntegerTestNode'new-2
InterfaceMethodRef'new-1
Interval''addMaterializationValue-2
Interval''addRange-3
Interval''addUsePos-3
Interval''alwaysInMemory-1
Interval''assignLocation-2
Interval''calcTo-1
Interval''canMaterialize-1
Interval''currentAtEnd-1
Interval''currentFrom-1
Interval''currentIntersects-2
Interval''currentIntersectsAt-2
Interval''currentSplitChild-1
Interval''currentTo-1
Interval''firstUsage-2
Interval''from-1
Interval''getIntervalCoveringOpId-2
Interval''getMaterializedValue-1
Interval''getSplitChildAtOpId-4
Interval''getSplitChildBeforeOpId-2
Interval''getSplitChildren-1
Interval''hasHoleBetween-3
Interval''isEndMarker-1
Interval''isSplitChild-1
Interval''isSplitParent-1
Interval''locationHint-2
Interval''makeCurrentSplitChild-1
Interval''newSplitChild-2
Interval''nextRange-1
Interval''nextUsage-3
Interval''nextUsageExact-3
Interval''previousUsage-3
Interval''removeFirstUsePos-1
Interval''rewindRange-1
Interval''setInsertMoveWhenActivated-2
Interval''setKind-2
Interval''setLocationHint-2
Interval''setSpillDefinitionPos-2
Interval''setSpillSlot-2
Interval''setSpillState-2
Interval''spillDefinitionPos-1
Interval''spillSlot-1
Interval''spillState-1
Interval''split-3
Interval''to-1
Interval'END_MARKER_OPERAND_NUMBER
Interval'new-4
IntervalBlockIterator'new-2
IntervalState'Active
IntervalState'Handled
IntervalState'Inactive
IntervalState'Unhandled
IntervalWalker''removeFromList-2
IntervalWalker''walkTo-2
IntervalWalker'new-3
IntrinsicContext'createFrameState-3
IntrinsicContext''isCallToOriginal-2
IntrinsicContext''isCompilationRoot-1
IntrinsicContext''isPostParseInlined-1
IntrinsicContext'new-4
IntrinsicScope'new-1
IntrinsicScope'new-3
InvokeKind''hasReceiver-1
InvokeKind''isIndirect-1
InvokeKind''isInterface-1
InvokeKind'Interface
InvokeKind'Special
InvokeKind'Static
InvokeKind'Virtual
InvokeKind'new-1
InvokeNode''getContextMethod-1
InvokeNode''getContextType-1
InvokeNode''getInvokeKind-1
InvokeNode''getReceiver-1
InvokeNode''getReceiverType-1
InvokeNode''intrinsify-2
InvokeNode''setClassInit-2
InvokeNode''setUseForInlining-2
InvokeNode'new-2
InvokeNode'new-3
IsNullNode'create-1
IsNullNode'new-1
IsNullNode'tryCanonicalize-1
IterativeConditionalEliminationPhase'new-2
IterativeNodeWorkList'new-3
JSRData'new-0
JVMCI'backend
JVMCI'runtime
JavaReadNode'new-5
JavaWriteNode'new-6
JsrScope''isEmpty-1
JsrScope''isPrefixOf-2
JsrScope''nextReturnAddress-1
JsrScope''pop-1
JsrScope''push-2
JsrScope'EMPTY_SCOPE
JsrScope'new-0
JumpOp''clearOutgoingValues-1
JumpOp''getOutgoingValue-2
JumpOp''setPhiValues-2
JumpOp'new-1
JumpOp'outgoingFlags
KeyData'new-3
KlassPointerStamp''compressed-2
KlassPointerStamp''isCompressed-1
KlassPointerStamp''uncompressed-1
KlassPointerStamp'KLASS
KlassPointerStamp'KLASS_ALWAYS_NULL
KlassPointerStamp'KLASS_NON_NULL
LIR''getLIRforBlock-2
LIR''nextVariable-1
LIR''setHasArgInCallerFrame-1
LIR''setLIRforBlock-3
LIR'getNextBlock-2
LIR'new-3
LIRBuilder''doBlock-4
LIRBuilder''doBlockPrologue-2
LIRBuilder''emitBranch-5
LIRBuilder''emitCompareBranch-5
LIRBuilder''emitConditional-2
LIRBuilder''emitConditional-4
LIRBuilder''emitConstantBranch-4
LIRBuilder''emitIf-2
LIRBuilder''emitIntegerTestBranch-5
LIRBuilder''emitInvoke-2
LIRBuilder''emitNode-2
LIRBuilder''emitOverflowCheckBranch-5
LIRBuilder''emitPrologue-2
LIRBuilder''emitSwitch-2
LIRBuilder''getExactPhiKind-2
LIRBuilder''getLIRBlock-2
LIRBuilder''hasOperand-2
LIRBuilder''operand-2
LIRBuilder''peephole-2
LIRBuilder''setResult-3
LIRBuilder''visitEndNode-2
LIRBuilder''visitInvokeArguments-3
LIRBuilder''visitLoopEnd-2
LIRBuilder''visitMerge-2
LIRBuilder''visitSafepointNode-2
LIRBuilder'new-2
LIRFieldsScanner'new-0
LIRGenerationContext'new-4
LIRGenerationPhase'new-0
LIRGenerationResult''buildFrameMap-1
LIRGenerationResult'new-2
LIRGenerator''append-2
LIRGenerator''asAddressValue-2
LIRGenerator''asAllocatable-2
LIRGenerator''beforeRegisterAllocation-1
LIRGenerator''emitAdd-4
LIRGenerator''emitAdd-5
LIRGenerator''emitAddress-2
LIRGenerator''emitAnd-3
LIRGenerator''emitAtomicReadAndAdd-3
LIRGenerator''emitAtomicReadAndWrite-3
LIRGenerator''emitBinaryMemory-5
LIRGenerator''emitBitCount-2
LIRGenerator''emitBitScanForward-2
LIRGenerator''emitBitScanReverse-2
LIRGenerator''emitBlackhole-2
LIRGenerator''emitByteSwap-2
LIRGenerator''emitCCall-4
LIRGenerator''emitCompareAndSwapBranch-9
LIRGenerator''emitCompareBranch-8
LIRGenerator''emitCompareOp-4
LIRGenerator''emitCompress-4
LIRGenerator''emitConditionalMove-7
LIRGenerator''emitConstant-3
LIRGenerator''emitConvertMemoryOp-5
LIRGenerator''emitCountLeadingZeros-2
LIRGenerator''emitCountTrailingZeros-2
LIRGenerator''emitDeoptimize-3
LIRGenerator''emitDeoptimizeCaller-3
LIRGenerator''emitDiv-3
LIRGenerator''emitForeignCall-3*
LIRGenerator''emitForeignCallOp-5
LIRGenerator''emitIncomingValues-2
LIRGenerator''emitIntegerTestBranch-6
LIRGenerator''emitIntegerTestMove-5
LIRGenerator''emitJavaConstant-2
LIRGenerator''emitJump-2
LIRGenerator''emitLFence-1
LIRGenerator''emitLoad-3
LIRGenerator''emitLoadConfigValue-3
LIRGenerator''emitLoadConstant-3
LIRGenerator''emitLogicCompareAndSwap-6
LIRGenerator''emitMembar-2
LIRGenerator''emitMove-2
LIRGenerator''emitMove-3
LIRGenerator''emitMoveConstant-3
LIRGenerator''emitMul-4
LIRGenerator''emitMulHigh-3
LIRGenerator''emitNarrow-3
LIRGenerator''emitNegate-2
LIRGenerator''emitNot-2
LIRGenerator''emitNullCheck-2
LIRGenerator''emitOr-3
LIRGenerator''emitOverflowCheckBranch-5
LIRGenerator''emitPrefetchAllocate-2
LIRGenerator''emitRandomSeed-1
LIRGenerator''emitRem-3
LIRGenerator''emitReturn-3
LIRGenerator''emitRol-3
LIRGenerator''emitRor-3
LIRGenerator''emitSaveRbp-1
LIRGenerator''emitShl-3
LIRGenerator''emitShr-3
LIRGenerator''emitSignExtend-4
LIRGenerator''emitSignedDivRem-3
LIRGenerator''emitStore-4a
LIRGenerator''emitStore-4v
LIRGenerator''emitStoreConst-4
LIRGenerator''emitStrategySwitch-5
LIRGenerator''emitStrategySwitch-6
LIRGenerator''emitSub-4
LIRGenerator''emitSub-5
LIRGenerator''emitTableSwitch-5
LIRGenerator''emitTailcall-3
LIRGenerator''emitUDiv-3
LIRGenerator''emitUMulHigh-3
LIRGenerator''emitURem-3
LIRGenerator''emitUShr-3
LIRGenerator''emitUncompress-4
LIRGenerator''emitUnsignedDivRem-3
LIRGenerator''emitValueCompareAndSwap-4
LIRGenerator''emitXor-3
LIRGenerator''emitZeroExtend-4
LIRGenerator''emitZeroExtendMemory-4
LIRGenerator'getAddressKind-3
LIRGenerator''getBlockScope-2
LIRGenerator''getLockSlot-2
LIRGenerator''hasBlockEnd-2
LIRGenerator''load-2
LIRGenerator''loadNonConst-2
LIRGenerator''newVariable-2
LIRGenerator''setLockStackHolder-2
LIRGenerator'toRegisterKind-1
LIRGenerator'new-1
LIRInsertionBuffer''append-3
LIRInsertionBuffer''finish-1
LIRInsertionBuffer''init-2
LIRInsertionBuffer''initialized-1
LIRInsertionBuffer'new-0
LIRInstruction''forEachAlive-2
LIRInstruction''forEachInput-2
LIRInstruction''forEachOutput-2
LIRInstruction''forEachRegisterHint-4
LIRInstruction''forEachTemp-2
LIRInstruction''hasOperands-1
LIRInstruction''setId-2
LIRInstruction''visitEachAlive-2
LIRInstruction''visitEachInput-2
LIRInstruction''visitEachOutput-2
LIRInstruction''visitEachTemp-2
LIRInstruction'addStackSlotsToTemporaries-2
LIRInstruction'new-0
LIRInstructionClass''forEachAlive-3
LIRInstructionClass''forEachDef-3
LIRInstructionClass''forEachRegisterHint-4
LIRInstructionClass''forEachTemp-3
LIRInstructionClass''forEachUse-3
LIRInstructionClass''hasOperands-1
LIRInstructionClass''visitEachAlive-3
LIRInstructionClass''visitEachDef-3
LIRInstructionClass''visitEachTemp-3
LIRInstructionClass''visitEachUse-3
LIRInstructionClass'new-1
LIRKind''getReferenceCount-1
LIRKind''isCompressedReference-2
LIRKind''isDerivedReference-1
LIRKind''isReference-2
LIRKind''isUnknownReference-1
LIRKind''isValue-1
LIRKind''makeDerivedReference-2
LIRKind''makeUnknownReference-1
LIRKind'Illegal
LIRKind'combine-1*
LIRKind'combineDerived-3
LIRKind'compressedReference-1
LIRKind'derivedBaseFromValue-1
LIRKind'derivedReference-3
LIRKind'fromJavaKind-2
LIRKind'isUnknownReference-1k
LIRKind'isUnknownReference-1v
LIRKind'isValue-1k
LIRKind'isValue-1v
LIRKind'mergeReferenceInformation-2
LIRKind'reference-1
LIRKind'unknownReference-1
LIRKind'value-1
LIRKindTool'getIntegerKind-1
LIRKindTool'getNarrowOopKind-0
LIRKindTool'getNarrowPointerKind-0
LIRKindTool'getObjectKind-0
LIRKindTool'getWordKind-0
LIRPhaseContext'new-1
LIRPhaseSuite'new-1*
LIRSuites'new-0
LIRValueUtil'isIntConstant-2
LIRValueUtil'isJavaConstant-1
LIRValueUtil'isStackSlotValue-1
LIRValueUtil'sameRegister-2
LSAllocationPhase'new-0
LSAssignLocationsPhase''assignLocations-2i
LSAssignLocationsPhase''colorLirOperand-4
LSAssignLocationsPhase'new-1
LSEliminateSpillMovePhase''eliminateSpillMoves-2
LSEliminateSpillMovePhase'new-1
LSLifetimeAnalysisPhase''addTemp-5
LSLifetimeAnalysisPhase''changeSpillDefinitionPos-5
LSLifetimeAnalysisPhase''computeGlobalLiveSets-1
LSLifetimeAnalysisPhase''computeLocalLiveSets-1
LSLifetimeAnalysisPhase''handleMethodArguments-2
LSLifetimeAnalysisPhase''isIntervalInLoop-3
LSLifetimeAnalysisPhase''numberInstructions-1
LSLifetimeAnalysisPhase'new-1
LSLifetimeAnalysisPhase'registerPriorityOfInputOperand-1
LSOptimizeSpillPositionPhase'new-1
LSRegisterAllocationPhase'new-1
LSResolveDataFlowPhase''optimizeEmptyBlocks-3
LSResolveDataFlowPhase''resolveDataFlow-1
LSResolveDataFlowPhase''resolveDataFlow0-3
LSResolveDataFlowPhase''resolveFindInsertPos-4
LSResolveDataFlowPhase'new-1
Label''addPatchAt-2
Label''bind-2
Label''isBound-1
Label''patchInstructions-2
Label'new-0
LabelOp''addIncomingValues-2
LabelOp''clearIncomingValues-1
LabelOp''getIncomingSize-1
LabelOp''getIncomingValue-2
LabelOp''isPhiIn-1
LabelOp''setIncomingValues-2
LabelOp''setPhiValues-2
LabelOp'new-2
LabelRef''getTargetBlock-1
LabelRef''label-1
LabelRef'new-3
LargeLocalLiveness'new-3
LeaOp'new-3
LeftShiftNode'create-2
LeftShiftNode'new-2
LessThanOp'new-0
LinearScan''allocate-2
LinearScan''assignSpillSlot-2
LinearScan''attributes-2
LinearScan''blockAt-2
LinearScan''blockCount-1
LinearScan''blockForId-2
LinearScan''coversBlockBegin-3
LinearScan''createAssignLocationsPhase-1
LinearScan''createDerivedInterval-2
LinearScan''createInterval-2
LinearScan''createOptimizeSpillPositionPhase-1
LinearScan''createRegisterAllocationPhase-1
LinearScan''createUnhandledLists-3
LinearScan''getBlockData-2
LinearScan''getFirstLirInstructionId-2
LinearScan''getFrameMapBuilder-1
LinearScan''getLastLirInstructionId-2
LinearScan''getRegisters-1
LinearScan''hasCall-2
LinearScan''initIntervals-1
LinearScan''initOpIdMaps-2
LinearScan''instructionForId-2
LinearScan''intervalFor-2i
LinearScan''intervalFor-2v
LinearScan''isBlockBegin-2
LinearScan''isCallerSave-2
LinearScan''isMaterialized-4
LinearScan''isProcessed-2
LinearScan''liveSetSize-1
LinearScan''maxOpId-1
LinearScan''numLoops-1
LinearScan''operandNumber-2
LinearScan''operandSize-1
LinearScan''putOpIdMaps-4
LinearScan''sortIntervalsAfterAllocation-1
LinearScan''sortIntervalsBeforeAllocation-1
LinearScan''sortedBlocks-1
LinearScan''splitChildAtOpId-4
LinearScan'DOMINATOR_SPILL_MOVE_ID
LinearScan'IS_PRECOLORED_INTERVAL
LinearScan'IS_STACK_INTERVAL
LinearScan'IS_VARIABLE_INTERVAL
LinearScan'addToList-3
LinearScan'canonicalSpillOpr-1
LinearScan'isVariableOrRegister-1
LinearScan'new-3
LinearScanPhase'new-0
LinearScanWalker''allocFreeRegister-2
LinearScanWalker''allocLockedRegister-2
LinearScanWalker''combineSpilledIntervals-2
LinearScanWalker''excludeFromUse-2
LinearScanWalker''findOptimalSplitPos-4
LinearScanWalker''findOptimalSplitPos-5
LinearScanWalker''finishAllocation-1
LinearScanWalker''freeCollectInactiveAny-2
LinearScanWalker''freeCollectInactiveFixed-2
LinearScanWalker''freeExcludeActiveAny-1
LinearScanWalker''freeExcludeActiveFixed-1
LinearScanWalker''initUseLists-2
LinearScanWalker''initVarsForAlloc-2
LinearScanWalker''insertMove-4
LinearScanWalker''isRegisterInRange-2
LinearScanWalker''maxRegisterNumber-1
LinearScanWalker''minRegisterNumber-1
LinearScanWalker''noAllocationPossible-2
LinearScanWalker''setBlockPos-3
LinearScanWalker''setUsePos-4
LinearScanWalker''spillBlockInactiveFixed-2
LinearScanWalker''spillCollectActiveAny-2
LinearScanWalker''spillCollectInactiveAny-2
LinearScanWalker''spillExcludeActiveFixed-1
LinearScanWalker''splitAndSpillIntersectingIntervals-2
LinearScanWalker''splitAndSpillInterval-2
LinearScanWalker''splitBeforeUsage-4
LinearScanWalker''splitForSpilling-2
LinearScanWalker''splitStackInterval-2
LinearScanWalker''splitWhenPartialRegisterAvailable-3
LinearScanWalker'isMove-3
LinearScanWalker'new-3
LoadCacheEntry'new-2
LoadConfigValueOp'new-2
LoadFieldNode'create-2
LoadFieldNode'create-4
LoadFieldNode'createOverrideStamp-3
LoadFieldNode'createOverrideStamp-5
LoadFieldNode'new-3
LoadHubNode'create-1
LoadHubNode'findSynonym-2
LoadHubNode'new-1
LoadHubNode'new-2
LoadIndexedNode'create-3
LoadIndexedNode'new-3
LoadIndexedNode'new-4
LoadIndexedPointerNode'new-3
LoadMetaspaceConstantOp'new-2
LoadObjectConstantOp'new-2
LocalLiveness'compute-4
LocalLiveness'new-1
LocationIdentity''isAny-1
LocationIdentity''isInit-1
LocationIdentity''isSingle-1
LocationIdentity''overlaps-2
LocationIdentity'ANY
LocationIdentity'INIT
LocationIdentity'new-1
LocationSet''add-2
LocationSet''addAll-2
LocationSet''contains-2
LocationSet''isAny-1
LocationSet'new-0
LockEliminationPhase'new-0
LockStack''makeLockSlot-2
LockStack'new-2
LockStackHolder'new-1
LockState'asList-1
LockState'new-2
LogicCompareAndSwapNode'new-4
LogicCompareAndSwapNode'new-5
LogicConstantNode'contradiction-0
LogicConstantNode'contradiction-1
LogicConstantNode'forBoolean-1
LogicConstantNode'forBoolean-2
LogicConstantNode'new-1
LogicConstantNode'tautology-0
LogicConstantNode'tautology-1
LogicNegationNode'create-1
LogicNegationNode'new-1
LogicNode''isContradiction-1
LogicNode''isTautology-1
LogicNode'and-3
LogicNode'and-5
LogicNode'new-0
LogicNode'or-3
LogicNode'or-5
Loop''addExit-2
Loop''canKill-2
Loop''getKillLocations-1
Loop''numBackedges-1
Loop'new-3
LoopBeginNode''canonicalizePhis-2
LoopBeginNode''disableSafepoint-1
LoopBeginNode''forwardEnd-1
LoopBeginNode''getSingleLoopEnd-1
LoopBeginNode''getSingleLoopExit-1
LoopBeginNode''incrementSplits-1
LoopBeginNode''incrementUnswitches-1
LoopBeginNode''isLoopExit-2
LoopBeginNode''isMainLoop-1
LoopBeginNode''isPostLoop-1
LoopBeginNode''isPreLoop-1
LoopBeginNode''isSimpleLoop-1
LoopBeginNode''loopEnds-1
LoopBeginNode''loopExits-1
LoopBeginNode''nextEndIndex-1
LoopBeginNode''orderedLoopEnds-1
LoopBeginNode''removeExits-1
LoopBeginNode''setLoopFrequency-2
LoopBeginNode''setLoopOrigFrequency-2
LoopBeginNode''setMainLoop-1
LoopBeginNode''setOverflowGuard-2
LoopBeginNode''setPostLoop-1
LoopBeginNode''setPreLoop-1
LoopBeginNode''setUnrollFactor-2
LoopBeginNode'new-0
LoopEndNode''disableSafepoint-1
LoopEndNode''setEndIndex-2
LoopEndNode''setLoopBegin-2
LoopEndNode'new-1
LoopEx''canDuplicateLoop-1
LoopEx''deleteUnusedNodes-1
LoopEx''detectCounted-1
LoopEx''entryPoint-1
LoopEx''getInductionVariables-1
LoopEx''inside-1
LoopEx''invalidateFragments-1
LoopEx''isCounted-1
LoopEx''isOutsideLoop-2
LoopEx''loopBegin-1
LoopEx''nodesInLoopBranch-3
LoopEx''reassociateInvariants-1
LoopEx''size-1
LoopEx''whole-1
LoopEx'new-2
LoopExitNode''proxies-1
LoopExitNode''removeProxies-1
LoopExitNode'new-1
LoopFragment''contains-2
LoopFragment''getDuplicatedNode-2
LoopFragment''graph-1
LoopFragment''isDuplicate-1
LoopFragment''mergeEarlyExits-1
LoopFragment''patchNodes-2
LoopFragment''putDuplicatedNode-3
LoopFragment'computeNodes-3
LoopFragment'computeNodes-4
LoopFragment'isLoopNode-3
LoopFragment'new-1
LoopFragment'new-2
LoopFragment'toHirBlocks-1
LoopFragment'toHirExits-1
LoopFragmentInside''exits-1
LoopFragmentInside''insertWithinAfter-2
LoopFragmentInside''insertWithinAfter-3
LoopFragmentInside''primAfter-2
LoopFragmentInside'new-1e
LoopFragmentInside'new-1f
LoopFragmentWhole''cleanupLoopExits-1
LoopFragmentWhole''entryPoint-1
LoopFragmentWhole'new-1e
LoopFragmentWhole'new-1f
LoopFullUnrollPhase'new-2
LoopKillCache''containsLocation-2
LoopKillCache''loopKillsLocations-1
LoopKillCache''rememberLoopKilledLocation-2
LoopKillCache''setKillsAll-1
LoopKillCache''visited-1
LoopKillCache'new-1
LoopPartialUnrollPhase'new-2
LoopPeelingPhase'new-1
LoopPhase'new-1
LoopSafepointEliminationPhase'new-0
LoopSafepointInsertionPhase'new-0
LoopTransformations'findUnswitchable-1
LoopTransformations'fullUnroll-2
LoopTransformations'insertPrePostLoops-1
LoopTransformations'isUnrollableLoop-1
LoopTransformations'partialUnroll-1
LoopTransformations'peel-1
LoopTransformations'unswitch-2
LoopType'MAIN_LOOP
LoopType'POST_LOOP
LoopType'PRE_LOOP
LoopType'SIMPLE_LOOP
LoopUnswitchingPhase'new-1
LoopsData''countedLoops-1
LoopsData''deleteUnusedNodes-1
LoopsData''detectedCountedLoops-1
LoopsData''loop-2
LoopsData'new-1
LowTier'new-0
LowerGuards'new-1
LowerOp''getSucceedingStampForX-5
LowerOp''getSucceedingStampForXLowerXPlusA-4
LowerOp''max-4
LowerOp''min-4
LowerOp''tryFold-3
LowerOp'new-0
LoweredAtomicReadAndWriteNode'new-4
LoweredCallTargetNode''callType-1
LoweredCallTargetNode''signature-1
LoweredCallTargetNode'new-6
Lowerer'arrayInitializationBarrier-1
Lowerer'arrayStoreBarrierType-1
Lowerer'boxingSnippets
Lowerer'createArrayAddress-4
Lowerer'createFieldAddress-3
Lowerer'createNullCheck-3
Lowerer'createNullCheckedValue-3
Lowerer'createOffsetAddress-3
Lowerer'createReadArrayComponentHub-3
Lowerer'createReadArrayLength-3
Lowerer'createReadHub-3
Lowerer'createUnsafeAddress-3
Lowerer'fieldInitializationBarrier-1
Lowerer'fieldLoadBarrierType-1
Lowerer'fieldStoreBarrierType-1
Lowerer'getBoundsCheck-3
Lowerer'implicitLoadConvert-3
Lowerer'implicitLoadConvert-4
Lowerer'implicitStoreConvert-3
Lowerer'implicitStoreConvert-4
Lowerer'instanceofSnippets
Lowerer'loadStamp-3
Lowerer'monitorSnippets
Lowerer'newObjectSnippets
Lowerer'smallestCompareWidth-0
Lowerer'storeBarrierType-2
Lowerer'unsafeLoadSnippets
Lowerer'writeBarrierSnippets
LoweringPhase'new-2
LoweringPhase'processBlock-1
LoweringPhase'processBlockBounded-1
LoweringRound'new-1
LoweringStage'HIGH_TIER
LoweringStage'LOW_TIER
LoweringStage'MID_TIER
LoweringTool''createGuard-5
LoweringTool''createGuard-7
LoweringTool''setLastFixedNode-2
LoweringTool'new-4
MOp'new-4
MROp'new-4
MacroNode''createInvoke-1
MacroNode''replaceWithInvoke-1
MacroNode'new-5*
MacroStateSplitNode'new-5*
MapReplacement'new-1
MarkedNodeIterator'new-1
MaterializationUsageReplacer'new-5
MaterializedObjectState'new-2
MathUtil'add-3
MathUtil'divBefore-4
MathUtil'mul-3
MathUtil'sub-3
MathUtil'unsignedDivBefore-4
MembarNode'new-1
MembarNode'new-2
MembarOp'new-1
MemberRef'new-2
MemoryAnchorNode'new-0
MemoryConstOp'new-4
MemoryConstOp'new-4a
MemoryConstOp'new-4b
MemoryInputMap'new-1
MemoryMROp'new-4
MemoryMap0'copy-1
MemoryMap0'new-0
MemoryMap0'new-1
MemoryMapNode''isEmpty-1
MemoryMapNode'new-1
MemoryOp'new-4
MemoryOutputMap'new-3
MemoryPhiNode'new-2
MemoryRMOp'new-4
MemoryTwoOp'new-5
MemoryVMConstOp'new-3
MergeNode'new-0
MergeProcessor''createValuePhi-2
MergeProcessor''getPhiValueAt-3
MergeProcessor''getPhis-1
MergeProcessor''getPredecessor-2
MergeProcessor''graph-1
MergeProcessor''setNewState-2
MergeProcessor''setPhiInput-4
MergeProcessor''setStateIndexes-2
MergeProcessor'new-1
MetaspaceOpcode'FROM_POINTER
MetaspaceOpcode'IS_NULL
MetaspaceOpcode'POINTER_EQ
MetaspaceOpcode'POINTER_NE
MetaspaceOpcode'READ_KLASS_POINTER
MetaspaceOpcode'TO_KLASS_POINTER
MethodCallOp'new-4
MethodCallTargetNode''invoke-1
MethodCallTargetNode''isStatic-1
MethodCallTargetNode''receiver-1
MethodCallTargetNode''returnKind-1
MethodCallTargetNode'devirtualizeCall-4
MethodCallTargetNode'findSpecialCallTarget-4
MethodCallTargetNode'new-4
MethodInvocation''buildCallsiteHolderForElement-2
MethodInvocation''incrementProcessedGraphs-1
MethodInvocation''isRoot-1
MethodInvocation''totalGraphs-1
MethodInvocation'new-4
MethodKey'new-2
MethodRef'new-1
MethodsCache''lookup-4
MethodsCache'new-0
MicroBlock''add-2
MicroBlock''prependChildrenTo-2
MicroBlock'new-1
MidTier'new-0
MonitorEnterNode'new-2
MonitorExitNode''clearEscapedReturnValue-1
MonitorExitNode'new-3
MonitorIdNode''setLockDepth-2
MonitorIdNode'new-1
MonitorTemplates''lower-3i
MonitorTemplates''lower-3o
MonitorTemplates'new-1
MoveFactory'allowConstantToStackMove-1
MoveFactory'canInlineConstant-1
MoveFactory'createLoad-2
MoveFactory'createMove-2
MoveFactory'createStackLoad-2
MoveFactory''createStackMove-3
MoveFactory''getScratchRegister-2
MoveFactory'new-1
MoveFromConstOp'new-2
MoveFromRegOp'new-3
MoveGuardsUpwards'new-0
MoveResolver''addMapping-3c
MoveResolver''addMapping-3i
MoveResolver''getMappingFrom-2
MoveResolver''hasMappings-1
MoveResolver''moveInsertPosition-3
MoveResolver''resolveAndAppendMoves-1
MoveResolver''setInsertPosition-3
MoveResolver''spillInterval-4
MoveResolver'new-1
MoveToRegOp'new-3
Mul'new-2
MulHigh'new-2
MulNode'canonical-3
MulNode'create-2
MulNode'new-2
NameAndType''getName-2
NameAndType''getType-2
NameAndType'new-1
NamedLocationIdentity'ARRAY_LENGTH
NamedLocationIdentity'CLASS_KLASS
NamedLocationIdentity'CLASS_MIRROR
NamedLocationIdentity'CLASS_MIRROR_HANDLE
NamedLocationIdentity'COMPRESSED_HUB
NamedLocationIdentity'DISPLACED_MARK_WORD
NamedLocationIdentity'GC_CARD
NamedLocationIdentity'GC_INDEX
NamedLocationIdentity'GC_LOG
NamedLocationIdentity'HUB
NamedLocationIdentity'HUB_WRITE
NamedLocationIdentity'KLASS_SUPER_CHECK_OFFSET
NamedLocationIdentity'MARK_WORD
NamedLocationIdentity'METASPACE_ARRAY_LENGTH
NamedLocationIdentity'OBJECT_MONITOR_CXQ
NamedLocationIdentity'OBJECT_MONITOR_ENTRY_LIST
NamedLocationIdentity'OBJECT_MONITOR_OWNER
NamedLocationIdentity'OBJECT_MONITOR_RECURSION
NamedLocationIdentity'OBJECT_RESULT
NamedLocationIdentity'OBJ_ARRAY_KLASS_ELEMENT_KLASS
NamedLocationIdentity'PENDING_DEOPTIMIZATION
NamedLocationIdentity'PENDING_EXCEPTION
NamedLocationIdentity'PRIMARY_SUPERS
NamedLocationIdentity'PROTOTYPE_MARK_WORD
NamedLocationIdentity'SECONDARY_SUPERS
NamedLocationIdentity'SECONDARY_SUPERS_ELEMENT
NamedLocationIdentity'SECONDARY_SUPER_CACHE
NamedLocationIdentity'TLAB_END
NamedLocationIdentity'TLAB_TOP
NamedLocationIdentity'getArrayLocation-1
NamedLocationIdentity'getUnboxLocation-1
NamedLocationIdentity'immutable-1
NamedLocationIdentity'mutable-1
Narrow'new-0
NarrowNode'create-2
NarrowNode'create-3
NarrowNode'new-2
NarrowNode'new-3
NarrowOopStamp''getEncoding-1
NarrowOopStamp'new-5
Neg'new-0
NegateNode'create-1
NegateNode'findSynonym-1
NegateNode'new-1
NewArrayNode''createVirtualArrayNode-2
NewArrayNode''defaultElementValue-1
NewArrayNode'new-2
NewInstanceNode''createVirtualInstanceNode-2
NewInstanceNode''defaultFieldValue-2
NewInstanceNode'new-1
NewObjectTemplates''lower-3a
NewObjectTemplates''lower-3i
NewObjectTemplates'new-0
NoOp''replace-3
NoOp'new-2
Node''addUsage-2
Node''applyInputs-2
Node''applySuccessors-2
Node''clearInputs-1
Node''clearSuccessors-1
Node''clone-3
Node''copyWithInputs-1
Node''dataFlowEquals-2
Node''hasExactlyOneUsage-1
Node''hasMoreThanOneUsage-1
Node''hasNoUsages-1
Node''hasUsages-1
Node''inputPositions-1
Node''inputs-1
Node''isAlive-1
Node''isDeleted-1
Node''markDeleted-1
Node''maybeNotifyZeroUsages-2
Node''removeUsage-2
Node''replaceAndDelete-2
Node''replaceAtAllUsages-3
Node''replaceAtMatchingUsages-3
Node''replaceAtPredecessor-2
Node''replaceAtUsages-2
Node''replaceAtUsages-3
Node''replaceAtUsagesAndDelete-2
Node''replaceFirstInput-3
Node''replaceFirstSuccessor-3
Node''safeDelete-1
Node''successorPositions-1
Node''successors-1
Node''updatePredecessor-3
Node''updateUsages-3
Node''valueEquals-2
Node'ALIVE_ID_START
Node'DELETED_ID_START
Node'INITIAL_ID
Node'NODE_LIST
Node'WithAllEdges
Node'WithNoEdges
Node'WithOnlyInputEdges
Node'WithOnlySucessorEdges
Node'new-0
NodeBitMap''checkAndMarkInc-2
NodeBitMap''clear-2
NodeBitMap''clearAll-1
NodeBitMap''clearAndGrow-2
NodeBitMap''invert-1
NodeBitMap''isMarked-2i
NodeBitMap''isMarked-2n
NodeBitMap''isMarkedAndGrow-2
NodeBitMap''isNew-2
NodeBitMap''mark-2
NodeBitMap''markAll-2
NodeBitMap''markAndGrow-2
NodeBitMap''nextMarkedNode-2
NodeBitMap'copy-1
NodeBitMap'new-1
NodeClass''applyInputs-3
NodeClass''applySuccessors-3
NodeClass''dataEquals-3
NodeClass''equalInputs-3
NodeClass''equalSuccessors-3
NodeClass''getEdges-2
NodeClass''isValid-4
NodeClass''registerAtInputsAsUsage-2
NodeClass''registerAtSuccessorsAsPredecessor-2
NodeClass''replaceFirstInput-4
NodeClass''replaceFirstSuccessor-4
NodeClass''unregisterAtInputsAsUsage-2
NodeClass''unregisterAtSuccessorsAsPredecessor-2
NodeClass''updateInputSuccInPlace-3
NodeClass'NEXT_EDGE
NodeClass'addGraphDuplicate-5
NodeClass'new-2
NodeClass'replaceFirstEdge-4
NodeClass'updateEdgesInPlace-3
NodeClosure'new-0
NodeCost'new-3
NodeEntry'new-1
NodeEvent'INPUT_CHANGED
NodeEvent'NODE_ADDED
NodeEvent'NODE_REMOVED
NodeEvent'ZERO_USAGES
NodeEventListener''event-3
NodeEventListener'new-0
NodeEventScope'new-2
NodeFieldsScanner'new-1
NodeFlood''add-2
NodeFlood''isMarked-2
NodeFlood'new-1
NodeInputList'new-1
NodeInputList'new-2i
NodeInputList'new-2s
NodeIteratorClosure'new-0
NodeList''clearWithoutUpdate-1
NodeList''copy-2
NodeList''initialize-3
NodeList''replaceFirst-3
NodeList'new-1
NodeList'new-2i
NodeList'new-2s
NodeLoopInfo'new-0
NodeMap''getAndGrow-2
NodeMap''getKey-2
NodeMap''isNew-2
NodeMap''set-3
NodeMap''setAndGrow-3
NodeMap'new-1g
NodeMap'new-1m
NodeSuccessorList'new-1
NodeSuccessorList'new-2i
NodeSuccessorList'new-2s
NodeWorkList''addAll-2
NodeWorkList'new-2
NonMaterializationUsageReplacer'new-5
NormalizeCompareNode'create-3
NormalizeCompareNode'new-3
NormalizeCompareNode'tryConstantFold-3
Not'new-0
NotNode'create-1
NotNode'new-1
NullCheckNode'new-1
NullCheckOp'new-1
NullCheckOptimizer'new-0
NumUtil'is32bit-1
NumUtil'isByte-1i
NumUtil'isByte-1l
NumUtil'isInt-1
NumUtil'maxUnsigned-2
NumUtil'maxValue-1
NumUtil'maxValueUnsigned-1
NumUtil'minUnsigned-2
NumUtil'minValue-1
NumUtil'roundUp-2i
NumUtil'roundUp-2l
NumUtil'sameSign-2
ObjectEqualsNode'create-2
ObjectEqualsNode'createCanonical-2
ObjectEqualsNode'new-2
ObjectEqualsOp'new-0
ObjectStamp'new-4
ObjectState''addLock-2
ObjectState''createEscapeObjectState-2
ObjectState''escape-2
ObjectState''getEntry-2
ObjectState''hasLocks-1
ObjectState''isVirtual-1
ObjectState''locksEqual-2
ObjectState''removeLock-1
ObjectState''setEnsureVirtualized-2
ObjectState''setEntry-3
ObjectState''share-1
ObjectState''updateMaterializedValue-2
ObjectState'new-3m
ObjectState'new-3s
ObjectState'new-3v
ObjectWriteBarrier'new-3
OffsetAddressNode'create-1
OffsetAddressNode'new-2
OpaqueNode'new-1
OperandFlag'COMPOSITE
OperandFlag'CONST
OperandFlag'HINT
OperandFlag'ILLEGAL
OperandFlag'OUTGOING
OperandFlag'REG
OperandFlag'STACK
OperandFlag'UNINITIALIZED
OperandMode'ALIVE
OperandMode'DEF
OperandMode'TEMP
OperandMode'USE
OperandModeAnnotation'new-0
OperandSize'BYTE
OperandSize'DWORD
OperandSize'QWORD
OperandSize'WORD
OperandSize'new-2
OperandSize'new-3
OptimisticOptimizations''devirtualizeInvokes-1
OptimisticOptimizations''lessOptimisticThan-2
OptimisticOptimizations''removeNeverExecutedCode-1
OptimisticOptimizations''useLoopLimitChecks-1
OptimisticOptimizations'ALL
OptimisticOptimizations'NONE
OptimisticOptimizations'new-1
Optimization'RemoveNeverExecutedCode
Optimization'UseLoopLimitChecks
Optimization'UseTypeCheckedInlining
OptimizingLinearScanWalker'new-3
Optionality'Optional
Optionality'Required
Or'new-2
OrNode'create-2
OrNode'new-2
PEMergeProcessor''getPhi-3
PEMergeProcessor'new-2
PEReadEliminationBlockState''addReadCache-8
PEReadEliminationBlockState''getReadCache-6
PEReadEliminationBlockState''killReadCache-1
PEReadEliminationBlockState''killReadCache-3
PEReadEliminationBlockState'copy-1
PEReadEliminationBlockState'new-0
PEReadEliminationClosure'new-1
PEReadEliminationMergeProcessor'new-2
ParameterNode'new-2
PartialEscapeBlockState''addLock-3
PartialEscapeBlockState''addObject-3
PartialEscapeBlockState''adoptAddObjectStates-2
PartialEscapeBlockState''contains-2
PartialEscapeBlockState''escape-3
PartialEscapeBlockState''materializeBefore-4
PartialEscapeBlockState''removeLock-2
PartialEscapeBlockState''resetObjectStates-2
PartialEscapeBlockState''setEntry-4
PartialEscapeBlockState''updateMaterializedValue-3
PartialEscapeBlockState'copy-1
PartialEscapeBlockState'identicalObjectStates-1
PartialEscapeBlockState'identicalObjectStates-2
PartialEscapeBlockState'new-0
PartialEscapeClosure''addVirtualAlias-3
PartialEscapeClosure''ensureMaterialized-5
PartialEscapeClosure''getAlias-2
PartialEscapeClosure''getAliasAndResolve-3
PartialEscapeClosure''getObjectState-3
PartialEscapeClosure'new-1
PartialEscapeClosure'updateStatesForMaterialized-3
PartialEscapePhase'new-2
PartialEscapePhase'new-3
PhaseContext'new-1
PhaseSuite''appendPhase-2
PhaseSuite''findPhase-2
PhaseSuite''findPhase-3
PhaseSuite'new-0
PhiInfoElement''get-2
PhiInfoElement''set-3
PhiInfoElement'new-0
PhiNode''addInput-2
PhiNode''firstValue-1
PhiNode''initializeValueAt-3
PhiNode''isLoopPhi-1
PhiNode''removeInput-2
PhiNode''setValueAt-3i
PhiNode''setValueAt-3n
PhiNode''singleBackValueOrThis-1
PhiNode''singleValueOrThis-1
PhiNode''valueAt-2i
PhiNode''valueAt-2n
PhiNode''valueCount-1
PhiNode'new-2
PiArrayNode'new-3
PiNode'canonical-3
PiNode'create-3
PiNode'intrinsify-4
PiNode'new-2
PiNode'new-3
Placeholder'new-1
PlaceholderStamp'SINGLETON
Plugins''getOverridingStamp-4
Plugins'create-0
Plugins'new-0
PointerCastNode'new-2
PointerCompressionOp''getBaseRegister-1
PointerCompressionOp''getShift-1
PointerCompressionOp''move-3
PointerCompressionOp'hasBase-1
PointerCompressionOp'new-5
PointerEqualsNode'create-2
PointerEqualsNode'findSynonym-2
PointerEqualsNode'new-2
PointerEqualsOp'new-0
Position''get-2
Position''getInputType-1
Position''initialize-3
Position''set-3
Position'new-3
PrefetchAllocateNode'new-1
Prefix'REX
Prefix'REXB
Prefix'REXR
Prefix'REXRB
Prefix'REXRX
Prefix'REXRXB
Prefix'REXW
Prefix'REXWB
Prefix'REXWR
Prefix'REXWRB
Prefix'REXWRX
Prefix'REXWRXB
Prefix'REXWX
Prefix'REXWXB
Prefix'REXX
Prefix'REXXB
Primitive'new-2
PrimitiveStamp'getBits-1
PrimitiveStamp'new-2
PrimitiveStrategy''getSliceEnd-3
PrimitiveStrategy'new-2
ProcessBlockState'ST_ENTER
ProcessBlockState'ST_ENTER_ALWAYS_REACHED
ProcessBlockState'ST_LEAVE
ProcessBlockState'ST_PROCESS
ProcessBlockState'ST_PROCESS_ALWAYS_REACHED
ProcessFrame''enter-2
ProcessFrame''enterAlwaysReached-2
ProcessFrame''postprocess-1
ProcessFrame''preprocess-1
ProcessFrame'new-5
PropagateDeoptimizeProbabilityPhase'new-0
ProxyNode'forGuard-3
ProxyNode'forValue-3
ProxyNode'new-2
RMEOptimization''doOptimize-2
RMEOptimization'new-1
RMIOp'new-5
RMOp'new-4
RandomSeedNode'new-0
Range''intersects-2
Range''intersectsAt-2
Range''isEndMarker-1
Range'new-3
RangesStrategy'new-2
RawConditionalEliminationVisitor'new-2
RawData'new-2
RawEdgesIterator'new-2
RawLoadNode''createUnsafeRead-2
RawLoadNode'new-4
RawLoadNode'new-5
RawMonitorEnterNode'new-3
RawPointerStamp'new-0
RawStoreNode'new-8
ReadCacheEntry'new-5
ReadEliminationBlockState''addCacheEntry-3
ReadEliminationBlockState''getCacheEntry-2
ReadEliminationBlockState''killReadCache-1
ReadEliminationBlockState''killReadCache-2
ReadEliminationBlockState'copy-1
ReadEliminationBlockState'new-0
ReadEliminationClosure'new-2
ReadEliminationMergeProcessor''getCachedPhi-3
ReadEliminationMergeProcessor'new-1
ReadNode'canonicalizeRead-4
ReadNode'new-4
ReadRegisterNode'new-4i
ReadRegisterNode'new-4r
ReadTimestampCounter'new-0
ReassociateInvariantPhase'new-0
ReassociateMatch''getOtherValue-2
ReassociateMatch''getValue-2
RedundantMoveElimination'new-0
ReentrantBlockIterator'apply-2
ReentrantBlockIterator'apply-4
ReentrantBlockIterator'processLoop-3
ReentrantNodeIterator'apply-3
ReentrantNodeIterator'processLoop-3
RefCount'new-0
ReflectionGetCallerClassNode'new-5*
RegisterAllocationConfig'allocatableRegisters
RegisterAllocationConfig'getAllocatableRegisters-1
RegisterBackupPair'new-2
RegisterBinding'Any
RegisterBinding'Fixed
RegisterBinding'Stack
RegisterBinding'VALUES
RegisterBindingLists''addToListSortedByCurrentFromPositions-3
RegisterBindingLists''addToListSortedByStartAndUsePositions-3
RegisterBindingLists''get-2
RegisterBindingLists''remove-3
RegisterBindingLists''set-3
RegisterBindingLists'new-3
RegisterEffect'DESTROYS_REGISTERS
RegisterEffect'PRESERVES_REGISTERS
RegisterMap''forEach-2
RegisterMap''put-3
RegisterMap'new-1
RegisterPriority'LiveAtLoopEnd
RegisterPriority'MustHaveRegister
RegisterPriority'None
RegisterPriority'ShouldHaveRegister
RegisterPriority'VALUES
RegisterPriority'greaterEqual-2
RegisterPriority'lessThan-2
Rem'new-2
RemNode'create-2
RemNode'new-2
RemoveValueProxyPhase'new-0
Replacements'createSnippet-1
Replacements'new-0
ReplacementsUtil'REFERENT_OFFSET
ReplacementsUtil'clearPendingException-1
ReplacementsUtil'getAndClearObjectResult-1
ReplacementsUtil'loadHub-1
ReplacementsUtil'loadWordFromObject-2
ReplacementsUtil'readPendingDeoptimization-1
ReplacementsUtil'readTlabEnd-1
ReplacementsUtil'readTlabTop-1
ReplacementsUtil'registerAsWord-1
ReplacementsUtil'writePendingDeoptimization-2
ReplacementsUtil'writeTlabTop-2
ResolvedJavaMethodBytecode'new-1
ResolvedJavaMethodBytecodeProvider'INSTANCE
ReturnNode''setMemoryMap-2
ReturnNode'new-1
ReturnNode'new-2
ReturnOp'new-1
ReturnToCallerData'containsReturnValue-2
ReturnToCallerData'new-2
RightShiftNode'create-2
RightShiftNode'new-2
SSALinearScan'new-3
SSALinearScanEliminateSpillMovePhase'new-1
SSALinearScanLifetimeAnalysisPhase'new-1
SSALinearScanLifetimeAnalysisPhase'setHint-3
SSALinearScanResolveDataFlowPhase'new-1
SSAMoveResolver'new-1
SSAUtil'forEachPhiRegisterHint-6
SSAUtil'forEachPhiValuePair-4
SSAUtil'phiIn-2
SSAUtil'phiOut-2
SSAUtil'phiOutIndex-2
SSAUtil'removePhiIn-2
SSAUtil'removePhiOut-2
SafepointNode'new-0
SafepointOp'emitCode-4
SafepointOp'new-2
SaveCalleeSaveRegisters'new-0
SaveRbp''finalize-2
SaveRbp'new-2
Scale'Times1
Scale'Times2
Scale'Times4
Scale'Times8
Scale'fromInt-1
Scale'fromShift-1
ScheduleInstance''run-3
ScheduleInstance'new-0
ScheduleInstance'new-1
SchedulePhase'new-0
SchedulePhase'new-1
SchedulePhase'run-3
ScheduleResult''nodesFor-2
ScheduleResult'new-3
ScheduledNodeIterator''insert-3
ScheduledNodeIterator''processNodes-3
ScheduledNodeIterator''replaceCurrent-2
ScheduledNodeIterator'new-0
SchedulingStrategy'EARLIEST
SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER
SchedulingStrategy'FINAL_SCHEDULE
SchedulingStrategy'LATEST
SchedulingStrategy'LATEST_OUT_OF_LOOPS
SchedulingStrategy'isEarliest-1
Scope''computeInvokeRelevance-2
Scope''getFastPathMinProbability-1
Scope''getScopeRelevanceWithinParent-1
Scope''process-2
Scope'new-3
SequentialStrategy'new-2
SerialWriteBarrier'new-2
ShiftNode''getOp-2
ShiftNode''getShiftAmountMask-1
ShiftNode'canonical-4
ShiftNode'new-3
ShiftOp'new-1
Shl'new-0
ShortCircuitOrNode''canonicalizeNegation-3
ShortCircuitOrNode'new-5
Shr'new-0
SignExtend'new-0
SignExtendNode'create-2
SignExtendNode'create-3
SignExtendNode'new-2
SignExtendNode'new-3
SignedDivNode'canonical-2
SignedDivNode'canonical-3
SignedDivNode'create-2
SignedDivNode'new-2
SignedRemNode'create-2
SignedRemNode'new-2
Signedness'SIGNED
Signedness'UNSIGNED
SingletonNodeWorkList'new-1
SlotSize'Illegal
SlotSize'Size1
SlotSize'Size2
SlotSize'Size4
SlotSize'Size8
SmallLocalLiveness'new-3
SnippetAnchorNode'new-0
SnippetInfo'new-2
SnippetReflection'asObject-2c
SnippetReflection'asObject-2t
SnippetReflection'forBoxed-2
SnippetReflection'forObject-1
SnippetTemplate''instantiate-3
SnippetTemplate''instantiate-5
SnippetTemplate'new-2
SpillRegistersNode'new-0
SpillRegistersOp'new-0
SpillState'ALWAYS_IN_MEMORY
SpillState'NoDefinitionFound
SpillState'NoOptimization
SpillState'NoSpillStore
SpillState'OneSpillStore
SpillState'SpillInDominator
SpillState'StartInMemory
SpillState'StoreAtDefinition
StackInterval''addFrom-2
StackInterval''addTo-2
StackInterval''setLocation-2
StackInterval''setLocationHint-2
StackInterval'new-2
StackLeaOp'new-2
StackMoveOptimizationPhase'new-0
StackSlotAllocator'new-0
Stamp''isEmpty-1
Stamp''neverDistinct-2
Stamp''tryImproveWith-2
Stamp'new-0
StampElement'new-2
StampFactory'booleanFalse
StampFactory'booleanTrue
StampFactory'forConstant-1
StampFactory'forDeclaredType-2
StampFactory'forInteger-1
StampFactory'forInteger-3i
StampFactory'forInteger-3k
StampFactory'forInteger-5
StampFactory'forIntegerWithMask-4
StampFactory'forIntegerWithMask-5
StampFactory'forKind-1
StampFactory'forPrimitiveConstant-1
StampFactory'forUnsignedInteger-1
StampFactory'forUnsignedInteger-3
StampFactory'forUnsignedInteger-5
StampFactory'nonNegativeInt
StampFactory'object-1
StampFactory'object-2
StampFactory'objectAlwaysNullStamp
StampFactory'objectNonNull-1
StampFactory'objectNonNullStamp
StampFactory'objectStamp
StampFactory'rawPointer
StampTool'isExactType-1
StampTool'isPointerAlwaysNull-1
StampTool'isPointerNeverNull-1
StampTool'meet-1
StampTool'meetOrNull-2
StampTool'objectTypeOrNull-1
StampTool'stampForLeadingZeros-1
StampTool'stampForTrailingZeros-1
StampTool'typeOrNull-1
StampTool'typeReferenceOrNull-1
StampTool'unsignedCompare-2
StartNode'new-0
StateSplitProxyNode'new-1
StateSplitProxyNode'new-2
StoreFieldNode'new-3
StoreFieldNode'new-4
StoreHubNode'new-2
StoreIndexedNode'new-4
StrategySwitchOp'new-5
StringRef''getValue-2
StringRef'new-1
StubForeignCallNode''operands-2
StubForeignCallNode'new-3*
Sub'new-2
SubNode'create-2
SubNode'new-2
SuccessorEdges'new-2
SuccessorInfo'new-1
Suites'createGraphBuilderSuite-0
Suites'createSuites-0
Suites'new-3
SwitchNode''defaultSuccessor-1
SwitchNode''defaultSuccessorIndex-1
SwitchNode''keyProbability-2
SwitchNode''keySuccessor-2
SwitchNode''keySuccessorIndex-2
SwitchNode''killOtherSuccessors-3
SwitchNode''setBlockSuccessor-3
SwitchNode''structureEquals-2
SwitchNode'new-4
SwitchStrategy''registerDefaultEffort-2
SwitchStrategy''registerEffort-4
SwitchStrategy'getBestStrategy-3
SwitchStrategy'new-1
TableSwitchOp'new-6
Tool'new-1
Transition'LEAF
Transition'LEAF_NOFP
Transition'SAFEPOINT
Transition'STACK_INSPECTABLE_LEAF
TwoOp'new-5
TwoSlotMarker'new-0
TypeCheckSnippetUtils'checkSecondarySubType-2
TypeCheckSnippetUtils'checkUnknownSubType-2
TypeReference''asExactReference-1
TypeReference'create-1
TypeReference'createExactTrusted-1
TypeReference'createTrusted-1
UMulHigh'new-2
UShr'new-0
UnaryArithmeticNode''getOp-2
UnaryArithmeticNode'findSynonym-2
UnaryArithmeticNode'new-2
UnaryNode'new-2
UnaryOp'new-1
UnaryOpLogicNode''getSucceedingStampForValue-3
UnaryOpLogicNode'new-1
UnboxNode'create-2
UnboxNode'new-2
UncompressPointerOp'new-5
UnpackEndianHalfNode'create-2
UnpackEndianHalfNode'new-2
Unsafe'ARRAY_BOOLEAN_BASE_OFFSET
Unsafe'ARRAY_BOOLEAN_INDEX_SCALE
Unsafe'ARRAY_BYTE_BASE_OFFSET
Unsafe'ARRAY_BYTE_INDEX_SCALE
Unsafe'ARRAY_CHAR_BASE_OFFSET
Unsafe'ARRAY_CHAR_INDEX_SCALE
Unsafe'ARRAY_INT_BASE_OFFSET
Unsafe'ARRAY_INT_INDEX_SCALE
Unsafe'ARRAY_LONG_BASE_OFFSET
Unsafe'ARRAY_LONG_INDEX_SCALE
Unsafe'ARRAY_OBJECT_BASE_OFFSET
Unsafe'ARRAY_OBJECT_INDEX_SCALE
Unsafe'ARRAY_SHORT_BASE_OFFSET
Unsafe'ARRAY_SHORT_INDEX_SCALE
UnsafeAccessNode'new-6
UnsafeCompareAndSwapNode'new-6
UnsafeLoadCacheEntry'new-3
UnsafeLoadTemplates''lower-3
UnsafeLoadTemplates'new-0
UnsignedDivNode'create-2
UnsignedDivNode'new-2
UnsignedLong''asLong-1
UnsignedLong''equals-2
UnsignedLong''isLessOrEqualTo-2
UnsignedLong''isLessThan-2
UnsignedLong''minus-2
UnsignedLong''plus-2
UnsignedLong''times-2
UnsignedLong''wrappingPlus-2
UnsignedLong''wrappingTimes-2
UnsignedLong'new-1
UnsignedMath'aboveOrEqual-2i
UnsignedMath'aboveOrEqual-2l
UnsignedMath'aboveThan-2i
UnsignedMath'aboveThan-2l
UnsignedMath'belowOrEqual-2i
UnsignedMath'belowOrEqual-2l
UnsignedMath'belowThan-2i
UnsignedMath'belowThan-2l
UnsignedMulHighNode'new-2
UnsignedRemNode'canonical-4
UnsignedRemNode'create-2
UnsignedRemNode'new-2
UnsignedRightShiftNode'create-2
UnsignedRightShiftNode'new-2
Unsupported'new-2
UseEntry''setValue-2
UseEntry'new-3
UsePosList''add-3
UsePosList''registerPriority-2
UsePosList''removeLowestUsePos-1
UsePosList''setRegisterPriority-3
UsePosList''size-1
UsePosList''splitAt-2
UsePosList''usePos-2
UsePosList'new-1i
UseTrappingNullChecksPhase'new-0
Utf8'new-1
VMConfigNode'cardTableAddress-0
VMConfigNode'isCardTableAddressConstant-0
VMConfigNode'logOfHeapRegionGrainBytes-0
VMConfigNode'new-0
VMConfigNode'new-2
VMConstOp'new-3
ValueAnchorNode''removeAnchoredNode-1
ValueAnchorNode'new-1
ValueCompareAndSwapNode'new-4
ValueCompareAndSwapNode'new-5
ValueFieldInfo'new-5
ValueMergeUtil'mergeReturns-2
ValueMergeUtil'mergeValueProducers-4
ValueNode''asConstant-1
ValueNode''asJavaConstant-1
ValueNode''getStackKind-1
ValueNode''hasUsagesOtherThan-3
ValueNode''isJavaConstant-1
ValueNode''isNullConstant-1
ValueNode''setStamp-2
ValueNode''updateStamp-2
ValueNode'IS_CONSTANT
ValueNode'new-1
ValuePhiNode'new-2
ValuePhiNode'new-3
ValueProxyNode'new-2
Values''getFlags-2
Values''getValue-3
Values''setValue-4
Values'new-1
Variable'new-2
VariableMap''filter-2
VariableMap''forEach-2
VariableMap''get-2
VariableMap''put-3
VariableMap''remove-2
VariableMap'new-0
VirtualArrayNode'entryIndexForOffset-4
VirtualArrayNode'new-2
VirtualBoxingNode''getBoxedValue-2
VirtualBoxingNode'new-2
VirtualInstanceNode''field-2
VirtualInstanceNode''fieldIndex-2
VirtualInstanceNode''getFields-1
VirtualInstanceNode'new-2
VirtualInstanceNode'new-3
VirtualObjectNode''resetObjectId-1
VirtualObjectNode''setObjectId-2
VirtualObjectNode'new-2
VirtualObjectState'new-2
VirtualStackSlot'new-2
VirtualState'new-0
VirtualizableInvokeMacroNode'new-5*
VirtualizerTool''reset-5
VirtualizerTool'new-1
VoidStamp'instance
Word''aboveOrEqual-2i
Word''aboveOrEqual-2w
Word''aboveThan-2i
Word''aboveThan-2w
Word''add-2i
Word''add-2w
Word''and-2i
Word''and-2w
Word''belowOrEqual-2i
Word''belowOrEqual-2w
Word''belowThan-2i
Word''belowThan-2w
Word''compareAndSwapInt-5
Word''compareAndSwapLong-5
Word''compareAndSwapObject-5
Word''compareAndSwapWord-5
Word''equal-2i
Word''equal-2w
Word''greaterOrEqual-2i
Word''greaterOrEqual-2w
Word''greaterThan-2i
Word''greaterThan-2w
Word''initializeLong-4i
Word''initializeLong-4w
Word''isNonNull-1
Word''isNull-1
Word''lessOrEqual-2i
Word''lessOrEqual-2w
Word''lessThan-2i
Word''lessThan-2w
Word''logicCompareAndSwapInt-5i
Word''logicCompareAndSwapInt-5w
Word''logicCompareAndSwapLong-5i
Word''logicCompareAndSwapLong-5w
Word''logicCompareAndSwapObject-5i
Word''logicCompareAndSwapObject-5w
Word''logicCompareAndSwapWord-5
Word''multiply-2i
Word''multiply-2w
Word''not-1
Word''notEqual-2i
Word''notEqual-2w
Word''or-2i
Word''or-2w
Word''rawValue-1
Word''readByte-2i
Word''readByte-2w
Word''readByte-3i
Word''readByte-3w
Word''readChar-2i
Word''readChar-2w
Word''readChar-3i
Word''readChar-3w
Word''readInt-2i
Word''readInt-2w
Word''readInt-3i
Word''readInt-3w
Word''readLong-2i
Word''readLong-2w
Word''readLong-3i
Word''readLong-3w
Word''readObject-2
Word''readObject-3ib
Word''readObject-3il
Word''readShort-2i
Word''readShort-2w
Word''readShort-3i
Word''readShort-3w
Word''readWord-2i
Word''readWord-2w
Word''readWord-3i
Word''readWord-3w
Word''shiftLeft-2i
Word''shiftLeft-2w
Word''signedDivide-2i
Word''signedDivide-2w
Word''signedRemainder-2i
Word''signedRemainder-2w
Word''signedShiftRight-2i
Word''signedShiftRight-2w
Word''subtract-2i
Word''subtract-2w
Word''unbox-1
Word''unsignedDivide-2i
Word''unsignedDivide-2w
Word''unsignedRemainder-2i
Word''unsignedRemainder-2w
Word''unsignedShiftRight-2i
Word''unsignedShiftRight-2w
Word''writeByte-3i
Word''writeByte-3w
Word''writeByte-4i
Word''writeByte-4w
Word''writeChar-3i
Word''writeChar-3w
Word''writeChar-4i
Word''writeChar-4w
Word''writeInt-3i
Word''writeInt-3w
Word''writeInt-4i
Word''writeInt-4w
Word''writeLong-3i
Word''writeLong-3w
Word''writeLong-4i
Word''writeLong-4w
Word''writeObject-3
Word''writeObject-4
Word''writeShort-3i
Word''writeShort-3w
Word''writeShort-4i
Word''writeShort-4w
Word''writeWord-3i
Word''writeWord-3w
Word''writeWord-4i
Word''writeWord-4w
Word''xor-2i
Word''xor-2w
Word'box-1
WordCastNode'addressToWord-2
WordCastNode'new-2
WordCastNode'objectToWord-2
WordCastNode'wordToObject-2
WordCastNode'wordToObjectNonNull-2
WordFactory'nullPointer-0
WordFactory'signed-1i
WordFactory'signed-1l
WordFactory'unsigned-1i
WordFactory'unsigned-1l
WordFactory'zero-0
WordFactoryOpcode'FROM_SIGNED
WordFactoryOpcode'FROM_UNSIGNED
WordFactoryOpcode'ZERO
WordOpcode'CAS_POINTER
WordOpcode'COMPARISON
WordOpcode'FROM_ADDRESS
WordOpcode'FROM_OBJECT
WordOpcode'INITIALIZE
WordOpcode'IS_NON_NULL
WordOpcode'IS_NULL
WordOpcode'NODE_CLASS
WordOpcode'NOT
WordOpcode'READ_BARRIERED
WordOpcode'READ_HEAP
WordOpcode'READ_OBJECT
WordOpcode'READ_POINTER
WordOpcode'TO_OBJECT
WordOpcode'TO_OBJECT_NON_NULL
WordOpcode'TO_RAW_VALUE
WordOpcode'WRITE_BARRIERED
WordOpcode'WRITE_OBJECT
WordOpcode'WRITE_POINTER
WordOperationPlugin'fromSigned-2
WordOperationPlugin'fromUnsigned-2
WordOperationPlugin'makeAddress-3
WordOperationPlugin'toUnsigned-3
WordOperationPlugin'new-0
WordTypes'asKind-1
WordTypes'getWordStamp-1
WordTypes'isWord-1j
WordTypes'isWord-1v
WordTypes'isWordOperation-1
WordTypes'klassPointer
WordTypes'word
WordTypes'wordKind
WorkListEntry'new-2
WriteBarrier'new-0
WriteBarrierAdditionPhase'new-0
WriteBarrierTemplates'new-1
WriteNode'new-4
Xor'new-2
XorNode'create-2
XorNode'new-2
ZeroData'create-2
ZeroData'new-2
ZeroExtend'new-0
ZeroExtendNode'create-2
ZeroExtendNode'create-3
ZeroExtendNode'create-4
ZeroExtendNode'new-2
ZeroExtendNode'new-4
)

;;;
 ; A snippet is a Graal graph expressed as a Java source method. Snippets are used for lowering
 ; nodes that have runtime dependent semantics (e.g. the CHECKCAST bytecode).
 ;;
(ยง annotation Snippet
)

;;;
 ; Denotes a non-optional (non-nil) node input. This should be applied to exactly the fields of a node
 ; that are of type Node or NodeInputList. Nodes that update fields of type Node outside of their
 ; constructor should call Node#updateUsages(Node, Node) just prior to doing the update of the input.
 ;;
(ยง annotation Input
    (ยง value #_"InputType" value InputType'Value)
)

;;;
 ; Denotes an optional (nullable) node input. This should be applied to exactly the fields of a node
 ; that are of type Node or NodeInputList. Nodes that update fields of type Node outside of their
 ; constructor should call Node#updateUsages(Node, Node) just prior to doing the update of the input.
 ;;
(ยง annotation OptionalInput
    (ยง value #_"InputType" value InputType'Value)
)

(ยง annotation Successor
)

;;;
 ; Denotes an injected parameter in a node intrinsic constructor.
 ; If the constructor is called as part of node intrinsification, the node intrinsifier will inject
 ; an argument for the annotated parameter. Injected parameters must precede all non-injected
 ; parameters in a constructor. If the type of the annotated parameter is Stamp, the
 ; {@linkplain Stamp#javaType type} of the injected stamp is the return type of the annotated
 ; method (which cannot be {@code void}).
 ;;
(ยง annotation InjectedNodeParameter
)

(ยง annotation MetaspaceOperation
    (ยง value #_"MetaspaceOpcode" opcode nil)
)

(ยง annotation Use   (ยง value #_"OperandFlag[]" value OperandFlag'REG))
(ยง annotation Alive (ยง value #_"OperandFlag[]" value OperandFlag'REG))
(ยง annotation Temp  (ยง value #_"OperandFlag[]" value OperandFlag'REG))
(ยง annotation Def   (ยง value #_"OperandFlag[]" value OperandFlag'REG))

;;;
 ; Links a method to a canonical operation represented by a WordFactoryOpcode val.
 ;;
(ยง annotation WordFactoryOperation
    (ยง value #_"WordFactoryOpcode" WordFactoryOperation''opcode-1)
)

;;;
 ; Links a method to a canonical operation represented by a WordOpcode val.
 ;;
(ยง annotation WordOperation
    (ยง value #_"Class<? implements ValueNode>" WordOperation''node-1 ValueNode'iface)
    (ยง value #_"boolean" WordOperation''rightOperandIsInt-1 false)
    (ยง value #_"WordOpcode" WordOperation''opcode-1 WordOpcode'NODE_CLASS)
    (ยง value #_"Condition" WordOperation''condition-1 Condition'EQ)
)

(defp AMD64Address)
(defp AMD64AddressNode)
(defp AMD64AddressValue)
(defp AMD64ByteSwapOp)
(defp AMD64CCall)
(defp AMD64ClearRegisterOp)
(defp AMD64DeoptimizeOp)

(defp AMD64HotSpotRestoreRbpOp
    ;;;
     ; The type of location (i.e. stack or register) in which RBP is saved is not known until initial LIR generation
     ; is finished. Until then, we use a placeholder variable so that LIR verification is successful.
     ;;
  #_(ยง def #_"Variable" AMD64HotSpotRestoreRbpOp'PLACEHOLDER (Variable'new-2 (LIRKind'value-1 AMD64Kind/QWORD), Integer/MAX_VALUE))

    (#_"void" AMD64HotSpotRestoreRbpOp'''setSavedRbp-2 [#_"AMD64HotSpotRestoreRbpOp" this, #_"AllocatableValue" value])
)

(defp AMD64HotSpotReturnOp)
(defp AMD64HotSpotStrategySwitchOp)
(defp AMD64ImmOp)
(defp AMD64LFenceOp)
(defp AMD64MIOp)
(defp AMD64MOp)
(defp AMD64MROp)
(defp AMD64MulDivOp)
(defp AMD64MultiStackMove)
(defp AMD64Op)
(defp AMD64PrefetchOp)
(defp AMD64PushPopStackMove)
(defp AMD64RMIOp)
(defp AMD64RMOp)

;;;
 ; Opcode with operand order of either RM or MR for 2 address forms.
 ;;
(defp AMD64RROp
    (#_"void" AMD64RROp'''emit-5 [#_"AMD64RROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src])
)

(defp AMD64RestoreRegistersOp)
(defp AMD64SaveRegistersOp)
(defp AMD64Shift)
(defp AMD64ShiftOp)
(defp AMD64SignExtendOp)
(defp AMD64StackMove)

(defp AMD64SwitchClosure
    (#_"void" AMD64SwitchClosure'''emitComparison-2 [#_"AMD64SwitchClosure" this, #_"Constant" c])
)

(defp AMD64TailcallOp)
(defp Abs)
(defp AbstractAddress)

(defp AbstractBeginNode
    (#_"void" AbstractBeginNode'''prepareDelete-2 [#_"AbstractBeginNode" this, #_"FixedNode" evacuateFrom])
    (#_"Node*" AbstractBeginNode'''anchored-1 [#_"AbstractBeginNode" this])
)

(defp AbstractCompareAndSwapNode)

;;;
 ; This node represents an unconditional explicit request for immediate deoptimization.
 ;
 ; After this node, execution will continue using a fallback execution engine (such as an
 ; interpreter) at the position described by the {@link #stateBefore() deoptimization state}.
 ;;
(defp AbstractDeoptimizeNode
    (#_"ValueNode" AbstractDeoptimizeNode'''getActionAndReason-1 [#_"AbstractDeoptimizeNode" this])
    (#_"ValueNode" AbstractDeoptimizeNode'''getSpeculation-1 [#_"AbstractDeoptimizeNode" this])
)

(defp AbstractEndNode
    (#_"AbstractMergeNode" AbstractEndNode'''merge-1 [#_"AbstractEndNode" this])
)

(defp AbstractFixedGuardNode)
(defp AbstractInlineInfo)
(defp AbstractLocalNode)
(defp AbstractMemoryCheckpoint)

;;;
 ; Denotes the merging of multiple control-flow paths.
 ;;
(defp AbstractMergeNode
    (#_"void" AbstractMergeNode'''deleteEnd-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" end])
    (#_"int" AbstractMergeNode'''phiPredecessorCount-1 [#_"AbstractMergeNode" this])
    (#_"int" AbstractMergeNode'''phiPredecessorIndex-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" pred])
    (#_"AbstractEndNode" AbstractMergeNode'''phiPredecessorAt-2 [#_"AbstractMergeNode" this, #_"int" index])
)

(defp AbstractMoveOp)
(defp AbstractNewObjectNode)

;;;
 ; Type describing all pointers to Java objects.
 ;;
(defp AbstractObjectStamp
    (#_"AbstractObjectStamp" AbstractObjectStamp'''copyWith-5 [#_"AbstractObjectStamp" this, #_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?])
)

;;;
 ; Abstract base class of all pointer types.
 ;;
(defp AbstractPointerStamp
    (#_"AbstractPointerStamp" AbstractPointerStamp'''copyWith-3 [#_"AbstractPointerStamp" this, #_"boolean" never-nil?, #_"boolean" always-nil?])
)

(defp AbstractStateSplit)
(defp AbstractTemplates)
(defp AbstractWriteNode)

(defp Access
    (#_"AddressNode" Access'''getAddress-1 [#_"Access" this])
    (#_"LocationIdentity" Access'''getLocationIdentity-1 [#_"Access" this])
    (#_"boolean" Access'''canNullCheck-1 [#_"Access" this])
)

(defp AccessArrayNode)
(defp AccessFieldNode)
(defp AccessIndexedNode)
(defp AccessMonitorNode)
(defp AcquiredCASLockNode)
(defp Add)
(defp AddNode)
(defp Address)
(defp AddressLowering)
(defp AddressLoweringPhase)

;;;
 ; Base class for nodes that deal with addressing calculation.
 ;;
(defp AddressNode
    (#_"ValueNode" AddressNode'''getBase-1 [#_"AddressNode" this])
    (#_"ValueNode" AddressNode'''getIndex-1 [#_"AddressNode" this])
    ;;;
     ; Constant that is the maximum displacement from the base and index for this address. This value
     ; is used to determine whether using the access as an implicit nil-check on the base is valid.
     ;
     ; @return the maximum distance in bytes from the base that this address can be
     ;;
    (#_"long" AddressNode'''getMaxConstantDisplacement-1 [#_"AddressNode" this])
)

(defp AllocatableRegisters)
(defp AllocatedObjectNode)
(defp Allocator)
(defp AnchoringNode)
(defp And)
(defp AndNode)
(defp Arguments)
(defp ArithmeticOp)
(defp ArithmeticOpTable)

;;;
 ; An ArithmeticOperation is an operation that does primitive value arithmetic without side effect.
 ;;
(defp ArithmeticOperation
    (#_"ArithmeticOp" ArithmeticOperation'''getArithmeticOp-1 [#_"ArithmeticOperation" this])
)

(defp ArithmeticStamp)
(defp ArrayLengthNode)

(defp ArrayLengthProvider
    ;;;
     ; Returns the length of the array described by this node, or nil if it is not available.
     ;;
    (#_"ValueNode" ArrayLengthProvider'''length-1 [#_"ArrayLengthProvider" this])
)

(defp ArrayPlaceholder)
(defp Assembler)
(defp AtomicReadAndAddNode)
(defp AtomicReadAndAddOp)
(defp AtomicReadAndWriteNode)
(defp AtomicReadAndWriteOp)

;;;
 ; Backends can subclass this abstract class and generate code for switch strategies by implementing
 ; the #conditionalJump(int, Condition, Label) method.
 ;;
(defp BaseSwitchClosure
    ;;;
     ; This method generates code for a comparison between the actual value and the constant at
     ; the given index and a condition jump to target.
     ;;
    (#_"void" BaseSwitchClosure'''conditionalJump-4 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition, #_"Label" target])
)

(defp BasicInductionVariable)
(defp BciBlock)
(defp BciBlockMapping)
(defp BeginLockScopeNode)
(defp BeginNode)
(defp BeginStateSplitNode)
(defp BelowOp)

;;;
 ; This sub-interface of Canonicalizable is intended for nodes that have exactly two inputs.
 ; It has an additional #canonical(CanonicalizerTool, Node, Node) method that looks at the given
 ; inputs instead of the current inputs of the node - which can be used to ask "what if this
 ; input is changed to this node" - questions.
 ;
 ; @param <T> the common supertype of all inputs of this node
 ;;
(defp Binary #_"<T implements Node>"
    ;;;
     ; Similar to Canonicalizable#canonical(CanonicalizerTool), except that implementations should act as if the
     ; current input of the node was the given one, i.e. they should never look at the inputs via the this pointer.
     ;;
    (#_"Node" Binary'''canonical-4 [#_"Binary<T>" this, #_"CanonicalizerTool" tool, #_"T" forX, #_"T" forY])
    ;;;
     ; Ensure a canonical ordering of inputs for commutative nodes to improve GVN results.
     ; Order the inputs by increasing Node#id and call Graph#findDuplicate(Node) on the node
     ; if it's currently in a graph. It's assumed that if there was a constant on the left,
     ; it's been moved to the right by other code and that ordering is left alone.
     ;
     ; @return the original node or another node with the same input ordering
     ;;
    (#_"Node" Binary'''maybeCommuteInputs-1 [#_"Binary<T>" this])
)

(defp BinaryArithmetic)

(defp BinaryArithmeticNode #_"<OP>"
    (#_"boolean" BinaryArithmeticNode'''isAssociative-1 [#_"BinaryArithmeticNode<OP>" this])
)

;;;
 ; This sub-interface of Binary is for nodes with two inputs where the operation is commutative.
 ; It is used to improve GVN by trying to merge nodes with the same inputs in different order.
 ;;
(defp BinaryCommutative)

;;;
 ; The BinaryNode class is the base of arithmetic and logic operations with two inputs.
 ;;
(defp BinaryNode
    ;;;
     ; Compute an improved for this node using the passed in stamps. The stamps must be compatible
     ; with the current values of #x and #y. This code is used to provide the default implementation
     ; of #inferStamp() and may be used by external optimizations.
     ;;
    (#_"Stamp" BinaryNode'''foldStamp-3 [#_"BinaryNode" this, #_"Stamp" stampX, #_"Stamp" stampY])
)

;;;
 ; Describes a binary arithmetic operation.
 ;;
(defp BinaryOp #_"<T>"
    ;;;
     ; Applies this operation to {@code a} and {@code b}.
     ;
     ; @return the result of applying this operation or nil if applying it would raise
     ;         an exception (e.g. ArithmeticException for dividing by 0)
     ;;
    (#_"Constant" BinaryOp'''foldConstant-3 [#_"BinaryOp<T>" this, #_"Constant" a, #_"Constant" b])
    ;;;
     ; Apply the operation to two Stamps.
     ;;
    (#_"Stamp" BinaryOp'''foldStamp-3 [#_"BinaryOp<T>" this, #_"Stamp" a, #_"Stamp" b])
    ;;;
     ; Check whether a Constant is a neutral element for this operation. A neutral
     ; element is any element {@code n} where {@code a . n == a} for all a.
     ;
     ; @param n the Constant that should be tested
     ; @return true iff for all {@code a}: {@code a . n == a}
     ;;
    (#_"boolean" BinaryOp'''isNeutral-2 [#_"BinaryOp<T>" this, #_"Constant" n])
    ;;;
     ; Check whether this operation has a zero {@code z == a . a} for each a. Examples of
     ; operations having such an element are subtraction and exclusive-or. Note that this
     ; may be different from the numbers tested by #isNeutral.
     ;
     ; @param stamp a Stamp
     ; @return a unique {@code z} such that {@code z == a . a} for each {@code a} in
     ;         {@code stamp} if it exists, otherwise nil
     ;;
    (#_"Constant" BinaryOp'''getZero-2 [#_"BinaryOp<T>" this, #_"Stamp" stamp])
)

(defp BinaryOpLogicNode
    (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForX-4 [#_"BinaryOpLogicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp])
    (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForY-4 [#_"BinaryOpLogicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp])
    (#_"TriState" BinaryOpLogicNode'''tryFold-3 [#_"BinaryOpLogicNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp])
)

(defp BinaryStrategy)
(defp BindToRegisterNode)
(defp BindToRegisterOp)
(defp BitCountNode)
(defp BitMap2D)
(defp BlackholeNode)
(defp BlackholeOp)
(defp Block)
(defp BlockClosure)
(defp BlockData)

;;;
 ; A block delimiter. Every well formed block must contain exactly one such operation and it
 ; must be the last operation in the block.
 ;;
(defp BlockEndOp)

(defp BlockIteratorClosure #_"<T>"
    (#_"T" BlockIteratorClosure'''getInitialState-1 [#_"BlockIteratorClosure<T>" this])
    (#_"T" BlockIteratorClosure'''processBlock-3 [#_"BlockIteratorClosure<T>" this, #_"Block" block, #_"T" currentState])
    (#_"T" BlockIteratorClosure'''merge-3 [#_"BlockIteratorClosure<T>" this, #_"Block" merge, #_"List<T>" states])
    (#_"T" BlockIteratorClosure'''cloneState-2 [#_"BlockIteratorClosure<T>" this, #_"T" oldState])
    (#_"List<T>" BlockIteratorClosure'''processLoop-3 [#_"BlockIteratorClosure<T>" this, #_"Loop" _loop, #_"T" initialState])
)

(defp BlockLoopInfo)
(defp BlockMap)
(defp BlockOrderComparator)
(defp BlockScope)
(defp BlockStates)
(defp BoxNode)
(defp BoxingTemplates)
(defp BranchOp)

;;;
 ; An interface for accessing the bytecode properties of a ResolvedJavaMethod that allows for
 ; different properties than those returned by ResolvedJavaMethod. Since the bytecode accessed
 ; directly from ResolvedJavaMethod may have been subject to bytecode instrumentation and VM
 ; rewriting, this indirection can be used to enable access to the original bytecode of a method
 ; (i.e. as defined in a class file).
 ;;
(defp Bytecode
    (#_"ResolvedJavaMethod" Bytecode'''getMethod-1 [#_"Bytecode" this])
    (#_"byte[]" Bytecode'''getCode-1 [#_"Bytecode" this])
    (#_"int" Bytecode'''getCodeSize-1 [#_"Bytecode" this])
    (#_"int" Bytecode'''getMaxStackSize-1 [#_"Bytecode" this])
    (#_"int" Bytecode'''getMaxLocals-1 [#_"Bytecode" this])
    (#_"ConstantPool" Bytecode'''getConstantPool-1 [#_"Bytecode" this])
)

(defp BytecodeLookupSwitch)
(defp BytecodeParser)

;;;
 ; Provides a Bytecode object for interposing on the bytecode of a ResolvedJavaMethod
 ; (i.e. potentially getting bytecode different than ResolvedJavaMethod#getCode()).
 ;;
(defp BytecodeProvider
    (#_"Bytecode" BytecodeProvider'''getBytecode-2 [#_"BytecodeProvider" this, #_"ResolvedJavaMethod" method])
)

(defp BytecodeStream)

;;;
 ; An abstract class that provides the state and methods common to Bytecodes#LOOKUPSWITCH and
 ; Bytecodes#TABLESWITCH instructions.
 ;;
(defp BytecodeSwitch
    ;;;
     ; Gets the key at {@code i}'th switch target index.
     ;
     ; @param i the switch target index
     ; @return the key at {@code i}'th switch target index
     ;;
    (#_"int" BytecodeSwitch'''keyAt-2 [#_"BytecodeSwitch" this, #_"int" i])
    ;;;
     ; Gets the offset from the start of the switch instruction for the {@code i}'th switch target.
     ;
     ; @param i the switch target index
     ; @return the offset to the {@code i}'th switch target
     ;;
    (#_"int" BytecodeSwitch'''offsetAt-2 [#_"BytecodeSwitch" this, #_"int" i])
    ;;;
     ; Gets the number of switch targets.
     ;
     ; @return the number of switch targets
     ;;
    (#_"int" BytecodeSwitch'''numberOfCases-1 [#_"BytecodeSwitch" this])
    ;;;
     ; Gets the total size in bytes of the switch instruction.
     ;
     ; @return the total size in bytes of the switch instruction
     ;;
    (#_"int" BytecodeSwitch'''size-1 [#_"BytecodeSwitch" this])
)

(defp BytecodeTableSwitch)
(defp CFOptimizer)
(defp CLOptimization)
(defp CRuntimeCallEpilogueOp)
(defp CRuntimeCallPrologueOp)

(defp CacheEntry #_"<T>"
    (#_"CacheEntry<T>" CacheEntry'''duplicateWithObject-2 [#_"CacheEntry<T>" this, #_"ValueNode" newObject])
    (#_"boolean" CacheEntry'''conflicts-2 [#_"CacheEntry<T>" this, #_"LocationIdentity" other])
    (#_"LocationIdentity" CacheEntry'''getIdentity-1 [#_"CacheEntry<T>" this])
)

(defp CallOp)
(defp CallTargetNode)
(defp CallsiteHolder)
(defp CanonicalCondition)

;;;
 ; Nodes can implement Canonicalizable or one of the two sub-interfaces Unary and
 ; Binary to provide local optimizations like constant folding and strength reduction.
 ; Implementations should return a replacement that is always semantically correct for
 ; the given inputs, or "this" if they do not see an opportunity for improvement.
 ;
 ; <b>Implementations of Canonicalizable#canonical(CanonicalizerTool) or the equivalent
 ; methods of the two sub-interfaces must not have any side effects.</b>
 ; They are not allowed to change inputs, successors or properties of any node (including
 ; the current one) and they also cannot add new nodes to the graph.
 ;
 ; In addition to pre-existing nodes they can return newly created nodes, which will be added
 ; to the graph automatically if (and only if) the effects of the canonicalization are committed.
 ; Non-cyclic graphs (DAGs) of newly created nodes (i.e. one newly created node with an input
 ; to another newly created node) will be handled correctly.
 ;;
(defp Canonicalizable
    ;;;
     ; Implementations of this method can provide local optimizations like constant folding and
     ; strength reduction. Implementations should look at the properties and inputs of the current
     ; node and determine if there is a more optimal and always semantically correct replacement.
     ;
     ; The return value determines the effect that the canonicalization will have:
     ;
     ; (1) Returning an pre-existing node will replace the current node with the given one.
     ; (2) Returning a newly created node (that was not yet added to the graph) will replace the
     ; current node with the given one, after adding it to the graph. If both the replacement and
     ; the replacee are anchored in control flow (fixed nodes), the replacement will be added to the
     ; control flow. It is invalid to replace a non-fixed node with a newly created fixed node
     ; (because its placement in the control flow cannot be determined without scheduling).
     ; (3) Returning nil will delete the current node and replace it with nil at all usages.
     ; Note that it is not necessary to delete floating nodes that have no more usages
     ; this way - they will be deleted automatically.
     ;
     ; @param tool provides access to runtime interfaces like MetaAccessProvider
     ;;
    (#_"Node" Canonicalizable'''canonical-2 [#_"Canonicalizable" this, #_"CanonicalizerTool" tool])
)

(defp CanonicalizableLocation
    (#_"ValueNode" CanonicalizableLocation'''canonicalizeRead-4 [#_"CanonicalizableLocation" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object])
)

(defp CanonicalizedCondition)
(defp CanonicalizerInstance)
(defp CanonicalizerPhase)

(defp CanonicalizerTool
    (#_"boolean" CanonicalizerTool'''canonicalizeReads-1 [#_"CanonicalizerTool" this])
    ;;;
     ; If this method returns false, not all {@link Node#usages() usages of a node} are yet available.
     ; So a node must not be canonicalized base on, e.g. information returned from Node#hasNoUsages().
     ;;
    (#_"boolean" CanonicalizerTool'''allUsagesAvailable-1 [#_"CanonicalizerTool" this])
    ;;;
     ; Indicates the smallest width for comparing an integer value on the target platform.
     ; If this method returns nil, then there is no known smallest compare width.
     ;;
    (#_"Integer" CanonicalizerTool'''smallestCompareWidth-1 [#_"CanonicalizerTool" this])
)

(defp ChainedNodeEventListener)
(defp ClassGetHubNode)
(defp ClassRef)
(defp Classfile)
(defp ClassfileBytecode)
(defp ClassfileBytecodeProvider)

(defp ClassfileConstant
    ;;;
     ; Loads the type, if any, referenced at a specified entry.
     ;;
    (#_"void" ClassfileConstant'''loadReferencedType-4 [#_"ClassfileConstant" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode])
)

(defp ClassfileConstantPool)
(defp CodeBuffer)
(defp CollectVirtualObjectsClosure)
(defp CommitAllocationNode)
(defp CommutativeTwoOp)
(defp CompareAndSwapOp)
(defp CompareNode)

(defp CompareOp
    (#_"LogicNode" CompareOp'''canonical-5 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY])
    (#_"LogicNode" CompareOp'''canonicalizeSymmetricConstant-6 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?])
    (#_"LogicNode" CompareOp'''optimizeNormalizeCompare-5 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?])
    (#_"LogicNode" CompareOp'''duplicateModified-3 [#_"CompareOp" this, #_"ValueNode" newW, #_"ValueNode" newY])
)

(defp CompilationResult)

;;;
 ; Base class to represent values that need to be stored in more than one register. This is mainly
 ; intended to support addresses and not general arbitrary nesting of composite values. Because of
 ; the possibility of sharing of CompositeValues they should be immutable.
 ;;
(defp CompositeValue
    ;;;
     ; Invoke {@code proc} on each Value element of this CompositeValue.
     ; If {@code proc} replaces any value then a new CompositeValue should be returned.
     ;
     ; @return the original CompositeValue or a copy with any modified values
     ;;
    (#_"CompositeValue" CompositeValue'''forEachComponent-4 [#_"CompositeValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"ValueProcedure" proc])
    (#_"void" CompositeValue'''visitEachComponent-4 [#_"CompositeValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"ValueConsumer" proc])
)

(defp CompressEncoding)
(defp CompressPointerOp)

;;;
 ; Compress or uncompress an oop or metaspace pointer.
 ;;
(defp CompressionNode
    (#_"Constant" CompressionNode'''compress-2 [#_"CompressionNode" this, #_"Constant" constant])
    (#_"Constant" CompressionNode'''uncompress-2 [#_"CompressionNode" this, #_"Constant" constant])
    (#_"Stamp" CompressionNode'''mkStamp-2 [#_"CompressionNode" this, #_"Stamp" input])
)

(defp ComputeInliningRelevance)
(defp ComputeLoopFrequenciesClosure)
(defp ComputeLoopFrequencyPhase)
(defp ComputeObjectAddressNode)
(defp CondMoveOp)
(defp CondSetOp)
(defp Condition)
(defp ConditionAnchorNode)
(defp ConditionFlag)
(defp ConditionalEliminationInstance)
(defp ConditionalEliminationPhase)
(defp ConditionalNode)
(defp ConstOp)
(defp ConstantLoadOptimization)
(defp ConstantNode)
(defp ConstantTree)
(defp ConstantTreeAnalyzer)
(defp ConstantValue)
(defp ConsumerConstOp)
(defp ConsumerOp)
(defp ControlFlowAnchorNode)

;;;
 ; Marker interface for nodes that prevents control flow optimizations. The node should never be duplicated.
 ;;
(defp ControlFlowAnchored)

(defp ControlFlowGraph)
(defp ControlFlowOptimizer)
(defp ControlSinkNode)

;;;
 ; The ControlSplitNode is a base class for all instructions that split the control flow (i.e. have more than one successor).
 ;;
(defp ControlSplitNode
    (#_"double" ControlSplitNode'''probability-2 [#_"ControlSplitNode" this, #_"AbstractBeginNode" successor])
    ;;;
     ; Attempts to set the probability for the given successor to the passed value (which has to be
     ; in the range of 0.0 and 1.0). Returns whether setting the probability was successful.
     ;;
    (#_"boolean" ControlSplitNode'''setProbability-3 [#_"ControlSplitNode" this, #_"AbstractBeginNode" successor, #_"double" value])
    ;;;
     ; Primary successor of the control split. Data dependencies on the node have to be scheduled in
     ; the primary successor. Returns nil if data dependencies are not expected.
     ;
     ; @return the primary successor
     ;;
    (#_"AbstractBeginNode" ControlSplitNode'''getPrimarySuccessor-1 [#_"ControlSplitNode" this])
    ;;;
     ; Returns the number of successors.
     ;;
    (#_"int" ControlSplitNode'''getSuccessorCount-1 [#_"ControlSplitNode" this])
)

(defp ConvertDeoptimizeToGuardPhase)

;;;
 ; Represents a conversion between primitive types.
 ;;
(defp ConvertNode
    (#_"ValueNode" ConvertNode'''getValue-1 [#_"ConvertNode" this])
    (#_"Constant" ConvertNode'''convert-2 [#_"ConvertNode" this, #_"Constant" constant])
    (#_"Constant" ConvertNode'''reverse-2 [#_"ConvertNode" this, #_"Constant" constant])
    ;;;
     ; Checks whether a nil-check may skip the conversion. This is true if in the conversion NULL
     ; is converted to NULL and if it is the only value converted to NULL.
     ;
     ; @return whether a nil-check may skip the conversion
     ;;
    (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"ConvertNode" this])
    ;;;
     ; Check whether a conversion is lossless.
     ;
     ; @return true iff reverse(convert(c)) == c for all c
     ;;
    (#_"boolean" ConvertNode'''isLossless-1 [#_"ConvertNode" this])
    ;;;
     ; Check whether a conversion preserves comparison order.
     ;
     ; @param op a comparison operator
     ; @return true iff (c1 op c2) == (convert(c1) op convert(c2)) for all c1, c2
     ;;
    (#_"boolean" ConvertNode'''preservesOrder-2 [#_"ConvertNode" this, #_"CanonicalCondition" op])
    ;;;
     ; Check whether a conversion preserves comparison order against a particular constant value.
     ;
     ; @param op a comparison operator
     ; @return true iff (c1 op value) == (convert(c1) op convert(value)) for value and all c1
     ;;
    (#_"boolean" ConvertNode'''preservesOrder-3 [#_"ConvertNode" this, #_"CanonicalCondition" op, #_"Constant" value])
)

(defp CountLeadingZerosNode)
(defp CountTrailingZerosNode)
(defp CountedLoopInfo)
(defp CurrentInvoke)
(defp CurrentLockNode)

(defp Data
    (#_"void" Data'''emit-3 [#_"Data" this, #_"ByteBuffer" buffer, #_"Patches" patches])
)

(defp DataOp)
(defp DataSection)
(defp DataTwoOp)
(defp DeadCodeEliminationPhase)
(defp DefUseTree)
(defp DefaultLoopPolicies)
(defp DefaultSimplifierTool)
(defp DeferredExit)

;;;
 ; Interface for nodes that need a FrameState for deoptimizing to a point after their execution.
 ;;
(defp DeoptAfter)

;;;
 ; Interface for nodes that need a FrameState for deoptimizing to a point before their execution.
 ;;
(defp DeoptBefore
    ;;;
     ; Sets the FrameState describing the program state before the execution of this node.
     ;;
    (#_"void" DeoptBefore'''setStateBefore-2 [#_"DeoptBefore" this, #_"FrameState" state])
)

;;;
 ; Interface for nodes that need a special FrameState for deoptimizing during their execution (e.g. InvokeNode).
 ;;
(defp DeoptDuring
    ;;;
     ; Sets the FrameState describing the program state during the execution of this node.
     ;;
    (#_"void" DeoptDuring'''setStateDuring-2 [#_"DeoptDuring" this, #_"FrameState" state])
    ;;;
     ; Compute the FrameState describing the program state during the execution of this node from
     ; an input FrameState describing the program state after finishing the execution of this node.
     ;;
    (#_"void" DeoptDuring'''computeStateDuring-2 [#_"DeoptDuring" this, #_"FrameState" stateAfter])
)

(defp DeoptimizationGroupingPhase)
(defp DeoptimizeCallerNode)
(defp DeoptimizeCallerOp)
(defp DeoptimizeNode)
(defp DeoptimizingFixedWithNextNode)

;;;
 ; Shared interface to capture core methods of AbstractFixedGuardNode and GuardNode.
 ;;
(defp DeoptimizingGuard
    (#_"LogicNode" DeoptimizingGuard'''getCondition-1 [#_"DeoptimizingGuard" this])
    (#_"void" DeoptimizingGuard'''setCondition-3 [#_"DeoptimizingGuard" this, #_"LogicNode" x, #_"boolean" negated?])
)

;;;
 ; Interface implemented by nodes which may need deoptimization information.
 ;;
(defp DeoptimizingNode
    (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"DeoptimizingNode" this])
)

(defp DerivedConvertedInductionVariable)
(defp DerivedInductionVariable)
(defp DerivedOffsetInductionVariable)
(defp DerivedScaledInductionVariable)
(defp DirectCallOp)
(defp DirectCallTargetNode)
(defp DirectFarForeignCallOp)
(defp DirectNearForeignCallOp)
(defp DirectStaticCallOp)
(defp DirectVirtualCallOp)
(defp Div)
(defp DominatorOptimizationProblem)
(defp DummyGuardHandle)

(defp DuplicationReplacement
    (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original])
)

(defp DynamicDeoptimizeNode)
(defp EMOptimizer)
(defp EarlyReadEliminationPhase)
(defp EdgeInfo)
(defp EdgeMoveOptimizer)

(defp EdgeVisitor
    (#_"Node" EdgeVisitor'''apply-3 [#_"EdgeVisitor" this, #_"Node" source, #_"Node" target])
)

;;;
 ; Describes Node fields representing the set of inputs for the node or the set of the node's successors.
 ;;
(defp Edges
    (#_"void" Edges'''update-4 [#_"Edges" this, #_"Node" node, #_"Node" oldValue, #_"Node" newValue])
)

(defp Effect
    (#_"boolean" Effect'''isCfgKill-1 [#_"Effect" this])
    (#_"void" Effect'''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes])
    (#_"void" Effect'''apply-2 [#_"Effect" this, #_"Graph" graph])
)

;;;
 ; An EffectList can be used to maintain a list of Effects and backtrack to a previous
 ; state by truncating the list.
 ;;
(defp EffectList
    (#_"void" EffectList'''clear-1 [#_"EffectList" this])
)

(defp EffectsBlockState #_"<T implements EffectsBlockState<T>>"
    (#_"boolean" EffectsBlockState'''equivalentTo-2 [#_"EffectsBlockState<T>" this, #_"T" other])
)

(defp EffectsClosure #_"<T implements EffectsBlockState<T>>"
    (#_"boolean" EffectsClosure'''needsApplyEffects-1 [#_"EffectsClosure<T>" this])
    (#_"void" EffectsClosure'''applyEffects-1 [#_"EffectsClosure<T>" this])
    ;;;
     ; Collects the effects of virtualizing the given node.
     ;
     ; @return true if the effects include removing the node, false otherwise
     ;;
    (#_"boolean" EffectsClosure'''processNode-5 [#_"EffectsClosure<T>" this, #_"Node" node, #_"T" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode])
    (#_"T" EffectsClosure'''stripKilledLoopLocations-3 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState])
    (#_"void" EffectsClosure'''processKilledLoopLocations-4 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState, #_"T" mergedStates])
    (#_"void" EffectsClosure'''processInitialLoopState-3 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState])
    (#_"void" EffectsClosure'''processLoopExit-5 [#_"EffectsClosure<T>" this, #_"LoopExitNode" exitNode, #_"T" initialState, #_"T" exitState, #_"GraphEffectList" effects])
    (#_"MergeProcessor<T>" EffectsClosure'''createMergeProcessor-2 [#_"EffectsClosure<T>" this, #_"Block" merge])
)

(defp EffectsPhase
    (#_"EffectsClosure" EffectsPhase'''createEffectsClosure-3 [#_"EffectsPhase" this, #_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg])
)

(defp EffortClosure)
(defp EndLockScopeNode)
(defp EndNode)
(defp EpilogueBlockEndOp)
(defp EscapeObjectState)
(defp ExactInlineInfo)
(defp ExecutableRef)
(defp ExpandLogicPhase)
(defp ExplodeLoopNode)
(defp FastAcquireBiasedLockNode)
(defp FieldInfo)
(defp FieldKey)
(defp FieldLocationIdentity)
(defp FieldRef)
(defp Fields)
(defp FieldsCache)

;;;
 ; Scans the fields in a class hierarchy.
 ;;
(defp FieldsScanner
    (#_"void" FieldsScanner'''scanField-3 [#_"FieldsScanner" this, #_"Field" field, #_"long" offset])
)

(defp FinalClosure)
(defp FinalFieldBarrierNode)
(defp FinalState)
(defp FixPointIntervalBuilder)
(defp FixReadsClosure)
(defp FixReadsPhase)
(defp FixedAccessNode)
(defp FixedBinaryNode)
(defp FixedGuardNode)
(defp FixedNode)
(defp FixedNodeProbabilityCache)
(defp FixedTarget)
(defp FixedValueAnchorNode)
(defp FixedWithNextNode)

;;;
 ; An FixedAccessNode that can be converted to a FloatingAccessNode.
 ;;
(defp FloatableAccessNode
    (#_"FloatingAccessNode" FloatableAccessNode'''asFloatingNode-2 [#_"FloatableAccessNode" this, #_"MemoryNode" lastLocationAccess])
)

(defp FloatingAccessNode
    (#_"FixedAccessNode" FloatingAccessNode'''asFixedNode-1 [#_"FloatingAccessNode" this])
)

(defp FloatingAnchoredNode)
(defp FloatingGuardedNode)
(defp FloatingNode)
(defp FloatingReadClosure)
(defp FloatingReadNode)
(defp FloatingReadPhase)
(defp ForeignCallDescriptor)
(defp ForeignCallLinkage)
(defp ForeignCallOp)
(defp ForeignCalls)
(defp FrameContext)
(defp FrameMap)
(defp FrameMapBuilder)
(defp FrameState)
(defp FrameStateAssignmentClosure)
(defp FrameStateAssignmentPhase)
(defp FrameStateBuilder)
(defp G1PostWriteBarrier)
(defp G1PreWriteBarrier)
(defp G1ReferentFieldReadBarrier)
(defp GetClassNode)
(defp GetObjectAddressNode)
(defp Graph)
(defp GraphBuilderInstance)
(defp GraphBuilderPhase)
(defp GraphEffectList)
(defp GuardLoweringPhase)
(defp GuardNode)
(defp GuardPhiNode)
(defp GuardProxyNode)

; @FunctionalInterface
(defp GuardRewirer
    ;;;
     ; Called if the condition could be proven to have a constant value ({@code result}) under {@code guard}.
     ;
     ; @param guard the guard whose result is proven
     ; @param result the known result of the guard
     ; @param newInput new input to pi nodes depending on the new guard
     ; @return whether the transformation could be applied
     ;;
    (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" this, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput])
)

;;;
 ; A node that may be guarded by a guarding node.
 ;;
(defp GuardedNode
    (#_"GuardingNode" GuardedNode'''getGuard-1 [#_"GuardedNode" this])
    (#_"void" GuardedNode'''setGuard-2 [#_"GuardedNode" this, #_"GuardingNode" guard])
)

(defp GuardingNode)
(defp HashSetNodeEventListener)

;;;
 ; Marker interface for nodes that accesses the heap.
 ;;
(defp HeapAccess)

(defp HeapBaseNode)
(defp HighTier)
(defp HotSpotCompressionNode)
(defp HotSpotDirectCallTargetNode)
(defp HotSpotNarrowOopStamp)
(defp HotSpotNodePlugin)
(defp HotSpotSwitchClosure)
(defp HubGetClassNode)
(defp IfNode)
(defp IllegalStamp)

(defp ImplicitNullCheck
    (#_"boolean" ImplicitNullCheck'''makeNullCheckFor-3 [#_"ImplicitNullCheck" this, #_"Value" value, #_"int" implicitNullCheckLimit])
)

(defp IncrementalCanonicalizerPhase)

;;;
 ; Marker interface for nodes that contains other nodes. When the inputs to this node changes,
 ; users of this node should also be placed on the work list for canonicalization.
 ;;
(defp IndirectCanonicalization)

;;;
 ; This class describes a value node that is an induction variable in a counted loop.
 ;;
(defp InductionVariable
    (#_"Graph" InductionVariable'''graph-1 [#_"InductionVariable" this])
    (#_"Direction" InductionVariable'''direction-1 [#_"InductionVariable" this])
    ;;;
     ; Returns the value node that is described by this induction variable.
     ;;
    (#_"ValueNode" InductionVariable'''valueNode-1 [#_"InductionVariable" this])
    ;;;
     ; Returns the node that gives the initial value of this induction variable.
     ;;
    (#_"ValueNode" InductionVariable'''initNode-1 [#_"InductionVariable" this])
    ;;;
     ; Returns the stride of the induction variable. The stride is the value that is added to
     ; the induction variable at each iteration.
     ;;
    (#_"ValueNode" InductionVariable'''strideNode-1 [#_"InductionVariable" this])
    (#_"boolean" InductionVariable'''isConstantInit-1 [#_"InductionVariable" this])
    (#_"boolean" InductionVariable'''isConstantStride-1 [#_"InductionVariable" this])
    (#_"long" InductionVariable'''constantInit-1 [#_"InductionVariable" this])
    (#_"long" InductionVariable'''constantStride-1 [#_"InductionVariable" this])
    (#_"boolean" InductionVariable'''isConstantExtremum-1 [#_"InductionVariable" this])
    (#_"long" InductionVariable'''constantExtremum-1 [#_"InductionVariable" this])
    ;;;
     ; Returns the exit value of the induction variable. The exit value is the value of the
     ; induction variable at the loop exit.
     ;;
    (#_"ValueNode" InductionVariable'''exitValueNode-1 [#_"InductionVariable" this])
    ;;;
     ; Deletes any nodes created within the scope of this object that have no usages.
     ;;
    (#_"void" InductionVariable'''deleteUnusedNodes-1 [#_"InductionVariable" this])
)

(defp InfoElement)
(defp InlineDuringParsingPlugin)

;;;
 ; Represents an opportunity for inlining at a given invoke, with the given weight and level. The weight is the amortized
 ; weight of the additional code - so smaller is better. The level is the number of nested inlinings that lead to this invoke.
 ;;
(defp InlineInfo
    ;;;
     ; The invocation that may be inlined.
     ;;
    (#_"InvokeNode" InlineInfo'''invoke-1 [#_"InlineInfo" this])
    ;;;
     ; Returns the number of methods that may be inlined by the {@link #invoke() invocation}.
     ;;
    (#_"int" InlineInfo'''numberOfMethods-1 [#_"InlineInfo" this])
    (#_"ResolvedJavaMethod" InlineInfo'''methodAt-2 [#_"InlineInfo" this, #_"int" index])
    (#_"Inlineable" InlineInfo'''inlineableElementAt-2 [#_"InlineInfo" this, #_"int" index])
    (#_"double" InlineInfo'''probabilityAt-2 [#_"InlineInfo" this, #_"int" index])
    (#_"double" InlineInfo'''relevanceAt-2 [#_"InlineInfo" this, #_"int" index])
    (#_"void" InlineInfo'''setInlinableElement-3 [#_"InlineInfo" this, #_"int" index, #_"Inlineable" inlineableElement])
    ;;;
     ; Performs the inlining described by this object and returns the node that represents the return value
     ; of the inlined method (or nil for void methods and methods that have no non-exceptional exit).
     ;
     ; @return a collection of nodes that need to be canonicalized after the inlining
     ;;
    (#_"EconomicSet<Node>" InlineInfo'''inline-1 [#_"InlineInfo" this])
    ;;;
     ; Try to make the call static bindable to avoid interface and virtual method calls.
     ;;
    (#_"void" InlineInfo'''tryToDevirtualizeInvoke-1 [#_"InlineInfo" this])
    (#_"boolean" InlineInfo'''shouldInline-1 [#_"InlineInfo" this])
    (#_"void" InlineInfo'''populateInlinableElements-4 [#_"InlineInfo" this, #_"PhaseContext" context, #_"Graph" caller, #_"CanonicalizerPhase" canonicalizer])
    (#_"int" InlineInfo'''determineNodeCount-1 [#_"InlineInfo" this])
)

(defp InlineInvokeInfo)

;;;
 ; Plugin for specifying what is inlined during graph parsing. This plugin is also notified
 ; {@link #notifyBeforeInline before} and #notifyAfterInline the inlining, as well as of
 ; {@link #notifyNotInlined non-inlined} invocations (i.e. those for which an InvokeNode
 ; is created).
 ;;
(defp InlineInvokePlugin
    ;;;
     ; Determines whether a call to a given method is to be inlined. The return value is a tri-state:
     ;
     ; Non-null return value with a non-nil {@link InlineInvokeInfo#getMethodToInline method}:
     ; That {@link InlineInvokeInfo#getMethodToInline method} is inlined. Note that it can be
     ; a different method than the one specified here as the parameter, which allows method substitutions.
     ;
     ; Non-null return value with a nil {@link InlineInvokeInfo#getMethodToInline method},
     ; e.g. InlineInvokeInfo#DO_NOT_INLINE_WITH_EXCEPTION: The method is not inlined,
     ; and other plugins with a lower priority cannot overwrite this decision.
     ;
     ; Null return value: This plugin made no decision, other plugins with a lower priority are asked.
     ;
     ; @param method the target method of an invoke
     ; @param args the arguments to the invoke
     ;;
    (#_"InlineInvokeInfo" InlineInvokePlugin'''shouldInlineInvoke-4 [#_"InlineInvokePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args])
    ;;;
     ; Notification that a method is about to be inlined.
     ;
     ; @param methodToInline the inlined method
     ;;
    (#_"void" InlineInvokePlugin'''notifyBeforeInline-2 [#_"InlineInvokePlugin" this, #_"ResolvedJavaMethod" methodToInline])
    ;;;
     ; Notification that a method was inlined.
     ;
     ; @param methodToInline the inlined method
     ;;
    (#_"void" InlineInvokePlugin'''notifyAfterInline-2 [#_"InlineInvokePlugin" this, #_"ResolvedJavaMethod" methodToInline])
    ;;;
     ; Notifies this plugin of the InvokeNode created for a method that was not inlined per #shouldInlineInvoke.
     ;
     ; @param method the method that was not inlined
     ; @param invoke the invoke node created for the call to {@code method}
     ;;
    (#_"void" InlineInvokePlugin'''notifyNotInlined-4 [#_"InlineInvokePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke])
)

(defp Inlineable
    (#_"int" Inlineable'''getNodeCount-1 [#_"Inlineable" this])
    (#_"InvokeNode*" Inlineable'''getInvokes-1 [#_"Inlineable" this])
    (#_"double" Inlineable'''getProbability-2 [#_"Inlineable" this, #_"InvokeNode" invoke])
)

(defp InlineableGraph)
(defp InliningData)
(defp InliningIterator)
(defp InliningPhase)
(defp InliningPolicy)

(defp InplaceUpdateClosure
    (#_"Node" InplaceUpdateClosure'''replacement-3 [#_"InplaceUpdateClosure" this, #_"Node" node, #_"EdgesType" type])
)

(defp InputEdges)
(defp InputInfo)
(defp InstanceOfDynamicNode)
(defp InstanceOfNode)

;;;
 ; Helper class for lowering InstanceOfNodes with snippets. The majority of the complexity
 ; in such a lowering derives from the fact that InstanceOfNode is a floating node. A snippet
 ; used to lower an InstanceOfNode will almost always incorporate control flow and replacing
 ; a floating node with control flow is not trivial.
 ;
 ; The mechanism implemented in this class ensures that the graph for an instanceof snippet
 ; is instantiated once per InstanceOfNode being lowered. The result produced is then re-used
 ; by all usages of the node. Additionally, if there is a single usage that is an IfNode, the
 ; control flow in the snippet is connected directly to the true and false successors of the
 ; IfNode. This avoids materializing the instanceof test as a boolean which is then retested
 ; by the IfNode.
 ;;
(defp InstanceOfSnippetsTemplates)

(defp InstanceOfTemplates)

;;;
 ; Replaces a usage of an InstanceOfNode or InstanceOfDynamicNode.
 ;;
(defp InstanceOfUsageReplacer
    ;;;
     ; Does the replacement based on a previously snippet instantiation.
     ;;
    (#_"void" InstanceOfUsageReplacer'''replaceUsingInstantiation-1 [#_"InstanceOfUsageReplacer" this])
)

(defp Instantiation)
(defp IntList)
(defp IntegerAddExactNode)
(defp IntegerAddExactSplitNode)
(defp IntegerBelowNode)
(defp IntegerConvertNode)

(defp IntegerConvertOp #_"<T>"
    (#_"Constant" IntegerConvertOp'''foldConstant-4 [#_"IntegerConvertOp<T>" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" value])
    (#_"Stamp" IntegerConvertOp'''foldStamp-4 [#_"IntegerConvertOp<T>" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp])
    ;;;
     ; Computes the stamp of the input for the given output stamp.
     ;;
    (#_"Stamp" IntegerConvertOp'''invertStamp-4 [#_"IntegerConvertOp<T>" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" outStamp])
)

(defp IntegerDivRemNode)
(defp IntegerEqualsNode)
(defp IntegerEqualsOp)

(defp IntegerExactArithmeticNode
    (#_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticNode'''createSplit-3 [#_"IntegerExactArithmeticNode" this, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" deopt])
)

(defp IntegerExactArithmeticSplitNode
    (#_"Value" IntegerExactArithmeticSplitNode'''generateArithmetic-2 [#_"IntegerExactArithmeticSplitNode" this, #_"LIRBuilder" builder])
)

(defp IntegerLessThanNode)
(defp IntegerLowerThanNode)
(defp IntegerMulExactNode)
(defp IntegerMulExactSplitNode)
(defp IntegerMulHighNode)
(defp IntegerStamp)
(defp IntegerSubExactNode)
(defp IntegerSubExactSplitNode)
(defp IntegerSwitchNode)
(defp IntegerTestNode)
(defp InterfaceMethodRef)
(defp Interval)
(defp IntervalBlockIterator)

(defp IntervalPredicate
    (#_"boolean" IntervalPredicate'''apply-2 [#_"IntervalPredicate" this, #_"Interval" i])
)

(defp IntervalWalker
    ;;;
     ; Processes the {@code currentInterval} interval in an attempt to allocate a physical register
     ; to it and thus allow it to be moved to a list of {@linkplain #activeLists active} intervals.
     ;
     ; @return true if a register was allocated to the {@code currentInterval} interval
     ;;
    (#_"boolean" IntervalWalker'''activateCurrent-2 [#_"IntervalWalker" this, #_"Interval" currentInterval])
    (#_"void" IntervalWalker'''walk-1 [#_"IntervalWalker" this])
)

(defp IntrinsicContext)
(defp IntrinsicScope)
(defp InvokeKind)
(defp InvokeNode)
(defp IsNullNode)
(defp IterativeConditionalEliminationPhase)
(defp IterativeNodeWorkList)
(defp JSRData)
(defp JavaReadNode)
(defp JavaWriteNode)
(defp JsrScope)
(defp JumpOp)
(defp KeyData)
(defp KlassPointerStamp)
(defp LIR)
(defp LIRBuilder)
(defp LIRFieldsScanner)
(defp LIRGenerationContext)
(defp LIRGenerationPhase)
(defp LIRGenerationResult)
(defp LIRGenerator)
(defp LIRInsertionBuffer)

;;;
 ; The base class for an LIRInstruction.
 ;;
(defp LIRInstruction
    (#_"void" LIRInstruction'''emitCode-2 [#_"LIRInstruction" this, #_"Assembler" asm])
    (#_"boolean" LIRInstruction'''destroysCallerSavedRegisters-1 [#_"LIRInstruction" this])
)

(defp LIRInstructionClass)
(defp LIRKind)

(defp LIRLowerable
    (#_"void" LIRLowerable'''generate-2 [#_"LIRLowerable" this, #_"LIRBuilder" builder])
)

(defp LIRLowerableAccess
    (#_"Stamp" LIRLowerableAccess'''getAccessStamp-1 [#_"LIRLowerableAccess" this])
)

;;;
 ; Base for all low-level phases. Subclasses should be stateless. There will be one global instance
 ; for each phase that is shared for all compilations.
 ;;
(defp LIRPhase #_"<C>"
    (#_"void" LIRPhase'''run-3 [#_"LIRPhase<C>" this, #_"LIRGenerationResult" lirGenRes, #_"C" context])
)

(defp LIRPhaseContext)
(defp LIRPhaseSuite)
(defp LIRSuites)

(defp LSAllocationPhase
    (#_"void" LSAllocationPhase'''run-2 [#_"LSAllocationPhase" this, #_"LIRGenerationResult" lirGenRes])
)

(defp LSAssignLocationsPhase)

(defp LSEliminateSpillMovePhase
    ;;;
     ; @return the index of the first instruction that is of interest for #eliminateSpillMoves
     ;;
    (#_"int" LSEliminateSpillMovePhase'''firstInstructionOfInterest-1 [#_"LSEliminateSpillMovePhase" this])
    ;;;
     ; @param block The block {@code move} is located in.
     ; @param move Spill move.
     ;;
    (#_"boolean" LSEliminateSpillMovePhase'''canEliminateSpillMove-3 [#_"LSEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move])
)

(defp LSLifetimeAnalysisPhase
    (#_"void" LSLifetimeAnalysisPhase'''addRegisterHint-6 [#_"LSLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"Value" targetValue, #_"OperandMode" mode, #_"{OperandFlag}" flags, #_"boolean" hintAtDef])
    ;;;
     ; Determines the register priority for an instruction's output/result operand.
     ;;
    (#_"RegisterPriority" LSLifetimeAnalysisPhase'''registerPriorityOfOutputOperand-2 [#_"LSLifetimeAnalysisPhase" this, #_"LIRInstruction" op])
    (#_"void" LSLifetimeAnalysisPhase'''buildIntervals-1 [#_"LSLifetimeAnalysisPhase" this])
)

(defp LSOptimizeSpillPositionPhase)
(defp LSRegisterAllocationPhase)

;;;
 ; Phase 6: resolve data flow
 ;
 ; Insert moves at edges between blocks if intervals have been split.
 ;;
(defp LSResolveDataFlowPhase
    (#_"void" LSResolveDataFlowPhase'''resolveCollectMappings-5 [#_"LSResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"Block" midBlock, #_"MoveResolver" moveResolver])
)

(defp Label)
(defp LabelOp)
(defp LabelRef)
(defp LargeLocalLiveness)
(defp LeaOp)
(defp LeftShiftNode)
(defp LessThanOp)

;;;
 ; This interface is like the derived ValueProxy. The difference is that only the graph builder
 ; should see through the proxy for doing some checks. Optimizations should not see through
 ; this proxy and therefore should only test for ValueProxy.
 ;;
(defp LimitedValueProxy
  #_(ยง override #_"ValueNode" Proxy'''getOriginalNode-1 [#_"LimitedValueProxy" this])
)

;;;
 ; An implementation of the linear scan register allocator algorithm described in
 ; <a href="http://doi.acm.org/10.1145/1064979.1064998">"Optimized Interval Splitting in a Linear Scan Register Allocator"</a>
 ; by Christian Wimmer and Hanspeter Moessenboeck.
 ;;
(defp LinearScan
    (#_"MoveResolver" LinearScan'''createMoveResolver-1 [#_"LinearScan" this])
    (#_"void" LinearScan'''initBlockData-2 [#_"LinearScan" this, #_"Block" block])
    (#_"Interval" LinearScan'''getOrCreateInterval-2 [#_"LinearScan" this, #_"AllocatableValue" operand])
    (#_"void" LinearScan'''beforeSpillMoveElimination-1 [#_"LinearScan" this])
    (#_"LSLifetimeAnalysisPhase" LinearScan'''createLifetimeAnalysisPhase-1 [#_"LinearScan" this])
    (#_"LSResolveDataFlowPhase" LinearScan'''createResolveDataFlowPhase-1 [#_"LinearScan" this])
    (#_"LSEliminateSpillMovePhase" LinearScan'''createSpillMoveEliminationPhase-1 [#_"LinearScan" this])
)

(defp LinearScanPhase)

(defp LinearScanWalker
    ;;;
     ; This is called for every interval that is assigned to a stack slot.
     ;;
    (#_"void" LinearScanWalker'''handleSpillSlot-2 [#_"LinearScanWalker" this, #_"Interval" interval])
)

(defp LoadCacheEntry)
(defp LoadConfigValueOp)

;;;
 ; Marker interface for a LIR operation that loads a #getConstant().
 ;;
(defp LoadConstantOp
    (#_"Constant" LoadConstantOp'''getConstant-1 [#_"LoadConstantOp" this])
)

(defp LoadFieldNode)
(defp LoadHubNode)
(defp LoadIndexedNode)
(defp LoadIndexedPointerNode)
(defp LoadMetaspaceConstantOp)
(defp LoadObjectConstantOp)

;;;
 ; Encapsulates the liveness calculation, so that subclasses for locals <= 64 and locals > 64 can be implemented.
 ;;
(defp LocalLiveness
    ;;;
     ; Returns whether the local is live at the beginning of the given block.
     ;;
    (#_"boolean" LocalLiveness'''localIsLiveIn-3 [#_"LocalLiveness" this, #_"BciBlock" block, #_"int" local])
    ;;;
     ; Returns whether the local is set in the given loop.
     ;;
    (#_"boolean" LocalLiveness'''localIsChangedInLoop-3 [#_"LocalLiveness" this, #_"int" loopId, #_"int" local])
    ;;;
     ; Returns whether the local is live at the end of the given block.
     ;;
    (#_"boolean" LocalLiveness'''localIsLiveOut-3 [#_"LocalLiveness" this, #_"BciBlock" block, #_"int" local])
    ;;;
     ; Returns the number of live locals at the end of the given block.
     ;;
    (#_"int" LocalLiveness'''liveOutCardinality-2 [#_"LocalLiveness" this, #_"int" blockID])
    ;;;
     ; Adds all locals the are in the liveIn of the successor to the liveOut of the block.
     ;;
    (#_"void" LocalLiveness'''propagateLiveness-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" successorID])
    ;;;
     ; Calculates a new liveIn for the given block from liveOut, liveKill and liveGen.
     ;;
    (#_"void" LocalLiveness'''updateLiveness-2 [#_"LocalLiveness" this, #_"int" blockID])
    ;;;
     ; Adds the local to liveGen if it wasn't already killed in this block.
     ;;
    (#_"void" LocalLiveness'''loadOne-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local])
    ;;;
     ; Add this local to liveKill if it wasn't already generated in this block.
     ;;
    (#_"void" LocalLiveness'''storeOne-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local])
)

;;;
 ; Marker interface for location identities. A different location identity of two memory accesses
 ; guarantees that the two accesses do not interfere.
 ;
 ; Clients of {@link LocationIdentity} must use {@link #equals(Object)}, not {@code ==}, when
 ; comparing two {@link LocationIdentity} values for equality. Likewise, they must not use
 ; {@link java.util.IdentityHashMap}s with {@link LocationIdentity} values as keys.
 ;;
(defp LocationIdentity)

(defp LocationSet)
(defp LockEliminationPhase)
(defp LockStack)
(defp LockStackHolder)
(defp LockState)
(defp LogicCompareAndSwapNode)
(defp LogicConstantNode)
(defp LogicNegationNode)
(defp LogicNode)
(defp Loop)
(defp LoopBeginNode)
(defp LoopEndNode)
(defp LoopEx)
(defp LoopExitNode)

(defp LoopFragment
    (#_"LoopFragment" LoopFragment'''duplicate-1 [#_"LoopFragment" this])
    (#_"void" LoopFragment'''insertBefore-2 [#_"LoopFragment" this, #_"LoopEx" l])
    ;;;
     ; Gets the corresponding value in this fragment. Should be called on duplicate fragments
     ; with a node from the original fragment as argument.
     ;
     ; @param b original value
     ; @return corresponding value in the peel
     ;;
    (#_"ValueNode" LoopFragment'''prim-2 [#_"LoopFragment" this, #_"ValueNode" b])
    (#_"NodeBitMap" LoopFragment'''nodes-1 [#_"LoopFragment" this])
    (#_"DuplicationReplacement" LoopFragment'''getDuplicationReplacement-1 [#_"LoopFragment" this])
    (#_"void" LoopFragment'''beforeDuplication-1 [#_"LoopFragment" this])
    (#_"void" LoopFragment'''finishDuplication-1 [#_"LoopFragment" this])
)

(defp LoopFragmentInside)
(defp LoopFragmentWhole)
(defp LoopFullUnrollPhase)
(defp LoopKillCache)
(defp LoopPartialUnrollPhase)
(defp LoopPeelingPhase)
(defp LoopPhase)

(defp LoopPolicies
    (#_"boolean" LoopPolicies'''shouldPeel-3 [#_"LoopPolicies" this, #_"LoopEx" _loop, #_"ControlFlowGraph" cfg])
    (#_"boolean" LoopPolicies'''shouldFullUnroll-2 [#_"LoopPolicies" this, #_"LoopEx" _loop])
    (#_"boolean" LoopPolicies'''shouldPartiallyUnroll-2 [#_"LoopPolicies" this, #_"LoopEx" _loop])
    (#_"boolean" LoopPolicies'''shouldTryUnswitch-2 [#_"LoopPolicies" this, #_"LoopEx" _loop])
    (#_"boolean" LoopPolicies'''shouldUnswitch-3 [#_"LoopPolicies" this, #_"LoopEx" _loop, #_"List<ControlSplitNode>" controlSplits])
)

(defp LoopSafepointEliminationPhase)
(defp LoopSafepointInsertionPhase)
(defp LoopUnswitchingPhase)
(defp LoopsData)
(defp LowTier)
(defp LowerGuards)

(defp LowerOp
    (#_"long" LowerOp'''upperBound-2 [#_"LowerOp" this, #_"IntegerStamp" stamp])
    (#_"long" LowerOp'''lowerBound-2 [#_"LowerOp" this, #_"IntegerStamp" stamp])
    (#_"int" LowerOp'''compare-3 [#_"LowerOp" this, #_"long" a, #_"long" b])
    (#_"long" LowerOp'''min-3 [#_"LowerOp" this, #_"long" a, #_"long" b])
    (#_"long" LowerOp'''max-3 [#_"LowerOp" this, #_"long" a, #_"long" b])
    (#_"long" LowerOp'''cast-3 [#_"LowerOp" this, #_"long" a, #_"int" bits])
    (#_"long" LowerOp'''minValue-2 [#_"LowerOp" this, #_"int" bits])
    (#_"long" LowerOp'''maxValue-2 [#_"LowerOp" this, #_"int" bits])
    (#_"IntegerStamp" LowerOp'''forInteger-4 [#_"LowerOp" this, #_"int" bits, #_"long" min, #_"long" max])
    (#_"CanonicalCondition" LowerOp'''getCondition-1 [#_"LowerOp" this])
    (#_"IntegerLowerThanNode" LowerOp'''createNode-3 [#_"LowerOp" this, #_"ValueNode" x, #_"ValueNode" y])
    (#_"LogicNode" LowerOp'''create-3 [#_"LowerOp" this, #_"ValueNode" x, #_"ValueNode" y])
    (#_"LogicNode" LowerOp'''findSynonym-3 [#_"LowerOp" this, #_"ValueNode" forX, #_"ValueNode" forY])
)

;;;
 ; Interface implemented by nodes that can replace themselves with lower level nodes during
 ; a phase that transforms a graph to replace higher level nodes with lower level nodes.
 ;;
(defp Lowerable
    ;;;
     ; Expand this node into lower level nodes expressing the same semantics. If the introduced
     ; nodes are themselves lowerable, they should be recursively lowered as part of this call.
     ;;
    (#_"void" Lowerable'''lower-2 [#_"Lowerable" this, #_"LoweringTool" lowerer])
)

(defp LoweredAtomicReadAndWriteNode)
(defp LoweredCallTargetNode)
(defp LoweringPhase)
(defp LoweringRound)
(defp LoweringTool)
(defp MOp)
(defp MROp)
(defp MacroNode)
(defp MacroStateSplitNode)
(defp MapReplacement)
(defp MarkedNodeIterator)
(defp MaterializationUsageReplacer)
(defp MaterializedObjectState)
(defp MembarNode)
(defp MembarOp)
(defp MemberRef)

;;;
 ; This interface marks nodes that access some memory location, and that have an edge to the last
 ; node that kills this location.
 ;;
(defp MemoryAccess
    (#_"LocationIdentity" MemoryAccess'''getLocationIdentity-1 [#_"MemoryAccess" this])
    ;;;
     ; @param lla the MemoryNode that represents the last kill of the location
     ;;
    (#_"void" MemoryAccess'''setLastLocationAccess-2 [#_"MemoryAccess" this, #_"MemoryNode" lla])
)

(defp MemoryAnchorNode)

;;;
 ; This interface marks subclasses of FixedNode that kill a set of memory locations represented
 ; by location identities (i.e. change a value at one or more locations that belong to these
 ; location identities).
 ;;
(defp MemoryCheckpoint)

(defp MemoryConstOp)
(defp MemoryInputMap)
(defp MemoryMROp)

;;;
 ; Maps a location to the last node that (potentially) wrote to the location.
 ;;
(defp MemoryMap
    ;;;
     ; Gets the last node that that (potentially) wrote to {@code location}.
     ;;
    (#_"MemoryNode" MemoryMap'''getLastLocationAccess-2 [#_"MemoryMap" this, #_"LocationIdentity" location])
    ;;;
     ; Gets the location identities in the domain of this map.
     ;;
    (#_"LocationIdentity*" MemoryMap'''getLocations-1 [#_"MemoryMap" this])
)

(defp MemoryMap0)
(defp MemoryMapNode)

;;;
 ; This interface marks nodes that are part of the memory graph.
 ;;
(defp MemoryNode)

(defp MemoryOp)
(defp MemoryOutputMap)
(defp MemoryPhiNode)
(defp MemoryRMOp)
(defp MemoryTwoOp)
(defp MemoryVMConstOp)
(defp MergeNode)

;;;
 ; The main workhorse for merging states, both for loops and for normal merges.
 ;;
(defp MergeProcessor #_"<T implements EffectsBlockState<T>>"
    (#_"void" MergeProcessor'''merge-2 [#_"MergeProcessor<T>" this, #_"List<T>" states])
)

(defp MethodCallOp)
(defp MethodCallTargetNode)
(defp MethodInvocation)
(defp MethodKey)
(defp MethodRef)
(defp MethodsCache)
(defp MicroBlock)
(defp MidTier)

;;;
 ; Denotes monitor locking transition.
 ;;
(defp MonitorEnter)

(defp MonitorEnterNode)

;;;
 ; Denotes monitor unlocking transition.
 ;;
(defp MonitorExit)

(defp MonitorExitNode)
(defp MonitorIdNode)
(defp MonitorTemplates)
(defp MoveFactory)
(defp MoveFromConstOp)
(defp MoveFromRegOp)
(defp MoveGuardsUpwards)

;;;
 ; Marker interface for a LIR operation that moves a value to #getResult().
 ;;
(defp MoveOp
    (#_"AllocatableValue" MoveOp'''getResult-1 [#_"MoveOp" this])
)

(defp MoveResolver
    (#_"void" MoveResolver'''setValueBlocked-3 [#_"MoveResolver" this, #_"Value" location, #_"int" direction])
    (#_"int" MoveResolver'''valueBlocked-2 [#_"MoveResolver" this, #_"Value" location])
    (#_"boolean" MoveResolver'''mightBeBlocked-2 [#_"MoveResolver" this, #_"Value" location])
    ;;;
     ; @param fromOpr {@link Interval#operand operand} of the {@code from} interval
     ; @param toOpr {@link Interval#operand operand} of the {@code to} interval
     ; @param fromLocation {@link Interval#location() location} of the {@code to} interval
     ; @param toLocation {@link Interval#location() location} of the {@code to} interval
     ;;
    (#_"LIRInstruction" MoveResolver'''createMove-5 [#_"MoveResolver" this, #_"AllocatableValue" fromOpr, #_"AllocatableValue" toOpr, #_"AllocatableValue" fromLocation, #_"AllocatableValue" toLocation])
    (#_"void" MoveResolver'''breakCycle-2 [#_"MoveResolver" this, #_"int" spillCandidate])
)

(defp MoveToRegOp)
(defp Mul)
(defp MulHigh)
(defp MulNode)

(defp Multi
    ;;;
     ; This method is used to determine which set of memory locations is killed by this node.
     ; Returning the special value LocationIdentity#any() will kill all memory locations.
     ;
     ; @return the identities of all locations killed by this node
     ;;
    (#_"LocationIdentity*" Multi'''getLocationIdentities-1 [#_"Multi" this])
)

(defp NameAndType)
(defp NamedLocationIdentity)
(defp Narrow)
(defp NarrowNode)

(defp NarrowOopStamp
    (#_"Stamp" NarrowOopStamp'''uncompressed-1 [#_"NarrowOopStamp" this])
)

(defp Neg)
(defp NegateNode)
(defp NewArrayNode)
(defp NewInstanceNode)
(defp NewObjectTemplates)
(defp NoOp)

;;;
 ; This class is the base class for all nodes. It represents a node that can be inserted in a Graph.
 ;
 ; Once a node has been added to a graph, it has a graph-unique #id(). Edges in the subclasses are
 ; represented with annotated fields. There are two kind of edges: Input and Successor.
 ; If a field, of a type compatible with Node, annotated with either Input and Successor is not nil,
 ; then there is an edge from this node to the node this field points to.
 ;;
(defp Node
    (#_"void" Node'''afterClone-2 [#_"Node" this, #_"Node" other])
    (#_"Node*" Node'''cfgPredecessors-1 [#_"Node" this])
    ;;;
     ; Returns an iterator that will provide all control-flow successors of this node. Normally this
     ; will be the contents of all fields annotated with Successor, but some node classes (like EndNode)
     ; may return different nodes.
     ;;
    (#_"Node*" Node'''cfgSuccessors-1 [#_"Node" this])
)

(defp NodeBitMap)
(defp NodeClass)

(defp NodeClosure #_"<T implements Node>"
    (#_"void" NodeClosure'''apply-3 [#_"NodeClosure<T>" this, #_"Node" usage, #_"T" node])
)

(defp NodeCost)
(defp NodeEntry)

;;;
 ; Client interested in one or more node related events.
 ;;
(defp NodeEventListener
    ;;;
     ; Notifies this listener about any change event in the graph.
     ;
     ; @param e an event
     ; @param node the node related to {@code e}
     ;;
    (#_"void" NodeEventListener'''changed-3 [#_"NodeEventListener" this, #_"NodeEvent" e, #_"Node" node])
    ;;;
     ; Notifies this listener about a change in a node's inputs.
     ;
     ; @param node a node who has had one of its inputs changed
     ;;
    (#_"void" NodeEventListener'''inputChanged-2 [#_"NodeEventListener" this, #_"Node" node])
    ;;;
     ; Notifies this listener of a node becoming unused.
     ;
     ; @param node a node whose Node#usages() just became empty
     ;;
    (#_"void" NodeEventListener'''usagesDroppedToZero-2 [#_"NodeEventListener" this, #_"Node" node])
    ;;;
     ; Notifies this listener of an added node.
     ;
     ; @param node a node that was just added to the graph
     ;;
    (#_"void" NodeEventListener'''nodeAdded-2 [#_"NodeEventListener" this, #_"Node" node])
    ;;;
     ; Notifies this listener of a removed node.
     ;;
    (#_"void" NodeEventListener'''nodeRemoved-2 [#_"NodeEventListener" this, #_"Node" node])
)

(defp NodeEventScope)
(defp NodeFieldsScanner)
(defp NodeFlood)
(defp NodeInputList)

(defp NodeIteratorClosure #_"<T>"
    (#_"T" NodeIteratorClosure'''processNode-3 [#_"NodeIteratorClosure<T>" this, #_"FixedNode" node, #_"T" currentState])
    (#_"T" NodeIteratorClosure'''merge-3 [#_"NodeIteratorClosure<T>" this, #_"AbstractMergeNode" merge, #_"List<T>" states])
    (#_"T" NodeIteratorClosure'''afterSplit-3 [#_"NodeIteratorClosure<T>" this, #_"AbstractBeginNode" node, #_"T" oldState])
    (#_"EconomicMap<LoopExitNode, T>" NodeIteratorClosure'''processLoop-3 [#_"NodeIteratorClosure<T>" this, #_"LoopBeginNode" _loop, #_"T" initialState])
)

(defp NodeList
    (#_"void" NodeList'''update-3 [#_"NodeList" this, #_"Node" oldNode, #_"Node" newNode])
)

(defp NodeLoopInfo)
(defp NodeMap)

(defp NodePlugin
    ;;;
     ; Handle the parsing of a method invocation bytecode to a method that can be bound statically.
     ; If the method returns true, it must push a value as the result of the method invocation
     ; using the {@link Signature#getReturnKind return kind} of the method.
     ;
     ; @param method the statically bound, invoked method
     ; @param args the arguments of the method invocation
     ; @return true if the plugin handles the invocation, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleInvoke-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args])
    ;;;
     ; Handle the parsing of a GETFIELD bytecode. If the method returns true, it must
     ; push a value using the {@link ResolvedJavaField#getJavaKind() kind} of the field.
     ;
     ; @param object the receiver object for the field access
     ; @param field the accessed field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleLoadField-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field])
    ;;;
     ; Handle the parsing of a GETSTATIC bytecode. If the method returns true, it must
     ; push a value using the {@link ResolvedJavaField#getJavaKind() kind} of the field.
     ;
     ; @param field the accessed field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleLoadStaticField-3 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field])
    ;;;
     ; Handle the parsing of a PUTFIELD bytecode.
     ;
     ; @param object the receiver object for the field access
     ; @param field the accessed field
     ; @param value the value to be stored into the field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleStoreField-5 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value])
    ;;;
     ; Handle the parsing of a PUTSTATIC bytecode.
     ;
     ; @param field the accessed field
     ; @param value the value to be stored into the field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleStoreStaticField-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"ValueNode" value])
    ;;;
     ; Handle the parsing of an array load bytecode. If the method returns true,
     ; it must push a value using the provided elementKind.
     ;
     ; @param array the accessed array
     ; @param index the index for the array access
     ; @param elementKind the element kind of the accessed array
     ; @return true if the plugin handles the array access, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleLoadIndexed-5 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind])
    ;;;
     ; Handle the parsing of an array store bytecode.
     ;
     ; @param array the accessed array
     ; @param index the index for the array access
     ; @param elementKind the element kind of the accessed array
     ; @param value the value to be stored into the array
     ; @return true if the plugin handles the array access, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleStoreIndexed-6 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value])
    ;;;
     ; Handle the parsing of a CHECKCAST bytecode. If the method returns true,
     ; it must push a value with the result of the cast using JavaKind#Object.
     ;
     ; @param object the object to be type checked
     ; @param type the type that the object is checked against
     ; @return true if the plugin handles the cast, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleCheckCast-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type])
    ;;;
     ; Handle the parsing of an INSTANCEOF bytecode. If the method returns true,
     ; it must push a value with the result of the instanceof using JavaKind#Int.
     ;
     ; @param object the object to be type checked
     ; @param type the type that the object is checked against
     ; @return true if the plugin handles the instanceof, false otherwise
     ;;
    (#_"boolean" NodePlugin'''handleInstanceOf-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type])
)

(defp NodeSuccessorList)

;;;
 ; Interface for nodes which have FrameState nodes as input.
 ;;
(defp NodeWithState)

(value-ns NodeWithState
    (defn #_"FrameState*" NodeWithState''states-1 [#_"NodeWithState" this]
        (filter #(satisfies? FrameState %) (Node''inputs-1 this))
    )
)

(defp NodeWorkList
    (#_"void" NodeWorkList'''add-2 [#_"NodeWorkList" this, #_"Node" node])
)

(defp NonMaterializationUsageReplacer)
(defp NormalizeCompareNode)
(defp Not)
(defp NotNode)

(defp NullCheck
    (#_"Value" NullCheck'''getCheckedValue-1 [#_"NullCheck" this])
)

(defp NullCheckNode)
(defp NullCheckOp)
(defp NullCheckOptimizer)
(defp ObjectEqualsNode)
(defp ObjectEqualsOp)
(defp ObjectStamp)
(defp ObjectState)
(defp ObjectWriteBarrier)
(defp OffsetAddressNode)
(defp OpaqueNode)
(defp OperandModeAnnotation)

;;;
 ; The x86 operand sizes.
 ;;
(defp OperandSize
    ;;;
     ; Emit an immediate of this size. Note that immediate #QWORD operands are encoded as sign-extended 32-bit values.
     ;;
    (#_"void" OperandSize'''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm])
)

(defp OptimisticOptimizations)
(defp OptimizingLinearScanWalker)
(defp Or)
(defp OrNode)
(defp PEMergeProcessor)
(defp PEReadEliminationBlockState)
(defp PEReadEliminationClosure)
(defp PEReadEliminationMergeProcessor)
(defp ParameterNode)

(defp PartialEscapeBlockState #_"<T implements PartialEscapeBlockState<T>>"
    (#_"void" PartialEscapeBlockState'''objectMaterialized-4 [#_"PartialEscapeBlockState<T>" this, #_"VirtualObjectNode" virtual, #_"AllocatedObjectNode" representation, #_"List<ValueNode>" values])
)

(defp PartialEscapeClosure)
(defp PartialEscapePhase)

; @FunctionalInterface
(defp Patches
    (#_"void" Patches'''registerPatch-3 [#_"Patches" this, #_"int" position, #_"VMConstant" constant])
)

;;;
 ; Base for all compiler phases. Subclasses should be stateless. There will be one global instance
 ; for each phase that is shared for all compilations. VM-, target- and compilation-specific data
 ; can be passed with a context object.
 ;;
(defp Phase
    (#_"Graph" Phase'''run-3 [#_"Phase" this, #_"Graph" graph, #_"PhaseContext" context])
)

(defp PhaseContext)
(defp PhaseSuite)
(defp PhiInfoElement)

;;;
 ; PhiNodes represent the merging of edges at a control flow merges (AbstractMergeNode or LoopBeginNode).
 ; For a AbstractMergeNode, the order of the values corresponds to the order of the ends. For LoopBeginNodes,
 ; the first value corresponds to the loop's predecessor, while the rest of the values correspond to the LoopEndNodes.
 ;;
(defp PhiNode)

(defp PhiValueVisitor
    ;;;
     ; @param phiIn the incoming value at the merge block
     ; @param phiOut the outgoing value from the predecessor block
     ;;
    (#_"void" PhiValueVisitor'''visit-3 [#_"PhiValueVisitor" this, #_"Value" phiIn, #_"Value" phiOut])
)

(defp PiArrayNode)
(defp PiNode)

;;;
 ; A placeholder node in a snippet that will be replaced with a PiNode when the snippet is instantiated.
 ;;
(defp Placeholder
    ;;;
     ; Replaces this node with a PiNode during snippet instantiation.
     ;
     ; @param snippetReplaceeStamp the stamp of the node being replace by the snippet
     ;;
    (#_"void" Placeholder'''makeReplacement-2 [#_"Placeholder" this, #_"Stamp" snippetReplaceeStamp])
)

(defp PlaceholderStamp)
(defp Plugins)
(defp PointerCastNode)
(defp PointerCompressionOp)
(defp PointerEqualsNode)
(defp PointerEqualsOp)
(defp Position)
(defp PrefetchAllocateNode)
(defp Primitive)
(defp PrimitiveStamp)
(defp PrimitiveStrategy)
(defp ProcessFrame)
(defp PropagateDeoptimizeProbabilityPhase)

;;;
 ; This interface marks nodes whose result is the same as one of their inputs. Such nodes are used
 ; to add type information, to introduce scheduling restrictions, etc.
 ;
 ; For some algorithms it is necessary or advantageous to see through these proxies.
 ;;
(defp Proxy
    (#_"Node" Proxy'''getOriginalNode-1 [#_"Proxy" this])
)

(defp ProxyNode)
(defp RMEOptimization)
(defp RMIOp)
(defp RMOp)
(defp RandomSeedNode)
(defp Range)
(defp RangesStrategy)
(defp RawConditionalEliminationVisitor)
(defp RawData)
(defp RawEdgesIterator)
(defp RawLoadNode)
(defp RawMonitorEnterNode)
(defp RawPointerStamp)
(defp RawStoreNode)
(defp ReadCacheEntry)
(defp ReadEliminationBlockState)
(defp ReadEliminationClosure)
(defp ReadEliminationMergeProcessor)
(defp ReadNode)
(defp ReadRegisterNode)
(defp ReadTimestampCounter)
(defp ReassociateInvariantPhase)

(defp RecursiveVisitor #_"<V>"
    (#_"V" RecursiveVisitor'''enter-2 [#_"RecursiveVisitor<V>" this, #_"Block" block])
    (#_"this" RecursiveVisitor'''exit-3 [#_"RecursiveVisitor<V>" this, #_"Block" block, #_"V" value])
)

(defp RedundantMoveElimination)
(defp RefCount)
(defp ReflectionGetCallerClassNode)
(defp RegisterBackupPair)
(defp RegisterBindingLists)
(defp RegisterMap)
(defp Rem)
(defp RemNode)
(defp RemoveValueProxyPhase)
(defp Replacements)
(defp ResolvedJavaMethodBytecode)
(defp ResolvedJavaMethodBytecodeProvider)
(defp ReturnNode)
(defp ReturnOp)
(defp ReturnToCallerData)
(defp RightShiftNode)
(defp SSALinearScan)
(defp SSALinearScanEliminateSpillMovePhase)
(defp SSALinearScanLifetimeAnalysisPhase)
(defp SSALinearScanResolveDataFlowPhase)
(defp SSAMoveResolver)
(defp SafepointNode)
(defp SafepointOp)
(defp SaveCalleeSaveRegisters)
(defp SaveRbp)
(defp Scale)
(defp ScheduleInstance)
(defp SchedulePhase)
(defp ScheduleResult)

;;;
 ; Iterates over a list of nodes, which usually comes from ScheduleResult#getBlockToNodesMap().
 ;
 ; While iterating, it is possible to {@link #insert(FixedNode, FixedWithNextNode) insert} and
 ; {@link #replaceCurrent(FixedWithNextNode) replace} nodes.
 ;;
(defp ScheduledNodeIterator
    (#_"void" ScheduledNodeIterator'''processNode-2 [#_"ScheduledNodeIterator" this, #_"Node" node])
)

(defp Scope)
(defp SequentialStrategy)
(defp SerialWriteBarrier)
(defp SerializableBinaryFunction #_"<T>" #_(ยง extends Function #_"<ArithmeticOpTable, BinaryOp<T>>"))
(defp SerializableIntegerConvertFunction #_"<T>" #_(ยง extends Function #_"<ArithmeticOpTable, IntegerConvertOp<T>>"))
(defp SerializableShiftFunction #_"<T>" #_(ยง extends Function #_"<ArithmeticOpTable, ShiftOp<T>>"))
(defp SerializableUnaryFunction #_"<T>" #_(ยง extends Function #_"<ArithmeticOpTable, UnaryOp<T>>"))
(defp ShiftNode)

;;;
 ; Describes a shift operation. The right argument of a shift operation always has kind JavaKind#Int.
 ;;
(defp ShiftOp #_"<OP>"
    ;;;
     ; Apply the shift to a constant.
     ;;
    (#_"Constant" ShiftOp'''foldConstant-3 [#_"ShiftOp<OP>" this, #_"Constant" constant, #_"int" amount])
    ;;;
     ; Apply the shift to a stamp.
     ;;
    (#_"Stamp" ShiftOp'''foldStamp-3 [#_"ShiftOp<OP>" this, #_"Stamp" stamp, #_"IntegerStamp" amount])
)

(defp Shl)
(defp ShortCircuitOrNode)
(defp Shr)

;;;
 ; Models the state of a graph in terms of {@link StateSplit#hasSideEffect() side effects}
 ; that are control flow predecessors of the current point in a graph.
 ;;
(defp SideEffectsState
    ;;;
     ; Determines if the current program point is preceded by one or more side effects.
     ;;
    (#_"boolean" SideEffectsState'''isAfterSideEffect-1 [#_"SideEffectsState" this])
    ;;;
     ; Gets the side effects preceding the current program point.
     ;;
    (#_"Iterable<StateSplit>" SideEffectsState'''sideEffects-1 [#_"SideEffectsState" this])
    ;;;
     ; Records a side effect for the current program point.
     ;;
    (#_"void" SideEffectsState'''addSideEffect-2 [#_"SideEffectsState" this, #_"StateSplit" sideEffect])
)

(defp SignExtend)
(defp SignExtendNode)
(defp SignedDivNode)
(defp SignedRemNode)

;;;
 ; This interface allows nodes to perform more complicated simplifications, in contrast to
 ; Canonicalizable, which supports only replacing the current node.
 ;
 ; Implementors of this interface need to be aware that they need to call
 ; SimplifierTool#addToWorkList(Node) for each node that might be influenced
 ; (in terms of simplification and canonicalization) by the actions performed in simplify.
 ;;
(defp Simplifiable
    (#_"void" Simplifiable'''simplify-2 [#_"Simplifiable" this, #_"SimplifierTool" tool])
)

(defp SimplifierTool
    (#_"void" SimplifierTool'''deleteBranch-2 [#_"SimplifierTool" this, #_"Node" branch])
    ;;;
     ; Adds a node to the worklist independent of whether it has already been on the worklist.
     ;;
    (#_"void" SimplifierTool'''addToWorkList-2n [#_"SimplifierTool" this, #_"Node" node])
    (#_"void" SimplifierTool'''addToWorkList-2s [#_"SimplifierTool" this, #_"Node*" nodes])
    (#_"void" SimplifierTool'''removeIfUnused-2 [#_"SimplifierTool" this, #_"Node" node])
)

(defp Single
    ;;;
     ; This method is used to determine which memory location is killed by this node. Returning
     ; the special value LocationIdentity#any() will kill all memory locations.
     ;
     ; @return the identity of the location killed by this node
     ;;
    (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"Single" this])
)

(defp SingletonNodeWorkList)
(defp SmallLocalLiveness)
(defp SnippetAnchorNode)

;;;
 ; Holds the ResolvedJavaMethod of the snippet, together with some information about the
 ; method that needs to be computed only once. The SnippetInfo should be created once per
 ; snippet and then cached.
 ;;
(defp SnippetInfo)

(defp SnippetTemplate)

;;;
 ; Marker interface for a class that defines one or more Snippets.
 ;;
(defp Snippets)

(defp SpillRegistersNode)
(defp SpillRegistersOp)
(defp StackInterval)
(defp StackLeaOp)
(defp StackMoveOptimizationPhase)
(defp StackSlotAllocator)

;;;
 ; A stamp is the basis for a type system.
 ;;
(defp Stamp
    ;;;
     ; Returns the type of the stamp, guaranteed to be non-nil. In some cases, it requires the
     ; lookup of class metadata.
     ;;
    (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"Stamp" this])
    (#_"boolean" Stamp'''alwaysDistinct-2 [#_"Stamp" this, #_"Stamp" other])
    ;;;
     ; Gets a Java JavaKind that can be used to store a value of this stamp on the Java bytecode stack.
     ; Returns JavaKind#Illegal if a value of this stamp can not be stored on the bytecode stack.
     ;;
    (#_"JavaKind" Stamp'''getStackKind-1 [#_"Stamp" this])
    ;;;
     ; Gets a platform dependent LIRKind that can be used to store a value of this stamp.
     ;;
    (#_"LIRKind" Stamp'''getLIRKind-1 [#_"Stamp" this])
    ;;;
     ; Returns the union of this stamp and the given stamp. Typically used to create stamps for phi nodes.
     ;
     ; @param other The stamp that will enlarge this stamp.
     ; @return the union of this stamp and the given stamp
     ;;
    (#_"Stamp" Stamp'''meet-2 [#_"Stamp" this, #_"Stamp" other])
    ;;;
     ; Returns the intersection of this stamp and the given stamp.
     ;
     ; @param other The stamp that will tighten this stamp.
     ; @return the intersection of this stamp and the given stamp
     ;;
    (#_"Stamp" Stamp'''join-2 [#_"Stamp" this, #_"Stamp" other])
    ;;;
     ; Returns a stamp of the same kind, but allowing the full value range of the kind.
     ;
     ; #unrestricted() is the neutral element of the #join(Stamp) operation.
     ;;
    (#_"Stamp" Stamp'''unrestricted-1 [#_"Stamp" this])
    ;;;
     ; Returns a stamp of the same kind, but with no allowed values.
     ;
     ; #empty() is the neutral element of the #meet(Stamp) operation.
     ;;
    (#_"Stamp" Stamp'''empty-1 [#_"Stamp" this])
    ;;;
     ; If it is possible to represent single value stamps of this kind, this method returns the
     ; stamp representing the single value c. stamp.constant(c).asConstant() should be equal to c.
     ;
     ; If it is not possible to represent single value stamps, this method returns a stamp that
     ; includes c, and is otherwise as narrow as possible.
     ;;
    (#_"Stamp" Stamp'''constant-2 [#_"Stamp" this, #_"Constant" constant])
    ;;;
     ; Test whether two stamps have the same base type.
     ;;
    (#_"boolean" Stamp'''isCompatible-2s [#_"Stamp" this, #_"Stamp" other])
    ;;;
     ; Check that the constant {@code other} is compatible with this stamp.
     ;;
    #_unused
    (#_"boolean" Stamp'''isCompatible-2c [#_"Stamp" this, #_"Constant" constant])
    ;;;
     ; Test whether this stamp has legal values.
     ;;
    (#_"boolean" Stamp'''hasValues-1 [#_"Stamp" this])
    ;;;
     ; Tests whether this stamp represents all values of this kind.
     ;;
    (#_"boolean" Stamp'''isUnrestricted-1 [#_"Stamp" this])
    ;;;
     ; If this stamp represents a single value, the methods returns this single value, nil otherwise.
     ;
     ; @return the constant corresponding to the single value of this stamp and nil if this stamp
     ;         can represent less or more than one value.
     ;;
    (#_"Constant" Stamp'''asConstant-1 [#_"Stamp" this])
    ;;;
     ; Read a value of this stamp from memory.
     ;
     ; @return the value read or nil if the value can't be read for some reason
     ;;
    (#_"Constant" Stamp'''readConstant-4 [#_"Stamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement])
    ;;;
     ; Tries to improve this stamp with the stamp given as parameter. If successful, returns the new
     ; improved stamp. Otherwise, returns a stamp equal to this.
     ;
     ; @param other the stamp that should be used to improve this stamp
     ; @return the newly improved stamp or a stamp equal to {@code this} if an improvement was not possible
     ;;
    (#_"Stamp" Stamp'''improveWith-2 [#_"Stamp" this, #_"Stamp" other])
)

(defp StampElement)

(defp StampInverter
    ;;;
     ; Computes the stamp of the input for the given output stamp.
     ;;
    (#_"Stamp" StampInverter'''invertStamp-2 [#_"StampInverter" this, #_"Stamp" outStamp])
)

;;;
 ; Marker interface for a LIR operation that is a conditional jump.
 ;;
(defp StandardBranchOp)

(defp StartNode)

;;;
 ; A state split is a node that may have a frame state associated with it.
 ;;
(defp StateSplit
    ;;;
     ; Sets the FrameState corresponding to the state of the JVM after execution of this node.
     ;;
    (#_"void" StateSplit'''setStateAfter-2 [#_"StateSplit" this, #_"FrameState" x])
    ;;;
     ; Determines if this node has a side-effect. Such nodes cannot be safely re-executed because they modify
     ; state which is visible to other threads or modify state beyond what is captured in FrameState nodes.
     ;;
    (#_"boolean" StateSplit'''hasSideEffect-1 [#_"StateSplit" this])
)

(defp StateSplitProxyNode)

(defp StaticDeoptimizingNode
    (#_"void" StaticDeoptimizingNode'''setReason-2 [#_"StaticDeoptimizingNode" this, #_"DeoptimizationReason" reason])
    (#_"void" StaticDeoptimizingNode'''setAction-2 [#_"StaticDeoptimizingNode" this, #_"DeoptimizationAction" action])
    (#_"GuardPriority" StaticDeoptimizingNode'''computePriority-1 [#_"StaticDeoptimizingNode" this])
)

(defp StoreFieldNode)
(defp StoreHubNode)
(defp StoreIndexedNode)
(defp StrategySwitchOp)
(defp StringRef)
(defp StubForeignCallNode)
(defp Sub)
(defp SubNode)
(defp SuccessorEdges)
(defp SuccessorInfo)
(defp Suites)

(defp SwitchClosure
    ;;;
     ; Generates a conditional or unconditional jump. The jump will be unconditional if
     ; condition is nil. If defaultTarget is true, then the jump will go the default.
     ;
     ; @param index Index of the value and the jump target (only used if defaultTarget == false)
     ; @param condition The condition on which to jump (can be nil)
     ; @param defaultTarget true if the jump should go to the default target, false if index should be used
     ;;
    (#_"void" SwitchClosure'''conditionalJump-4 [#_"SwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" defaultTarget])
    ;;;
     ; Generates a conditional jump to the target with the specified index. The fall through
     ; should go to the default target.
     ;
     ; @param index Index of the value and the jump target
     ; @param condition The condition on which to jump
     ; @param canFallThrough true if this is the last instruction in the switch statement, to allow for fall-through optimizations
     ;;
    (#_"void" SwitchClosure'''conditionalJumpOrDefault-4 [#_"SwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" canFallThrough])
    ;;;
     ; Create a new label and generate a conditional jump to it.
     ;
     ; @param index Index of the value and the jump target
     ; @param condition The condition on which to jump
     ; @return a new Label
     ;;
    (#_"Label" SwitchClosure'''conditionalJump-3 [#_"SwitchClosure" this, #_"int" index, #_"Condition" condition])
    ;;;
     ; Binds a label returned by #conditionalJump(int, Condition).
     ;;
    (#_"void" SwitchClosure'''bind-2 [#_"SwitchClosure" this, #_"Label" label])
    ;;;
     ; Return true iff the target of both indexes is the same.
     ;;
    (#_"boolean" SwitchClosure'''isSameTarget-3 [#_"SwitchClosure" this, #_"int" index1, #_"int" index2])
)

;;;
 ; The SwitchNode class is the base of both lookup and table switches.
 ;;
(defp SwitchNode
    (#_"boolean" SwitchNode'''isSorted-1 [#_"SwitchNode" this])
    ;;;
     ; The key at the specified position, encoded in a Constant.
     ;;
    (#_"Constant" SwitchNode'''keyAt-2 [#_"SwitchNode" this, #_"int" i])
    ;;;
     ; Returns true if the switch has the same keys in the same order as this switch.
     ;;
    (#_"boolean" SwitchNode'''equalKeys-2 [#_"SwitchNode" this, #_"SwitchNode" switchNode])
    (#_"Stamp" SwitchNode'''getValueStampForSuccessor-2 [#_"SwitchNode" this, #_"AbstractBeginNode" beginNode])
)

;;;
 ; This class encapsulates different strategies on how to generate code for switch instructions.
 ;
 ; The #getBestStrategy(double[], JavaConstant[], LabelRef[]) method can be used to get strategy
 ; with the smallest average effort (average number of comparisons until a decision is reached).
 ; The strategy returned by this method will have its averageEffort set, while a strategy
 ; constructed directly will not.
 ;;
(defp SwitchStrategy
    (#_"double" SwitchStrategy'''getAverageEffort-1 [#_"SwitchStrategy" this])
    (#_"void" SwitchStrategy'''run-2 [#_"SwitchStrategy" this, #_"SwitchClosure" closure])
)

(defp TableSwitchOp)
(defp Tool)
(defp TwoOp)
(defp TwoSlotMarker)

;;;
 ; Plugin for overriding types in the bytecode parser. This can be used to modify the standard
 ; behavior of Java type resolution, e.g. to introduce trusted interface types with special semantics.
 ;;
(defp TypePlugin
    ;;;
     ; Intercept the type of arguments or return values.
     ;;
    (#_"Stamp" TypePlugin'''interceptType-4 [#_"TypePlugin" this, #_"BytecodeParser" parser, #_"JavaType" declaredType, #_"boolean" never-nil?])
)

(defp TypeReference)
(defp UMulHigh)
(defp UShr)

;;;
 ; This sub-interface of Canonicalizable is intended for nodes that have exactly one input. It has an
 ; additional #canonical(CanonicalizerTool, Node) method that looks at the given input instead of the current
 ; input of the node - which can be used to ask "what if this input is changed to this node" - questions.
 ;
 ; @param <T> the common supertype of all inputs of this node
 ;;
(defp Unary #_"<T implements Node>"
    ;;;
     ; Similar to Canonicalizable#canonical(CanonicalizerTool), except that implementations should act as if the
     ; current input of the node was the given one, i.e. they should never look at the inputs via the this pointer.
     ;;
    (#_"Node" Unary'''canonical-3 [#_"Unary<T>" this, #_"CanonicalizerTool" tool, #_"T" forValue])
    ;;;
     ; Gets the current value of the input, so that calling #canonical(CanonicalizerTool, Node) with the value
     ; returned from this method should behave exactly like Canonicalizable#canonical(CanonicalizerTool).
     ;;
    (#_"T" Unary'''getValue-1 [#_"Unary<T>" this])
)

(defp UnaryArithmeticNode)

;;;
 ; The UnaryNode class is the base of arithmetic and bit logic operations with exactly one input.
 ;;
(defp UnaryNode
    ;;;
     ; Compute an improved for this node using the passed in stamp. The stamp must be compatible
     ; with the current value of #value. This code is used to provide the default implementation
     ; of #inferStamp() and may be used by external optimizations.
     ;;
    (#_"Stamp" UnaryNode'''foldStamp-2 [#_"UnaryNode" this, #_"Stamp" stamp])
)

;;;
 ; Describes a unary arithmetic operation.
 ;;
(defp UnaryOp #_"<T>"
    ;;;
     ; Apply the operation to a Constant.
     ;;
    (#_"Constant" UnaryOp'''foldConstant-2 [#_"UnaryOp<T>" this, #_"Constant" value])
    ;;;
     ; Apply the operation to a Stamp.
     ;;
    (#_"Stamp" UnaryOp'''foldStamp-2 [#_"UnaryOp<T>" this, #_"Stamp" stamp])
)

(defp UnaryOpLogicNode
    (#_"Stamp" UnaryOpLogicNode'''getSucceedingStampForValue-2 [#_"UnaryOpLogicNode" this, #_"boolean" negated?])
    (#_"TriState" UnaryOpLogicNode'''tryFold-2 [#_"UnaryOpLogicNode" this, #_"Stamp" valueStamp])
)

(defp UnboxNode)
(defp UncompressPointerOp)
(defp UnpackEndianHalfNode)

(defp UnsafeAccessNode
    (#_"ValueNode" UnsafeAccessNode'''cloneAsFieldAccess-2 [#_"UnsafeAccessNode" this, #_"ResolvedJavaField" field])
    (#_"ValueNode" UnsafeAccessNode'''cloneAsArrayAccess-3 [#_"UnsafeAccessNode" this, #_"ValueNode" offset, #_"LocationIdentity" location])
)

(defp UnsafeCompareAndSwapNode)
(defp UnsafeLoadCacheEntry)
(defp UnsafeLoadTemplates)
(defp UnsignedDivNode)
(defp UnsignedLong)
(defp UnsignedMulHighNode)
(defp UnsignedRemNode)
(defp UnsignedRightShiftNode)
(defp Unsupported)

;;;
 ; Logic for replacing a snippet-lowered node at its usages with the return value of the snippet.
 ; An alternative to the {@linkplain SnippetTemplate#DEFAULT_REPLACER default} replacement logic
 ; can be used to handle mismatches between the stamp of the node being lowered and the stamp of
 ; the snippet's return value.
 ;;
(defp UsageReplacer
    ;;;
     ; Replaces all usages of {@code oldNode} with direct or indirect usages of {@code newNode}.
     ;;
    (#_"void" UsageReplacer'''replace-3 [#_"UsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode])
)

(defp UseEntry)
(defp UsePosList)
(defp UseTrappingNullChecksPhase)
(defp Utf8)
(defp VMConfigNode)
(defp VMConstOp)
(defp ValueAnchorNode)
(defp ValueCompareAndSwapNode)

;;;
 ; Functional interface for iterating over a list of values without modifying them.
 ; See ValueProcedure for a version that can modify values.
 ;;
; @FunctionalInterface
(defp ValueConsumer
    ;;;
     ; Iterator method to be overwritten.
     ;
     ; @param op The current instruction.
     ; @param value The value that is iterated.
     ; @param mode The operand mode for the value.
     ; @param flags A set of flags for the value.
     ;;
    (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" this, #_"LIRInstruction" op, #_"Value" value, #_"OperandMode" mode, #_"{OperandFlag}" flags])
)

(defp ValueFieldInfo)

;;;
 ; Marker interface for a LIR operation that moves some non-constant value to another location.
 ;;
(defp ValueMoveOp
    (#_"AllocatableValue" ValueMoveOp'''getInput-1 [#_"ValueMoveOp" this])
)

;;;
 ; This class represents a value within the graph, including local variables, phis, and all other instructions.
 ;;
(defp ValueNode
    ;;;
     ; This method can be overridden by subclasses of ValueNode if they need to recompute
     ; their stamp if their inputs change. A typical implementation will compute the stamp and pass
     ; it to #updateStamp(Stamp), whose return value can be used as the result of this method.
     ;
     ; @return true if the stamp has changed, false otherwise
     ;;
    (#_"boolean" ValueNode'''inferStamp-1 [#_"ValueNode" this])
)

(defp ValuePhiNode)

;;;
 ; Functional interface for iterating over a list of values, possibly returning a value to replace the old value.
 ;;
; @FunctionalInterface
(defp ValueProcedure
    ;;;
     ; Iterator method to be overwritten.
     ;
     ; @param op The current instruction.
     ; @param value The value that is iterated.
     ; @param mode The operand mode for the value.
     ; @param flags A set of flags for the value.
     ; @return the new value to replace the value that was passed in
     ;;
    (#_"Value" ValueProcedure'''doValue-5 [#_"ValueProcedure" this, #_"LIRInstruction" op, #_"Value" value, #_"OperandMode" mode, #_"{OperandFlag}" flags])
)

;;;
 ; This interface marks nodes whose result is the same as one of their inputs. Such nodes are used
 ; to add type information, to introduce scheduling restrictions, etc.
 ;
 ; For some algorithms it is necessary or advantageous to see through these proxies.
 ;;
(defp ValueProxy)

(defp ValueProxyNode)
(defp Values)
(defp Variable)
(defp VariableMap)
(defp VirtualArrayNode)
(defp VirtualBoxingNode)

(defp VirtualClosure
    (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs])
)

(defp VirtualInstanceNode)

(defp VirtualObjectNode
    ;;;
     ; The type of object described by this VirtualObjectNode. In case of arrays, this is
     ; the array type (and not the component type).
     ;;
    (#_"ResolvedJavaType" VirtualObjectNode'''type-1 [#_"VirtualObjectNode" this])
    ;;;
     ; The number of entries this virtual object has. Either the number of fields or the number of
     ; array elements.
     ;;
    (#_"int" VirtualObjectNode'''entryCount-1 [#_"VirtualObjectNode" this])
    ;;;
     ; If the given index denotes an entry in this virtual object, the index of this entry is
     ; returned. If no such entry can be found, this method returns -1.
     ;
     ; @param constantOffset offset, where the value is placed.
     ; @param expectedEntryKind specifies which type is expected at this offset, important when
     ;            doing implicit casts, especially on big endian systems
     ;;
    (#_"int" VirtualObjectNode'''entryIndexForOffset-3 [#_"VirtualObjectNode" this, #_"long" constantOffset, #_"JavaKind" expectedEntryKind])
    ;;;
     ; Returns the JavaKind of the entry at the given index.
     ;;
    (#_"JavaKind" VirtualObjectNode'''entryKind-2 [#_"VirtualObjectNode" this, #_"int" index])
    ;;;
     ; Returns an exact duplicate of this virtual object node, which has not been added to the graph yet.
     ;;
    (#_"VirtualObjectNode" VirtualObjectNode'''duplicate-1 [#_"VirtualObjectNode" this])
    ;;;
     ; Returns a node that can be used to materialize this virtual object. If this returns an
     ; AllocatedObjectNode then this node will be attached to a CommitAllocationNode,
     ; otherwise the node will just be added to the graph.
     ;;
    (#_"ValueNode" VirtualObjectNode'''getMaterializedRepresentation-4 [#_"VirtualObjectNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks])
)

(defp VirtualObjectState)
(defp VirtualStackSlot)

;;;
 ; Base class for nodes that contain "virtual" state, like FrameState and VirtualObjectState.
 ; Subclasses of this class will be treated in a special way by the scheduler.
 ;;
(defp VirtualState
    (#_"VirtualState" VirtualState'''duplicateWithVirtualState-1 [#_"VirtualState" this])
    (#_"void" VirtualState'''applyToNonVirtual-2 [#_"VirtualState" this, #_"NodeClosure<? super ValueNode>" closure])
    ;;;
     ; Performs a <b>pre-order</b> iteration over all elements reachable from this state that
     ; are a subclass of VirtualState.
     ;;
    (#_"void" VirtualState'''applyToVirtual-2 [#_"VirtualState" this, #_"VirtualClosure" closure])
    (#_"boolean" VirtualState'''isPartOfThisState-2 [#_"VirtualState" this, #_"VirtualState" state])
)

;;;
 ; This interface allows a node to convey information about what its effect would be if some of its
 ; inputs were virtualized. The #virtualize(VirtualizerTool) method will only be called for nodes
 ; that have some interaction with virtualized nodes. However, the virtualized nodes might have
 ; been re-materialized in the meantime.
 ;;
(defp Virtualizable
    ;;;
     ; A node class can implement this method to convey information about what its effect would be
     ; if some of its inputs were virtualized. All modifications must be made through the supplied
     ; tool, and not directly on the node, because by the time this method is called the
     ; virtualized/non-virtualized state is still speculative and might not hold because of loops, etc.
     ;
     ; @param tool the tool used to describe the effects of this node
     ;;
    (#_"void" Virtualizable'''virtualize-2 [#_"Virtualizable" this, #_"VirtualizerTool" tool])
)

;;;
 ; This interface allows a node to convey information about what its effect would be if some of its
 ; inputs were virtualized.
 ;
 ; The difference to Virtualizable is that the #virtualize(VirtualizerTool) method will be called
 ; regardless of whether this node had any interaction with virtualized nodes. This interface can
 ; therefore be used for object allocations, for which virtualization introduces new virtualized objects.
 ;;
(defp VirtualizableAllocation)

(defp VirtualizableInvokeMacroNode)

;;;
 ; This tool can be used to query the current state (normal/virtualized/re-materialized) of values
 ; and to describe the actions that would be taken for this state.
 ;
 ; See also Virtualizable.
 ;;
(defp VirtualizerTool
    ;;;
     ; This method should be used to query the maximum size of virtualized objects before attempting virtualization.
     ;
     ; @return the maximum number of entries for virtualized objects
     ;;
    (#_"int" VirtualizerTool'''getMaximumEntryCount-1 [#_"VirtualizerTool" this])
    ;;;
     ; Introduces a new virtual object to the current state.
     ;
     ; @param virtualObject the new virtual object.
     ; @param entryState the initial state of the virtual object's fields.
     ; @param locks the initial locking depths.
     ; @param ensureVirtualized true if this object needs to stay virtual
     ;;
    (#_"void" VirtualizerTool'''createVirtualObject-5 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"ValueNode[]" entryState, #_"List<MonitorIdNode>" locks, #_"boolean" ensureVirtualized])
    ;;;
     ; Returns a VirtualObjectNode if the given value is aliased with a virtual object that is still
     ; virtual, the materialized value of the given value is aliased with a virtual object that was
     ; materialized, the replacement if the give value was replaced, otherwise the given value.
     ;
     ; Replacements via #replaceWithValue(ValueNode) are not immediately committed. This method can be
     ; used to determine if a value was replaced by another one (e.g. a load field by the loaded value).
     ;;
    (#_"ValueNode" VirtualizerTool'''getAlias-2 [#_"VirtualizerTool" this, #_"ValueNode" value])
    ;;;
     ; Sets the entry (field or array element) with the given index in the virtualized object.
     ;
     ; @param index the index to be set.
     ; @param value the new value for the given index.
     ; @param accessKind the kind of the store which might be different than VirtualObjectNode#entryKind(int)
     ; @return true if the operation was permitted
     ;;
    (#_"boolean" VirtualizerTool'''setVirtualEntry-6 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index, #_"ValueNode" value, #_"JavaKind" accessKind, #_"long" offset])
    (#_"void" VirtualizerTool'''setVirtualEntry-4 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index, #_"ValueNode" value])
    (#_"ValueNode" VirtualizerTool'''getEntry-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index])
    (#_"void" VirtualizerTool'''addLock-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"MonitorIdNode" monitorId])
    (#_"MonitorIdNode" VirtualizerTool'''removeLock-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])
    #_unused
    (#_"boolean" VirtualizerTool'''getEnsureVirtualized-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])
    ;;;
     ; Deletes the current node and replaces it with the given virtualized object.
     ;
     ; @param virtualObject the virtualized object that should replace the current node.
     ;;
    (#_"void" VirtualizerTool'''replaceWithVirtual-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])
    ;;;
     ; Deletes the current node and replaces it with the given value.
     ;
     ; @param replacement the value that should replace the current node.
     ;;
    (#_"void" VirtualizerTool'''replaceWithValue-2 [#_"VirtualizerTool" this, #_"ValueNode" replacement])
    ;;;
     ; Deletes the current node.
     ;;
    (#_"void" VirtualizerTool'''delete-1 [#_"VirtualizerTool" this])
    ;;;
     ; Replaces an input of the current node.
     ;
     ; @param oldInput the old input value.
     ; @param replacement the new input value.
     ;;
    #_unused
    (#_"void" VirtualizerTool'''replaceFirstInput-3 [#_"VirtualizerTool" this, #_"Node" oldInput, #_"Node" replacement])
    ;;;
     ; Adds the given node to the graph.This action will only be performed when, and if, the changes are committed.
     ;
     ; @param node the node to add.
     ;;
    (#_"void" VirtualizerTool'''addNode-2 [#_"VirtualizerTool" this, #_"ValueNode" node])
    ;;;
     ; This method performs either #replaceWithValue(ValueNode) or #replaceWithVirtual(VirtualObjectNode),
     ; depending on the given value.
     ;
     ; @param value the replacement value
     ;;
    (#_"void" VirtualizerTool'''replaceWith-2 [#_"VirtualizerTool" this, #_"ValueNode" value])
    ;;;
     ; If state is virtual, materialization is performed for the given state.
     ;
     ; @return true if materialization happened, false if not
     ;;
    #_unused
    (#_"boolean" VirtualizerTool'''ensureMaterialized-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])
)

(defp VoidStamp)
(defp Word)
(defp WordCastNode)
(defp WordOperationPlugin)
(defp WorkListEntry)
(defp WriteBarrier)
(defp WriteBarrierAdditionPhase)
(defp WriteBarrierTemplates)
(defp WriteNode)
(defp Xor)
(defp XorNode)
(defp ZeroData)
(defp ZeroExtend)
(defp ZeroExtendNode)

(value-ns HotSpot
    (def #_"HotSpotJVMCIRuntime" JVMCI'runtime (HotSpotJVMCIRuntime/runtime))
    (def #_"JVMCIBackend"        JVMCI'backend (#_"HotSpotJVMCIRuntime" .getHostJVMCIBackend JVMCI'runtime))

    (def #_"CodeCacheProvider"          HotSpot'codeCache          (#_"JVMCIBackend"        .getCodeCache          JVMCI'backend))
    (def #_"RegisterConfig"             HotSpot'registerConfig     (#_"CodeCacheProvider"   .getRegisterConfig     HotSpot'codeCache))
    (def #_"TargetDescription"          HotSpot'target             (#_"CodeCacheProvider"   .getTarget             HotSpot'codeCache))
    (def #_"ConstantReflectionProvider" HotSpot'constantReflection (#_"JVMCIBackend"        .getConstantReflection JVMCI'backend))
    (def #_"MetaAccessProvider"         HotSpot'metaAccess         (#_"JVMCIBackend"        .getMetaAccess         JVMCI'backend))

    (def #_"HotSpotVMConfigAccess" HotSpot'config (HotSpotVMConfigAccess. (#_"HotSpotJVMCIRuntime" .getConfigStore JVMCI'runtime)))

    (def #_"boolean" HotSpot'useFastLocking          (.getFlag HotSpot'config, "JVMCIUseFastLocking",    Boolean))
    (def #_"boolean" HotSpot'foldStableValues        (.getFlag HotSpot'config, "FoldStableValues",       Boolean))
    (def #_"boolean" HotSpot'useTLAB                 (.getFlag HotSpot'config, "UseTLAB",                Boolean))
    (def #_"boolean" HotSpot'useBiasedLocking        (.getFlag HotSpot'config, "UseBiasedLocking",       Boolean))
    (def #_"boolean" HotSpot'threadLocalHandshakes   (.getFlag HotSpot'config, "ThreadLocalHandshakes",  Boolean))
    (def #_"boolean" HotSpot'useG1GC                 (.getFlag HotSpot'config, "UseG1GC",                Boolean))
    (def #_"boolean" HotSpot'useDeferredInitBarriers (.getFlag HotSpot'config, "ReduceInitialCardMarks", Boolean))

    (def #_"int" HotSpot'allocatePrefetchStyle         (.getFlag HotSpot'config, "AllocatePrefetchStyle",         Integer))
    (def #_"int" HotSpot'allocatePrefetchInstr         (.getFlag HotSpot'config, "AllocatePrefetchInstr",         Integer))
    (def #_"int" HotSpot'allocatePrefetchLines         (.getFlag HotSpot'config, "AllocatePrefetchLines",         Integer))
    (def #_"int" HotSpot'allocateInstancePrefetchLines (.getFlag HotSpot'config, "AllocateInstancePrefetchLines", Integer))
    (def #_"int" HotSpot'allocatePrefetchStepSize      (.getFlag HotSpot'config, "AllocatePrefetchStepSize",      Integer))
    (def #_"int" HotSpot'allocatePrefetchDistance      (.getFlag HotSpot'config, "AllocatePrefetchDistance",      Integer))
    (def #_"int" HotSpot'codeEntryAlignment            (.getFlag HotSpot'config, "CodeEntryAlignment",            Integer))
    (def #_"int" HotSpot'objectAlignment               (.getFlag HotSpot'config, "ObjectAlignmentInBytes",        Integer))
    (def #_"int" HotSpot'heapWordSize                  (.getConstant HotSpot'config, "HeapWordSize",              Integer))

    ;; Compressed Oops related values.
    (def #_"boolean" HotSpot'useCompressedOops          (.getFlag HotSpot'config, "UseCompressedOops",          Boolean))
    (def #_"boolean" HotSpot'useCompressedClassPointers (.getFlag HotSpot'config, "UseCompressedClassPointers", Boolean))

    (def #_"long" HotSpot'narrowOopBase   (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_oop_base",   Long, "address"))
    (def #_"long" HotSpot'narrowKlassBase (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_klass_base", Long, "address"))

    (def #_"int" HotSpot'narrowOopShift   (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_oop_shift",   Integer, "int"))
    (def #_"int" HotSpot'narrowKlassShift (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_klass_shift", Integer, "int"))
    (def #_"int" HotSpot'narrowKlassSize  (.getFieldValue HotSpot'config, "CompilerToVM::Data::sizeof_narrowKlass",          Integer, "int"))
    (def #_"int" HotSpot'arrayOopDescSize (.getFieldValue HotSpot'config, "CompilerToVM::Data::sizeof_arrayOopDesc",         Integer, "int"))
    (def #_"int" HotSpot'vmPageSize       (.getFieldValue HotSpot'config, "CompilerToVM::Data::vm_page_size",                Integer, "int"))

    (ยง def #_"CompressEncoding" HotSpot'oopEncoding   (CompressEncoding'new-2 HotSpot'narrowOopBase, HotSpot'narrowOopShift))
    (ยง def #_"CompressEncoding" HotSpot'klassEncoding (CompressEncoding'new-2 HotSpot'narrowKlassBase, HotSpot'narrowKlassShift))

    (def #_"boolean" HotSpot'useStackBanging (.getFlag HotSpot'config, "UseStackBanging", Boolean))
    (def #_"int" HotSpot'stackShadowPages    (.getFlag HotSpot'config, "StackShadowPages", Integer))
    (def #_"int" HotSpot'stackBias           (.getConstant HotSpot'config, "STACK_BIAS", Integer))

    (def #_"int" HotSpot'markOffset (.getFieldOffset HotSpot'config, "oopDesc::_mark",            Integer, "markOop"))
    (def #_"int" HotSpot'hubOffset  (.getFieldOffset HotSpot'config, "oopDesc::_metadata._klass", Integer, "Klass*"))

    (def #_"int" HotSpot'prototypeMarkWordOffset   (.getFieldOffset HotSpot'config, "Klass::_prototype_header",      Integer, "markOop"))
    (def #_"int" HotSpot'superCheckOffsetOffset    (.getFieldOffset HotSpot'config, "Klass::_super_check_offset",    Integer, "juint"))
    (def #_"int" HotSpot'secondarySuperCacheOffset (.getFieldOffset HotSpot'config, "Klass::_secondary_super_cache", Integer, "Klass*"))
    (def #_"int" HotSpot'secondarySupersOffset     (.getFieldOffset HotSpot'config, "Klass::_secondary_supers",      Integer, "Array<Klass*>*"))
    (def #_"int" HotSpot'classMirrorOffset         (.getFieldOffset HotSpot'config, "Klass::_java_mirror",           Integer, "OopHandle"))

    ;;;
     ; The offset of the array length word in an array object's header.
     ;;
    (def #_"int" HotSpot'arrayLengthOffset (if HotSpot'useCompressedClassPointers (+ HotSpot'hubOffset HotSpot'narrowKlassSize) HotSpot'arrayOopDescSize))

    (def #_"int" HotSpot'metaspaceArrayBaseOffset   (.getFieldOffset HotSpot'config, "Array<Klass*>::_data[0]",       Integer, "Klass*"))
    (def #_"int" HotSpot'metaspaceArrayLengthOffset (.getFieldOffset HotSpot'config, "Array<Klass*>::_length",        Integer, "int"))
    (def #_"int" HotSpot'arrayClassElementOffset    (.getFieldOffset HotSpot'config, "ObjArrayKlass::_element_klass", Integer, "Klass*"))

    (def #_"int" HotSpot'threadTlabOffset       (.getFieldOffset HotSpot'config, "Thread::_tlab",          Integer, "ThreadLocalAllocBuffer"))
    (def #_"int" HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaThread::_anchor",    Integer, "JavaFrameAnchor"))
    (def #_"int" HotSpot'objectResultOffset     (.getFieldOffset HotSpot'config, "JavaThread::_vm_result", Integer, "oop"))

    ;;;
     ; This field is used to pass exception objects into and out of the runtime system during exception handling for compiled code.
     ;;
    (def #_"int" HotSpot'pendingExceptionOffset         (.getFieldOffset HotSpot'config, "ThreadShadow::_pending_exception",        Integer, "oop"))
    (def #_"int" HotSpot'pendingDeoptimizationOffset    (.getFieldOffset HotSpot'config, "JavaThread::_pending_deoptimization",     Integer, "int"))
    (def #_"int" HotSpot'pendingFailedSpeculationOffset (.getFieldOffset HotSpot'config, "JavaThread::_pending_failed_speculation", Integer, "oop"))

    (def #_"int" HotSpot'threadLastJavaSpOffset (+ HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaFrameAnchor::_last_Java_sp", Integer, "intptr_t*")))
    (def #_"int" HotSpot'threadLastJavaPcOffset (+ HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaFrameAnchor::_last_Java_pc", Integer, "address")))
    (def #_"int" HotSpot'threadLastJavaFpOffset (+ HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaFrameAnchor::_last_Java_fp", Integer, "intptr_t*")))

    ;;;
     ; Mask for a biasable, locked or unlocked mark word.
     ;
     ; +----------------------------------+-+-+
     ; |                                 1|1|1|
     ; +----------------------------------+-+-+
     ;;

    ;;;
     ; Pattern for a biasable, unlocked mark word.
     ;
     ; +----------------------------------+-+-+
     ; |                                 1|0|1|
     ; +----------------------------------+-+-+
     ;;

    (def #_"int" HotSpot'biasedLockMaskInPlace (.getConstant HotSpot'config, "markOopDesc::biased_lock_mask_in_place", Integer))
    (def #_"int" HotSpot'biasedLockPattern     (.getConstant HotSpot'config, "markOopDesc::biased_lock_pattern",       Integer))
    (def #_"int" HotSpot'ageMaskInPlace        (.getConstant HotSpot'config, "markOopDesc::age_mask_in_place",         Integer))
    (def #_"int" HotSpot'epochMaskInPlace      (.getConstant HotSpot'config, "markOopDesc::epoch_mask_in_place",       Integer))
    (def #_"int" HotSpot'unlockedMask          (.getConstant HotSpot'config, "markOopDesc::unlocked_value",            Integer))
    (def #_"int" HotSpot'monitorMask           (.getConstant HotSpot'config, "markOopDesc::monitor_value",             Integer, -1))

    ;; this field has no type in vmStructs.cpp
    (def #_"int" HotSpot'objectMonitorOwnerOffset      (.getFieldOffset HotSpot'config, "ObjectMonitor::_owner",      Integer, nil,             -1))
    (def #_"int" HotSpot'objectMonitorRecursionsOffset (.getFieldOffset HotSpot'config, "ObjectMonitor::_recursions", Integer, "intptr_t",      -1))
    (def #_"int" HotSpot'objectMonitorCxqOffset        (.getFieldOffset HotSpot'config, "ObjectMonitor::_cxq",        Integer, "ObjectWaiter*", -1))
    (def #_"int" HotSpot'objectMonitorEntryListOffset  (.getFieldOffset HotSpot'config, "ObjectMonitor::_EntryList",  Integer, "ObjectWaiter*", -1))

    ;;;
     ; Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
     ; are allowed to look like (respectively) the high or low bits of a real oop.
     ;;
    (def #_"long" HotSpot'nonOopBits (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_non_oop_bits", Long, "void*"))

    (def #_"int" HotSpot'logOfHeapRegionGrainBytes (.getFieldValue HotSpot'config, "HeapRegion::LogOfHRGrainBytes", Integer, "int"))

    (def #_"long" HotSpot'cardTableAddress (.getFieldValue HotSpot'config, "CompilerToVM::Data::cardtable_start_address", Long, "jbyte*"))
    (def #_"int" HotSpot'cardTableShift (.getFieldValue HotSpot'config, "CompilerToVM::Data::cardtable_shift", Integer, "int"))

    (def #_"long" HotSpot'safepointPollingAddress (.getFieldValue HotSpot'config, "os::_polling_page", Long, "address"))

    ;; G1 Collector Related Values.
    (def #_"byte" HotSpot'dirtyCardValue   (.getConstant HotSpot'config, "CardTableModRefBS::dirty_card",         Byte))
    (def #_"byte" HotSpot'g1YoungCardValue (.getConstant HotSpot'config, "G1SATBCardTableModRefBS::g1_young_gen", Byte))

    (def #_"int" HotSpot'javaThreadDirtyCardQueueOffset (.getFieldOffset HotSpot'config, "JavaThread::_dirty_card_queue", Integer, "DirtyCardQueue"))
    (def #_"int" HotSpot'javaThreadSatbMarkQueueOffset  (.getFieldOffset HotSpot'config, "JavaThread::_satb_mark_queue",  Integer))

    (def #_"int" HotSpot'g1CardQueueIndexOffset   (+ HotSpot'javaThreadDirtyCardQueueOffset (.getConstant HotSpot'config, "dirtyCardQueueIndexOffset",  Integer)))
    (def #_"int" HotSpot'g1CardQueueBufferOffset  (+ HotSpot'javaThreadDirtyCardQueueOffset (.getConstant HotSpot'config, "dirtyCardQueueBufferOffset", Integer)))
    (def #_"int" HotSpot'g1SATBQueueMarkingOffset (+ HotSpot'javaThreadSatbMarkQueueOffset  (.getConstant HotSpot'config, "satbMarkQueueActiveOffset",  Integer)))
    (def #_"int" HotSpot'g1SATBQueueIndexOffset   (+ HotSpot'javaThreadSatbMarkQueueOffset  (.getConstant HotSpot'config, "satbMarkQueueIndexOffset",   Integer)))
    (def #_"int" HotSpot'g1SATBQueueBufferOffset  (+ HotSpot'javaThreadSatbMarkQueueOffset  (.getConstant HotSpot'config, "satbMarkQueueBufferOffset",  Integer)))

    (def #_"int" HotSpot'klassOffset (.getFieldValue HotSpot'config, "java_lang_Class::_klass_offset", Integer, "int"))

    (def #_"int" HotSpot'lockDisplacedMarkOffset (.getFieldOffset HotSpot'config, "BasicLock::_displaced_header", Integer, "markOop"))

    (def #_"int" HotSpot'threadPollingPageOffset (.getFieldOffset HotSpot'config, "Thread::_polling_page", Integer, "address"))

    (def #_"int" HotSpot'threadTlabEndOffset (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_end", Integer, "HeapWord*")))
    (def #_"int" HotSpot'threadTlabTopOffset (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_top", Integer, "HeapWord*")))

    (def #_"long" HotSpot'handleDeoptStub  (.getFieldValue HotSpot'config, "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack",        Long, "address"))
    (def #_"long" HotSpot'uncommonTrapStub (.getFieldValue HotSpot'config, "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", Long, "address"))

    (def #_"long" HotSpot'codeCacheLowBound  (.getFieldValue HotSpot'config, "CodeCache::_low_bound",  Long, "address"))
    (def #_"long" HotSpot'codeCacheHighBound (.getFieldValue HotSpot'config, "CodeCache::_high_bound", Long, "address"))

    (def #_"long" HotSpot'newInstanceAddress        (.getAddress HotSpot'config, "JVMCIRuntime::new_instance"))
    (def #_"long" HotSpot'newArrayAddress           (.getAddress HotSpot'config, "JVMCIRuntime::new_array"))
    (def #_"long" HotSpot'monitorenterAddress       (.getAddress HotSpot'config, "JVMCIRuntime::monitorenter"))
    (def #_"long" HotSpot'monitorexitAddress        (.getAddress HotSpot'config, "JVMCIRuntime::monitorexit"))
    (def #_"long" HotSpot'writeBarrierPreAddress    (.getAddress HotSpot'config, "JVMCIRuntime::write_barrier_pre"))
    (def #_"long" HotSpot'writeBarrierPostAddress   (.getAddress HotSpot'config, "JVMCIRuntime::write_barrier_post"))

    (def #_"int" HotSpot'verifiedEntryMark             (.getConstant HotSpot'config, "CodeInstaller::VERIFIED_ENTRY",                 Integer))
    (def #_"int" HotSpot'deoptHandlerEntryMark         (.getConstant HotSpot'config, "CodeInstaller::DEOPT_HANDLER_ENTRY",            Integer))
    (def #_"int" HotSpot'invokeinterfaceMark           (.getConstant HotSpot'config, "CodeInstaller::INVOKEINTERFACE",                Integer))
    (def #_"int" HotSpot'invokevirtualMark             (.getConstant HotSpot'config, "CodeInstaller::INVOKEVIRTUAL",                  Integer))
    (def #_"int" HotSpot'invokestaticMark              (.getConstant HotSpot'config, "CodeInstaller::INVOKESTATIC",                   Integer))
    (def #_"int" HotSpot'invokespecialMark             (.getConstant HotSpot'config, "CodeInstaller::INVOKESPECIAL",                  Integer))
    (def #_"int" HotSpot'pollNearMark                  (.getConstant HotSpot'config, "CodeInstaller::POLL_NEAR",                      Integer))
    (def #_"int" HotSpot'pollReturnNearMark            (.getConstant HotSpot'config, "CodeInstaller::POLL_RETURN_NEAR",               Integer))
    (def #_"int" HotSpot'pollFarMark                   (.getConstant HotSpot'config, "CodeInstaller::POLL_FAR",                       Integer))
    (def #_"int" HotSpot'pollReturnFarMark             (.getConstant HotSpot'config, "CodeInstaller::POLL_RETURN_FAR",                Integer))
    (def #_"int" HotSpot'cardTableAddressMark          (.getConstant HotSpot'config, "CodeInstaller::CARD_TABLE_ADDRESS",             Integer))
    (def #_"int" HotSpot'logOfHeapRegionGrainBytesMark (.getConstant HotSpot'config, "CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES", Integer))

    (defn- #_"?" peep [#_"Class" class #_"String" field] (let [#_"Field" f (.getDeclaredField class, field)] (.setAccessible f, true) (.get f, class)))

    (def #_"Unsafe" HotSpot'unsafe (peep Unsafe "theUnsafe"))

    (def #_"int" Unsafe'ARRAY_BOOLEAN_BASE_OFFSET (peep Unsafe "ARRAY_BOOLEAN_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_BYTE_BASE_OFFSET    (peep Unsafe "ARRAY_BYTE_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_SHORT_BASE_OFFSET   (peep Unsafe "ARRAY_SHORT_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_CHAR_BASE_OFFSET    (peep Unsafe "ARRAY_CHAR_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_INT_BASE_OFFSET     (peep Unsafe "ARRAY_INT_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_LONG_BASE_OFFSET    (peep Unsafe "ARRAY_LONG_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_OBJECT_BASE_OFFSET  (peep Unsafe "ARRAY_OBJECT_BASE_OFFSET"))

    (def #_"int" Unsafe'ARRAY_BOOLEAN_INDEX_SCALE (peep Unsafe "ARRAY_BOOLEAN_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_BYTE_INDEX_SCALE    (peep Unsafe "ARRAY_BYTE_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_SHORT_INDEX_SCALE   (peep Unsafe "ARRAY_SHORT_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_CHAR_INDEX_SCALE    (peep Unsafe "ARRAY_CHAR_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_INT_INDEX_SCALE     (peep Unsafe "ARRAY_INT_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_LONG_INDEX_SCALE    (peep Unsafe "ARRAY_LONG_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_OBJECT_INDEX_SCALE  (peep Unsafe "ARRAY_OBJECT_INDEX_SCALE"))

    (defn #_"int" HotSpot'arrayBaseOffset-1 [#_"JavaKind" kind]
        (condp = kind
            JavaKind/Boolean Unsafe'ARRAY_BOOLEAN_BASE_OFFSET
            JavaKind/Byte    Unsafe'ARRAY_BYTE_BASE_OFFSET
            JavaKind/Short   Unsafe'ARRAY_SHORT_BASE_OFFSET
            JavaKind/Char    Unsafe'ARRAY_CHAR_BASE_OFFSET
            JavaKind/Int     Unsafe'ARRAY_INT_BASE_OFFSET
            JavaKind/Long    Unsafe'ARRAY_LONG_BASE_OFFSET
            JavaKind/Object  Unsafe'ARRAY_OBJECT_BASE_OFFSET
        )
    )

    (defn #_"int" HotSpot'arrayIndexScale-1 [#_"JavaKind" kind]
        (condp = kind
            JavaKind/Boolean Unsafe'ARRAY_BOOLEAN_INDEX_SCALE
            JavaKind/Byte    Unsafe'ARRAY_BYTE_INDEX_SCALE
            JavaKind/Short   Unsafe'ARRAY_SHORT_INDEX_SCALE
            JavaKind/Char    Unsafe'ARRAY_CHAR_INDEX_SCALE
            JavaKind/Int     Unsafe'ARRAY_INT_INDEX_SCALE
            JavaKind/Long    Unsafe'ARRAY_LONG_INDEX_SCALE
            JavaKind/Object  Unsafe'ARRAY_OBJECT_INDEX_SCALE
        )
    )

    ;;;
     ; Special registers reserved by HotSpot for frequently used values.
     ;;
    (def #_"Register" HotSpot'threadRegister       AMD64/r15)
    (def #_"Register" HotSpot'heapBaseRegister     AMD64/r12)
    (def #_"Register" HotSpot'stackPointerRegister AMD64/rsp)

    (ยง def #_"ValueKindFactory<LIRKind>" HotSpot'valueKindFactory
        (reify ValueKindFactory #_"<LIRKind>"
            (#_"LIRKind" getValueKind [#_"ValueKindFactory<LIRKind>" _, #_"JavaKind" javaKind]
                (LIRKind'fromJavaKind-2 (.arch HotSpot'target), javaKind)
            )
        )
    )

    (ยง def #_"BytecodeProvider" HotSpot'defaultBytecodeProvider (ClassfileBytecodeProvider'new-0))

    (ยง def #_"ForeignCalls" HotSpot'foreignCalls (ForeignCalls'new-0))
    (ยง def #_"Replacements" HotSpot'replacements (Replacements'new-0))
    (ยง def #_"Plugins"      HotSpot'plugins      (Plugins'create-0))

    (ยง def #_"PhaseSuite" HotSpot'graphBuilderSuite (Suites'createGraphBuilderSuite-0))
)

;;;
 ; Constants for X86 prefix bytes.
 ;;
(value-ns Prefix
    (def #_"int" Prefix'REX     0x40)
    (def #_"int" Prefix'REXB    0x41)
    (def #_"int" Prefix'REXX    0x42)
    (def #_"int" Prefix'REXXB   0x43)
    (def #_"int" Prefix'REXR    0x44)
    (def #_"int" Prefix'REXRB   0x45)
    (def #_"int" Prefix'REXRX   0x46)
    (def #_"int" Prefix'REXRXB  0x47)
    (def #_"int" Prefix'REXW    0x48)
    (def #_"int" Prefix'REXWB   0x49)
    (def #_"int" Prefix'REXWX   0x4a)
    (def #_"int" Prefix'REXWXB  0x4b)
    (def #_"int" Prefix'REXWR   0x4c)
    (def #_"int" Prefix'REXWRB  0x4d)
    (def #_"int" Prefix'REXWRX  0x4e)
    (def #_"int" Prefix'REXWRXB 0x4f)
)

;;;
 ; Definitions of the standard Java bytecodes defined by
 ; <a href= "http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">Java Virtual Machine Specification</a>.
 ;;
(value-ns Bytecodes
    (def #_"int" Bytecodes'NOP               0) ;; 0x00
    (def #_"int" Bytecodes'ACONST_NULL       1) ;; 0x01
    (def #_"int" Bytecodes'ICONST_M1         2) ;; 0x02
    (def #_"int" Bytecodes'ICONST_0          3) ;; 0x03
    (def #_"int" Bytecodes'ICONST_1          4) ;; 0x04
    (def #_"int" Bytecodes'ICONST_2          5) ;; 0x05
    (def #_"int" Bytecodes'ICONST_3          6) ;; 0x06
    (def #_"int" Bytecodes'ICONST_4          7) ;; 0x07
    (def #_"int" Bytecodes'ICONST_5          8) ;; 0x08
    (def #_"int" Bytecodes'LCONST_0          9) ;; 0x09
    (def #_"int" Bytecodes'LCONST_1         10) ;; 0x0a
    (def #_"int" Bytecodes'BIPUSH           16) ;; 0x10
    (def #_"int" Bytecodes'SIPUSH           17) ;; 0x11
    (def #_"int" Bytecodes'LDC              18) ;; 0x12
    (def #_"int" Bytecodes'LDC_W            19) ;; 0x13
    (def #_"int" Bytecodes'LDC2_W           20) ;; 0x14
    (def #_"int" Bytecodes'ILOAD            21) ;; 0x15
    (def #_"int" Bytecodes'LLOAD            22) ;; 0x16
    (def #_"int" Bytecodes'ALOAD            25) ;; 0x19
    (def #_"int" Bytecodes'ILOAD_0          26) ;; 0x1a
    (def #_"int" Bytecodes'ILOAD_1          27) ;; 0x1b
    (def #_"int" Bytecodes'ILOAD_2          28) ;; 0x1c
    (def #_"int" Bytecodes'ILOAD_3          29) ;; 0x1d
    (def #_"int" Bytecodes'LLOAD_0          30) ;; 0x1e
    (def #_"int" Bytecodes'LLOAD_1          31) ;; 0x1f
    (def #_"int" Bytecodes'LLOAD_2          32) ;; 0x20
    (def #_"int" Bytecodes'LLOAD_3          33) ;; 0x21
    (def #_"int" Bytecodes'ALOAD_0          42) ;; 0x2a
    (def #_"int" Bytecodes'ALOAD_1          43) ;; 0x2b
    (def #_"int" Bytecodes'ALOAD_2          44) ;; 0x2c
    (def #_"int" Bytecodes'ALOAD_3          45) ;; 0x2d
    (def #_"int" Bytecodes'IALOAD           46) ;; 0x2e
    (def #_"int" Bytecodes'LALOAD           47) ;; 0x2f
    (def #_"int" Bytecodes'AALOAD           50) ;; 0x32
    (def #_"int" Bytecodes'BALOAD           51) ;; 0x33
    (def #_"int" Bytecodes'CALOAD           52) ;; 0x34
    (def #_"int" Bytecodes'SALOAD           53) ;; 0x35
    (def #_"int" Bytecodes'ISTORE           54) ;; 0x36
    (def #_"int" Bytecodes'LSTORE           55) ;; 0x37
    (def #_"int" Bytecodes'ASTORE           58) ;; 0x3a
    (def #_"int" Bytecodes'ISTORE_0         59) ;; 0x3b
    (def #_"int" Bytecodes'ISTORE_1         60) ;; 0x3c
    (def #_"int" Bytecodes'ISTORE_2         61) ;; 0x3d
    (def #_"int" Bytecodes'ISTORE_3         62) ;; 0x3e
    (def #_"int" Bytecodes'LSTORE_0         63) ;; 0x3f
    (def #_"int" Bytecodes'LSTORE_1         64) ;; 0x40
    (def #_"int" Bytecodes'LSTORE_2         65) ;; 0x41
    (def #_"int" Bytecodes'LSTORE_3         66) ;; 0x42
    (def #_"int" Bytecodes'ASTORE_0         75) ;; 0x4b
    (def #_"int" Bytecodes'ASTORE_1         76) ;; 0x4c
    (def #_"int" Bytecodes'ASTORE_2         77) ;; 0x4d
    (def #_"int" Bytecodes'ASTORE_3         78) ;; 0x4e
    (def #_"int" Bytecodes'IASTORE          79) ;; 0x4f
    (def #_"int" Bytecodes'LASTORE          80) ;; 0x50
    (def #_"int" Bytecodes'AASTORE          83) ;; 0x53
    (def #_"int" Bytecodes'BASTORE          84) ;; 0x54
    (def #_"int" Bytecodes'CASTORE          85) ;; 0x55
    (def #_"int" Bytecodes'SASTORE          86) ;; 0x56
    (def #_"int" Bytecodes'POP              87) ;; 0x57
    (def #_"int" Bytecodes'POP2             88) ;; 0x58
    (def #_"int" Bytecodes'DUP              89) ;; 0x59
    (def #_"int" Bytecodes'DUP_X1           90) ;; 0x5a
    (def #_"int" Bytecodes'DUP_X2           91) ;; 0x5b
    (def #_"int" Bytecodes'DUP2             92) ;; 0x5c
    (def #_"int" Bytecodes'DUP2_X1          93) ;; 0x5d
    (def #_"int" Bytecodes'DUP2_X2          94) ;; 0x5e
    (def #_"int" Bytecodes'SWAP             95) ;; 0x5f
    (def #_"int" Bytecodes'IADD             96) ;; 0x60
    (def #_"int" Bytecodes'LADD             97) ;; 0x61
    (def #_"int" Bytecodes'ISUB            100) ;; 0x64
    (def #_"int" Bytecodes'LSUB            101) ;; 0x65
    (def #_"int" Bytecodes'IMUL            104) ;; 0x68
    (def #_"int" Bytecodes'LMUL            105) ;; 0x69
    (def #_"int" Bytecodes'IDIV            108) ;; 0x6c
    (def #_"int" Bytecodes'LDIV            109) ;; 0x6d
    (def #_"int" Bytecodes'IREM            112) ;; 0x70
    (def #_"int" Bytecodes'LREM            113) ;; 0x71
    (def #_"int" Bytecodes'INEG            116) ;; 0x74
    (def #_"int" Bytecodes'LNEG            117) ;; 0x75
    (def #_"int" Bytecodes'ISHL            120) ;; 0x78
    (def #_"int" Bytecodes'LSHL            121) ;; 0x79
    (def #_"int" Bytecodes'ISHR            122) ;; 0x7a
    (def #_"int" Bytecodes'LSHR            123) ;; 0x7b
    (def #_"int" Bytecodes'IUSHR           124) ;; 0x7c
    (def #_"int" Bytecodes'LUSHR           125) ;; 0x7d
    (def #_"int" Bytecodes'IAND            126) ;; 0x7e
    (def #_"int" Bytecodes'LAND            127) ;; 0x7f
    (def #_"int" Bytecodes'IOR             128) ;; 0x80
    (def #_"int" Bytecodes'LOR             129) ;; 0x81
    (def #_"int" Bytecodes'IXOR            130) ;; 0x82
    (def #_"int" Bytecodes'LXOR            131) ;; 0x83
    (def #_"int" Bytecodes'IINC            132) ;; 0x84
    (def #_"int" Bytecodes'I2L             133) ;; 0x85
    (def #_"int" Bytecodes'L2I             136) ;; 0x88
    (def #_"int" Bytecodes'I2B             145) ;; 0x91
    (def #_"int" Bytecodes'I2C             146) ;; 0x92
    (def #_"int" Bytecodes'I2S             147) ;; 0x93
    (def #_"int" Bytecodes'LCMP            148) ;; 0x94
    (def #_"int" Bytecodes'IFEQ            153) ;; 0x99
    (def #_"int" Bytecodes'IFNE            154) ;; 0x9a
    (def #_"int" Bytecodes'IFLT            155) ;; 0x9b
    (def #_"int" Bytecodes'IFGE            156) ;; 0x9c
    (def #_"int" Bytecodes'IFGT            157) ;; 0x9d
    (def #_"int" Bytecodes'IFLE            158) ;; 0x9e
    (def #_"int" Bytecodes'IF_ICMPEQ       159) ;; 0x9f
    (def #_"int" Bytecodes'IF_ICMPNE       160) ;; 0xa0
    (def #_"int" Bytecodes'IF_ICMPLT       161) ;; 0xa1
    (def #_"int" Bytecodes'IF_ICMPGE       162) ;; 0xa2
    (def #_"int" Bytecodes'IF_ICMPGT       163) ;; 0xa3
    (def #_"int" Bytecodes'IF_ICMPLE       164) ;; 0xa4
    (def #_"int" Bytecodes'IF_ACMPEQ       165) ;; 0xa5
    (def #_"int" Bytecodes'IF_ACMPNE       166) ;; 0xa6
    (def #_"int" Bytecodes'GOTO            167) ;; 0xa7
    (def #_"int" Bytecodes'JSR             168) ;; 0xa8
    (def #_"int" Bytecodes'RET             169) ;; 0xa9
    (def #_"int" Bytecodes'TABLESWITCH     170) ;; 0xaa
    (def #_"int" Bytecodes'LOOKUPSWITCH    171) ;; 0xab
    (def #_"int" Bytecodes'IRETURN         172) ;; 0xac
    (def #_"int" Bytecodes'LRETURN         173) ;; 0xad
    (def #_"int" Bytecodes'ARETURN         176) ;; 0xb0
    (def #_"int" Bytecodes'RETURN          177) ;; 0xb1
    (def #_"int" Bytecodes'GETSTATIC       178) ;; 0xb2
    (def #_"int" Bytecodes'PUTSTATIC       179) ;; 0xb3
    (def #_"int" Bytecodes'GETFIELD        180) ;; 0xb4
    (def #_"int" Bytecodes'PUTFIELD        181) ;; 0xb5
    (def #_"int" Bytecodes'INVOKEVIRTUAL   182) ;; 0xb6
    (def #_"int" Bytecodes'INVOKESPECIAL   183) ;; 0xb7
    (def #_"int" Bytecodes'INVOKESTATIC    184) ;; 0xb8
    (def #_"int" Bytecodes'INVOKEINTERFACE 185) ;; 0xb9
    (def #_"int" Bytecodes'INVOKEDYNAMIC   186) ;; 0xba
    (def #_"int" Bytecodes'NEW             187) ;; 0xbb
    (def #_"int" Bytecodes'NEWARRAY        188) ;; 0xbc
    (def #_"int" Bytecodes'ANEWARRAY       189) ;; 0xbd
    (def #_"int" Bytecodes'ARRAYLENGTH     190) ;; 0xbe
    (def #_"int" Bytecodes'CHECKCAST       192) ;; 0xc0
    (def #_"int" Bytecodes'INSTANCEOF      193) ;; 0xc1
    (def #_"int" Bytecodes'MONITORENTER    194) ;; 0xc2
    (def #_"int" Bytecodes'MONITOREXIT     195) ;; 0xc3
    (def #_"int" Bytecodes'WIDE            196) ;; 0xc4
    (def #_"int" Bytecodes'IFNULL          198) ;; 0xc6
    (def #_"int" Bytecodes'IFNONNULL       199) ;; 0xc7
    (def #_"int" Bytecodes'GOTO_W          200) ;; 0xc8
    (def #_"int" Bytecodes'JSR_W           201) ;; 0xc9

    (def #_"int" Bytecodes'ILLEGAL         255)
    (def #_"int" Bytecodes'END             256)

    ;;;
     ; An array that maps from a bytecode value to the length in bytes for the corresponding instruction.
     ;;
    (def- #_"int[]" Bytecodes'lengthArray (int-array 256))

    ;;;
     ; Defines a bytecode.
     ;
     ; @param format encodes the length of the instruction
     ;;
    (defn- #_"void" Bytecodes'def-2 [#_"int" opcode, #_"String" format]
        (aset Bytecodes'lengthArray opcode (count format))
        nil
    )

    (ยง init
        (Bytecodes'def-2 Bytecodes'NOP,             "b")
        (Bytecodes'def-2 Bytecodes'ACONST_NULL,     "b")
        (Bytecodes'def-2 Bytecodes'ICONST_M1,       "b")
        (Bytecodes'def-2 Bytecodes'ICONST_0,        "b")
        (Bytecodes'def-2 Bytecodes'ICONST_1,        "b")
        (Bytecodes'def-2 Bytecodes'ICONST_2,        "b")
        (Bytecodes'def-2 Bytecodes'ICONST_3,        "b")
        (Bytecodes'def-2 Bytecodes'ICONST_4,        "b")
        (Bytecodes'def-2 Bytecodes'ICONST_5,        "b")
        (Bytecodes'def-2 Bytecodes'LCONST_0,        "b")
        (Bytecodes'def-2 Bytecodes'LCONST_1,        "b")
        (Bytecodes'def-2 Bytecodes'BIPUSH,          "bc")
        (Bytecodes'def-2 Bytecodes'SIPUSH,          "bcc")
        (Bytecodes'def-2 Bytecodes'LDC,             "bi")
        (Bytecodes'def-2 Bytecodes'LDC_W,           "bii")
        (Bytecodes'def-2 Bytecodes'LDC2_W,          "bii")
        (Bytecodes'def-2 Bytecodes'ILOAD,           "bi")
        (Bytecodes'def-2 Bytecodes'LLOAD,           "bi")
        (Bytecodes'def-2 Bytecodes'ALOAD,           "bi")
        (Bytecodes'def-2 Bytecodes'ILOAD_0,         "b")
        (Bytecodes'def-2 Bytecodes'ILOAD_1,         "b")
        (Bytecodes'def-2 Bytecodes'ILOAD_2,         "b")
        (Bytecodes'def-2 Bytecodes'ILOAD_3,         "b")
        (Bytecodes'def-2 Bytecodes'LLOAD_0,         "b")
        (Bytecodes'def-2 Bytecodes'LLOAD_1,         "b")
        (Bytecodes'def-2 Bytecodes'LLOAD_2,         "b")
        (Bytecodes'def-2 Bytecodes'LLOAD_3,         "b")
        (Bytecodes'def-2 Bytecodes'ALOAD_0,         "b")
        (Bytecodes'def-2 Bytecodes'ALOAD_1,         "b")
        (Bytecodes'def-2 Bytecodes'ALOAD_2,         "b")
        (Bytecodes'def-2 Bytecodes'ALOAD_3,         "b")
        (Bytecodes'def-2 Bytecodes'IALOAD,          "b")
        (Bytecodes'def-2 Bytecodes'LALOAD,          "b")
        (Bytecodes'def-2 Bytecodes'AALOAD,          "b")
        (Bytecodes'def-2 Bytecodes'BALOAD,          "b")
        (Bytecodes'def-2 Bytecodes'CALOAD,          "b")
        (Bytecodes'def-2 Bytecodes'SALOAD,          "b")
        (Bytecodes'def-2 Bytecodes'ISTORE,          "bi")
        (Bytecodes'def-2 Bytecodes'LSTORE,          "bi")
        (Bytecodes'def-2 Bytecodes'ASTORE,          "bi")
        (Bytecodes'def-2 Bytecodes'ISTORE_0,        "b")
        (Bytecodes'def-2 Bytecodes'ISTORE_1,        "b")
        (Bytecodes'def-2 Bytecodes'ISTORE_2,        "b")
        (Bytecodes'def-2 Bytecodes'ISTORE_3,        "b")
        (Bytecodes'def-2 Bytecodes'LSTORE_0,        "b")
        (Bytecodes'def-2 Bytecodes'LSTORE_1,        "b")
        (Bytecodes'def-2 Bytecodes'LSTORE_2,        "b")
        (Bytecodes'def-2 Bytecodes'LSTORE_3,        "b")
        (Bytecodes'def-2 Bytecodes'ASTORE_0,        "b")
        (Bytecodes'def-2 Bytecodes'ASTORE_1,        "b")
        (Bytecodes'def-2 Bytecodes'ASTORE_2,        "b")
        (Bytecodes'def-2 Bytecodes'ASTORE_3,        "b")
        (Bytecodes'def-2 Bytecodes'IASTORE,         "b")
        (Bytecodes'def-2 Bytecodes'LASTORE,         "b")
        (Bytecodes'def-2 Bytecodes'AASTORE,         "b")
        (Bytecodes'def-2 Bytecodes'BASTORE,         "b")
        (Bytecodes'def-2 Bytecodes'CASTORE,         "b")
        (Bytecodes'def-2 Bytecodes'SASTORE,         "b")
        (Bytecodes'def-2 Bytecodes'POP,             "b")
        (Bytecodes'def-2 Bytecodes'POP2,            "b")
        (Bytecodes'def-2 Bytecodes'DUP,             "b")
        (Bytecodes'def-2 Bytecodes'DUP_X1,          "b")
        (Bytecodes'def-2 Bytecodes'DUP_X2,          "b")
        (Bytecodes'def-2 Bytecodes'DUP2,            "b")
        (Bytecodes'def-2 Bytecodes'DUP2_X1,         "b")
        (Bytecodes'def-2 Bytecodes'DUP2_X2,         "b")
        (Bytecodes'def-2 Bytecodes'SWAP,            "b")
        (Bytecodes'def-2 Bytecodes'IADD,            "b")
        (Bytecodes'def-2 Bytecodes'LADD,            "b")
        (Bytecodes'def-2 Bytecodes'ISUB,            "b")
        (Bytecodes'def-2 Bytecodes'LSUB,            "b")
        (Bytecodes'def-2 Bytecodes'IMUL,            "b")
        (Bytecodes'def-2 Bytecodes'LMUL,            "b")
        (Bytecodes'def-2 Bytecodes'IDIV,            "b")
        (Bytecodes'def-2 Bytecodes'LDIV,            "b")
        (Bytecodes'def-2 Bytecodes'IREM,            "b")
        (Bytecodes'def-2 Bytecodes'LREM,            "b")
        (Bytecodes'def-2 Bytecodes'INEG,            "b")
        (Bytecodes'def-2 Bytecodes'LNEG,            "b")
        (Bytecodes'def-2 Bytecodes'ISHL,            "b")
        (Bytecodes'def-2 Bytecodes'LSHL,            "b")
        (Bytecodes'def-2 Bytecodes'ISHR,            "b")
        (Bytecodes'def-2 Bytecodes'LSHR,            "b")
        (Bytecodes'def-2 Bytecodes'IUSHR,           "b")
        (Bytecodes'def-2 Bytecodes'LUSHR,           "b")
        (Bytecodes'def-2 Bytecodes'IAND,            "b")
        (Bytecodes'def-2 Bytecodes'LAND,            "b")
        (Bytecodes'def-2 Bytecodes'IOR,             "b")
        (Bytecodes'def-2 Bytecodes'LOR,             "b")
        (Bytecodes'def-2 Bytecodes'IXOR,            "b")
        (Bytecodes'def-2 Bytecodes'LXOR,            "b")
        (Bytecodes'def-2 Bytecodes'IINC,            "bic")
        (Bytecodes'def-2 Bytecodes'I2L,             "b")
        (Bytecodes'def-2 Bytecodes'L2I,             "b")
        (Bytecodes'def-2 Bytecodes'I2B,             "b")
        (Bytecodes'def-2 Bytecodes'I2C,             "b")
        (Bytecodes'def-2 Bytecodes'I2S,             "b")
        (Bytecodes'def-2 Bytecodes'LCMP,            "b")
        (Bytecodes'def-2 Bytecodes'IFEQ,            "boo")
        (Bytecodes'def-2 Bytecodes'IFNE,            "boo")
        (Bytecodes'def-2 Bytecodes'IFLT,            "boo")
        (Bytecodes'def-2 Bytecodes'IFGE,            "boo")
        (Bytecodes'def-2 Bytecodes'IFGT,            "boo")
        (Bytecodes'def-2 Bytecodes'IFLE,            "boo")
        (Bytecodes'def-2 Bytecodes'IF_ICMPEQ,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ICMPNE,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ICMPLT,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ICMPGE,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ICMPGT,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ICMPLE,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ACMPEQ,       "boo")
        (Bytecodes'def-2 Bytecodes'IF_ACMPNE,       "boo")
        (Bytecodes'def-2 Bytecodes'GOTO,            "boo")
        (Bytecodes'def-2 Bytecodes'JSR,             "boo")
        (Bytecodes'def-2 Bytecodes'RET,             "bi")
        (Bytecodes'def-2 Bytecodes'TABLESWITCH,     "")
        (Bytecodes'def-2 Bytecodes'LOOKUPSWITCH,    "")
        (Bytecodes'def-2 Bytecodes'IRETURN,         "b")
        (Bytecodes'def-2 Bytecodes'LRETURN,         "b")
        (Bytecodes'def-2 Bytecodes'ARETURN,         "b")
        (Bytecodes'def-2 Bytecodes'RETURN,          "b")
        (Bytecodes'def-2 Bytecodes'GETSTATIC,       "bjj")
        (Bytecodes'def-2 Bytecodes'PUTSTATIC,       "bjj")
        (Bytecodes'def-2 Bytecodes'GETFIELD,        "bjj")
        (Bytecodes'def-2 Bytecodes'PUTFIELD,        "bjj")
        (Bytecodes'def-2 Bytecodes'INVOKEVIRTUAL,   "bjj")
        (Bytecodes'def-2 Bytecodes'INVOKESPECIAL,   "bjj")
        (Bytecodes'def-2 Bytecodes'INVOKESTATIC,    "bjj")
        (Bytecodes'def-2 Bytecodes'INVOKEINTERFACE, "bjja_")
        (Bytecodes'def-2 Bytecodes'INVOKEDYNAMIC,   "bjjjj")
        (Bytecodes'def-2 Bytecodes'NEW,             "bii")
        (Bytecodes'def-2 Bytecodes'NEWARRAY,        "bc")
        (Bytecodes'def-2 Bytecodes'ANEWARRAY,       "bii")
        (Bytecodes'def-2 Bytecodes'ARRAYLENGTH,     "b")
        (Bytecodes'def-2 Bytecodes'CHECKCAST,       "bii")
        (Bytecodes'def-2 Bytecodes'INSTANCEOF,      "bii")
        (Bytecodes'def-2 Bytecodes'MONITORENTER,    "b")
        (Bytecodes'def-2 Bytecodes'MONITOREXIT,     "b")
        (Bytecodes'def-2 Bytecodes'WIDE,            "")
        (Bytecodes'def-2 Bytecodes'IFNULL,          "boo")
        (Bytecodes'def-2 Bytecodes'IFNONNULL,       "boo")
        (Bytecodes'def-2 Bytecodes'GOTO_W,          "boooo")
        (Bytecodes'def-2 Bytecodes'JSR_W,           "boooo")
    )

    ;;;
     ; Gets the length of an instruction denoted by a given opcode.
     ;
     ; @return the length of the instruction denoted by {@code opcode}. If {@code opcode} is an
     ;         illegal instruction or denotes a variable length instruction (e.g. #TABLESWITCH),
     ;         then 0 is returned.
     ;;
    (defn #_"int" Bytecodes'lengthOf-1 [#_"int" opcode]
        (nth Bytecodes'lengthArray (& opcode 0xff))
    )
)

;;;
 ; A collection of utility methods for dealing with bytes, particularly in byte arrays.
 ;;
(value-ns Bytes
    ;;;
     ; Gets a signed 1-byte value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the signed 1-byte value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beS1-2 [#_"byte[]" data, #_"int" bci]
        (nth data bci)
    )

    ;;;
     ; Gets a signed 2-byte big-endian value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the signed 2-byte, big-endian, value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beS2-2 [#_"byte[]" data, #_"int" bci]
        (| (<< (nth data bci) 8) (& (nth data (inc bci)) 0xff))
    )

    ;;;
     ; Gets an unsigned 1-byte value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the unsigned 1-byte value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beU1-2 [#_"byte[]" data, #_"int" bci]
        (& (nth data bci) 0xff)
    )

    ;;;
     ; Gets an unsigned 2-byte big-endian value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the unsigned 2-byte, big-endian, value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beU2-2 [#_"byte[]" data, #_"int" bci]
        (| (<< (& (nth data bci) 0xff) 8) (& (nth data (inc bci)) 0xff))
    )

    ;;;
     ; Gets a signed 4-byte big-endian value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the signed 4-byte, big-endian, value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beS4-2 [#_"byte[]" data, #_"int" bci]
        (| (<< (nth data bci) 24) (<< (& (nth data (inc bci)) 0xff) 16) (<< (& (nth data (+ bci 2)) 0xff) 8) (& (nth data (+ bci 3)) 0xff))
    )
)

(value-ns LIRKindTool
    ;;;
     ; Get an architecture specific integer kind of a certain size.
     ;;
    (defn #_"LIRKind" LIRKindTool'getIntegerKind-1 [#_"int" bits]
        (LIRKind'value-1
            (cond
                (<= bits 8)  AMD64Kind/BYTE
                (<= bits 16) AMD64Kind/WORD
                (<= bits 32) AMD64Kind/DWORD
                :else        AMD64Kind/QWORD
            )
        )
    )

    ;;;
     ; Get the architecture specific kind used to represent Java objects.
     ;;
    (defn #_"LIRKind" LIRKindTool'getObjectKind-0 []
        (LIRKind'reference-1 AMD64Kind/QWORD)
    )

    ;;;
     ; Get the architecture specific kind pointer-sized integer kind.
     ;;
    (defn #_"LIRKind" LIRKindTool'getWordKind-0 []
        (LIRKind'value-1 AMD64Kind/QWORD)
    )

    ;;;
     ; Get the platform specific kind used to represent compressed oops.
     ;;
    (defn #_"LIRKind" LIRKindTool'getNarrowOopKind-0 []
        (LIRKind'compressedReference-1 AMD64Kind/DWORD)
    )

    ;;;
     ; Gets the platform specific kind used to represent compressed metaspace pointers.
     ;;
    (defn #_"LIRKind" LIRKindTool'getNarrowPointerKind-0 []
        (LIRKind'value-1 AMD64Kind/DWORD)
    )
)

;;;
 ; Computes an ordering of the block that can be used by the linear scan register allocator and the
 ; machine code generator. The machine code generation order will start with the first block and
 ; produce a straight sequence always following the most likely successor. Then it will continue
 ; with the most likely path that was left out during this process. The process iteratively
 ; continues until all blocks are scheduled. Additionally, it is guaranteed that all blocks of a
 ; loop are scheduled before any block following the loop is scheduled.
 ;
 ; The machine code generator order includes reordering of loop headers such that the backward jump
 ; is a conditional jump if there is only one loop end block. Additionally, the target of loop
 ; backward jumps are always marked as aligned. Aligning the target of conditional jumps does not
 ; bring a measurable benefit and is therefore avoided to keep the code size small.
 ;
 ; The linear scan register allocator order has an additional mechanism that prevents merge nodes
 ; from being scheduled if there is at least one highly likely predecessor still unscheduled. This
 ; increases the probability that the merge node and the corresponding predecessor are more closely
 ; together in the schedule thus decreasing the probability for inserted phi moves. Also, the
 ; algorithm sets the linear scan order number of the block that corresponds to its index in the
 ; linear scan order.
 ;;
(value-ns ComputeBlockOrder
    ;;;
     ; The initial capacities of the worklists used for iteratively finding the block order.
     ;;
    (def- #_"int" ComputeBlockOrder'INITIAL_WORKLIST_CAPACITY 10)

    ;;;
     ; Divisor used for degrading the probability of the current path versus unscheduled paths at
     ; a merge node when calculating the linear scan order. A high value means that predecessors
     ; of merge nodes are more likely to be scheduled before the merge node.
     ;;
    (def- #_"int" ComputeBlockOrder'PENALTY_VERSUS_UNSCHEDULED 10)

    ;;;
     ; Find the highest likely unvisited successor block of a given block.
     ;;
    (defn- #_"Block" ComputeBlockOrder'findAndMarkMostLikelySuccessor-2 [#_"Block" block, #_"BitSet" visited]
        (let [
            #_"Block" result
                (loop-when [result nil #_"ISeq" s (seq (:successors block))] (some? s) => result
                    (let [
                        #_"Block" successor (first s)
                        result
                            (when (and (not (#_"BitSet" .get visited, (:id successor))) (<= (Block''getLoopDepth-1 block) (Block''getLoopDepth-1 successor)) (or (nil? result) (<= (:probability result) (:probability successor)))) => result
                                successor
                            )
                    ]
                        (recur result (next s))
                    )
                )
        ]
            (when (some? result)
                (#_"BitSet" .set visited, (:id result))
            )
            result
        )
    )

    ;;;
     ; Add successor blocks into the given work list if they are not already marked as visited.
     ;;
    (defn- #_"void" ComputeBlockOrder'enqueueSuccessors-3 [#_"Block" block, #_"PriorityQueue<Block>" worklist, #_"BitSet" visited]
        (doseq [#_"Block" successor (:successors block)]
            (when-not (#_"BitSet" .get visited, (:id successor))
                (#_"BitSet" .set visited, (:id successor))
                (#_"PriorityQueue" .add worklist, successor)
            )
        )
        nil
    )

    ;;;
     ; Add a linear path to the linear scan order greedily following the most likely successor.
     ;;
    (defn- #_"Block" ComputeBlockOrder'addPathToLinearScanOrder-4 [#_"Block" block, #_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visited]
        (ยง ass! block (Block''setLinearScanNumber-2 block, (count order)))
        (#_"List" .add order, block)
        (let [
            #_"Block" mostLikelySuccessor (ComputeBlockOrder'findAndMarkMostLikelySuccessor-2 block, visited)
        ]
            (ComputeBlockOrder'enqueueSuccessors-3 block, worklist, visited)
            (when (and (some? mostLikelySuccessor) (not (Block''isLoopHeader-1 mostLikelySuccessor)) (< 1 (count (:predecessors mostLikelySuccessor)))) => mostLikelySuccessor
                ;; We are at a merge. Check probabilities of predecessors that are not yet scheduled.
                (let [
                    #_"double" unscheduledSum
                        (loop-when [unscheduledSum 0.0 #_"ISeq" s (seq (:predecessors mostLikelySuccessor))] (some? s) => unscheduledSum
                            (let [
                                #_"Block" pred (first s)
                                unscheduledSum
                                    (when (= (:linearScanNumber pred) -1) => unscheduledSum
                                        (+ unscheduledSum (:probability pred))
                                    )
                            ]
                                (recur unscheduledSum (next s))
                            )
                        )
                ]
                    (when (< (/ (:probability block) ComputeBlockOrder'PENALTY_VERSUS_UNSCHEDULED) unscheduledSum) => mostLikelySuccessor
                        ;; Add this merge only after at least one additional predecessor gets scheduled.
                        (#_"BitSet" .clear visited, (:id mostLikelySuccessor))
                        nil
                    )
                )
            )
        )
    )

    ;;;
     ; Iteratively adds paths to the linear scan block order.
     ;;
    (defn- #_"void" ComputeBlockOrder'computeLinearScanOrder-3 [#_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visited]
        (while (seq worklist)
            (loop [#_"Block" path (#_"PriorityQueue" .poll worklist)]
                (let [
                    path (ComputeBlockOrder'addPathToLinearScanOrder-4 path, order, worklist, visited)
                ]
                    (recur-if (some? path) [path])
                )
            )
        )
        nil
    )

    ;;;
     ; Initializes the priority queue used for the work list of blocks and adds the start block.
     ;;
    (defn- #_"PriorityQueue<Block>" ComputeBlockOrder'initializeWorklist-2 [#_"Block" startBlock, #_"BitSet" visited]
        (let [
            #_"PriorityQueue<Block>" result (PriorityQueue. ComputeBlockOrder'INITIAL_WORKLIST_CAPACITY, (BlockOrderComparator'new-0))
        ]
            (#_"PriorityQueue" .add result, startBlock)
            (#_"BitSet" .set visited, (:id startBlock))
            result
        )
    )

    ;;;
     ; Computes the block order used for the linear scan register allocator.
     ;
     ; @return sorted list of blocks
     ;;
    (defn #_"Block[]" ComputeBlockOrder'computeLinearScanOrder-1 [#_"Block" startBlock]
        (let [
            #_"List<Block>" order (ArrayList.)
            #_"BitSet" visited (BitSet.)
        ]
            (ComputeBlockOrder'computeLinearScanOrder-3 order, (ComputeBlockOrder'initializeWorklist-2 startBlock, visited), visited)
            (into-array Block'iface order)
        )
    )

    ;;;
     ; Skip the loop header block if the loop consists of more than one block and it has only a single loop end block.
     ;;
    (defn- #_"boolean" ComputeBlockOrder'skipLoopHeader-1 [#_"Block" block]
        (and (Block''isLoopHeader-1 block) (not (Block''isLoopEnd-1 block)) (= (Loop''numBackedges-1 (:loop block)) 1))
    )

    ;;;
     ; Add a linear path to the code emission order greedily following the most likely successor.
     ;;
    (defn- #_"void" ComputeBlockOrder'addPathToCodeEmittingOrder-4 [#_"Block" block, #_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visited]
        (loop-when [block block] (some? block)
            ;; Skip loop headers if there is only a single loop end block to make
            ;; the backward jump be a conditional jump.
            (when-not (ComputeBlockOrder'skipLoopHeader-1 block)
                ;; Align unskipped loop headers as they are the target of the backward jump.
                (when (Block''isLoopHeader-1 block)
                    (ยง ass! block (Block''setAlign-2 block, true))
                )
                (#_"List" .add order, block)
            )

            (let [
                #_"Loop" _loop (:loop block)
            ]
                (when (and (Block''isLoopEnd-1 block) (ComputeBlockOrder'skipLoopHeader-1 (:header _loop)))
                    ;; This is the only loop end of a skipped loop header.
                    ;; Add the header immediately afterwards.
                    (#_"List" .add order, (:header _loop))

                    ;; Make sure the loop successors of the loop header are aligned,
                    ;; as they are the target of the backward jump.
                    (doseq [#_"Block" successor (:successors (:header _loop))]
                        (when (= (Block''getLoopDepth-1 successor) (Block''getLoopDepth-1 block))
                            (ยง ass! successor (Block''setAlign-2 successor, true))
                        )
                    )
                )

                (let [
                    #_"Block" mostLikelySuccessor (ComputeBlockOrder'findAndMarkMostLikelySuccessor-2 block, visited)
                ]
                    (ComputeBlockOrder'enqueueSuccessors-3 block, worklist, visited)
                    (recur mostLikelySuccessor)
                )
            )
        )
        nil
    )

    ;;;
     ; Iteratively adds paths to the code emission block order.
     ;;
    (defn- #_"void" ComputeBlockOrder'computeCodeEmittingOrder-3 [#_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visited]
        (while (seq worklist)
            (ComputeBlockOrder'addPathToCodeEmittingOrder-4 (#_"PriorityQueue" .poll worklist), order, worklist, visited)
        )
        nil
    )

    ;;;
     ; Computes the block order used for code emission.
     ;
     ; @return sorted list of blocks
     ;;
    (defn #_"Block[]" ComputeBlockOrder'computeCodeEmittingOrder-1 [#_"Block" startBlock]
        (let [
            #_"List<Block>" order (ArrayList.)
            #_"BitSet" visited (BitSet.)
        ]
            (ComputeBlockOrder'computeCodeEmittingOrder-3 order, (ComputeBlockOrder'initializeWorklist-2 startBlock, visited), visited)
            (into-array Block'iface order)
        )
    )
)

;;;
 ; Configuration for register allocation. This is different to RegisterConfig.
 ;;
(value-ns RegisterAllocationConfig
    ;;;
     ; Specify priority of register selection within phases of register allocation. Highest priority is first.
     ; A useful heuristic is to give registers a low priority when they are required by machine instructions,
     ; like EAX and EDX on I486, and choose no-save registers before save-on-call and save-on-call before save-on-entry.
     ; Registers which participate in fixed calling sequences should come last.
     ; Registers which are used as pairs must fall on an even boundary.
     ;
     ; Adopted from x86_64.ad.
     ;;
    (def- #_"Register*" RegisterAllocationConfig'registerAllocationOrder
        [
            AMD64/r10, AMD64/r11, AMD64/r8, AMD64/r9, AMD64/r12,
            AMD64/rcx, AMD64/rbx, AMD64/rdi, AMD64/rdx, AMD64/rsi, AMD64/rax, AMD64/rbp,
            AMD64/r13, AMD64/r14, ;; AMD64/r15, AMD64/rsp
        ]
    )

    ;;;
     ; The ordered set of registers that can be used by the register allocator.
     ;;
    (ยง def #_"RegisterArray" RegisterAllocationConfig'allocatableRegisters
        (let [
            #_"RegisterArray" registers (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig)
            #_"BitSet" bits (BitSet.)
            _
                (doseq [#_"Register" reg registers]
                    (#_"BitSet" .set bits, (.number reg))
                )
            #_"ArrayList<Register>" allocatableRegisters (ArrayList.)
            _
                (doseq [#_"Register" reg RegisterAllocationConfig'registerAllocationOrder]
                    (when (#_"BitSet" .get bits, (.number reg))
                        (#_"ArrayList" .add allocatableRegisters, reg)
                    )
                )
        ]
            (RegisterArray. allocatableRegisters)
        )
    )

    (defn- #_"AllocatableRegisters" RegisterAllocationConfig'createAllocatableRegisters-1 [#_"RegisterArray" registers]
        (loop-when [#_"int" min Integer/MAX_VALUE #_"int" max Integer/MIN_VALUE #_"ISeq" s (seq registers)] (some? s) => (AllocatableRegisters'new-3 registers, min, max)
            (let [
                #_"int" n (.number (first s))
            ]
                (recur (if (< n min) n min) (if (< max n) n max) (next s))
            )
        )
    )

    ;;;
     ; Gets the set of registers that can be used by the register allocator for a value of a particular kind.
     ;;
    #_memoize
    (defn #_"AllocatableRegisters" RegisterAllocationConfig'getAllocatableRegisters-1 [#_"PlatformKind" kind]
        (let [
            #_"RegisterArray" available (#_"RegisterConfig" .filterAllocatableRegisters HotSpot'registerConfig, kind, RegisterAllocationConfig'allocatableRegisters)
        ]
            (RegisterAllocationConfig'createAllocatableRegisters-1 available)
        )
    )
)

;;;
 ; Utilities for unsigned comparisons. All methods have correct, but slow, standard Java
 ; implementations so that they can be used with compilers not supporting the intrinsics.
 ;;
(value-ns UnsignedMath
    (defn #_"boolean" UnsignedMath'aboveThan-2i    [#_"int" a, #_"int" b] (>  (Integer/compareUnsigned a, b) 0))
    (defn #_"boolean" UnsignedMath'aboveOrEqual-2i [#_"int" a, #_"int" b] (>= (Integer/compareUnsigned a, b) 0))
    (defn #_"boolean" UnsignedMath'belowThan-2i    [#_"int" a, #_"int" b] (<  (Integer/compareUnsigned a, b) 0))
    (defn #_"boolean" UnsignedMath'belowOrEqual-2i [#_"int" a, #_"int" b] (<= (Integer/compareUnsigned a, b) 0))

    (defn #_"boolean" UnsignedMath'aboveThan-2l    [#_"long" a, #_"long" b] (>  (Long/compareUnsigned a, b) 0))
    (defn #_"boolean" UnsignedMath'aboveOrEqual-2l [#_"long" a, #_"long" b] (>= (Long/compareUnsigned a, b) 0))
    (defn #_"boolean" UnsignedMath'belowThan-2l    [#_"long" a, #_"long" b] (<  (Long/compareUnsigned a, b) 0))
    (defn #_"boolean" UnsignedMath'belowOrEqual-2l [#_"long" a, #_"long" b] (<= (Long/compareUnsigned a, b) 0))
)

;;;
 ; This class encapsulates options that control the behavior of the Graal compiler.
 ;;
(value-ns GraalOptions
    ;; @Option "Maximum desired size of the compiler graph in nodes."
    (def #_"int" GraalOptions'maximumDesiredSize 20000)

    ;; @Option "Maximum level of recursive inlining."
    (def #_"int" GraalOptions'maximumRecursiveInlining 5)

    ;; @Option "Graphs with less than this number of nodes are trivial and therefore always inlined."
    (def #_"int" GraalOptions'trivialInliningSize 10)

    ;; @Option "Inlining is explored up to this number of nodes in the graph for each call site."
    (def #_"int" GraalOptions'maximumInliningSize 300)

    (def #_"double" GraalOptions'limitInlinedInvokes 5.0)

    (def #_"boolean" GraalOptions'inlineEverything false)

    ;; escape analysis settings
    (def #_"boolean" GraalOptions'partialEscapeAnalysis true)
    (def #_"int" GraalOptions'escapeAnalysisIterations 2)
    (def #_"int" GraalOptions'escapeAnalysisLoopCutoff 20)
    (def #_"int" GraalOptions'maximumEscapeAnalysisArrayLength 32)
    (def #_"boolean" GraalOptions'loopPeeling true)
    (def #_"boolean" GraalOptions'reassociateInvariants true)
    (def #_"boolean" GraalOptions'fullUnroll true)
    (def #_"boolean" GraalOptions'loopUnswitch true)
    (def #_"boolean" GraalOptions'partialUnroll true)
    (def #_"float" GraalOptions'minimumPeelProbability 0.35 #_"f")
    (def #_"int" GraalOptions'loopMaxUnswitch 3)
    (def #_"boolean" GraalOptions'useLoopLimitChecks true)

    ;; debugging settings
    (def #_"boolean" GraalOptions'zapStackOnMethodEntry false)

    ;; @Option "Stress the code by emitting reads at earliest instead of latest point."
    (def #_"boolean" GraalOptions'stressTestEarlyReads false)

    ;; register allocator debugging
    (def #_"boolean" GraalOptions'conditionalElimination true)
    (def #_"boolean" GraalOptions'rawConditionalElimination true)
    (def #_"boolean" GraalOptions'replaceInputsWithConstantsBasedOnStamps true)
    (def #_"boolean" GraalOptions'removeNeverExecutedCode true)
    (def #_"boolean" GraalOptions'genLoopSafepoints true)
    (def #_"boolean" GraalOptions'resolveClassBeforeStaticInvoke false)
    (def #_"boolean" GraalOptions'canOmitFrame true)

    ;; runtime settings
    (def #_"boolean" GraalOptions'optConvertDeoptsToGuards true)
    (def #_"boolean" GraalOptions'optReadElimination true)
    (def #_"int" GraalOptions'readEliminationMaxLoopVisits 5)
    (def #_"boolean" GraalOptions'optDeoptimizationGrouping true)
    (def #_"boolean" GraalOptions'optScheduleOutOfLoops true)
    (def #_"boolean" GraalOptions'guardPriorities true)
    (def #_"boolean" GraalOptions'optEliminateGuards true)
    (def #_"boolean" GraalOptions'optImplicitNullChecks true)
    (def #_"boolean" GraalOptions'optClearNonLiveLocals true)
    (def #_"boolean" GraalOptions'optLoopTransform true)
    (def #_"boolean" GraalOptions'optFloatingReads true)
    (def #_"boolean" GraalOptions'optDevirtualizeInvokesOptimistically true)

    ;; @Option "AMD64: Emit lfence instructions at the beginning of basic blocks."
    (def #_"boolean" GraalOptions'mitigateSpeculativeExecutionAttacks false)

    ;; @Option "Determines whether to treat final fields with default values as constant."
    (def #_"boolean" GraalOptions'trustFinalDefaultFields true)

    ;; @Option "Enable inlining."
    (def #_"boolean" GraalOptions'inline true)

    ;;;
     ; Options related to HotSpot snippets in this package.
     ;;
    ;; @Option "Handle simple cases for inflated monitors in the fast-path."
    (def #_"boolean" GraalOptions'simpleFastInflatedLocking true)

    ;;;
     ; Options related to BytecodeParser.
     ;;
    ;; @Option "Inlines trivial methods during bytecode parsing."
    (def #_"boolean" GraalOptions'inlineDuringParsing true)

    ;; @Option "Inlines partial intrinsic exits during bytecode parsing when possible. A partial intrinsic exit is a call within an intrinsic to the method being intrinsified and denotes semantics of the original method that the intrinsic does not support."
    (def #_"boolean" GraalOptions'inlinePartialIntrinsicExitDuringParsing true)

    ;; @Option "Maximum depth when inlining during bytecode parsing."
    (def #_"int" GraalOptions'inlineDuringParsingMaxDepth 10)

    ;; @Option "Enable LIR level optimiztations."
    (def #_"boolean" GraalOptions'lirOptimization true)

    ;; @Option "Enable spill position optimization."
    (def #_"boolean" GraalOptions'lirOptLSRAOptimizeSpillPosition (and GraalOptions'lirOptimization true))

    ;; @Option "Enable spill move elimination."
    (def #_"boolean" GraalOptions'lirOptLSRAEliminateSpillMoves (and GraalOptions'lirOptimization true))

    ;; @Option "Enable LSRA optimization."
    (def #_"boolean" GraalOptions'lsraOptimization false)
    ;; @Option "LSRA optimization: Only split but do not reassign."
    (def #_"boolean" GraalOptions'lsraOptSplitOnly false)

    (def #_"int" GraalOptions'loopUnswitchMaxIncrease 500)
    (def #_"int" GraalOptions'loopUnswitchTrivial 10)
    (def #_"double" GraalOptions'loopUnswitchFrequencyBoost 10.0)

    (def #_"int" GraalOptions'fullUnrollMaxNodes 300)
    (def #_"int" GraalOptions'fullUnrollMaxIterations 600)
    (def #_"int" GraalOptions'exactFullUnrollMaxNodes 1200)
    (def #_"int" GraalOptions'exactPartialUnrollMaxNodes 200)

    (def #_"int" GraalOptions'unrollMaxIterations 16)

    ;; @Option "Disable optional dead code eliminations."
    (def #_"boolean" GraalOptions'reduceDCE true)

    ;;;
     ; This is a defensive measure against known pathologies of the inliner where the breadth of
     ; the inlining call tree exploration can be wide enough to prevent inlining from completing
     ; in reasonable time.
     ;;
    ;; @Option "Per-compilation method inlining exploration limit before giving up (use 0 to disable)."
    (def #_"int" GraalOptions'methodInlineBailoutLimit 5000)

    ;; @Option "Use traps for nil-checks instead of explicit nil-checks."
    (def #_"boolean" GraalOptions'useTrappingNullChecks true)

    (def #_"boolean" GraalOptions'optEarlyReadElimination true)
)

;;;
 ; A collection of static utility functions that check ranges of numbers.
 ;;
(value-ns NumUtil
    ;;;
     ; Determines if {@code n} is in the range of signed byte values.
     ;;
    (defn #_"boolean" NumUtil'isByte-1i [#_"int"  n] (= (byte n) n))
    (defn #_"boolean" NumUtil'isByte-1l [#_"long" n] (= (byte n) n))

    ;;;
     ; Determines if {@code n} is in the range of signed int values.
     ;;
    (defn #_"boolean" NumUtil'isInt-1 [#_"long" n]
        (= (int n) n)
    )

    (defn #_"boolean" NumUtil'is32bit-1 [#_"long" n]
        (and (<= -0x80000000 n) (< n 0x80000000))
    )

    (defn #_"int"  NumUtil'roundUp-2i [#_"int"  n, #_"int"  m] (* (quot (+ n m -1) m) m))
    (defn #_"long" NumUtil'roundUp-2l [#_"long" n, #_"long" m] (* (quot (+ n m -1) m) m))

    ;;;
     ; Get the min/max value representable in a {@code n} bit signed integer.
     ;;
    (defn #_"long" NumUtil'minValue-1 [#_"int" n] (CodeUtil/minValue n))
    (defn #_"long" NumUtil'maxValue-1 [#_"int" n] (CodeUtil/maxValue n))

    ;;;
     ; Get the max value representable in a {@code n} bit unsigned integer.
     ;;
    (defn #_"long" NumUtil'maxValueUnsigned-1 [#_"int" n]
        (if (< n 64) (dec (<< 1 n)) 0xffffffffffffffff)
    )

    (defn #_"long" NumUtil'maxUnsigned-2 [#_"long" a, #_"long" b] (if (pos? (Long/compareUnsigned a, b)) b a))
    (defn #_"long" NumUtil'minUnsigned-2 [#_"long" a, #_"long" b] (if (pos? (Long/compareUnsigned a, b)) a b))

    (defn #_"boolean" NumUtil'sameSign-2 [#_"long" a, #_"long" b]
        (= (neg? a) (neg? b))
    )
)

;;;
 ; Constants denoting whether a set of edges are inputs or successors.
 ;;
(value-ns EdgesType
    (ยง enum EdgesType'Inputs)
    (ยง enum EdgesType'Successors)
)

;;;
 ; Constants for specifying whether a foreign call destroys or preserves registers. A foreign
 ; call will always destroy {@link ForeignCallLinkage#getOutgoingCallingConvention() its}
 ; {@linkplain ForeignCallLinkage#getTemporaries() temporary} registers.
 ;;
(value-ns RegisterEffect
    (ยง enum RegisterEffect'DESTROYS_REGISTERS)
    (ยง enum RegisterEffect'PRESERVES_REGISTERS)
)

;;;
 ; Constants for specifying whether a call is a leaf or not and whether a JavaFrameAnchor prologue
 ; and epilogue is required around the call. A leaf function does not lock, GC or throw exceptions.
 ;;
(value-ns Transition
    ;;;
     ; A call to a leaf function that is guaranteed to not use floating point registers and will never have
     ; its caller stack inspected by the VM. That is, JavaFrameAnchor management around the call can be omitted.
     ;;
    (ยง enum Transition'LEAF_NOFP)
    ;;;
     ; A call to a leaf function that might use floating point registers but will never have its
     ; caller stack inspected. That is, JavaFrameAnchor management around the call can be omitted.
     ;;
    (ยง enum Transition'LEAF)
    ;;;
     ; A call to a leaf function that might use floating point registers and may have its caller
     ; stack inspected. That is, JavaFrameAnchor management code around the call is required.
     ;;
    (ยง enum Transition'STACK_INSPECTABLE_LEAF)
    ;;;
     ; A function that may lock, GC or raise an exception and thus requires debug info to be associated
     ; with a call site to the function. The execution stack may be inspected while in the called function.
     ; That is, JavaFrameAnchor management code around the call is required.
     ;;
    (ยง enum Transition'SAFEPOINT)
)

;;;
 ; Implements the logic that decides whether a field read should be constant folded.
 ;;
(value-ns ConstantFields
    (def- #_"ResolvedJavaField" ConstantFields'stringValueField (#_"MetaAccessProvider" .lookupJavaField HotSpot'metaAccess, (#_"Class" .getDeclaredField String, "value")))
    (def- #_"ResolvedJavaField" ConstantFields'stringHashField  (#_"MetaAccessProvider" .lookupJavaField HotSpot'metaAccess, (#_"Class" .getDeclaredField String, "hash")))

    (def- #_"ResolvedJavaType" ConstantFields'hotSpotType   (ยง soon #_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (ร HotSpot)))
    (def- #_"ResolvedJavaType" ConstantFields'nodeClassType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, NodeClass'iface))

    (defn #_"boolean" ConstantFields'isStaticFieldConstant-1 [#_"ResolvedJavaField" field]
        (let [
            #_"ResolvedJavaType" declaringClass (#_"ResolvedJavaField" .getDeclaringClass field)
        ]
            (and (#_"ResolvedJavaType" .isInitialized declaringClass) (not (= (#_"ResolvedJavaType" .getName declaringClass) "Ljava/lang/System;")))
        )
    )

    (defn #_"boolean" ConstantFields'isStableField-1 [#_"ResolvedJavaField" field]
        (and HotSpot'foldStableValues
             (or (not (#_"ResolvedJavaField" .isStatic field))
                 (ConstantFields'isStaticFieldConstant-1 field)
             )
             (or (#_"HotSpotResolvedJavaField" .isStable field)
                 (any = field ConstantFields'stringValueField ConstantFields'stringHashField)
             )
        )
    )

    (defn #_"boolean" ConstantFields'isStableFieldValueConstant-3 [#_"ResolvedJavaField" field, #_"JavaConstant" value, #_"JavaConstant" receiver]
        (or (not (#_"JavaConstant" .isDefaultForKind value))
            (and (not (#_"ResolvedJavaField" .isStatic field))
                (#_"ResolvedJavaType" .isInstance ConstantFields'hotSpotType, receiver)
            )
        )
    )

    (defn #_"boolean" ConstantFields'isFinalField-1 [#_"ResolvedJavaField" field]
        (and (#_"ResolvedJavaField" .isFinal field)
            (or (not (#_"ResolvedJavaField" .isStatic field)) (ConstantFields'isStaticFieldConstant-1 field))
        )
    )

    (defn #_"boolean" ConstantFields'isFinalFieldValueConstant-3 [#_"ResolvedJavaField" field, #_"JavaConstant" value, #_"JavaConstant" receiver]
        (or GraalOptions'trustFinalDefaultFields (not (#_"JavaConstant" .isDefaultForKind value))
            (and (not (#_"ResolvedJavaField" .isStatic field))
                (#_"ResolvedJavaType" .isInstance ConstantFields'nodeClassType, receiver)
            )
        )
    )

    (defn- #_"int" ConstantFields'getArrayDimension-1 [#_"JavaType" type]
        (loop-when-recur [#_"int" n 0 type (#_"JavaType" .getComponentType type)] (some? type) [(inc n) (#_"JavaType" .getComponentType type)] => n)
    )

    ;;;
     ; Decide whether a read from the {@code field} should be constant folded.
     ;;
    (defn #_"ConstantNode" ConstantFields'readConstantField-2 [#_"ResolvedJavaField" field, #_"JavaConstant" receiver]
        (when (ConstantFields'isStableField-1 field)
            (let [
                #_"JavaConstant" value (#_"ConstantReflectionProvider" .readFieldValue HotSpot'constantReflection, field, receiver)
            ]
                (when (and (some? value) (ConstantFields'isStableFieldValueConstant-3 field, value, receiver))
                    (ยง return (ConstantNode'forConstant-3c value, (ConstantFields'getArrayDimension-1 (#_"ResolvedJavaField" .getType field)), false))
                )
            )
        )
        (when (ConstantFields'isFinalField-1 field)
            (let [
                #_"JavaConstant" value (#_"ConstantReflectionProvider" .readFieldValue HotSpot'constantReflection, field, receiver)
            ]
                (when (and (some? value) (ConstantFields'isFinalFieldValueConstant-3 field, value, receiver))
                    (ยง return (ConstantNode'forConstant-1 value))
                )
            )
        )
        nil
    )

    (defn #_"ConstantNode" ConstantFields'tryConstantFold-2 [#_"ResolvedJavaField" field, #_"JavaConstant" receiver]
        (when (or (#_"ResolvedJavaField" .isStatic field) (and (some? receiver) (not (#_"JavaConstant" .isNull receiver))))
            (ConstantFields'readConstantField-2 field, receiver)
        )
    )
)

;;;
 ; Reflection operations on values represented as constants for the processing of snippets.
 ; Snippets need a direct access to the value of object constants, which is not allowed in
 ; other parts of Graal to enforce compiler-VM separation.
 ;
 ; This interface must not be used in Graal code that is not related to snippet processing.
 ;;
(value-ns SnippetReflection
    ;;;
     ; Creates a boxed {@link JavaKind#Object object} constant.
     ;
     ; @param object the object value to box
     ; @return a constant containing {@code object}
     ;;
    (defn #_"JavaConstant" SnippetReflection'forObject-1 [#_"Object" object]
        (#_"HotSpotConstantReflectionProvider" .forObject HotSpot'constantReflection, object)
    )

    ;;;
     ; Gets the object reference a given constant represents if it is of a given type. The constant
     ; must have kind JavaKind#Object.
     ;
     ; @param type the expected type of the object represented by {@code constant}. If the object is required
     ;            to be of this type, then wrap the call to this method in Objects#requireNonNull(Object).
     ; @param constant an object constant
     ; @return the object value represented by {@code constant} if it is an
     ;         {@link ResolvedJavaType#isInstance(JavaConstant) instance of} {@code type} otherwise nil
     ;;
    #_unused
    (defn #_"Object" SnippetReflection'asObject-2t [#_"ResolvedJavaType" type, #_"JavaConstant" constant]
        (when-not (#_"JavaConstant" .isNull constant)
            (#_"HotSpotObjectConstant" .asObject constant, type)
        )
    )

    ;;;
     ; Gets the object reference a given constant represents if it is of a given type. The constant
     ; must have kind JavaKind#Object.
     ;
     ; @param type the expected type of the object represented by {@code constant}. If the object is required
     ;            to be of this type, then wrap the call to this method in Objects#requireNonNull(Object).
     ; @param constant an object constant
     ; @return the object value represented by {@code constant} cast to {@code type} if it is an
     ;         {@link Class#isInstance(Object) instance of} {@code type} otherwise nil
     ;;
    (defn #_"<T> T" SnippetReflection'asObject-2c [#_"Class<T>" type, #_"JavaConstant" constant]
        (when-not (#_"JavaConstant" .isNull constant)
            (#_"HotSpotObjectConstant" .asObject constant, type)
        )
    )

    ;;;
     ; Creates a boxed constant for the given kind from an Object. The object needs to be of the
     ; Java boxed type corresponding to the kind.
     ;
     ; @param kind the kind of the constant to create
     ; @param value the Java boxed value: a Byte instance for JavaKind#Byte, etc.
     ; @return the boxed copy of {@code value}
     ;;
    (defn #_"JavaConstant" SnippetReflection'forBoxed-2 [#_"JavaKind" kind, #_"Object" value]
        (if (= kind JavaKind/Object)
            (SnippetReflection'forObject-1 value)
            (JavaConstant/forBoxedPrimitive value)
        )
    )
)

;;;
 ; A collection of methods used in HotSpot snippets, substitutions and stubs.
 ;;
(value-ns ReplacementsUtil
    (defn #_"Word" ReplacementsUtil'readTlabTop-1 [#_"Word" thread] (Word''readWord-3i thread, HotSpot'threadTlabTopOffset, NamedLocationIdentity'TLAB_TOP))
    (defn #_"Word" ReplacementsUtil'readTlabEnd-1 [#_"Word" thread] (Word''readWord-3i thread, HotSpot'threadTlabEndOffset, NamedLocationIdentity'TLAB_END))

    (defn #_"void" ReplacementsUtil'writeTlabTop-2 [#_"Word" thread, #_"Word" top]
        (Word''writeWord-4i thread, HotSpot'threadTlabTopOffset, top, NamedLocationIdentity'TLAB_TOP)
        nil
    )

    ;;;
     ; Clears the pending exception for the given thread.
     ;
     ; @return the pending exception, or nil if there was none
     ;;
    (defn #_"Object" ReplacementsUtil'clearPendingException-1 [#_"Word" thread]
        (let [
            #_"Object" result (Word''readObject-3il thread, HotSpot'pendingExceptionOffset, NamedLocationIdentity'PENDING_EXCEPTION)
        ]
            (Word''writeObject-4 thread, HotSpot'pendingExceptionOffset, nil, NamedLocationIdentity'PENDING_EXCEPTION)
            result
        )
    )

    ;;;
     ; Reads the pending deoptimization value for the given thread.
     ;
     ; @return true if there was a pending deoptimization
     ;;
    #_unused
    (defn #_"int" ReplacementsUtil'readPendingDeoptimization-1 [#_"Word" thread]
        (Word''readInt-3i thread, HotSpot'pendingDeoptimizationOffset, NamedLocationIdentity'PENDING_DEOPTIMIZATION)
    )

    ;;;
     ; Writes the pending deoptimization value for the given thread.
     ;;
    #_unused
    (defn #_"void" ReplacementsUtil'writePendingDeoptimization-2 [#_"Word" thread, #_"int" value]
        (Word''writeInt-4i thread, HotSpot'pendingDeoptimizationOffset, value, NamedLocationIdentity'PENDING_DEOPTIMIZATION)
        nil
    )

    ;;;
     ; Gets and clears the object result from a runtime call stored in a thread local.
     ;
     ; @return the object that was in the thread local
     ;;
    (defn #_"Object" ReplacementsUtil'getAndClearObjectResult-1 [#_"Word" thread]
        (let [
            #_"Object" result (Word''readObject-3il thread, HotSpot'objectResultOffset, NamedLocationIdentity'OBJECT_RESULT)
        ]
            (Word''writeObject-4 thread, HotSpot'objectResultOffset, nil, NamedLocationIdentity'OBJECT_RESULT)
            result
        )
    )

    ;;;
     ; Loads the hub of an object (without nil-checking it first).
     ;;
    #_unused
    (defn #_"KlassPointer" ReplacementsUtil'loadHub-1 [#_"Object" object]
        (LoadHubNode'loadHubIntrinsic-1 object)
    )

    (defn #_"Word" ReplacementsUtil'loadWordFromObject-2 [#_"Object" object, #_"int" offset]
        (RawLoadNode'loadWordFromObjectIntrinsic-4 object, offset, LocationIdentity'ANY, (.wordJavaKind HotSpot'target))
    )

    ;;;
     ; Reads the value of a given register.
     ;
     ; @param register a register which must not be available to the register allocator
     ; @return the value of {@code register} as a word
     ;;
    (defn #_"Word" ReplacementsUtil'registerAsWord-1 [#_"Register" register]
        (ReadRegisterNode'registerAsWord-3 register, true, false)
    )

    (def #_"long" ReplacementsUtil'REFERENT_OFFSET (.objectFieldOffset HotSpot'unsafe, (#_"Class" .getDeclaredField java.lang.ref.Reference, "referent")))
)

;;;
 ; Snippets used for implementing the type test of an instanceof instruction. Since instanceof is
 ; a floating node, it is lowered separately for each of its usages.
 ;
 ; The type tests implemented are described in the paper
 ; <a href="http://dl.acm.org/citation.cfm?id=583821">Fast subtype checking in the HotSpot JVM</a>
 ; by Cliff Click and John Rose.
 ;;
(value-ns InstanceOfSnippets (ยง implements Snippets)
    ;;;
     ; A test against a final type.
     ;;
    (ยง snippet! #_"Object" #_"InstanceOfSnippets" "instanceofExact" [#_"Object" object, #_"KlassPointer" exactHub, #_"Object" trueValue, #_"Object" falseValue]
        (when (some? object) => falseValue
            (let [
                #_"KlassPointer" objectHub (LoadHubNode'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                (if (Word''klassPointersNotEqual-2 objectHub, exactHub)
                    falseValue
                    trueValue
                )
            )
        )
    )

    ;;;
     ; A test against a primary type.
     ;;
    (ยง snippet! #_"Object" #_"InstanceOfSnippets" "instanceofPrimary" [#_"KlassPointer" hub, #_"Object" object, #_"int" superCheckOffset, #_"Object" trueValue, #_"Object" falseValue]
        (when (some? object) => falseValue
            (let [
                #_"KlassPointer" objectHub (LoadHubNode'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                (if (Word''klassPointersNotEqual-2 (Word''readKlassPointer-3 objectHub, superCheckOffset, NamedLocationIdentity'PRIMARY_SUPERS), hub)
                    falseValue
                    trueValue
                )
            )
        )
    )

    ;;;
     ; A test against a restricted secondary type.
     ;;
    (ยง snippet! #_"Object" #_"InstanceOfSnippets" "instanceofSecondary" [#_"KlassPointer" hub, #_"Object" object, #_"Object" trueValue, #_"Object" falseValue]
        (when (some? object) => falseValue
            (let [
                #_"KlassPointer" objectHub (LoadHubNode'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                (if (TypeCheckSnippetUtils'checkSecondarySubType-2 hub, objectHub)
                    trueValue
                    falseValue
                )
            )
        )
    )

    ;;;
     ; Type test used when the type being tested against is not known at compile time.
     ;;
    (ยง snippet! #_"Object" #_"InstanceOfSnippets" "instanceofDynamic" [#_"KlassPointer" hub, #_"Object" object, #_"Object" trueValue, #_"Object" falseValue, #_"boolean" allow-nil?]
        (when (some? object) => (if allow-nil? trueValue falseValue)
            (let [
                #_"KlassPointer" objectHub (LoadHubNode'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                ;; The hub of a primitive type can be nil => always return false in this case.
                (if (and (not (Word''klassPointerIsNull-1 hub)) (TypeCheckSnippetUtils'checkUnknownSubType-2 hub, objectHub))
                    trueValue
                    falseValue
                )
            )
        )
    )
)

;;;
 ; Snippets used for implementing the monitorenter and monitorexit instructions.
 ;
 ; The locking algorithm used is described in the paper
 ; <a href="http://dl.acm.org/citation.cfm?id=1167515.1167496">Eliminating synchronization-related atomic operations with biased locking and bulk rebiasing</a>
 ; by Kenneth Russell and David Detlefs.
 ;
 ; Comment below is reproduced from {@code markOop.hpp} for convenience:
 ;
 ;  Bit-format of an object header (most significant first, big endian layout below):
 ;  32 bits:
 ;  --------
 ;             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
 ;             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
 ;             size:32 ------------------------------------------>| (CMS free block)
 ;             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)
 ;
 ;  64 bits:
 ;  --------
 ;  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
 ;  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
 ;  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
 ;  size:64 ----------------------------------------------------->| (CMS free block)
 ;
 ;  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)
 ;  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)
 ;  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)
 ;  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)
 ;
 ;  - hash contains the identity hash value: largest value is
 ;    31 bits, see os::random().  Also, 64-bit vm's require
 ;    a hash value no bigger than 32 bits because they will not
 ;    properly generate a mask larger than that: see library_call.cpp
 ;    and c1_CodePatterns_sparc.cpp.
 ;
 ;  - the biased lock pattern is used to bias a lock toward a given
 ;    thread. When this pattern is set in the low three bits, the lock
 ;    is either biased toward a given thread or "anonymously" biased,
 ;    indicating that it is possible for it to be biased. When the
 ;    lock is biased toward a given thread, locking and unlocking can
 ;    be performed by that thread without using atomic operations.
 ;    When a lock's bias is revoked, it reverts back to the normal
 ;    locking scheme described below.
 ;
 ;    Note that we are overloading the meaning of the "unlocked" state
 ;    of the header. Because we steal a bit from the age we can
 ;    guarantee that the bias pattern will never be seen for a truly
 ;    unlocked object.
 ;
 ;    Note also that the biased state contains the age bits normally
 ;    contained in the object header. Large increases in scavenge
 ;    times were seen when these bits were absent and an arbitrary age
 ;    assigned to all biased objects, because they tended to consume a
 ;    significant fraction of the eden semispaces and were not
 ;    promoted promptly, causing an increase in the amount of copying
 ;    performed. The runtime system aligns all JavaThread* pointers to
 ;    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))
 ;    to make room for the age bits & the epoch bits (used in support of
 ;    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).
 ;
 ;    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread
 ;    [0           | epoch | age | 1 | 01]       lock is anonymously biased
 ;
 ;  - the two lock bits are used to describe three states: locked/unlocked and monitor.
 ;
 ;    [ptr             | 00]  locked             ptr points to real header on stack
 ;    [header      | 0 | 01]  unlocked           regular object header
 ;    [ptr             | 10]  monitor            inflated lock (header is wapped out)
 ;    [ptr             | 11]  marked             used by markSweep to mark an object
 ;                                               not valid at any other time
 ;
 ;    We assume that stack/thread pointers have the lowest two bits cleared.
 ;
 ; Note that {@code Thread::allocate} enforces JavaThread objects to be aligned
 ; appropriately to comply with the layouts above.
 ;;
(value-ns MonitorSnippets (ยง implements Snippets)
    (defn- #_"boolean" MonitorSnippets'tryEnterBiased-4 [#_"Object" object, #_"KlassPointer" hub, #_"Word" lock, #_"Word" mark]
        ;; See whether the lock is currently biased toward our thread and whether the epoch is still valid.
        ;; Note that the runtime guarantees sufficient alignment of JavaThread pointers to allow age to be placed into low bits.
        (let [
            #_"Word" biasableLockBits (Word''and-2i mark, HotSpot'biasedLockMaskInPlace)
            ;; Check whether the bias pattern is present in the object's mark word and the bias owner and the epoch are both still current.
            #_"Word" prototypeMarkWord (Word''readWord-3i hub, HotSpot'prototypeMarkWordOffset, NamedLocationIdentity'PROTOTYPE_MARK_WORD)
            #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
            #_"Word" tmp (Word''and-2i (Word''xor-2w (Word''or-2w prototypeMarkWord, thread), mark), (bit-not HotSpot'ageMaskInPlace))
        ]
            (or
                (and (Word''equal-2i tmp, 0)
                    (do
                        ;; object is already biased to current thread -> done
                        (FastAcquireBiasedLockNode'mark-1 object)
                        true
                    )
                )

                ;; now check to see whether biasing is enabled for this object ;; => biasing not enabled -> fall through to lightweight locking
                (and (Word''equal-2w biasableLockBits, (WordFactory'unsigned-1i HotSpot'biasedLockPattern))
                    (let [
                        #_"Word" objectPointer (Word'objectToTrackedPointer-1 object)
                    ]
                        ;; At this point we know that the mark word has the bias pattern and that we are not the bias owner in the
                        ;; current epoch. We need to figure out more details about the state of the mark word in order to know what
                        ;; operations can be legally performed on the object's mark word.

                        ;; If the low three bits in the xor result aren't clear, that means the prototype header is no longer biasable
                        ;; and we have to revoke the bias on this object.
                        (if (Word''equal-2i (Word''and-2i tmp, HotSpot'biasedLockMaskInPlace), 0)
                            (or
                                ;; Biasing is still enabled for object's type. See whether the epoch of the current bias is still valid,
                                ;; meaning that the epoch bits of the mark word are equal to the epoch bits of the prototype mark word.
                                ;; (Note that the prototype mark word's epoch bits only change at a safepoint.) If not, attempt to rebias
                                ;; the object toward the current thread. Note that we must be absolutely sure that the current epoch is
                                ;; invalid in order to do this, because otherwise the manipulations it performs on the mark word are illegal.
                                (if (Word''equal-2i (Word''and-2i tmp, HotSpot'epochMaskInPlace), 0)
                                    ;; The epoch of the current bias is still valid but we know nothing about the owner, it might be
                                    ;; set or it might be clear. Try to acquire the bias of the object using an atomic operation. If
                                    ;; this fails we will go in to the runtime to revoke the object's bias. Note that we first construct
                                    ;; the presumed unbiased header so we don't accidentally blow away another thread's valid bias.
                                    (let [
                                        #_"Word" unbiasedMark (Word''and-2i mark, (| HotSpot'biasedLockMaskInPlace HotSpot'ageMaskInPlace HotSpot'epochMaskInPlace))
                                        #_"Word" biasedMark (Word''or-2w unbiasedMark, thread)
                                    ]
                                        (and (Word''logicCompareAndSwapWord-5 objectPointer, HotSpot'markOffset, unbiasedMark, biasedMark, NamedLocationIdentity'MARK_WORD)
                                            ;; object is now biased to current thread -> done
                                            true
                                        )
                                        ;; If the biasing toward our thread failed, this means that another thread owns the bias
                                        ;; and we need to revoke that bias. The revocation will occur in the interpreter runtime.
                                    )
                                    ;; At this point we know the epoch has expired, meaning that the current bias owner, if any, is
                                    ;; actually invalid. Under these circumstances *only*, are we allowed to use the current mark word
                                    ;; value as the comparison value when doing the CAS to acquire the bias in the current epoch. In
                                    ;; other words, we allow transfer of the bias from one thread to another directly in this situation.
                                    (let [
                                        #_"Word" biasedMark (Word''or-2w prototypeMarkWord, thread)
                                    ]
                                        (and (Word''logicCompareAndSwapWord-5 objectPointer, HotSpot'markOffset, mark, biasedMark, NamedLocationIdentity'MARK_WORD)
                                            ;; object is now biased to current thread -> done
                                            true
                                        )
                                        ;; If the biasing toward our thread failed, then another thread succeeded in biasing it toward itself
                                        ;; and we need to revoke that bias. The revocation will occur in the runtime in the slow case.
                                    )
                                )

                                (do
                                    ;; slow-path runtime-call
                                    (StubForeignCallNode'monitorenter-4 ForeignCallDescriptor'MONITORENTER, thread, object, lock)
                                    (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                                        (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                                    )
                                    true
                                )
                            )
                            ;; The prototype mark word doesn't have the bias bit set any more, indicating that objects of this
                            ;; data type are not supposed to be biased any more. We are going to try to reset the mark of this
                            ;; object to the prototype value and fall through to the CAS-based locking scheme. Note that if our
                            ;; CAS fails, it means that another thread raced us for the privilege of revoking the bias of this
                            ;; particular object, so it's okay to continue in the normal locking code.
                            (do
                                (Word''compareAndSwapWord-5 objectPointer, HotSpot'markOffset, mark, prototypeMarkWord, NamedLocationIdentity'MARK_WORD)
                                ;; Fall through to the normal CAS-based lock, because no matter what the result of the above CAS,
                                ;; some thread must have succeeded in removing the bias bit from the object's header.
                                false
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"boolean" MonitorSnippets'inlineFastLockSupported-0 []
        (and GraalOptions'simpleFastInflatedLocking (<= 0 HotSpot'monitorMask) (<= 0 HotSpot'objectMonitorOwnerOffset))
    )

    (defn- #_"boolean" MonitorSnippets'tryEnterInflated-3 [#_"Object" object, #_"Word" lock, #_"Word" mark]
        ;; write non-zero value to lock slot
        (Word''writeWord-4i lock, HotSpot'lockDisplacedMarkOffset, lock, NamedLocationIdentity'DISPLACED_MARK_WORD)
        ;; mark is a pointer to the ObjectMonitor + monitorMask
        (let [
            #_"Word" monitor (Word''subtract-2i mark, HotSpot'monitorMask)
            #_"Word" owner (Word''readWord-3i monitor, HotSpot'objectMonitorOwnerOffset, NamedLocationIdentity'OBJECT_MONITOR_OWNER)
            #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
        ]
            ;; appears being unlocked when owner is 0
            (and (Word''equal-2i owner, 0)
                 (Word''logicCompareAndSwapWord-5 monitor, HotSpot'objectMonitorOwnerOffset, owner, thread, NamedLocationIdentity'OBJECT_MONITOR_OWNER)
            )
        )
    )

    (ยง snippet! #_"void" #_"MonitorSnippets" "monitorenter" [#_"Object" object, #_"KlassPointer" hub, #_"int" lockDepth]
        ;; load the mark word - this includes a nil-check on object
        (let [
            #_"Word" mark (ReplacementsUtil'loadWordFromObject-2 object, HotSpot'markOffset)
            #_"Word" lock (BeginLockScopeNode'beginLockScope-1 lockDepth)
        ]
            (when-not (and HotSpot'useBiasedLocking (MonitorSnippets'tryEnterBiased-4 object, hub, lock, mark))
                ;; not biased, fall-through
                (or
                    (if (and (MonitorSnippets'inlineFastLockSupported-0) (Word''notEqual-2i (Word''and-2i mark, HotSpot'monitorMask), 0))
                        ;; inflated case
                        (when (MonitorSnippets'tryEnterInflated-3 object, lock, mark)
                            :done
                        )
                        ;; create the unlocked mark word pattern
                        (let [
                            #_"Word" unlockedMark (Word''or-2i mark, HotSpot'unlockedMask)
                        ]
                            ;; copy this unlocked mark word into the lock slot on the stack
                            (Word''writeWord-4i lock, HotSpot'lockDisplacedMarkOffset, unlockedMark, NamedLocationIdentity'DISPLACED_MARK_WORD)
                            ;; make sure previous store does not float below compareAndSwap
                            (MembarNode'memoryBarrier-1 MemoryBarriers/STORE_STORE)
                            ;; Test if the object's mark word is unlocked, and if so, store the (address of) the lock slot into the object's mark word.
                            (let [
                                #_"Word" objectPointer (Word'objectToTrackedPointer-1 object)
                                #_"Word" currentMark (Word''compareAndSwapWord-5 objectPointer, HotSpot'markOffset, unlockedMark, lock, NamedLocationIdentity'MARK_WORD)
                            ]
                                (if (Word''equal-2w currentMark, unlockedMark)
                                    (do
                                        (AcquiredCASLockNode'mark-1 object)
                                        :done
                                    )
                                    ;; The mark word in the object header was not the same.
                                    ;; Either the object is locked by another thread or is already locked by the current thread.
                                    ;; The latter is true if the mark word is a stack pointer into the current thread's stack,
                                    ;; i.e.:
                                    ;;
                                    ;; 1. (currentMark & aligned_mask) == 0
                                    ;; 2. rsp <= currentMark
                                    ;; 3. currentMark <= rsp + page_size
                                    ;;
                                    ;; These 3 tests can be done by evaluating the following expression:
                                    ;;
                                    ;; (currentMark - rsp) & (aligned_mask - page_size)
                                    ;;
                                    ;; assuming both the stack pointer and page_size have their least
                                    ;; significant 2 bits cleared and page_size is a power of 2
                                    (let [
                                        #_"Word" alignedMask (WordFactory'unsigned-1i (dec (.wordSize HotSpot'target)))
                                        #_"Word" stackPointer (Word''add-2i (ReplacementsUtil'registerAsWord-1 HotSpot'stackPointerRegister), HotSpot'stackBias)
                                    ]
                                        (when (Word''equal-2i (Word''and-2w (Word''subtract-2w currentMark, stackPointer), (Word''subtract-2i alignedMask, (.pageSize HotSpot'unsafe))), 0)
                                            ;; recursively locked => write 0 to the lock slot
                                            (Word''writeWord-4i lock, HotSpot'lockDisplacedMarkOffset, (WordFactory'zero-0), NamedLocationIdentity'DISPLACED_MARK_WORD)
                                            :done
                                        )
                                    )
                                )
                            )
                        )
                    )
                    ;; slow-path runtime-call
                    (let [
                        #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
                    ]
                        (StubForeignCallNode'monitorenter-4 ForeignCallDescriptor'MONITORENTER, thread, object, lock)
                        (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                            (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Calls straight out to the monitorenter stub.
     ;;
    (ยง snippet! #_"void" #_"MonitorSnippets" "monitorenterStub" [#_"Object" object, #_"int" lockDepth]
        (when (some? object) => (DeoptimizeNode'deopt-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/NullCheckException)
            (let [
                #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
            ]
                ;; BeginLockScope nodes do not read from object, so a use of object cannot float about the nil-check above.
                (StubForeignCallNode'monitorenter-4 ForeignCallDescriptor'MONITORENTER, thread, object, (BeginLockScopeNode'beginLockScope-1 lockDepth))
                (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                    (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                )
            )
        )
        nil
    )

    (defn- #_"boolean" MonitorSnippets'inlineFastUnlockSupported-0 []
        (and GraalOptions'simpleFastInflatedLocking
            (<= 0 HotSpot'objectMonitorEntryListOffset)
            (<= 0 HotSpot'objectMonitorCxqOffset)
            (<= 0 HotSpot'monitorMask)
            (<= 0 HotSpot'objectMonitorOwnerOffset)
            (<= 0 HotSpot'objectMonitorRecursionsOffset)
        )
    )

    (defn- #_"boolean" MonitorSnippets'tryExitInflated-3 [#_"Object" object, #_"Word" mark, #_"Word" lock]
        (and (MonitorSnippets'inlineFastUnlockSupported-0)
             (Word''notEqual-2i (Word''and-2i mark, HotSpot'monitorMask), 0)
            ;; inflated case: mark is a pointer to the ObjectMonitor + monitorMask
            (let [
                #_"Word" monitor (Word''subtract-2i mark, HotSpot'monitorMask)
                #_"int" ownerOffset HotSpot'objectMonitorOwnerOffset
                #_"Word" owner (Word''readWord-3i monitor, ownerOffset, NamedLocationIdentity'OBJECT_MONITOR_OWNER)
                #_"Word" recursions (Word''readWord-3i monitor, HotSpot'objectMonitorRecursionsOffset, NamedLocationIdentity'OBJECT_MONITOR_RECURSION)
                #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
            ]
                (or
                    (when (Word''equal-2i (Word''or-2w (Word''xor-2w owner, thread), recursions), 0) ;; owner == thread && recursions == 0
                        (let [
                            #_"Word" cxq (Word''readWord-3i monitor, HotSpot'objectMonitorCxqOffset, NamedLocationIdentity'OBJECT_MONITOR_CXQ)
                            #_"Word" entryList (Word''readWord-3i monitor, HotSpot'objectMonitorEntryListOffset, NamedLocationIdentity'OBJECT_MONITOR_ENTRY_LIST)
                        ]
                            (when (Word''equal-2i (Word''or-2w cxq, entryList), 0) ;; cxq == 0 && entryList == 0: nobody is waiting, success
                                (MembarNode'memoryBarrier-1 (| MemoryBarriers/LOAD_STORE MemoryBarriers/STORE_STORE))
                                (Word''writeWord-3i monitor, ownerOffset, (WordFactory'zero-0))
                                :done
                            )
                        )
                    )

                    (do
                        (StubForeignCallNode'monitorexit-4 ForeignCallDescriptor'MONITOREXIT, thread, object, lock)
                        (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                            (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                        )
                    )
                )
                true
            )
        )
    )

    (ยง snippet! #_"void" #_"MonitorSnippets" "monitorexit" [#_"Object" object, #_"int" lockDepth]
        (let [
            #_"Word" mark (ReplacementsUtil'loadWordFromObject-2 object, HotSpot'markOffset)
        ]
            ;; Check for biased locking unlock case, which is a no-op. Note: we do not have to check the thread ID for two reasons.
            ;; First, the interpreter checks for IllegalMonitorStateException at a higher level.
            ;; Second, if the bias was revoked while we held the lock, the object could not be rebiased toward another thread, so the bias bit would be clear.
            (when-not (and HotSpot'useBiasedLocking (Word''equal-2w (Word''and-2i mark, HotSpot'biasedLockMaskInPlace), (WordFactory'unsigned-1i HotSpot'biasedLockPattern)))
                (let [
                    #_"Word" lock (CurrentLockNode'currentLock-1 lockDepth)
                    #_"Word" displacedMark (Word''readWord-3i lock, HotSpot'lockDisplacedMarkOffset, NamedLocationIdentity'DISPLACED_MARK_WORD)
                ]
                    ;; => recursive locking, done
                    (when (and (not (Word''equal-2i displacedMark, 0)) (not (MonitorSnippets'tryExitInflated-3 object, mark, lock)))
                        ;; Test if object's mark word is pointing to the displaced mark word, and if so,
                        ;; restore the displaced mark in the object. Otherwise, do unlocking via runtime call.
                        (let [
                            #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
                            #_"Word" objectPointer (Word'objectToTrackedPointer-1 object)
                        ]
                            (when-not (Word''logicCompareAndSwapWord-5 objectPointer, HotSpot'markOffset, lock, displacedMark, NamedLocationIdentity'MARK_WORD)
                                ;; the object's mark word was not pointing to the displaced header
                                (StubForeignCallNode'monitorexit-4 ForeignCallDescriptor'MONITOREXIT, thread, object, lock)
                                (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                                    (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                                )
                            )
                        )
                    )
                )
            )
            (EndLockScopeNode'endLockScope-0)
        )
        nil
    )

    ;;;
     ; Calls straight out to the monitorexit stub.
     ;;
    (ยง snippet! #_"void" #_"MonitorSnippets" "monitorexitStub" [#_"Object" object, #_"int" lockDepth]
        (let [
            #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
            #_"Word" lock (CurrentLockNode'currentLock-1 lockDepth)
        ]
            (StubForeignCallNode'monitorexit-4 ForeignCallDescriptor'MONITOREXIT, thread, object, lock)
            (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
            )
            (EndLockScopeNode'endLockScope-0)
        )
        nil
    )
)

;;;
 ; Snippets used for implementing NEW, ANEWARRAY and NEWARRAY.
 ;;
(value-ns NewObjectSnippets (ยง implements Snippets)
    (defn- #_"void" NewObjectSnippets'emitPrefetchAllocate-2 [#_"Word" address, #_"boolean" isArray]
        (when (pos? HotSpot'allocatePrefetchStyle)
            ;; Insert a prefetch for each allocation only on the fast-path.
            ;; Generate several prefetch instructions.
            (let [
                #_"int" lines (if isArray HotSpot'allocatePrefetchLines HotSpot'allocateInstancePrefetchLines)
                #_"int" stepSize HotSpot'allocatePrefetchStepSize
                #_"int" distance HotSpot'allocatePrefetchDistance
            ]
                (ExplodeLoopNode'explodeLoop-0)
                (loop-when-recur [distance distance #_"int" i 0] (< i lines) [(+ distance stepSize) (inc i)]
                    (PrefetchAllocateNode'prefetch-1 (OffsetAddressNode'address-2 address, distance))
                )
            )
        )
        nil
    )

    (defn- #_"void" NewObjectSnippets'initializeObjectHeader-3 [#_"Word" memory, #_"Word" markWord, #_"KlassPointer" hub]
        (Word''writeWord-4i memory, HotSpot'markOffset, markWord, NamedLocationIdentity'MARK_WORD)
        (StoreHubNode'write-2 memory, hub)
        nil
    )

    (defn- #_"int" NewObjectSnippets'instanceHeaderSize-0 []
        (- (* 2 (.wordSize HotSpot'target)) (if HotSpot'useCompressedClassPointers 4 0))
    )

    ;;;
     ; Maximum number of long stores to emit when zeroing an object with a constant size.
     ; Larger objects have their bodies initialized in a loop.
     ;;
    (def- #_"int" NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES 8)

    (defn- #_"void" NewObjectSnippets'fillMemory-6 [#_"long" value, #_"int" size, #_"Word" memory, #_"boolean" constantSize, #_"int" offset, #_"boolean" manualUnroll]
        (let [
            offset
                (when-not (zero? (& offset 0x7)) => offset
                    (Word''writeInt-4i memory, offset, (int value), LocationIdentity'INIT)
                    (+ offset 4)
                )
        ]
            (if (and manualUnroll (<= (quot (- size offset) 8) NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES))
                (do
                    ;; This case handles arrays of constant length. Instead of having a snippet variant
                    ;; for each length, generate a chain of stores of maximum length. Once it's inlined
                    ;; the break statement will trim excess stores.
                    (ExplodeLoopNode'explodeLoop-0)
                    (loop-when-recur [#_"int" i offset #_"int" n 0] (and (< i size) (< n NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES)) [(+ i 8) (inc n)]
                        (Word''initializeLong-4i memory, i, value, LocationIdentity'INIT)
                    )
                )
                ;; Use Word instead of int to avoid extension to long in generated code.
                (do
                    (when (and constantSize (<= (quot (- size offset) 8) NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES))
                        (ExplodeLoopNode'explodeLoop-0)
                    )
                    (loop-when-recur [#_"Word" w (WordFactory'signed-1i offset)] (< (Word''rawValue-1 w) size) [(Word''add-2i w, 8)]
                        (Word''initializeLong-4w memory, w, value, LocationIdentity'INIT)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Zero uninitialized memory in a newly allocated object, unrolling as necessary and ensuring that stores are aligned.
     ;
     ; @param size number of bytes to zero
     ; @param memory beginning of object which is being zeroed
     ; @param constantSize is {@code size} known to be constant in the snippet
     ; @param startOffset offset to begin zeroing. May not be word aligned.
     ; @param manualUnroll maximally unroll zeroing
     ;;
    (defn- #_"void" NewObjectSnippets'zeroMemory-5 [#_"int" size, #_"Word" memory, #_"boolean" constantSize, #_"int" startOffset, #_"boolean" manualUnroll]
        (NewObjectSnippets'fillMemory-6 0, size, memory, constantSize, startOffset, manualUnroll)
        nil
    )

    ;;;
     ; Formats some allocated memory with an object header and zeroes out the rest.
     ;;
    (defn- #_"Object" NewObjectSnippets'formatObject-6 [#_"KlassPointer" hub, #_"int" size, #_"Word" memory, #_"Word" compileTimePrototypeMarkWord, #_"boolean" fillContents, #_"boolean" constantSize]
        (let [
            #_"Word" prototypeMarkWord (if HotSpot'useBiasedLocking (Word''readWord-3i hub, HotSpot'prototypeMarkWordOffset, NamedLocationIdentity'PROTOTYPE_MARK_WORD) compileTimePrototypeMarkWord)
        ]
            (NewObjectSnippets'initializeObjectHeader-3 memory, prototypeMarkWord, hub)
            (when fillContents
                (NewObjectSnippets'zeroMemory-5 size, memory, constantSize, (NewObjectSnippets'instanceHeaderSize-0), false)
            )
            (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_STORE, LocationIdentity'INIT)
            (Word''toObjectNonNull-1 memory)
        )
    )

    (ยง snippet! #_"Object" #_"NewObjectSnippets" "allocateInstance" [#_"int" size, #_"KlassPointer" hub, #_"Word" prototypeMarkWord]
        (let [
            #_"Object" object
                (let [
                    #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
                    #_"Word" top (ReplacementsUtil'readTlabTop-1 thread)
                    #_"Word" end (ReplacementsUtil'readTlabEnd-1 thread)
                    #_"Word" newTop (Word''add-2i top, size)
                ]
                    (if (and HotSpot'useTLAB (Word''belowOrEqual-2w newTop, end))
                        (do
                            (ReplacementsUtil'writeTlabTop-2 thread, newTop)
                            (NewObjectSnippets'emitPrefetchAllocate-2 newTop, false)
                            (NewObjectSnippets'formatObject-6 hub, size, top, prototypeMarkWord, true, true)
                        )
                        (do
                            (StubForeignCallNode'newInstance-3 ForeignCallDescriptor'NEW_INSTANCE, thread, hub)
                            (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                                (ReplacementsUtil'getAndClearObjectResult-1 thread)
                                (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                            )
                            (ReplacementsUtil'getAndClearObjectResult-1 thread)
                        )
                    )
                )
        ]
            (Placeholder'piCastToSnippetReplaceeStamp-1 object)
        )
    )

    ;;;
     ; Computes the size of the memory chunk allocated for an array. This size accounts for the array header size,
     ; body size and any padding after the last element to satisfy object alignment requirements.
     ;
     ; @param length the number of elements in the array
     ; @param headerSize the size of the array header
     ; @param log2ElementSize log2 of the size of an element in the array
     ;
     ; @return the size of the memory chunk
     ;;
    (defn- #_"int" NewObjectSnippets'arrayAllocationSize-3 [#_"int" length, #_"int" headerSize, #_"int" log2ElementSize]
        (let [
            #_"int" alignment HotSpot'objectAlignment
            #_"int" size (+ (<< length log2ElementSize) headerSize (dec alignment))
            #_"int" mask (bit-not (dec alignment))
        ]
            (& size mask)
        )
    )

    ;;;
     ; Formats some allocated memory with an object header and zeroes out the rest.
     ;;
    (defn- #_"Object" NewObjectSnippets'formatArray-8 [#_"KlassPointer" hub, #_"int" allocationSize, #_"int" length, #_"int" headerSize, #_"Word" memory, #_"Word" prototypeMarkWord, #_"boolean" fillContents, #_"boolean" maybeUnroll]
        (Word''writeInt-4i memory, HotSpot'arrayLengthOffset, length, LocationIdentity'INIT)
        ;; store hub last as the concurrent garbage collectors assume length is valid if hub field is not nil
        (NewObjectSnippets'initializeObjectHeader-3 memory, prototypeMarkWord, hub)
        (when fillContents
            (NewObjectSnippets'zeroMemory-5 allocationSize, memory, false, headerSize, maybeUnroll)
        )
        (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_STORE, LocationIdentity'INIT)
        (Word''toObjectNonNull-1 memory)
    )

    ;;;
     ; Maximum array length for which fast path allocation is used.
     ;;
    (def- #_"int" NewObjectSnippets'MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH 0x00ffffff)

    (ยง snippet! #_"Object" #_"NewObjectSnippets" "allocateArray" [#_"KlassPointer" hub, #_"int" length, #_"Word" prototypeMarkWord, #_"int" headerSize, #_"int" log2ElementSize, #_"boolean" maybeUnroll]
        (let [
            #_"Object" object
                (let [
                    #_"int" allocationSize (NewObjectSnippets'arrayAllocationSize-3 length, headerSize, log2ElementSize)
                    #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
                    #_"Word" top (ReplacementsUtil'readTlabTop-1 thread)
                    #_"Word" end (ReplacementsUtil'readTlabEnd-1 thread)
                    #_"Word" newTop (Word''add-2i top, allocationSize)
                ]
                    (if (and HotSpot'useTLAB (Word''belowOrEqual-2w newTop, end) (UnsignedMath'belowThan-2i length, NewObjectSnippets'MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH))
                        (do
                            (ReplacementsUtil'writeTlabTop-2 thread, newTop)
                            (NewObjectSnippets'emitPrefetchAllocate-2 newTop, true)
                            (NewObjectSnippets'formatArray-8 hub, allocationSize, length, headerSize, top, prototypeMarkWord, true, maybeUnroll)
                        )
                        (do
                            (StubForeignCallNode'newArray-4 ForeignCallDescriptor'NEW_ARRAY, thread, hub, length)
                            (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                                (ReplacementsUtil'getAndClearObjectResult-1 thread)
                                (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                            )
                            (ReplacementsUtil'getAndClearObjectResult-1 thread)
                        )
                    )
                )
        ]
            (ArrayPlaceholder'piArrayCastToSnippetReplaceeStamp-2 object, length)
        )
    )
)

;;;
 ; Utilities and common code paths used by the type check snippets.
 ;;
(value-ns TypeCheckSnippetUtils
    (defn- #_"KlassPointer" TypeCheckSnippetUtils'loadSecondarySupersElement-2 [#_"Word" metaspaceArray, #_"int" index]
        (Word'klassPointerFromWord-1 (Word''readWord-3i metaspaceArray, (+ HotSpot'metaspaceArrayBaseOffset (* index (.wordSize HotSpot'target))), NamedLocationIdentity'SECONDARY_SUPERS_ELEMENT))
    )

    (defn- #_"boolean" TypeCheckSnippetUtils'checkSelfAndSupers-2 [#_"KlassPointer" t, #_"KlassPointer" s]
        ;; if (T == S) return true
        (or (Word''klassPointersEqual-2 s, t)
            ;; if (S.scan_s_s_array(T)) { S.cache = T; return true; }
            (let [
                #_"Word" secondarySupers (Word''readWord-3i s, HotSpot'secondarySupersOffset, NamedLocationIdentity'SECONDARY_SUPERS)
                #_"int" n (Word''readInt-3i secondarySupers, HotSpot'metaspaceArrayLengthOffset, NamedLocationIdentity'METASPACE_ARRAY_LENGTH)
            ]
                (loop-when [#_"int" i 0] (< i n) => false
                    (when (Word''klassPointersEqual-2 t, (TypeCheckSnippetUtils'loadSecondarySupersElement-2 secondarySupers, i)) => (recur (inc i))
                        (Word''writeKlassPointer-4 s, HotSpot'secondarySuperCacheOffset, t, NamedLocationIdentity'SECONDARY_SUPER_CACHE)
                        true
                    )
                )
            )
        )
    )

    (defn #_"boolean" TypeCheckSnippetUtils'checkSecondarySubType-2 [#_"KlassPointer" t, #_"KlassPointer" sNonNull]
        ;; if (S.cache == T) return true
        (or (Word''klassPointersEqual-2 (Word''readKlassPointer-3 sNonNull, HotSpot'secondarySuperCacheOffset, NamedLocationIdentity'SECONDARY_SUPER_CACHE), t)
            (TypeCheckSnippetUtils'checkSelfAndSupers-2 t, sNonNull)
        )
    )

    (defn #_"boolean" TypeCheckSnippetUtils'checkUnknownSubType-2 [#_"KlassPointer" t, #_"KlassPointer" sNonNull]
        ;; int off = T.offset
        (let [
            #_"int" superCheckOffset (Word''readInt-3i t, HotSpot'superCheckOffsetOffset, NamedLocationIdentity'KLASS_SUPER_CHECK_OFFSET)
        ]
            ;; if (T = S[off]) return true
            (or (Word''klassPointersEqual-2 (Word''readKlassPointer-3 sNonNull, superCheckOffset, NamedLocationIdentity'PRIMARY_SUPERS), t)
                ;; if (off != &cache) return false
                (and (= superCheckOffset HotSpot'secondarySuperCacheOffset)
                    (TypeCheckSnippetUtils'checkSelfAndSupers-2 t, sNonNull)
                )
            )
        )
    )
)

(value-ns UnsafeLoadSnippets (ยง implements Snippets)
    (ยง snippet! #_"Object" #_"UnsafeLoadSnippets" "lowerUnsafeLoad" [#_"Object" object, #_"long" offset]
        (Word''readObject-3ib (Word'objectToTrackedPointer-1 (FixedValueAnchorNode'getObject-1 object)), (int offset), (if (and (instance? java.lang.ref.Reference object) (= offset ReplacementsUtil'REFERENT_OFFSET)) BarrierType'PRECISE BarrierType'NONE))
    )
)

(value-ns WriteBarrierSnippets (ยง implements Snippets)
    (defn- #_"void" WriteBarrierSnippets'serialWriteBarrier-1 [#_"Word" ptr]
        (let [
            #_"long" startAddress (VMConfigNode'cardTableAddress-0)
            #_"Word" base (Word''unsignedShiftRight-2i ptr, HotSpot'cardTableShift)
        ]
            (if (and (= (int startAddress) startAddress) (VMConfigNode'isCardTableAddressConstant-0))
                (Word''writeByte-4i base, (int startAddress), (byte 0), NamedLocationIdentity'GC_CARD)
                (Word''writeByte-4w base, (WordFactory'unsigned-1l startAddress), (byte 0), NamedLocationIdentity'GC_CARD)
            )
        )
        nil
    )

    (ยง snippet! #_"void" #_"WriteBarrierSnippets" "serialImpreciseWriteBarrier" [#_"Object" object]
        (WriteBarrierSnippets'serialWriteBarrier-1 (Word'objectToTrackedPointer-1 object))
        nil
    )

    (ยง snippet! #_"void" #_"WriteBarrierSnippets" "serialPreciseWriteBarrier" [#_"Address" address]
        (WriteBarrierSnippets'serialWriteBarrier-1 (Word'fromAddress-1 address))
        nil
    )

    (ยง snippet! #_"void" #_"WriteBarrierSnippets" "g1PreWriteBarrier" [#_"Address" address, #_"Object" object, #_"Object" expectedObject, #_"boolean" doLoad, #_"boolean" nullCheck]
        (when nullCheck
            (NullCheckNode'nullCheck-1 address)
        )
        (let [
            #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
            #_"byte" markingValue (Word''readByte-2i thread, HotSpot'g1SATBQueueMarkingOffset)
        ]
            ;; If the concurrent marker is enabled, the barrier is issued.
            (when (not= markingValue (byte 0))
                ;; If the previous value has to be loaded (before the write), the load is issued.
                ;; The load is always issued except the cases of CAS and referent field.
                (let [
                    #_"Word" previousOop (Word'objectToTrackedPointer-1 (if doLoad (Word''readObject-3ib (Word'fromAddress-1 address), 0, BarrierType'NONE) (FixedValueAnchorNode'getObject-1 expectedObject)))
                ]
                    ;; If the previous value is nil the barrier should not be issued.
                    (when (Word''notEqual-2i previousOop, 0)
                        ;; If the thread-local SATB buffer is full, issue a native call, which will initialize a new one and add the entry.
                        (let [
                            #_"Word" indexAddress (Word''add-2i thread, HotSpot'g1SATBQueueIndexOffset)
                            #_"Word" indexValue (Word''readWord-2i indexAddress, 0)
                        ]
                            (if (Word''notEqual-2i indexValue, 0)
                                (let [
                                    #_"Word" bufferAddress (Word''readWord-2i thread, HotSpot'g1SATBQueueBufferOffset)
                                    #_"Word" nextIndex (Word''subtract-2i indexValue, (.wordSize HotSpot'target))
                                    #_"Word" logAddress (Word''add-2w bufferAddress, nextIndex)
                                ]
                                    ;; Log the object to be marked as well as update the SATB's buffer next index.
                                    (Word''writeWord-4i logAddress, 0, previousOop, NamedLocationIdentity'GC_LOG)
                                    (Word''writeWord-4i indexAddress, 0, nextIndex, NamedLocationIdentity'GC_INDEX)
                                )
                                (do
                                    (StubForeignCallNode'g1PreBarrier-3 ForeignCallDescriptor'G1WBPRECALL, thread, (Word''toObject-1 previousOop))
                                    (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                                        (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (ยง snippet! #_"void" #_"WriteBarrierSnippets" "g1PostWriteBarrier" [#_"Address" address, #_"Object" object, #_"Object" value, #_"boolean" precise?]
        (let [
            #_"Word" oop (if precise? (Word'fromAddress-1 address) (Word'objectToTrackedPointer-1 object))
            #_"Word" writtenValue (Word'objectToTrackedPointer-1 (FixedValueAnchorNode'getObject-1 value))
            ;; The result of the xor reveals whether the installed pointer crosses heap regions.
            ;; In case it does the write barrier has to be issued.
            #_"Word" xorResult (Word''unsignedShiftRight-2i (Word''xor-2w oop, writtenValue), (VMConfigNode'logOfHeapRegionGrainBytes-0))
            ;; Calculate the address of the card to be enqueued to the thread local card queue.
            #_"Word" cardBase (Word''unsignedShiftRight-2i oop, HotSpot'cardTableShift)
            #_"long" startAddress (VMConfigNode'cardTableAddress-0)
            [cardBase #_"int" displacement]
                (if (and (= (int startAddress) startAddress) (VMConfigNode'isCardTableAddressConstant-0))
                    [cardBase (int startAddress)]
                    [(Word''add-2w cardBase, (WordFactory'unsigned-1l startAddress)) 0]
                )
            #_"Word" cardAddress (Word''add-2i cardBase, displacement)
        ]
            (when (and (Word''notEqual-2i xorResult, 0) (Word''notEqual-2i writtenValue, 0))
                ;; If the written value is not nil, continue with the barrier addition.
                (let [
                    #_"byte" cardByte (Word''readByte-3i cardAddress, 0, NamedLocationIdentity'GC_CARD)
                ]
                    ;; If the card is already dirty, (hence already enqueued) skip the insertion.
                    (when (not= cardByte HotSpot'g1YoungCardValue)
                        (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_LOAD, NamedLocationIdentity'GC_CARD)
                        (let [
                            #_"byte" cardByteReload (Word''readByte-3i cardAddress, 0, NamedLocationIdentity'GC_CARD)
                        ]
                            (when (not= cardByteReload HotSpot'dirtyCardValue)
                                (Word''writeByte-4i cardAddress, 0, (byte 0), NamedLocationIdentity'GC_CARD)
                                ;; If the thread-local card queue is full, issue a native call, which will initialize a new one and add the card entry.
                                (let [
                                    #_"Word" thread (ReplacementsUtil'registerAsWord-1 HotSpot'threadRegister)
                                    #_"Word" indexAddress (Word''add-2i thread, HotSpot'g1CardQueueIndexOffset)
                                    #_"Word" indexValue (Word''readWord-2i thread, HotSpot'g1CardQueueIndexOffset)
                                ]
                                    (if (Word''notEqual-2i indexValue, 0)
                                        (let [
                                            #_"Word" bufferAddress (Word''readWord-2i thread, HotSpot'g1CardQueueBufferOffset)
                                            #_"Word" nextIndex (Word''subtract-2i indexValue, (.wordSize HotSpot'target))
                                            #_"Word" logAddress (Word''add-2w bufferAddress, nextIndex)
                                        ]
                                            ;; Log the object to be scanned as well as update the card queue's next index.
                                            (Word''writeWord-4i logAddress, 0, cardAddress, NamedLocationIdentity'GC_LOG)
                                            (Word''writeWord-4i indexAddress, 0, nextIndex, NamedLocationIdentity'GC_INDEX)
                                        )
                                        (do
                                            (StubForeignCallNode'g1PostBarrier-3 ForeignCallDescriptor'G1WBPOSTCALL, thread, cardAddress)
                                            (when (some? (ReplacementsUtil'clearPendingException-1 thread))
                                                (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

(value-ns MetaspaceOpcode
    (ยง enum MetaspaceOpcode'FROM_POINTER)
    (ยง enum MetaspaceOpcode'TO_KLASS_POINTER)
    (ยง enum MetaspaceOpcode'POINTER_EQ)
    (ยง enum MetaspaceOpcode'POINTER_NE)
    (ยง enum MetaspaceOpcode'IS_NULL)
    (ยง enum MetaspaceOpcode'READ_KLASS_POINTER)
)

(value-ns WordTypes
    (def #_"JavaKind" WordTypes'wordKind (.wordJavaKind HotSpot'target))

    (def #_"ResolvedJavaType" WordTypes'word         (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Word'iface))
    (def #_"ResolvedJavaType" WordTypes'klassPointer (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, #_"KlassPointer" Word'iface))

    ;;;
     ; Determines if a given type is a word type.
     ;;
    (defn #_"boolean" WordTypes'isWord-1j [#_"JavaType" type]
        (and (instance? ResolvedJavaType type)
            (or
                (#_"ResolvedJavaType" .isAssignableFrom WordTypes'klassPointer, type)
                (#_"ResolvedJavaType" .isAssignableFrom WordTypes'word, type)
            )
        )
    )

    ;;;
     ; Determines if a given node has a word type.
     ;;
    (defn #_"boolean" WordTypes'isWord-1v [#_"ValueNode" node]
        (WordTypes'isWord-1j (StampTool'typeOrNull-1 (:stamp node)))
    )

    ;;;
     ; Determines if a given method denotes a word operation.
     ;;
    (defn #_"boolean" WordTypes'isWordOperation-1 [#_"ResolvedJavaMethod" targetMethod]
        (WordTypes'isWord-1j (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod))
    )

    ;;;
     ; Gets the kind for a given type, returning the {@linkplain #getWordKind() word kind}
     ; if {@code type} is a {@linkplain #isWord(JavaType) word type}.
     ;;
    (defn #_"JavaKind" WordTypes'asKind-1 [#_"JavaType" type]
        (if (or (= type WordTypes'klassPointer) (WordTypes'isWord-1j type))
            WordTypes'wordKind
            (#_"JavaType" .getJavaKind type)
        )
    )

    ;;;
     ; Gets the stamp for a given {@linkplain #isWord(JavaType) word type}.
     ;;
    (defn #_"Stamp" WordTypes'getWordStamp-1 [#_"ResolvedJavaType" type]
        (if (= type WordTypes'klassPointer)
            KlassPointerStamp'KLASS
            (StampFactory'forKind-1 WordTypes'wordKind)
        )
    )
)

;;;
 ; Constants denoting the register usage priority for an interval. The constants are declared in
 ; increasing order of priority are are used to optimize spilling when multiple overlapping
 ; intervals compete for limited registers.
 ;;
(value-ns RegisterPriority
    ;;;
     ; No special reason for an interval to be allocated a register.
     ;;
    (ยง enum RegisterPriority'None)
    ;;;
     ; Priority level for intervals live at the end of a loop.
     ;;
    (ยง enum RegisterPriority'LiveAtLoopEnd)
    ;;;
     ; Priority level for intervals that should be allocated to a register.
     ;;
    (ยง enum RegisterPriority'ShouldHaveRegister)
    ;;;
     ; Priority level for intervals that must be allocated to a register.
     ;;
    (ยง enum RegisterPriority'MustHaveRegister)

    (ยง def #_"RegisterPriority[]" RegisterPriority'VALUES (RegisterPriority'values-0))

    ;;;
     ; Determines if a priority is higher than or equal to an other.
     ;;
    (defn #_"boolean" RegisterPriority'greaterEqual-2 [#_"RegisterPriority" a, #_"RegisterPriority" b]
        (>= (RegisterPriority''ordinal-1 a) (RegisterPriority''ordinal-1 b))
    )

    ;;;
     ; Determines if a priority is lower than an other.
     ;;
    (defn #_"boolean" RegisterPriority'lessThan-2 [#_"RegisterPriority" a, #_"RegisterPriority" b]
        (< (RegisterPriority''ordinal-1 a) (RegisterPriority''ordinal-1 b))
    )
)

;;;
 ; Constants denoting whether an interval is bound to a specific register. This models platform
 ; dependencies on register usage for certain instructions.
 ;;
(value-ns RegisterBinding
    ;;;
     ; Interval is bound to a specific register as required by the platform.
     ;;
    (ยง enum RegisterBinding'Fixed)
    ;;;
     ; Interval has no specific register requirements.
     ;;
    (ยง enum RegisterBinding'Any)
    ;;;
     ; Interval is bound to a stack slot.
     ;;
    (ยง enum RegisterBinding'Stack)

    (ยง def #_"RegisterBinding[]" RegisterBinding'VALUES (RegisterBinding'values-0))
)

;;;
 ; Constants denoting the linear-scan states an interval may be in with respect to the
 ; {@linkplain Interval#from() start} {@code position} of the interval being processed.
 ;;
(value-ns IntervalState
    ;;;
     ; An interval that starts after {@code position}.
     ;;
    (ยง enum IntervalState'Unhandled)
    ;;;
     ; An interval that {@linkplain Interval#covers covers} {@code position} and has an assigned register.
     ;;
    (ยง enum IntervalState'Active)
    ;;;
     ; An interval that starts before and ends after {@code position} but does not
     ; {@linkplain Interval#covers cover} it due to a lifetime hole.
     ;;
    (ยง enum IntervalState'Inactive)
    ;;;
     ; An interval that ends before {@code position} or is spilled to memory.
     ;;
    (ยง enum IntervalState'Handled)
)

;;;
 ; Constants used in optimization of spilling of an interval.
 ;;
(value-ns SpillState
    ;;;
     ; Starting state of calculation: no definition found yet.
     ;;
    (ยง enum SpillState'NoDefinitionFound)
    ;;;
     ; One definition has already been found. Two consecutive definitions are treated as one
     ; (e.g. a consecutive move and add because of two-operand LIR form). The position of this
     ; definition is given by Interval#spillDefinitionPos().
     ;;
    (ยง enum SpillState'NoSpillStore)
    ;;;
     ; One spill move has already been inserted.
     ;;
    (ยง enum SpillState'OneSpillStore)
    ;;;
     ; The interval is spilled multiple times or is spilled in a loop. Place the store somewhere
     ; on the dominator path between the definition and the usages.
     ;;
    (ยง enum SpillState'SpillInDominator)
    ;;;
     ; The interval should be stored immediately after its definition to prevent multiple
     ; redundant stores.
     ;;
    (ยง enum SpillState'StoreAtDefinition)
    ;;;
     ; The interval starts in memory (e.g. method parameter), so a store is never necessary.
     ;;
    (ยง enum SpillState'StartInMemory)
    ;;;
     ; The interval has more than one definition (e.g. resulting from phi moves), so stores to
     ; memory are not optimized.
     ;;
    (ยง enum SpillState'NoOptimization)

    (ยง def #_"EnumSet<SpillState>" SpillState'ALWAYS_IN_MEMORY (EnumSet/of SpillState'SpillInDominator, SpillState'StoreAtDefinition, SpillState'StartInMemory))
)

;;;
 ; AMD64 LIR instructions that have two inputs and one output.
 ;;
(value-ns AMD64Binary
)

;;;
 ; AMD64 LIR instructions that have two input operands, but no output operand.
 ;;
(value-ns AMD64BinaryConsumer
)

(value-ns AMD64Call
    (defn- #_"void" AMD64Call'emitAlignmentForDirectCall-1 [#_"Assembler" asm]
        ;; make sure that the displacement word of the call ends up word aligned
        (let [
            #_"int" offset (+ (Assembler''position-1 asm) (#_"Architecture" .getMachineCodeCallDisplacementOffset (.arch HotSpot'target)))
            #_"int" modulus (.wordSize HotSpot'target)
        ]
            (when-not (zero? (% offset modulus))
                (Assembler''nop-2 asm, (- modulus (% offset modulus)))
            )
        )
        nil
    )

    (defn #_"int" AMD64Call'directCall-4 [#_"Assembler" asm, #_"InvokeTarget" callTarget, #_"Register" scratch, #_"boolean" align?]
        (when align?
            (AMD64Call'emitAlignmentForDirectCall-1 asm)
        )
        (let [
            #_"int" callPCOffset
                (if (some? scratch)
                    (do
                        ;; offset might not fit a 32-bit immediate, generate an indirect call with a 64-bit immediate
                        (Assembler''movq-3rl asm, scratch, 0)
                        (let [
                            callPCOffset (Assembler''position-1 asm)
                        ]
                            (Assembler''call-2 asm, scratch)
                            callPCOffset
                        )
                    )
                    (let [
                        callPCOffset (Assembler''position-1 asm)
                    ]
                        (Assembler''call-1 asm)
                        callPCOffset
                    )
                )
        ]
            (Assembler''ensureUniquePC-1 asm)
            callPCOffset
        )
    )

    (defn #_"void" AMD64Call'directJmp-2 [#_"Assembler" asm, #_"InvokeTarget" target]
        (Assembler''jmp-3 asm, 0, true)
        (Assembler''ensureUniquePC-1 asm)
        nil
    )

    #_unused
    (defn #_"void" AMD64Call'directConditionalJmp-3 [#_"Assembler" asm, #_"InvokeTarget" target, #_"ConditionFlag" cond]
        (Assembler''jcc-4 asm, cond, 0, true)
        (Assembler''ensureUniquePC-1 asm)
        nil
    )
)

(value-ns AMD64ControlFlow
    (defn #_"void" AMD64ControlFlow'cmove-4 [#_"Assembler" asm, #_"Value" result, #_"ConditionFlag" cond, #_"Value" other]
        (if (instance? RegisterValue other)
            (condp =? (#_"Value" .getPlatformKind other)
               [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                    (Assembler''cmovl-4rr asm, cond, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister other))
                AMD64Kind/QWORD
                    (Assembler''cmovq-4rr asm, cond, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister other))
            )
            (let [
                #_"AMD64Address" addr (Assembler''asAddress-2 asm, other)
            ]
                (condp =? (#_"Value" .getPlatformKind other)
                   [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                        (Assembler''cmovl-4ra asm, cond, (#_"RegisterValue" .getRegister result), addr)
                    AMD64Kind/QWORD
                        (Assembler''cmovq-4ra asm, cond, (#_"RegisterValue" .getRegister result), addr)
                )
            )
        )
        nil
    )

    (defn #_"void" AMD64ControlFlow'setcc-3 [#_"Assembler" asm, #_"Value" result, #_"ConditionFlag" cond]
        (condp =? (#_"Value" .getPlatformKind result)
           [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                (Assembler''setl-3 asm, cond, (#_"RegisterValue" .getRegister result))
            AMD64Kind/QWORD
                (Assembler''setq-3 asm, cond, (#_"RegisterValue" .getRegister result))
        )
        nil
    )

    (defn #_"ConditionFlag" AMD64ControlFlow'intCond-1 [#_"Condition" cond]
        (condp = cond
            Condition'EQ ConditionFlag'Equal
            Condition'NE ConditionFlag'NotEqual
            Condition'LT ConditionFlag'Less
            Condition'LE ConditionFlag'LessEqual
            Condition'GE ConditionFlag'GreaterEqual
            Condition'GT ConditionFlag'Greater
            Condition'BE ConditionFlag'BelowEqual
            Condition'AE ConditionFlag'AboveEqual
            Condition'AT ConditionFlag'Above
            Condition'BT ConditionFlag'Below
        )
    )
)

(value-ns AMD64Move
    (defn #_"void" AMD64Move'move-3 [#_"Assembler" asm, #_"Value" result, #_"Value" input]
        (AMD64Move'move-4 (#_"Value" .getPlatformKind result), asm, result, input)
        nil
    )

    (defn- #_"void" AMD64Move'reg2reg-4 [#_"AMD64Kind" kind, #_"Assembler" asm, #_"Value" result, #_"Value" input]
        (when-not (= (#_"RegisterValue" .getRegister input) (#_"RegisterValue" .getRegister result))
            (condp =? kind
               [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                    (Assembler''movl-3rr asm, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister input))
                AMD64Kind/QWORD
                    (Assembler''movq-3rr asm, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister input))
            )
        )
        nil
    )

    (defn #_"void" AMD64Move'move-4 [#_"AMD64Kind" moveKind, #_"Assembler" asm, #_"Value" result, #_"Value" input]
        (cond
            (instance? RegisterValue input)
                (condp instance? result
                    RegisterValue (AMD64Move'reg2reg-4 moveKind, asm, result, input)
                    StackSlot     (AMD64Move'reg2stack-4 moveKind, asm, result, (#_"RegisterValue" .getRegister input))
                )
            (instance? StackSlot input)
                (condp instance? result
                    RegisterValue (AMD64Move'stack2reg-4 moveKind, asm, (#_"RegisterValue" .getRegister result), input)
                )
            (LIRValueUtil'isJavaConstant-1 input)
                (condp instance? result
                    RegisterValue (AMD64Move'const2reg-3 asm, (#_"RegisterValue" .getRegister result), (:constant input))
                    StackSlot     (AMD64Move'const2stack-3 asm, result, (:constant input))
                )
            :else                 (throw! "should not reach here")
        )
        nil
    )

    (defn #_"void" AMD64Move'reg2stack-4 [#_"AMD64Kind" kind, #_"Assembler" asm, #_"Value" result, #_"Register" input]
        (let [
            #_"AMD64Address" dst (Assembler''asAddress-2 asm, result)
        ]
            (condp = kind
                AMD64Kind/BYTE  (Assembler''movb-3ar asm, dst, input)
                AMD64Kind/WORD  (Assembler''movw-3ar asm, dst, input)
                AMD64Kind/DWORD (Assembler''movl-3ar asm, dst, input)
                AMD64Kind/QWORD (Assembler''movq-3ar asm, dst, input)
            )
        )
        nil
    )

    (defn #_"void" AMD64Move'stack2reg-4 [#_"AMD64Kind" kind, #_"Assembler" asm, #_"Register" result, #_"Value" input]
        (let [
            #_"AMD64Address" src (Assembler''asAddress-2 asm, input)
        ]
            (condp = kind
                AMD64Kind/BYTE  (Assembler''movsbl-3ra asm, result, src)
                AMD64Kind/WORD  (Assembler''movswl-3 asm, result, src)
                AMD64Kind/DWORD (Assembler''movl-3ra asm, result, src)
                AMD64Kind/QWORD (Assembler''movq-3ra asm, result, src)
            )
        )
        nil
    )

    (defn #_"void" AMD64Move'const2reg-3 [#_"Assembler" asm, #_"Register" result, #_"JavaConstant" input]
        ;; Note: we use the kind of the input operand (and not the kind of the result operand),
        ;; because they don't match in all cases. For example, an object constant can be loaded to
        ;; a long register when unsafe casts occurred (e.g. for a write barrier where arithmetic
        ;; operations are then performed on the pointer).
        (condp = (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind input))
            JavaKind/Int
                ;; Do not optimize with an XOR, as this instruction may be between a CMP and a Jcc,
                ;; in which case the XOR will modify the condition flags and interfere with the Jcc.
                (Assembler''movl-3ri asm, result, (#_"JavaConstant" .asInt input))
            JavaKind/Long
                ;; Do not optimize with an XOR, as this instruction may be between a CMP and a Jcc,
                ;; in which case the XOR will modify the condition flags and interfere with the Jcc.
                (cond
                    (= (#_"JavaConstant" .asLong input) (int (#_"JavaConstant" .asLong input)))
                        ;; sign extended to long
                        (Assembler''movslq-3ri asm, result, (int (#_"JavaConstant" .asLong input)))
                    (= (& (#_"JavaConstant" .asLong input) 0xffffffff) (#_"JavaConstant" .asLong input))
                        ;; zero extended to long
                        (Assembler''movl-3ri asm, result, (int (#_"JavaConstant" .asLong input)))
                    :else
                        (Assembler''movq-3rl asm, result, (#_"JavaConstant" .asLong input))
                )
            JavaKind/Object
                ;; Do not optimize with an XOR, as this instruction may be between a CMP and a Jcc,
                ;; in which case the XOR will modify the condition flags and interfere with the Jcc.
                (cond
                    (#_"JavaConstant" .isNull input)
                        (Assembler''movq-3rl asm, result, 0)
                    (.inlineObjects HotSpot'target)
                    (do
                        (Assembler''recordInlineDataInCode-2 asm, input)
                        (Assembler''movq-3rl asm, result, 0xdeaddeaddeaddead)
                    )
                    :else
                        (Assembler''movq-3ra asm, result, (Assembler''recordDataReferenceInCode-3c asm, input, 0))
                )
        )
        nil
    )

    (defn #_"boolean" AMD64Move'canMoveConst2Stack-1 [#_"JavaConstant" input]
        (condp = (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind input))
            JavaKind/Int    true
            JavaKind/Long   true
            JavaKind/Object (#_"JavaConstant" .isNull input)
                            false
        )
    )

    (defn #_"void" AMD64Move'const2stack-3 [#_"Assembler" asm, #_"Value" result, #_"JavaConstant" input]
        (let [
            #_"AMD64Address" dest (Assembler''asAddress-2 asm, result)
            #_"long" imm
                (condp = (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind input))
                    JavaKind/Int  (#_"JavaConstant" .asInt input)
                    JavaKind/Long (#_"JavaConstant" .asLong input)
                    JavaKind/Object
                        (when (#_"JavaConstant" .isNull input) => (throw! "non-nil object constants must be in register")
                            0
                        )
                )
        ]
            (condp = (#_"Value" .getPlatformKind result)
                AMD64Kind/BYTE  (AMD64MIOp''emit-5a AMD64MIOp'MOVB, asm, OperandSize'BYTE, dest, (int imm))
                AMD64Kind/WORD  (AMD64MIOp''emit-5a AMD64MIOp'MOV, asm, OperandSize'WORD, dest, (int imm))
                AMD64Kind/DWORD (Assembler''movl-3ai asm, dest, (int imm))
                AMD64Kind/QWORD (Assembler''movlong-3 asm, dest, imm)
            )
        )
        nil
    )
)

;;;
 ; AMD64 LIR instructions that have one input and one output.
 ;;
(value-ns AMD64Unary
)

(value-ns DataBuilder
    (defn #_"Data" DataBuilder'createDataItem-1 [#_"Constant" constant]
        (cond
            (JavaConstant/isNull constant)
                (let [
                    #_"int" size (if (= HotSpotCompressedNullConstant/COMPRESSED_NULL constant) 4 (.wordSize HotSpot'target))
                ]
                    (ZeroData'create-2 size, size)
                )
            (instance? VMConstant constant)
                (when (instance? HotSpotConstant constant) => (throw! (str constant))
                    (let [
                        #_"int" size (if (#_"HotSpotConstant" .isCompressed constant) 4 (.wordSize HotSpot'target))
                    ]
                        (ยง proxy #_"Data" (Data'new-2 size, size)
                            (#_"void" Data'''emit-3 [#_"Data" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                                (let [
                                    #_"int" position (#_"ByteBuffer" .position buffer)
                                ]
                                    (if (= (:size this) Integer/BYTES)
                                        (#_"ByteBuffer" .putInt buffer, 0xdeaddead)
                                        (#_"ByteBuffer" .putLong buffer, 0xdeaddeaddeaddead)
                                    )
                                    (Patches'''registerPatch-3 patches, position, constant)
                                )
                                nil
                            )
                        )
                    )
                )
            :else
                (throw! (str constant))
        )
    )
)

(value-ns Flags
    (ยง enum Flags'IN_SUBTREE)
    (ยง enum Flags'HAS_USAGE)
    (ยง enum Flags'MATERIALIZE)
    (ยง enum Flags'CANDIDATE)
)

;;;
 ; Constants denoting how a LIR instruction uses an operand.
 ;;
(value-ns OperandMode
    ;;;
     ; The value must have been defined before. It is alive before the instruction until the beginning
     ; of the instruction, but not necessarily throughout the instruction. A register assigned to it can
     ; also be assigned to a #TEMP or #DEF operand. The value can be used again after the instruction,
     ; so the instruction must not modify the register.
     ;;
    (ยง enum OperandMode'USE)
    ;;;
     ; The value must have been defined before. It is alive before the instruction and throughout
     ; the instruction. A register assigned to it cannot be assigned to a #TEMP or #DEF operand.
     ; The value can be used again after the instruction, so the instruction must not modify the register.
     ;;
    (ยง enum OperandMode'ALIVE)
    ;;;
     ; The value must not have been defined before, and must not be used after the instruction.
     ; The instruction can do whatever it wants with the register assigned to it (or not use it at all).
     ;;
    (ยง enum OperandMode'TEMP)
    ;;;
     ; The value must not have been defined before. The instruction has to assign a value to the
     ; register. The value can (and most likely will) be used after the instruction.
     ;;
    (ยง enum OperandMode'DEF)
)

;;;
 ; Flags for an operand.
 ;;
(value-ns OperandFlag
    ;;;
     ; The value can be a RegisterValue.
     ;;
    (ยง enum OperandFlag'REG)
    ;;;
     ; The value can be a StackSlot.
     ;;
    (ยง enum OperandFlag'STACK)
    ;;;
     ; The value can be a CompositeValue.
     ;;
    (ยง enum OperandFlag'COMPOSITE)
    ;;;
     ; The value can be a JavaConstant.
     ;;
    (ยง enum OperandFlag'CONST)
    ;;;
     ; The value can be Value#ILLEGAL.
     ;;
    (ยง enum OperandFlag'ILLEGAL)
    ;;;
     ; The register allocator should try to assign a certain register to improve code quality.
     ; Use LIRInstruction#forEachRegisterHint to access the register hints.
     ;;
    (ยง enum OperandFlag'HINT)
    ;;;
     ; The value can be uninitialized, e.g. a stack slot that has not written to before. This
     ; is only used to avoid false positives in verification code.
     ;;
    (ยง enum OperandFlag'UNINITIALIZED)
    ;;;
     ; Outgoing block value.
     ;;
    (ยง enum OperandFlag'OUTGOING)
)

(value-ns LIRValueUtil
    (defn #_"boolean" LIRValueUtil'isJavaConstant-1 [#_"Value" value]
        (and (satisfies? ConstantValue value) (instance? JavaConstant (:constant value)))
    )

    (defn #_"boolean" LIRValueUtil'isIntConstant-2 [#_"Value" value, #_"long" expected]
        (and (LIRValueUtil'isJavaConstant-1 value)
            (let [
                #_"JavaConstant" jc (:constant value)
            ]
                (and (some? jc) (#_"JavaKind" .isNumericInteger (#_"JavaConstant" .getJavaKind jc))
                    (= (#_"JavaConstant" .asLong jc) expected)
                )
            )
        )
    )

    (defn #_"boolean" LIRValueUtil'isStackSlotValue-1 [#_"Value" value]
        (or (instance? StackSlot value) (satisfies? VirtualStackSlot value))
    )

    (defn #_"boolean" LIRValueUtil'sameRegister-2 [#_"Value" v1, #_"Value" v2]
        (and (instance? RegisterValue v1) (instance? RegisterValue v2) (= (#_"RegisterValue" .getRegister v1) (#_"RegisterValue" .getRegister v2)))
    )
)

;;;
 ; Utilities for working with Static-Single-Assignment LIR form.
 ;
 ; Representation of {@code PHI}s
 ;
 ; There is no explicit {@code PHI} LIRInstruction. Instead, they are implemented
 ; as parallel copy that span across a control-flow edge.
 ;
 ; The variables introduced by {@code PHI}s of a specific merge block
 ; are {@linkplain LabelOp#setIncomingValues attached} to the LabelOp
 ; of the block. The outgoing values from the predecessor are {@link JumpOp#getOutgoingValue input}
 ; to the BlockEndOp of the predecessor. Because there are no critical edges we know
 ; that the BlockEndOp of the predecessor has to be a JumpOp.
 ;
 ; Example:
 ;
 ; B0 -> B1
 ;   ...
 ;   v0|i = ...
 ;   JUMP ~[v0|i, int[0|0x0]] destination: B0 -> B1
 ; ________________________________________________
 ;
 ; B2 -> B1
 ;   ...
 ;   v1|i = ...
 ;   v2|i = ...
 ;   JUMP ~[v1|i, v2|i] destination: B2 -> B1
 ; ________________________________________________
 ;
 ; B1 <- B0,B2
 ;   [v3|i, v4|i] = LABEL
 ;   ...
 ;;
(value-ns SSAUtil
    (defn #_"LabelOp" SSAUtil'phiIn-2 [#_"LIR" lir, #_"Block" block]
        (nth (LIR''getLIRforBlock-2 lir, block) 0)
    )

    (defn #_"void" SSAUtil'removePhiIn-2 [#_"LIR" lir, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
        ]
            (ยง ass! (nth ops 0) (LabelOp''clearIncomingValues-1 (nth ops 0)))
        )
        nil
    )

    (defn #_"int" SSAUtil'phiOutIndex-2 [#_"LIR" lir, #_"Block" block]
        (dec (count (LIR''getLIRforBlock-2 lir, block)))
    )

    (defn #_"JumpOp" SSAUtil'phiOut-2 [#_"LIR" lir, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
        ]
            (nth ops (dec (count ops)))
        )
    )

    (defn #_"void" SSAUtil'removePhiOut-2 [#_"LIR" lir, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
        ]
            (ยง ass! (nth ops (dec (count ops))) (JumpOp''clearOutgoingValues-1 (nth ops (dec (count ops)))))
        )
        nil
    )

    ;;;
     ; Visits each phi value pair of an edge, i.e. the outgoing value from the predecessor and the
     ; incoming value to the merge block.
     ;;
    (defn #_"void" SSAUtil'forEachPhiValuePair-4 [#_"LIR" lir, #_"Block" merge, #_"Block" pred, #_"PhiValueVisitor" visitor]
        (when-not (< (count (:predecessors merge)) 2)
            (let [
                #_"LabelOp" label (SSAUtil'phiIn-2 lir, merge)
                #_"JumpOp" jump (SSAUtil'phiOut-2 lir, pred)
            ]
                (dotimes [#_"int" i (:numPhis label)]
                    (PhiValueVisitor'''visit-3 visitor, (LabelOp''getIncomingValue-2 label, i), (JumpOp''getOutgoingValue-2 jump, i))
                )
            )
        )
        nil
    )

    (defn- #_"int" SSAUtil'indexOfValue-2 [#_"LabelOp" label, #_"Value" value]
        (loop-when [#_"int" i 0] (< i (LabelOp''getIncomingSize-1 label)) => -1
            (if (= (LabelOp''getIncomingValue-2 label, i) value)
                i
                (recur (inc i))
            )
        )
    )

    (defn #_"void" SSAUtil'forEachPhiRegisterHint-6 [#_"LIR" lir, #_"Block" block, #_"LabelOp" label, #_"Value" targetValue, #_"OperandMode" mode, #_"ValueConsumer" valueConsumer]
        (when (LabelOp''isPhiIn-1 label)
            (let [
                #_"int" idx (SSAUtil'indexOfValue-2 label, targetValue)
            ]
                (doseq [#_"Block" pred (:predecessors block)]
                    (let [
                        #_"JumpOp" jump (SSAUtil'phiOut-2 lir, pred)
                    ]
                        (ValueConsumer'''visitValue-5 valueConsumer, jump, (JumpOp''getOutgoingValue-2 jump, idx), nil, nil)
                    )
                )
            )
        )
        nil
    )
)

(value-ns SlotSize
    (ยง enum SlotSize'Size1)
    (ยง enum SlotSize'Size2)
    (ยง enum SlotSize'Size4)
    (ยง enum SlotSize'Size8)
    (ยง enum SlotSize'Illegal)
)

;;;
 ; A collection of machine-independent LIR operations, as well as interfaces to be implemented
 ; for specific kinds or LIR operations.
 ;;
(value-ns StandardOp
)

(value-ns Direction
    :Direction'Up
    :Direction'Down

    (defn #_"Direction" Direction''opposite-1 [#_"Direction" this]
        (case this
            :Direction'Up :Direction'Down
            :Direction'Down :Direction'Up
        )
    )
)

;;;
 ; Utility methods to perform integer math with some obvious constant folding first.
 ;;
(value-ns MathUtil
    (defn- #_"boolean" MathUtil'isConstantOne-1 [#_"ValueNode" v1]
        (and (satisfies? ConstantNode v1) (satisfies? IntegerStamp (:stamp v1)) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 v1)) 1))
    )

    (defn- #_"boolean" MathUtil'isConstantZero-1 [#_"ValueNode" v1]
        (and (satisfies? ConstantNode v1) (satisfies? IntegerStamp (:stamp v1)) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 v1))))
    )

    (defn #_"ValueNode" MathUtil'add-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (cond
            (MathUtil'isConstantZero-1 v1) v2
            (MathUtil'isConstantZero-1 v2) v1
            :else                          (BinaryArithmeticNode'add-3 graph, v1, v2)
        )
    )

    (defn #_"ValueNode" MathUtil'mul-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (cond
            (MathUtil'isConstantOne-1 v1) v2
            (MathUtil'isConstantOne-1 v2) v1
            :else                         (BinaryArithmeticNode'mul-3 graph, v1, v2)
        )
    )

    (defn #_"ValueNode" MathUtil'sub-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (cond
            (MathUtil'isConstantZero-1 v2) v1
            :else                          (BinaryArithmeticNode'sub-3 graph, v1, v2)
        )
    )

    (defn- #_"ValueNode" MathUtil'fixedDivBefore-5 [#_"Graph" graph, #_"FixedNode" before, #_"ValueNode" dividend, #_"ValueNode" divisor, #_"fn ValueNode [ValueNode ValueNode]" f'createDiv-2]
        (when-not (MathUtil'isConstantOne-1 divisor) => dividend
            (let [
                #_"ValueNode" div (Graph''addOrUniqueWithInputs-2 graph, (f'createDiv-2 dividend, divisor))
            ]
                (when (satisfies? FixedBinaryNode div) => div
                    (if (and (satisfies? FixedBinaryNode (:predecessor before)) (Node''dataFlowEquals-2 div, (:predecessor before)))
                        (do
                            (Node''safeDelete-1 div)
                            (:predecessor before)
                        )
                        (do
                            (Graph''addBeforeFixed-3 graph, before, div)
                            div
                        )
                    )
                )
            )
        )
    )

    #_unused
    (defn #_"ValueNode" MathUtil'divBefore-4 [#_"Graph" graph, #_"FixedNode" before, #_"ValueNode" dividend, #_"ValueNode" divisor]
        (MathUtil'fixedDivBefore-5 graph, before, dividend, divisor, SignedDivNode'create-2)
    )

    (defn #_"ValueNode" MathUtil'unsignedDivBefore-4 [#_"Graph" graph, #_"FixedNode" before, #_"ValueNode" dividend, #_"ValueNode" divisor]
        (MathUtil'fixedDivBefore-5 graph, before, dividend, divisor, UnsignedDivNode'create-2)
    )
)

(value-ns LoopTransformations
    (defn #_"void" LoopTransformations'peel-1 [#_"LoopEx" _loop]
        (LoopFragment'''insertBefore-2 (LoopFragment'''duplicate-1 (LoopEx''inside-1 _loop)), _loop)
        (ยง ass! (LoopEx''loopBegin-1 _loop) (LoopBeginNode''setLoopFrequency-2 (LoopEx''loopBegin-1 _loop), (max 0.0 (dec (:loopFrequency (LoopEx''loopBegin-1 _loop))))))
        nil
    )

    (defn #_"void" LoopTransformations'fullUnroll-2 [#_"LoopEx" _loop, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 _loop)
            #_"Graph" graph (:graph loopBegin)
            #_"int" initialNodeCount (Graph''getNodeCount-1 graph)
        ]
            (while (not (Node''isDeleted-1 loopBegin))
                (let [
                    #_"int" mark (Graph''getMark-1 graph)
                ]
                    (LoopTransformations'peel-1 _loop)
                    (CanonicalizerPhase''applyIncremental-3m canonicalizer, graph, mark)
                    (ยง ass! _loop (LoopEx''invalidateFragments-1 _loop))
                    (when (< (+ initialNodeCount (* GraalOptions'maximumDesiredSize 2)) (Graph''getNodeCount-1 graph))
                        (throw! "full unroll: graph seems to grow out of proportion")
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" LoopTransformations'unswitch-2 [#_"LoopEx" _loop, #_"List<ControlSplitNode>" controlSplitNodeSet]
        (let [
            #_"ControlSplitNode" firstNode (#_"Iterator" .next (#_"List" .iterator controlSplitNodeSet))
            #_"LoopFragmentWhole" originalLoop (LoopEx''whole-1 _loop)
            #_"Graph" graph (:graph firstNode)
        ]
            (ยง ass! (LoopEx''loopBegin-1 _loop) (LoopBeginNode''incrementUnswitches-1 (LoopEx''loopBegin-1 _loop)))

            ;; create new control split out of loop
            (let [
                #_"ControlSplitNode" newControlSplit (Node''copyWithInputs-1 firstNode)
            ]
                (Node''replaceAtPredecessor-2 (LoopFragmentWhole''entryPoint-1 originalLoop), newControlSplit)

                ;; The code below assumes that all of the control split nodes have the same successor structure,
                ;; which should have been enforced by findUnswitchable.
                (let [
                    ;; original loop is used as first successor
                    [#_"Position" firstPosition & #_"Position*" successors] (Node''successorPositions-1 firstNode)
                    #_"AbstractBeginNode" originalLoopBegin (BeginNode'begin-1 (LoopFragmentWhole''entryPoint-1 originalLoop))
                ]
                    (Position''set-3 firstPosition, newControlSplit, originalLoopBegin)

                    (doseq [#_"Position" position successors]
                        (let [
                            ;; create a new loop duplicate and connect it
                            #_"LoopFragmentWhole" duplicateLoop (LoopFragment'''duplicate-1 originalLoop)
                            #_"AbstractBeginNode" newBegin (BeginNode'begin-1 (LoopFragmentWhole''entryPoint-1 duplicateLoop))
                        ]
                            (Position''set-3 position, newControlSplit, newBegin)

                            ;; for each cloned ControlSplitNode, simplify the proper path
                            (doseq [#_"ControlSplitNode" controlSplitNode controlSplitNodeSet]
                                (let [
                                    #_"ControlSplitNode" duplicatedControlSplit (LoopFragment''getDuplicatedNode-2 duplicateLoop, controlSplitNode)
                                ]
                                    (when (Node''isAlive-1 duplicatedControlSplit)
                                        (let [
                                            #_"AbstractBeginNode" survivingSuccessor (Position''get-2 position, duplicatedControlSplit)
                                        ]
                                            (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, newBegin)
                                            (Graph''removeSplitPropagate-3 graph, duplicatedControlSplit, survivingSuccessor)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    ;; original loop is simplified last to avoid deleting controlSplitNode too early
                    (doseq [#_"ControlSplitNode" controlSplitNode controlSplitNodeSet]
                        (when (Node''isAlive-1 controlSplitNode)
                            (let [
                                #_"AbstractBeginNode" survivingSuccessor (Position''get-2 firstPosition, controlSplitNode)
                            ]
                                (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, originalLoopBegin)
                                (Graph''removeSplitPropagate-3 graph, controlSplitNode, survivingSuccessor)
                            )
                        )
                    )

                    ;; TODO probabilities need some amount of fixup (probably also in other transforms)
                )
            )
        )
        nil
    )

    (defn #_"void" LoopTransformations'partialUnroll-1 [#_"LoopEx" _loop]
        (LoopFragmentInside''insertWithinAfter-2 (LoopFragment'''duplicate-1 (LoopEx''inside-1 _loop)), _loop)
        nil
    )

    (defn- #_"EndNode" LoopTransformations'getBlockEnd-1 [#_"FixedNode" node]
        (loop-when-recur node (satisfies? FixedWithNextNode node) (:next node) => node)
    )

    ;;;
     ; Find the end of the block following the LoopExit.
     ;;
    (defn- #_"EndNode" LoopTransformations'getBlockEndAfterLoopExit-1 [#_"LoopBeginNode" curLoopBegin]
        ;; find the last node after the exit blocks starts
        (LoopTransformations'getBlockEnd-1 (:next (LoopBeginNode''getSingleLoopExit-1 curLoopBegin)))
    )

    (defn- #_"void" LoopTransformations'processPreLoopPhis-3 [#_"LoopEx" preLoop, #_"LoopFragmentWhole" mainLoop, #_"LoopFragmentWhole" postLoop]
        ;; process phis for the post loop
        (doseq [#_"PhiNode" prePhiNode (AbstractMergeNode''phis-1 (LoopEx''loopBegin-1 preLoop))]
            (let [
                #_"PhiNode" postPhiNode (LoopFragment''getDuplicatedNode-2 postLoop, prePhiNode)
                #_"PhiNode" mainPhiNode (LoopFragment''getDuplicatedNode-2 mainLoop, prePhiNode)
            ]
                (PhiNode''setValueAt-3i postPhiNode, 0, mainPhiNode)

                ;; build a work list to update the pre loop phis to the post loops phis
                (doseq [#_"Node" usage (:nodeUsages prePhiNode)]
                    (when (and (not= usage mainPhiNode) (LoopEx''isOutsideLoop-2 preLoop, usage))
                        (Node''replaceFirstInput-3 usage, prePhiNode, postPhiNode)
                    )
                )
            )
        )
        (doseq [#_"Node" node (LoopFragment'''nodes-1 (LoopEx''inside-1 preLoop))]
            (doseq [#_"Node" externalUsage (:nodeUsages node)]
                (when (LoopEx''isOutsideLoop-2 preLoop, externalUsage)
                    (let [
                        #_"Node" postUsage (LoopFragment''getDuplicatedNode-2 postLoop, node)
                    ]
                        (Node''replaceFirstInput-3 externalUsage, node, postUsage)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Cleanup the merge and remove the predecessors too.
     ;;
    (defn- #_"void" LoopTransformations'cleanupMerge-2 [#_"AbstractMergeNode" mergeNode, #_"AbstractBeginNode" landingNode]
        (doseq [#_"EndNode" end (ยง snap (Node'''cfgPredecessors-1 mergeNode))]
            (AbstractMergeNode''removeEnd-2 mergeNode, end)
            (Node''safeDelete-1 end)
        )
        (AbstractBeginNode'''prepareDelete-2 mergeNode, landingNode)
        (Node''safeDelete-1 mergeNode)
        nil
    )

    (defn- #_"void" LoopTransformations'updateMainLoopLimit-3 [#_"IfNode" preLimit, #_"InductionVariable" preIv, #_"LoopFragmentWhole" mainLoop]
        ;; update the main loops limit test to be different than the post loop
        (let [
            #_"IfNode" mainLimit (LoopFragment''getDuplicatedNode-2 mainLoop, preLimit)
            #_"LogicNode" logic (:logic mainLimit)
            #_"ValueNode" prePhi (InductionVariable'''valueNode-1 preIv)
            #_"ValueNode" mainPhi (LoopFragment''getDuplicatedNode-2 mainLoop, prePhi)
            #_"ValueNode" preStride (InductionVariable'''strideNode-1 preIv)
            #_"ValueNode" mainStride (if (satisfies? ConstantNode preStride) preStride (LoopFragment''getDuplicatedNode-2 mainLoop, preStride))
            ;; fetch the bounds to pose lowering the range by one
            #_"ValueNode" ub
                (condp = mainPhi
                    (:x logic) (:y logic)
                    (:y logic) (:x logic)
                )
            ;; preloop always performs at least one iteration, so remove that from the main loop
            #_"ValueNode" newLimit (MathUtil'sub-3 (:graph preLimit), ub, mainStride)
        ]
            ;; re-wire the condition with the new limit
            (Node''replaceFirstInput-3 logic, ub, newLimit)
        )
        nil
    )

    (defn- #_"void" LoopTransformations'updatePreLoopLimit-3 [#_"IfNode" preLimit, #_"InductionVariable" preIv, #_"CountedLoopInfo" preCounted]
        ;; update the pre loops limit test
        (let [
            #_"Graph" graph (:graph preLimit)
            #_"LogicNode" logic (:logic preLimit)
            #_"ValueNode" prePhi (InductionVariable'''valueNode-1 preIv)
            ;; make new limit one iteration
            #_"ValueNode" initIv (CountedLoopInfo''getStart-1 preCounted)
            #_"ValueNode" newLimit (MathUtil'add-3 graph, initIv, (InductionVariable'''strideNode-1 preIv))
            ;; fetch the variable we are not replacing and configure the one we are
            #_"ValueNode" ub
                (condp = prePhi
                    (:x logic) (:y logic)
                    (:y logic) (:x logic)
                )
        ]
            ;; re-wire the condition with the new limit
            (Node''replaceFirstInput-3 logic, ub, (Graph''add-2 graph, (ConditionalNode'new-3 (Graph''add-2 graph, (if (= (InductionVariable'''direction-1 preIv) :Direction'Up) (IntegerLessThanNode'new-2 newLimit, ub) (IntegerLessThanNode'new-2 ub, newLimit))), newLimit, ub)))
        )
        nil
    )

    ;; This function splits candidate loops into pre, main and post loops,
    ;; dividing the iteration space to facilitate the majority of iterations
    ;; being executed in a main loop, which will have RCE implemented upon it.
    ;; The initial loop form is constrained to single entry/exit, but can have
    ;; flow. The translation looks like:
    ;;
    ;;       (Simple Loop entry)                   (Pre Loop Entry)
    ;;                |                                  |
    ;;         (LoopBeginNode)                    (LoopBeginNode)
    ;;                |                                  |
    ;;       (Loop Control Test)<------   ==>  (Loop control Test)<------
    ;;         /               \       \         /               \       \
    ;;    (Loop Exit)      (Loop Body) |    (Loop Exit)      (Loop Body) |
    ;;        |                |       |        |                |       |
    ;; (continue code)     (Loop End)  |  if (M < length)*   (Loop End)  |
    ;;                         \       /       /      \           \      /
    ;;                          ----->        /       |            ----->
    ;;                                       /  if ( ... )*
    ;;                                      /     /       \
    ;;                                     /     /         \
    ;;                                    /     /           \
    ;;                                   |     /     (Main Loop Entry)
    ;;                                   |    |             |
    ;;                                   |    |      (LoopBeginNode)
    ;;                                   |    |             |
    ;;                                   |    |     (Loop Control Test)<------
    ;;                                   |    |      /               \        \
    ;;                                   |    |  (Loop Exit)      (Loop Body) |
    ;;                                    \   \      |                |       |
    ;;                                     \   \     |            (Loop End)  |
    ;;                                      \   \    |                \       /
    ;;                                       \   \   |                 ------>
    ;;                                        \   \  |
    ;;                                      (Main Loop Merge)*
    ;;                                               |
    ;;                                      (Post Loop Entry)
    ;;                                               |
    ;;                                        (LoopBeginNode)
    ;;                                               |
    ;;                                       (Loop Control Test)<-----
    ;;                                        /               \       \
    ;;                                    (Loop Exit)     (Loop Body) |
    ;;                                        |               |       |
    ;;                                 (continue code)    (Loop End)  |
    ;;                                                         \      /
    ;;                                                          ----->
    ;;
    ;; Key: "*" = optional.
    ;;
    ;; The value "M" is the maximal value of the loop trip for the original
    ;; loop. The value of "length" is applicable to the number of arrays found
    ;; in the loop but is reduced if some or all of the arrays are known to be
    ;; the same length as "M". The maximum number of tests can be equal to the
    ;; number of arrays in the loop, where multiple instances of an array are
    ;; subsumed into a single test for that arrays length.
    ;;
    ;; If the optional main loop entry tests are absent, the Pre Loop exit
    ;; connects to the Main loops entry and there is no merge hanging off the
    ;; main loops exit to converge flow from said tests. All split use data
    ;; flow is mitigated through phi(s) in the main merge if present and
    ;; passed through the main and post loop phi(s) from the originating pre
    ;; loop with final phi(s) and data flow patched to the "continue code".
    ;; The pre loop is constrained to one iteration for now and will likely
    ;; be updated to produce vector alignment if applicable.

    (defn #_"LoopBeginNode" LoopTransformations'insertPrePostLoops-1 [#_"LoopEx" _loop]
        (let [
            #_"Graph" graph (:graph (LoopEx''loopBegin-1 _loop))
            #_"LoopFragmentWhole" preLoop (LoopEx''whole-1 _loop)
            #_"CountedLoopInfo" preCounted (:counted _loop)
            #_"IfNode" preLimit (:ifNode preCounted)
            #_"LoopBeginNode" preLoopBegin (LoopEx''loopBegin-1 _loop)
            #_"InductionVariable" preIv (:iv preCounted)
            #_"LoopExitNode" preLoopExitNode (LoopBeginNode''getSingleLoopExit-1 preLoopBegin)
            #_"FixedNode" continuationNode (:next preLoopExitNode)
            ;; each duplication is inserted after the original, ergo create the post loop first
            #_"LoopFragmentWhole" mainLoop (LoopFragment'''duplicate-1 preLoop)
            #_"LoopFragmentWhole" postLoop (LoopFragment'''duplicate-1 preLoop)
        ]
            (ยง ass! preLoopBegin (LoopBeginNode''incrementSplits-1 preLoopBegin))
            (ยง ass! preLoopBegin (LoopBeginNode''incrementSplits-1 preLoopBegin))
            (ยง ass! preLoopBegin (LoopBeginNode''setPreLoop-1 preLoopBegin))
            (let [
                #_"LoopBeginNode" mainLoopBegin (LoopFragment''getDuplicatedNode-2 mainLoop, preLoopBegin)
            ]
                (ยง ass! mainLoopBegin (LoopBeginNode''setMainLoop-1 mainLoopBegin))
                (let [
                    #_"LoopBeginNode" postLoopBegin (LoopFragment''getDuplicatedNode-2 postLoop, preLoopBegin)
                ]
                    (ยง ass! postLoopBegin (LoopBeginNode''setPostLoop-1 postLoopBegin))

                    (let [
                        #_"EndNode" postEndNode (LoopTransformations'getBlockEndAfterLoopExit-1 postLoopBegin)
                        #_"AbstractMergeNode" postMergeNode (AbstractEndNode'''merge-1 postEndNode)
                        #_"LoopExitNode" postLoopExitNode (LoopBeginNode''getSingleLoopExit-1 postLoopBegin)
                    ]
                        ;; update the main loop phi initialization to carry from the pre loop
                        (doseq [#_"PhiNode" prePhiNode (AbstractMergeNode''phis-1 preLoopBegin)]
                            (PhiNode''setValueAt-3i (LoopFragment''getDuplicatedNode-2 mainLoop, prePhiNode), 0, prePhiNode)
                        )

                        (let [
                            #_"EndNode" mainEndNode (LoopTransformations'getBlockEndAfterLoopExit-1 mainLoopBegin)
                            #_"AbstractMergeNode" mainMergeNode (AbstractEndNode'''merge-1 mainEndNode)
                            #_"AbstractEndNode" postEntryNode (LoopBeginNode''forwardEnd-1 postLoopBegin)
                            ;; in the case of no Bounds tests, we just flow right into the main loop
                            #_"AbstractBeginNode" mainLandingNode (BeginNode'begin-1 postEntryNode)
                            #_"LoopExitNode" mainLoopExitNode (LoopBeginNode''getSingleLoopExit-1 mainLoopBegin)
                        ]
                            (ยง ass! mainLoopExitNode (FixedWithNextNode''setNext-2 mainLoopExitNode, mainLandingNode))
                            (ยง ass! preLoopExitNode (FixedWithNextNode''setNext-2 preLoopExitNode, (LoopBeginNode''forwardEnd-1 mainLoopBegin)))

                            ;; add and update any phi edges as per merge usage as needed and update usages
                            (LoopTransformations'processPreLoopPhis-3 _loop, mainLoop, postLoop)
                            (Node''clearSuccessors-1 (:predecessor continuationNode))
                            (ยง ass! postLoopExitNode (FixedWithNextNode''setNext-2 postLoopExitNode, continuationNode))
                            (LoopTransformations'cleanupMerge-2 postMergeNode, postLoopExitNode)
                            (LoopTransformations'cleanupMerge-2 mainMergeNode, mainLandingNode)

                            ;; change the preLoop to execute one iteration for now
                            (LoopTransformations'updateMainLoopLimit-3 preLimit, preIv, mainLoop)
                            (LoopTransformations'updatePreLoopLimit-3 preLimit, preIv, preCounted)
                            (ยง ass! preLoopBegin (LoopBeginNode''setLoopFrequency-2 preLoopBegin, 1))
                            (ยง ass! mainLoopBegin (LoopBeginNode''setLoopFrequency-2 mainLoopBegin, (max 0.0 (- (:loopFrequency mainLoopBegin) 2))))
                            (ยง ass! postLoopBegin (LoopBeginNode''setLoopFrequency-2 postLoopBegin, (max 0.0 (- (:loopFrequency postLoopBegin) 1))))

                            ;; the pre and post loops don't require safepoints at all
                            (doseq [#_"SafepointNode" safepoint (filter #(satisfies? SafepointNode %) (LoopFragment'''nodes-1 preLoop))]
                                (Graph''removeFixed-2 graph, safepoint)
                            )
                            (doseq [#_"SafepointNode" safepoint (filter #(satisfies? SafepointNode %) (LoopFragment'''nodes-1 postLoop))]
                                (Graph''removeFixed-2 graph, safepoint)
                            )
                            mainLoopBegin
                        )
                    )
                )
            )
        )
    )

    (defn #_"List<ControlSplitNode>" LoopTransformations'findUnswitchable-1 [#_"LoopEx" _loop]
        (let [
            [#_"ValueNode" invariantValue #_"List<ControlSplitNode>" controls]
                (loop-when [invariantValue nil controls nil #_"ISeq" s (seq (filter #(satisfies? IfNode %) (LoopFragment'''nodes-1 (LoopEx''whole-1 _loop))))] (some? s) => [invariantValue controls]
                    (let [
                        #_"IfNode" ifNode (first s)
                        [invariantValue controls]
                            (when (LoopEx''isOutsideLoop-2 _loop, (:logic ifNode)) => [invariantValue controls]
                                (if (nil? controls)
                                    (let [
                                        controls (ArrayList.)
                                    ]
                                        (#_"List" .add controls, ifNode)
                                        [(:logic ifNode) controls]
                                    )
                                    (do
                                        (when (= (:logic ifNode) invariantValue)
                                            (#_"List" .add controls, ifNode)
                                        )
                                        [invariantValue controls]
                                    )
                                )
                            )
                    ]
                        (recur invariantValue controls (next s))
                    )
                )
        ]
            (or controls
                (loop-when [#_"SwitchNode" firstSwitch nil invariantValue invariantValue controls controls #_"ISeq" s (seq (filter #(satisfies? SwitchNode %) (LoopFragment'''nodes-1 (LoopEx''whole-1 _loop))))] (some? s) => controls
                    (let [
                        #_"SwitchNode" switchNode (first s)
                        [firstSwitch invariantValue controls]
                            (when (and (< 1 (count (Node''successors-1 switchNode))) (LoopEx''isOutsideLoop-2 _loop, (:value switchNode))) => [firstSwitch invariantValue controls]
                                (if (nil? controls)
                                    (let [
                                        controls (ArrayList.)
                                    ]
                                        (#_"List" .add controls, switchNode)
                                        [switchNode (:value switchNode) controls]
                                    )
                                    (do
                                        (when (and (= (:value switchNode) invariantValue) (SwitchNode''structureEquals-2 firstSwitch, switchNode))
                                            ;; only collect switches which test the same values in the same order
                                            (#_"List" .add controls, switchNode)
                                        )
                                        [firstSwitch invariantValue controls]
                                    )
                                )
                            )
                    ]
                        (recur firstSwitch invariantValue controls (next s))
                    )
                )
            )
        )
    )

    (defn #_"boolean" LoopTransformations'isUnrollableLoop-1 [#_"LoopEx" _loop]
        (and (LoopEx''isCounted-1 _loop)
            (InductionVariable'''isConstantStride-1 (:iv (:counted _loop)))
            (empty? (:children (:loop _loop)))
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 _loop)
                #_"LogicNode" logic (:logic (:ifNode (:counted _loop)))
            ]
                (and (satisfies? CompareNode logic)
                    (not (= (:condition logic) CanonicalCondition'EQ))
                    (or (LoopBeginNode''isMainLoop-1 loopBegin) (LoopBeginNode''isSimpleLoop-1 loopBegin))
                    ;; Flow-less loops to partial unroll for now. 3 blocks corresponds to an if that either exits
                    ;; or continues the loop. There might be fixed and floating work within the loop as well.
                    (< (count (:blocks (:loop _loop))) 3)
                )
            )
        )
    )
)

(value-ns InputType
    ;;;
     ; Inputs that consume an actual value generated by the referenced node.
     ;;
    (ยง enum InputType'Value)
    ;;;
     ; Inputs that consume the memory state of the referenced node.
     ;;
    (ยง enum InputType'Memory)
    ;;;
     ; Inputs that reference a guard (guards, begin nodes).
     ;;
    (ยง enum InputType'Guard)
    ;;;
     ; Inputs that reference an anchor (begin nodes, value anchors).
     ;;
    (ยง enum InputType'Anchor)
)

(value-ns ReassociateMatch
    :ReassociateMatch'x
    :ReassociateMatch'y

    (defn #_"ValueNode" ReassociateMatch''getValue-2 [#_"ReassociateMatch" this, #_"BinaryNode" binary]
        (condp = this
            :ReassociateMatch'x (:x binary)
            :ReassociateMatch'y (:y binary)
        )
    )

    (defn #_"ValueNode" ReassociateMatch''getOtherValue-2 [#_"ReassociateMatch" this, #_"BinaryNode" binary]
        (condp = this
            :ReassociateMatch'x (:y binary)
            :ReassociateMatch'y (:x binary)
        )
    )
)

(value-ns DivRemOp
    (ยง enum DivRemOp'DIV)
    (ยง enum DivRemOp'REM)
)

(value-ns Signedness
    (ยง enum Signedness'SIGNED)
    (ยง enum Signedness'UNSIGNED)
)

(value-ns CompressionOp
    (ยง enum CompressionOp'Compress)
    (ยง enum CompressionOp'Uncompress)
)

;;;
 ; Denotes the compilation context in which an intrinsic is being parsed.
 ;;
(value-ns CompilationContext
    ;;;
     ; An intrinsic is being processed when parsing an invoke bytecode that calls the
     ; intrinsified method.
     ;;
    (ยง enum CompilationContext'INLINE_DURING_PARSING)
    ;;;
     ; An intrinsic is being processed when inlining an InvokeNode in an existing graph.
     ;;
    (ยง enum CompilationContext'INLINE_AFTER_PARSING)
    ;;;
     ; An intrinsic is the root of compilation.
     ;;
    (ยง enum CompilationContext'ROOT_COMPILATION)
)

(value-ns LoopType
    (ยง enum LoopType'SIMPLE_LOOP)
    (ยง enum LoopType'PRE_LOOP)
    (ยง enum LoopType'MAIN_LOOP)
    (ยง enum LoopType'POST_LOOP)
)

;;;
 ; The types of (write/read) barriers attached to stores.
 ;;
(value-ns BarrierType
    ;;;
     ; Primitive stores which do not necessitate barriers.
     ;;
    (ยง enum BarrierType'NONE)
    ;;;
     ; Array object stores which necessitate precise barriers.
     ;;
    (ยง enum BarrierType'PRECISE)
    ;;;
     ; Field object stores which necessitate imprecise barriers.
     ;;
    (ยง enum BarrierType'IMPRECISE)
)

;;;
 ; The lowering stages used in a standard Graal phase plan. Lowering is called 3 times,
 ; during every tier of compilation.
 ;;
(value-ns LoweringStage
    (ยง enum LoweringStage'HIGH_TIER)
    (ยง enum LoweringStage'MID_TIER)
    (ยง enum LoweringStage'LOW_TIER)
)

;;;
 ; Describes how much information is gathered when deoptimization triggers.
 ;
 ; This enum is Comparable and orders its element from highest priority to lowest priority.
 ;;
(value-ns GuardPriority (ยง implements Comparable #_"<GuardPriority>")
    (ยง enum GuardPriority'Speculation)
    (ยง enum GuardPriority'Profile)
    (ยง enum GuardPriority'None)

    (defn #_"boolean" GuardPriority'isHigherPriorityThan-2 [#_"GuardPriority" a, #_"GuardPriority" b]
        (neg? (#_"Comparable" .compareTo a, b))
    )

    (defn #_"boolean" GuardPriority'isLowerPriorityThan-2 [#_"GuardPriority" a, #_"GuardPriority" b]
        (pos? (#_"Comparable" .compareTo a, b))
    )

    (defn #_"GuardPriority" GuardPriority'highest-0 []
        GuardPriority'Speculation
    )
)

;;;
 ; The type of events sent to a NodeEventListener.
 ;;
(value-ns NodeEvent
    ;;;
     ; A node's input is changed.
     ;;
    (ยง enum NodeEvent'INPUT_CHANGED)
    ;;;
     ; A node's {@linkplain Node#usages() usages} count dropped to zero.
     ;;
    (ยง enum NodeEvent'ZERO_USAGES)
    ;;;
     ; A node was added to a graph.
     ;;
    (ยง enum NodeEvent'NODE_ADDED)
    ;;;
     ; A node was removed from the graph.
     ;;
    (ยง enum NodeEvent'NODE_REMOVED)
)

;;;
 ; The different stages of the compilation of a Graph regarding the status of {@link GuardNode guards},
 ; {@link DeoptimizingNode deoptimizations} and {@link FrameState framestates}.
 ; The stage of a graph progresses monotonously.
 ;;
(value-ns GuardsStage
    ;;;
     ; During this stage, there can be {@link FloatingNode floating} DeoptimizingNodes
     ; such as GuardNodes. New DeoptimizingNodes can be introduced without constraints.
     ; FrameState nodes are associated with StateSplit nodes.
     ;;
    (ยง enum GuardsStage'FLOATING_GUARDS)
    ;;;
     ; During this stage, all DeoptimizingNodes must be {@link FixedNode fixed},
     ; but new DeoptimizingNodes can still be introduced.
     ; FrameState nodes are still associated with StateSplit nodes.
     ;;
    (ยง enum GuardsStage'FIXED_DEOPTS)
    ;;;
     ; During this stage, all DeoptimizingNodes must be {@link FixedNode fixed}.
     ; New DeoptimizingNodes can not be introduced any more.
     ; FrameState nodes are now associated with DeoptimizingNode nodes.
     ;;
    (ยง enum GuardsStage'AFTER_FSA)

    (defn #_"boolean" GuardsStage'allowsFloatingGuards-1 [#_"GuardsStage" self]
        (= self GuardsStage'FLOATING_GUARDS)
    )

    (defn #_"boolean" GuardsStage'areFrameStatesAtDeopts-1 [#_"GuardsStage" self]
        (= self GuardsStage'AFTER_FSA)
    )

    (defn #_"boolean" GuardsStage'areFrameStatesAtSideEffects-1 [#_"GuardsStage" self]
        (not (GuardsStage'areFrameStatesAtDeopts-1 self))
    )

    (defn #_"boolean" GuardsStage'areDeoptsFixed-1 [#_"GuardsStage" self]
        (<= (GuardsStage''ordinal-1 GuardsStage'FIXED_DEOPTS) (GuardsStage''ordinal-1 self))
    )
)

;;;
 ; Helper class that is used to keep all stamp-related operations in one place.
 ;;
(value-ns StampTool
    #_unused
    (defn #_"Stamp" StampTool'meet-1 [#_"ValueNode*" values]
        (or (StampTool'meetOrNull-2 values, nil) VoidStamp'instance)
    )

    ;;;
     ; Meet a collection of ValueNodes optionally excluding {@code self}. If no values
     ; are encountered then return nil.
     ;;
    (defn #_"Stamp" StampTool'meetOrNull-2 [#_"ValueNode*" values, #_"ValueNode" self]
        (loop-when [#_"Stamp" stamp nil #_"ISeq" s (seq values)] (some? s) => stamp
            (let [
                #_"ValueNode" value (first s)
                stamp
                    (when-not (= value self) => stamp
                        (if (some? stamp) (Stamp'''meet-2 stamp, (:stamp value)) (:stamp value))
                    )
            ]
                (recur stamp (next s))
            )
        )
    )

    ;;;
     ; Compute the stamp resulting from the unsigned comparison being true.
     ;
     ; @return nil if it can't be true or if nothing useful can be encoded
     ;;
    #_unused
    (defn #_"Stamp" StampTool'unsignedCompare-2 [#_"Stamp" a, #_"Stamp" b]
        (cond
            (and (Stamp'''isUnrestricted-1 a) (Stamp'''isUnrestricted-1 b))
                ;; don't know anything
                nil
            ;; c <| n, where c is a constant and n is known to be positive
            (= (:lowerBound a) (:upperBound a))
                (when (IntegerStamp''isPositive-1 b)
                    (cond
                        ;; constant is MAX_VALUE which must fail
                        (= (:lowerBound a) (dec (<< 1 (:bits a)))) nil
                        ;; test will fail - return illegalStamp instead?
                        (<= (:lowerBound a) (:lowerBound b)) nil
                        ;; when test succeeds, n is at greater than c, so the bounds are [c+1..-n.upperBound]
                        :else (StampFactory'forInteger-3i (:bits a), (inc (:lowerBound a)), (:upperBound b))
                    )
                )
            ;; n <| c, where c is a strictly positive constant
            (and (= (:lowerBound b) (:upperBound b)) (IntegerStamp''isStrictlyPositive-1 b))
                ;; the test proves that n is positive and less than c, [0..c-1]
                (StampFactory'forInteger-3i (:bits b), 0, (dec (:lowerBound b)))
        )
    )

    (defn #_"Stamp" StampTool'stampForLeadingZeros-1 [#_"IntegerStamp" stamp]
        (let [
            #_"long" mask (CodeUtil/mask (:bits stamp))
            ;; Don't count zeros from the mask in the result.
            #_"int" adjust (Long/numberOfLeadingZeros mask)
            #_"int" lower (- (Long/numberOfLeadingZeros (& (:upMask stamp) mask)) adjust)
            #_"int" upper (- (Long/numberOfLeadingZeros (& (:downMask stamp) mask)) adjust)
        ]
            (StampFactory'forInteger-3k JavaKind/Int, lower, upper)
        )
    )

    (defn #_"Stamp" StampTool'stampForTrailingZeros-1 [#_"IntegerStamp" stamp]
        (let [
            #_"long" mask (CodeUtil/mask (:bits stamp))
            #_"int" lower (Long/numberOfTrailingZeros (& (:upMask stamp) mask))
            #_"int" upper (Long/numberOfTrailingZeros (& (:downMask stamp) mask))
        ]
            (StampFactory'forInteger-3k JavaKind/Int, lower, upper)
        )
    )

    ;;;
     ; Checks whether this Stamp represents a {@linkplain Stamp#hasValues() legal} pointer stamp
     ; whose values are known to be always nil.
     ;;
    (defn #_"boolean" StampTool'isPointerAlwaysNull-1 [#_"Stamp" stamp]
        (and (satisfies? AbstractPointerStamp stamp) (Stamp'''hasValues-1 stamp)
            (:always-nil? stamp)
        )
    )

    ;;;
     ; Checks whether this Stamp represents a {@linkplain Stamp#hasValues() legal} pointer stamp
     ; whose values are known to be never nil.
     ;;
    (defn #_"boolean" StampTool'isPointerNeverNull-1 [#_"Stamp" stamp]
        (and (satisfies? AbstractPointerStamp stamp)
            (:never-nil? stamp)
        )
    )

    ;;;
     ; Returns the Java type this Stamp has if it is a {@linkplain Stamp#hasValues() legal} Object stamp.
     ;;
    (defn #_"TypeReference" StampTool'typeReferenceOrNull-1 [#_"Stamp" stamp]
        (when (and (satisfies? AbstractObjectStamp stamp) (Stamp'''hasValues-1 stamp))
            (if (AbstractObjectStamp''isExactType-1 stamp)
                (TypeReference'createExactTrusted-1 (:type stamp))
                (TypeReference'createTrusted-1 (:type stamp))
            )
        )
    )

    (defn #_"ResolvedJavaType" StampTool'typeOrNull-1 [#_"Stamp" stamp]
        (let [
            #_"TypeReference" type (StampTool'typeReferenceOrNull-1 stamp)
        ]
            (when (some? type) (:type type))
        )
    )

    #_unused
    (defn #_"ResolvedJavaType" StampTool'objectTypeOrNull-1 [#_"Stamp" stamp]
        (when (and (satisfies? AbstractObjectStamp stamp) (Stamp'''hasValues-1 stamp))
            (or (:type stamp)
                (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Object)
            )
        )
    )

    ;;;
     ; Checks whether this Stamp represents a {@linkplain Stamp#hasValues() legal} Object stamp whose Java type
     ; is known exactly. If this method returns true, then the Java type returned by #typeReferenceOrNull(Stamp)
     ; is the only concrete dynamic/runtime Java type possible for values of this stamp.
     ;;
    #_unused
    (defn #_"boolean" StampTool'isExactType-1 [#_"Stamp" stamp]
        (and (satisfies? AbstractObjectStamp stamp) (Stamp'''hasValues-1 stamp)
            (AbstractObjectStamp''isExactType-1 stamp)
        )
    )
)

(value-ns GraphUtil
    (defn- #_"void" GraphUtil'fixSurvivingAffectedMerges-2 [#_"{Node}" nodes, #_"{AbstractMergeNode [AbstractEndNode]}" merges]
        (doseq [[#_"AbstractMergeNode" merge #_"[AbstractEndNode]" ends] merges]
            (doseq [#_"AbstractEndNode" end ends]
                (AbstractMergeNode''removeEnd-2 merge, end)
            )
            (when (= (AbstractMergeNode'''phiPredecessorCount-1 merge) 1)
                (if (satisfies? LoopBeginNode merge)
                    (do
                        (doseq [#_"LoopExitNode" exit (ยง snap (LoopBeginNode''loopExits-1 merge))]
                            (when (contains? nodes exit)
                                ;; disconnect from loop begin so that reduceDegenerateLoopBegin doesn't transform it into a new beginNode
                                (Node''replaceFirstInput-3 exit, merge, nil)
                            )
                        )
                        (ยง ass! (:graph merge) (Graph''reduceDegenerateLoopBegin-2 (:graph merge), merge))
                    )
                    (Graph''reduceTrivialMerge-2 (:graph merge), merge)
                )
            )
        )
        nil
    )

    (defn- #_"{Node}" GraphUtil'markFixedNodes-1 [#_"FixedNode" fixed]
        (let [
            [#_"{Node}" nodes #_"{AbstractMergeNode [AbstractEndNode]}" merges]
                (loop-when [nodes #{} merges {} #_"Node*" stack (list fixed)] (seq stack) => [nodes merges]
                    (let [
                        [#_"Node" node & stack] stack
                        nodes (conj nodes node)
                        merges
                            (when (satisfies? AbstractMergeNode node) => merges
                                (dissoc merges node)
                            )
                        [node nodes]
                            (loop-when [node node nodes nodes] (satisfies? FixedWithNextNode node) => [node nodes]
                                (let [
                                    node (:next node)
                                    nodes
                                        (when (some? node) => nodes
                                            (conj nodes node)
                                        )
                                ]
                                    (recur node nodes)
                                )
                            )
                        [merges stack]
                            (condp satisfies? node
                                ControlSplitNode
                                    [merges (into stack (Node''successors-1 node))]
                                AbstractEndNode
                                    (let [
                                        #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 node)
                                    ]
                                        (when (some? merge) => [merges stack]
                                            (let [
                                                [stack done?]
                                                    (when (satisfies? LoopBeginNode merge) => [stack false]
                                                        (if (= (LoopBeginNode''forwardEnd-1 merge) node)
                                                            [(cons merge stack) true]
                                                            [stack (contains? nodes merge)]
                                                        )
                                                    )
                                            ]
                                                (when-not done? => [merges stack]
                                                    (let [
                                                        merges (update merges merge #(conj (vec %) node))
                                                        stack
                                                            (when (and (not (satisfies? LoopEndNode node)) (= (count (get merges merge)) (AbstractMergeNode''forwardEndCount-1 merge))) => stack
                                                                ;; all this merge's forward ends are marked: it needs to be killed
                                                                (cons merge stack)
                                                            )
                                                    ]
                                                        [merges stack]
                                                    )
                                                )
                                            )
                                        )
                                    )
                                [merges stack]
                            )
                    ]
                        (recur nodes merges stack)
                    )
                )
        ]
            (GraphUtil'fixSurvivingAffectedMerges-2 nodes, merges)
            nodes
        )
    )

    (defn- #_"{Node}" GraphUtil'markUsages-1 [#_"{Node}" nodes]
        (loop-when [nodes nodes #_"Node*" stack (reverse nodes)] (seq stack) => nodes
            (let [
                [#_"Node" marked & stack] stack
                [nodes stack]
                    (loop-when [nodes nodes stack stack #_"ISeq" s (seq (:nodeUsages marked))] (some? s) => [nodes stack]
                        (let [
                            #_"Node" usage (first s)
                            [nodes stack]
                                (when-not (contains? nodes usage) => [nodes stack]
                                    [(conj nodes usage) (cons usage stack)]
                                )
                        ]
                            (recur nodes stack (next s))
                        )
                    )
            ]
                (recur nodes stack)
            )
        )
    )

    (defn #_"void" GraphUtil'killCFG-1 [#_"FixedNode" fixed]
        (let [
            ;; detach this node from CFG
            _ (Node''replaceAtPredecessor-2 fixed, nil)
            #_"{Node}" nodes (GraphUtil'markFixedNodes-1 fixed)
            ;; mark non-fixed nodes
            nodes (GraphUtil'markUsages-1 nodes)
        ]
            ;; detach marked nodes from non-marked nodes
            (doseq [#_"Node" node nodes #_"Node" input (Node''inputs-1 node)]
                (when-not (contains? nodes input)
                    (Node''replaceFirstInput-3 node, input, nil)
                    (GraphUtil'tryKillUnused-1 input)
                )
            )
            ;; kill marked nodes
            (run! Node''markDeleted-1 (filter Node''isAlive-1 nodes))
        )
        nil
    )

    (defn #_"boolean" GraphUtil'isFloatingNode-1 [#_"Node" node]
        (not (satisfies? FixedNode node))
    )

    (defn #_"void" GraphUtil'killWithUnusedFloatingInputs-1 [#_"Node" node]
        (GraphUtil'killWithUnusedFloatingInputs-2 node, false)
        nil
    )

    (defn #_"void" GraphUtil'killWithUnusedFloatingInputs-2 [#_"Node" node, #_"boolean" mayKillGuard]
        (Node''markDeleted-1 node)
        (doseq [#_"Node" in (Node''inputs-1 node)]
            (when (Node''isAlive-1 in)
                (ยง ass! in (Node''removeUsage-2 in, node))
                (when (Node''hasNoUsages-1 in)
                    (Node''maybeNotifyZeroUsages-2 node, in)
                )
                (when (GraphUtil'isFloatingNode-1 in)
                    (cond
                        (Node''hasNoUsages-1 in)
                            (if (satisfies? GuardNode in)
                                nil ;; Guard nodes are only killed if their anchor dies.
                                (GraphUtil'killWithUnusedFloatingInputs-1 in)
                            )
                        (satisfies? PhiNode in)
                            (loop [#_"ISeq" s (seq (:nodeUsages in))]
                                (if (some? s)
                                    (when (= (first s) in)
                                        (recur (next s))
                                    )
                                    (do
                                        (ยง ass! in (Node''replaceAtUsages-2 in, nil))
                                        (GraphUtil'killWithUnusedFloatingInputs-1 in)
                                    )
                                )
                            )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" GraphUtil'removeFixedWithUnusedInputs-1 [#_"FixedWithNextNode" fixed]
        (when (satisfies? StateSplit fixed)
            (let [
                #_"FrameState" state (:stateAfter fixed)
            ]
                (when (some? state)
                    (StateSplit'''setStateAfter-2 fixed, nil)
                    (when (Node''hasNoUsages-1 state)
                        (GraphUtil'killWithUnusedFloatingInputs-1 state)
                    )
                )
            )
        )
        (GraphUtil'unlinkFixedNode-1 fixed)
        (GraphUtil'killWithUnusedFloatingInputs-1 fixed)
        nil
    )

    (defn #_"void" GraphUtil'unlinkFixedNode-1 [#_"FixedWithNextNode" fixed]
        (let [
            #_"FixedNode" _next (:next fixed)
        ]
            (ยง ass! fixed (FixedWithNextNode''setNext-2 fixed, nil))
            (Node''replaceAtPredecessor-2 fixed, _next)
        )
        nil
    )

    (defn #_"void" GraphUtil'checkRedundantPhi-1 [#_"PhiNode" phiNode]
        (when-not (or (Node''isDeleted-1 phiNode) (= (PhiNode''valueCount-1 phiNode) 1))
            (let [
                #_"ValueNode" singleValue (PhiNode''singleValueOrThis-1 phiNode)
            ]
                (when-not (= singleValue phiNode)
                    (ยง ass! phiNode (Node''replaceAtUsagesAndDelete-2 phiNode, singleValue))
                    (doseq [#_"PhiNode" phi (ยง snap (filter #(satisfies? PhiNode %) (:nodeUsages phiNode)))]
                        (GraphUtil'checkRedundantPhi-1 phi)
                    )
                    (doseq [#_"ProxyNode" proxy (ยง snap (filter #(satisfies? ProxyNode %) (:nodeUsages phiNode)))]
                        (GraphUtil'checkRedundantProxy-1 proxy)
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" GraphUtil'checkRedundantProxy-1 [#_"ProxyNode" vpn]
        (when-not (Node''isDeleted-1 vpn)
            (let [
                #_"AbstractBeginNode" proxyPoint (:loopExit vpn)
            ]
                (when (satisfies? LoopExitNode proxyPoint)
                    (let [
                        #_"LoopBeginNode" loopBegin (:loopBegin proxyPoint)
                        #_"Node" vpnValue (:value vpn)
                    ]
                        (loop-when [#_"ISeq" s (seq (:values (:stateAfter loopBegin)))] (some? s)
                            (let [
                                #_"ValueNode" v (first s)
                                v
                                    (when (AbstractMergeNode''isPhiAtMerge-2 loopBegin, v) => v
                                        (PhiNode''valueAt-2n v, (LoopBeginNode''forwardEnd-1 loopBegin))
                                    )
                            ]
                                (when (= vpnValue v) => (recur (next s))
                                    (ยง ass! vpn (Node''replaceAtUsagesAndDelete-2 vpn, vpnValue))
                                    (doseq [#_"PhiNode" phi (ยง snap (filter #(satisfies? PhiNode %) (:nodeUsages vpn)))]
                                        (GraphUtil'checkRedundantPhi-1 phi)
                                    )
                                    (doseq [#_"ProxyNode" proxy (ยง snap (filter #(satisfies? ProxyNode %) (:nodeUsages vpn)))]
                                        (GraphUtil'checkRedundantProxy-1 proxy)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" GraphUtil'normalizeLoopBegin-1 [#_"LoopBeginNode" begin]
        ;; Delete unnecessary loop phi functions, i.e. phi functions where all inputs are either the same or the phi itself.
        (doseq [#_"PhiNode" phi (ยง snap (AbstractMergeNode''phis-1 begin))]
            (GraphUtil'checkRedundantPhi-1 phi)
        )
        (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 begin)]
            (doseq [#_"ProxyNode" vpn (ยง snap (LoopExitNode''proxies-1 exit))]
                (GraphUtil'checkRedundantProxy-1 vpn)
            )
        )
        nil
    )

    ;;;
     ; Remove loop header without loop ends. This can happen with degenerated loops like this one:
     ;
     ; for ( ; ; ) {
     ;     try {
     ;         break;
     ;     } catch (UnresolvedException iioe) {
     ;     }
     ; }
     ;;
    (defn #_"Graph" GraphUtil'normalizeLoops-1 [#_"Graph" graph]
        (let [
            #_"boolean" removed?
                (loop-when [removed? false #_"ISeq" s (seq (Graph''getNodes-2 graph, LoopBeginNode))] (some? s) => removed?
                    (let [
                        #_"LoopBeginNode" begin (first s)
                        removed?
                            (if (empty? (LoopBeginNode''loopEnds-1 begin))
                                (do
                                    (ยง ass! graph (Graph''reduceDegenerateLoopBegin-2 graph, begin))
                                    true
                                )
                                (do
                                    (GraphUtil'normalizeLoopBegin-1 begin)
                                    removed?
                                )
                            )
                    ]
                        (recur removed? (next s))
                    )
                )
        ]
            (when removed?
                ;; Removing a degenerated loop can make non-loop phi functions unnecessary. Therefore,
                ;; we re-check all phi functions and remove redundant ones.
                (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                    (when (satisfies? PhiNode node)
                        (GraphUtil'checkRedundantPhi-1 node)
                    )
                )
            )
            graph
        )
    )

    ;;;
     ; Gets the original value by iterating through all {@link ValueProxy ValueProxies}.
     ;
     ; @param value the start value.
     ; @return the first non-proxy value encountered
     ;;
    (defn #_"ValueNode" GraphUtil'unproxify-1n [#_"ValueNode" value]
        (if (satisfies? ValueProxy value) (GraphUtil'unproxify-1p value) value)
    )

    ;;;
     ; Gets the original value by iterating through all {@link ValueProxy ValueProxies}.
     ;
     ; @param value the start value proxy.
     ; @return the first non-proxy value encountered
     ;;
    (defn #_"ValueNode" GraphUtil'unproxify-1p [#_"ValueProxy" value]
        (when (some? value)
            (loop-when-recur [#_"ValueNode" n (Proxy'''getOriginalNode-1 value)] (satisfies? ValueProxy n) [(Proxy'''getOriginalNode-1 n)] => n)
        )
    )

    (defn #_"ValueNode" GraphUtil'skipPi-1 [#_"ValueNode" node]
        (loop-when-recur node (satisfies? PiNode node) (Proxy'''getOriginalNode-1 node) => node)
    )

    (defn #_"ValueNode" GraphUtil'skipPiWhileNonNull-1 [#_"ValueNode" node]
        (loop-when node (satisfies? PiNode node) => node
            (recur-if (:never-nil? (:stamp (Proxy'''getOriginalNode-1 node))) (Proxy'''getOriginalNode-1 node) => node)
        )
    )

    ;;;
     ; Looks for an ArrayLengthProvider while iterating through all {@link ValueProxy ValueProxies}.
     ;
     ; @param value The start value.
     ; @return the array length if one was found, or nil otherwise
     ;;
    (defn #_"ValueNode" GraphUtil'arrayLength-1 [#_"ValueNode" value]
        (loop [value value]
            (when (satisfies? ArrayLengthProvider value)
                (let [
                    #_"ValueNode" length (ArrayLengthProvider'''length-1 value)
                ]
                    (when (some? length)
                        (ยง return length)
                    )
                )
            )
            (when (satisfies? ValueProxy value)
                (recur (Proxy'''getOriginalNode-1 value))
            )
        )
    )

    (defn- #_"ValueNode" GraphUtil'originalValueForProxy-1 [#_"ValueNode" value]
        (loop-when-recur value (satisfies? LimitedValueProxy value) (Proxy'''getOriginalNode-1 value) => value)
    )

    ;;;
     ; Handling complicated nestings of phi functions. We reduce them recursively using a temporary map
     ; of visited nodes to avoid endless recursion of cycles.
     ;;
    (defn- #_"ValueNode" GraphUtil'originalValueForComplicatedPhi-2 [#_"PhiNode" phi, #_"NodeBitMap" visited]
        ;; Else found a phi function that was already seen. Either a cycle, or just a second phi input
        ;; to a path we have already processed.
        (when-not (NodeBitMap''isMarked-2n visited, phi)
            (NodeBitMap''mark-2 visited, phi)

            (loop-when [#_"ValueNode" prior nil #_"int" i 0] (< i (PhiNode''valueCount-1 phi)) => prior
                (let [
                    #_"ValueNode" value (GraphUtil'originalValueForProxy-1 (PhiNode''valueAt-2i phi, i))
                    value
                        (when (satisfies? PhiNode value) => value
                            ;; Recursively process a phi function input.
                            (GraphUtil'originalValueForComplicatedPhi-2 value, visited)
                        )
                ]
                    (cond
                        ;; Cycle to a phi function that was already seen. We can ignore this input.
                        (nil? value)       (recur prior (inc i))
                        ;; The first input.
                        (nil? prior)       (recur value (inc i))
                        ;; Another input that is different from the first input. Since we already
                        ;; recursively looked through other phi functions, we now know that this phi
                        ;; function cannot be reduced any further, hence it is the original value.
                        (not= value prior) phi
                        :else              (recur prior (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; Tries to find an original value of the given node by traversing through proxies and
     ; unambiguous phis. Note that this method will perform an exhaustive search through phis. It is
     ; intended to be used during graph building, when phi nodes aren't yet canonicalized.
     ;
     ; @param value The node whose original value should be determined.
     ; @return the original value (which might be the input value itself)
     ;;
    (defn #_"ValueNode" GraphUtil'originalValue-1 [#_"ValueNode" value]
        ;; The very simple case: look through proxies.
        (loop-when [#_"ValueNode" node (GraphUtil'originalValueForProxy-1 value)] (satisfies? PhiNode node) => node ;; We reached a "normal" node, which is the original value.
            ;; We found a phi function. Check if we can analyze it without allocating temporary data structures.
            (let [
                #_"ValueNode" phiSingleValue
                    (loop-when [phiSingleValue nil #_"int" i 0] (< i (PhiNode''valueCount-1 node)) => phiSingleValue
                        (let [
                            #_"ValueNode" phiCurValue (GraphUtil'originalValueForProxy-1 (PhiNode''valueAt-2i node, i))
                            phiSingleValue
                                (cond
                                    (= phiCurValue node)           phiSingleValue ;; Simple cycle, we can ignore the input value.
                                    (nil? phiSingleValue)          phiCurValue    ;; The first input.
                                    (= phiSingleValue phiCurValue) phiSingleValue
                                    :else
                                        ;; Another input that is different from the first input.
                                        (if (or (satisfies? PhiNode phiSingleValue) (satisfies? PhiNode phiCurValue))
                                            ;; We have two different input values for the phi function, and at least one
                                            ;; of the inputs is another phi function. We need to do a complicated
                                            ;; exhaustive check.
                                            (ยง return (GraphUtil'originalValueForComplicatedPhi-2 node, (NodeBitMap'new-1 (:graph value))))
                                            ;; We have two different input values for the phi function, but none of them
                                            ;; is another phi function. This phi function cannot be reduce any further,
                                            ;; so the phi function is the original value.
                                            (ยง return node)
                                        )
                                )
                        ]
                            (recur phiSingleValue (inc i))
                        )
                    )
            ]
                ;; Successfully reduced the phi function to a single input value. The single input value
                ;; can itself be a phi function again, so we might take another loop iteration.
                (recur phiSingleValue)
            )
        )
    )

    (defn #_"boolean" GraphUtil'tryKillUnused-1 [#_"Node" node]
        (and (Node''isAlive-1 node) (GraphUtil'isFloatingNode-1 node) (Node''hasNoUsages-1 node) (not (satisfies? GuardNode node))
            (do
                (GraphUtil'killWithUnusedFloatingInputs-1 node)
                true
            )
        )
    )
)

(value-ns Optionality
    (ยง enum Optionality'Optional)
    (ยง enum Optionality'Required)
)

(value-ns InliningUtil
    ;;;
     ; @return nil iff the check succeeds, otherwise a (non-nil) descriptive message
     ;;
    (defn #_"String" InliningUtil'checkInvokeConditions-1 [#_"InvokeNode" invoke]
        (cond
            (or (nil? (:predecessor invoke)) (not (Node''isAlive-1 invoke))) "the invoke is dead code"
            (not (satisfies? MethodCallTargetNode (:callTarget invoke)))     "the invoke has already been lowered, or has been created as a low-level node"
            :else
                (let [
                    #_"MethodCallTargetNode" callTarget (:callTarget invoke)
                ]
                    (cond
                        (nil? (:targetMethod callTarget)) "target method is nil"
                        (not (:useForInlining invoke))    "the invoke is marked to be not used for inlining"
                        :else
                            (let [
                                #_"ValueNode" receiver (MethodCallTargetNode''receiver-1 callTarget)
                            ]
                                (when (and (some? receiver) (satisfies? ConstantNode receiver) (ValueNode''isNullConstant-1 receiver))
                                    "receiver is nil"
                                )
                            )
                    )
                )
        )
    )

    (defn- #_"void" InliningUtil'fixFrameStates-3 [#_"Graph" graph, #_"MergeNode" originalMerge, #_"PhiNode" returnPhi]
        ;; It is possible that some of the frame states that came from AFTER_BCI reference a Phi node
        ;; that was created to merge multiple returns. This can create cycles (see GR-3949 and GR-3957).
        ;; To detect this, we follow the control paths starting from the merge node,
        ;; split the Phi node inputs at merges and assign the proper input to each frame state.
        (let [
            #_"NodeMap<Node>" seen (NodeMap'new-1g graph)
            #_"ArrayDeque<Node>" workList (ArrayDeque.)
            #_"ArrayDeque<ValueNode>" valueList (ArrayDeque.)
        ]
            (#_"ArrayDeque" .push workList, originalMerge)
            (#_"ArrayDeque" .push valueList, returnPhi)
            (loop-when-recur [] (not (#_"ArrayDeque" .isEmpty workList)) []
                (let [
                    #_"Node" node (#_"ArrayDeque" .pop workList)
                    #_"ValueNode" currentValue (#_"ArrayDeque" .pop valueList)
                ]
                    (when-not (contains? seen node)
                        (#_"Map" .put seen, node, node)
                        (when (and (satisfies? StateSplit node) (not= node originalMerge))
                            (let [
                                #_"FrameState" state (:stateAfter node)
                            ]
                                (when (and (some? state) (#_"List" .contains (:values state), returnPhi))
                                    (let [
                                        #_"FrameState" duplicate (FrameState''duplicate-1 state)
                                    ]
                                        (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq (:values state))] (some? s) [(inc i) (next s)]
                                            (when (= (first s) returnPhi)
                                                (#_"List" .set (:values duplicate), i, currentValue)
                                            )
                                        )
                                        (StateSplit'''setStateAfter-2 node, duplicate)
                                        (GraphUtil'tryKillUnused-1 state)
                                    )
                                )
                            )
                        )
                        (cond
                            (satisfies? AbstractMergeNode node)
                                (doseq [#_"EndNode" pred (Node'''cfgPredecessors-1 node)]
                                    (let [
                                        #_"ValueNode" newValue
                                            (when (AbstractMergeNode''isPhiAtMerge-2 node, currentValue) => currentValue
                                                (PhiNode''valueAt-2n currentValue, pred)
                                            )
                                    ]
                                        (#_"ArrayDeque" .push workList, pred)
                                        (#_"ArrayDeque" .push valueList, newValue)
                                    )
                                )
                            (some? (:predecessor node))
                                (do
                                    (#_"ArrayDeque" .push workList, (:predecessor node))
                                    (#_"ArrayDeque" .push valueList, currentValue)
                                )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"ValueNode" InliningUtil'finishInlining-5 [#_"InvokeNode" invoke, #_"Graph" graph, #_"FixedNode" firstNode, #_"List<ReturnNode>" returnNodes, #_"Graph" inlineGraph]
        (let [
            #_"FixedNode" invokeNode invoke
            #_"FrameState" stateAfter (:stateAfter invoke)
        ]
            (Node''replaceAtPredecessor-2 invokeNode, firstNode)

            (if (empty? returnNodes)
                (do
                    (ยง ass! invokeNode (Node''replaceAtUsages-2 invokeNode, nil))
                    (GraphUtil'killCFG-1 (:next invoke))
                    nil
                )
                (let [
                    #_"FixedNode" n (:next invoke)
                ]
                    (ยง ass! invoke (FixedWithNextNode''setNext-2 invoke, nil))
                    (if (= (count returnNodes) 1)
                        (let [
                            #_"ReturnNode" returnNode (nth returnNodes 0)
                            returnValue (:result returnNode)
                        ]
                            (ยง ass! invokeNode (Node''replaceAtUsages-2 invokeNode, returnValue))
                            (ยง ass! returnNode (Node''replaceAndDelete-2 returnNode, n))
                            returnValue
                        )
                        (let [
                            #_"MergeNode" merge (Graph''add-2 graph, (MergeNode'new-0))
                        ]
                            (StateSplit'''setStateAfter-2 merge, stateAfter)
                            (let [
                                returnValue (ValueMergeUtil'mergeReturns-2 merge, returnNodes)
                            ]
                                (ยง ass! invokeNode (Node''replaceAtUsages-2 invokeNode, returnValue))
                                (when (AbstractMergeNode''isPhiAtMerge-2 merge, returnValue)
                                    (InliningUtil'fixFrameStates-3 graph, merge, (ยง cast #_"PhiNode" returnValue))
                                )
                                (ยง ass! merge (FixedWithNextNode''setNext-2 merge, n))
                                returnValue
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Performs an actual inlining, thereby replacing the given invoke with the given {@code inlineGraph}.
     ;
     ; @param invoke the invoke that will be replaced
     ; @param inlineGraph the graph that the invoke will be replaced with
     ; @param receiverNullCheck true if a nil-check needs to be generated for non-static inlinings,
     ;            false if no such check is required
     ; @param inlineeMethod the actual method being inlined. Maybe be nil for snippets.
     ;;
    (defn #_"void" InliningUtil'inline-4 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"boolean" receiverNullCheck, #_"ResolvedJavaMethod" inlineeMethod]
        (let [
            #_"FixedNode" invokeNode invoke
            #_"Graph" graph (:graph invokeNode)
            #_"NodeInputList<ValueNode>" parameters (:arguments (:callTarget invoke))
        ]
            (when (and receiverNullCheck (not (MethodCallTargetNode''isStatic-1 (:callTarget invoke))))
                (InliningUtil'nonNullReceiver-1 invoke)
            )

            (let [
                #_"ArrayList<Node>" nodes (ArrayList.)
                #_"ArrayList<ReturnNode>" returnNodes (ArrayList.)
                #_"ArrayList<InvokeNode>" partialIntrinsicExits (ArrayList.)
                #_"StartNode" start (:start inlineGraph)
                #_"FixedNode" firstCFGNode (:next start)
            ]
                (when (some? firstCFGNode) => (throw (IllegalStateException. (str "Inlined graph is in invalid state: " inlineGraph)))
                    (doseq [#_"Node" node (Graph''getNodes-1 inlineGraph)]
                        (when-not (or (= node start) (and (= node (:stateAfter start)) (Node''hasExactlyOneUsage-1 node)) (satisfies? ParameterNode node))
                            (#_"ArrayList" .add nodes, node)
                            (condp satisfies? node
                                ReturnNode
                                    (#_"ArrayList" .add returnNodes, node)
                                InvokeNode
                                    (when (= (:bci node) BytecodeFrame/UNKNOWN_BCI)
                                        (#_"ArrayList" .add partialIntrinsicExits, node)
                                    )
                                nil
                            )
                        )
                    )

                    (let [
                        #_"AbstractBeginNode" prevBegin (AbstractBeginNode'prevBegin-1 invokeNode)
                        #_"DuplicationReplacement" localReplacement
                            (reify DuplicationReplacement
                                (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" _, #_"Node" original]
                                    (cond
                                        (satisfies? ParameterNode original) (nth parameters (AbstractLocalNode''index-1 original))
                                        (= original start)                  prevBegin
                                        :else                               original
                                    )
                                )
                            )
                        ;; Instead, attach the inlining log of the child graph to the current inlining log.
                        #_"EconomicMap<Node, Node>" duplicates (Graph''addDuplicates-5r graph, nodes, inlineGraph, (Graph''getNodeCount-1 inlineGraph), localReplacement)
                        #_"FrameState" stateAfter (:stateAfter invoke)
                    ]
                        (when (some? stateAfter)
                            (InliningUtil'processFrameStates-4 invoke, inlineGraph, duplicates, (< 1 (count returnNodes)))
                            (when-not (zero? (FrameState''nestedLockDepth-1 stateAfter))
                                (doseq [#_"MonitorIdNode" original (Graph''getNodes-2 inlineGraph, MonitorIdNode)]
                                    (InliningUtil'processMonitorId-2 (:stateAfter invoke), (get duplicates original))
                                )
                            )
                        )

                        (let [
                            firstCFGNode (get duplicates firstCFGNode)
                        ]
                            (dotimes [#_"int" i (count returnNodes)]
                                (#_"ArrayList" .set returnNodes, i, (get duplicates (nth returnNodes i)))
                            )
                            (doseq [#_"InvokeNode" exit partialIntrinsicExits]
                                ;; A partial intrinsic exit must be replaced with a call to the intrinsified method.
                                (InvokeNode''intrinsify-2 (get duplicates exit), (Graph''add-2 graph, (InvokeNode'new-2 (:callTarget invoke), (:bci invoke))))
                            )
                            (InliningUtil'finishInlining-5 invoke, graph, firstCFGNode, returnNodes, inlineGraph)
                            (GraphUtil'killCFG-1 invokeNode)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Inline {@code inlineGraph} into the current replacing the InvokeNode and return the set of
     ; nodes which should be canonicalized. The set should only contain nodes which modified by the
     ; inlining since the current graph and {@code inlineGraph} are expected to already be canonical.
     ;
     ; @return the set of nodes to canonicalize
     ;;
    ; @SuppressWarnings("try")
    (defn #_"EconomicSet<Node>" InliningUtil'inlineForCanonicalization-4 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"boolean" receiverNullCheck, #_"ResolvedJavaMethod" inlineeMethod]
        (let [
            #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
        ]
            ;; This code assumes that Graph.addDuplicates doesn't trigger the NodeEventListener to track
            ;; only nodes which were modified into the process of inlining the graph into the current graph.
            (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 (:graph invoke), listener)])
                (InliningUtil'inline-4 invoke, inlineGraph, receiverNullCheck, inlineeMethod)
            )
            (:nodes listener)
        )
    )

    (defn #_"void" InliningUtil'processMonitorId-2 [#_"FrameState" stateAfter, #_"MonitorIdNode" monitorIdNode]
        (when (some? stateAfter)
            (ยง ass! monitorIdNode (MonitorIdNode''setLockDepth-2 monitorIdNode, (+ (:lockDepth monitorIdNode) (FrameState''nestedLockDepth-1 stateAfter))))
        )
        nil
    )

    (defn #_"void" InliningUtil'processFrameStates-4 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"EconomicMap<Node, Node>" duplicates, #_"boolean" alwaysDuplicateStateAfter]
        (let [
            #_"FrameState" stateAtReturn (:stateAfter invoke)
            #_"JavaKind" invokeReturnKind (ValueNode''getStackKind-1 invoke)
            #_"EconomicMap<Node, Node>" replacements (EconomicMap/create)
            #_"FrameState" outerFrameState
                (loop-when [outerFrameState nil #_"ISeq" s (seq (Graph''getNodes-2 inlineGraph, FrameState))] (some? s) => outerFrameState
                    (let [
                        #_"FrameState" frameState (get duplicates (first s))
                        outerFrameState
                            (when (and (some? frameState) (Node''isAlive-1 frameState)) => outerFrameState
                                (let [
                                    outerFrameState
                                        (or outerFrameState
                                            (FrameState''duplicateModifiedDuringCall-3 stateAtReturn, (:bci invoke), invokeReturnKind)
                                        )
                                ]
                                    (InliningUtil'processFrameState-8 frameState, invoke, replacements, (:rootMethod inlineGraph), outerFrameState, alwaysDuplicateStateAfter, (:targetMethod (:callTarget invoke)), (:arguments (:callTarget invoke)))
                                    outerFrameState
                                )
                            )
                    ]
                        (recur outerFrameState (next s))
                    )
                )
        ]
            ;; If processing the frame states replaced any nodes, update the duplicates map.
            (#_"EconomicMap" .replaceAll duplicates, (fn [k v] (if (contains? replacements v) (get replacements v) v)))
        )
        nil
    )

    (defn- #_"FrameState" InliningUtil'handleAfterBciFrameState-3 [#_"FrameState" frameState, #_"InvokeNode" invoke, #_"boolean" alwaysDuplicateStateAfter]
        (let [
            #_"FrameState" atReturn (:stateAfter invoke)
            #_"JavaKind" invokeReturnKind (ValueNode''getStackKind-1 invoke)
            ;; pop return kind from invoke's stateAfter and replace with this frameState's return value (top of stack)
            #_"FrameState" afterReturn
                (if (and (pos? (:stackSize frameState)) (or alwaysDuplicateStateAfter (not= (FrameState''stackAt-2 atReturn, 0) (FrameState''stackAt-2 frameState, 0))))
                    (FrameState''duplicateModified-4 atReturn, invokeReturnKind, invokeReturnKind, (FrameState''stackAt-2 frameState, 0)) ;; a non-void return value
                    (FrameState''duplicate-1 atReturn) ;; a void return value
                )
        ]
            ;; return value does no longer need to be limited by the monitor exit
            (doseq [#_"MonitorExitNode" node (filter #(satisfies? MonitorExitNode %) (:nodeUsages frameState))]
                (ยง ass! node (MonitorExitNode''clearEscapedReturnValue-1 node))
            )
            (ยง ass! frameState (Node''replaceAndDelete-2 frameState, afterReturn))
            afterReturn
        )
    )

    (defn #_"FrameState" InliningUtil'processFrameState-8 [#_"FrameState" frameState, #_"InvokeNode" invoke, #_"EconomicMap<Node, Node>" replacements, #_"ResolvedJavaMethod" inlinedMethod, #_"FrameState" outerFrameState, #_"boolean" alwaysDuplicateStateAfter, #_"ResolvedJavaMethod" invokeTargetMethod, #_"List<ValueNode>" invokeArgsList]
        (let [
            #_"FrameState" stateAtReturn (:stateAfter invoke)
            #_"JavaKind" invokeReturnKind (ValueNode''getStackKind-1 invoke)
        ]
            (condp = (:bci frameState)
                BytecodeFrame/AFTER_BCI
                    (InliningUtil'handleAfterBciFrameState-3 frameState, invoke, alwaysDuplicateStateAfter)
                BytecodeFrame/BEFORE_BCI
                    ;; This is an intrinsic. Deoptimizing within an intrinsic must re-execute the intrinsified invocation.
                    (let [
                        #_"ValueNode[]" invokeArgs (if (empty? invokeArgsList) (make-array ValueNode'iface 0) (into-array ValueNode'iface invokeArgsList))
                        #_"FrameState" stateBeforeCall (FrameState''duplicateModifiedBeforeCall-5 stateAtReturn, (:bci invoke), invokeReturnKind, (#_"Signature" .toParameterKinds (#_"ResolvedJavaMethod" .getSignature invokeTargetMethod), (not (#_"ResolvedJavaMethod" .isStatic invokeTargetMethod))), invokeArgs)
                    ]
                        (ยง ass! frameState (Node''replaceAndDelete-2 frameState, stateBeforeCall))
                        stateBeforeCall
                    )
                (do
                    ;; only handle the outermost frame states
                    (when (nil? (:outerFrameState frameState))
                        (ยง ass! frameState (FrameState''setOuterFrameState-2 frameState, outerFrameState))
                    )
                    frameState
                )
            )
        )
    )

    ;;;
     ; Gets the receiver for an invoke, adding a guard if necessary to ensure it is non-nil,
     ; and ensuring that the resulting type is compatible with the method being invoked.
     ;;
    (defn #_"ValueNode" InliningUtil'nonNullReceiver-1 [#_"InvokeNode" invoke]
        (let [
            #_"MethodCallTargetNode" callTarget (:callTarget invoke)
            #_"Graph" graph (:graph callTarget)
            #_"ValueNode" oldReceiver (nth (:arguments callTarget) 0)
            #_"ValueNode" newReceiver oldReceiver
        ]
            (when (= (ValueNode''getStackKind-1 newReceiver) JavaKind/Object)
                (when (= (InvokeNode''getInvokeKind-1 invoke) InvokeKind'Special)
                    (let [
                        #_"Stamp" paramStamp (:stamp newReceiver)
                        #_"Stamp" stamp (Stamp'''join-2 paramStamp, (StampFactory'object-1 (TypeReference'create-1 (#_"ResolvedJavaMethod" .getDeclaringClass (:targetMethod callTarget)))))
                    ]
                        (when-not (= stamp paramStamp)
                            ;; The verifier and previous optimizations guarantee unconditionally that the
                            ;; receiver is at least of the type of the method holder for a special invoke.
                            (ยง ass newReceiver (Graph''add-2 graph, (PiNode'new-2 newReceiver, stamp)))
                        )
                    )
                )

                (when-not (StampTool'isPointerNeverNull-1 (:stamp newReceiver))
                    (let [
                        #_"LogicNode" logic (Graph''add-2 graph, (IsNullNode'create-1 newReceiver))
                        #_"FixedGuardNode" fixedGuard (Graph''add-2 graph, (FixedGuardNode'new-4 logic, DeoptimizationReason/NullCheckException, DeoptimizationAction/InvalidateReprofile, true))
                        #_"PiNode" nonNullReceiver (Graph''add-2 graph, (PiNode'new-3 newReceiver, StampFactory'objectNonNullStamp, fixedGuard))
                    ]
                        (Graph''addBeforeFixed-3 graph, invoke, fixedGuard)
                        (ยง ass newReceiver nonNullReceiver)
                    )
                )
            )

            (when-not (= newReceiver oldReceiver)
                (Node''replaceFirstInput-3 callTarget, oldReceiver, newReceiver)
            )
            newReceiver
        )
    )
)

(value-ns ProcessBlockState
    (ยง enum ProcessBlockState'ST_ENTER)
    (ยง enum ProcessBlockState'ST_PROCESS)
    (ยง enum ProcessBlockState'ST_ENTER_ALWAYS_REACHED)
    (ยง enum ProcessBlockState'ST_LEAVE)
    (ยง enum ProcessBlockState'ST_PROCESS_ALWAYS_REACHED)
)

(value-ns ReentrantBlockIterator
    (defn- #_"<T> boolean" ReentrantBlockIterator'allEndsVisited-3 [#_"EconomicMap<FixedNode, T>" states, #_"Block" current, #_"AbstractMergeNode" merge]
        (loop-when [#_"ISeq" s (seq (:ends merge))] (some? s) => true
            (let [
                #_"AbstractEndNode" forwardEnd (first s)
            ]
                (and (or (= forwardEnd (:endNode current)) (contains? states forwardEnd))
                    (recur (next s))
                )
            )
        )
    )

    (defn- #_"<T> Block" ReentrantBlockIterator'processMultipleSuccessors-5 [#_"BlockIteratorClosure<T>" closure, #_"Deque<Block>" blockQueue, #_"EconomicMap<FixedNode, T>" states, #_"T" state, #_"Block*" successors]
        (loop-when-recur [#_"int" i 1] (< i (count successors)) [(inc i)]
            (let [
                #_"Block" successor (nth successors i)
            ]
                (#_"Deque" .addFirst blockQueue, successor)
                (#_"EconomicMap" .put states, (:beginNode successor), (BlockIteratorClosure'''cloneState-2 closure, state))
            )
        )
        (nth successors 0)
    )

    (defn- #_"<T> ArrayList<T>" ReentrantBlockIterator'mergeStates-5 [#_"EconomicMap<FixedNode, T>" states, #_"T" state, #_"Block" current, #_"Block" successor, #_"AbstractMergeNode" merge]
        (let [
            #_"ArrayList<T>" mergedStates (ArrayList.)
        ]
            (doseq [#_"Block" predecessor (:predecessors successor)]
                (#_"ArrayList" .add mergedStates, (if (= predecessor current) state (#_"EconomicMap" .removeKey states, (:endNode predecessor))))
            )
            mergedStates
        )
    )

    (defn- #_"<T> void" ReentrantBlockIterator'recurseIntoLoop-5 [#_"BlockIteratorClosure<T>" closure, #_"Deque<Block>" blockQueue, #_"EconomicMap<FixedNode, T>" states, #_"T" state, #_"Block" successor]
        ;; recurse into the loop
        (let [
            #_"Loop" _loop (:loop successor)
            #_"List<T>" exitStates (BlockIteratorClosure'''processLoop-3 closure, _loop, state)
        ]
            (loop-when [#_"int" i 0 #_"ISeq" s (seq (:exits _loop))] (some? s)
                (let [
                    #_"Block" exit (first s)
                ]
                    (#_"EconomicMap" .put states, (:beginNode exit), (nth exitStates i))
                    (#_"Deque" .addFirst blockQueue, exit)
                    (recur (inc i) (next s))
                )
            )
        )
        nil
    )

    (defn #_"<T> EconomicMap<FixedNode, T>" ReentrantBlockIterator'apply-4 [#_"BlockIteratorClosure<T>" closure, #_"Block" start, #_"T" initialState, #_"fn boolean [Block]" f'stopAtBlock-1]
        (let [
            #_"Deque<Block>" blockQueue (ArrayDeque.)
            ;; States are stored on EndNodes before merges, and on BeginNodes after ControlSplitNodes.
            #_"EconomicMap<FixedNode, T>" states (EconomicMap/create)
            #_"Graph" graph (:graph (:beginNode start))
        ]
            (loop [#_"Block" block start #_"T" state initialState]
                (let [
                    [block state]
                        (if (and (some? f'stopAtBlock-1) (f'stopAtBlock-1 block))
                            (do
                                (#_"EconomicMap" .put states, (:beginNode block), state)
                                [nil state]
                            )
                            (let [
                                state (BlockIteratorClosure'''processBlock-3 closure, block, state)
                                #_"Block[]" successors (:successors block)
                            ]
                                (case (count successors)
                                    0
                                        [nil state] ;; nothing to do...
                                    1
                                        (let [
                                            #_"Block" successor (nth successors 0)
                                        ]
                                            (cond
                                                (Block''isLoopHeader-1 successor)
                                                    (do
                                                        (if (Block''isLoopEnd-1 block)
                                                            ;; nothing to do... loop ends only lead to loop begins we've already visited
                                                            (#_"EconomicMap" .put states, (:endNode block), state)
                                                            (ReentrantBlockIterator'recurseIntoLoop-5 closure, blockQueue, states, state, successor)
                                                        )
                                                        [nil state]
                                                    )
                                                (satisfies? AbstractEndNode (:endNode block))
                                                    (let [
                                                        #_"AbstractEndNode" end (:endNode block)
                                                        ;; add the end node and see if the merge is ready for processing
                                                        #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 end)
                                                    ]
                                                        (if (ReentrantBlockIterator'allEndsVisited-3 states, block, merge)
                                                            [successor (BlockIteratorClosure'''merge-3 closure, successor, (ReentrantBlockIterator'mergeStates-5 states, state, block, successor, merge))]
                                                            (do
                                                                (#_"EconomicMap" .put states, end, state)
                                                                [nil state]
                                                            )
                                                        )
                                                    )
                                                :else
                                                    [successor state]
                                            )
                                        )
                                    [(ReentrantBlockIterator'processMultipleSuccessors-5 closure, blockQueue, states, state, successors) state]
                                )
                            )
                        )
                ]
                    ;; get next queued block
                    (cond
                        (some? block)
                            (recur block state)
                        (empty? blockQueue)
                            states
                        :else
                            (let [
                                block (#_"Deque" .removeFirst blockQueue)
                            ]
                                (recur block (#_"EconomicMap" .removeKey states, (:beginNode block)))
                            )
                    )
                )
            )
        )
    )

    (defn #_"<T> void" ReentrantBlockIterator'apply-2 [#_"BlockIteratorClosure<T>" closure, #_"Block" start]
        (ReentrantBlockIterator'apply-4 closure, start, (BlockIteratorClosure'''getInitialState-1 closure), nil)
        nil
    )

    (defn #_"<T> BlockLoopInfo<T>" ReentrantBlockIterator'processLoop-3 [#_"BlockIteratorClosure<T>" closure, #_"Loop" _loop, #_"T" initialState]
        (let [
            #_"EconomicMap<FixedNode, T>" blockEndStates (ReentrantBlockIterator'apply-4 closure, (:header _loop), initialState, #(not (or (= (:loop %) _loop) (Block''isLoopHeader-1 %))))
            #_"Block[]" predecessors (:predecessors (:header _loop))
            #_"BlockLoopInfo<T>" info (BlockLoopInfo'new-2 (dec (count predecessors)), (count (:exits _loop)))
        ]
            (loop-when-recur [#_"int" i 1] (< i (count predecessors)) [(inc i)]
                (let [
                    #_"T" endState (get blockEndStates (:endNode (nth predecessors i)))
                ]
                    ;; make sure all end states are unique objects
                    (#_"List" .add (:endStates info), (BlockIteratorClosure'''cloneState-2 closure, endState))
                )
            )
            (doseq [#_"Block" loopExit (:exits _loop)]
                (let [
                    #_"T" exitState (get blockEndStates (:beginNode loopExit))
                ]
                    ;; make sure all exit states are unique objects
                    (#_"List" .add (:exitStates info), (BlockIteratorClosure'''cloneState-2 closure, exitState))
                )
            )
            info
        )
    )
)

(value-ns ReentrantNodeIterator
    (defn- #_"<T> EconomicMap<FixedNode, T>" ReentrantNodeIterator'apply-4 [#_"NodeIteratorClosure<T>" closure, #_"FixedNode" start, #_"T" initialState, #_"LoopBeginNode" boundary]
        (let [
            #_"Deque<AbstractBeginNode>" nodeQueue (ArrayDeque.)
            #_"EconomicMap<FixedNode, T>" blockEndStates (EconomicMap/create)
        ]
            (loop [#_"T" state initialState #_"FixedNode" node start]
                (let [
                    [state node]
                        (loop-when [state state node node] (satisfies? FixedWithNextNode node) => [state node]
                            (if (and (some? boundary) (satisfies? LoopExitNode node) (= (:loopBegin node) boundary))
                                (do
                                    (#_"EconomicMap" .put blockEndStates, node, state)
                                    (recur state nil)
                                )
                                (recur (NodeIteratorClosure'''processNode-3 closure, node, state) (:next node))
                            )
                        )
                ]
                    (when (some? node)
                        (let [
                            state (NodeIteratorClosure'''processNode-3 closure, node, state)
                            #_"Node*" successors (Node''successors-1 node)
                        ]
                            (if (seq successors)
                                (let [
                                    [#_"FixedNode" firstSuccessor & successors] successors
                                ]
                                    (when (seq successors)
                                        (loop [successors successors]
                                            (let [
                                                [#_"AbstractBeginNode" successor & successors] successors
                                            ]
                                                (#_"EconomicMap" .put blockEndStates, successor, (NodeIteratorClosure'''afterSplit-3 closure, successor, state))
                                                (#_"Deque" .add nodeQueue, successor)
                                                (recur-if (seq successors) [successors])
                                            )
                                        )
                                        (ยง ass state (NodeIteratorClosure'''afterSplit-3 closure, (ยง cast #_"AbstractBeginNode" firstSuccessor), state))
                                    )
                                    (ยง ass node firstSuccessor)
                                    (ยง continue )
                                )
                                (condp satisfies? node
                                    LoopEndNode
                                        (#_"EconomicMap" .put blockEndStates, node, state)
                                    EndNode
                                        ;; add the end node and see if the merge is ready for processing
                                        (let [
                                            #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 node)
                                        ]
                                            (if (satisfies? LoopBeginNode merge)
                                                (let [
                                                    #_"EconomicMap<LoopExitNode, T>" loopExitState (NodeIteratorClosure'''processLoop-3 closure, merge, state)
                                                    #_"MapCursor<LoopExitNode, T>" entry (#_"EconomicMap" .getEntries loopExitState)
                                                ]
                                                    (while (#_"MapCursor" .advance entry)
                                                        (#_"EconomicMap" .put blockEndStates, (#_"MapCursor" .getKey entry), (#_"MapCursor" .getValue entry))
                                                        (#_"Deque" .add nodeQueue, (#_"MapCursor" .getKey entry))
                                                    )
                                                )
                                                (let [
                                                    #_"boolean" endsVisited
                                                        (loop-when [#_"ISeq" s (seq (:ends merge))] (some? s) => true
                                                            (let [
                                                                #_"AbstractEndNode" forwardEnd (first s)
                                                            ]
                                                                (and (or (= forwardEnd node) (contains? blockEndStates forwardEnd))
                                                                    (recur (next s))
                                                                )
                                                            )
                                                        )
                                                ]
                                                    (if endsVisited
                                                        (let [
                                                            #_"ArrayList<T>" states (ArrayList.)
                                                        ]
                                                            (dotimes [#_"int" i (AbstractMergeNode''forwardEndCount-1 merge)]
                                                                (let [
                                                                    #_"AbstractEndNode" forwardEnd (AbstractMergeNode''forwardEndAt-2 merge, i)
                                                                ]
                                                                    (#_"ArrayList" .add states, (if (= forwardEnd node) state (#_"EconomicMap" .removeKey blockEndStates, forwardEnd)))
                                                                )
                                                            )
                                                            (ยง ass state (NodeIteratorClosure'''merge-3 closure, merge, states))
                                                            (ยง ass node merge)
                                                            (ยง continue )
                                                        )
                                                        (#_"EconomicMap" .put blockEndStates, node, state)
                                                    )
                                                )
                                            )
                                        )
                                    nil
                                )
                            )
                        )
                    )

                    (when (seq nodeQueue) => blockEndStates
                        (let [
                            node (#_"Deque" .removeFirst nodeQueue)
                        ]
                            (recur (#_"EconomicMap" .removeKey blockEndStates, node) node)
                        )
                    )
                )
            )
        )
    )

    (defn #_"<T> void" ReentrantNodeIterator'apply-3 [#_"NodeIteratorClosure<T>" closure, #_"FixedNode" start, #_"T" initialState]
        (ReentrantNodeIterator'apply-4 closure, start, initialState, nil)
        nil
    )

    (defn #_"<T> NodeLoopInfo<T>" ReentrantNodeIterator'processLoop-3 [#_"NodeIteratorClosure<T>" closure, #_"LoopBeginNode" _loop, #_"T" initialState]
        (let [
            #_"EconomicMap<FixedNode, T>" blockEndStates (ReentrantNodeIterator'apply-4 closure, _loop, initialState, _loop)
            #_"NodeLoopInfo<T>" info (NodeLoopInfo'new-0)
        ]
            (doseq [#_"LoopEndNode" end (LoopBeginNode''loopEnds-1 _loop)]
                (when (contains? blockEndStates end)
                    (#_"EconomicMap" .put (:endStates info), end, (get blockEndStates end))
                )
            )
            (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 _loop)]
                (when (contains? blockEndStates exit)
                    (#_"EconomicMap" .put (:exitStates info), exit, (get blockEndStates exit))
                )
            )
            info
        )
    )
)

(value-ns Optimization
    (ยง enum Optimization'RemoveNeverExecutedCode)
    (ยง enum Optimization'UseTypeCheckedInlining)
    (ยง enum Optimization'UseLoopLimitChecks)
)

(value-ns SchedulingStrategy
    (ยง enum SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER)
    (ยง enum SchedulingStrategy'EARLIEST)
    (ยง enum SchedulingStrategy'LATEST)
    (ยง enum SchedulingStrategy'LATEST_OUT_OF_LOOPS)
    (ยง enum SchedulingStrategy'FINAL_SCHEDULE)

    (defn #_"boolean" SchedulingStrategy'isEarliest-1 [#_"SchedulingStrategy" self]
        (any = self SchedulingStrategy'EARLIEST SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER)
    )
)

(value-ns GuardOrder
    ;;;
     ; This fills in a map of transitive priorities ({@code priorities}). It also marks the
     ; nodes from this micro-block in {@code blockNodes}.
     ;
     ; The transitive priority of a guard is the highest of its priority and the priority of
     ; the guards that depend on it (transitively).
     ;
     ; This method returns false if no re-ordering is necessary in this micro-block.
     ;;
    (defn- #_"boolean" GuardOrder'propagatePriority-3 [#_"MicroBlock" block, #_"NodeMap<GuardPriority>" priorities, #_"NodeBitMap" blockNodes]
        (let [
            [#_"GuardPriority" lowest #_"Node*" stack]
                (loop-when [lowest (GuardPriority'highest-0) stack nil #_"NodeEntry" e (:head block)] (some? e) => [lowest stack]
                    (NodeBitMap''mark-2 blockNodes, (:node e))
                    (let [
                        [lowest stack]
                            (when (satisfies? GuardNode (:node e)) => [lowest stack]
                                (let [
                                    #_"GuardNode" guard (:node e)
                                    #_"GuardPriority" priority (StaticDeoptimizingNode'''computePriority-1 guard)
                                    lowest
                                        (when (some? lowest)
                                            (cond
                                                (GuardPriority'isLowerPriorityThan-2 priority, lowest)  priority
                                                (GuardPriority'isHigherPriorityThan-2 priority, lowest) nil
                                                :else                                                   lowest
                                            )
                                        )
                                    stack (cons guard stack)
                                ]
                                    (NodeMap''set-3 priorities, guard, priority)
                                    [lowest stack]
                                )
                            )
                    ]
                        (recur lowest stack (:next e))
                    )
                )
        ]
            (if (some? lowest)
                (do
                    (NodeBitMap''clearAll-1 blockNodes)
                    false
                )
                (loop [stack stack]
                    (let [
                        [#_"Node" node & stack] stack
                        #_"GuardPriority" priority (get priorities node)
                        stack
                            (loop-when [stack stack #_"ISeq" s (seq (Node''inputs-1 node))] (some? s) => stack
                                (let [
                                    #_"Node" input (first s)
                                    stack
                                        (when (NodeBitMap''isMarked-2n blockNodes, input) => stack
                                            (let [
                                                #_"GuardPriority" ip (get priorities input)
                                            ]
                                                (when (or (nil? ip) (GuardPriority'isLowerPriorityThan-2 ip, priority)) => stack
                                                    (NodeMap''set-3 priorities, input, priority)
                                                    (cons input stack)
                                                )
                                            )
                                        )
                                ]
                                    (recur stack (next s))
                                )
                            )
                    ]
                        (recur-if (seq stack) [stack] => true)
                    )
                )
            )
        )
    )

    ;;;
     ; Add a node to the re-sorted micro-block. This also pushes nodes that need to be
     ; (re-)examined on the stack.
     ;;
    (defn- #_"Node*" GuardOrder'addNodeToResort-5 [#_"Node" node, #_"Node*" stack, #_"NodeBitMap" sorted, #_"MicroBlock" newBlock, #_"boolean" pushUsages]
        (NodeBitMap''mark-2 sorted, node)
        (ยง ass! newBlock (MicroBlock''add-2 newBlock, node))
        (when pushUsages => stack
            (into stack (remove #(NodeBitMap''isMarked-2n sorted, %) (:nodeUsages node)))
        )
    )

    ;;;
     ; This checks if {@code node} can be scheduled, if it is the case, it schedules it now
     ; by calling #addNodeToResort(Node, Node*, NodeBitMap, MicroBlock, boolean).
     ;;
    (defn- #_"Node*" GuardOrder'checkIfAvailable-6 [#_"Node" node, #_"Node*" stack, #_"NodeBitMap" sorted, #_"MicroBlock" newBlock, #_"SortedSet<GuardNode>" availableGuardNodes, #_"boolean" pushUsages]
        (when-not (NodeBitMap''isMarked-2n sorted, node) => stack
            (loop [stack stack #_"ISeq" s (seq (Node''inputs-1 node))]
                (if (some? s)
                    (when (NodeBitMap''isMarked-2n sorted, (first s)) => stack
                        (recur stack (next s))
                    )
                    (when (satisfies? GuardNode node) => (GuardOrder'addNodeToResort-5 node, stack, sorted, newBlock, pushUsages)
                        (#_"SortedSet" .add availableGuardNodes, node)
                        stack
                    )
                )
            )
        )
    )

    ;;;
     ; This resorts guards within one micro-block.
     ;
     ; {@code blockNodes} and {@code priorities} are temporary data-structures allocated once by the callers of this method.
     ; They should be in their "initial"/"empty" state when calling this method and when it returns.
     ;;
    (defn- #_"MicroBlock" GuardOrder'resortGuards-3 [#_"MicroBlock" block, #_"NodeBitMap" blockNodes, #_"NodeMap<GuardPriority>" priorities]
        (when (GuardOrder'propagatePriority-3 block, priorities, blockNodes)
            (let [
                #_"SortedSet<GuardNode>" availableGuards (ร TreeSet. (ร #_"Comparator" .thenComparingInt (#_"Comparator" .thenComparing (Comparator/comparing (ยง ffun #_"Map" .get)), (ร GuardNode(ยง ffun )StaticDeoptimizingNode'''computePriority-1)), (ยง ffun #_"Object" .hashCode)))
                #_"MicroBlock" newBlock (MicroBlock'new-1 (:id block))
                #_"NodeBitMap" sorted blockNodes
                _ (NodeBitMap''invert-1 sorted)
                #_"Node*" stack
                    (loop-when-recur [stack nil #_"NodeEntry" e (:head block)]
                                     (some? e)
                                     [(GuardOrder'checkIfAvailable-6 (:node e), stack, sorted, newBlock, availableGuards, false) (:next e)]
                                  => stack
                    )
            ]
                (loop [stack stack]
                    (let [
                        stack (loop-when-recur stack (seq stack) (GuardOrder'checkIfAvailable-6 (first stack), (next stack), sorted, newBlock, availableGuards, true) => stack)
                        #_"Iterator<GuardNode>" it (#_"SortedSet" .iterator availableGuards)
                        stack
                            (when (#_"Iterator" .hasNext it) => stack
                                (let [
                                    stack (GuardOrder'addNodeToResort-5 (#_"Iterator" .next it), stack, sorted, newBlock, true)
                                ]
                                    (#_"Iterator" .remove it)
                                    stack
                                )
                            )
                    ]
                        (recur-if (or (seq stack) (seq availableGuards)) [stack])
                    )
                )
                (NodeBitMap''clearAll-1 blockNodes)
                newBlock
            )
        )
    )

    ;;;
     ; After an earliest schedule, this will re-sort guards to honor their
     ; {@linkplain StaticDeoptimizingNode#computePriority() priority}.
     ;
     ; Note that this only changes the order of nodes within {@linkplain MicroBlock micro-blocks},
     ; nodes will not be moved from one micro-block to another.
     ;;
    (defn #_"void" GuardOrder'resortGuards-2 [#_"Graph" graph, #_"NodeMap<MicroBlock>" entries]
        (let [
            #_"NodeBitMap" blockNodes (NodeBitMap'new-1 graph)
            #_"NodeMap<GuardPriority>" priorities (NodeMap'new-1g graph)
        ]
            (doseq [#_"MicroBlock" block (into #{} (map #(get entries %) (Graph''getNodes-2 graph, GuardNode)))]
                (let [
                    #_"MicroBlock" newBlock (GuardOrder'resortGuards-3 block, blockNodes, priorities)
                ]
                    (when (some? newBlock)
                        (ยง ass! block (assoc block :head (:head newBlock)))
                        (ยง ass! block (assoc block :tail (:tail newBlock)))
                    )
                )
            )
        )
        nil
    )
)

(value-ns ValueMergeUtil
    (defn #_"<T> ValueNode" ValueMergeUtil'mergeValueProducers-4 [#_"AbstractMergeNode" merge, #_"T*" valueProducers, #_"fn FixedWithNextNode [T]" f'lastInstrFunction-1, #_"fn ValueNode [T]" f'valueFunction-1]
        (let [
            [#_"ValueNode" singleResult #_"PhiNode" phiResult]
                (loop-when [singleResult nil phiResult nil #_"ISeq" s (seq valueProducers)] (some? s) => [singleResult phiResult]
                    (let [
                        #_"T" valueProducer (first s)
                        #_"ValueNode" result (f'valueFunction-1 valueProducer)
                        [singleResult phiResult]
                            (when (some? result) => [singleResult phiResult]
                                (cond
                                    (and (nil? phiResult) (or (nil? singleResult) (= singleResult result)))
                                        (do
                                            ;; Only one result value, so no need yet for a phi node.
                                            [result phiResult]
                                        )
                                    (nil? phiResult)
                                        ;; Found a second result value, so create phi node.
                                        (let [
                                            phiResult (Graph''add-2 (:graph merge), (ValuePhiNode'new-2 (Stamp'''unrestricted-1 (:stamp result)), merge))
                                        ]
                                            (dotimes [#_"int" i (AbstractMergeNode''forwardEndCount-1 merge)]
                                                (PhiNode''addInput-2 phiResult, singleResult)
                                            )
                                            (PhiNode''addInput-2 phiResult, result)
                                            [singleResult phiResult]
                                        )
                                    :else
                                        (do
                                            ;; Multiple return values, just add to existing phi node.
                                            (PhiNode''addInput-2 phiResult, result)
                                            [singleResult phiResult]
                                        )
                                )
                            )
                        ;; create and wire up a new EndNode
                        #_"EndNode" endNode (Graph''add-2 (:graph merge), (EndNode'new-0))
                    ]
                        (AbstractMergeNode''addForwardEnd-2 merge, endNode)
                        (if (some? f'lastInstrFunction-1)
                            (ยง ass! (f'lastInstrFunction-1 valueProducer) (FixedWithNextNode''setNext-2 (f'lastInstrFunction-1 valueProducer), endNode))
                            (ยง ass! valueProducer (Node''replaceAndDelete-2 valueProducer, endNode))
                        )
                        (recur singleResult phiResult (next s))
                    )
                )
        ]
            (when (some? phiResult) => singleResult
                (ValueNode'''inferStamp-1 phiResult)
                phiResult
            )
        )
    )

    (defn #_"ValueNode" ValueMergeUtil'mergeReturns-2 [#_"AbstractMergeNode" merge, #_"ReturnNode*" returnNodes]
        (ValueMergeUtil'mergeValueProducers-4 merge, returnNodes, nil, (ร (returnNode)  (ยง fun (:result returnNode))))
    )
)

(value-ns BoxingSnippets (ยง implements Snippets)
    (ยง snippet! #_"Object" #_"BoxingSnippets" "booleanValueOf" [#_"boolean" value] (Placeholder'piCastToSnippetReplaceeStamp-1 (Boolean/valueOf value)))
    (ยง snippet! #_"Object" #_"BoxingSnippets" "byteValueOf"    [#_"byte" value]    (Placeholder'piCastToSnippetReplaceeStamp-1 (Byte/valueOf value)))
    (ยง snippet! #_"Object" #_"BoxingSnippets" "charValueOf"    [#_"char" value]    (Placeholder'piCastToSnippetReplaceeStamp-1 (Character/valueOf value)))
    (ยง snippet! #_"Object" #_"BoxingSnippets" "intValueOf"     [#_"int" value]     (Placeholder'piCastToSnippetReplaceeStamp-1 (Integer/valueOf value)))
    (ยง snippet! #_"Object" #_"BoxingSnippets" "longValueOf"    [#_"long" value]    (Placeholder'piCastToSnippetReplaceeStamp-1 (Long/valueOf value)))
    (ยง snippet! #_"Object" #_"BoxingSnippets" "shortValueOf"   [#_"short" value]   (Placeholder'piCastToSnippetReplaceeStamp-1 (Short/valueOf value)))

    (ยง snippet! #_"boolean" #_"BoxingSnippets" "booleanValue" [#_"Boolean" value]   (#_"Boolean" .booleanValue value))
    (ยง snippet! #_"byte"    #_"BoxingSnippets" "byteValue"    [#_"Byte" value]      (#_"Byte" .byteValue value))
    (ยง snippet! #_"char"    #_"BoxingSnippets" "charValue"    [#_"Character" value] (#_"Character" .charValue value))
    (ยง snippet! #_"int"     #_"BoxingSnippets" "intValue"     [#_"Integer" value]   (#_"Integer" .intValue value))
    (ยง snippet! #_"long"    #_"BoxingSnippets" "longValue"    [#_"Long" value]      (#_"Long" .longValue value))
    (ยง snippet! #_"short"   #_"BoxingSnippets" "shortValue"   [#_"Short" value]     (#_"Short" .shortValue value))

    (defn #_"FloatingNode" BoxingSnippets'canonicalizeBoxing-1 [#_"BoxNode" box]
        (let [
            #_"ValueNode" value (Unary'''getValue-1 box)
        ]
            (when (satisfies? ConstantNode value)
                (let [
                    #_"JavaConstant" sourceConstant (ValueNode''asJavaConstant-1 value)
                    sourceConstant
                        (when (and (not= (#_"JavaConstant" .getJavaKind sourceConstant) (:boxingKind box)) (#_"JavaKind" .isNumericInteger (#_"JavaConstant" .getJavaKind sourceConstant))) => sourceConstant
                            (condp = (:boxingKind box)
                                JavaKind/Boolean (JavaConstant/forBoolean (not (zero? (#_"JavaConstant" .asLong sourceConstant))))
                                JavaKind/Byte    (JavaConstant/forByte          (byte (#_"JavaConstant" .asLong sourceConstant)))
                                JavaKind/Char    (JavaConstant/forChar          (char (#_"JavaConstant" .asLong sourceConstant)))
                                JavaKind/Short   (JavaConstant/forShort        (short (#_"JavaConstant" .asLong sourceConstant)))
                                                 sourceConstant
                            )
                        )
                    #_"JavaConstant" boxedConstant (#_"ConstantReflectionProvider" .boxPrimitive HotSpot'constantReflection, sourceConstant)
                ]
                    (when (and (some? boxedConstant) (= (#_"JavaConstant" .getJavaKind sourceConstant) (:boxingKind box)))
                        (ConstantNode'forConstant-2c boxedConstant, (:graph box))
                    )
                )
            )
        )
    )
)

;;;
 ; Provides a capability for replacing a higher node with one or more lower level nodes.
 ;;
(value-ns Lowerer
    (ยง def #_"BoxingTemplates"       Lowerer'boxingSnippets       (BoxingTemplates'new-0))
    (ยง def #_"InstanceOfTemplates"   Lowerer'instanceofSnippets   (InstanceOfTemplates'new-0))
    (ยง def #_"NewObjectTemplates"    Lowerer'newObjectSnippets    (NewObjectTemplates'new-0))
    (ยง def #_"MonitorTemplates"      Lowerer'monitorSnippets      (MonitorTemplates'new-1 HotSpot'useFastLocking))
    (ยง def #_"WriteBarrierTemplates" Lowerer'writeBarrierSnippets (WriteBarrierTemplates'new-1 (when HotSpot'useCompressedOops HotSpot'oopEncoding)))
    (ยง def #_"UnsafeLoadTemplates"   Lowerer'unsafeLoadSnippets   (UnsafeLoadTemplates'new-0))

    ;;;
     ; Indicates the smallest width for comparing an integer value on the target platform.
     ;;
    (defn #_"Integer" Lowerer'smallestCompareWidth-0 []
        8
    )

    (defn #_"AddressNode" Lowerer'createOffsetAddress-3 [#_"Graph" graph, #_"ValueNode" object, #_"long" offset]
        (Graph''add-2 graph, (OffsetAddressNode'new-2 object, (ConstantNode'forIntegerKind-3 (.wordJavaKind HotSpot'target), offset, graph)))
    )

    (defn #_"AddressNode" Lowerer'createFieldAddress-3 [#_"Graph" graph, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (let [
            #_"int" offset (#_"HotSpotResolvedJavaField" .offset field)
        ]
            (when (<= 0 offset) (Lowerer'createOffsetAddress-3 graph, object, offset))
        )
    )

    ;;;
     ; Creates a read node that read the array length and is guarded by a nil-check.
     ;
     ; The created node is placed before {@code before} in the CFG.
     ;;
    (defn #_"ReadNode" Lowerer'createReadArrayLength-3 [#_"ValueNode" array, #_"FixedNode" before, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph array)
            #_"ValueNode" canonicalArray (Lowerer'createNullCheckedValue-3 (GraphUtil'skipPiWhileNonNull-1 array), before, lowerer)
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, canonicalArray, HotSpot'arrayLengthOffset)
            #_"ReadNode" readArrayLength (Graph''add-2 graph, (ReadNode'new-4 address, NamedLocationIdentity'ARRAY_LENGTH, StampFactory'nonNegativeInt, BarrierType'NONE))
        ]
            (Graph''addBeforeFixed-3 graph, before, readArrayLength)
            readArrayLength
        )
    )

    (defn #_"AddressNode" Lowerer'createUnsafeAddress-3 [#_"Graph" graph, #_"ValueNode" object, #_"ValueNode" offset]
        (if (and (satisfies? ConstantNode object) (#_"Constant" .isDefaultForKind (:value object)))
            (Graph''addOrUniqueWithInputs-2 graph, (OffsetAddressNode'create-1 offset))
            (Graph''add-2 graph, (OffsetAddressNode'new-2 object, offset))
        )
    )

    (defn #_"BarrierType" Lowerer'fieldLoadBarrierType-1 [#_"ResolvedJavaField" field]
        (if (and HotSpot'useG1GC (= (#_"HotSpotResolvedJavaField" .getJavaKind field) JavaKind/Object) (= (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, java.lang.ref.Reference) (#_"HotSpotResolvedJavaField" .getDeclaringClass field)) (= (#_"HotSpotResolvedJavaField" .getName field) "referent"))
            BarrierType'PRECISE
            BarrierType'NONE
        )
    )

    (defn #_"BarrierType" Lowerer'fieldStoreBarrierType-1 [#_"ResolvedJavaField" field]
        (if (= (#_"ResolvedJavaField" .getJavaKind field) JavaKind/Object) BarrierType'IMPRECISE BarrierType'NONE)
    )

    (defn #_"BarrierType" Lowerer'arrayStoreBarrierType-1 [#_"JavaKind" elementKind]
        (if (= elementKind JavaKind/Object) BarrierType'PRECISE BarrierType'NONE)
    )

    (defn #_"BarrierType" Lowerer'fieldInitializationBarrier-1 [#_"JavaKind" entryKind]
        (if (and (= entryKind JavaKind/Object) (not HotSpot'useDeferredInitBarriers)) BarrierType'IMPRECISE BarrierType'NONE)
    )

    (defn #_"BarrierType" Lowerer'arrayInitializationBarrier-1 [#_"JavaKind" entryKind]
        (if (and (= entryKind JavaKind/Object) (not HotSpot'useDeferredInitBarriers)) BarrierType'PRECISE BarrierType'NONE)
    )

    (defn #_"BarrierType" Lowerer'storeBarrierType-2 [#_"ValueNode" object, #_"ValueNode" value]
        (when (and (= (ValueNode''getStackKind-1 value) JavaKind/Object) (= (ValueNode''getStackKind-1 object) JavaKind/Object)) => BarrierType'NONE
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp object))
            ]
                (if (and (some? type) (not (#_"ResolvedJavaType" .isArray type))) BarrierType'IMPRECISE BarrierType'PRECISE)
            )
        )
    )

    (defn- #_"boolean" Lowerer'useCompressedOops-2 [#_"JavaKind" kind, #_"boolean" compressible?]
        (and (= kind JavaKind/Object) compressible? HotSpot'useCompressedOops)
    )

    (defn #_"Stamp" Lowerer'loadStamp-3 [#_"Stamp" stamp, #_"JavaKind" kind, #_"boolean" compressible?]
        (if (Lowerer'useCompressedOops-2 kind, compressible?)
            (HotSpotNarrowOopStamp'compressed-2 stamp, HotSpot'oopEncoding)
            (condp =? kind
                [JavaKind/Boolean JavaKind/Byte] (IntegerConvertOp'''foldStamp-4 (:narrow IntegerStamp'OPS), 32, 8, stamp)
                [JavaKind/Char JavaKind/Short]   (IntegerConvertOp'''foldStamp-4 (:narrow IntegerStamp'OPS), 32, 16, stamp)
                                                 stamp
            )
        )
    )

    (defn- #_"ValueNode" Lowerer'newCompressionNode-2 [#_"CompressionOp" op, #_"ValueNode" value]
        (HotSpotCompressionNode'new-3 op, value, HotSpot'oopEncoding)
    )

    (defn #_"ValueNode" Lowerer'implicitLoadConvert-4 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value, #_"boolean" compressible?]
        (let [
            #_"ValueNode" ret
                (when-not (Lowerer'useCompressedOops-2 kind, compressible?) => (Lowerer'newCompressionNode-2 CompressionOp'Uncompress, value)
                    (condp =? kind
                        [JavaKind/Byte JavaKind/Short]   (SignExtendNode'new-2 value, 32)
                        [JavaKind/Boolean JavaKind/Char] (ZeroExtendNode'new-2 value, 32)
                                                         value
                    )
                )
        ]
            (when-not (Node''isAlive-1 ret) => ret
                (Graph''add-2 graph, ret)
            )
        )
    )

    (defn #_"ValueNode" Lowerer'implicitLoadConvert-3 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value]
        (Lowerer'implicitLoadConvert-4 graph, kind, value, true)
    )

    (defn #_"ValueNode" Lowerer'implicitStoreConvert-4 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value, #_"boolean" compressible?]
        (let [
            #_"ValueNode" ret
                (when-not (Lowerer'useCompressedOops-2 kind, compressible?) => (Lowerer'newCompressionNode-2 CompressionOp'Compress, value)
                    (condp =? kind
                        [JavaKind/Boolean JavaKind/Byte] (NarrowNode'new-2 value, 8)
                        [JavaKind/Char JavaKind/Short]   (NarrowNode'new-2 value, 16)
                                                         value
                    )
                )
        ]
            (when-not (Node''isAlive-1 ret) => ret
                (Graph''add-2 graph, ret)
            )
        )
    )

    (defn #_"ValueNode" Lowerer'implicitStoreConvert-3 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value]
        (Lowerer'implicitStoreConvert-4 graph, kind, value, true)
    )

    (defn #_"ValueNode" Lowerer'createReadHub-3 [#_"Graph" graph, #_"ValueNode" object, #_"LoweringTool" lowerer]
        (if-not (= (:loweringStage (:phase lowerer)) LoweringStage'LOW_TIER)
            (Graph''add-2 graph, (LoadHubNode'new-1 object))
            (let [
                #_"KlassPointerStamp" hubStamp KlassPointerStamp'KLASS_NON_NULL
                hubStamp (if HotSpot'useCompressedClassPointers (KlassPointerStamp''compressed-2 hubStamp, HotSpot'klassEncoding) hubStamp)
                #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, object, HotSpot'hubOffset)
                #_"LocationIdentity" hubLocation (if HotSpot'useCompressedClassPointers NamedLocationIdentity'COMPRESSED_HUB NamedLocationIdentity'HUB)
                #_"FloatingReadNode" memoryRead (Graph''add-2 graph, (FloatingReadNode'new-6 address, hubLocation, nil, hubStamp, nil, BarrierType'NONE))
            ]
                (if HotSpot'useCompressedClassPointers (HotSpotCompressionNode'uncompress-2 memoryRead, HotSpot'klassEncoding) memoryRead)
            )
        )
    )

    (defn #_"ValueNode" Lowerer'createReadArrayComponentHub-3 [#_"Graph" graph, #_"ValueNode" arrayHub, #_"FixedNode" anchor]
        ;; Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
        ;; is an object class, which might not be the case in other parts of the compiled method.
        (let [
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, arrayHub, HotSpot'arrayClassElementOffset)
        ]
            (Graph''add-2 graph, (FloatingReadNode'new-5 address, NamedLocationIdentity'OBJ_ARRAY_KLASS_ELEMENT_KLASS, nil, KlassPointerStamp'KLASS_NON_NULL, (AbstractBeginNode'prevBegin-1 anchor)))
        )
    )

    (defn #_"GuardingNode" Lowerer'getBoundsCheck-3 [#_"AccessIndexedNode" node, #_"ValueNode" array, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" arrayLength (ArrayLengthNode'readArrayLength-1 array)
            arrayLength
                (if (some? arrayLength)
                    (if (Node''isAlive-1 arrayLength) arrayLength (Graph''addOrUniqueWithInputs-2 (:graph node), arrayLength))
                    (Lowerer'createReadArrayLength-3 array, node, lowerer)
                )
            #_"LogicNode" boundsCheck (IntegerBelowNode'create-2 (AccessIndexedNode''index-1 node), arrayLength)
        ]
            (when-not (LogicNode''isTautology-1 boundsCheck)
                (LoweringTool''createGuard-5 lowerer, node, (Graph''addOrUniqueWithInputs-2 (:graph node), boundsCheck), DeoptimizationReason/BoundsCheckException, DeoptimizationAction/InvalidateReprofile)
            )
        )
    )

    (defn #_"GuardingNode" Lowerer'createNullCheck-3 [#_"ValueNode" object, #_"FixedNode" before, #_"LoweringTool" lowerer]
        (when-not (StampTool'isPointerNeverNull-1 (:stamp object))
            (LoweringTool''createGuard-7 lowerer, before, (Graph''add-2 (:graph before), (IsNullNode'create-1 object)), DeoptimizationReason/NullCheckException, DeoptimizationAction/InvalidateReprofile, JavaConstant/NULL_POINTER, true)
        )
    )

    (defn #_"ValueNode" Lowerer'createNullCheckedValue-3 [#_"ValueNode" object, #_"FixedNode" before, #_"LoweringTool" lowerer]
        (let [
            #_"GuardingNode" nullCheck (Lowerer'createNullCheck-3 object, before, lowerer)
        ]
            (when (some? nullCheck) => object
                (Graph''maybeAddOrUnique-2 (:graph before), (PiNode'create-3 object, (Stamp'''join-2 (:stamp object), StampFactory'objectNonNullStamp), nullCheck))
            )
        )
    )

    (defn #_"AddressNode" Lowerer'createArrayAddress-4 [#_"Graph" graph, #_"ValueNode" array, #_"JavaKind" elementKind, #_"ValueNode" index]
        (let [
            #_"ValueNode" wordIndex
                (if (< 4 (.wordSize HotSpot'target))
                    (Graph''add-2 graph, (SignExtendNode'new-2 index, (* (.wordSize HotSpot'target) 8)))
                    index
                )
            #_"int" shift (CodeUtil/log2 (HotSpot'arrayIndexScale-1 elementKind))
            #_"ValueNode" scaledIndex (Graph''add-2 graph, (LeftShiftNode'new-2 wordIndex, (ConstantNode'forInt-2 shift, graph)))
            #_"int" base (HotSpot'arrayBaseOffset-1 elementKind)
            #_"ValueNode" offset (Graph''add-2 graph, (AddNode'new-2 scaledIndex, (ConstantNode'forIntegerKind-3 (.wordJavaKind HotSpot'target), base, graph)))
        ]
            (Graph''add-2 graph, (OffsetAddressNode'new-2 array, offset))
        )
    )
)

;;;
 ; Provides factory methods to create machine-word-sized values.
 ;;
(value-ns WordFactory
    ;;;
     ; The constant 0, i.e. the word with no bits set.
     ; There is no difference between a signed and unsigned zero.
     ;;
    ; @WordFactoryOperation(opcode = WordFactoryOpcode'ZERO)
    (defn #_"Word" WordFactory'zero-0 []
        (Word'box-1 0)
    )

    ;;;
     ; The null pointer, i.e. the pointer with no bits set.
     ; There is no difference to a signed or unsigned {@link #zero}.
     ;;
    ; @WordFactoryOperation(opcode = WordFactoryOpcode'ZERO)
    #_unused
    (defn #_"Word" WordFactory'nullPointer-0 []
        (Word'box-1 0)
    )

    ;;;
     ; Unsafe conversion from a Java long value to a Word. The parameter is treated as an unsigned
     ; 64-bit value (in contrast to the semantics of a Java long).
     ;;
    ; @WordFactoryOperation(opcode = WordFactoryOpcode'FROM_UNSIGNED)
    (defn #_"Word" WordFactory'unsigned-1l [#_"long" val]
        (Word'box-1 val)
    )

    ;;;
     ; Unsafe conversion from a Java int value to a Word. The parameter is treated as an unsigned
     ; 32-bit value (in contrast to the semantics of a Java int).
     ;;
    ; @WordFactoryOperation(opcode = WordFactoryOpcode'FROM_UNSIGNED)
    (defn #_"Word" WordFactory'unsigned-1i [#_"int" val]
        (Word'box-1 (& val 0xffffffff))
    )

    ;;;
     ; Unsafe conversion from a Java long value to a Word. The parameter is treated as a signed
     ; 64-bit value (unchanged semantics of a Java long).
     ;;
    ; @WordFactoryOperation(opcode = WordFactoryOpcode'FROM_SIGNED)
    #_unused
    (defn #_"Word" WordFactory'signed-1l [#_"long" val]
        (Word'box-1 val)
    )

    ;;;
     ; Unsafe conversion from a Java int value to a Word. The parameter is treated as a signed
     ; 32-bit value (unchanged semantics of a Java int).
     ;;
    ; @WordFactoryOperation(opcode = WordFactoryOpcode'FROM_SIGNED)
    (defn #_"Word" WordFactory'signed-1i [#_"int" val]
        (Word'box-1 val)
    )
)

;;;
 ; The canonical WordFactoryOperation represented by a method in a word type.
 ;;
(value-ns WordFactoryOpcode
    (ยง enum WordFactoryOpcode'ZERO)
    (ยง enum WordFactoryOpcode'FROM_UNSIGNED)
    (ยง enum WordFactoryOpcode'FROM_SIGNED)
)

;;;
 ; The canonical WordOperation represented by a method in the Word class.
 ;;
(value-ns WordOpcode
    (ยง enum WordOpcode'NODE_CLASS)
    (ยง enum WordOpcode'COMPARISON)
    (ยง enum WordOpcode'IS_NULL)
    (ยง enum WordOpcode'IS_NON_NULL)
    (ยง enum WordOpcode'NOT)
    (ยง enum WordOpcode'READ_POINTER)
    (ยง enum WordOpcode'READ_OBJECT)
    (ยง enum WordOpcode'READ_BARRIERED)
    (ยง enum WordOpcode'READ_HEAP)
    (ยง enum WordOpcode'WRITE_POINTER)
    (ยง enum WordOpcode'WRITE_OBJECT)
    (ยง enum WordOpcode'WRITE_BARRIERED)
    (ยง enum WordOpcode'INITIALIZE)
    (ยง enum WordOpcode'TO_RAW_VALUE)
    (ยง enum WordOpcode'FROM_OBJECT)
    (ยง enum WordOpcode'FROM_ADDRESS)
    (ยง enum WordOpcode'TO_OBJECT)
    (ยง enum WordOpcode'TO_OBJECT_NON_NULL)
    (ยง enum WordOpcode'CAS_POINTER)
)

;;;
 ; Base class for AMD64 opcodes.
 ;;
(class-ns AMD64Op []
    (defn #_"AMD64Op" AMD64Op'new-6 [#_"int" prefix1, #_"int" prefix2, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte, #_"AMD64$CPUFeature" feature]
        (merge (AMD64Op'class.)
            (hash-map
                #_"int" :prefix1 prefix1
                #_"int" :prefix2 prefix2
                #_"int" :op op
                #_"boolean" :dstIsByte dstIsByte
                #_"boolean" :srcIsByte srcIsByte
                #_"AMD64$CPUFeature" :feature feature
            )
        )
    )

    (defn #_"void" AMD64Op''emitOpcode-6 [#_"AMD64Op" this, #_"Assembler" asm, #_"OperandSize" size, #_"int" rxb, #_"int" dstEnc, #_"int" srcEnc]
        (when-not (zero? (:prefix1 this))
            (Assembler''emitByte-2 asm, (:prefix1 this))
        )
        (when-not (zero? (:sizePrefix size))
            (Assembler''emitByte-2 asm, (:sizePrefix size))
        )
        (let [
            #_"int" rexPrefix (| rxb (if (= size OperandSize'QWORD) 0x48 0x40))
        ]
            (when (or (not= rexPrefix 0x40) (and (:dstIsByte this) (<= 4 dstEnc)) (and (:srcIsByte this) (<= 4 srcEnc)))
                (Assembler''emitByte-2 asm, rexPrefix)
            )
            (cond
                (< 0xff (:prefix2 this)) (Assembler''emitShort-2 asm, (:prefix2 this))
                (< 0x00 (:prefix2 this)) (Assembler''emitByte-2 asm, (:prefix2 this))
            )
            (Assembler''emitByte-2 asm, (:op this))
        )
        nil
    )
)

;;;
 ; Base class for AMD64 opcodes with immediate operands.
 ;;
(class-ns AMD64ImmOp [AMD64Op]
    (defn #_"AMD64ImmOp" AMD64ImmOp'new-5 [#_"int" prefix, #_"int" op, #_"boolean" immIsByte, #_"boolean" dstIsByte, #_"boolean" srcIsByte]
        (merge (AMD64ImmOp'class.) (AMD64Op'new-6 0, prefix, op, dstIsByte, srcIsByte, nil)
            (hash-map
                #_"boolean" :immIsByte immIsByte
            )
        )
    )

    (defn #_"void" AMD64ImmOp''emitImmediate-4 [#_"AMD64ImmOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"int" imm]
        (if (:immIsByte this)
            (Assembler''emitByte-2 asm, imm)
            (OperandSize'''emitImmediate-3 size, asm, imm)
        )
        nil
    )

    (defn #_"int" AMD64ImmOp''immediateSize-2 [#_"AMD64ImmOp" this, #_"OperandSize" size]
        (if (:immIsByte this) 1 (:bytes size))
    )
)

;;;
 ; Opcodes with operand order of MI.
 ;;
(class-ns AMD64MIOp [AMD64ImmOp, AMD64Op]
    (defn #_"AMD64MIOp" AMD64MIOp'new-1 [#_"int" op]
        (AMD64MIOp'new-5 op, 0, false, false, false)
    )

    (defn #_"AMD64MIOp" AMD64MIOp'new-3 [#_"int" op, #_"int" ext, #_"boolean" immIsByte]
        (AMD64MIOp'new-5 op, ext, immIsByte, false, false)
    )

    (defn #_"AMD64MIOp" AMD64MIOp'new-4 [#_"int" op, #_"boolean" immIsByte, #_"boolean" dstIsByte, #_"boolean" srcIsByte]
        (AMD64MIOp'new-5 op, 0, immIsByte, dstIsByte, srcIsByte)
    )

    (defn #_"AMD64MIOp" AMD64MIOp'new-5 [#_"int" op, #_"int" ext, #_"boolean" immIsByte, #_"boolean" dstIsByte, #_"boolean" srcIsByte]
        (merge (AMD64MIOp'class.) (AMD64ImmOp'new-5 0, op, immIsByte, dstIsByte, srcIsByte)
            (hash-map
                #_"int" :ext ext
            )
        )
    )

    (ยง def #_"AMD64MIOp" AMD64MIOp'MOVB (AMD64MIOp'new-4 0xc6, true, true, true))
    (ยง def #_"AMD64MIOp" AMD64MIOp'MOV  (AMD64MIOp'new-1 0xc7))
    (ยง def #_"AMD64MIOp" AMD64MIOp'TEST (AMD64MIOp'new-1 0xf7))

    (defn #_"void" AMD64MIOp''emit-5r [#_"AMD64MIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2rr nil, dst), 0, (.encoding dst))
        (Assembler''emitModRM-3ir asm, (:ext this), dst)
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )

    (defn #_"void" AMD64MIOp''emit-5a [#_"AMD64MIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"AMD64Address" dst, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2ra nil, dst), 0, 0)
        (Assembler''emitOperandHelper-4i asm, (:ext this), dst, (AMD64ImmOp''immediateSize-2 this, size))
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )
)

;;;
 ; Opcodes with operand order of RMI.
 ;;
(class-ns AMD64RMIOp [AMD64ImmOp, AMD64Op]
    (defn #_"AMD64RMIOp" AMD64RMIOp'new-2 [#_"int" op, #_"boolean" immIsByte]
        (merge (AMD64RMIOp'class.) (AMD64ImmOp'new-5 0, op, immIsByte, false, false))
    )

    (ยง def #_"AMD64RMIOp" AMD64RMIOp'IMUL    (AMD64RMIOp'new-2 0x69, false))
    (ยง def #_"AMD64RMIOp" AMD64RMIOp'IMUL_SX (AMD64RMIOp'new-2 0x6b, true))

    (defn #_"void" AMD64RMIOp''emit-6r [#_"AMD64RMIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2rr dst, src), (.encoding dst), (.encoding src))
        (Assembler''emitModRM-3rr asm, dst, src)
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )

    (defn #_"void" AMD64RMIOp''emit-6a [#_"AMD64RMIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"AMD64Address" src, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2ra dst, src), (.encoding dst), 0)
        (Assembler''emitOperandHelper-4r asm, dst, src, (AMD64ImmOp''immediateSize-2 this, size))
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )
)

;;;
 ; Opcodes with operand order of M.
 ;;
(class-ns AMD64MOp [AMD64Op]
    (defn #_"AMD64MOp" AMD64MOp'new-2 [#_"int" op, #_"int" ext]
        (merge (AMD64MOp'class.) (AMD64Op'new-6 0, 0, op, false, false, nil)
            (hash-map
                #_"int" :ext ext
            )
        )
    )

    (ยง def #_"AMD64MOp" AMD64MOp'NOT  (AMD64MOp'new-2 0xf7, 2))
    (ยง def #_"AMD64MOp" AMD64MOp'NEG  (AMD64MOp'new-2 0xf7, 3))
    (ยง def #_"AMD64MOp" AMD64MOp'MUL  (AMD64MOp'new-2 0xf7, 4))
    (ยง def #_"AMD64MOp" AMD64MOp'IMUL (AMD64MOp'new-2 0xf7, 5))
    (ยง def #_"AMD64MOp" AMD64MOp'DIV  (AMD64MOp'new-2 0xf7, 6))
    (ยง def #_"AMD64MOp" AMD64MOp'IDIV (AMD64MOp'new-2 0xf7, 7))
    (ยง def #_"AMD64MOp" AMD64MOp'INC  (AMD64MOp'new-2 0xff, 0))
    (ยง def #_"AMD64MOp" AMD64MOp'DEC  (AMD64MOp'new-2 0xff, 1))
    (ยง def #_"AMD64MOp" AMD64MOp'PUSH (AMD64MOp'new-2 0xff, 6))
    (ยง def #_"AMD64MOp" AMD64MOp'POP  (AMD64MOp'new-2 0x8f, 0))

    (defn #_"void" AMD64MOp''emit-4r [#_"AMD64MOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2rr nil, dst), 0, (.encoding dst))
        (Assembler''emitModRM-3ir asm, (:ext this), dst)
        nil
    )

    (defn #_"void" AMD64MOp''emit-4a [#_"AMD64MOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"AMD64Address" dst]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2ra nil, dst), 0, 0)
        (Assembler''emitOperandHelper-4i asm, (:ext this), dst, 0)
        nil
    )
)

(class-ns AMD64RROp [AMD64Op]
    (defn #_"AMD64RROp" AMD64RROp'new-6 [#_"int" prefix1, #_"int" prefix2, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte, #_"AMD64$CPUFeature" feature]
        (merge (AMD64RROp'class.) (AMD64Op'new-6 prefix1, prefix2, op, dstIsByte, srcIsByte, feature))
    )
)

;;;
 ; Opcode with operand order of MR.
 ;;
(class-ns AMD64MROp [AMD64RROp, AMD64Op]
    (defn #_"AMD64MROp" AMD64MROp'new-1 [#_"int" op]
        (merge (AMD64MROp'class.) (AMD64RROp'new-6 0, 0, op, false, false, nil))
    )

    (defn #_"AMD64MROp" AMD64MROp'new-3 [#_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte]
        (merge (AMD64MROp'class.) (AMD64RROp'new-6 0, 0, op, dstIsByte, srcIsByte, nil))
    )

    (ยง def #_"AMD64MROp" AMD64MROp'MOVB (AMD64MROp'new-3 0x88, true, true))
    (ยง def #_"AMD64MROp" AMD64MROp'MOV  (AMD64MROp'new-1 0x89))

    (defm AMD64MROp AMD64RROp
        (#_"void" AMD64RROp'''emit-5 [#_"AMD64MROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src]
            (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2rr src, dst), (.encoding src), (.encoding dst))
            (Assembler''emitModRM-3rr asm, src, dst)
            nil
        )
    )

    (defn #_"void" AMD64MROp''emit-5 [#_"AMD64MROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"AMD64Address" dst, #_"Register" src]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2ra src, dst), (.encoding src), 0)
        (Assembler''emitOperandHelper-4r asm, src, dst, 0)
        nil
    )
)

;;;
 ; Opcode with operand order of RM.
 ;;
(class-ns AMD64RMOp [AMD64RROp, AMD64Op]
    (defn #_"AMD64RMOp" AMD64RMOp'new-1 [#_"int" op]
        (merge (AMD64RMOp'class.) (AMD64RROp'new-6 0, 0, op, false, false, nil))
    )

    (defn #_"AMD64RMOp" AMD64RMOp'new-2 [#_"int" prefix, #_"int" op]
        (merge (AMD64RMOp'class.) (AMD64RROp'new-6 0, prefix, op, false, false, nil))
    )

    (defn #_"AMD64RMOp" AMD64RMOp'new-3 [#_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte]
        (merge (AMD64RMOp'class.) (AMD64RROp'new-6 0, 0, op, dstIsByte, srcIsByte, nil))
    )

    (defn #_"AMD64RMOp" AMD64RMOp'new-4b [#_"int" prefix, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte]
        (merge (AMD64RMOp'class.) (AMD64RROp'new-6 0, prefix, op, dstIsByte, srcIsByte, nil))
    )

    (defn #_"AMD64RMOp" AMD64RMOp'new-4f [#_"int" prefix1, #_"int" prefix2, #_"int" op, #_"AMD64$CPUFeature" feature]
        (merge (AMD64RMOp'class.) (AMD64RROp'new-6 prefix1, prefix2, op, false, false, feature))
    )

    (ยง def #_"AMD64RMOp" AMD64RMOp'IMUL   (AMD64RMOp'new-2        0x0f, 0xaf))
    (ยง def #_"AMD64RMOp" AMD64RMOp'BSF    (AMD64RMOp'new-2        0x0f, 0xbc))
    (ยง def #_"AMD64RMOp" AMD64RMOp'BSR    (AMD64RMOp'new-2        0x0f, 0xbd))
    (ยง def #_"AMD64RMOp" AMD64RMOp'POPCNT (AMD64RMOp'new-4f 0xf3, 0x0f, 0xb8,              CPUFeature'POPCNT))
    (ยง def #_"AMD64RMOp" AMD64RMOp'TZCNT  (AMD64RMOp'new-4f 0xf3, 0x0f, 0xbc,              CPUFeature'BMI1))
    (ยง def #_"AMD64RMOp" AMD64RMOp'LZCNT  (AMD64RMOp'new-4f 0xf3, 0x0f, 0xbd,              CPUFeature'LZCNT))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOVZXB (AMD64RMOp'new-4b       0x0f, 0xb6, false, true))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOVZX  (AMD64RMOp'new-2        0x0f, 0xb7))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOVSXB (AMD64RMOp'new-4b       0x0f, 0xbe, false, true))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOVSX  (AMD64RMOp'new-2        0x0f, 0xbf))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOVSXD (AMD64RMOp'new-1              0x63))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOVB   (AMD64RMOp'new-3              0x8a, true,  true))
    (ยง def #_"AMD64RMOp" AMD64RMOp'MOV    (AMD64RMOp'new-1              0x8b))

    ;; TEST is documented as MR operation, but it's symmetric, and using it as RM operation is more convenient.
    (ยง def #_"AMD64RMOp" AMD64RMOp'TESTB  (AMD64RMOp'new-3             0x84, true, true))
    (ยง def #_"AMD64RMOp" AMD64RMOp'TEST   (AMD64RMOp'new-1             0x85))

    (defm AMD64RMOp AMD64RROp
        (#_"void" AMD64RROp'''emit-5 [#_"AMD64RMOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src]
            (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2rr dst, src), (.encoding dst), (.encoding src))
            (Assembler''emitModRM-3rr asm, dst, src)
            nil
        )
    )

    (defn #_"void" AMD64RMOp''emit-5 [#_"AMD64RMOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"AMD64Address" src]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2ra dst, src), (.encoding dst), 0)
        (Assembler''emitOperandHelper-4r asm, dst, src, 0)
        nil
    )
)

;;;
 ; Shift operation with operand order of M1, MC or MI.
 ;;
(class-ns AMD64Shift []
    (defn- #_"AMD64Shift" AMD64Shift'new-1 [#_"int" code]
        (merge (AMD64Shift'class.)
            (hash-map
                #_"AMD64MOp" :m1Op (AMD64MOp'new-2 0xd1, code)
                #_"AMD64MOp" :mcOp (AMD64MOp'new-2 0xd3, code)
                #_"AMD64MIOp" :miOp (AMD64MIOp'new-3 0xc1, code, true)
            )
        )
    )

    (ยง def #_"AMD64Shift" AMD64Shift'ROL (AMD64Shift'new-1 0))
    (ยง def #_"AMD64Shift" AMD64Shift'ROR (AMD64Shift'new-1 1))
    (ยง def #_"AMD64Shift" AMD64Shift'RCL (AMD64Shift'new-1 2))
    (ยง def #_"AMD64Shift" AMD64Shift'RCR (AMD64Shift'new-1 3))
    (ยง def #_"AMD64Shift" AMD64Shift'SHL (AMD64Shift'new-1 4))
    (ยง def #_"AMD64Shift" AMD64Shift'SHR (AMD64Shift'new-1 5))
    (ยง def #_"AMD64Shift" AMD64Shift'SAR (AMD64Shift'new-1 7))
)

;;;
 ; Abstract base class that represents a platform specific address.
 ;;
(class-ns AbstractAddress []
    (defn #_"AbstractAddress" AbstractAddress'new-0 []
        (AbstractAddress'class.)
    )
)

;;;
 ; Represents an address in target machine memory, specified via some combination of a base
 ; register, an index register, a displacement and a scale. Note that the base and index registers
 ; may be a variable that will get a register assigned later by the register allocator.
 ;;
(class-ns AMD64Address [AbstractAddress]
    ;;;
     ; Creates an AMD64Address with given base register, no scaling and no displacement.
     ;
     ; @param base the base register
     ;;
    (defn #_"AMD64Address" AMD64Address'new-1 [#_"Register" base]
        (AMD64Address'new-4 base, Register/None, Scale'Times1, 0)
    )

    ;;;
     ; Creates an AMD64Address with given base register, no scaling and a given displacement.
     ;
     ; @param base the base register
     ; @param displacement the displacement
     ;;
    (defn #_"AMD64Address" AMD64Address'new-2 [#_"Register" base, #_"int" displacement]
        (AMD64Address'new-4 base, Register/None, Scale'Times1, displacement)
    )

    ;;;
     ; Creates an AMD64Address with given base and index registers, scaling and 0 displacement.
     ;
     ; @param base the base register
     ; @param index the index register
     ; @param scale the scaling factor
     ;;
    #_unused
    (defn #_"AMD64Address" AMD64Address'new-3 [#_"Register" base, #_"Register" index, #_"Scale" scale]
        (AMD64Address'new-5 base, index, scale, 0, -1)
    )

    ;;;
     ; Creates an AMD64Address with given base and index registers, scaling and displacement.
     ; This is the most general constructor.
     ;
     ; @param base the base register
     ; @param index the index register
     ; @param scale the scaling factor
     ; @param displacement the displacement
     ;;
    (defn #_"AMD64Address" AMD64Address'new-4 [#_"Register" base, #_"Register" index, #_"Scale" scale, #_"int" displacement]
        (AMD64Address'new-5 base, index, scale, displacement, -1)
    )

    (defn #_"AMD64Address" AMD64Address'new-5 [#_"Register" base, #_"Register" index, #_"Scale" scale, #_"int" displacement, #_"int" instructionStartPosition]
        (merge (AMD64Address'class.) (AbstractAddress'new-0)
            (hash-map
                ;;;
                 ; Base register that defines the start of the address computation.
                 ; If not present, is denoted by Register#None.
                 ;;
                #_"Register" :base base
                ;;;
                 ; Index register, the value of which (possibly scaled by #getScale) is added to #getBase.
                 ; If not present, is denoted by Register#None.
                 ;;
                #_"Register" :index index
                ;;;
                 ; Scaling factor for indexing, dependent on target operand size.
                 ;;
                #_"Scale" :scale scale
                ;;;
                 ; Optional additive displacement.
                 ;;
                #_"int" :displacement displacement
                ;;;
                 ; The start of the instruction, i.e. the value that is used as the key for looking up placeholder
                 ; patching information. Only used for {@link Assembler#getPlaceholder placeholder addresses}.
                 ;;
                #_"int" :instructionStartPosition instructionStartPosition
            )
        )
    )
)

(class-ns AbstractInlineInfo [InlineInfo]
    (defn #_"AbstractInlineInfo" AbstractInlineInfo'new-1 [#_"InvokeNode" invoke]
        (merge (AbstractInlineInfo'class.)
            (hash-map
                #_"InvokeNode" :invoke invoke
            )
        )
    )

    (defm AbstractInlineInfo InlineInfo
        (#_"InvokeNode" InlineInfo'''invoke-1 [#_"AbstractInlineInfo" this]
            (:invoke this)
        )
    )

    (defn #_"EconomicSet<Node>" AbstractInlineInfo'inline-4 [#_"InvokeNode" invoke, #_"ResolvedJavaMethod" concrete, #_"Inlineable" inlineable, #_"boolean" receiverNullCheck]
        (InliningUtil'inlineForCanonicalization-4 invoke, (:graph inlineable), receiverNullCheck, concrete)
    )

    (defm AbstractInlineInfo InlineInfo
        (#_"void" InlineInfo'''populateInlinableElements-4 [#_"AbstractInlineInfo" this, #_"PhaseContext" context, #_"Graph" caller, #_"CanonicalizerPhase" canonicalizer]
            (dotimes [#_"int" i (InlineInfo'''numberOfMethods-1 this)]
                (InlineInfo'''setInlinableElement-3 this, i, (InlineableGraph'new-4 (InlineInfo'''methodAt-2 this, i), (:invoke this), context, canonicalizer))
            )
            nil
        )

        (#_"int" InlineInfo'''determineNodeCount-1 [#_"AbstractInlineInfo" this]
            (loop-when [#_"int" n 0 #_"int" i 0] (< i (InlineInfo'''numberOfMethods-1 this)) => n
                (let [
                    #_"Inlineable" elem (InlineInfo'''inlineableElementAt-2 this, i)
                ]
                    (recur (if (some? elem) (+ n (Inlineable'''getNodeCount-1 elem)) n) (inc i))
                )
            )
        )
    )
)

;;;
 ; Represents an inlining opportunity where the compiler can statically determine a monomorphic
 ; target method and therefore is able to determine the called method exactly.
 ;;
(class-ns ExactInlineInfo [AbstractInlineInfo, InlineInfo]
    (defn #_"ExactInlineInfo" ExactInlineInfo'new-2 [#_"InvokeNode" invoke, #_"ResolvedJavaMethod" concrete]
        (merge (ExactInlineInfo'class.) (AbstractInlineInfo'new-1 invoke)
            (hash-map
                #_"ResolvedJavaMethod" :concrete concrete
                #_"Inlineable" :inlineableElement nil
            )
        )
    )

    (defm ExactInlineInfo InlineInfo
        (#_"EconomicSet<Node>" InlineInfo'''inline-1 [#_"ExactInlineInfo" this]
            (AbstractInlineInfo'inline-4 (:invoke this), (:concrete this), (:inlineableElement this), true)
        )

        (#_"void" InlineInfo'''tryToDevirtualizeInvoke-1 [#_"ExactInlineInfo" this]
            ;; nothing todo, can already be bound statically
            nil
        )

        (#_"int" InlineInfo'''numberOfMethods-1 [#_"ExactInlineInfo" this]
            1
        )

        (#_"ResolvedJavaMethod" InlineInfo'''methodAt-2 [#_"ExactInlineInfo" this, #_"int" index]
            (:concrete this)
        )

        (#_"double" InlineInfo'''probabilityAt-2 [#_"ExactInlineInfo" this, #_"int" index]
            1.0
        )

        (#_"double" InlineInfo'''relevanceAt-2 [#_"ExactInlineInfo" this, #_"int" index]
            1.0
        )

        (#_"Inlineable" InlineInfo'''inlineableElementAt-2 [#_"ExactInlineInfo" this, #_"int" index]
            (:inlineableElement this)
        )

        (#_"void" InlineInfo'''setInlinableElement-3 [#_"ExactInlineInfo" this, #_"int" index, #_"Inlineable" inlineableElement]
            (ยง ass! this (assoc this :inlineableElement inlineableElement))
            nil
        )

        (#_"boolean" InlineInfo'''shouldInline-1 [#_"ExactInlineInfo" this]
            (#_"ResolvedJavaMethod" .shouldBeInlined (:concrete this))
        )
    )
)

(value-ns InliningPolicy
    (def #_"float" InliningPolicy'RelevanceCapForInlining 1.0 #_"f")
    (def #_"float" InliningPolicy'CapInheritedRelevance 1.0 #_"f")

    (defn- #_"double" InliningPolicy'determineInvokeProbability-1 [#_"InlineInfo" info]
        (loop-when [#_"double" probability 0 #_"int" i 0] (< i (InlineInfo'''numberOfMethods-1 info)) => probability
            (let [
                #_"Inlineable" callee (InlineInfo'''inlineableElementAt-2 info, i)
                probability
                    (loop-when-recur [probability probability #_"ISeq" s (seq (Inlineable'''getInvokes-1 callee))]
                                     (some? s)
                                     [(+ probability (Inlineable'''getProbability-2 callee, (first s))) (next s)]
                                  => probability
                    )
            ]
                (recur probability (inc i))
            )
        )
    )

    (defn- #_"double" InliningPolicy'computeMaximumSize-2 [#_"double" relevance, #_"int" configuredMaximum]
        (* configuredMaximum (min InliningPolicy'RelevanceCapForInlining relevance))
    )

    (defn #_"boolean" InliningPolicy'continueInlining-1 [#_"Graph" graph]
        (< (Graph''getNodeCount-1 graph) GraalOptions'maximumDesiredSize)
    )

    (defn #_"boolean" InliningPolicy'isWorthInlining-3 [#_"MethodInvocation" invocation, #_"int" inliningDepth, #_"boolean" fullyProcessed]
        (or GraalOptions'inlineEverything (InlineInfo'''shouldInline-1 (:callee invocation))
            (let [
                #_"int" nodes (InlineInfo'''determineNodeCount-1 (:callee invocation))
            ]
                (or (< nodes GraalOptions'trivialInliningSize)
                    ;; TODO invoked methods that are on important paths but not yet compiled -> will be compiled anyways
                    ;; and it is likely that we are the only caller... might be useful to inline those methods but increases
                    ;; bootstrap time (maybe those methods are also getting queued in the compilation queue concurrently)
                    (and
                        (not (and fullyProcessed (pos? GraalOptions'limitInlinedInvokes) (< GraalOptions'limitInlinedInvokes (InliningPolicy'determineInvokeProbability-1 (:callee invocation)))))
                        (<= nodes (InliningPolicy'computeMaximumSize-2 (:relevance invocation), GraalOptions'maximumInliningSize))
                    )
                )
            )
        )
    )
)

(class-ns NodeList [#_"AbstractList" #_"<Node>", #_"Iterable" #_"<Node>"]
    (defn #_"NodeList" NodeList'new-1 [#_"Node" self]
        (merge (NodeList'class.) (ร AbstractList.)
            (hash-map
                #_"Node" :self self
                #_"Node[]" :nodes (make-array Node'iface 0)
                #_"int" :size 0
                #_"int" :initialSize 0
            )
        )
    )

    (defn #_"NodeList" NodeList'new-2i [#_"Node" self, #_"int" n]
        (merge (NodeList'class.) (ร AbstractList.)
            (hash-map
                #_"Node" :self self
                #_"Node[]" :nodes (make-array Node'iface n)
                #_"int" :size n
                #_"int" :initialSize n
            )
        )
    )

    (defn #_"NodeList" NodeList'new-2s [#_"Node" self, #_"Node*" elements]
        (let [
            #_"int" n (count elements)
        ]
            (when (pos? n) => (NodeList'new-1 self)
                (merge (NodeList'class.) (ร AbstractList.)
                    (hash-map
                        #_"Node" :self self
                        #_"Node[]" :nodes (let [a (make-array Node'iface n) _ (dotimes [#_"int" i n] (aset a i (nth elements i)))] a)
                        #_"int" :size n
                        #_"int" :initialSize n
                    )
                )
            )
        )
    )

    (ยง override! #_"boolean" #_"List." add [#_"NodeList" this, #_"Node" node]
        (let [
            #_"int" n (count (:nodes this))
        ]
            (cond
                (zero? n)
                    (ยง ass! this (assoc this :nodes (make-array Node'iface 2)))
                (= (:size this) n)
                    (let [
                        #_"Node[]" a (make-array Node'iface (inc (* 2 n)))
                    ]
                        (System/arraycopy (:nodes this), 0, a, 0, n)
                        (ยง ass! this (assoc this :nodes a))
                    )
            )
            (aset (:nodes this) (:size this) node)
            (ยง ass! this (update this :size inc))
            (NodeList'''update-3 this, nil, node)
            true
        )
    )

    (ยง override! #_"Node" #_"List." set [#_"NodeList" this, #_"int" index, #_"Node" node]
        (let [
            #_"Node" oldValue (nth (:nodes this) index)
        ]
            (NodeList'''update-3 this, (nth (:nodes this) index), node)
            (aset (:nodes this) index node)
            oldValue
        )
    )

    (defn #_"void" NodeList''initialize-3 [#_"NodeList" this, #_"int" index, #_"Node" node]
        (aset (:nodes this) index node)
        nil
    )

    (defn #_"void" NodeList''copy-2 [#_"NodeList" this, #_"NodeList" other]
        (let [
            #_"Node[]" newNodes (make-array Node'iface (:size other))
        ]
            (System/arraycopy (:nodes other), 0, newNodes, 0, (count newNodes))
            (ยง ass! this (assoc this :nodes newNodes))
            (ยง ass! this (assoc this :size (:size other)))
        )
        nil
    )

    (ยง override! #_"void" #_"List." clear [#_"NodeList" this]
        (dotimes [#_"int" i (:size this)]
            (NodeList'''update-3 this, (nth (:nodes this) i), nil)
        )
        (ยง ass! this (NodeList''clearWithoutUpdate-1 this))
        nil
    )

    (defn #_"this" NodeList''clearWithoutUpdate-1 [#_"NodeList" this]
        (let [
            this (assoc this :nodes (make-array Node'iface 0))
            this (assoc this :size 0)
        ]
            this
        )
    )

    (ยง override! #_"boolean" #_"List." remove [#_"NodeList" this, #_"Object" node]
        (let [
            #_"int" i (loop-when-recur [i 0] (and (< i (:size this)) (not= (nth (:nodes this) i) node)) [(inc i)] => i)
        ]
            (and (< i (:size this))
                (let [
                    #_"Node" oldValue (nth (:nodes this) i)
                ]
                    (loop-when-recur [i (inc i)] (< i (:size this)) [(inc i)]
                        (aset (:nodes this) (dec i) (nth (:nodes this) i))
                    )
                    (ยง ass! this (update this :size dec))
                    (aset (:nodes this) (:size this) nil)
                    (NodeList'''update-3 this, oldValue, nil)
                    true
                )
            )
        )
    )

    (ยง override! #_"Node" #_"List." remove [#_"NodeList" this, #_"int" index]
        (let [
            #_"Node" oldValue (nth (:nodes this) index)
        ]
            (loop-when-recur [#_"int" i (inc index)] (< i (:size this)) [(inc i)]
                (aset (:nodes this) (dec i) (nth (:nodes this) i))
            )
            (ยง ass! this (update this :size dec))
            (aset (:nodes this) (:size this) nil)
            (NodeList'''update-3 this, oldValue, nil)
            oldValue
        )
    )

    (defn #_"boolean" NodeList''replaceFirst-3 [#_"NodeList" this, #_"Node" node, #_"Node" other]
        (loop-when [#_"int" i 0] (< i (:size this)) => false
            (when (= (nth (:nodes this) i) node) => (recur (inc i))
                (aset (:nodes this) i other)
                true
            )
        )
    )

    (ยง override! #_"Iterator<Node>" #_"Iterable." iterator [#_"NodeList" this]
        (let [
            #_"int'" v'i (volatile! 0)
        ]
            (reify Iterator #_"<Node>"
                (#_"boolean" hasNext [#_"Iterator<Node>" _]
                    (< @v'i (:size this))
                )

                (#_"Node" next [#_"Iterator<Node>" _]
                    (let [
                        #_"Node" node (nth (:nodes this) @v'i)
                    ]
                        (vswap! v'i inc)
                        node
                    )
                )
            )
        )
    )

    (ยง override! #_"int" #_"List." indexOf [#_"NodeList" this, #_"Object" node]
        (loop-when [#_"int" i 0] (< i (:size this)) => -1
            (if (= (nth (:nodes this) i) node)
                i
                (recur (inc i))
            )
        )
    )

    (ยง override! #_"boolean" #_"List." contains [#_"NodeList" this, #_"Object" o]
        (not= (#_"List" .indexOf this, o) -1)
    )

    (ยง override! #_"boolean" #_"List." addAll [#_"NodeList" this, #_"Collection<Node>" nodes]
        (doseq [#_"Node" node nodes]
            (#_"List" .add this, node)
        )
        true
    )
)

(class-ns NodeInputList [NodeList, #_"AbstractList" #_"<Node>", #_"Iterable" #_"<Node>"]
    (defn #_"NodeInputList" NodeInputList'new-1 [#_"Node" self]
        (merge (NodeInputList'class.) (NodeList'new-1 self))
    )

    (defn #_"NodeInputList" NodeInputList'new-2i [#_"Node" self, #_"int" initialSize]
        (merge (NodeInputList'class.) (NodeList'new-2i self, initialSize))
    )

    (defn #_"NodeInputList" NodeInputList'new-2s [#_"Node" self, #_"Node*" elements]
        (merge (NodeInputList'class.) (NodeList'new-2s self, elements))
    )

    (defm NodeInputList NodeList
        (#_"void" NodeList'''update-3 [#_"NodeInputList" this, #_"Node" oldNode, #_"Node" newNode]
            (Node''updateUsages-3 (:self this), oldNode, newNode)
            nil
        )
    )
)

(class-ns NodeSuccessorList [NodeList, #_"AbstractList" #_"<Node>", #_"Iterable" #_"<Node>"]
    #_unused
    (defn #_"NodeSuccessorList" NodeSuccessorList'new-1 [#_"Node" self]
        (merge (NodeSuccessorList'class.) (NodeList'new-1 self))
    )

    (defn #_"NodeSuccessorList" NodeSuccessorList'new-2i [#_"Node" self, #_"int" initialSize]
        (merge (NodeSuccessorList'class.) (NodeList'new-2i self, initialSize))
    )

    (defn #_"NodeSuccessorList" NodeSuccessorList'new-2s [#_"Node" self, #_"Node*" elements]
        (merge (NodeSuccessorList'class.) (NodeList'new-2s self, elements))
    )

    (defm NodeSuccessorList NodeList
        (#_"void" NodeList'''update-3 [#_"NodeSuccessorList" this, #_"Node" oldNode, #_"Node" newNode]
            (Node''updatePredecessor-3 (:self this), oldNode, newNode)
            nil
        )
    )
)

;;;
 ; Base class for snippet classes. It provides a cache for SnippetTemplates.
 ;;
(class-ns AbstractTemplates []
    (defn #_"AbstractTemplates" AbstractTemplates'new-0 []
        (AbstractTemplates'class.)
    )

    (defn- #_"Method" AbstractTemplates'findMethod-3 [#_"Class<Snippets>" declaringClass, #_"String" methodName]
        (loop-when [#_"ISeq" s (seq (#_"Class" .getDeclaredMethods declaringClass))] (some? s)
            (let [
                #_"Method" method (first s)
            ]
                (if (= (#_"Method" .getName method) methodName) method (recur (next s)))
            )
        )
    )

    ;;;
     ; Finds the unique method in {@code declaringClass} named {@code methodName} annotated by Snippet
     ; and returns a SnippetInfo value describing it. There must be exactly one snippet method in
     ; {@code declaringClass}.
     ;;
    (defn #_"SnippetInfo" AbstractTemplates'snippet-3* [#_"Class<Snippets>" declaringClass, #_"String" methodName & #_"LocationIdentity..." privateLocations]
        (let [
            #_"ResolvedJavaMethod" method (#_"MetaAccessProvider" .lookupJavaMethod HotSpot'metaAccess, (AbstractTemplates'findMethod-3 declaringClass, methodName))
        ]
            (SnippetInfo'new-2 method, privateLocations)
        )
    )
)

(class-ns BoxingTemplates [AbstractTemplates]
    (defn #_"BoxingTemplates" BoxingTemplates'new-0 []
        (let [
            #_"EnumMap<JavaKind, SnippetInfo>" boxSnippets (EnumMap. JavaKind)
            #_"EnumMap<JavaKind, SnippetInfo>" unboxSnippets (EnumMap. JavaKind)
            _
                (doseq [#_"JavaKind" kind (list JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Int JavaKind/Long JavaKind/Short)]
                    (#_"EnumMap" .put boxSnippets,   kind, (AbstractTemplates'snippet-3* BoxingSnippets, (str (#_"JavaKind" .getJavaName kind) "ValueOf")))
                    (#_"EnumMap" .put unboxSnippets, kind, (AbstractTemplates'snippet-3* BoxingSnippets, (str (#_"JavaKind" .getJavaName kind) "Value")))
                )
        ]
            (merge (BoxingTemplates'class.) (AbstractTemplates'new-0)
                (hash-map
                    #_"EnumMap<JavaKind, SnippetInfo>" :boxSnippets boxSnippets
                    #_"EnumMap<JavaKind, SnippetInfo>" :unboxSnippets unboxSnippets
                )
            )
        )
    )

    (defn #_"void" BoxingTemplates''lower-3b [#_"BoxingTemplates" this, #_"BoxNode" box, #_"LoweringTool" lowerer]
        (let [
            #_"FloatingNode" canonical (BoxingSnippets'canonicalizeBoxing-1 box)
        ]
            ;; if in AOT mode, we don't want to embed boxed constants.
            (if (some? canonical)
                (ยง ass! (:graph box) (Graph''replaceFixedWithFloating-3 (:graph box), box, canonical))
                (let [
                    #_"Arguments" args
                        (Arguments'new-4* (get (:boxSnippets this) (:boxingKind box)), (:guardsStage (:graph box)), (:loweringStage (:phase lowerer)),
                            (Unary'''getValue-1 box)
                        )
                ]
                    (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, box), box, args)
                )
            )
        )
        nil
    )

    (defn #_"void" BoxingTemplates''lower-3u [#_"BoxingTemplates" this, #_"UnboxNode" unbox, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (Arguments'new-4* (get (:unboxSnippets this) (:boxingKind unbox)), (:guardsStage (:graph unbox)), (:loweringStage (:phase lowerer)),
                    (Unary'''getValue-1 unbox)
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, unbox), unbox, args)
        )
        nil
    )
)

(class-ns InstanceOfSnippetsTemplates [AbstractTemplates]
    (defn #_"InstanceOfSnippetsTemplates" InstanceOfSnippetsTemplates'new-0 []
        (merge (InstanceOfSnippetsTemplates'class.) (AbstractTemplates'new-0))
    )

    ;;;
     ; Determines if an {@code instanceof} usage can be materialized.
     ;;
    (defn- #_"boolean" InstanceOfSnippetsTemplates'canMaterialize-1 [#_"Node" usage]
        (condp satisfies? usage
            ConditionalNode (and (satisfies? ConstantNode (:trueValue usage)) (satisfies? ConstantNode (:falseValue usage)))
            IfNode              false
            FixedGuardNode      false
            ShortCircuitOrNode  false
            ConditionAnchorNode false
                                true
        )
    )

    ;;;
     ; Gets the specific replacer object used to replace the usage of an instanceof node with
     ; the result of an instantiated instanceof snippet.
     ;;
    (defn- #_"InstanceOfUsageReplacer" InstanceOfSnippetsTemplates'createReplacer-3 [#_"FloatingNode" instanceOf, #_"Instantiation" instantiation, #_"Node" usage]
        (if (InstanceOfSnippetsTemplates'canMaterialize-1 usage)
            (MaterializationUsageReplacer'new-5 instantiation, (:trueValue usage), (:falseValue usage), instanceOf, usage)
            (let [
                #_"ValueNode" trueValue (ConstantNode'forInt-2 1, (:graph usage))
                #_"ValueNode" falseValue (ConstantNode'forInt-2 0, (:graph usage))
                [trueValue falseValue]
                    (if (and (Instantiation''isInitialized-1 instantiation) (not (and (= trueValue (:trueValue instantiation)) (= falseValue (:falseValue instantiation)))))
                        ;; This code doesn't really care what values are used, so adopt the values from the previous instantiation.
                        [(:trueValue instantiation) (:falseValue instantiation)]
                        [trueValue falseValue]
                    )
            ]
                (NonMaterializationUsageReplacer'new-5 instantiation, trueValue, falseValue, instanceOf, usage)
            )
        )
    )

    (defn #_"void" InstanceOfSnippetsTemplates''lower-3 [#_"InstanceOfSnippetsTemplates" this, #_"FloatingNode" instanceOf, #_"LoweringTool" lowerer]
        (let [
            #_"Instantiation" instantiation (Instantiation'new-0)
        ]
            (doseq [#_"Node" usage (:nodeUsages instanceOf)]
                (let [
                    #_"InstanceOfUsageReplacer" replacer (InstanceOfSnippetsTemplates'createReplacer-3 instanceOf, instantiation, usage)
                ]
                    (if (Instantiation''isInitialized-1 instantiation)
                        ;; no need to re-instantiate the snippet - just re-use its result
                        (InstanceOfUsageReplacer'''replaceUsingInstantiation-1 replacer)
                        (let [
                            #_"Arguments" args (InstanceOfSnippetsTemplates''makeArguments-3 this, replacer, lowerer)
                        ]
                            (SnippetTemplate''instantiate-5 (SnippetTemplate'new-2 args, instanceOf), instanceOf, replacer, lowerer, args)
                        )
                    )
                )
            )
            (when-not (Node''isDeleted-1 instanceOf)
                (GraphUtil'killWithUnusedFloatingInputs-1 instanceOf)
            )
        )
        nil
    )
)

(class-ns InstanceOfTemplates [InstanceOfSnippetsTemplates, AbstractTemplates]
    (defn #_"InstanceOfTemplates" InstanceOfTemplates'new-0 []
        (merge (InstanceOfTemplates'class.) (InstanceOfSnippetsTemplates'new-0)
            (hash-map
                #_"SnippetInfo" :instanceofExact (AbstractTemplates'snippet-3* InstanceOfSnippets, "instanceofExact")
                #_"SnippetInfo" :instanceofPrimary (AbstractTemplates'snippet-3* InstanceOfSnippets, "instanceofPrimary")
                #_"SnippetInfo" :instanceofSecondary (AbstractTemplates'snippet-3* InstanceOfSnippets, "instanceofSecondary", NamedLocationIdentity'SECONDARY_SUPER_CACHE)
                #_"SnippetInfo" :instanceofDynamic (AbstractTemplates'snippet-3* InstanceOfSnippets, "instanceofDynamic", NamedLocationIdentity'SECONDARY_SUPER_CACHE)
            )
        )
    )

    ;;;
     ; Gets the arguments used to retrieve and instantiate an instanceof snippet template.
     ;;
    (defn #_"Arguments" InstanceOfSnippetsTemplates''makeArguments-3 [#_"InstanceOfTemplates" this, #_"InstanceOfUsageReplacer" replacer, #_"LoweringTool" lowerer]
        (condp satisfies? (:instanceOf replacer)
            InstanceOfNode
                (let [
                    #_"InstanceOfNode" instanceOf (:instanceOf replacer)
                    #_"ValueNode" object (Unary'''getValue-1 instanceOf)
                    #_"TypeReference" targetType (InstanceOfNode''type-1 instanceOf)
                    #_"HotSpotResolvedObjectType" type (:type targetType)
                    ;; If non-nil, this is the only type that could pass the type check, because the target of the type check is a final
                    ;; class or has been speculated to be a final class and this value is the only concrete subclass of the target type.
                    #_"ResolvedJavaType" exact (when (and (some? targetType) (:exactReference targetType)) type)
                    #_"ConstantNode" hub (ConstantNode'forConstant-3s KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass type), (:graph instanceOf))
                    #_"Graph" graph (:graph instanceOf)
                ]
                    (cond
                        (some? exact)
                            (Arguments'new-4* (:instanceofExact this), (:guardsStage graph), (:loweringStage (:phase lowerer)),
                                object,
                                (ConstantNode'forConstant-3s KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass exact), graph),
                                (:trueValue replacer),
                                (:falseValue replacer)
                            )
                        (#_"HotSpotResolvedObjectType" .isPrimaryType type)
                            (Arguments'new-4* (:instanceofPrimary this), (:guardsStage graph), (:loweringStage (:phase lowerer)),
                                hub,
                                object,
                                (#_"HotSpotResolvedObjectType" .superCheckOffset type),
                                (:trueValue replacer),
                                (:falseValue replacer)
                            )
                        :else
                            (Arguments'new-4* (:instanceofSecondary this), (:guardsStage graph), (:loweringStage (:phase lowerer)),
                                hub,
                                object,
                                (:trueValue replacer),
                                (:falseValue replacer)
                            )
                    )
                )
            InstanceOfDynamicNode
                (let [
                    #_"InstanceOfDynamicNode" instanceOf (:instanceOf replacer)
                    #_"ValueNode" object (:y instanceOf)
                ]
                    (Arguments'new-4* (:instanceofDynamic this), (:guardsStage (:graph instanceOf)), (:loweringStage (:phase lowerer)),
                        (:x instanceOf),
                        object,
                        (:trueValue replacer),
                        (:falseValue replacer),
                        (:allow-nil? instanceOf)
                    )
                )
        )
    )
)

(class-ns MonitorTemplates [AbstractTemplates]
    (defn #_"MonitorTemplates" MonitorTemplates'new-1 [#_"boolean" useFastLocking]
        (merge (MonitorTemplates'class.) (AbstractTemplates'new-0)
            (hash-map
                #_"SnippetInfo" :monitorenter (AbstractTemplates'snippet-3* MonitorSnippets, "monitorenter")
                #_"SnippetInfo" :monitorexit (AbstractTemplates'snippet-3* MonitorSnippets, "monitorexit")
                #_"SnippetInfo" :monitorenterStub (AbstractTemplates'snippet-3* MonitorSnippets, "monitorenterStub")
                #_"SnippetInfo" :monitorexitStub (AbstractTemplates'snippet-3* MonitorSnippets, "monitorexitStub")
                #_"boolean" :useFastLocking useFastLocking
            )
        )
    )

    (defn #_"void" MonitorTemplates''lower-3i [#_"MonitorTemplates" this, #_"RawMonitorEnterNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (if (:useFastLocking this)
                    (Arguments'new-4* (:monitorenter this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                        (:object node),
                        (:hub node),
                        (:lockDepth (:monitorId node))
                    )
                    (Arguments'new-4* (:monitorenterStub this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                        (:object node),
                        (:lockDepth (:monitorId node))
                    )
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )

    (defn #_"void" MonitorTemplates''lower-3o [#_"MonitorTemplates" this, #_"MonitorExitNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (Arguments'new-4* (if (:useFastLocking this) (:monitorexit this) (:monitorexitStub this)), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                    (:object node),
                    (:lockDepth (:monitorId node))
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )
)

(class-ns NewObjectTemplates [AbstractTemplates]
    (defn #_"NewObjectTemplates" NewObjectTemplates'new-0 []
        (merge (NewObjectTemplates'class.) (AbstractTemplates'new-0)
            (hash-map
                #_"SnippetInfo" :allocateInstance (AbstractTemplates'snippet-3* NewObjectSnippets, "allocateInstance", NamedLocationIdentity'MARK_WORD, NamedLocationIdentity'HUB_WRITE, NamedLocationIdentity'TLAB_TOP, NamedLocationIdentity'TLAB_END)
                #_"SnippetInfo" :allocateArray (AbstractTemplates'snippet-3* NewObjectSnippets, "allocateArray", NamedLocationIdentity'MARK_WORD, NamedLocationIdentity'HUB_WRITE, NamedLocationIdentity'TLAB_TOP, NamedLocationIdentity'TLAB_END)
            )
        )
    )

    (defn #_"void" NewObjectTemplates''lower-3i [#_"NewObjectTemplates" this, #_"NewInstanceNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"HotSpotResolvedObjectType" type (:instanceClass node)
            #_"Arguments" args
                (Arguments'new-4* (:allocateInstance this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                    (#_"HotSpotResolvedObjectType" .instanceSize type),
                    (ConstantNode'forConstant-3s KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass type), (:graph node)),
                    (#_"HotSpotResolvedObjectType" .prototypeMarkWord type)
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )

    (defn #_"void" NewObjectTemplates''lower-3a [#_"NewObjectTemplates" this, #_"NewArrayNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"HotSpotResolvedObjectType" arrayType (#_"ResolvedJavaType" .getArrayClass (:elementType node))
            #_"JavaKind" elementKind (#_"ResolvedJavaType" .getJavaKind (:elementType node))
            #_"ValueNode" length (ArrayLengthProvider'''length-1 node)
            #_"Arguments" args
                (Arguments'new-4* (:allocateArray this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                    (ConstantNode'forConstant-3s KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass arrayType), (:graph node)),
                    (if (Node''isAlive-1 length) length (Graph''addOrUniqueWithInputs-2 (:graph node), length)),
                    (#_"HotSpotResolvedObjectType" .prototypeMarkWord arrayType),
                    (HotSpot'arrayBaseOffset-1 elementKind),
                    (CodeUtil/log2 (HotSpot'arrayIndexScale-1 elementKind)),
                    (satisfies? ConstantNode length)
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )
)

(class-ns UnsafeLoadTemplates [AbstractTemplates]
    (defn #_"UnsafeLoadTemplates" UnsafeLoadTemplates'new-0 []
        (merge (UnsafeLoadTemplates'class.) (AbstractTemplates'new-0)
            (hash-map
                #_"SnippetInfo" :lowerUnsafeLoad (AbstractTemplates'snippet-3* UnsafeLoadSnippets, "lowerUnsafeLoad")
            )
        )
    )

    (defn #_"void" UnsafeLoadTemplates''lower-3 [#_"UnsafeLoadTemplates" this, #_"RawLoadNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (Arguments'new-4* (:lowerUnsafeLoad this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                    (:object node),
                    (:offset node)
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )
)

(class-ns WriteBarrierTemplates [AbstractTemplates]
    (defn #_"WriteBarrierTemplates" WriteBarrierTemplates'new-1 [#_"CompressEncoding" oopEncoding]
        (merge (WriteBarrierTemplates'class.) (AbstractTemplates'new-0)
            (hash-map
                #_"SnippetInfo" :serialImpreciseWriteBarrier (AbstractTemplates'snippet-3* WriteBarrierSnippets, "serialImpreciseWriteBarrier", NamedLocationIdentity'GC_CARD)
                #_"SnippetInfo" :serialPreciseWriteBarrier (AbstractTemplates'snippet-3* WriteBarrierSnippets, "serialPreciseWriteBarrier", NamedLocationIdentity'GC_CARD)
                #_"SnippetInfo" :g1PreWriteBarrier (AbstractTemplates'snippet-3* WriteBarrierSnippets, "g1PreWriteBarrier", NamedLocationIdentity'GC_INDEX, NamedLocationIdentity'GC_LOG)
                #_"SnippetInfo" :g1ReferentReadBarrier (AbstractTemplates'snippet-3* WriteBarrierSnippets, "g1PreWriteBarrier", NamedLocationIdentity'GC_INDEX, NamedLocationIdentity'GC_LOG)
                #_"SnippetInfo" :g1PostWriteBarrier (AbstractTemplates'snippet-3* WriteBarrierSnippets, "g1PostWriteBarrier", NamedLocationIdentity'GC_CARD, NamedLocationIdentity'GC_INDEX, NamedLocationIdentity'GC_LOG)
                #_"CompressEncoding" :oopEncoding oopEncoding
            )
        )
    )

    (ยง defn #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"SerialWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (if (:precise? node)
                    (Arguments'new-4* (:serialPreciseWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                        (:address node)
                    )
                    (Arguments'new-4* (:serialImpreciseWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                        (AddressNode'''getBase-1 (:address node))
                    )
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )

    (ยง defn #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1PreWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" expected (:value node)
            expected
                (when (and (some? expected) (satisfies? NarrowOopStamp (:stamp expected))) => expected
                    (HotSpotCompressionNode'uncompress-2 expected, (:oopEncoding this))
                )
            #_"Arguments" args
                (Arguments'new-4* (:g1PreWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                    (:address node),
                    (when (satisfies? OffsetAddressNode (:address node)) (AddressNode'''getBase-1 (:address node))),
                    expected,
                    (:doLoad node),
                    (:nullCheck node)
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )

    (ยง defn #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1ReferentFieldReadBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" expected (G1ReferentFieldReadBarrier''getExpectedObject-1 node)
            expected
                (when (and (some? expected) (satisfies? NarrowOopStamp (:stamp expected))) => expected
                    (HotSpotCompressionNode'uncompress-2 expected, (:oopEncoding this))
                )
            #_"Arguments" args
                (Arguments'new-4* (:g1ReferentReadBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                    (:address node),
                    (when (satisfies? OffsetAddressNode (:address node)) (AddressNode'''getBase-1 (:address node))),
                    expected,
                    (:doLoad node),
                    false
                )
        ]
            (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
        )
        nil
    )

    (ยง defn #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1PostWriteBarrier" node, #_"LoweringTool" lowerer]
        (when-not (:always-nil? node) => (Graph''removeFixed-2 (:graph node), node)
            (let [
                #_"ValueNode" value
                    (when (satisfies? NarrowOopStamp (:stamp (:value node))) => (:value node)
                        (HotSpotCompressionNode'uncompress-2 (:value node), (:oopEncoding this))
                    )
                #_"Arguments" args
                    (Arguments'new-4* (:g1PostWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)),
                        (:address node),
                        (when (satisfies? OffsetAddressNode (:address node)) (AddressNode'''getBase-1 (:address node))),
                        value,
                        (:precise? node)
                    )
            ]
                (SnippetTemplate''instantiate-3 (SnippetTemplate'new-2 args, node), node, args)
            )
        )
        nil
    )
)

(class-ns AddressLowering []
    (def- #_"int" AddressLowering'ADDRESS_BITS 64)
    (def- #_"int" AddressLowering'INT_BITS 32)

    (defn #_"AddressLowering" AddressLowering'new-1 [#_"Register" heapBaseRegister]
        (merge (AddressLowering'class.)
            (hash-map
                #_"long" :heapBase (:base HotSpot'oopEncoding)
                #_"Register" :heapBaseRegister (if (zero? (:base HotSpot'oopEncoding)) nil heapBaseRegister)
            )
        )
    )

    (defn- #_"ValueNode" AddressLowering'improveConstDisp-6 [#_"AMD64AddressNode" address, #_"ValueNode" original, #_"JavaConstant" constant, #_"ValueNode" other, #_"int" shift, #_"boolean" negateExtractedDisplacement]
        (when (#_"JavaKind" .isNumericInteger (#_"JavaConstant" .getJavaKind constant)) => original
            (when (AddressLowering'updateDisplacement-3 address, (<< (#_"JavaConstant" .asLong constant) shift), negateExtractedDisplacement) => original
                other
            )
        )
    )

    (defn- #_"ValueNode" AddressLowering'improveInput-4 [#_"AMD64AddressNode" address, #_"ValueNode" node, #_"int" shift, #_"boolean" negateExtractedDisplacement]
        (when (some? node)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 node)
            ]
                (cond
                    (some? constant)
                        (AddressLowering'improveConstDisp-6 address, node, constant, nil, shift, negateExtractedDisplacement)
                    ;; We can't swallow zero-extends because of multiple reasons:
                    ;;
                    ;; (a) we might encounter something like the following: ZeroExtend(Add(negativeValue, positiveValue)).
                    ;; If we swallow the zero-extend in this case and subsequently optimize the add, we might end up with a negative value
                    ;; that has less than 64 bits in base or index. Such a value would require sign extension instead of zero-extension,
                    ;; but the backend can only do (implicit) zero-extension by using a larger register (e.g. rax instead of eax).
                    ;;
                    ;; (b) our backend does not guarantee that the upper half of a 64-bit register equals 0 if a 32-bit value is stored in there.
                    ;;
                    ;; (c) we also can't swallow zero-extends with less than 32 bits as most of these values are immediately sign-extended
                    ;; to 32 bit by the backend (therefore, the subsequent implicit zero-extension to 64 bit won't do what we expect).
                    (and (satisfies? IntegerStamp (:stamp node)) (satisfies? AddNode node))
                        (cond
                            (satisfies? ConstantNode (:x node))
                                (AddressLowering'improveConstDisp-6 address, node, (ValueNode''asJavaConstant-1 (:x node)), (:y node), shift, negateExtractedDisplacement)
                            (satisfies? ConstantNode (:y node))
                                (AddressLowering'improveConstDisp-6 address, node, (ValueNode''asJavaConstant-1 (:y node)), (:x node), shift, negateExtractedDisplacement)
                            :else
                                node
                        )
                    :else
                        node
                )
            )
        )
    )

    (defn #_"boolean" AddressLowering'updateDisplacement-3 [#_"AMD64AddressNode" address, #_"long" displacementDelta, #_"boolean" negateDelta]
        (let [
            #_"long" disp (+ (:displacement address) (* displacementDelta (if negateDelta -1 1)))
        ]
            (and (NumUtil'isInt-1 disp)
                (do
                    (ยง ass! address (AMD64AddressNode''setDisplacement-2 address, (int disp)))
                    true
                )
            )
        )
    )

    (defn- #_"ValueNode" AddressLowering'considerNegation-3 [#_"Graph" graph, #_"ValueNode" value, #_"boolean" negate?]
        (if (and negate? (some? value)) (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 value)) value)
    )

    (defn- #_"boolean" AddressLowering''improveNegation-5 [#_"AddressLowering" this, #_"Graph" graph, #_"AMD64AddressNode" addr, #_"boolean" o'baseNegated, #_"boolean" o'indexNegated]
        (let [
            #_"ValueNode" o'base (AddressNode'''getBase-1 addr)
            #_"ValueNode" o'index (AddressNode'''getIndex-1 addr)
            #_"boolean" baseNegated o'baseNegated
            #_"boolean" indexNegated o'indexNegated
            [baseNegated indexNegated]
                (when (satisfies? NegateNode (AddressNode'''getBase-1 addr)) => [baseNegated indexNegated]
                    (ยง ass! addr (AMD64AddressNode''setBase-2 addr, (Unary'''getValue-1 (AddressNode'''getBase-1 addr))))
                    [(not baseNegated) indexNegated]
                )
            [baseNegated indexNegated]
                (when (satisfies? NegateNode (AddressNode'''getIndex-1 addr)) => [baseNegated indexNegated]
                    (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (Unary'''getValue-1 (AddressNode'''getIndex-1 addr))))
                    [baseNegated (not indexNegated)]
                )
        ]
            (and (not (and (= baseNegated o'baseNegated) (= indexNegated o'indexNegated)))
                (let [
                    #_"ValueNode" base (AddressNode'''getBase-1 addr)
                    #_"ValueNode" index (AddressNode'''getIndex-1 addr)
                    #_"boolean" improved? (AddressLowering''improve-5 this, graph, addr, baseNegated, indexNegated)
                ]
                    (when-not (= baseNegated o'baseNegated)
                        (cond
                            (= base (AddressNode'''getBase-1 addr))
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, o'base))
                            (some? (AddressNode'''getBase-1 addr))
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 (AddressNode'''getBase-1 addr)))))
                        )
                    )
                    (when-not (= indexNegated o'indexNegated)
                        (cond
                            (= index (AddressNode'''getIndex-1 addr))
                                (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, o'index))
                            (some? (AddressNode'''getIndex-1 addr))
                                (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 (AddressNode'''getIndex-1 addr)))))
                        )
                    )
                    improved?
                )
            )
        )
    )

    (defn #_"boolean" AddressLowering''improveUncompression-4 [#_"AddressLowering" this, #_"AMD64AddressNode" addr, #_"CompressionNode" compression, #_"ValueNode" other]
        (let [
            #_"CompressEncoding" encoding (CompressionNode''getEncoding-1 compression)
            #_"Scale" scale (Scale'fromShift-1 (:shift encoding))
        ]
            (and (some? scale)
                (cond
                    (and (some? (:heapBaseRegister this)) (= (:base encoding) (:heapBase this)))
                        (and (nil? other)
                            (do
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, (Graph''add-2 (:graph compression), (HeapBaseNode'new-1 (:heapBaseRegister this)))))
                                true
                            )
                        )
                    (not (zero? (:base encoding)))
                        (and (AddressLowering'updateDisplacement-3 addr, (:base encoding), false)
                            (do
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, other))
                                true
                            )
                        )
                    :else
                        (do
                            (ยง ass! addr (AMD64AddressNode''setBase-2 addr, other))
                            true
                        )
                )
                (do
                    (ยง ass! addr (AMD64AddressNode''setScale-2 addr, scale))
                    (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (Unary'''getValue-1 compression)))
                    true
                )
            )
        )
    )

    (defn- #_"boolean" AddressLowering''tryToImproveUncompression-4 [#_"AddressLowering" this, #_"AMD64AddressNode" addr, #_"ValueNode" value, #_"ValueNode" other]
        (and (satisfies? CompressionNode value) (= (:op value) CompressionOp'Uncompress)
            (AddressLowering''improveUncompression-4 this, addr, value, other)
        )
    )

    ;;;
     ; Tries to optimize addresses so that they match the AMD64-specific addressing mode better (base + index * scale + displacement).
     ;
     ; @param addr the address that should be optimized
     ; @param isBaseNegated determines if the address base is negated - if so, all values that are extracted from the base will be negated as well
     ; @param isIndexNegated determines if the index is negated - if so, all values that are extracted from the index will be negated as well
     ; @return true if the address was modified
     ;;
    (defn #_"boolean" AddressLowering''improve-5 [#_"AddressLowering" this, #_"Graph" graph, #_"AMD64AddressNode" addr, #_"boolean" isBaseNegated, #_"boolean" isIndexNegated]
        (let [
            #_"ValueNode" base (AddressNode'''getBase-1 addr)
            #_"ValueNode" index (AddressNode'''getIndex-1 addr)
        ]
            (or
                (let [
                    #_"ValueNode" newBase (AddressLowering'improveInput-4 addr, base, 0, isBaseNegated)
                ]
                    (and (not= newBase base)
                        (do
                            (ยง ass! addr (AMD64AddressNode''setBase-2 addr, newBase))
                            true
                        )
                    )
                )

                (let [
                    #_"ValueNode" newIndex (AddressLowering'improveInput-4 addr, index, (:shift (:scale addr)), isIndexNegated)
                ]
                    (and (not= newIndex index)
                        (do
                            (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, newIndex))
                            true
                        )
                    )
                )

                (and (satisfies? LeftShiftNode index) (satisfies? ConstantNode (:y index))
                    (let [
                        #_"int" amount (+ (:shift (:scale addr)) (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y index))))
                        #_"Scale" scale (Scale'fromShift-1 amount)
                    ]
                        (and (some? scale)
                            (do
                                (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (:x index)))
                                (ยง ass! addr (AMD64AddressNode''setScale-2 addr, scale))
                                true
                            )
                        )
                    )
                )

                (and (= (:scale addr) Scale'Times1)
                    (or
                        (and (nil? index) (satisfies? AddNode base)
                            (do
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, (:x base)))
                                (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (AddressLowering'considerNegation-3 graph, (:y base), isBaseNegated)))
                                true
                            )
                        )

                        (and (nil? base) (satisfies? AddNode index)
                            (do
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, (AddressLowering'considerNegation-3 graph, (:x index), isIndexNegated)))
                                (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (:y index)))
                                true
                            )
                        )

                        (and (satisfies? LeftShiftNode base) (not (satisfies? LeftShiftNode index))
                            (do
                                (ยง ass! addr (AMD64AddressNode''setBase-2 addr, (AddressLowering'considerNegation-3 graph, index, (not= isIndexNegated isBaseNegated))))
                                (ยง ass! addr (AMD64AddressNode''setIndex-2 addr, (AddressLowering'considerNegation-3 graph, base, (not= isIndexNegated isBaseNegated))))
                                true
                            )
                        )
                    )
                )

                (AddressLowering''improveNegation-5 this, graph, addr, isBaseNegated, isIndexNegated)

                (and (not isBaseNegated) (not isIndexNegated) (= (:scale addr) Scale'Times1)
                    (or (AddressLowering''tryToImproveUncompression-4 this, addr, index, base)
                        (AddressLowering''tryToImproveUncompression-4 this, addr, base, index)
                    )
                )
            )
        )
    )

    (defn #_"AddressNode" AddressLowering''lower-3 [#_"AddressLowering" this, #_"ValueNode" base, #_"ValueNode" offset]
        (let [
            #_"AMD64AddressNode" addr (AMD64AddressNode'new-2 base, offset)
        ]
            (while (AddressLowering''improve-5 this, (:graph base), addr, false, false)
                nil
            )
            (Graph''add-2 (:graph base), addr)
        )
    )

    ;;;
     ; Create a sign extend for {@code input}, or zero extend if {@code input} can be proven positive.
     ;;
    (defn- #_"ValueNode" AddressLowering'signExtend-2 [#_"ValueNode" input, #_"LoopEx" _loop]
        (let [
            #_"Graph" graph (:graph input)
        ]
            (when (satisfies? PhiNode input)
                (let [
                    #_"EconomicMap<Node, InductionVariable>" ivs (LoopEx''getInductionVariables-1 _loop)
                    #_"InductionVariable" inductionVariable (get ivs input)
                ]
                    (when (and (some? inductionVariable) (satisfies? BasicInductionVariable inductionVariable))
                        (let [
                            #_"CountedLoopInfo" countedLoopInfo (:counted _loop)
                            #_"IntegerStamp" initStamp (:stamp (InductionVariable'''initNode-1 inductionVariable))
                        ]
                            (when (IntegerStamp''isPositive-1 initStamp)
                                (when (InductionVariable'''isConstantExtremum-1 inductionVariable)
                                    (let [
                                        #_"long" init (InductionVariable'''constantInit-1 inductionVariable)
                                        #_"long" stride (InductionVariable'''constantStride-1 inductionVariable)
                                        #_"long" extremum (InductionVariable'''constantExtremum-1 inductionVariable)
                                    ]
                                        (when (and (<= 0 init) (<= 0 extremum))
                                            (let [
                                                #_"long" shortestTrip (inc (quot (- extremum init) stride))
                                            ]
                                                (when (= (CountedLoopInfo''constantMaxTripCount-1 countedLoopInfo) shortestTrip)
                                                    (ยง return (Graph''add-2 graph, (ZeroExtendNode'new-4 input, AddressLowering'INT_BITS, AddressLowering'ADDRESS_BITS, true)))
                                                )
                                            )
                                        )
                                    )
                                )
                                (when (and (= (:iv countedLoopInfo) inductionVariable) (= (InductionVariable'''direction-1 inductionVariable) :Direction'Up) (some? (CountedLoopInfo''getOverFlowGuard-1 countedLoopInfo)))
                                    (ยง return (Graph''add-2 graph, (ZeroExtendNode'new-4 input, AddressLowering'INT_BITS, AddressLowering'ADDRESS_BITS, true)))
                                )
                            )
                        )
                    )
                )
            )
            (Graph''maybeAddOrUnique-2 (:graph input), (SignExtendNode'create-2 input, AddressLowering'ADDRESS_BITS))
        )
    )

    ;;;
     ; Given that Add(a, cst) is always positive, performs the following: ZeroExtend(Add(a, cst)) -> Add(SignExtend(a), SignExtend(cst)).
     ;;
    (defn- #_"void" AddressLowering'optimizeAdd-4 [#_"ZeroExtendNode" node, #_"ConstantNode" constant, #_"ValueNode" other, #_"LoopEx" _loop]
        (ยง ass! node (Node''replaceAtUsages-2 node, (Graph''add-2 (:graph node), (AddNode'new-2 (AddressLowering'signExtend-2 other, _loop), (ConstantNode'forLong-2 (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 constant)), (:graph node))))))
        nil
    )

    (defn- #_"boolean" AddressLowering'applicableToImplicitZeroExtend-1 [#_"ZeroExtendNode" node]
        (and (:inputAlwaysPositive node) (= (IntegerConvertNode''getInputBits-1 node) AddressLowering'INT_BITS) (= (IntegerConvertNode''getResultBits-1 node) AddressLowering'ADDRESS_BITS))
    )

    (defn- #_"void" AddressLowering'tryOptimize-2 [#_"OffsetAddressNode" offsetAddress, #_"LoopEx" _loop]
        (loop-when [#_"InductionVariable" iv (get (LoopEx''getInductionVariables-1 _loop) (:offset offsetAddress))] (some? iv)
            (when (satisfies? DerivedInductionVariable iv)
                (let [
                    #_"ValueNode" value (InductionVariable'''valueNode-1 iv)
                ]
                    (when-not (Node''isDeleted-1 value)
                        (when (and (satisfies? ZeroExtendNode value) (AddressLowering'applicableToImplicitZeroExtend-1 value))
                            (let [
                                #_"ValueNode" input (Unary'''getValue-1 value)
                            ]
                                (when (satisfies? AddNode input)
                                    (cond
                                        (satisfies? ConstantNode (:x input)) (AddressLowering'optimizeAdd-4 value, (:x input), (:y input), _loop)
                                        (satisfies? ConstantNode (:y input)) (AddressLowering'optimizeAdd-4 value, (:y input), (:x input), _loop)
                                    )
                                )
                            )
                        )
                        (recur (DerivedInductionVariable''getBase-1 iv))
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AddressLowering'preProcess-1 [#_"Graph" graph]
        (when (Graph''hasLoops-1 graph)
            (let [
                #_"LoopsData" loopsData (LoopsData'new-1 graph)
            ]
                (LoopsData''detectedCountedLoops-1 loopsData)
                (doseq [#_"LoopEx" _loop (LoopsData''countedLoops-1 loopsData)]
                    (doseq [#_"OffsetAddressNode" offsetAdressNode (filter #(satisfies? OffsetAddressNode %) (LoopFragment'''nodes-1 (LoopEx''whole-1 _loop)))]
                        (AddressLowering'tryOptimize-2 offsetAdressNode, _loop)
                    )
                )
            )
        )
        nil
    )

    (defn- #_"ValueNode" AddressLowering'tryImplicitZeroExtend-1 [#_"ValueNode" input]
        (when (and (satisfies? ZeroExtendNode input) (AddressLowering'applicableToImplicitZeroExtend-1 input)) => input
            (Unary'''getValue-1 input)
        )
    )

    (defn #_"AddressNode" AddressLowering'postProcess-1 [#_"AddressNode" address]
        ;; Allow implicit zero extend for always positive input. This assumes
        ;; that the upper bits of the operand is zero out by the backend.
        (let [
            address (AMD64AddressNode''setBase-2 address, (AddressLowering'tryImplicitZeroExtend-1 (AddressNode'''getBase-1 address)))
            address (AMD64AddressNode''setIndex-2 address, (AddressLowering'tryImplicitZeroExtend-1 (AddressNode'''getIndex-1 address)))
        ]
            address
        )
    )
)

(class-ns AddressLoweringPhase [Phase]
    (defn #_"AddressLoweringPhase" AddressLoweringPhase'new-1 [#_"AddressLowering" lowering]
        (merge (AddressLoweringPhase'class.)
            (hash-map
                #_"AddressLowering" :lowering lowering
            )
        )
    )

    (defm AddressLoweringPhase Phase
        (#_"Graph" Phase'''run-3 [#_"AddressLoweringPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (AddressLowering'preProcess-1 graph)
            (loop-when-recur [#_"ISeq" s (seq (Graph''getNodes-1 graph))] (some? s) [(next s)]
                (let [
                    #_"Node" node (first s)
                ]
                    (when (satisfies? OffsetAddressNode node)
                        (let [
                            #_"AddressNode" lowered (AddressLowering''lower-3 (:lowering this), (AddressNode'''getBase-1 node), (:offset node))
                        ]
                            (ยง ass! node (Node''replaceAtUsages-2 node, (AddressLowering'postProcess-1 lowered)))
                            (GraphUtil'killWithUnusedFloatingInputs-1 node)
                        )
                    )
                )
            )
            graph
        )
    )
)

(class-ns AllocatableRegisters []
    (defn #_"AllocatableRegisters" AllocatableRegisters'new-3 [#_"RegisterArray" allocatableRegisters, #_"int" minRegisterNumber, #_"int" maxRegisterNumber]
        (merge (AllocatableRegisters'class.)
            (hash-map
                #_"Register[]" :allocatableRegisters (#_"RegisterArray" .toArray allocatableRegisters)
                #_"int" :minRegisterNumber minRegisterNumber
                #_"int" :maxRegisterNumber maxRegisterNumber
            )
        )
    )
)

;;;
 ; Represents a value that is yet to be bound to a machine location (such as a RegisterValue or StackSlot)
 ; by a register allocator.
 ;;
(class-ns Variable [#_"AllocatableValue"]
    (defn #_"Variable" Variable'new-2 [#_"ValueKind" kind, #_"int" index]
        (merge (Variable'class.) (AllocatableValue. kind)
            (hash-map
                ;;;
                 ; The identifier of the variable. This is a non-zero index in a contiguous 0-based name space.
                 ;;
                #_"int" :index index
            )
        )
    )
)

;;;
 ; VirtualStackSlots are stack slots that are not yet fixed to specific frame offset. They
 ; are replaced by real StackSlots with a fixed position in the frame before code emission.
 ;;
(class-ns VirtualStackSlot [#_"AllocatableValue"]
    (defn #_"VirtualStackSlot" VirtualStackSlot'new-2 [#_"int" id, #_"ValueKind" kind]
        (merge (VirtualStackSlot'class.) (AllocatableValue. kind)
            (hash-map
                #_"int" :id id
            )
        )
    )
)

(class-ns Allocator []
    ;;;
     ; Numbers all instructions in all blocks.
     ;
     ; @return the id of the last operation
     ;;
    (defn- #_"int" Allocator'numberInstructions-2 [#_"LIR" lir, #_"Block*" sortedBlocks]
        (loop-when [#_"int" opId 0 #_"ISeq" s (seq sortedBlocks)] (some? s) => (- opId 2)
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, (first s))
                opId
                    (loop-when [opId opId #_"int" i 0] (< i (count ops)) => opId
                        (ยง ass! (nth ops i) (LIRInstruction''setId-2 (nth ops i), opId))
                        ;; numbering of lirOps by two
                        (recur (+ opId 2) (inc i))
                    )
            ]
                (recur opId (next s))
            )
        )
    )

    (defn #_"Allocator" Allocator'new-2 [#_"LIR" lir, #_"FrameMapBuilder" frameMapBuilder]
        (merge (Allocator'class.)
            (hash-map
                #_"LIR" :lir lir
                #_"FrameMapBuilder" :frameMapBuilder frameMapBuilder
                #_"StackInterval[]" :stackSlotMap (make-array StackInterval'iface (:numStackSlots frameMapBuilder))
                ;; insert by from
                #_"PriorityQueue<StackInterval>" :unhandled (ร PriorityQueue. (ร (a, b)  (ยง fun (- (:from a) (:from b)))))
                ;; insert by to
                #_"PriorityQueue<StackInterval>" :active (ร PriorityQueue. (ร (a, b)  (ยง fun (- (:to a) (:to b)))))
                #_"Block[]" :sortedBlocks (:reversePostOrder (:cfg lir))
                ;;;
                 ; Highest instruction id.
                 ;;
                #_"int" :maxOpId (Allocator'numberInstructions-2 lir, (:reversePostOrder (:cfg lir)))
                #_"EnumMap<SlotSize, Deque<StackSlot>>" :freeSlots nil
            )
        )
    )

    (defn- #_"StackInterval" Allocator''get-2 [#_"Allocator" this, #_"VirtualStackSlot" stackSlot]
        (nth (:stackSlotMap this) (:id stackSlot))
    )

    (defn- #_"SlotSize" Allocator'forKind-1 [#_"ValueKind" kind]
        (case (FrameMap'spillSlotSize-1 kind)
            1 SlotSize'Size1
            2 SlotSize'Size2
            4 SlotSize'Size4
            8 SlotSize'Size8
              SlotSize'Illegal
        )
    )

    ;;;
     ; @return the list of free stack slots for {@code size} or nil if there is none
     ;;
    (defn- #_"Deque<StackSlot>" Allocator''getOrNullFreeSlots-2 [#_"Allocator" this, #_"SlotSize" size]
        (when (some? (:freeSlots this))
            (get (:freeSlots this) size)
        )
    )

    ;;;
     ; @return the list of free stack slots for {@code size}. If there is none a list is created
     ;;
    (defn- #_"Deque<StackSlot>" Allocator''getOrInitFreeSlots-2 [#_"Allocator" this, #_"SlotSize" size]
        (let [
            #_"Deque<StackSlot>" freeList
                (if (some? (:freeSlots this))
                    (get (:freeSlots this) size)
                    (do
                        (ยง ass! this (assoc this :freeSlots (EnumMap. SlotSize)))
                        nil
                    )
                )
        ]
            (or freeList
                (let [
                    freeList (ArrayDeque.)
                ]
                    (#_"EnumMap" .put (:freeSlots this), size, freeList)
                    freeList
                )
            )
        )
    )

    (defn- #_"EconomicSet<LIRInstruction>" Allocator''buildIntervals-1 [#_"Allocator" this]
        (FixPointIntervalBuilder''build-1 (FixPointIntervalBuilder'new-3 (:lir this), (:stackSlotMap this), (:maxOpId this)))
    )

    ;;;
     ; Gets a free stack slot for {@code slot} or nil if there is none.
     ;;
    (defn- #_"StackSlot" Allocator''findFreeSlot-2 [#_"Allocator" this, #_"VirtualStackSlot" slot]
        (let [
            #_"SlotSize" size (Allocator'forKind-1 (#_"Value" .getValueKind slot))
        ]
            (when-not (= size SlotSize'Illegal)
                (let [
                    #_"Deque<StackSlot>" freeList (Allocator''getOrNullFreeSlots-2 this, size)
                ]
                    (when (some? freeList)
                        (#_"Deque" .pollLast freeList)
                    )
                )
            )
        )
    )

    (defn- #_"void" Allocator''allocateSlot-2 [#_"Allocator" this, #_"StackInterval" interval]
        (let [
            #_"VirtualStackSlot" virtualSlot (:operand interval)
            #_"StackSlot" location
                (let [
                    #_"StackSlot" slot (Allocator''findFreeSlot-2 this, virtualSlot)
                ]
                    (if (some? slot)
                        ;; Free stack slot available. Note that we create a new one because the kind might not match.
                        (StackSlot/get (:kind interval), (#_"StackSlot" .getRawOffset slot), (#_"StackSlot" .getRawAddFrameSize slot))
                        ;; Allocate new stack slot.
                        (FrameMap''allocateSpillSlot-2 (:frameMap (:frameMapBuilder this)), (#_"Value" .getValueKind virtualSlot))
                    )
                )
        ]
            (ยง ass! interval (StackInterval''setLocation-2 interval, location))
        )
        nil
    )

    ;;;
     ; Gets the lowest {@link StackInterval#to() end position} of all active intervals.
     ; If there is none Integer#MAX_VALUE is returned.
     ;;
    (defn- #_"int" Allocator''activePeekId-1 [#_"Allocator" this]
        (let [
            #_"StackInterval" interval (#_"PriorityQueue" .peek (:active this))
        ]
            (if (some? interval) (:to interval) Integer/MAX_VALUE)
        )
    )

    ;;;
     ; Adds a stack slot to the list of free slots.
     ;;
    (defn- #_"void" Allocator''freeSlot-2 [#_"Allocator" this, #_"StackSlot" slot]
        (let [
            #_"SlotSize" size (Allocator'forKind-1 (#_"StackSlot" .getValueKind slot))
        ]
            (when-not (= size SlotSize'Illegal)
                (#_"Deque" .addLast (Allocator''getOrInitFreeSlots-2 this, size), slot)
            )
        )
        nil
    )

    ;;;
     ; Finishes {@code interval} by adding its location to the list of free stack slots.
     ;;
    (defn- #_"void" Allocator''finished-2 [#_"Allocator" this, #_"StackInterval" interval]
        (Allocator''freeSlot-2 this, (:location interval))
        nil
    )

    ;;;
     ; Gets the next unhandled interval and finishes handled intervals.
     ;;
    (defn- #_"StackInterval" Allocator''activateNext-1 [#_"Allocator" this]
        (when (seq (:unhandled this))
            (let [
                #_"StackInterval" _next (#_"PriorityQueue" .poll (:unhandled this))
            ]
                ;; finish handled intervals
                (loop-when-recur [#_"int" id (:from _next)] (< (Allocator''activePeekId-1 this) id) [id]
                    (Allocator''finished-2 this, (#_"PriorityQueue" .poll (:active this)))
                )
                (#_"PriorityQueue" .add (:active this), _next)
                _next
            )
        )
    )

    (defn- #_"void" Allocator''allocateStackSlots-1 [#_"Allocator" this]
        ;; create unhandled lists
        (doseq [#_"StackInterval" interval (:stackSlotMap this)]
            (when (some? interval)
                (#_"PriorityQueue" .add (:unhandled this), interval)
            )
        )

        (loop-when-recur [#_"StackInterval" interval (Allocator''activateNext-1 this)] (some? interval) [(Allocator''activateNext-1 this)]
            (Allocator''allocateSlot-2 this, interval)
        )
        nil
    )

    (defn- #_"void" Allocator''assignStackSlots-2 [#_"Allocator" this, #_"EconomicSet<LIRInstruction>" usePos]
        (let [
            #_"ValueProcedure" assignSlot
                (reify ValueProcedure
                    (#_"Value" ValueProcedure'''doValue-5 [#_"ValueProcedure" _, #_"LIRInstruction" _op, #_"Value" value, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                        (when (satisfies? VirtualStackSlot value) => value
                            (:location (Allocator''get-2 this, value))
                        )
                    )
                )
        ]
            (doseq [#_"LIRInstruction" op usePos]
                (LIRInstruction''forEachInput-2 op, assignSlot)
                (LIRInstruction''forEachAlive-2 op, assignSlot)
                (LIRInstruction''forEachTemp-2 op, assignSlot)
                (LIRInstruction''forEachOutput-2 op, assignSlot)
            )
        )
        nil
    )

    (defn #_"void" Allocator''allocate-1 [#_"Allocator" this]
        (let [
            #_"EconomicSet<LIRInstruction>" usePos (Allocator''buildIntervals-1 this)
        ]
            (Allocator''allocateStackSlots-1 this)
            (Allocator''assignStackSlots-2 this, usePos)
        )
        nil
    )
)

;;;
 ; Values that are bound to the snippet method parameters.
 ;;
(class-ns Arguments []
    (defn #_"Arguments" Arguments'new-4* [#_"SnippetInfo" info, #_"GuardsStage" guardsStage, #_"LoweringStage" loweringStage & #_"Object..." values]
        (merge (Arguments'class.)
            (hash-map
                #_"SnippetInfo" :info info
                #_"GuardsStage" :guardsStage guardsStage
                #_"LoweringStage" :loweringStage loweringStage
                #_"Object*" :values values
            )
        )
    )
)

(class-ns ArithmeticOp []
    (defn #_"ArithmeticOp" ArithmeticOp'new-1 [#_"String" operator]
        (merge (ArithmeticOp'class.)
            (hash-map
                #_"String" :operator operator
            )
        )
    )
)

(class-ns BinaryOp #_"<T>" [ArithmeticOp]
    (defn #_"BinaryOp" BinaryOp'new-3 [#_"String" operation, #_"boolean" associative?, #_"boolean" commutative?]
        (merge (BinaryOp'class.) (ArithmeticOp'new-1 operation)
            (hash-map
                #_"boolean" :associative? associative?
                #_"boolean" :commutative? commutative?
            )
        )
    )

    ;;;
     ; Checks whether this operation is associative. An operation is associative when
     ; {@code (a . b) . c == a . (b . c)} for all a, b, c. Note that you still have to be
     ; careful with inverses. For example the integer subtraction operation will report true
     ; here, since you can still reassociate as long as the correct negations are inserted.
     ;;
    (defn #_"boolean" BinaryOp''isAssociative-1 [#_"BinaryOp<T>" this]
        (:associative? this)
    )

    ;;;
     ; Checks whether this operation is commutative. An operation is commutative when
     ; {@code a . b == b . a} for all a, b.
     ;;
    #_unused
    (defn #_"boolean" BinaryOp''isCommutative-1 [#_"BinaryOp<T>" this]
        (:commutative? this)
    )

    (defm BinaryOp #_"<T>" BinaryOp
        (#_"boolean" BinaryOp'''isNeutral-2 [#_"BinaryOp<T>" this, #_"Constant" n]
            false
        )
    )

    (defm BinaryOp #_"<T>" BinaryOp
        (#_"Constant" BinaryOp'''getZero-2 [#_"BinaryOp<T>" this, #_"Stamp" stamp]
            nil
        )
    )
)

(class-ns Add [BinaryOp #_"<Add>", ArithmeticOp]
    (defn #_"Add" Add'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Add'class.) (BinaryOp'new-3 "+", associative?, commutative?))
    )
)

(class-ns And [BinaryOp #_"<And>", ArithmeticOp]
    (defn #_"And" And'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (And'class.) (BinaryOp'new-3 "&", associative?, commutative?))
    )
)

(class-ns Div [BinaryOp #_"<Div>", ArithmeticOp]
    (defn #_"Div" Div'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Div'class.) (BinaryOp'new-3 "/", associative?, commutative?))
    )
)

(class-ns Mul [BinaryOp #_"<Mul>", ArithmeticOp]
    (defn #_"Mul" Mul'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Mul'class.) (BinaryOp'new-3 "*", associative?, commutative?))
    )
)

(class-ns MulHigh [BinaryOp #_"<MulHigh>", ArithmeticOp]
    (defn #_"MulHigh" MulHigh'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (MulHigh'class.) (BinaryOp'new-3 "*H", associative?, commutative?))
    )
)

(class-ns Or [BinaryOp #_"<Or>", ArithmeticOp]
    (defn #_"Or" Or'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Or'class.) (BinaryOp'new-3 "|", associative?, commutative?))
    )
)

(class-ns Rem [BinaryOp #_"<Rem>", ArithmeticOp]
    (defn #_"Rem" Rem'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Rem'class.) (BinaryOp'new-3 "%", associative?, commutative?))
    )
)

(class-ns Sub [BinaryOp #_"<Sub>", ArithmeticOp]
    (defn #_"Sub" Sub'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Sub'class.) (BinaryOp'new-3 "-", associative?, commutative?))
    )
)

(class-ns UMulHigh [BinaryOp #_"<UMulHigh>", ArithmeticOp]
    (defn #_"UMulHigh" UMulHigh'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (UMulHigh'class.) (BinaryOp'new-3 "|*H|", associative?, commutative?))
    )
)

(class-ns Xor [BinaryOp #_"<Xor>", ArithmeticOp]
    (defn #_"Xor" Xor'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (merge (Xor'class.) (BinaryOp'new-3 "^", associative?, commutative?))
    )
)

(class-ns IntegerConvertOp #_"<T>" [ArithmeticOp]
    (defn #_"IntegerConvertOp" IntegerConvertOp'new-1 [#_"String" op]
        (merge (IntegerConvertOp'class.) (ArithmeticOp'new-1 op))
    )
)

(class-ns Narrow [IntegerConvertOp #_"<Narrow>", ArithmeticOp]
    (defn #_"Narrow" Narrow'new-0 []
        (merge (Narrow'class.) (IntegerConvertOp'new-1 "Narrow"))
    )

    (defm Narrow IntegerConvertOp
        (#_"Stamp" IntegerConvertOp'''invertStamp-4 [#_"Narrow" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" outStamp]
            nil
        )
    )
)

(class-ns SignExtend [IntegerConvertOp #_"<SignExtend>", ArithmeticOp]
    (defn #_"SignExtend" SignExtend'new-0 []
        (merge (SignExtend'class.) (IntegerConvertOp'new-1 "SignExtend"))
    )
)

(class-ns ZeroExtend [IntegerConvertOp #_"<ZeroExtend>", ArithmeticOp]
    (defn #_"ZeroExtend" ZeroExtend'new-0 []
        (merge (ZeroExtend'class.) (IntegerConvertOp'new-1 "ZeroExtend"))
    )
)

(class-ns ShiftOp #_"<OP>" [ArithmeticOp]
    (defn #_"ShiftOp" ShiftOp'new-1 [#_"String" operation]
        (merge (ShiftOp'class.) (ArithmeticOp'new-1 operation))
    )

    (defn #_"int" ShiftOp'getShiftAmountMask-1 [#_"Stamp" stamp]
        (dec (:bits stamp))
    )
)

(class-ns Shl [ShiftOp #_"<Shl>", ArithmeticOp]
    (defn #_"Shl" Shl'new-0 []
        (merge (Shl'class.) (ShiftOp'new-1 "<<"))
    )
)

(class-ns Shr [ShiftOp #_"<Shr>", ArithmeticOp]
    (defn #_"Shr" Shr'new-0 []
        (merge (Shr'class.) (ShiftOp'new-1 ">>"))
    )
)

(class-ns UShr [ShiftOp #_"<UShr>", ArithmeticOp]
    (defn #_"UShr" UShr'new-0 []
        (merge (UShr'class.) (ShiftOp'new-1 ">>>"))
    )
)

(class-ns UnaryOp #_"<T>" [ArithmeticOp]
    (defn #_"UnaryOp" UnaryOp'new-1 [#_"String" operation]
        (merge (UnaryOp'class.) (ArithmeticOp'new-1 operation))
    )
)

(class-ns Abs [UnaryOp #_"<Abs>", ArithmeticOp]
    (defn #_"Abs" Abs'new-0 []
        (merge (Abs'class.) (UnaryOp'new-1 "ABS"))
    )
)

(class-ns Neg [UnaryOp #_"<Neg>", ArithmeticOp]
    (defn #_"Neg" Neg'new-0 []
        (merge (Neg'class.) (UnaryOp'new-1 "-"))
    )
)

(class-ns Not [UnaryOp #_"<Not>", ArithmeticOp]
    (defn #_"Not" Not'new-0 []
        (merge (Not'class.) (UnaryOp'new-1 "~"))
    )
)

;;;
 ; Information about arithmetic operations.
 ;;
(class-ns ArithmeticOpTable []
    (defn #_"ArithmeticOpTable" ArithmeticOpTable'new-19 [#_"UnaryOp<Neg>" neg, #_"BinaryOp<Add>" add, #_"BinaryOp<Sub>" sub, #_"BinaryOp<Mul>" mul, #_"BinaryOp<MulHigh>" mulHigh, #_"BinaryOp<UMulHigh>" umulHigh, #_"BinaryOp<Div>" div, #_"BinaryOp<Rem>" rem, #_"UnaryOp<Not>" not, #_"BinaryOp<And>" and, #_"BinaryOp<Or>" or, #_"BinaryOp<Xor>" xor, #_"ShiftOp<Shl>" shl, #_"ShiftOp<Shr>" shr, #_"ShiftOp<UShr>" ushr, #_"UnaryOp<Abs>" abs, #_"IntegerConvertOp<ZeroExtend>" zeroExtend, #_"IntegerConvertOp<SignExtend>" signExtend, #_"IntegerConvertOp<Narrow>" narrow]
        (merge (ArithmeticOpTable'class.)
            (hash-map
                #_"UnaryOp<Neg>"                 :neg neg               ;; unary negation operation
                #_"BinaryOp<Add>"                :add add               ;; addition operation
                #_"BinaryOp<Sub>"                :sub sub               ;; subtraction operation
                #_"BinaryOp<Mul>"                :mul mul               ;; multiplication operation
                #_"BinaryOp<MulHigh>"            :mulHigh mulHigh       ;; signed operation that multiples the upper 32-bits of two long values
                #_"BinaryOp<UMulHigh>"           :umulHigh umulHigh     ;; unsigned operation that multiples the upper 32-bits of two long values
                #_"BinaryOp<Div>"                :div div               ;; division operation
                #_"BinaryOp<Rem>"                :rem rem               ;; remainder operation
                #_"UnaryOp<Not>"                 :not not               ;; bitwise not operation
                #_"BinaryOp<And>"                :and and               ;; bitwise and operation
                #_"BinaryOp<Or>"                 :or or                 ;; bitwise or operation
                #_"BinaryOp<Xor>"                :xor xor               ;; bitwise xor operation
                #_"ShiftOp<Shl>"                 :shl shl               ;; shift left operation
                #_"ShiftOp<Shr>"                 :shr shr               ;; signed shift right operation
                #_"ShiftOp<UShr>"                :ushr ushr             ;; unsigned shift right operation
                #_"UnaryOp<Abs>"                 :abs abs               ;; absolute value operation
                #_"IntegerConvertOp<ZeroExtend>" :zeroExtend zeroExtend ;; zero extend conversion
                #_"IntegerConvertOp<SignExtend>" :signExtend signExtend ;; sign extend conversion
                #_"IntegerConvertOp<Narrow>"     :narrow narrow         ;; narrowing conversion
            )
        )
    )

    (ยง def #_"ArithmeticOpTable" ArithmeticOpTable'EMPTY (ArithmeticOpTable'new-19 nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil))

    (defn #_"ArithmeticOpTable" ArithmeticOpTable'forStamp-1 [#_"Stamp" stamp]
        (if (satisfies? ArithmeticStamp stamp) (:ops stamp) ArithmeticOpTable'EMPTY)
    )
)

(class-ns Assembler []
    (def- #_"boolean" Assembler'UseNormalNop false)
    (def- #_"boolean" Assembler'UseAddressNop true)
    (def- #_"boolean" Assembler'UseIncDec true)

    (def- #_"int" Assembler'MinEncodingNeedsRex 8)

    (defn #_"Assembler" Assembler'new-1 [#_"LIRGenerationResult" res]
        (let [
            #_"Assembler" this
                (merge (Assembler'class.)
                    (hash-map
                        ;;;
                         ; The LIR for which code is being generated.
                         ;;
                        #_"LIR" :lir (:lir res)
                        #_"FrameMap" :frameMap (:frameMap res)
                        ;;;
                         ; The object that emits code for managing a method's frame.
                         ;;
                        #_"FrameContext" :frameContext nil
                        #_"CompilationResult" :compilationResult nil
                        ;;;
                         ; The index of the block currently being emitted.
                         ;;
                        #_"int" :currentBlockIndex 0
                        #_"EconomicMap<Constant, Data>" :dataCache (EconomicMap/create)
                        #_"CodeBuffer" :codeBuffer (CodeBuffer'new-1 (#_"Architecture" .getByteOrder (.arch HotSpot'target)))
                    )
                )
            ;; Omit the frame if the method:
            ;; - has no spill slots or other slots allocated during register allocation
            ;; - has no callee-saved registers
            ;; - has no incoming arguments passed on the stack
            ;; - has no deoptimization points
            ;; - makes no foreign calls (which require an aligned stack)
            #_"boolean" omit-frame?
                (and GraalOptions'canOmitFrame
                    (not (FrameMap''frameNeedsAllocating-1 (:frameMap res)))
                    (not (:hasArgInCallerFrame (:lir res)))
                    (not (:hasForeignCall res))
                )
            this (assoc this :frameContext (FrameContext'new-1 omit-frame?))
            this (assoc this :compilationResult (CompilationResult'new-1 (FrameMap''totalFrameSize-1 (:frameMap res))))
        ]
            this
        )
    )

    ;;;
     ; Returns the current position of the underlying code buffer.
     ;
     ; @return current position in code buffer
     ;;
    (defn #_"int" Assembler''position-1 [#_"Assembler" this]
        (CodeBuffer''position-1 (:codeBuffer this))
    )

    (defn #_"void" Assembler''emitByte-2 [#_"Assembler" this, #_"int" x]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitByte-2 (:codeBuffer this), x))
        nil
    )

    (defn #_"void" Assembler''emitShort-2 [#_"Assembler" this, #_"int" x]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitShort-2 (:codeBuffer this), x))
        nil
    )

    (defn #_"void" Assembler''emitInt-2 [#_"Assembler" this, #_"int" x]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitInt-2 (:codeBuffer this), x))
        nil
    )

    (defn #_"void" Assembler''emitLong-2 [#_"Assembler" this, #_"long" x]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitLong-2 (:codeBuffer this), x))
        nil
    )

    (defn #_"void" Assembler''emitByte-3 [#_"Assembler" this, #_"int" b, #_"int" pos]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitByte-3 (:codeBuffer this), b, pos))
        nil
    )

    #_unused
    (defn #_"void" Assembler''emitShort-3 [#_"Assembler" this, #_"int" b, #_"int" pos]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitShort-3 (:codeBuffer this), b, pos))
        nil
    )

    (defn #_"void" Assembler''emitInt-3 [#_"Assembler" this, #_"int" b, #_"int" pos]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitInt-3 (:codeBuffer this), b, pos))
        nil
    )

    #_unused
    (defn #_"void" Assembler''emitLong-3 [#_"Assembler" this, #_"long" b, #_"int" pos]
        (ยง ass! (:codeBuffer this) (CodeBuffer''emitLong-3 (:codeBuffer this), b, pos))
        nil
    )

    (defn #_"int" Assembler''getByte-2 [#_"Assembler" this, #_"int" pos]
        (CodeBuffer''getByte-2 (:codeBuffer this), pos)
    )

    (defn #_"int" Assembler''getShort-2 [#_"Assembler" this, #_"int" pos]
        (CodeBuffer''getShort-2 (:codeBuffer this), pos)
    )

    #_unused
    (defn #_"int" Assembler''getInt-2 [#_"Assembler" this, #_"int" pos]
        (CodeBuffer''getInt-2 (:codeBuffer this), pos)
    )

    ;;;
     ; Closes this assembler. No extra data can be written to this assembler after this call.
     ;
     ; @param trim? if true, then a copy of the underlying byte array up to (but not including) {@code position()} is returned
     ; @return the data in this buffer or a trimmed copy if {@code trim?} is true
     ;;
    (defn #_"byte[]" Assembler''close-2 [#_"Assembler" this, #_"boolean" trim?]
        (CodeBuffer''close-2 (:codeBuffer this), trim?)
    )

    (defn #_"void" Assembler''bind-2 [#_"Assembler" this, #_"Label" l]
        (ยง ass! l (Label''bind-2 l, (Assembler''position-1 this)))
        (Label''patchInstructions-2 l, this)
        nil
    )

    (defn- #_"int" Assembler'encode-1 [#_"Register" r]
        (& (.encoding r) 0x7)
    )

    ;;;
     ; Get RXB bits for register-register instruction. In that encoding, ModRM.rm contains a register index.
     ; The R bit extends the ModRM.reg field and the B bit extends the ModRM.rm field. The X bit must be 0.
     ;;
    (defn #_"int" Assembler'getRXB-2rr [#_"Register" reg, #_"Register" rm]
        (| (>> (if (nil? reg) 0 (& (.encoding reg) 0x08)) 1) (>> (if (nil? rm) 0 (& (.encoding rm) 0x08)) 3))
    )

    ;;;
     ; Get RXB bits for register-memory instruction. The R bit extends the ModRM.reg field.
     ; There are two cases for the memory operand:
     ; ModRM.rm contains the base register: In that case, B extends the ModRM.rm field and X = 0.
     ;
     ; There is an SIB byte: In that case, X extends SIB.index and B extends SIB.base.
     ;;
    (defn #_"int" Assembler'getRXB-2ra [#_"Register" reg, #_"AMD64Address" rm]
        (let [
            #_"int" rxb (>> (if (nil? reg) 0 (& (.encoding reg) 0x08)) 1)
        ]
            (when-not (= (:index rm) Register/None)
                (ยง ass rxb (| rxb (>> (& (.encoding (:index rm)) 0x08) 2)))
            )
            (when-not (= (:base rm) Register/None)
                (ยง ass rxb (| rxb (>> (& (.encoding (:base rm)) 0x08) 3)))
            )
            rxb
        )
    )

    ;;;
     ; Emit the ModR/M byte for one register operand and an opcode extension in the R field.
     ;
     ; Format: [ 11 reg r/m ]
     ;;
    (defn #_"void" Assembler''emitModRM-3ir [#_"Assembler" this, #_"int" reg, #_"Register" rm]
        (Assembler''emitByte-2 this, (| 0xc0 (<< reg 3) (& (.encoding rm) 0x07)))
        nil
    )

    ;;;
     ; Emit the ModR/M byte for two register operands.
     ;
     ; Format: [ 11 reg r/m ]
     ;;
    (defn #_"void" Assembler''emitModRM-3rr [#_"Assembler" this, #_"Register" reg, #_"Register" rm]
        (Assembler''emitModRM-3ir this, (& (.encoding reg) 0x07), rm)
        nil
    )

    (defn #_"void" Assembler''emitOperandHelper-4r [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" addr, #_"int" additionalInstructionSize]
        (Assembler''emitOperandHelper-5i this, (Assembler'encode-1 reg), addr, false, additionalInstructionSize)
        nil
    )

    ;;;
     ; Emits the ModR/M byte and optionally the SIB byte for one register and one memory operand.
     ;
     ; @param force4Byte use 4 byte encoding for displacements that would normally fit in a byte
     ;;
    (defn #_"void" Assembler''emitOperandHelper-5r [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" addr, #_"boolean" force4Byte, #_"int" additionalInstructionSize]
        (Assembler''emitOperandHelper-5i this, (Assembler'encode-1 reg), addr, force4Byte, additionalInstructionSize)
        nil
    )

    (defn #_"void" Assembler''emitOperandHelper-4i [#_"Assembler" this, #_"int" reg, #_"AMD64Address" addr, #_"int" additionalInstructionSize]
        (Assembler''emitOperandHelper-5i this, reg, addr, false, additionalInstructionSize)
        nil
    )

    ;;;
     ; Emits the ModR/M byte and optionally the SIB byte for one memory operand and an opcode
     ; extension in the R field.
     ;
     ; @param force4Byte use 4 byte encoding for displacements that would normally fit in a byte
     ; @param additionalInstructionSize the number of bytes that will be emitted after the operand,
     ;            so that the start position of the next instruction can be computed even though
     ;            this instruction has not been completely emitted yet.
     ;;
    (defn #_"void" Assembler''emitOperandHelper-5i [#_"Assembler" this, #_"int" reg, #_"AMD64Address" addr, #_"boolean" force4Byte, #_"int" additionalInstructionSize]
        (let [
            #_"int" regenc (<< reg 3)
            #_"Register" base (:base addr)
            #_"Register" index (:index addr)
            #_"Scale" scale (:scale addr)
            #_"int" disp (:displacement addr)
        ]
            (cond
                (= base AMD64/rip) ;; also matches addresses returned by getPlaceholder()
                    (do
                        ;; [00 000 101] disp32
                        (Assembler''emitByte-2 this, (| 0x05 regenc))
                        (Assembler''emitInt-2 this, disp)
                    )
                (#_"Register" .isValid base)
                    (let [
                        #_"int" baseenc (if (#_"Register" .isValid base) (Assembler'encode-1 base) 0)
                    ]
                        (cond
                            (#_"Register" .isValid index)
                            (let [
                                #_"int" indexenc (<< (Assembler'encode-1 index) 3)
                            ]
                                ;; [base + indexscale + disp]
                                (cond
                                    (and (zero? disp) (not (= base AMD64/rbp)) (not (= base AMD64/r13)))
                                    (do
                                        ;; [base + indexscale]
                                        ;; [00 reg 100][ss index base]
                                        (Assembler''emitByte-2 this, (| 0x04 regenc))
                                        (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc baseenc))
                                    )
                                    (and (NumUtil'isByte-1i disp) (not force4Byte))
                                    (do
                                        ;; [base + indexscale + imm8]
                                        ;; [01 reg 100][ss index base] imm8
                                        (Assembler''emitByte-2 this, (| 0x44 regenc))
                                        (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc baseenc))
                                        (Assembler''emitByte-2 this, (& disp 0xff))
                                    )
                                    :else
                                    (do
                                        ;; [base + indexscale + disp32]
                                        ;; [10 reg 100][ss index base] disp32
                                        (Assembler''emitByte-2 this, (| 0x84 regenc))
                                        (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc baseenc))
                                        (Assembler''emitInt-2 this, disp)
                                    )
                                )
                            )
                            (any = base AMD64/rsp AMD64/r12)
                                ;; [rsp + disp]
                                (cond
                                    (zero? disp)
                                    (do
                                        ;; [rsp]
                                        ;; [00 reg 100][00 100 100]
                                        (Assembler''emitByte-2 this, (| 0x04 regenc))
                                        (Assembler''emitByte-2 this, 0x24)
                                    )
                                    (and (NumUtil'isByte-1i disp) (not force4Byte))
                                    (do
                                        ;; [rsp + imm8]
                                        ;; [01 reg 100][00 100 100] disp8
                                        (Assembler''emitByte-2 this, (| 0x44 regenc))
                                        (Assembler''emitByte-2 this, 0x24)
                                        (Assembler''emitByte-2 this, (& disp 0xff))
                                    )
                                    :else
                                    (do
                                        ;; [rsp + imm32]
                                        ;; [10 reg 100][00 100 100] disp32
                                        (Assembler''emitByte-2 this, (| 0x84 regenc))
                                        (Assembler''emitByte-2 this, 0x24)
                                        (Assembler''emitInt-2 this, disp)
                                    )
                                )
                            :else
                                ;; [base + disp]
                                (cond
                                    (and (zero? disp) (not (= base AMD64/rbp)) (not (= base AMD64/r13)))
                                    (do
                                        ;; [base]
                                        ;; [00 reg base]
                                        (Assembler''emitByte-2 this, (| 0x00 regenc baseenc))
                                    )
                                    (and (NumUtil'isByte-1i disp) (not force4Byte))
                                    (do
                                        ;; [base + disp8]
                                        ;; [01 reg base] disp8
                                        (Assembler''emitByte-2 this, (| 0x40 regenc baseenc))
                                        (Assembler''emitByte-2 this, (& disp 0xff))
                                    )
                                    :else
                                    (do
                                        ;; [base + disp32]
                                        ;; [10 reg base] disp32
                                        (Assembler''emitByte-2 this, (| 0x80 regenc baseenc))
                                        (Assembler''emitInt-2 this, disp)
                                    )
                                )
                        )
                    )
                :else
                    (if (#_"Register" .isValid index)
                        (let [
                            #_"int" indexenc (<< (Assembler'encode-1 index) 3)
                        ]
                            ;; [indexscale + disp]
                            ;; [00 reg 100][ss index 101] disp32
                            (Assembler''emitByte-2 this, (| 0x04 regenc))
                            (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc 0x05))
                            (Assembler''emitInt-2 this, disp)
                        )
                        (do
                            ;; [disp] ABSOLUTE
                            ;; [00 reg 100][00 100 101] disp32
                            (Assembler''emitByte-2 this, (| 0x04 regenc))
                            (Assembler''emitByte-2 this, 0x25)
                            (Assembler''emitInt-2 this, disp)
                        )
                    )
            )
        )
        nil
    )

    (defn- #_"int" Assembler''prefixAndEncode-3b [#_"Assembler" this, #_"int" regEnc, #_"boolean" byte-inst?]
        (if (< regEnc 8)
            (do
                (when (and byte-inst? (<= 4 regEnc))
                    (Assembler''emitByte-2 this, Prefix'REX)
                )
                regEnc
            )
            (do
                (Assembler''emitByte-2 this, Prefix'REXB)
                (- regEnc 8)
            )
        )
    )

    (defn- #_"int" Assembler''prefixAndEncode-2 [#_"Assembler" this, #_"int" regEnc]
        (Assembler''prefixAndEncode-3b this, regEnc, false)
    )

    (defn- #_"int" Assembler''prefixqAndEncode-2 [#_"Assembler" this, #_"int" regEnc]
        (if (< regEnc 8)
            (do
                (Assembler''emitByte-2 this, Prefix'REXW)
                regEnc
            )
            (do
                (Assembler''emitByte-2 this, Prefix'REXWB)
                (- regEnc 8)
            )
        )
    )

    (defn- #_"int" Assembler''prefixAndEncode-5 [#_"Assembler" this, #_"int" dstEncoding, #_"boolean" dstIsByte, #_"int" srcEncoding, #_"boolean" srcIsByte]
        (let [
            #_"int" src srcEncoding
            #_"int" dst dstEncoding
            [src dst]
                (if (< dst 8)
                    (if (< src 8)
                        (do
                            (when (or (and srcIsByte (<= 4 src)) (and dstIsByte (<= 4 dst)))
                                (Assembler''emitByte-2 this, Prefix'REX)
                            )
                            [src dst]
                        )
                        (do
                            (Assembler''emitByte-2 this, Prefix'REXB)
                            [(- src 8) dst]
                        )
                    )
                    (if (< src 8)
                        (do (Assembler''emitByte-2 this, Prefix'REXR)  [   src    (- dst 8)])
                        (do (Assembler''emitByte-2 this, Prefix'REXRB) [(- src 8) (- dst 8)])
                    )
                )
        ]
            (| (<< dst 3) src)
        )
    )

    (defn- #_"int" Assembler''prefixAndEncode-3i [#_"Assembler" this, #_"int" dstEnc, #_"int" srcEnc]
        (Assembler''prefixAndEncode-5 this, dstEnc, false, srcEnc, false)
    )

    ;;;
     ; Creates prefix and the encoding of the lower 6 bits of the ModRM-Byte. It emits an operand
     ; prefix. If the given operands exceed 3 bits, the 4th bit is encoded in the prefix.
     ;
     ; @param regEncoding the encoding of the register part of the ModRM-Byte
     ; @param rmEncoding the encoding of the r/m part of the ModRM-Byte
     ; @return the lower 6 bits of the ModRM-Byte that should be emitted
     ;;
    (defn- #_"int" Assembler''prefixqAndEncode-3 [#_"Assembler" this, #_"int" regEncoding, #_"int" rmEncoding]
        (let [
            #_"int" rm rmEncoding
            #_"int" reg regEncoding
            [rm reg]
                (if (< reg 8)
                    (if (< rm 8)
                        (do (Assembler''emitByte-2 this, Prefix'REXW)   [   rm    reg])
                        (do (Assembler''emitByte-2 this, Prefix'REXWB)  [(- rm 8) reg])
                    )
                    (if (< rm 8)
                        (do (Assembler''emitByte-2 this, Prefix'REXWR)  [   rm    (- reg 8)])
                        (do (Assembler''emitByte-2 this, Prefix'REXWRB) [(- rm 8) (- reg 8)])
                    )
                )
        ]
            (| (<< reg 3) rm)
        )
    )

    (defn- #_"boolean" Assembler'needsRex-1 [#_"Register" reg]
        (<= Assembler'MinEncodingNeedsRex (.encoding reg))
    )

    (defn- #_"void" Assembler''prefix-2 [#_"Assembler" this, #_"AMD64Address" adr]
        (if (Assembler'needsRex-1 (:base adr))
            (if (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXXB)
                (Assembler''emitByte-2 this, Prefix'REXB)
            )
            (when (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXX)
            )
        )
        nil
    )

    (defn- #_"void" Assembler''prefixq-2 [#_"Assembler" this, #_"AMD64Address" adr]
        (if (Assembler'needsRex-1 (:base adr))
            (if (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXWXB)
                (Assembler''emitByte-2 this, Prefix'REXWB)
            )
            (if (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXWX)
                (Assembler''emitByte-2 this, Prefix'REXW)
            )
        )
        nil
    )

    (defn- #_"void" Assembler''prefix-4 [#_"Assembler" this, #_"AMD64Address" adr, #_"Register" reg, #_"boolean" byte-inst?]
        (if (< (.encoding reg) 8)
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXXB)
                    (Assembler''emitByte-2 this, Prefix'REXB)
                )
                (cond
                    (Assembler'needsRex-1 (:index adr))
                        (Assembler''emitByte-2 this, Prefix'REXX)
                    (and byte-inst? (<= 4 (.encoding reg)))
                        (Assembler''emitByte-2 this, Prefix'REX)
                )
            )
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXRXB)
                    (Assembler''emitByte-2 this, Prefix'REXRB)
                )
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXRX)
                    (Assembler''emitByte-2 this, Prefix'REXR)
                )
            )
        )
        nil
    )

    (defn- #_"void" Assembler''prefix-3 [#_"Assembler" this, #_"AMD64Address" adr, #_"Register" reg]
        (Assembler''prefix-4 this, adr, reg, false)
        nil
    )

    (defn- #_"void" Assembler''prefixq-3 [#_"Assembler" this, #_"AMD64Address" adr, #_"Register" src]
        (if (< (.encoding src) 8)
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWXB)
                    (Assembler''emitByte-2 this, Prefix'REXWB)
                )
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWX)
                    (Assembler''emitByte-2 this, Prefix'REXW)
                )
            )
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWRXB)
                    (Assembler''emitByte-2 this, Prefix'REXWRB)
                )
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWRX)
                    (Assembler''emitByte-2 this, Prefix'REXWR)
                )
            )
        )
        nil
    )

    (defn #_"void" Assembler''addl-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5a (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''addl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''addl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'ADD), this, OperandSize'DWORD, dst, src)
        nil
    )

    (defn- #_"void" Assembler''addrNop4-1 [#_"Assembler" this]
        ;; 4 bytes: NOP DWORD PTR [EAX+0]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x40) ;; emitRm(cbuf, 0x1, EAXEnc, EAXEnc);
        (Assembler''emitByte-2 this, 0) ;; 8-bits offset (1 byte)
        nil
    )

    (defn- #_"void" Assembler''addrNop5-1 [#_"Assembler" this]
        ;; 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x44) ;; emitRm(cbuf, 0x1, EAXEnc, 0x4);
        (Assembler''emitByte-2 this, 0x00) ;; emitRm(cbuf, 0x0, EAXEnc, EAXEnc);
        (Assembler''emitByte-2 this, 0) ;; 8-bits offset (1 byte)
        nil
    )

    (defn- #_"void" Assembler''addrNop7-1 [#_"Assembler" this]
        ;; 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x80) ;; emitRm(cbuf, 0x2, EAXEnc, EAXEnc);
        (Assembler''emitInt-2 this, 0) ;; 32-bits offset (4 bytes)
        nil
    )

    (defn- #_"void" Assembler''addrNop8-1 [#_"Assembler" this]
        ;; 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x84) ;; emitRm(cbuf, 0x2, EAXEnc, 0x4);
        (Assembler''emitByte-2 this, 0x00) ;; emitRm(cbuf, 0x0, EAXEnc, EAXEnc);
        (Assembler''emitInt-2 this, 0) ;; 32-bits offset (4 bytes)
        nil
    )

    #_unused
    (defn #_"void" Assembler''andl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'AND, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    #_unused
    (defn #_"void" Assembler''andl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'AND), this, OperandSize'DWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''bsfq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (#_"Register" .encoding dst), (#_"Register" .encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbc)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''bsrl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3i this, (#_"Register" .encoding dst), (#_"Register" .encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbd)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''bswapl-2 [#_"Assembler" this, #_"Register" reg]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding reg))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (defn #_"void" Assembler''cdql-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x99)
        nil
    )

    (defn #_"void" Assembler''cmovl-4rr [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3i this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''cmovl-4ra [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''cmpl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    #_unused
    (defn #_"void" Assembler''cmpl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'DWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''cmpl-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'DWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''cmpl-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5a (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    ;; The 32-bit cmpxchg compares the value at adr with the contents of X86.rax,
    ;; and stores reg into adr if so; otherwise, the value at adr is loaded into X86.rax.
    ;; The ZF is set if the compared values were equal, and cleared otherwise.
    (defn #_"void" Assembler''cmpxchgl-3 [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" adr] ;; cmpxchg
        (Assembler''prefix-3 this, adr, reg)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb1)
        (Assembler''emitOperandHelper-4r this, reg, adr, 0)
        nil
    )

    (defn #_"void" Assembler''decl-2a [#_"Assembler" this, #_"AMD64Address" dst]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xff)
        (Assembler''emitOperandHelper-4i this, 1, dst, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''hlt-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xf4)
        nil
    )

    #_unused
    (defn #_"void" Assembler''imull-4 [#_"Assembler" this, #_"Register" dst, #_"Register" src, #_"int" value]
        (if (NumUtil'isByte-1i value)
            (AMD64RMIOp''emit-6r AMD64RMIOp'IMUL_SX, this, OperandSize'DWORD, dst, src, value)
            (AMD64RMIOp''emit-6r AMD64RMIOp'IMUL, this, OperandSize'DWORD, dst, src, value)
        )
        nil
    )

    (defn #_"void" Assembler''incl-2a [#_"Assembler" this, #_"AMD64Address" dst]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xff)
        (Assembler''emitOperandHelper-4i this, 0, dst, 0)
        nil
    )

    (defn #_"void" Assembler''jcc-4 [#_"Assembler" this, #_"ConditionFlag" cc, #_"int" jumpTarget, #_"boolean" forceDisp32]
        (let [
            #_"int" shortSize 2
            #_"int" longSize 6
            #_"long" disp (- jumpTarget (Assembler''position-1 this))
        ]
            (if (and (not forceDisp32) (NumUtil'isByte-1l (- disp shortSize)))
                (do
                    ;; 0111 tttn #8-bit disp
                    (Assembler''emitByte-2 this, (| 0x70 (:value cc)))
                    (Assembler''emitByte-2 this, (int (& (- disp shortSize) 0xff)))
                )
                (do
                    ;; 0000 1111 1000 tttn #32-bit disp
                    (Assembler''emitByte-2 this, 0x0f)
                    (Assembler''emitByte-2 this, (| 0x80 (:value cc)))
                    (Assembler''emitInt-2 this, (int (- disp longSize)))
                )
            )
        )
        nil
    )

    (defn #_"void" Assembler''jcc-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Label" l]
        (if (Label''isBound-1 l)
            (Assembler''jcc-4 this, cc, (:position l), false)
            (do
                ;; note: could eliminate cond. jumps to this jump if condition is the same however, seems to be rather unlikely case
                ;; note: use jccb() if label to be bound is very close to get an 8-bit displacement
                (ยง ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, 0x0f)
                (Assembler''emitByte-2 this, (| 0x80 (:value cc)))
                (Assembler''emitInt-2 this, 0)
            )
        )
        nil
    )

    (defn #_"void" Assembler''jccb-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Label" l]
        (if (Label''isBound-1 l)
            (let [
                #_"int" shortSize 2
                #_"int" entry (:position l)
                #_"long" disp (- entry (Assembler''position-1 this))
            ]
                ;; 0111 tttn #8-bit disp
                (Assembler''emitByte-2 this, (| 0x70 (:value cc)))
                (Assembler''emitByte-2 this, (int (& (- disp shortSize) 0xff)))
            )
            (do
                (ยง ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, (| 0x70 (:value cc)))
                (Assembler''emitByte-2 this, 0)
            )
        )
        nil
    )

    (defn #_"void" Assembler''jmp-3 [#_"Assembler" this, #_"int" jumpTarget, #_"boolean" forceDisp32]
        (let [
            #_"int" shortSize 2
            #_"int" longSize 5
            #_"long" disp (- jumpTarget (Assembler''position-1 this))
        ]
            (if (and (not forceDisp32) (NumUtil'isByte-1l (- disp shortSize)))
                (do
                    (Assembler''emitByte-2 this, 0xeb)
                    (Assembler''emitByte-2 this, (int (& (- disp shortSize) 0xff)))
                )
                (do
                    (Assembler''emitByte-2 this, 0xe9)
                    (Assembler''emitInt-2 this, (int (- disp longSize)))
                )
            )
        )
        nil
    )

    (defn #_"void" Assembler''jmp-2l [#_"Assembler" this, #_"Label" l]
        (if (Label''isBound-1 l)
            (Assembler''jmp-3 this, (:position l), false)
            (do
                ;; By default, forward jumps are always 32-bit displacements, since we can't yet know where the label will be bound.
                ;; If you're sure that the forward jump will not run beyond 256 bytes, use jmpb to force an 8-bit displacement.
                (ยง ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, 0xe9)
                (Assembler''emitInt-2 this, 0)
            )
        )
        nil
    )

    (defn #_"void" Assembler''jmp-2r [#_"Assembler" this, #_"Register" entry]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding entry))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xe0 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''jmp-2a [#_"Assembler" this, #_"AMD64Address" adr]
        (Assembler''prefix-2 this, adr)
        (Assembler''emitByte-2 this, 0xff)
        (Assembler''emitOperandHelper-4r this, AMD64/rsp, adr, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''jmpb-2 [#_"Assembler" this, #_"Label" l]
        (if (Label''isBound-1 l)
            (let [
                #_"int" shortSize 2
                #_"int" entry (:position l)
                #_"long" offs (- entry (Assembler''position-1 this))
            ]
                (Assembler''emitByte-2 this, 0xeb)
                (Assembler''emitByte-2 this, (int (& (- offs shortSize) 0xff)))
            )
            (do
                (ยง ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, 0xeb)
                (Assembler''emitByte-2 this, 0)
            )
        )
        nil
    )

    (defn #_"void" Assembler''lead-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8d)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''leaq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8d)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''leave-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xc9)
        nil
    )

    (defn #_"void" Assembler''lock-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xf0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''movb-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm8]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xc6)
        (Assembler''emitOperandHelper-4i this, 0, dst, 1)
        (Assembler''emitByte-2 this, imm8)
        nil
    )

    (defn #_"void" Assembler''movb-3ar [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefix-4 this, dst, src, true)
        (Assembler''emitByte-2 this, 0x88)
        (Assembler''emitOperandHelper-4r this, src, dst, 0)
        nil
    )

    (defn #_"void" Assembler''movl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, (| 0xb8 encode))
            (Assembler''emitInt-2 this, imm32)
        )
        nil
    )

    (defn #_"void" Assembler''movl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3i this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x8b)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''movl-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8b)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    ;;;
     ; @param wide? use 4 byte encoding for displacements that would normally fit in a byte
     ;;
    #_unused
    (defn #_"void" Assembler''movl-4 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src, #_"boolean" wide?]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8b)
        (Assembler''emitOperandHelper-5r this, dst, src, wide?, 0)
        nil
    )

    (defn #_"void" Assembler''movl-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xc7)
        (Assembler''emitOperandHelper-4i this, 0, dst, 4)
        (Assembler''emitInt-2 this, imm32)
        nil
    )

    (defn #_"void" Assembler''movl-3ar [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefix-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x89)
        (Assembler''emitOperandHelper-4r this, src, dst, 0)
        nil
    )

    (defn #_"void" Assembler''movq-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''movq-4 this, dst, src, false)
        nil
    )

    (defn #_"void" Assembler''movq-4 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src, #_"boolean" wide]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8b)
        (Assembler''emitOperandHelper-5r this, dst, src, wide, 0)
        nil
    )

    (defn #_"void" Assembler''movq-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x8b)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''movq-3ar [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefixq-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x89)
        (Assembler''emitOperandHelper-4r this, src, dst, 0)
        nil
    )

    (defn #_"void" Assembler''movsbl-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xbe)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''movsbl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-5 this, (.encoding dst), false, (.encoding src), true)
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbe)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''movsbq-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xbe)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''movsbq-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbe)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''movswl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xbf)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''movw-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm16]
        (Assembler''emitByte-2 this, 0x66) ;; switch to 16-bit mode
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xc7)
        (Assembler''emitOperandHelper-4i this, 0, dst, 2)
        (Assembler''emitShort-2 this, imm16)
        nil
    )

    (defn #_"void" Assembler''movw-3ar [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''emitByte-2 this, 0x66)
        (Assembler''prefix-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x89)
        (Assembler''emitOperandHelper-4r this, src, dst, 0)
        nil
    )

    (defn #_"void" Assembler''movzbl-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb6)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''movzbl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 AMD64RMOp'MOVZXB, this, OperandSize'DWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''movzbq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 AMD64RMOp'MOVZXB, this, OperandSize'QWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''movzwl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb7)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''negl-2 [#_"Assembler" this, #_"Register" dst]
        (AMD64MOp''emit-4r AMD64MOp'NEG, this, OperandSize'DWORD, dst)
        nil
    )

    #_unused
    (defn #_"void" Assembler''notl-2 [#_"Assembler" this, #_"Register" dst]
        (AMD64MOp''emit-4r AMD64MOp'NOT, this, OperandSize'DWORD, dst)
        nil
    )

    #_unused
    (defn #_"void" Assembler''notq-2 [#_"Assembler" this, #_"Register" dst]
        (AMD64MOp''emit-4r AMD64MOp'NOT, this, OperandSize'QWORD, dst)
        nil
    )

    ;;;
     ; Emits a NOP instruction to advance the current PC.
     ;;
    (defn #_"void" Assembler''ensureUniquePC-1 [#_"Assembler" this]
        (Assembler''nop-1 this)
        nil
    )

    (defn #_"void" Assembler''nop-1 [#_"Assembler" this]
        (Assembler''nop-2 this, 1)
        nil
    )

    (defn #_"void" Assembler''nop-2 [#_"Assembler" this, #_"int" n]
        (cond
            Assembler'UseNormalNop
            (do
                ;; The fancy nops aren't currently recognized by debuggers making it a pain to disassemble code while debugging.
                ;; If assert are on clearly speed is not an issue so simply use the single byte traditional nop to do alignment.
                (dotimes [_ n]
                    (Assembler''emitByte-2 this, 0x90)
                )
            )

            Assembler'UseAddressNop
            (do
                ;; Using multi-bytes nops "0x0f 0x1f [Address]" for AMD.
                ;;
                ;;  1: 0x90
                ;;  2: 0x66 0x90
                ;;  3: 0x66 0x66 0x90 (don't use "0x0f 0x1f 0x00" - need patching safe padding)
                ;;  4: 0x0f 0x1f 0x40 0x00
                ;;  5: 0x0f 0x1f 0x44 0x00 0x00
                ;;  6: 0x66 0x0f 0x1f 0x44 0x00 0x00
                ;;  7: 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00
                ;;  8: 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;;  9: 0x66 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;; 10: 0x66 0x66 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;; 11: 0x66 0x66 0x66 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;;
                ;; The rest coding is AMD specific - use consecutive Address nops.
                ;;
                ;; 12: 0x66 0x0f 0x1f 0x44 0x00 0x00 0x66 0x0f 0x1f 0x44 0x00 0x00
                ;; 13: 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00 0x66 0x0f 0x1f 0x44 0x00 0x00
                ;; 14: 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00
                ;; 15: 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00
                ;; 16: 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;;
                ;; Size prefixes (0x66) are added for larger sizes.
                (ยง ass n
                    (loop-when-recur n (<= 22 n) (- n 11) => n
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                    )
                )
                ;; Generate first nop for size between 21-12.
                (ยง ass n
                    (case n
                        21
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop8-1 this)
                            (- n 11)
                        )
                        (20 19)
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop8-1 this)
                            (- n 10)
                        )
                        (18 17)
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop8-1 this)
                            (- n 9)
                        )
                        (16 15)
                        (do
                            (Assembler''addrNop8-1 this)
                            (- n 8)
                        )
                        (14 13)
                        (do
                            (Assembler''addrNop7-1 this)
                            (- n 7)
                        )
                        12
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop5-1 this)
                            (- n 6)
                        )
                        n
                    )
                )

                ;; Generate second nop for size between 11-1.
                (case n
                    11
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    10
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    9
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    8
                    (do
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    7
                    (do
                        (Assembler''addrNop7-1 this)
                        nil
                    )
                    6
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop5-1 this)
                        nil
                    )
                    5
                    (do
                        (Assembler''addrNop5-1 this)
                        nil
                    )
                    4
                    (do
                        (Assembler''addrNop4-1 this)
                        nil
                    )
                    3
                    (do
                        ;; Don't use "0x0f 0x1f 0x00" - need patching safe padding.
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    2
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    1
                    (do
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    nil
                )
            )

            :else
            (do
                ;; Using nops with size prefixes "0x66 0x90".
                ;; From AMD Optimization Guide:
                ;;  1: 0x90
                ;;  2: 0x66 0x90
                ;;  3: 0x66 0x66 0x90
                ;;  4: 0x66 0x66 0x66 0x90
                ;;  5: 0x66 0x66 0x90 0x66 0x90
                ;;  6: 0x66 0x66 0x90 0x66 0x66 0x90
                ;;  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
                ;;  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
                ;;  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
                ;; 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
                (ยง ass n
                    (loop-when-recur n (< 12 n) (- n 4) => n
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                    )
                )
                ;; 1 - 12 nops
                (when (< 8 n)
                    (when (< 9 n)
                        (Assembler''emitByte-2 this, 0x66)
                        (ยง ass n (dec n))
                    )
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x90)
                    (ยง ass n (- n 3))
                )
                ;; 1 - 8 nops
                (when (< 4 n)
                    (when (< 6 n)
                        (Assembler''emitByte-2 this, 0x66)
                        (ยง ass n (dec n))
                    )
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x90)
                    (ยง ass n (- n 3))
                )
                (case n
                    4
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    3
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    2
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    1
                    (do
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    nil
                )
            )
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''orl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'OR), this, OperandSize'DWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''orl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'OR, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    #_unused
    (defn #_"void" Assembler''pop-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, (| 0x58 encode))
        )
        nil
    )

    (defn #_"void" Assembler''push-2 [#_"Assembler" this, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding src))
        ]
            (Assembler''emitByte-2 this, (| 0x50 encode))
        )
        nil
    )

    (defn #_"void" Assembler''ret-2 [#_"Assembler" this, #_"int" imm16]
        (if (zero? imm16)
            (Assembler''emitByte-2 this, 0xc3)
            (do
                (Assembler''emitByte-2 this, 0xc2)
                (Assembler''emitShort-2 this, imm16)
            )
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''sarl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xf8 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xf8 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''shll-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''shll-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe0 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''shrl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xc1)
            (Assembler''emitByte-2 this, (| 0xe8 encode))
            (Assembler''emitByte-2 this, imm8)
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''shrl-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe8 encode))
        )
        nil
    )

    (defn #_"void" Assembler''subl-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5a (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''subl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'DWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''subl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'SUB), this, OperandSize'DWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''testl-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        ;; not using emitArith because test
        ;; doesn't support sign-extension of
        ;; 8bit operands
        (let [
            #_"int" encode (.encoding dst)
        ]
            (if (zero? encode)
                (Assembler''emitByte-2 this, 0xa9)
                (do
                    (ยง ass encode (Assembler''prefixAndEncode-2 this, encode))
                    (Assembler''emitByte-2 this, 0xf7)
                    (Assembler''emitByte-2 this, (| 0xc0 encode))
                )
            )
            (Assembler''emitInt-2 this, imm32)
        )
        nil
    )

    (defn #_"void" Assembler''testl-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3i this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x85)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''testl-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x85)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''xorl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'XOR), this, OperandSize'DWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''decl-2r [#_"Assembler" this, #_"Register" dst]
        ;; Use two-byte form (one-byte form is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (defn #_"void" Assembler''incl-2r [#_"Assembler" this, #_"Register" dst]
        ;; Use two-byte form (one-byte from is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''addq-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'QWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''addq-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5a (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'QWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''addq-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'ADD), this, OperandSize'QWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''addq-3ar [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (AMD64MROp''emit-5 (:mrOp BinaryArithmetic'ADD), this, OperandSize'QWORD, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''andq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'AND, OperandSize'QWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    #_unused
    (defn #_"void" Assembler''bsrq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (#_"Register" .encoding dst), (#_"Register" .encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbd)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''bswapq-2 [#_"Assembler" this, #_"Register" reg]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding reg))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (defn #_"void" Assembler''cdqq-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, Prefix'REXW)
        (Assembler''emitByte-2 this, 0x99)
        nil
    )

    (defn #_"void" Assembler''cmovq-4rr [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''setb-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3b this, (.encoding dst), true)
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0x90 (:value cc)))
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''cmovq-4ra [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''cmpq-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'QWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''cmpq-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'QWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''cmpq-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'QWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''cmpxchgq-3 [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" adr]
        (Assembler''prefixq-3 this, adr, reg)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb1)
        (Assembler''emitOperandHelper-4r this, reg, adr, 0)
        nil
    )

    (defn #_"void" Assembler''decq-2r [#_"Assembler" this, #_"Register" dst]
        ;; Use two-byte form (one-byte from is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (defn #_"void" Assembler''decq-2a [#_"Assembler" this, #_"AMD64Address" dst]
        (AMD64MOp''emit-4a AMD64MOp'DEC, this, OperandSize'QWORD, dst)
        nil
    )

    #_unused
    (defn #_"void" Assembler''imulq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xaf)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''incq-2r [#_"Assembler" this, #_"Register" dst]
        ;; Don't use it directly. Use the macro incrementq() instead.
        ;; Use two-byte form (one-byte from is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''incq-2a [#_"Assembler" this, #_"AMD64Address" dst]
        (AMD64MOp''emit-4a AMD64MOp'INC, this, OperandSize'QWORD, dst)
        nil
    )

    (defn #_"void" Assembler''movq-3rl [#_"Assembler" this, #_"Register" dst, #_"long" imm64]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, (| 0xb8 encode))
            (Assembler''emitLong-2 this, imm64)
        )
        nil
    )

    (defn #_"void" Assembler''movslq-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xc7)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
            (Assembler''emitInt-2 this, imm32)
        )
        nil
    )

    (defn #_"void" Assembler''movslq-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (Assembler''prefixq-2 this, dst)
        (Assembler''emitByte-2 this, 0xc7)
        (Assembler''emitOperandHelper-4i this, 0, dst, 4)
        (Assembler''emitInt-2 this, imm32)
        nil
    )

    (defn #_"void" Assembler''movslq-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x63)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''movslq-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x63)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''negq-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xf7)
            (Assembler''emitByte-2 this, (| 0xd8 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''orq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'OR), this, OperandSize'QWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''shlq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''shlq-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe0 encode))
        )
        nil
    )

    (defn #_"void" Assembler''shrq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xe8 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xe8 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''shrq-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe8 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''sbbq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'SBB), this, OperandSize'QWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''subq-3ri [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'QWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''subq-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5a (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'QWORD, (NumUtil'isByte-1i imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''subqWide-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        ;; don't use the sign-extending version, forcing a 32-bit immediate
        (AMD64MIOp''emit-5r (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'QWORD, false), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (defn #_"void" Assembler''subq-3rr [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RROp'''emit-5 (:rmOp BinaryArithmetic'SUB), this, OperandSize'QWORD, dst, src)
        nil
    )

    (defn #_"void" Assembler''testq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x85)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (defn #_"void" Assembler''btrq-3 [#_"Assembler" this, #_"Register" src, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xba)
            (Assembler''emitByte-2 this, (| 0xf0 encode))
            (Assembler''emitByte-2 this, imm8)
        )
        nil
    )

    (defn #_"void" Assembler''xaddl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefix-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xc1)
        (Assembler''emitOperandHelper-4r this, src, dst, 0)
        nil
    )

    (defn #_"void" Assembler''xaddq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefixq-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xc1)
        (Assembler''emitOperandHelper-4r this, src, dst, 0)
        nil
    )

    (defn #_"void" Assembler''xchgl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x87)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''xchgq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x87)
        (Assembler''emitOperandHelper-4r this, dst, src, 0)
        nil
    )

    (defn #_"void" Assembler''membar-2 [#_"Assembler" this, #_"int" barriers]
        (when (.isMP HotSpot'target)
            ;; We only have to handle StoreLoad.
            (when-not (zero? (& barriers MemoryBarriers/STORE_LOAD))
                ;; All usable chips support "locked" instructions which suffice as barriers,
                ;; and are much faster than the alternative of using cpuid instruction.
                ;; We use here a locked add [rsp],0. This is conveniently otherwise a no-op except
                ;; for blowing flags. Any change to this code may need to revisit other places
                ;; in the code where this idiom is used, in particular the orderAccess code.
                (Assembler''lock-1 this)
                (Assembler''addl-3ai this, (AMD64Address'new-2 AMD64/rsp, 0), 0) ;; Assert the lock# signal here.
            )
        )
        nil
    )

    (defn #_"void" Assembler''patchJumpTarget-3 [#_"Assembler" this, #_"int" branch, #_"int" jumpTarget]
        (let [
            #_"int" op (Assembler''getByte-2 this, branch)
        ]
            (cond
                (= op 0x00)
                    (let [
                        #_"int" offsetToJumpTableBase (Assembler''getShort-2 this, (inc branch))
                        #_"int" jumpTableBase (- branch offsetToJumpTableBase)
                        #_"int" imm32 (- jumpTarget jumpTableBase)
                    ]
                        (Assembler''emitInt-3 this, imm32, branch)
                    )
                (or (= op 0xeb) (= (& op 0xf0) 0x70))
                    ;; short offset operators (jmp and jcc)
                    (let [
                        #_"int" imm8 (- jumpTarget (+ branch 2))
                    ]
                        ;; Since a wrongly patched short branch can potentially lead to working but really bad
                        ;; behaving code we should always fail with an exception instead of having an assert.
                        (when-not (NumUtil'isByte-1i imm8)
                            (throw! (str "branch displacement out of range: " imm8))
                        )
                        (Assembler''emitByte-3 this, imm8, (inc branch))
                    )
                :else
                    (let [
                        #_"int" off (if (= op 0x0f) 2 1)
                        #_"int" imm32 (- jumpTarget (+ branch 4 off))
                    ]
                        (Assembler''emitInt-3 this, imm32, (+ branch off))
                    )
            )
        )
        nil
    )

    (defn #_"void" Assembler''nullCheck-2 [#_"Assembler" this, #_"AMD64Address" address]
        (Assembler''testl-3ra this, AMD64/rax, address)
        nil
    )

    (defn #_"void" Assembler''align-2 [#_"Assembler" this, #_"int" modulus]
        (when-not (zero? (% (Assembler''position-1 this) modulus))
            (Assembler''nop-2 this, (- modulus (% (Assembler''position-1 this) modulus)))
        )
        nil
    )

    ;;;
     ; Emits a direct call instruction. Note that the actual call target is not specified, because
     ; all calls need patching anyway. Therefore, 0 is emitted as the call target, and the user is
     ; responsible to add the call address to the appropriate patching tables.
     ;;
    (defn #_"void" Assembler''call-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xe8)
        (Assembler''emitInt-2 this, 0)
        nil
    )

    (defn #_"void" Assembler''call-2 [#_"Assembler" this, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xd0 encode))
        )
        nil
    )

    ;;;
     ; Returns a target specific placeholder address that can be used for code patching.
     ;
     ; @param pos The start of the instruction, i.e. the value that is used as the key
     ;            for looking up placeholder patching information.
     ;;
    (defn #_"AMD64Address" Assembler'createPlaceholder-1 [#_"int" pos]
        (AMD64Address'new-5 AMD64/rip, Register/None, Scale'Times1, 0, pos)
    )

    (defn- #_"void" Assembler''prefetchPrefix-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0f)
        nil
    )

    (defn #_"void" Assembler''prefetchnta-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4i this, 0, src, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''prefetchr-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0d)
        (Assembler''emitOperandHelper-4i this, 0, src, 0)
        nil
    )

    (defn #_"void" Assembler''prefetcht0-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4i this, 1, src, 0)
        nil
    )

    #_unused
    (defn #_"void" Assembler''prefetcht1-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4i this, 2, src, 0)
        nil
    )

    (defn #_"void" Assembler''prefetcht2-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4i this, 3, src, 0)
        nil
    )

    (defn #_"void" Assembler''prefetchw-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x0d)
        (Assembler''emitOperandHelper-4i this, 1, src, 0)
        nil
    )

    (defn #_"void" Assembler''rdtsc-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x31)
        nil
    )

    ;;;
     ; Emits an instruction which is considered to be illegal. This is used if we deliberately want
     ; to crash the program (debugging etc.).
     ;;
    #_unused
    (defn #_"void" Assembler''illegal-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x0b)
        nil
    )

    (defn #_"void" Assembler''lfence-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xae)
        (Assembler''emitByte-2 this, 0xe8)
        nil
    )

    ;; masm

    (defn #_"void" Assembler''decrementq-3r [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subq-3ri this, reg, value)
            (neg? value)                          (Assembler''incrementq-3r this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decq-2r this, reg)
            :else                                 (Assembler''subq-3ri this, reg, value)
        )
        nil
    )

    (defn #_"void" Assembler''decrementq-3a [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subq-3ai this, dst, value)
            (neg? value)                          (Assembler''incrementq-3a this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decq-2a this, dst)
            :else                                 (Assembler''subq-3ai this, dst, value)
        )
        nil
    )

    (defn #_"void" Assembler''incrementq-3r [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addq-3ri this, reg, value)
            (neg? value)                          (Assembler''decrementq-3r this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incq-2r this, reg)
            :else                                 (Assembler''addq-3ri this, reg, value)
        )
        nil
    )

    (defn #_"void" Assembler''incrementq-3a [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addq-3ai this, dst, value)
            (neg? value)                          (Assembler''decrementq-3a this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incq-2a this, dst)
            :else                                 (Assembler''addq-3ai this, dst, value)
        )
        nil
    )

    (defn #_"void" Assembler''movptr-3ra [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''movq-3ra this, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''movptr-3ar [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''movq-3ar this, dst, src)
        nil
    )

    #_unused
    (defn #_"void" Assembler''movptr-3ai [#_"Assembler" this, #_"AMD64Address" dst, #_"int" src]
        (Assembler''movslq-3ai this, dst, src)
        nil
    )

    (defn #_"void" Assembler''cmpptr-3rr [#_"Assembler" this, #_"Register" src1, #_"Register" src2]
        (Assembler''cmpq-3rr this, src1, src2)
        nil
    )

    #_unused
    (defn #_"void" Assembler''cmpptr-3ra [#_"Assembler" this, #_"Register" src1, #_"AMD64Address" src2]
        (Assembler''cmpq-3ra this, src1, src2)
        nil
    )

    #_unused
    (defn #_"void" Assembler''decrementl-2 [#_"Assembler" this, #_"Register" reg]
        (Assembler''decrementl-3r this, reg, 1)
        nil
    )

    (defn #_"void" Assembler''decrementl-3r [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subl-3ri this, reg, value)
            (neg? value)                          (Assembler''incrementl-3r this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decl-2r this, reg)
            :else                                 (Assembler''subl-3ri this, reg, value)
        )
        nil
    )

    (defn #_"void" Assembler''decrementl-3a [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subl-3ai this, dst, value)
            (neg? value)                          (Assembler''incrementl-3a this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decl-2a this, dst)
            :else                                 (Assembler''subl-3ai this, dst, value)
        )
        nil
    )

    (defn #_"void" Assembler''incrementl-3r [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addl-3ri this, reg, value)
            (neg? value)                          (Assembler''decrementl-3r this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incl-2r this, reg)
            :else                                 (Assembler''addl-3ri this, reg, value)
        )
        nil
    )

    (defn #_"void" Assembler''incrementl-3a [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addl-3ai this, dst, value)
            (neg? value)                          (Assembler''decrementl-3a this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incl-2a this, dst)
            :else                                 (Assembler''addl-3ai this, dst, value)
        )
        nil
    )

    ;;;
     ; Non-atomic write of a 64-bit constant to memory.
     ; Do not use if the address might be a volatile field!
     ;;
    (defn #_"void" Assembler''movlong-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"long" src]
        (if (NumUtil'isInt-1 src)
            (AMD64MIOp''emit-5a AMD64MIOp'MOV, this, OperandSize'QWORD, dst, (int src))
            (let [
                #_"AMD64Address" high (AMD64Address'new-4 (:base dst), (:index dst), (:scale dst), (+ (:displacement dst) 4))
            ]
                (Assembler''movl-3ai this, dst, (int (& src 0xffffffff)))
                (Assembler''movl-3ai this, high, (int (>> src 32)))
            )
        )
        nil
    )

    (defn #_"void" Assembler''setl-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst]
        (Assembler''setb-3 this, cc, dst)
        (Assembler''movzbl-3rr this, dst, dst)
        nil
    )

    (defn #_"void" Assembler''setq-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst]
        (Assembler''setb-3 this, cc, dst)
        (Assembler''movzbq-3 this, dst, dst)
        nil
    )

    ;; crb

    (defn #_"Mark" Assembler''recordMark-2 [#_"Assembler" this, #_"Object" id]
        (CompilationResult''recordMark-3 (:compilationResult this), (Assembler''position-1 this), id)
    )

    (defn #_"void" Assembler''recordInlineDataInCode-2 [#_"Assembler" this, #_"Constant" data]
        (when (instance? VMConstant data)
            (CompilationResult''recordDataPatch-3 (:compilationResult this), (Assembler''position-1 this), (ConstantReference. data))
        )
        nil
    )

    (defn #_"AbstractAddress" Assembler''recordDataSectionReference-2 [#_"Assembler" this, #_"Data" data]
        (let [
            #_"DataSectionReference" reference (DataSection''insertData-2 (:dataSection (:compilationResult this)), data)
            #_"int" pos (Assembler''position-1 this)
        ]
            (CompilationResult''recordDataPatch-3 (:compilationResult this), pos, reference)
            (Assembler'createPlaceholder-1 pos)
        )
    )

    (defn- #_"Data" Assembler''createDataItem-2 [#_"Assembler" this, #_"Constant" constant]
        (or (get (:dataCache this) constant)
            (let [
                #_"Data" data (DataBuilder'createDataItem-1 constant)
            ]
                (#_"EconomicMap" .put (:dataCache this), constant, data)
                data
            )
        )
    )

    (defn #_"AbstractAddress" Assembler''recordDataReferenceInCode-3c [#_"Assembler" this, #_"Constant" constant, #_"int" alignment]
        (let [
            #_"Data" data (Assembler''createDataItem-2 this, constant)
        ]
            (ยง ass! data (Data''updateAlignment-2 data, alignment))
            (Assembler''recordDataSectionReference-2 this, data)
        )
    )

    #_unused
    (defn #_"AbstractAddress" Assembler''recordDataReferenceInCode-3d [#_"Assembler" this, #_"Data" data, #_"int" alignment]
        (ยง ass! data (Data''updateAlignment-2 data, alignment))
        (Assembler''recordDataSectionReference-2 this, data)
    )

    #_unused
    (defn #_"AbstractAddress" Assembler''recordDataReferenceInCode-3a [#_"Assembler" this, #_"byte[]" data, #_"int" alignment]
        (Assembler''recordDataSectionReference-2 this, (RawData'new-2 data, alignment))
    )

    ;;;
     ; Returns the address of a long constant that is embedded as a data reference into the code.
     ;;
    (defn #_"AbstractAddress" Assembler''asLongConstRef-2 [#_"Assembler" this, #_"JavaConstant" value]
        (Assembler''recordDataReferenceInCode-3c this, value, 8)
    )

    (defn #_"AbstractAddress" Assembler''asAddress-2 [#_"Assembler" this, #_"Value" value]
        (AMD64Address'new-2 (#_"RegisterConfig" .getFrameRegister HotSpot'registerConfig), (FrameMap''offsetForStackSlot-2 (:frameMap this), value))
    )

    ;;;
     ; Determines if a given edge from the block currently being emitted goes to its lexical successor.
     ;;
    (defn #_"boolean" Assembler''isSuccessorEdge-2 [#_"Assembler" this, #_"LabelRef" edge]
        (= (LIR'getNextBlock-2 (:codeEmittingOrder (:lir this)), (:currentBlockIndex this)) (LabelRef''getTargetBlock-1 edge))
    )

    ;;;
     ; Emits code for {@code lir} in its {@linkplain LIR#codeEmittingOrder() code emitting order}.
     ;;
    (defn #_"this" Assembler''assemble-1 [#_"Assembler" this]
        (Assembler''align-2 this, HotSpot'codeEntryAlignment)
        (Assembler''recordMark-2 this, HotSpot'verifiedEntryMark)

        (FrameContext''enter-2 (:frameContext this), this)
        (let [
            this
                (loop-when [this this #_"ISeq" s (seq (:codeEmittingOrder (:lir this)))] (some? s) => this
                    (let [
                        #_"Block" block (first s)
                    ]
                        (when (some? block)
                            (doseq [#_"LIRInstruction" op (LIR''getLIRforBlock-2 (:lir this), block)]
                                (LIRInstruction'''emitCode-2 op, this)
                            )
                        )
                        (recur (update this :currentBlockIndex inc) (next s))
                    )
                )
        ]
            (Assembler''recordMark-2 this, HotSpot'deoptHandlerEntryMark)
            (AMD64Call'directCall-4 this, (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, ForeignCallDescriptor'DEOPTIMIZATION_HANDLER), nil, false)
            this
        )
    )

    (defn #_"CompilationResult" Assembler''finish-1 [#_"Assembler" this]
        (ยง ass! (:compilationResult this) (CompilationResult''setTargetCode-3 (:compilationResult this), (Assembler''close-2 this, false), (Assembler''position-1 this)))
        (CompilationResult''close-1 (:compilationResult this))
    )
)

(class-ns BaseSwitchClosure [SwitchClosure]
    (defn #_"BaseSwitchClosure" BaseSwitchClosure'new-3 [#_"Assembler" asm, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget]
        (merge (BaseSwitchClosure'class.)
            (hash-map
                #_"Assembler" :asm asm
                #_"LabelRef[]" :keyTargets keyTargets
                #_"LabelRef" :defaultTarget defaultTarget
            )
        )
    )

    (defm BaseSwitchClosure BaseSwitchClosure
        (#_"void" BaseSwitchClosure'''conditionalJump-4 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" targetDefault]
            (let [
                #_"Label" target (if targetDefault (LabelRef''label-1 (:defaultTarget this)) (LabelRef''label-1 (nth (:keyTargets this) index)))
            ]
                (if (nil? condition)
                    (Assembler''jmp-2l (:asm this), target)
                    (BaseSwitchClosure'''conditionalJump-4 this, index, condition, target)
                )
            )
            nil
        )
    )

    (defm BaseSwitchClosure SwitchClosure
        (#_"void" SwitchClosure'''conditionalJumpOrDefault-4 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" canFallThrough]
            (cond
                (and canFallThrough (Assembler''isSuccessorEdge-2 (:asm this), (:defaultTarget this)))
                    (BaseSwitchClosure'''conditionalJump-4 this, index, condition, (LabelRef''label-1 (nth (:keyTargets this) index)))
                (and canFallThrough (Assembler''isSuccessorEdge-2 (:asm this), (nth (:keyTargets this) index)))
                    (BaseSwitchClosure'''conditionalJump-4 this, index, (Condition''negate-1 condition), (LabelRef''label-1 (:defaultTarget this)))
                :else
                (do
                    (BaseSwitchClosure'''conditionalJump-4 this, index, condition, (LabelRef''label-1 (nth (:keyTargets this) index)))
                    (Assembler''jmp-2l (:asm this), (LabelRef''label-1 (:defaultTarget this)))
                )
            )
            nil
        )

        (#_"Label" SwitchClosure'''conditionalJump-3 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition]
            (let [
                #_"Label" label (Label'new-0)
            ]
                (BaseSwitchClosure'''conditionalJump-4 this, index, condition, label)
                label
            )
        )

        (#_"void" SwitchClosure'''bind-2 [#_"BaseSwitchClosure" this, #_"Label" label]
            (Assembler''bind-2 (:asm this), label)
            nil
        )

        (#_"boolean" SwitchClosure'''isSameTarget-3 [#_"BaseSwitchClosure" this, #_"int" index1, #_"int" index2]
            (= (nth (:keyTargets this) index1) (nth (:keyTargets this) index2))
        )
    )
)

(class-ns AMD64SwitchClosure [BaseSwitchClosure, SwitchClosure]
    (defn #_"AMD64SwitchClosure" AMD64SwitchClosure'new-3 [#_"StrategySwitchOp" op, #_"Register" keyRegister, #_"Assembler" asm]
        (merge (AMD64SwitchClosure'class.) (BaseSwitchClosure'new-3 asm, (:keyTargets op), (:defaultTarget op))
            (hash-map
                #_"StrategySwitchOp" :op op
                #_"Register" :keyRegister keyRegister
                #_"Assembler" :asm asm
            )
        )
    )

    (defm AMD64SwitchClosure AMD64SwitchClosure
        (#_"void" AMD64SwitchClosure'''emitComparison-2 [#_"AMD64SwitchClosure" this, #_"Constant" c]
            (condp = (#_"JavaConstant" .getJavaKind c)
                JavaKind/Int  (Assembler''cmpl-3ri (:asm this), (:keyRegister this), (int (#_"JavaConstant" .asLong c)))
                JavaKind/Long (Assembler''cmpq-3ra (:asm this), (:keyRegister this), (Assembler''asLongConstRef-2 (:asm this), c))
                JavaKind/Object
                    (do
                        (AMD64Move'const2reg-3 (:asm this), (#_"RegisterValue" .getRegister (:scratch (:op this))), c)
                        (Assembler''cmpptr-3rr (:asm this), (:keyRegister this), (#_"RegisterValue" .getRegister (:scratch (:op this))))
                    )
            )
            nil
        )
    )

    (defm AMD64SwitchClosure BaseSwitchClosure
        (#_"void" BaseSwitchClosure'''conditionalJump-4 [#_"AMD64SwitchClosure" this, #_"int" index, #_"Condition" condition, #_"Label" target]
            (AMD64SwitchClosure'''emitComparison-2 this, (nth (:keyConstants (:op this)) index))
            (Assembler''jcc-3 (:asm this), (AMD64ControlFlow'intCond-1 condition), target)
            nil
        )
    )
)

(class-ns HotSpotSwitchClosure [AMD64SwitchClosure, BaseSwitchClosure, SwitchClosure]
    (defn #_"HotSpotSwitchClosure" HotSpotSwitchClosure'new-3 [#_"AMD64HotSpotStrategySwitchOp" op, #_"Register" keyRegister, #_"Assembler" asm]
        (merge (HotSpotSwitchClosure'class.) (AMD64SwitchClosure'new-3 op, keyRegister, asm))
    )

    (defm HotSpotSwitchClosure AMD64SwitchClosure
        (#_"void" AMD64SwitchClosure'''emitComparison-2 [#_"HotSpotSwitchClosure" this, #_"Constant" constant]
            (when (instance? HotSpotMetaspaceConstant constant) => (AMD64SwitchClosure'''emitComparison-2 (ยง super AMD64SwitchClosure'iface), constant)
                (if (#_"HotSpotMetaspaceConstant" .isCompressed constant)
                    (do
                        (Assembler''recordInlineDataInCode-2 (:asm this), constant)
                        (Assembler''cmpl-3ri (:asm this), (:keyRegister this), 0xdeaddead)
                    )
                    (let [
                        #_"AMD64Address" addr (Assembler''recordDataReferenceInCode-3c (:asm this), constant, 8)
                    ]
                        (Assembler''cmpq-3ra (:asm this), (:keyRegister this), addr)
                    )
                )
            )
            nil
        )
    )
)

(class-ns BciBlock []
    (defn #_"BciBlock" BciBlock'new-1 [#_"int" startBci]
        (merge (BciBlock'class.)
            (hash-map
                #_"int" :id 0
                #_"int" :startBci startBci
                #_"int" :endBci 0
                #_"boolean" :isLoopHeader false
                #_"int" :loopId 0
                #_"int" :loopEnd 0
                #_"List<BciBlock>" :successors (ArrayList.)
                #_"int" :predecessorCount 0
                #_"boolean" :visited false
                #_"boolean" :active false
                #_"long" :loops 0
                #_"JSRData" :jsrData nil
            )
        )
    )

    (defn #_"BciBlock" BciBlock'copy-1 [#_"BciBlock" other]
        (let [
            #_"BciBlock" this (#_"Object" .clone (ยง super #_"Object"))
            this
                (when (some? (:jsrData this)) => this
                    (assoc this :jsrData (#_"Object" .clone (:jsrData this)))
                )
            this (assoc this :successors (ArrayList. (:successors other)))
        ]
            this
        )
    )

    (defn #_"BciBlock" BciBlock''getSuccessor-2 [#_"BciBlock" this, #_"int" index]
        (nth (:successors this) index)
    )

    (defn- #_"JSRData" BciBlock''getOrCreateJSRData-1 [#_"BciBlock" this]
        (when (nil? (:jsrData this))
            (ยง ass! this (assoc this :jsrData (JSRData'new-0)))
        )
        (:jsrData this)
    )

    (defn #_"void" BciBlock''setEndsWithRet-1 [#_"BciBlock" this]
        (ยง ass! (:endsWithRet (BciBlock''getOrCreateJSRData-1 this)) true)
        nil
    )

    (defn #_"JsrScope" BciBlock''getJsrScope-1 [#_"BciBlock" this]
        (if (some? (:jsrData this)) (:jsrScope (:jsrData this)) JsrScope'EMPTY_SCOPE)
    )

    (defn #_"boolean" BciBlock''endsWithRet-1 [#_"BciBlock" this]
        (and (some? (:jsrData this)) (:endsWithRet (:jsrData this)))
    )

    (defn #_"void" BciBlock''setRetSuccessor-2 [#_"BciBlock" this, #_"BciBlock" bciBlock]
        (ยง ass! (:retSuccessor (BciBlock''getOrCreateJSRData-1 this)) bciBlock)
        nil
    )

    (defn #_"BciBlock" BciBlock''getRetSuccessor-1 [#_"BciBlock" this]
        (when (some? (:jsrData this)) (:retSuccessor (:jsrData this)))
    )

    (defn #_"BciBlock" BciBlock''getJsrSuccessor-1 [#_"BciBlock" this]
        (when (some? (:jsrData this)) (:jsrSuccessor (:jsrData this)))
    )

    (defn #_"int" BciBlock''getJsrReturnBci-1 [#_"BciBlock" this]
        (if (some? (:jsrData this)) (:jsrReturnBci (:jsrData this)) -1)
    )

    (defn #_"EconomicMap<JsrScope, BciBlock>" BciBlock''getJsrAlternatives-1 [#_"BciBlock" this]
        (when (some? (:jsrData this)) (:jsrAlternatives (:jsrData this)))
    )

    (defn #_"void" BciBlock''initJsrAlternatives-1 [#_"BciBlock" this]
        (let [
            #_"JSRData" data (BciBlock''getOrCreateJSRData-1 this)
        ]
            (when (nil? (:jsrAlternatives data))
                (ยง ass! data (assoc data :jsrAlternatives (EconomicMap/create)))
            )
        )
        nil
    )

    (defn #_"void" BciBlock''setJsrScope-2 [#_"BciBlock" this, #_"JsrScope" nextScope]
        (ยง ass! (:jsrScope (BciBlock''getOrCreateJSRData-1 this)) nextScope)
        nil
    )

    (defn #_"void" BciBlock''setJsrSuccessor-2 [#_"BciBlock" this, #_"BciBlock" clone]
        (ยง ass! (:jsrSuccessor (BciBlock''getOrCreateJSRData-1 this)) clone)
        nil
    )

    (defn #_"void" BciBlock''setJsrReturnBci-2 [#_"BciBlock" this, #_"int" bci]
        (ยง ass! (:jsrReturnBci (BciBlock''getOrCreateJSRData-1 this)) bci)
        nil
    )

    (defn #_"BciBlock" BciBlock''setId-2 [#_"BciBlock" this, #_"int" id]
        (assoc this :id id)
    )

    (defn #_"void" BciBlock''addSuccessor-2 [#_"BciBlock" this, #_"BciBlock" sux]
        (#_"List" .add (:successors this), sux)
        (ยง ass sux (update sux :predecessorCount inc))
        nil
    )

    (defn #_"void" BciBlock''clearSucccessors-1 [#_"BciBlock" this]
        (loop-when-recur [#_"ISeq" s (seq (:successors this))] (some? s) [(next s)]
            (let [
                #_"BciBlock" sux (first s)
            ]
                (ยง ass! sux (update sux :predecessorCount dec))
            )
        )
        (#_"List" .clear (:successors this))
        nil
    )
)

;;;
 ; Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
 ; (CFG). It makes one linear passes over the bytecodes to build the CFG where it detects block
 ; headers and connects them.
 ;
 ; It also creates exception dispatch blocks for exception handling. These blocks are between a
 ; bytecode that might throw an exception, and the actual exception handler entries, and are later
 ; used to create the type checks with the exception handler catch types. If a bytecode is covered
 ; by an exception handler, this bytecode ends the basic block. This guarantees that (a) control flow
 ; cannot be transferred to an exception dispatch block in the middle of a block, and (b) that every
 ; block has at most one exception dispatch block (which is always the last entry in the successor list).
 ;
 ; If a bytecode is covered by multiple exception handlers, a chain of exception dispatch blocks is
 ; created so that multiple exception handler types can be checked. The chains are re-used if
 ; multiple bytecodes are covered by the same exception handlers.
 ;
 ; Note that exception unwinds, i.e. bytecodes that can throw an exception but the exception is not
 ; handled in this method, do not end a basic block. Not modeling the exception unwind block reduces
 ; the complexity of the CFG, and there is no algorithm yet where the exception unwind block would matter.
 ;
 ; The class also handles subroutines (jsr and ret bytecodes): subroutines are inlined by
 ; duplicating the subroutine blocks. This is limited to simple, structured subroutines with a
 ; maximum subroutine nesting of 4. Otherwise, a bailout is thrown.
 ;
 ; Loops in the methods are detected. If a method contains an irreducible loop (a loop with more
 ; than one entry), a bailout is thrown. This simplifies the compiler later on since only structured
 ; loops need to be supported.
 ;
 ; A data flow analysis computes the live local variables from the point of view of the interpreter.
 ; The result is used later to prune frame states, i.e. remove local variable entries that are
 ; guaranteed to be never used again (even in the case of deoptimization).
 ;
 ; The algorithms and analysis in this class are conservative and do not use any assumptions or
 ; profiling information.
 ;;
(class-ns BciBlockMapping []
    (def- #_"int" BciBlockMapping'LOOP_HEADER_MAX_CAPACITY Long/SIZE)
    (def- #_"int" BciBlockMapping'LOOP_HEADER_INITIAL_CAPACITY 4)

    ;;;
     ; Creates a new BlockMap instance from {@code code}.
     ;;
    (defn- #_"BciBlockMapping" BciBlockMapping'new-1 [#_"Bytecode" code]
        (merge (BciBlockMapping'class.)
            (hash-map
                #_"Bytecode" :code code
                ;;;
                 ; The blocks found in this method, in reverse postorder.
                 ;;
                #_"BciBlock[]" :blocks nil
                #_"BciBlock" :startBlock nil
                #_"int" :blocksNotYetAssignedId 0
                ;;;
                 ; The next available loop number.
                 ;;
                #_"int" :nextLoop 0
                #_"BciBlock[]" :loopHeaders nil
                #_"boolean" :loopChanges false
                #_"boolean" :hasJsrBytecodes false
                #_"ArrayList<BciBlock>" :jsrVisited (ArrayList.)
            )
        )
    )

    (defn- #_"BciBlock" BciBlockMapping''makeBlock-3 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"int" startBci]
        (let [
            #_"BciBlock" oldBlock (nth blockMap startBci)
        ]
            (cond
                (nil? oldBlock)
                    (let [
                        #_"BciBlock" newBlock (BciBlock'new-1 startBci)
                    ]
                        (ยง ass! this (update this :blocksNotYetAssignedId inc))
                        (ยง aset! blockMap startBci newBlock)
                        newBlock
                    )
                (not= (:startBci oldBlock) startBci)
                    ;; Backward branch into the middle of an already processed block.
                    ;; Add the correct fall-through successor.
                    (let [
                        #_"BciBlock" newBlock (BciBlock'new-1 startBci)
                    ]
                        (ยง ass! this (update this :blocksNotYetAssignedId inc))
                        (ยง ass newBlock (assoc newBlock :endBci (:endBci oldBlock)))
                        (doseq [#_"BciBlock" oldSuccessor (:successors oldBlock)]
                            (BciBlock''addSuccessor-2 newBlock, oldSuccessor)
                        )

                        (ยง ass oldBlock (assoc oldBlock :endBci (dec startBci)))
                        (BciBlock''clearSucccessors-1 oldBlock)
                        (BciBlock''addSuccessor-2 oldBlock, newBlock)

                        (loop-when-recur [#_"int" i startBci] (<= i (:endBci newBlock)) [(inc i)]
                            (ยง aset! blockMap i newBlock)
                        )
                        newBlock
                    )
                :else
                    oldBlock
            )
        )
    )

    (defn- #_"void" BciBlockMapping'addSuccessor-3 [#_"BciBlock*" blockMap, #_"int" predBci, #_"BciBlock" sux]
        (BciBlock''addSuccessor-2 (nth blockMap predBci), sux)
        nil
    )

    (defn- #_"void" BciBlockMapping''addSwitchSuccessors-4 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"int" predBci, #_"BytecodeSwitch" bswitch]
        ;; adds distinct targets to the successor list
        (let [
            #_"Collection<Integer>" targets (TreeSet.)
        ]
            (dotimes [#_"int" i (BytecodeSwitch'''numberOfCases-1 bswitch)]
                (#_"Collection" .add targets, (BytecodeSwitch''targetAt-2 bswitch, i))
            )
            (#_"Collection" .add targets, (BytecodeSwitch''defaultTarget-1 bswitch))
            (doseq [#_"int" targetBci targets]
                (BciBlockMapping'addSuccessor-3 blockMap, predBci, (BciBlockMapping''makeBlock-3 this, blockMap, targetBci))
            )
        )
        nil
    )

    (defn- #_"BciBlockMapping" BciBlockMapping''iterateOverBytecodes-3 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"BytecodeStream" stream]
        ;; iterate over the bytecodes top to bottom,
        ;; mark the entrypoints of basic blocks and build lists of successors for all bytecodes
        ;; that end basic blocks (i.e. goto, ifs, switches, throw, jsr, returns, ret)
        (loop-when [this this #_"BciBlock" block nil _ (ยง ass! stream (BytecodeStream''setBCI-2 stream, 0))] (not= (BytecodeStream''currentBC-1 stream) Bytecodes'END) => this
            (let [
                #_"int" bci (:curBCI stream)
                block
                    (when (or (nil? block) (some? (nth blockMap bci))) => block
                        (let [
                            #_"BciBlock" b (BciBlockMapping''makeBlock-3 this, blockMap, bci)
                        ]
                            (when (some? block)
                                (BciBlockMapping'addSuccessor-3 blockMap, (:endBci block), b)
                            )
                            b
                        )
                    )
                _ (ยง aset! blockMap bci block)
                block (assoc block :endBci bci)
                block
                    (condp =? (BytecodeStream''currentBC-1 stream)
                       [Bytecodes'IRETURN Bytecodes'LRETURN Bytecodes'ARETURN Bytecodes'RETURN]
                            nil
                       [Bytecodes'IFEQ Bytecodes'IFNE
                        Bytecodes'IFLT Bytecodes'IFGE
                        Bytecodes'IFGT Bytecodes'IFLE
                        Bytecodes'IF_ICMPEQ Bytecodes'IF_ICMPNE
                        Bytecodes'IF_ICMPLT Bytecodes'IF_ICMPGE
                        Bytecodes'IF_ICMPGT Bytecodes'IF_ICMPLE
                        Bytecodes'IF_ACMPEQ Bytecodes'IF_ACMPNE
                        Bytecodes'IFNULL Bytecodes'IFNONNULL]
                        (do
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (BytecodeStream''readBranchDest-1 stream)))
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (:nextBCI stream)))
                            nil
                        )
                       [Bytecodes'GOTO Bytecodes'GOTO_W]
                        (do
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (BytecodeStream''readBranchDest-1 stream)))
                            nil
                        )
                        Bytecodes'TABLESWITCH
                        (do
                            (BciBlockMapping''addSwitchSuccessors-4 this, blockMap, bci, (BytecodeTableSwitch'new-2 stream, bci))
                            nil
                        )
                        Bytecodes'LOOKUPSWITCH
                        (do
                            (BciBlockMapping''addSwitchSuccessors-4 this, blockMap, bci, (BytecodeLookupSwitch'new-2 stream, bci))
                            nil
                        )
                       [Bytecodes'JSR Bytecodes'JSR_W]
                        (do
                            (ยง ass! this (assoc this :hasJsrBytecodes true))
                            (let [
                                #_"int" target (BytecodeStream''readBranchDest-1 stream)
                            ]
                                (when (zero? target)
                                    (throw! "jsr target bci 0 not allowed")
                                )
                                (let [
                                    #_"BciBlock" b1 (BciBlockMapping''makeBlock-3 this, blockMap, target)
                                ]
                                    (BciBlock''setJsrSuccessor-2 block, b1)
                                    (BciBlock''setJsrReturnBci-2 block, (:nextBCI stream))
                                    (BciBlockMapping'addSuccessor-3 blockMap, bci, b1)
                                )
                            )
                            nil
                        )
                        Bytecodes'RET
                        (do
                            (BciBlock''setEndsWithRet-1 block)
                            nil
                        )
                       [Bytecodes'INVOKEINTERFACE Bytecodes'INVOKESPECIAL Bytecodes'INVOKESTATIC Bytecodes'INVOKEVIRTUAL Bytecodes'INVOKEDYNAMIC]
                        (do
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (:nextBCI stream)))
                            nil
                        )
                        block
                    )
            ]
                (recur this block (ยง ass! stream (BytecodeStream''next-1 stream)))
            )
        )
    )

    (defn- #_"this" BciBlockMapping''createJsrAlternatives-3 [#_"BciBlockMapping" this, #_"BciBlock*" blockMap, #_"BciBlock" block]
        (#_"ArrayList" .add (:jsrVisited this), block)
        (let [
            #_"JsrScope" scope (BciBlock''getJsrScope-1 block)
        ]
            (when (BciBlock''endsWithRet-1 block)
                (BciBlock''setRetSuccessor-2 block, (nth blockMap (JsrScope''nextReturnAddress-1 scope)))
                (BciBlock''addSuccessor-2 block, (BciBlock''getRetSuccessor-1 block))
            )
            (when (or (some? (BciBlock''getJsrSuccessor-1 block)) (not (JsrScope''isEmpty-1 scope)))
                (loop-when-recur [#_"int" i 0] (< i (count (:successors block))) [(inc i)]
                    (let [
                        #_"BciBlock" successor (BciBlock''getSuccessor-2 block, i)
                        #_"JsrScope" nextScope scope
                        nextScope
                            (when (= successor (BciBlock''getJsrSuccessor-1 block)) => nextScope
                                (JsrScope''push-2 scope, (BciBlock''getJsrReturnBci-1 block))
                            )
                        nextScope
                            (when (= successor (BciBlock''getRetSuccessor-1 block)) => nextScope
                                (JsrScope''pop-1 scope)
                            )
                    ]
                        (when-not (JsrScope''isPrefixOf-2 (BciBlock''getJsrScope-1 successor), nextScope)
                            (throw! (str "unstructured control flow (" (BciBlock''getJsrScope-1 successor) " " nextScope ")"))
                        )
                        (when-not (JsrScope''isEmpty-1 nextScope)
                            (let [
                                #_"BciBlock" clone
                                    (if (and (some? (BciBlock''getJsrAlternatives-1 successor)) (contains? (BciBlock''getJsrAlternatives-1 successor) nextScope))
                                        (get (BciBlock''getJsrAlternatives-1 successor) nextScope)
                                        (do
                                            (BciBlock''initJsrAlternatives-1 successor)
                                            (let [
                                                clone (BciBlock'copy-1 successor)
                                            ]
                                                (ยง ass! this (update this :blocksNotYetAssignedId inc))
                                                (BciBlock''setJsrScope-2 clone, nextScope)
                                                (#_"EconomicMap" .put (BciBlock''getJsrAlternatives-1 successor), nextScope, clone)
                                                clone
                                            )
                                        )
                                    )
                            ]
                                (#_"List" .set (:successors block), i, clone)
                                (when (= successor (BciBlock''getJsrSuccessor-1 block))
                                    (BciBlock''setJsrSuccessor-2 block, clone)
                                )
                                (when (= successor (BciBlock''getRetSuccessor-1 block))
                                    (BciBlock''setRetSuccessor-2 block, clone)
                                )
                            )
                        )
                    )
                )
            )
            (doseq [#_"BciBlock" successor (:successors block)]
                (when-not (#_"ArrayList" .contains (:jsrVisited this), successor)
                    (ยง ass! this (BciBlockMapping''createJsrAlternatives-3 this, blockMap, successor))
                )
            )
            this
        )
    )

    (defn- #_"long" BciBlockMapping''fixLoopBits-2b [#_"BciBlockMapping" this, #_"BciBlock" block]
        (if (:visited block)
            ;; Return cached loop information for this block.
            (if (:isLoopHeader block) (& (:loops block) (bit-not (<< 1 (:loopId block)))) (:loops block))
            (let [
                _ (ยง ass! block (assoc block :visited true))
                #_"long" loops
                    (loop-when-recur [loops (:loops block) #_"ISeq" s (seq (:successors block))]
                                     (some? s)
                                     ;; Recursively process successors.
                                     [(| loops (BciBlockMapping''fixLoopBits-2b this, (first s))) (next s)]
                                  => loops
                    )
            ]
                (when-not (= (:loops block) loops)
                    (ยง ass! this (assoc this :loopChanges true))
                    (ยง ass! block (assoc block :loops loops))
                )

                (if (:isLoopHeader block) (& loops (bit-not (<< 1 (:loopId block)))) loops)
            )
        )
    )

    (defn- #_"BciBlockMapping" BciBlockMapping''fixLoopBits-2m [#_"BciBlockMapping" this, #_"BciBlock*" blockMap]
        (loop [this this]
            (let [
                this (assoc this :loopChanges false)
            ]
                (loop-when-recur [#_"ISeq" s (seq (:blocks this))] (some? s) [(next s)]
                    (let [
                        #_"BciBlock" b (first s)
                    ]
                        (ยง ass! b (assoc b :visited false))
                    )
                )
                ;; => There is a path from a loop end to the method entry that does not pass the loop header.
                ;; Therefore, the loop is non reducible (has more than one entry).
                ;; We don't want to compile such methods because the IR only supports structured loops.
                (when (zero? (BciBlockMapping''fixLoopBits-2b this, (nth blockMap 0))) => (throw! "non-reducible loop")
                    (recur-if (:loopChanges this) [this] => this)
                )
            )
        )
    )

    ;;;
     ; Mark the block as a loop header, using the next available loop number. Also checks for corner
     ; cases that we don't want to compile.
     ;;
    (defn- #_"this" BciBlockMapping''makeLoopHeader-2 [#_"BciBlockMapping" this, #_"BciBlock" block]
        (when-not (:isLoopHeader block) => this
            (ยง ass! block (assoc block :isLoopHeader true))
            (when (<= BciBlockMapping'LOOP_HEADER_MAX_CAPACITY (:nextLoop this))
                ;; This restriction can be removed by using a fall-back to a BitSet in case we have more than 64 loops.
                ;; Don't compile such methods for now, until we see a concrete case that allows checking for correctness.
                (throw! "too many loops in method")
            )
            (ยง ass! block (assoc block :loops (<< 1 (:nextLoop this))))
            (cond
                (nil? (:loopHeaders this))
                    (ยง ass! this (assoc this :loopHeaders (make-array BciBlock'iface BciBlockMapping'LOOP_HEADER_INITIAL_CAPACITY)))
                (<= (count (:loopHeaders this)) (:nextLoop this))
                    (ยง ass! this (assoc this :loopHeaders (Arrays/copyOf (:loopHeaders this), BciBlockMapping'LOOP_HEADER_MAX_CAPACITY)))
            )
            (aset (:loopHeaders this) (:nextLoop this) block)
            (ยง ass! block (assoc block :loopId (:nextLoop this)))
            (update this :nextLoop inc)
        )
    )

    ;;;
     ; Depth-first traversal of the control flow graph. The flag {@linkplain BciBlock#visited} is used to visit
     ; every block only once. The flag {@linkplain BciBlock#active} is used to detect cycles (backward edges).
     ;;
    (defn- #_"long" BciBlockMapping''computeBlockOrder-2b [#_"BciBlockMapping" this, #_"BciBlock" block]
        (if (:visited block)
            (cond
                (:active block)
                    (do
                        ;; Reached block via backward branch.
                        (ยง ass! this (BciBlockMapping''makeLoopHeader-2 this, block))
                        ;; Return cached loop information for this block.
                        (:loops block)
                    )
                (:isLoopHeader block) (& (:loops block) (bit-not (<< 1 (:loopId block))))
                :else                 (:loops block)
            )
            (do
                (ยง ass! block (assoc block :visited true))
                (ยง ass! block (assoc block :active true))

                (let [
                    #_"long" loops
                        (loop-when [loops 0 #_"ISeq" s (seq (:successors block))] (some? s) => loops
                            (let [
                                #_"BciBlock" successor (first s)
                                ;; Recursively process successors.
                                loops (| loops (BciBlockMapping''computeBlockOrder-2b this, successor))
                                loops
                                    (when (:active successor) => loops
                                        ;; Reached block via backward branch.
                                        (| loops (<< 1 (:loopId successor)))
                                    )
                            ]
                                (recur loops (next s))
                            )
                        )
                ]
                    (ยง ass! block (assoc block :loops loops))
                    (let [
                        loops
                            (when (:isLoopHeader block) => loops
                                (& loops (bit-not (<< 1 (:loopId block))))
                            )
                    ]
                        (ยง ass! block (assoc block :active false))
                        (ยง ass! this (update this :blocksNotYetAssignedId dec))
                        (aset (:blocks this) (:blocksNotYetAssignedId this) block)

                        loops
                    )
                )
            )
        )
    )

    (defn- #_"int" BciBlockMapping''handleLoopHeader-5 [#_"BciBlockMapping" this, #_"BciBlock[]" newBlocks, #_"int" n, #_"int" i, #_"BciBlock" loopHeader]
        (let [
            [#_"int" e n]
                (loop-when [e (dec n) n n i (inc i)] (< i (count (:blocks this))) => [e n]
                    (let [
                        #_"BciBlock" block (nth (:blocks this) i)
                        [e n]
                            (when (and (some? block) (not (zero? (& (:loops block) (<< 1 (:loopId loopHeader)))))) => [e n]
                                (ยง ass! block (BciBlock''setId-2 block, n))
                                (let [
                                    e n
                                    _ (ยง aset! newBlocks n block)
                                    n (inc n)
                                    _ (aset (:blocks this) i nil)
                                ]
                                    [e (if (:isLoopHeader block) (BciBlockMapping''handleLoopHeader-5 this, newBlocks, n, i, block) n)]
                                )
                            )
                    ]
                        (recur e n (inc i))
                    )
                )
        ]
            (ยง ass! loopHeader (assoc loopHeader :loopEnd e))
            n
        )
    )

    (defn- #_"BciBlockMapping" BciBlockMapping''computeBlockOrder-2m [#_"BciBlockMapping" this, #_"BciBlock*" blockMap]
        (let [
            #_"int" maxBlocks (:blocksNotYetAssignedId this)
            this (assoc this :blocks (make-array BciBlock'iface maxBlocks))
        ]
            ;; => There is a path from a loop end to the method entry that does not pass the loop header.
            ;; Therefore, the loop is non reducible (has more than one entry).
            ;; We don't want to compile such methods because the IR only supports structured loops.
            (when (zero? (BciBlockMapping''computeBlockOrder-2b this, (nth blockMap 0))) => (throw! "non-reducible loop")
                ;; Purge nil entries for unreached blocks and sort blocks such that loop bodies are always
                ;; consecutively in the array.
                (let [
                    #_"int" blockCount (inc (- maxBlocks (:blocksNotYetAssignedId this)))
                    #_"BciBlock[]" newBlocks (make-array BciBlock'iface blockCount)
                    #_"int" n
                        (loop-when [n 0 #_"int" i 0] (< i (count (:blocks this))) => n
                            (let [
                                #_"BciBlock" b (nth (:blocks this) i)
                                n
                                    (when (some? b) => n
                                        (let [
                                            b (BciBlock''setId-2 b, n)
                                            _ (aset newBlocks n b)
                                            n (inc n)
                                        ]
                                            (when (:isLoopHeader b) => n
                                                (BciBlockMapping''handleLoopHeader-5 this, newBlocks, n, i, b)
                                            )
                                        )
                                    )
                            ]
                                (recur n (inc i))
                            )
                        )
                    _ (ร aset newBlocks (dec (count newBlocks)) unwindBlock)
                ]
                    (assoc this :blocks newBlocks)
                )
            )
        )
    )

    ;;;
     ; Builds the block map and conservative CFG and numbers blocks.
     ;;
    (defn #_"this" BciBlockMapping''build-2 [#_"BciBlockMapping" this, #_"BytecodeStream" stream]
        (let [
            #_"int" codeSize (Bytecode'''getCodeSize-1 (:code this))
            #_"BciBlock[]" blockMap (make-array BciBlock'iface codeSize)
            this (BciBlockMapping''iterateOverBytecodes-3 this, blockMap, stream)
            this
                (when (:hasJsrBytecodes this) => this
                    (BciBlockMapping''createJsrAlternatives-3 this, blockMap, (nth blockMap 0))
                )
            this (BciBlockMapping''computeBlockOrder-2m this, blockMap)
            this (BciBlockMapping''fixLoopBits-2m this, blockMap)
            this (assoc this :startBlock (nth blockMap 0))
        ]
            this
        )
    )

    (defn #_"BciBlockMapping" BciBlockMapping'create-2 [#_"BytecodeStream" stream, #_"Bytecode" code]
        (BciBlockMapping''build-2 (BciBlockMapping'new-1 code), stream)
    )
)

;;;
 ; Arithmetic operation with operand order of RM, MR or MI.
 ;;
(class-ns BinaryArithmetic []
    (defn- #_"BinaryArithmetic" BinaryArithmetic'new-1 [#_"int" code]
        (let [
            #_"int" base (<< code 3)
        ]
            (merge (BinaryArithmetic'class.)
                (hash-map
                    #_"AMD64MIOp" :byteImmOp (AMD64MIOp'new-5 0x80, code,       true, true, true)
                    #_"AMD64MROp" :byteMrOp  (AMD64MROp'new-3       base,             true, true)
                    #_"AMD64RMOp" :byteRmOp  (AMD64RMOp'new-3    (| base 0x02),       true, true)
                    #_"AMD64MIOp" :immOp     (AMD64MIOp'new-3 0x81, code,       false)
                    #_"AMD64MIOp" :immSxOp   (AMD64MIOp'new-3 0x83, code,       true)
                    #_"AMD64MROp" :mrOp      (AMD64MROp'new-1    (| base 0x01))
                    #_"AMD64RMOp" :rmOp      (AMD64RMOp'new-1    (| base 0x03))
                )
            )
        )
    )

    (ยง def #_"BinaryArithmetic" BinaryArithmetic'ADD (BinaryArithmetic'new-1 0))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'OR  (BinaryArithmetic'new-1 1))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'ADC (BinaryArithmetic'new-1 2))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'SBB (BinaryArithmetic'new-1 3))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'AND (BinaryArithmetic'new-1 4))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'SUB (BinaryArithmetic'new-1 5))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'XOR (BinaryArithmetic'new-1 6))
    (ยง def #_"BinaryArithmetic" BinaryArithmetic'CMP (BinaryArithmetic'new-1 7))

    (defn #_"AMD64MIOp" BinaryArithmetic''getMIOpcode-3 [#_"BinaryArithmetic" this, #_"OperandSize" size, #_"boolean" sx]
        (cond
            (= size OperandSize'BYTE) (:byteImmOp this)
            sx                        (:immSxOp this)
            :else                     (:immOp this)
        )
    )

    #_unused
    (defn #_"AMD64MROp" BinaryArithmetic''getMROpcode-2 [#_"BinaryArithmetic" this, #_"OperandSize" size]
        (if (= size OperandSize'BYTE) (:byteMrOp this) (:mrOp this))
    )

    (defn #_"AMD64RMOp" BinaryArithmetic''getRMOpcode-2 [#_"BinaryArithmetic" this, #_"OperandSize" size]
        (if (= size OperandSize'BYTE) (:byteRmOp this) (:rmOp this))
    )
)

;;;
 ; This class implements a two-dimensional bitmap.
 ;;
(class-ns BitMap2D []
    (defn #_"BitMap2D" BitMap2D'new-2 [#_"int" sizeInSlots, #_"int" bitsPerSlot]
        (merge (BitMap2D'class.)
            (hash-map
                #_"BitSet" :bits (BitSet. (* sizeInSlots bitsPerSlot))
                #_"int" :bitsPerSlot bitsPerSlot
            )
        )
    )

    (defn- #_"int" BitMap2D''bitIndex-3 [#_"BitMap2D" this, #_"int" i, #_"int" j]
        (+ (* i (:bitsPerSlot this)) j)
    )

    (defn #_"boolean" BitMap2D''at-3       [#_"BitMap2D" this, #_"int" i, #_"int" j] (#_"BitSet" .get   (:bits this), (BitMap2D''bitIndex-3 this, i, j)))
    (defn #_"void"    BitMap2D''setBit-3   [#_"BitMap2D" this, #_"int" i, #_"int" j] (#_"BitSet" .set   (:bits this), (BitMap2D''bitIndex-3 this, i, j)) nil)
    (defn #_"void"    BitMap2D''clearBit-3 [#_"BitMap2D" this, #_"int" i, #_"int" j] (#_"BitSet" .clear (:bits this), (BitMap2D''bitIndex-3 this, i, j)) nil)
)

(class-ns Block []
    (def #_"Block[]" Block'EMPTY_ARRAY (make-array Block'iface 0))

    (defn #_"Block" Block'new-1 [#_"AbstractBeginNode" node]
        (merge (Block'class.)
            (hash-map
                #_"int" :id ControlFlowGraph'BLOCK_ID_INITIAL
                ;;;
                 ; Level in the dominator tree starting with 0 for the start block.
                 ;;
                #_"int" :domDepth 0
                #_"Block[]" :predecessors nil
                #_"Block[]" :successors nil
                #_"Block" :dominator nil
                #_"Block" :firstDominated nil
                #_"Block" :dominatedSibling nil
                #_"int" :domNumber -1
                #_"int" :maxChildDomNumber -1
                #_"boolean" :aligned? false
                #_"int" :linearScanNumber -1
                #_"AbstractBeginNode" :beginNode node
                #_"FixedNode" :endNode nil
                #_"double" :probability 0.0
                #_"Loop" :loop nil
                #_"Block" :postdominator nil
                #_"LocationSet" :killLocations nil
                #_"LocationSet" :killLocationsBetweenThisAndDominator nil
            )
        )
    )

    (defn #_"Block" Block''setDominatorNumber-2 [#_"Block" this, #_"int" domNumber]
        (assoc this :domNumber domNumber)
    )

    (defn #_"Block" Block''setMaxChildDomNumber-2 [#_"Block" this, #_"int" maxChildDomNumber]
        (assoc this :maxChildDomNumber maxChildDomNumber)
    )

    (defn #_"Block" Block''setId-2 [#_"Block" this, #_"int" id]
        (assoc this :id id)
    )

    (defn #_"Block" Block''setPredecessors-2 [#_"Block" this, #_"Block[]" predecessors]
        (assoc this :predecessors predecessors)
    )

    (defn #_"Block" Block''setSuccessors-2 [#_"Block" this, #_"Block[]" successors]
        (assoc this :successors successors)
    )

    (defn #_"this" Block''setDominator-2 [#_"Block" this, #_"Block" dominator]
        (let [
            this (assoc this :dominator dominator)
            this (assoc this :domDepth (inc (:domDepth dominator)))
        ]
            this
        )
    )

    (defn #_"Block" Block''setFirstDominated-2 [#_"Block" this, #_"Block" block]
        (assoc this :firstDominated block)
    )

    (defn #_"Block" Block''setDominatedSibling-2 [#_"Block" this, #_"Block" block]
        (assoc this :dominatedSibling block)
    )

    (defn #_"Block" Block''setLinearScanNumber-2 [#_"Block" this, #_"int" linearScanNumber]
        (assoc this :linearScanNumber linearScanNumber)
    )

    (defn #_"Block" Block''setAlign-2 [#_"Block" this, #_"boolean" aligned?]
        (assoc this :aligned? aligned?)
    )

    ;;;
     ; Return the LoopExitNode for this block if it exists.
     ;;
    (defn #_"LoopExitNode" Block''getLoopExit-1 [#_"Block" this]
        (condp satisfies? (:beginNode this)
            BeginNode
                (when (satisfies? LoopExitNode (:next (:beginNode this)))
                    (:next (:beginNode this))
                )
            LoopExitNode
                (:beginNode this)
            nil
        )
    )

    (defn #_"Block" Block''setLoop-2 [#_"Block" this, #_"Loop" _loop]
        (assoc this :loop _loop)
    )

    (defn #_"int" Block''getLoopDepth-1 [#_"Block" this]
        (if (some? (:loop this)) (:depth (:loop this)) 0)
    )

    (defn #_"boolean" Block''isLoopHeader-1 [#_"Block" this]
        (satisfies? LoopBeginNode (:beginNode this))
    )

    (defn #_"boolean" Block''isLoopEnd-1 [#_"Block" this]
        (satisfies? LoopEndNode (:endNode this))
    )

    (defn #_"Block" Block''getFirstPredecessor-1 [#_"Block" this]
        (nth (:predecessors this) 0)
    )

    (defn #_"Block" Block''getFirstSuccessor-1 [#_"Block" this]
        (nth (:successors this) 0)
    )

    (defn #_"FixedNode*" Block''getNodes-1 [#_"Block" this]
        (->> (:beginNode this) (iterate #(when (and (satisfies? FixedWithNextNode %) (not (satisfies? AbstractBeginNode (:next %)))) (:next %))) (take-while some?))
    )

    (defn #_"Block" Block''setProbability-2 [#_"Block" this, #_"double" probability]
        (assoc this :probability probability)
    )

    (defn #_"Block" Block''getDominator-2 [#_"Block" this, #_"int" distance]
        (loop-when-recur [#_"Block" block this #_"int" i 0] (< i distance) [(:dominator block) (inc i)] => block)
    )

    (defn #_"boolean" Block''canKill-2 [#_"Block" this, #_"LocationIdentity" location]
        (and (not (:immutable location))
            (LocationSet''contains-2 (Block''getKillLocations-1 this), location)
        )
    )

    (defn- #_"LocationSet" Block''calcKillLocations-1 [#_"Block" this]
        (let [
            #_"LocationSet" result (LocationSet'new-0)
        ]
            (loop-when [#_"ISeq" s (seq (Block''getNodes-1 this))] (some? s)
                (let [
                    #_"FixedNode" node (first s)
                ]
                    (condp satisfies? node
                        Single
                            (let [
                                #_"LocationIdentity" location (Single'''getLocationIdentity-1 node)
                            ]
                                (ยง ass! result (LocationSet''add-2 result, location))
                            )
                        Multi
                            (doseq [#_"LocationIdentity" location (Multi'''getLocationIdentities-1 node)]
                                (ยง ass! result (LocationSet''add-2 result, location))
                            )
                        nil
                    )
                    (when-not (LocationSet''isAny-1 result)
                        (recur (next s))
                    )
                )
            )
            result
        )
    )

    (defn #_"LocationSet" Block''getKillLocations-1 [#_"Block" this]
        (when (nil? (:killLocations this))
            (ยง ass! this (assoc this :killLocations (Block''calcKillLocations-1 this)))
        )
        (:killLocations this)
    )

    (declare Block''getKillLocationsBetweenThisAndDominator-1)

    (defn- #_"void" Block''calcKillLocationsBetweenThisAndTarget-3 [#_"Block" this, #_"LocationSet" result, #_"Block" stopBlock]
        (if (or (= stopBlock this) (LocationSet''isAny-1 result))
            nil ;; We reached the stop block => nothing to do.
            (if (= stopBlock (:dominator this))
                (ยง ass! result (LocationSet''addAll-2 result, (Block''getKillLocationsBetweenThisAndDominator-1 this)))
                (do
                    ;; Divide and conquer: Aggregate kill locations from this to the dominator and then
                    ;; from the dominator onwards.
                    (Block''calcKillLocationsBetweenThisAndTarget-3 this, result, (:dominator this))
                    (ยง ass! result (LocationSet''addAll-2 result, (Block''getKillLocations-1 (:dominator this))))
                    (when-not (LocationSet''isAny-1 result)
                        (Block''calcKillLocationsBetweenThisAndTarget-3 (:dominator this), result, stopBlock)
                    )
                )
            )
        )
        nil
    )

    (defn- #_"LocationSet" Block''getKillLocationsBetweenThisAndDominator-1 [#_"Block" this]
        (when (nil? (:killLocationsBetweenThisAndDominator this))
            (let [
                #_"LocationSet" dominatorResult (LocationSet'new-0)
                #_"Block" stopBlock (:dominator this)
            ]
                (if (Block''isLoopHeader-1 this)
                    (ยง ass! dominatorResult (LocationSet''addAll-2 dominatorResult, (Loop''getKillLocations-1 (:loop this))))
                    (loop-when [#_"ISeq" s (seq (:predecessors this))] (some? s)
                        (let [
                            #_"Block" b (first s)
                        ]
                            (or
                                (when-not (= b stopBlock)
                                    (or
                                        (do
                                            (ยง ass! dominatorResult (LocationSet''addAll-2 dominatorResult, (Block''getKillLocations-1 b)))
                                            (when (LocationSet''isAny-1 dominatorResult)
                                                :done
                                            )
                                        )
                                        (do
                                            (Block''calcKillLocationsBetweenThisAndTarget-3 b, dominatorResult, stopBlock)
                                            (when (LocationSet''isAny-1 dominatorResult)
                                                :done
                                            )
                                        )
                                    )
                                )
                                (recur (next s))
                            )
                        )
                    )
                )
                (ยง ass! this (assoc this :killLocationsBetweenThisAndDominator dominatorResult))
            )
        )
        (:killLocationsBetweenThisAndDominator this)
    )

    (defn #_"boolean" Block''canKillBetweenThisAndDominator-2 [#_"Block" this, #_"LocationIdentity" location]
        (and (not (:immutable location))
            (LocationSet''contains-2 (Block''getKillLocationsBetweenThisAndDominator-1 this), location)
        )
    )

    (defn #_"void" Block''delete-1 [#_"Block" this]
        ;; adjust successor and predecessor lists
        (let [
            #_"Block" _next (nth (:successors this) 0)
        ]
            (doseq [#_"Block" pred (:predecessors this)]
                (let [
                    #_"Block[]" predSuccs (:successors pred)
                    #_"Block[]" newPredSuccs (make-array Block'iface (count predSuccs))
                ]
                    (dotimes [#_"int" i (count predSuccs)]
                        (aset newPredSuccs i (if (= (nth predSuccs i) this) _next (nth predSuccs i)))
                    )
                    (ยง ass! pred (Block''setSuccessors-2 pred, newPredSuccs))
                )
            )

            (let [
                #_"ArrayList<Block>" newPreds (ArrayList.)
            ]
                (dotimes [#_"int" i (count (:predecessors _next))]
                    (let [
                        #_"Block" curPred (nth (:predecessors _next) i)
                    ]
                        (if (= curPred this)
                            (doseq [#_"Block" b (:predecessors this)]
                                (#_"ArrayList" .add newPreds, b)
                            )
                            (#_"ArrayList" .add newPreds, curPred)
                        )
                    )
                )

                (ยง ass! _next (Block''setPredecessors-2 _next, (into-array Block'iface newPreds)))
            )
        )
        nil
    )

    (defn #_"Block" Block''setPostDominator-2 [#_"Block" this, #_"Block" postdominator]
        (assoc this :postdominator postdominator)
    )
)

(class-ns BlockClosure []
    (defn- #_"void" BlockClosure''addDef-3 [#_"BlockClosure" this, #_"VirtualStackSlot" stackSlot, #_"LIRInstruction" op]
        (ยง ass! (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), stackSlot) (StackInterval''addFrom-2 (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), stackSlot), (:id op)))
        nil
    )

    (defn- #_"void" BlockClosure''addUse-4 [#_"BlockClosure" this, #_"VirtualStackSlot" stackSlot, #_"LIRInstruction" op, #_"EnumSet<OperandFlag>" flags]
        (let [
            #_"StackInterval" interval (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), stackSlot)
        ]
            (if (contains? flags OperandFlag'UNINITIALIZED)
                (do
                    ;; Stack slot is marked uninitialized so we have to assume it is live all the time.
                    (ยง ass! interval (StackInterval''addFrom-2 interval, 0))
                    (ยง ass! interval (StackInterval''addTo-2 interval, (:maxOpId (:builder this))))
                )
                (ยง ass! interval (StackInterval''addTo-2 interval, (:id op)))
            )
        )
        nil
    )

    (defn #_"BlockClosure" BlockClosure'new-2 [#_"FixPointIntervalBuilder" builder, #_"BitSet" bits]
        (merge (BlockClosure'class.)
            (hash-map
                #_"FixPointIntervalBuilder" :builder builder
                #_"BitSet" :currentSet bits
                #_"ValueConsumer" :defConsumer
                    (reify ValueConsumer
                        (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _, #_"LIRInstruction" op, #_"Value" value, #_"OperandMode" mode, #_"{OperandFlag}" flags]
                            (when (satisfies? VirtualStackSlot value)
                                (BlockClosure''addDef-3 (ร this), value, op)
                                (BlockClosure''addRegisterHint-6 (ร this), op, value, mode, flags, true)
                                (#_"EconomicSet" .add (:usePos builder), op)
                                (#_"BitSet" .clear bits, (:id value))
                            )
                            nil
                        )
                    )
                #_"ValueConsumer" :useConsumer
                    (reify ValueConsumer
                        (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _, #_"LIRInstruction" op, #_"Value" value, #_"OperandMode" mode, #_"{OperandFlag}" flags]
                            (when (satisfies? VirtualStackSlot value)
                                (BlockClosure''addUse-4 (ร this), value, op, flags)
                                (BlockClosure''addRegisterHint-6 (ร this), op, value, mode, flags, false)
                                (#_"EconomicSet" .add (:usePos builder), op)
                                (#_"BitSet" .set bits, (:id value))
                            )
                            nil
                        )
                    )
            )
        )
    )

    ;;;
     ; Process all values of an instruction bottom-up, i.e. definitions before usages.
     ; Values that start or end at the current operation are not included.
     ;;
    (defn #_"void" BlockClosure''processInstructionBottomUp-2 [#_"BlockClosure" this, #_"LIRInstruction" op]
        (LIRInstruction''visitEachTemp-2 op, (:defConsumer this))
        (LIRInstruction''visitEachOutput-2 op, (:defConsumer this))

        (LIRInstruction''visitEachAlive-2 op, (:useConsumer this))
        (LIRInstruction''visitEachInput-2 op, (:useConsumer this))
        nil
    )

    (defn #_"void" BlockClosure''addRegisterHint-6 [#_"BlockClosure" this, #_"LIRInstruction" op, #_"VirtualStackSlot" targetValue, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags, #_"boolean" hintAtDef]
        (when (contains? flags OperandFlag'HINT)
            (LIRInstruction''forEachRegisterHint-4 op, targetValue, mode,
                (reify ValueProcedure
                    (#_"Value" ValueProcedure'''doValue-5 [#_"ValueProcedure" _, #_"LIRInstruction" _op, #_"Value" registerHint, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                        (when (satisfies? VirtualStackSlot registerHint)
                            (let [
                                #_"StackInterval" from (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), registerHint)
                                #_"StackInterval" to (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), targetValue)
                            ]
                                ;; hints always point from def to use
                                (if hintAtDef
                                    (ยง ass! to (StackInterval''setLocationHint-2 to, from))
                                    (ยง ass! from (StackInterval''setLocationHint-2 from, to))
                                )
                                registerHint
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

(class-ns BlockData []
    (defn #_"BlockData" BlockData'new-0 []
        (merge (BlockData'class.)
            (hash-map
                ;;;
                 ; Bit map specifying which operands are live upon entry to this block. These are values
                 ; used in this block or any of its successors where such value are not defined in this
                 ; block. The bit index of an operand is its {@linkplain LinearScan#operandNumber(Value)
                 ; operand number}.
                 ;;
                #_"BitSet" :liveIn nil
                ;;;
                 ; Bit map specifying which operands are live upon exit from this block. These are values
                 ; used in a successor block that are either defined in this block or were live upon entry
                 ; to this block. The bit index of an operand is its
                 ; {@linkplain LinearScan#operandNumber(Value) operand number}.
                 ;;
                #_"BitSet" :liveOut nil
                ;;;
                 ; Bit map specifying which operands are used (before being defined) in this block. That is,
                 ; these are the values that are live upon entry to the block. The bit index of an operand
                 ; is its {@linkplain LinearScan#operandNumber(Value) operand number}.
                 ;;
                #_"BitSet" :liveGen nil
                ;;;
                 ; Bit map specifying which operands are defined/overwritten in this block. The bit index of
                 ; an operand is its {@linkplain LinearScan#operandNumber(Value) operand number}.
                 ;;
                #_"BitSet" :liveKill nil
            )
        )
    )
)

(class-ns EffectsClosure #_"<T implements EffectsBlockState<T>>" [BlockIteratorClosure #_"<T>"]
    (defn #_"EffectsClosure" EffectsClosure'new-2 [#_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg]
        (let [
            #_"EffectsClosure" this
                (merge (EffectsClosure'class.)
                    (hash-map
                        #_"ControlFlowGraph" :cfg cfg
                        #_"ScheduleResult" :schedule schedule
                        ;;;
                         ; If a node has an alias, this means that it was replaced with another node during analysis.
                         ; Nodes can be replaced by normal ("scalar") nodes, e.g. a LoadIndexedNode with a ConstantNode,
                         ; or by virtual nodes, e.g. a NewInstanceNode with a VirtualInstanceNode. A node was replaced
                         ; with a virtual value iff the alias is a subclass of VirtualObjectNode.
                         ;
                         ; This alias map exists only once and is not part of the block state, so that during iterative
                         ; loop processing the alias of a node may be changed to another value.
                         ;;
                        #_"NodeMap<ValueNode>" :aliases (NodeMap'new-1g (:graph cfg))
                        ;;;
                         ; This set allows for a quick check whether a node has inputs that were replaced with "scalar" values.
                         ;;
                        #_"NodeBitMap" :hasScalarReplacedInputs (NodeBitMap'new-1 (:graph cfg))
                        ;;;
                         ; The effects accumulated during analysis of nodes. They may be cleared and re-filled during
                         ; iterative loop processing.
                         ;;
                        #_"BlockMap<GraphEffectList>" :blockEffects (BlockMap'new-1 cfg)
                        ;;;
                         ; Effects that can only be applied after the effects from within the loop have been applied and
                         ; that must be applied before any effect from after the loop is applied. E.g., updating phis.
                         ;;
                        #_"EconomicMap<Loop, GraphEffectList>" :loopMergeEffects (EconomicMap/create)
                        ;;;
                         ; The entry state of loops is needed when loop proxies are processed.
                         ;;
                        #_"EconomicMap<LoopBeginNode, T>" :loopEntryStates (EconomicMap/create)
                        ;;;
                         ; Intended to be used by read-eliminating phases based on the effects phase.
                         ;;
                        #_"EconomicMap<Loop, LoopKillCache>" :loopLocationKillCache (EconomicMap/create)
                        #_"boolean" :changed? false
                    )
                )
        ]
            (doseq [#_"Block" block (:reversePostOrder cfg)]
                (BlockMap''put-3 (:blockEffects this), block, (GraphEffectList'new-0))
            )
            this
        )
    )

    (defm EffectsClosure #_"<T>" EffectsClosure
        (#_"boolean" EffectsClosure'''needsApplyEffects-1 [#_"EffectsClosure<T>" this]
            true
        )

        (#_"void" EffectsClosure'''applyEffects-1 [#_"EffectsClosure<T>" this]
            (let [
                #_"Graph" graph (:graph (:cfg this))
                #_"ArrayList<Node>" obsoleteNodes (ArrayList.)
                #_"ArrayList<GraphEffectList>" effectList (ArrayList.)
                ;; Effects are applied during a ordered iteration over the blocks to apply them in the correct order,
                ;; e.g. apply the effect that adds a node to the graph before the node is used.
                #_"BlockIteratorClosure<Void>" closure
                    (reify BlockIteratorClosure #_"<Void>"
                        (#_"Void" BlockIteratorClosure'''getInitialState-1 [#_"BlockIteratorClosure<Void>" _]
                            nil
                        )

                        (#_"Void" BlockIteratorClosure'''processBlock-3 [#_"BlockIteratorClosure<Void>" _, #_"Block" block, #_"Void" currentState]
                            (let [
                                #_"GraphEffectList" effects (BlockMap''get-2 (:blockEffects this), block)
                            ]
                                (when (and (some? effects) (not (EffectList''isEmpty-1 effects)))
                                    (#_"ArrayList" .add effectList, effects)
                                )
                                currentState
                            )
                        )

                        (#_"Void" BlockIteratorClosure'''merge-3 [#_"BlockIteratorClosure<Void>" _, #_"Block" merge, #_"List<Void>" states]
                            nil
                        )

                        (#_"Void" BlockIteratorClosure'''cloneState-2 [#_"BlockIteratorClosure<Void>" _, #_"Void" oldState]
                            oldState
                        )

                        (#_"List<Void>" BlockIteratorClosure'''processLoop-3 [#_"BlockIteratorClosure<Void>" self, #_"Loop" _loop, #_"Void" initialState]
                            (let [
                                #_"BlockLoopInfo<Void>" info (ReentrantBlockIterator'processLoop-3 self, _loop, initialState)
                                #_"GraphEffectList" effects (get (:loopMergeEffects this) _loop)
                            ]
                                (when (and (some? effects) (not (EffectList''isEmpty-1 effects)))
                                    (#_"ArrayList" .add effectList, effects)
                                )
                                (:exitStates info)
                            )
                        )
                    )
            ]
                (ReentrantBlockIterator'apply-2 closure, (ControlFlowGraph''getStartBlock-1 (:cfg this)))

                (doseq [#_"GraphEffectList" effects effectList]
                    (EffectList''apply-4 effects, graph, obsoleteNodes, false)
                )
                ;; Effects that modify the cfg (e.g. removing a branch for an if that got a constant condition)
                ;; need to be performed after all other effects, because they change phi value indexes.
                (doseq [#_"GraphEffectList" effects effectList]
                    (EffectList''apply-4 effects, graph, obsoleteNodes, true)
                )
                (doseq [#_"Node" node obsoleteNodes]
                    (when (and (Node''isAlive-1 node) (Node''hasNoUsages-1 node))
                        (ยง ass! node (Node''replaceAtUsages-2 node, nil))
                        (GraphUtil'killWithUnusedFloatingInputs-1 node)
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Changes to CommitAllocationNodes, AllocatedObjectNodes and BoxNodes are not considered to be "important".
     ; If only changes to those nodes are discovered during analysis, the effects need not be applied.
     ;;
    (defn- #_"boolean" EffectsClosure'isSignificantNode-1 [#_"Node" node]
        (not (or (satisfies? CommitAllocationNode node) (satisfies? AllocatedObjectNode node) (satisfies? BoxNode node)))
    )

    (defn- #_"void" EffectsClosure''doMergeWithoutDead-3 [#_"EffectsClosure<T>" this, #_"MergeProcessor<T>" mergeProcessor, #_"List<T>" states]
        (let [
            #_"int" alive
                (loop-when-recur [alive 0 #_"ISeq" s (seq states)]
                                 (some? s)
                                 [(if (EffectsBlockState''isDead-1 (first s)) alive (inc alive)) (next s)]
                              => alive
                )
        ]
            (cond
                (zero? alive)
                    (ยง ass! mergeProcessor (MergeProcessor''setNewState-2 mergeProcessor, (nth states 0)))
                (= alive (count states))
                    (let [
                        #_"int[]" stateIndexes (int-array (count states))
                    ]
                        (dotimes [#_"int" i (count stateIndexes)]
                            (aset stateIndexes i i)
                        )
                        (ยง ass! mergeProcessor (MergeProcessor''setStateIndexes-2 mergeProcessor, stateIndexes))
                        (ยง ass! mergeProcessor (MergeProcessor''setNewState-2 mergeProcessor, (BlockIteratorClosure'''getInitialState-1 this)))
                        (MergeProcessor'''merge-2 mergeProcessor, states)
                    )
                :else
                    (let [
                        #_"ArrayList<T>" aliveStates (ArrayList.)
                        #_"int[]" stateIndexes (int-array alive)
                    ]
                        (dotimes [#_"int" i (count states)]
                            (when-not (EffectsBlockState''isDead-1 (nth states i))
                                (aset stateIndexes (count aliveStates) i)
                                (#_"ArrayList" .add aliveStates, (nth states i))
                            )
                        )
                        (ยง ass! mergeProcessor (MergeProcessor''setStateIndexes-2 mergeProcessor, stateIndexes))
                        (ยง ass! mergeProcessor (MergeProcessor''setNewState-2 mergeProcessor, (BlockIteratorClosure'''getInitialState-1 this)))
                        (MergeProcessor'''merge-2 mergeProcessor, aliveStates)
                    )
            )
        )
        nil
    )

    (defm EffectsClosure #_"<T>" BlockIteratorClosure
        (#_"T" BlockIteratorClosure'''processBlock-3 [#_"EffectsClosure<T>" this, #_"Block" block, #_"T" state]
            (when-not (EffectsBlockState''isDead-1 state) => state
                (let [
                    #_"GraphEffectList" effects (BlockMap''get-2 (:blockEffects this), block)
                ]
                    ;; If we enter an if branch that is known to be unreachable, we mark it as dead and
                    ;; cease to do any more analysis on it. At merges, these dead branches will be ignored.
                    (when (satisfies? IfNode (:predecessor (:beginNode block)))
                        (let [
                            #_"IfNode" ifNode (:predecessor (:beginNode block))
                            #_"Node" alias (EffectsClosure''getScalarAlias-2 this, (:logic ifNode))
                        ]
                            (when (and (satisfies? LogicConstantNode alias) (not (= (:value alias) (= (:beginNode block) (:trueSuccessor ifNode)))))
                                (ยง ass! state (EffectsBlockState''markAsDead-1 state))
                                (GraphEffectList''killIfBranch-3 effects, ifNode, (:value alias))
                                (ยง return state)
                            )
                        )
                    )

                    ;; a lastFixedNode is needed in case we want to insert fixed nodes
                    (loop-when [#_"FixedWithNextNode" lastFixedNode nil #_"ISeq" s (seq (if (some? (:schedule this)) (BlockMap''get-2 (:blockToNodesMap (:schedule this)), block) (Block''getNodes-1 block)))] (some? s)
                        (let [
                            #_"Node" node (first s)
                        ]
                            ;; reset the aliases (may be non-nil due to iterative loop processing)
                            (NodeMap''set-3 (:aliases this), node, nil)
                            (when (satisfies? LoopExitNode node)
                                (loop-when-recur [#_"ISeq" s (seq (LoopExitNode''proxies-1 node))] (some? s) [(next s)]
                                    (let [
                                        #_"ProxyNode" proxy (first s)
                                    ]
                                        (NodeMap''set-3 (:aliases this), proxy, nil)
                                        (ยง ass! this (assoc this :changed? (or (:changed? this) (and (EffectsClosure'''processNode-5 this, proxy, state, effects, lastFixedNode) (EffectsClosure'isSignificantNode-1 node)))))
                                    )
                                )
                                (EffectsClosure'''processLoopExit-5 this, node, (get (:loopEntryStates this) (:loopBegin node)), state, (BlockMap''get-2 (:blockEffects this), block))
                            )
                            (ยง ass! this (assoc this :changed? (or (:changed? this) (and (EffectsClosure'''processNode-5 this, node, state, effects, lastFixedNode) (EffectsClosure'isSignificantNode-1 node)))))
                            (when-not (EffectsBlockState''isDead-1 state)
                                (recur (if (satisfies? FixedWithNextNode node) node lastFixedNode) (next s))
                            )
                        )
                    )

                    state
                )
            )
        )

        (#_"T" BlockIteratorClosure'''merge-3 [#_"EffectsClosure<T>" this, #_"Block" merge, #_"List<T>" states]
            (let [
                #_"MergeProcessor<T>" processor (EffectsClosure'''createMergeProcessor-2 this, merge)
            ]
                (EffectsClosure''doMergeWithoutDead-3 this, processor, states)
                (EffectList''addAll-2 (BlockMap''get-2 (:blockEffects this), merge), (:mergeEffects processor))
                (EffectList''addAll-2 (BlockMap''get-2 (:blockEffects this), merge), (:afterMergeEffects processor))
                (:newState processor)
            )
        )

        (#_"List<T>" BlockIteratorClosure'''processLoop-3 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState]
            (if (EffectsBlockState''isDead-1 initialState)
                (let [
                    #_"ArrayList<T>" states (ArrayList.)
                ]
                    (dotimes [#_"int" i (count (:exits _loop))]
                        (#_"ArrayList" .add states, initialState)
                    )
                    states
                )
                ;; Special case nested loops: To avoid an exponential runtime for nested loops we try to
                ;; only process them as little times as possible.
                ;;
                ;; In the first iteration of an outer most loop we go into the inner most loop(s). We run
                ;; the first iteration of the inner most loop and then, if necessary, a second iteration.
                ;;
                ;; We return from the recursion and finish the first iteration of the outermost loop. If we
                ;; have to do a second iteration in the outer most loop we go again into the inner most
                ;; loop(s) but this time we already know all states that are killed by the loop so inside
                ;; the loop we will only have those changes that propagate from the first iteration of the
                ;; outer most loop into the current loop. We strip the initial loop state for the inner most
                ;; loops and do the first iteration with the (possible) changes from outer loops. If there
                ;; are no changes we only have to do 1 iteration and are done.
                (let [
                    #_"T" initialStateRemovedKilledLocations (EffectsClosure'''stripKilledLoopLocations-3 this, _loop, (BlockIteratorClosure'''cloneState-2 this, initialState))
                    #_"T" loopEntryState initialStateRemovedKilledLocations
                    #_"T" lastMergedState (BlockIteratorClosure'''cloneState-2 this, initialStateRemovedKilledLocations)
                ]
                    (EffectsClosure'''processInitialLoopState-3 this, _loop, lastMergedState)
                    (let [
                        #_"MergeProcessor<T>" mergeProcessor (EffectsClosure'''createMergeProcessor-2 this, (:header _loop))
                    ]
                        ;; Iterative loop processing: we take the predecessor state as the loop's starting state,
                        ;; processing the loop contents, merge the states of all loop ends, and check whether the
                        ;; resulting state is equal to the starting state. If it is, the loop processing has
                        ;; finished, if not, another iteration is needed.
                        ;;
                        ;; This processing converges because the merge processing always makes the starting state
                        ;; more generic, e.g. adding phis instead of non-phi values.
                        (loop-when [#_"int" iteration 0] (< iteration 10) => (throw! (str "too many iterations at " _loop))
                            (let [
                                #_"BlockLoopInfo<T>" info (ReentrantBlockIterator'processLoop-3 this, _loop, (BlockIteratorClosure'''cloneState-2 this, lastMergedState))
                                #_"List<T>" states (ArrayList.)
                            ]
                                (#_"ArrayList" .add states, initialStateRemovedKilledLocations)
                                (#_"List" .addAll states, (:endStates info))
                                (EffectsClosure''doMergeWithoutDead-3 this, mergeProcessor, states)

                                (if (EffectsBlockState'''equivalentTo-2 (:newState mergeProcessor), lastMergedState)
                                    (do
                                        (ยง ass! (BlockMap''get-2 (:blockEffects this), (:header _loop)) (EffectList''insertAll-3 (BlockMap''get-2 (:blockEffects this), (:header _loop)), (:mergeEffects mergeProcessor), 0))
                                        (#_"EconomicMap" .put (:loopMergeEffects this), _loop, (:afterMergeEffects mergeProcessor))
                                        (#_"EconomicMap" .put (:loopEntryStates this), (:beginNode (:header _loop)), loopEntryState)
                                        (EffectsClosure'''processKilledLoopLocations-4 this, _loop, initialStateRemovedKilledLocations, (:newState mergeProcessor))
                                        (:exitStates info)
                                    )
                                    (do
                                        (ยง ass lastMergedState (:newState mergeProcessor))
                                        (doseq [#_"Block" block (:blocks _loop)]
                                            (EffectList'''clear-1 (BlockMap''get-2 (:blockEffects this), block))
                                        )
                                        (recur (inc iteration))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defm EffectsClosure #_"<T>" EffectsClosure
        (#_"T" EffectsClosure'''stripKilledLoopLocations-3 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState]
            initialState
        )

        (#_"void" EffectsClosure'''processKilledLoopLocations-4 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState, #_"T" mergedStates]
            ;; nothing to do
            nil
        )

        (#_"void" EffectsClosure'''processInitialLoopState-3 [#_"EffectsClosure<T>" this, #_"Loop" _loop, #_"T" initialState]
            ;; nothing to do
            nil
        )
    )

    (defn #_"void" EffectsClosure''addScalarAlias-3 [#_"EffectsClosure<T>" this, #_"ValueNode" node, #_"ValueNode" alias]
        (NodeMap''set-3 (:aliases this), node, alias)
        (doseq [#_"Node" usage (:nodeUsages node)]
            (when-not (NodeBitMap''isNew-2 (:hasScalarReplacedInputs this), usage)
                (NodeBitMap''mark-2 (:hasScalarReplacedInputs this), usage)
            )
        )
        nil
    )

    (defn #_"boolean" EffectsClosure''hasScalarReplacedInputs-2 [#_"EffectsClosure<T>" this, #_"Node" node]
        (NodeBitMap''isMarked-2n (:hasScalarReplacedInputs this), node)
    )

    (defn #_"ValueNode" EffectsClosure''getScalarAlias-2 [#_"EffectsClosure<T>" this, #_"ValueNode" node]
        (when (and (some? node) (Node''isAlive-1 node) (not (NodeMap''isNew-2 (:aliases this), node))) => node
            (let [
                #_"ValueNode" result (get (:aliases this) node)
            ]
                (if (and (some? result) (not (satisfies? VirtualObjectNode result))) result node)
            )
        )
    )
)

(class-ns PartialEscapeClosure #_"<T implements PartialEscapeBlockState<T>>" [EffectsClosure #_"<T>", BlockIteratorClosure #_"<T>"]
    (defn #_"PartialEscapeClosure" PartialEscapeClosure'new-1 [#_"ScheduleResult" schedule]
        (let [
            #_"PartialEscapeClosure" this
                (merge (PartialEscapeClosure'class.) (EffectsClosure'new-2 schedule, (:cfg schedule))
                    (hash-map
                        ;;;
                         ; Nodes with inputs that were modified during analysis are marked in this bitset - this way
                         ; nodes that are not influenced at all by analysis can be rejected quickly.
                         ;;
                        #_"NodeBitMap" :hasVirtualInputs (NodeBitMap'new-1 (:graph (:cfg schedule)))
                        ;;;
                         ; This is handed out to implementers of Virtualizable.
                         ;;
                        #_"VirtualizerTool" :tool nil
                        ;;;
                         ; The indexes into this array correspond to VirtualObjectNode#getObjectId().
                         ;;
                        #_"ArrayList<VirtualObjectNode>" :virtualObjects (ArrayList.)
                    )
                )
            this (assoc this :tool (VirtualizerTool'new-1 this))
        ]
            this
        )
    )

    (defm PartialEscapeClosure #_"<T>" EffectsClosure
        (#_"boolean" EffectsClosure'''needsApplyEffects-1 [#_"PartialEscapeClosure<T>" this]
            (or (:changed? this)
                ;; If there is a mismatch between the number of materializations and the number of virtualizations,
                ;; we need to apply effects, even if there were no other significant changes to the graph.
                (let [
                    #_"int" delta 0
                    delta
                        (loop-when [delta delta #_"ISeq" s (seq (:reversePostOrder (:cfg this)))] (some? s) => delta
                            (let [
                                #_"GraphEffectList" effects (BlockMap''get-2 (:blockEffects this), (first s))
                            ]
                                (recur (if (some? effects) (+ delta (:virtualizationDelta effects)) delta) (next s))
                            )
                        )
                    delta
                        (loop-when [delta delta #_"ISeq" s (seq (:loops (:cfg this)))] (some? s) => delta
                            (let [
                                #_"GraphEffectList" effects (get (:loopMergeEffects this) (first s))
                            ]
                                (recur (if (some? effects) (+ delta (:virtualizationDelta effects)) delta) (next s))
                            )
                        )
                ]
                    (not (zero? delta))
                )
            )
        )
    )

    (defn- #_"boolean" PartialEscapeClosure''processVirtualizable-5 [#_"PartialEscapeClosure<T>" this, #_"ValueNode" node, #_"FixedNode" insertBefore, #_"T" state, #_"GraphEffectList" effects]
        (ยง ass! (:tool this) (VirtualizerTool''reset-5 (:tool this), state, node, insertBefore, effects))
        (Virtualizable'''virtualize-2 node, (:tool this))
        true ;; request further processing
    )

    (defn- #_"FrameState" PartialEscapeClosure'getUniqueFramestate-2 [#_"NodeWithState" nodeWithState, #_"FrameState" frameState]
        (when (Node''hasMoreThanOneUsage-1 frameState) => frameState
            ;; Can happen for example from inlined snippets with multiple state split nodes.
            (let [
                #_"FrameState" copy (Node''copyWithInputs-1 frameState)
            ]
                (Node''replaceFirstInput-3 nodeWithState, frameState, copy)
                copy
            )
        )
    )

    (defn- #_"EconomicSet<VirtualObjectNode>" PartialEscapeClosure''collectLockedVirtualObjects-3 [#_"PartialEscapeClosure<T>" this, #_"T" state, #_"EconomicSet<VirtualObjectNode>" virtual]
        (dotimes [#_"int" i (count (:objectStates state))]
            (let [
                #_"ObjectState" objState (nth (:objectStates state) i)
            ]
                (when (and (some? objState) (ObjectState''isVirtual-1 objState) (ObjectState''hasLocks-1 objState))
                    (#_"EconomicSet" .add virtual, (nth (:virtualObjects this) i))
                )
            )
        )
        virtual
    )

    (defn- #_"EconomicSet<VirtualObjectNode>" PartialEscapeClosure''collectReferencedVirtualObjects-3 [#_"PartialEscapeClosure<T>" this, #_"T" state, #_"EconomicSet<VirtualObjectNode>" virtual]
        (let [
            #_"Iterator<VirtualObjectNode>" it (#_"EconomicSet" .iterator virtual)
        ]
            (loop-when-recur [virtual virtual] (#_"Iterator" .hasNext it) [virtual] => virtual
                (let [
                    #_"int" id (:oid (#_"Iterator" .next it))
                ]
                    (when-not (= id -1)
                        (let [
                            #_"ObjectState" objState (when (< id (count (:objectStates state))) (nth (:objectStates state) id))
                        ]
                            (when (and (some? objState) (ObjectState''isVirtual-1 objState))
                                (doseq [#_"ValueNode" entry (:entries objState)]
                                    (when (satisfies? VirtualObjectNode entry)
                                        (#_"EconomicSet" .add virtual, entry)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" PartialEscapeClosure''processNodeWithState-4 [#_"PartialEscapeClosure<T>" this, #_"NodeWithState" nodeWithState, #_"T" state, #_"GraphEffectList" effects]
        (doseq [#_"FrameState" fs (NodeWithState''states-1 nodeWithState)]
            (let [
                #_"FrameState" frameState (PartialEscapeClosure'getUniqueFramestate-2 nodeWithState, fs)
                #_"EconomicSet<VirtualObjectNode>" virtual (EconomicSet/create)
            ]
                (VirtualState'''applyToNonVirtual-2 frameState, (CollectVirtualObjectsClosure'new-4 this, virtual, effects, state))

                (let [
                    virtual (PartialEscapeClosure''collectLockedVirtualObjects-3 this, state, virtual)
                    virtual (PartialEscapeClosure''collectReferencedVirtualObjects-3 this, state, virtual)
                ]
                    (doseq [#_"VirtualObjectNode" obj virtual]
                        (GraphEffectList''addVirtualMapping-3 effects, frameState, (ObjectState''createEscapeObjectState-2 (nth (:objectStates state) (:oid obj)), obj))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; This replaces all inputs that point to virtual or materialized values with the actual value,
     ; materializing if necessary.
     ; Also takes care of frame states, adding the necessary VirtualObjectState.
     ;;
    (defn- #_"void" PartialEscapeClosure''processNodeInputs-5 [#_"PartialEscapeClosure<T>" this, #_"ValueNode" node, #_"FixedNode" insertBefore, #_"T" state, #_"GraphEffectList" effects]
        (doseq [#_"Node" input (Node''inputs-1 node)]
            (when (satisfies? ValueNode input)
                (let [
                    #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 this, input)
                ]
                    (when (satisfies? VirtualObjectNode alias)
                        (let [
                            #_"int" id (:oid alias)
                        ]
                            (PartialEscapeClosure''ensureMaterialized-5 this, state, id, insertBefore, effects)
                            (GraphEffectList''replaceFirstInput-4 effects, node, input, (:materializedValue (nth (:objectStates state) id)))
                        )
                    )
                )
            )
        )
        (when (satisfies? NodeWithState node)
            (PartialEscapeClosure''processNodeWithState-4 this, node, state, effects)
        )
        nil
    )

    ;;;
     ; Nodes created during canonicalizations need to be scanned for values that were replaced.
     ;;
    (defn- #_"boolean" PartialEscapeClosure''prepareCanonicalNode-4 [#_"PartialEscapeClosure<T>" this, #_"ValueNode" node, #_"T" state, #_"GraphEffectList" effects]
        (loop-when [#_"ISeq" s (seq (Node''inputPositions-1 node))] (some? s) => true
            (let [
                #_"Position" pos (first s)
                #_"Node" input (Position''get-2 pos, node)
            ]
                (and
                    (when (satisfies? ValueNode input) => true
                        (if (Node''isAlive-1 input)
                            (when-not (satisfies? VirtualObjectNode input) => true
                                (let [
                                    #_"ObjectState" obj (PartialEscapeClosure''getObjectState-3 this, state, input)
                                ]
                                    (if (nil? obj)
                                        (do
                                            (Position''initialize-3 pos, node, (EffectsClosure''getScalarAlias-2 this, input))
                                            true
                                        )
                                        (if (ObjectState''isVirtual-1 obj)
                                            false
                                            (do
                                                (Position''initialize-3 pos, node, (:materializedValue obj))
                                                true
                                            )
                                        )
                                    )
                                )
                            )
                            (PartialEscapeClosure''prepareCanonicalNode-4 this, input, state, effects)
                        )
                    )
                    (recur (next s))
                )
            )
        )
    )

    ;;;
     ; This tries to canonicalize the node based on improved (replaced) inputs.
     ;;
    (defn- #_"boolean" PartialEscapeClosure''processNodeWithScalarReplacedInputs-5 [#_"PartialEscapeClosure<T>" this, #_"ValueNode" node, #_"FixedNode" insertBefore, #_"T" state, #_"GraphEffectList" effects]
        (let [
            #_"ValueNode" canonicalizedValue
                (condp satisfies? node
                    Unary
                        (let [
                            #_"ObjectState" valueObj (PartialEscapeClosure''getObjectState-3 this, state, (Unary'''getValue-1 node))
                            #_"ValueNode" valueAlias (if (some? valueObj) (:materializedValue valueObj) (EffectsClosure''getScalarAlias-2 this, (Unary'''getValue-1 node)))
                        ]
                            (when-not (= valueAlias (Unary'''getValue-1 node)) => node
                                (Unary'''canonical-3 node, (:tool this), valueAlias)
                            )
                        )
                    Binary
                        (let [
                            #_"ObjectState" xObj (PartialEscapeClosure''getObjectState-3 this, state, (:x node))
                            #_"ValueNode" xAlias (if (some? xObj) (:materializedValue xObj) (EffectsClosure''getScalarAlias-2 this, (:x node)))
                            #_"ObjectState" yObj (PartialEscapeClosure''getObjectState-3 this, state, (:y node))
                            #_"ValueNode" yAlias (if (some? yObj) (:materializedValue yObj) (EffectsClosure''getScalarAlias-2 this, (:y node)))
                        ]
                            (when-not (and (= xAlias (:x node)) (= yAlias (:y node))) => node
                                (Binary'''canonical-4 node, (:tool this), xAlias, yAlias)
                            )
                        )
                    (ยง return false)
                )
        ]
            (and (some? canonicalizedValue) (not= canonicalizedValue node)
                (if (Node''isAlive-1 canonicalizedValue)
                    (let [
                        #_"ValueNode" alias (PartialEscapeClosure''getAliasAndResolve-3 this, state, canonicalizedValue)
                    ]
                        (if (satisfies? VirtualObjectNode alias)
                            (do
                                (PartialEscapeClosure''addVirtualAlias-3 this, alias, node)
                                (GraphEffectList''deleteNode-2 effects, node)
                            )
                            (do
                                (GraphEffectList''replaceAtUsages-4 effects, node, alias, insertBefore)
                                (EffectsClosure''addScalarAlias-3 this, node, alias)
                            )
                        )
                        true
                    )
                    (and (PartialEscapeClosure''prepareCanonicalNode-4 this, canonicalizedValue, state, effects)
                        (do
                            (if (satisfies? ControlSinkNode canonicalizedValue)
                                (do
                                    (GraphEffectList''replaceWithSink-3 effects, (ยง cast #_"FixedWithNextNode" node), canonicalizedValue)
                                    (ยง ass! state (EffectsBlockState''markAsDead-1 state))
                                )
                                (do
                                    (GraphEffectList''replaceAtUsages-4 effects, node, canonicalizedValue, insertBefore)
                                    (EffectsClosure''addScalarAlias-3 this, node, canonicalizedValue)
                                )
                            )
                            true
                        )
                    )
                )
            )
        )
    )

    (defn- #_"boolean" PartialEscapeClosure''processNodeInternal-5 [#_"PartialEscapeClosure<T>" this, #_"Node" node, #_"T" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
        (let [
            #_"FixedNode" nextFixedNode (when (some? lastFixedNode) (:next lastFixedNode))
        ]
            (when (satisfies? VirtualizableAllocation node)
                (when-not (PartialEscapeClosure''processVirtualizable-5 this, node, nextFixedNode, state, effects)
                    (ยง return false)
                )
                (when (:deleted (:tool this))
                    (ยง return true)
                )
            )
            (when (and (NodeBitMap''isMarked-2n (:hasVirtualInputs this), node) (satisfies? ValueNode node))
                (when (satisfies? Virtualizable node)
                    (when-not (PartialEscapeClosure''processVirtualizable-5 this, node, nextFixedNode, state, effects)
                        (ยง return false)
                    )
                    (when (:deleted (:tool this))
                        (ยง return true)
                    )
                )
                (PartialEscapeClosure''processNodeInputs-5 this, (ยง cast #_"ValueNode" node), nextFixedNode, state, effects)
            )

            (and (EffectsClosure''hasScalarReplacedInputs-2 this, node) (satisfies? ValueNode node) (PartialEscapeClosure''processNodeWithScalarReplacedInputs-5 this, node, nextFixedNode, state, effects))
        )
    )

    ;;;
     ; @return true if the node was deleted, false otherwise
     ;;
    (defm PartialEscapeClosure #_"<T>" EffectsClosure
        (#_"boolean" EffectsClosure'''processNode-5 [#_"PartialEscapeClosure<T>" this, #_"Node" node, #_"T" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
            ;; These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
            ;; and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
            ;; scheduled, but can safely be ignored.
            (if (or (satisfies? CallTargetNode node) (satisfies? FrameState node) (satisfies? ConstantNode node))
                false
                (if (satisfies? InvokeNode node)
                    (PartialEscapeClosure''processNodeInternal-5 this, (:callTarget node), state, effects, lastFixedNode)
                    (PartialEscapeClosure''processNodeInternal-5 this, node, state, effects, lastFixedNode)
                )
            )
        )
    )

    ;;;
     ; @return true if materialization happened, false if not
     ;;
    (defn #_"boolean" PartialEscapeClosure''ensureMaterialized-5 [#_"PartialEscapeClosure<T>" this, #_"PartialEscapeBlockState" state, #_"int" object, #_"FixedNode" materializeBefore, #_"GraphEffectList" effects]
        (and (ObjectState''isVirtual-1 (nth (:objectStates state) object))
            (do
                (PartialEscapeBlockState''materializeBefore-4 state, materializeBefore, (nth (:virtualObjects this) object), effects)
                true
            )
        )
    )

    (defn #_"boolean" PartialEscapeClosure'updateStatesForMaterialized-3 [#_"PartialEscapeBlockState" state, #_"VirtualObjectNode" virtual, #_"ValueNode" materializedValue]
        ;; update all existing states with the newly materialized object
        (loop-when [#_"boolean" changed? false #_"int" i 0] (< i (count (:objectStates state))) => changed?
            (let [
                #_"ObjectState" objState (nth (:objectStates state) i)
                changed?
                    (when (and (some? objState) (ObjectState''isVirtual-1 objState)) => changed?
                        (let [
                            #_"ValueNode[]" entries (:entries objState)
                        ]
                            (loop-when [changed? changed? #_"int" j 0] (< j (count entries)) => changed?
                                (let [
                                    changed?
                                        (when (= (nth entries j) virtual) => changed?
                                            (PartialEscapeBlockState''setEntry-4 state, i, j, materializedValue)
                                            true
                                        )
                                ]
                                    (recur changed? (inc j))
                                )
                            )
                        )
                    )
            ]
                (recur changed? (inc i))
            )
        )
    )

    (defm PartialEscapeClosure #_"<T>" EffectsClosure
        (#_"T" EffectsClosure'''stripKilledLoopLocations-3 [#_"PartialEscapeClosure<T>" this, #_"Loop" _loop, #_"T" originalInitialState]
            (let [
                #_"T" initialState (EffectsClosure'''stripKilledLoopLocations-3 (ยง super EffectsClosure'iface), _loop, originalInitialState)
            ]
                (when (< GraalOptions'escapeAnalysisLoopCutoff (:depth _loop))
                    ;; After we've reached the maximum loop nesting, we'll simply materialize everything we
                    ;; can to make sure that the loops only need to be iterated one time. Care is taken here
                    ;; to not materialize virtual objects that have the "ensureVirtualized" flag set.
                    (let [
                        #_"LoopBeginNode" loopBegin (:beginNode (:header _loop))
                        #_"AbstractEndNode" end (LoopBeginNode''forwardEnd-1 loopBegin)
                        #_"Block" loopPredecessor (Block''getFirstPredecessor-1 (:header _loop))
                        #_"int" length (count (:objectStates initialState))
                        #_"BitSet" ensureVirtualized (BitSet.)
                        _
                            (dotimes [#_"int" i length]
                                (let [
                                    #_"ObjectState" state (nth (:objectStates initialState) i)
                                ]
                                    (when (and (some? state) (ObjectState''isVirtual-1 state) (:ensureVirtualized state))
                                        (#_"BitSet" .set ensureVirtualized, i)
                                    )
                                )
                            )
                    ]
                        (loop []
                            ;; propagate "ensureVirtualized" flag
                            (let [
                                #_"boolean" changed?
                                    (loop-when [changed? false #_"int" i 0] (< i length) => changed?
                                        (let [
                                            changed?
                                                (when-not (#_"BitSet" .get ensureVirtualized, i) => changed?
                                                    (let [
                                                        #_"ObjectState" state (nth (:objectStates initialState) i)
                                                    ]
                                                        (when (and (some? state) (ObjectState''isVirtual-1 state)) => changed?
                                                            (loop-when [changed? changed? #_"ISeq" s (seq (:entries state))] (some? s) => changed?
                                                                (let [
                                                                    #_"ValueNode" entry (first s)
                                                                ]
                                                                    (when (and (satisfies? VirtualObjectNode entry) (#_"BitSet" .get ensureVirtualized, (:oid entry))) => (recur changed? (next s))
                                                                        (#_"BitSet" .set ensureVirtualized, i)
                                                                        true
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                        ]
                                            (recur changed? (inc i))
                                        )
                                    )
                            ]
                                (ร recur-if changed? [])
                            )
                        )

                        (dotimes [#_"int" i length]
                            (let [
                                #_"ObjectState" state (nth (:objectStates initialState) i)
                            ]
                                (when (and (some? state) (ObjectState''isVirtual-1 state) (not (#_"BitSet" .get ensureVirtualized, i)))
                                    (PartialEscapeBlockState''materializeBefore-4 initialState, end, (nth (:virtualObjects this) i), (BlockMap''get-2 (:blockEffects this), loopPredecessor))
                                )
                            )
                        )
                    )
                )
                initialState
            )
        )
    )

    (defm PartialEscapeClosure #_"<T>" EffectsClosure
        (#_"void" EffectsClosure'''processInitialLoopState-3 [#_"PartialEscapeClosure<T>" this, #_"Loop" _loop, #_"T" initialState]
            (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 (:beginNode (:header _loop)))]
                (when (some? (PhiNode''valueAt-2i phi, 0))
                    (let [
                        #_"ValueNode" alias (PartialEscapeClosure''getAliasAndResolve-3 this, initialState, (PhiNode''valueAt-2i phi, 0))
                    ]
                        (if (satisfies? VirtualObjectNode alias)
                            (PartialEscapeClosure''addVirtualAlias-3 this, alias, phi)
                            (NodeMap''set-3 (:aliases this), phi, nil)
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"void" PartialEscapeClosure'processVirtualAtLoopExit-6 [#_"LoopExitNode" exitNode, #_"GraphEffectList" effects, #_"int" object, #_"ObjectState" exitObjState, #_"ObjectState" initialObjState, #_"PartialEscapeBlockState" exitState]
        (dotimes [#_"int" i (count (:entries exitObjState))]
            (let [
                #_"ValueNode" value (ObjectState''getEntry-2 (nth (:objectStates exitState) object), i)
            ]
                (when-not (or (satisfies? VirtualObjectNode value) (satisfies? ConstantNode value))
                    (when-not (and (not (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin exitNode), value)) (some? initialObjState) (ObjectState''isVirtual-1 initialObjState) (= (ObjectState''getEntry-2 initialObjState, i) value))
                        (let [
                            #_"ProxyNode" proxy (ValueProxyNode'new-2 value, exitNode)
                        ]
                            (PartialEscapeBlockState''setEntry-4 exitState, object, i, proxy)
                            (GraphEffectList''addFloatingNode-3 effects, proxy, "virtualProxy")
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" PartialEscapeClosure'processMaterializedAtLoopExit-7 [#_"LoopExitNode" exitNode, #_"GraphEffectList" effects, #_"EconomicMap<Integer, ProxyNode>" proxies, #_"int" object, #_"ObjectState" exitObjState, #_"ObjectState" initialObjState, #_"PartialEscapeBlockState" exitState]
        (when (or (nil? initialObjState) (ObjectState''isVirtual-1 initialObjState))
            (let [
                #_"ProxyNode" proxy (get proxies object)
            ]
                (if (nil? proxy)
                    (do
                        (ยง ass proxy (ValueProxyNode'new-2 (:materializedValue exitObjState), exitNode))
                        (GraphEffectList''addFloatingNode-3 effects, proxy, "proxy")
                    )
                    (do
                        (GraphEffectList''replaceFirstInput-4 effects, proxy, (:value proxy), (:materializedValue exitObjState))
                        ;; nothing to do - will be handled in processNode
                    )
                )
                (PartialEscapeBlockState''updateMaterializedValue-3 exitState, object, proxy)
            )
        )
        nil
    )

    (defm PartialEscapeClosure #_"<T>" EffectsClosure
        (#_"void" EffectsClosure'''processLoopExit-5 [#_"PartialEscapeClosure<T>" this, #_"LoopExitNode" exitNode, #_"T" initialState, #_"T" exitState, #_"GraphEffectList" effects]
            (when (:hasValueProxies (:graph exitNode))
                (let [
                    #_"EconomicMap<Integer, ProxyNode>" proxies (EconomicMap/create)
                ]
                    (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 exitNode)]
                        (let [
                            #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 this, (:value proxy))
                        ]
                            (when (satisfies? VirtualObjectNode alias)
                                (#_"EconomicMap" .put proxies, (:oid alias), proxy)
                            )
                        )
                    )
                    (dotimes [#_"int" i (count (:objectStates exitState))]
                        (let [
                            #_"ObjectState" exitObjState (nth (:objectStates exitState) i)
                        ]
                            (when (some? exitObjState)
                                (let [
                                    #_"ObjectState" initialObjState (when (< i (count (:objectStates initialState))) (nth (:objectStates initialState) i))
                                ]
                                    (if (ObjectState''isVirtual-1 exitObjState)
                                        (PartialEscapeClosure'processVirtualAtLoopExit-6 exitNode, effects, i, exitObjState, initialObjState, exitState)
                                        (PartialEscapeClosure'processMaterializedAtLoopExit-7 exitNode, effects, proxies, i, exitObjState, initialObjState, exitState)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defm PartialEscapeClosure #_"<T>" EffectsClosure
        (#_"PEMergeProcessor<T>" EffectsClosure'''createMergeProcessor-2 [#_"PartialEscapeClosure<T>" this, #_"Block" merge]
            (PEMergeProcessor'new-2 this, merge)
        )
    )

    (defn #_"ObjectState" PartialEscapeClosure''getObjectState-3 [#_"PartialEscapeClosure<T>" this, #_"PartialEscapeBlockState" state, #_"ValueNode" value]
        (when (some? value)
            (if (and (Node''isAlive-1 value) (not (NodeMap''isNew-2 (:aliases this), value)))
                (let [
                    #_"ValueNode" object (get (:aliases this) value)
                ]
                    (when (satisfies? VirtualObjectNode object)
                        (let [#_"int" id (:oid object)] (when (< id (count (:objectStates state))) (nth (:objectStates state) id)))
                    )
                )
                (when (satisfies? VirtualObjectNode value)
                    (let [#_"int" id (:oid value)] (when (< id (count (:objectStates state))) (nth (:objectStates state) id)))
                )
            )
        )
    )

    (defn #_"ValueNode" PartialEscapeClosure''getAlias-2 [#_"PartialEscapeClosure<T>" this, #_"ValueNode" value]
        (if (and (some? value) (not (satisfies? VirtualObjectNode value)) (Node''isAlive-1 value) (not (NodeMap''isNew-2 (:aliases this), value)))
            (or (get (:aliases this) value)
                value
            )
            value
        )
    )

    (defn #_"ValueNode" PartialEscapeClosure''getAliasAndResolve-3 [#_"PartialEscapeClosure<T>" this, #_"PartialEscapeBlockState" state, #_"ValueNode" value]
        (let [
            #_"ValueNode" result (PartialEscapeClosure''getAlias-2 this, value)
        ]
            (when (satisfies? VirtualObjectNode result)
                (let [
                    #_"int" id (:oid result)
                ]
                    (when (and (not= id -1) (not (ObjectState''isVirtual-1 (nth (:objectStates state) id))))
                        (ยง ass result (:materializedValue (nth (:objectStates state) id)))
                    )
                )
            )
            result
        )
    )

    (defn- #_"void" PartialEscapeClosure''markVirtualUsages-2 [#_"PartialEscapeClosure<T>" this, #_"Node" node]
        (when (and (not (NodeBitMap''isNew-2 (:hasVirtualInputs this), node)) (not (NodeBitMap''isMarked-2n (:hasVirtualInputs this), node)))
            (NodeBitMap''mark-2 (:hasVirtualInputs this), node)
            (when (satisfies? VirtualState node)
                (doseq [#_"Node" usage (:nodeUsages node)]
                    (PartialEscapeClosure''markVirtualUsages-2 this, usage)
                )
            )
        )
        nil
    )

    (defn #_"void" PartialEscapeClosure''addVirtualAlias-3 [#_"PartialEscapeClosure<T>" this, #_"VirtualObjectNode" virtual, #_"ValueNode" node]
        (when (Node''isAlive-1 node)
            (NodeMap''set-3 (:aliases this), node, virtual)
            (doseq [#_"Node" usage (:nodeUsages node)]
                (PartialEscapeClosure''markVirtualUsages-2 this, usage)
            )
        )
        nil
    )
)

;;;
 ; Final subclass of PartialEscapeClosure, for performance and to make everything
 ; behave nicely with generics.
 ;;
(class-ns FinalClosure [PartialEscapeClosure #_"<FinalState>", EffectsClosure #_"<FinalState>", BlockIteratorClosure #_"<FinalState>"]
    (defn #_"FinalClosure" FinalClosure'new-1 [#_"ScheduleResult" schedule]
        (merge (FinalClosure'class.) (PartialEscapeClosure'new-1 schedule))
    )

    (defm FinalClosure BlockIteratorClosure
        (#_"FinalState" BlockIteratorClosure'''getInitialState-1 [#_"FinalClosure" this]
            (FinalState'new-0)
        )

        (#_"FinalState" BlockIteratorClosure'''cloneState-2 [#_"FinalClosure" this, #_"FinalState" oldState]
            (FinalState'copy-1 oldState)
        )
    )
)

(class-ns PEReadEliminationClosure [PartialEscapeClosure #_"<PEReadEliminationBlockState>", EffectsClosure #_"<PEReadEliminationBlockState>", BlockIteratorClosure #_"<PEReadEliminationBlockState>"]
    (defn #_"PEReadEliminationClosure" PEReadEliminationClosure'new-1 [#_"ScheduleResult" schedule]
        (merge (PEReadEliminationClosure'class.) (PartialEscapeClosure'new-1 schedule))
    )

    (defn- #_"boolean" PEReadEliminationClosure''processLoad-8 [#_"PEReadEliminationClosure" this, #_"FixedNode" load, #_"ValueNode" object, #_"LocationIdentity" location, #_"int" index, #_"JavaKind" kind, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"ValueNode" unproxiedObject (GraphUtil'unproxify-1n object)
            #_"ValueNode" cachedValue (PEReadEliminationBlockState''getReadCache-6 state, unproxiedObject, location, index, kind, this)
        ]
            (if (some? cachedValue)
                (do
                    ;; perform the read elimination
                    (GraphEffectList''replaceAtUsages-4 effects, load, cachedValue, load)
                    (EffectsClosure''addScalarAlias-3 this, load, cachedValue)
                    true
                )
                (do
                    (PEReadEliminationBlockState''addReadCache-8 state, unproxiedObject, location, index, kind, false, load, this)
                    false
                )
            )
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processLoadField-4 [#_"PEReadEliminationClosure" this, #_"LoadFieldNode" load, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (if (AccessFieldNode''isVolatile-1 load)
            (do
                (PEReadEliminationBlockState''killReadCache-1 state)
                false
            )
            (PEReadEliminationClosure''processLoad-8 this, load, (:object load), (FieldLocationIdentity'new-1 (:field load)), -1, (#_"ResolvedJavaField" .getJavaKind (:field load)), state, effects)
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processStore-10 [#_"PEReadEliminationClosure" this, #_"FixedNode" store, #_"ValueNode" object, #_"LocationIdentity" location, #_"int" index, #_"JavaKind" accessKind, #_"boolean" overflowAccess, #_"ValueNode" value, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"ValueNode" unproxiedObject (GraphUtil'unproxify-1n object)
            #_"ValueNode" cachedValue (PEReadEliminationBlockState''getReadCache-6 state, object, location, index, accessKind, this)
            #_"ValueNode" finalValue (EffectsClosure''getScalarAlias-2 this, value)
            #_"boolean" result
                (when (= (GraphUtil'unproxify-1n finalValue) (GraphUtil'unproxify-1n cachedValue)) => false
                    (GraphEffectList''deleteNode-2 effects, store)
                    true
                )
        ]
            (PEReadEliminationBlockState''killReadCache-3 state, location, index)
            (PEReadEliminationBlockState''addReadCache-8 state, unproxiedObject, location, index, accessKind, overflowAccess, finalValue, this)
            result
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processStoreField-4 [#_"PEReadEliminationClosure" this, #_"StoreFieldNode" store, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (if (AccessFieldNode''isVolatile-1 store)
            (do
                (PEReadEliminationBlockState''killReadCache-1 state)
                false
            )
            (let [
                #_"JavaKind" kind (#_"ResolvedJavaField" .getJavaKind (:field store))
            ]
                (PEReadEliminationClosure''processStore-10 this, store, (:object store), (FieldLocationIdentity'new-1 (:field store)), -1, kind, false, (:value store), state, effects)
            )
        )
    )

    (defn- #_"JavaKind" PEReadEliminationClosure'getElementKindFromStamp-1 [#_"ValueNode" array]
        (let [
            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp array))
        ]
            (when (and (some? type) (#_"ResolvedJavaType" .isArray type)) => JavaKind/Illegal
                (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type))
            )
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processLoadIndexed-4 [#_"PEReadEliminationClosure" this, #_"LoadIndexedNode" load, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (and (satisfies? ConstantNode (AccessIndexedNode''index-1 load))
            (let [
                #_"int" index (#_"JavaConstant" .asInt (:value (AccessIndexedNode''index-1 load)))
                ;; BALOAD (with elementKind being Byte) can be used to retrieve values from boolean arrays.
                #_"JavaKind" elementKind (:elementKind load)
                elementKind
                    (when (= elementKind JavaKind/Byte) => elementKind
                        (let [
                            elementKind (PEReadEliminationClosure'getElementKindFromStamp-1 (:array load))
                        ]
                            (when (= elementKind JavaKind/Illegal) => elementKind
                                (ยง return false)
                            )
                        )
                    )
            ]
                (PEReadEliminationClosure''processLoad-8 this, load, (:array load), (NamedLocationIdentity'getArrayLocation-1 elementKind), index, elementKind, state, effects)
            )
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processStoreIndexed-4 [#_"PEReadEliminationClosure" this, #_"StoreIndexedNode" store, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"int" index (if (satisfies? ConstantNode (AccessIndexedNode''index-1 store)) (#_"JavaConstant" .asInt (:value (AccessIndexedNode''index-1 store))) -1)
            ;; BASTORE (with elementKind being Byte) can be used to store values in boolean arrays.
            #_"JavaKind" elementKind (:elementKind store)
            elementKind
                (when (= elementKind JavaKind/Byte) => elementKind
                    (let [
                        elementKind (PEReadEliminationClosure'getElementKindFromStamp-1 (:array store))
                    ]
                        (when (= elementKind JavaKind/Illegal) => elementKind
                            ;; Could not determine the actual access kind from stamp. Hence kill both.
                            (PEReadEliminationBlockState''killReadCache-3 state, (NamedLocationIdentity'getArrayLocation-1 JavaKind/Boolean), index)
                            (PEReadEliminationBlockState''killReadCache-3 state, (NamedLocationIdentity'getArrayLocation-1 JavaKind/Byte), index)
                            (ยง return false)
                        )
                    )
                )
        ]
            (let [
                #_"LocationIdentity" arrayLocation (NamedLocationIdentity'getArrayLocation-1 elementKind)
            ]
                (when (= index -1) => (PEReadEliminationClosure''processStore-10 this, store, (:array store), arrayLocation, index, elementKind, false, (:value store), state, effects)
                    (PEReadEliminationBlockState''killReadCache-3 state, arrayLocation, -1)
                    false
                )
            )
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processArrayLength-4 [#_"PEReadEliminationClosure" this, #_"ArrayLengthNode" length, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (PEReadEliminationClosure''processLoad-8 this, length, (:array length), NamedLocationIdentity'ARRAY_LENGTH, -1, JavaKind/Int, state, effects)
    )

    (defn- #_"boolean" PEReadEliminationClosure''processUnbox-4 [#_"PEReadEliminationClosure" this, #_"UnboxNode" unbox, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (PEReadEliminationClosure''processLoad-8 this, unbox, (Unary'''getValue-1 unbox), (NamedLocationIdentity'getUnboxLocation-1 (:boxingKind unbox)), -1, (:boxingKind unbox), state, effects)
    )

    (defn- #_"boolean" PEReadEliminationClosure'isOverflowAccess-2 [#_"JavaKind" accessKind, #_"JavaKind" declaredKind]
        (cond
            (= accessKind declaredKind)
                false
            (= accessKind JavaKind/Object)
                (condp = declaredKind
                    JavaKind/Object false
                    JavaKind/Long   false
                    JavaKind/Double (throw! "should not reach here")
                                    true
                )
            (#_"JavaKind" .isPrimitive declaredKind)
                (< (#_"JavaKind" .getBitCount declaredKind) (#_"JavaKind" .getBitCount accessKind))
            :else
                true
        )
    )

    (defn- #_"boolean" PEReadEliminationClosure''processUnsafeLoad-4 [#_"PEReadEliminationClosure" this, #_"RawLoadNode" load, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (and (satisfies? ConstantNode (:offset load))
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object load)))
            ]
                (and (some? type) (#_"ResolvedJavaType" .isArray type)
                    (let [
                        #_"JavaKind" accessKind (:accessKind load)
                        #_"JavaKind" componentKind (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type))
                        #_"long" offset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset load)))
                        #_"int" index (VirtualArrayNode'entryIndexForOffset-4 offset, accessKind, (#_"ResolvedJavaType" .getComponentType type), Integer/MAX_VALUE)
                        #_"ValueNode" object (GraphUtil'unproxify-1n (:object load))
                        #_"LocationIdentity" location (NamedLocationIdentity'getArrayLocation-1 componentKind)
                        #_"ValueNode" cachedValue (PEReadEliminationBlockState''getReadCache-6 state, object, location, index, accessKind, this)
                    ]
                        (if (some? cachedValue)
                            (do
                                (GraphEffectList''replaceAtUsages-4 effects, load, cachedValue, load)
                                (EffectsClosure''addScalarAlias-3 this, load, cachedValue)
                                true
                            )
                            (do
                                (PEReadEliminationBlockState''addReadCache-8 state, object, location, index, accessKind, (PEReadEliminationClosure'isOverflowAccess-2 accessKind, componentKind), load, this)
                                false
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" PEReadEliminationClosure'processIdentity-2 [#_"PEReadEliminationBlockState" state, #_"LocationIdentity" location]
        (if (LocationIdentity''isAny-1 location)
            (PEReadEliminationBlockState''killReadCache-1 state)
            (PEReadEliminationBlockState''killReadCache-3 state, location, -1)
        )
        nil
    )

    (defn- #_"boolean" PEReadEliminationClosure''processUnsafeStore-4 [#_"PEReadEliminationClosure" this, #_"RawStoreNode" store, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object store)))
        ]
            (if (and (some? type) (#_"ResolvedJavaType" .isArray type))
                (let [
                    #_"JavaKind" accessKind (:accessKind store)
                    #_"JavaKind" componentKind (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type))
                    #_"LocationIdentity" location (NamedLocationIdentity'getArrayLocation-1 componentKind)
                ]
                    (if (satisfies? ConstantNode (:offset store))
                        (let [
                            #_"long" offset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset store)))
                            #_"boolean" overflowAccess (PEReadEliminationClosure'isOverflowAccess-2 accessKind, componentKind)
                            #_"int" index (if overflowAccess -1 (VirtualArrayNode'entryIndexForOffset-4 offset, accessKind, (#_"ResolvedJavaType" .getComponentType type), Integer/MAX_VALUE))
                        ]
                            (PEReadEliminationClosure''processStore-10 this, store, (:object store), location, index, accessKind, overflowAccess, (:value store), state, effects)
                        )
                        (do
                            (PEReadEliminationClosure'processIdentity-2 state, location)
                            false
                        )
                    )
                )
                (do
                    (PEReadEliminationBlockState''killReadCache-1 state)
                    false
                )
            )
        )
    )

    (defm PEReadEliminationClosure BlockIteratorClosure
        (#_"PEReadEliminationBlockState" BlockIteratorClosure'''getInitialState-1 [#_"PEReadEliminationClosure" this]
            (PEReadEliminationBlockState'new-0)
        )

        (#_"PEReadEliminationBlockState" BlockIteratorClosure'''cloneState-2 [#_"PEReadEliminationClosure" this, #_"PEReadEliminationBlockState" other]
            (PEReadEliminationBlockState'copy-1 other)
        )
    )

    (defm PEReadEliminationClosure EffectsClosure
        (#_"PEMergeProcessor<PEReadEliminationBlockState>" EffectsClosure'''createMergeProcessor-2 [#_"PEReadEliminationClosure" this, #_"Block" merge]
            (PEReadEliminationMergeProcessor'new-2 this, merge)
        )

        (#_"boolean" EffectsClosure'''processNode-5 [#_"PEReadEliminationClosure" this, #_"Node" node, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
            (or (EffectsClosure'''processNode-5 (ยง super #_"PartialEscapeClosure"), node, state, effects, lastFixedNode)
                (condp satisfies? node
                    LoadFieldNode    (PEReadEliminationClosure''processLoadField-4 this, node, state, effects)
                    StoreFieldNode   (PEReadEliminationClosure''processStoreField-4 this, node, state, effects)
                    LoadIndexedNode  (PEReadEliminationClosure''processLoadIndexed-4 this, node, state, effects)
                    StoreIndexedNode (PEReadEliminationClosure''processStoreIndexed-4 this, node, state, effects)
                    ArrayLengthNode  (PEReadEliminationClosure''processArrayLength-4 this, node, state, effects)
                    UnboxNode        (PEReadEliminationClosure''processUnbox-4 this, node, state, effects)
                    RawLoadNode      (PEReadEliminationClosure''processUnsafeLoad-4 this, node, state, effects)
                    RawStoreNode     (PEReadEliminationClosure''processUnsafeStore-4 this, node, state, effects)
                    Single
                        (let [
                            #_"LocationIdentity" location (Single'''getLocationIdentity-1 node)
                        ]
                            (PEReadEliminationClosure'processIdentity-2 state, location)
                            false
                        )
                    Multi
                        (do
                            (doseq [#_"LocationIdentity" location (Multi'''getLocationIdentities-1 node)]
                                (PEReadEliminationClosure'processIdentity-2 state, location)
                            )
                            false
                        )
                    false
                )
            )
        )

        (#_"void" EffectsClosure'''processInitialLoopState-3 [#_"PEReadEliminationClosure" this, #_"Loop" _loop, #_"PEReadEliminationBlockState" initialState]
            (EffectsClosure'''processInitialLoopState-3 (ยง super #_"PartialEscapeClosure"), _loop, initialState)

            (when (seq (:readCache initialState))
                (let [
                    #_"EconomicMap<ValueNode, Pair<ValueNode, Object>>" firstValueSet
                        (loop-when [firstValueSet nil #_"ISeq" s (seq (AbstractMergeNode''phis-1 (:beginNode (:header _loop))))] (some? s) => firstValueSet
                            (let [
                                #_"PhiNode" phi (first s)
                                #_"ValueNode" firstValue (PhiNode''valueAt-2i phi, 0)
                                firstValueSet
                                    (when (and (some? firstValue) (#_"JavaKind" .isObject (ValueNode''getStackKind-1 phi))) => firstValueSet
                                        (let [
                                            #_"ValueNode" unproxified (GraphUtil'unproxify-1n firstValue)
                                            firstValueSet (or firstValueSet (EconomicMap/create))
                                        ]
                                            (#_"EconomicMap" .put firstValueSet, unproxified, (Pair/create unproxified, (get firstValueSet unproxified)))
                                            firstValueSet
                                        )
                                    )
                            ]
                                (recur firstValueSet (next s))
                            )
                        )
                ]
                    (when (some? firstValueSet)
                        (let [
                            #_"ReadCacheEntry[]" entries (make-array ReadCacheEntry'iface (count (:readCache initialState)))
                            _
                                (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq (keys (:readCache initialState)))] (some? s) [(inc i) (next s)]
                                    (aset entries i (first s))
                                )
                        ]
                            (doseq [#_"ReadCacheEntry" entry entries]
                                (when (some? (:object entry))
                                    (loop-when-recur [#_"Pair<ValueNode, Object>" pair (get firstValueSet (:object entry))] (some? pair) [(#_"Pair" .getRight pair)]
                                        (PEReadEliminationBlockState''addReadCache-8 initialState, (#_"Pair" .getLeft pair), (:identity entry), (:index entry), (:kind entry), (:overflowAccess entry), (get (:readCache initialState) entry), this)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        (#_"void" EffectsClosure'''processLoopExit-5 [#_"PEReadEliminationClosure" this, #_"LoopExitNode" exitNode, #_"PEReadEliminationBlockState" initialState, #_"PEReadEliminationBlockState" exitState, #_"GraphEffectList" effects]
            (EffectsClosure'''processLoopExit-5 (ยง super #_"PartialEscapeClosure"), exitNode, initialState, exitState, effects)

            (when (:hasValueProxies (:graph exitNode))
                (let [
                    #_"MapCursor<ReadCacheEntry, ValueNode>" entry (#_"EconomicMap" .getEntries (:readCache exitState))
                ]
                    (while (#_"MapCursor" .advance entry)
                        (when-not (= (get (:readCache initialState) (#_"MapCursor" .getKey entry)) (#_"MapCursor" .getValue entry))
                            (let [
                                #_"ValueNode" value (PEReadEliminationBlockState''getReadCache-6 exitState, (:object (#_"MapCursor" .getKey entry)), (:identity (#_"MapCursor" .getKey entry)), (:index (#_"MapCursor" .getKey entry)), (:kind (#_"MapCursor" .getKey entry)), this)
                            ]
                                (when-not (and (satisfies? ProxyNode value) (= (:loopExit value) exitNode))
                                    (let [
                                        #_"ProxyNode" proxy (ValueProxyNode'new-2 value, exitNode)
                                    ]
                                        (GraphEffectList''addFloatingNode-3 effects, proxy, "readCacheProxy")
                                        (#_"EconomicMap" .put (:readCache exitState), (#_"MapCursor" .getKey entry), proxy)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        (#_"void" EffectsClosure'''processKilledLoopLocations-4 [#_"PEReadEliminationClosure" this, #_"Loop" _loop, #_"PEReadEliminationBlockState" initialState, #_"PEReadEliminationBlockState" mergedStates]
            (when (seq (:readCache initialState))
                (let [
                    #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) _loop)
                ]
                    ;; we have fully processed this loop the first time, remember to cache it the next time it is visited
                    (if (nil? loopKilledLocations)
                        (do
                            (ยง ass loopKilledLocations (LoopKillCache'new-1 1)) ;; 1.visit
                            (#_"EconomicMap" .put (:loopLocationKillCache this), _loop, loopKilledLocations)
                        )
                        (do
                            (if (< GraalOptions'readEliminationMaxLoopVisits (:visits loopKilledLocations))
                                (do
                                    ;; we have processed the loop too many times: kill all locations, so
                                    ;; the inner loop will never be processed more than once again on visit
                                    (ยง ass! loopKilledLocations (LoopKillCache''setKillsAll-1 loopKilledLocations))
                                )
                                ;; we have fully processed this loop >1 times, update the killed locations
                                (let [
                                    #_"EconomicSet<LocationIdentity>" forwardEndLiveLocations (EconomicSet/create)
                                ]
                                    (doseq [#_"ReadCacheEntry" entry (keys (:readCache initialState))]
                                        (#_"EconomicSet" .add forwardEndLiveLocations, (:identity entry))
                                    )
                                    (doseq [#_"ReadCacheEntry" entry (keys (:readCache mergedStates))]
                                        (#_"EconomicSet" .remove forwardEndLiveLocations, (:identity entry))
                                    )
                                    ;; every location that is alive before the loop but not after is killed by the loop
                                    (doseq [#_"LocationIdentity" location forwardEndLiveLocations]
                                        (ยง ass! loopKilledLocations (LoopKillCache''rememberLoopKilledLocation-2 loopKilledLocations, location))
                                    )
                                )
                            )
                            ;; remember the loop visit
                            (ยง ass! loopKilledLocations (LoopKillCache''visited-1 loopKilledLocations))
                        )
                    )
                )
            )
            nil
        )

        (#_"PEReadEliminationBlockState" EffectsClosure'''stripKilledLoopLocations-3 [#_"PEReadEliminationClosure" this, #_"Loop" _loop, #_"PEReadEliminationBlockState" originalInitialState]
            (let [
                #_"PEReadEliminationBlockState" initialState (EffectsClosure'''stripKilledLoopLocations-3 (ยง super #_"PartialEscapeClosure"), _loop, originalInitialState)
                #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) _loop)
            ]
                (when (and (some? loopKilledLocations) (LoopKillCache''loopKillsLocations-1 loopKilledLocations))
                    (let [
                        #_"Iterator<ReadCacheEntry>" it (#_"Iterable" .iterator (keys (:readCache initialState)))
                    ]
                        (while (#_"Iterator" .hasNext it)
                            (when (LoopKillCache''containsLocation-2 loopKilledLocations, (:identity (#_"Iterator" .next it)))
                                (#_"Iterator" .remove it)
                            )
                        )
                    )
                )
                initialState
            )
        )
    )
)

;;;
 ; This closure initially handled a set of nodes that is disjunct from PEReadEliminationClosure,
 ; but over time both have evolved so that there's a significant overlap.
 ;;
(class-ns ReadEliminationClosure [EffectsClosure #_"<ReadEliminationBlockState>", BlockIteratorClosure #_"<ReadEliminationBlockState>"]
    (defn #_"ReadEliminationClosure" ReadEliminationClosure'new-2 [#_"ControlFlowGraph" cfg, #_"boolean" considerGuards]
        (merge (ReadEliminationClosure'class.) (EffectsClosure'new-2 nil, cfg)
            (hash-map
                #_"boolean" :considerGuards considerGuards
            )
        )
    )

    (defm ReadEliminationClosure BlockIteratorClosure
        (#_"ReadEliminationBlockState" BlockIteratorClosure'''getInitialState-1 [#_"ReadEliminationClosure" this]
            (ReadEliminationBlockState'new-0)
        )

        (#_"ReadEliminationBlockState" BlockIteratorClosure'''cloneState-2 [#_"ReadEliminationClosure" this, #_"ReadEliminationBlockState" other]
            (ReadEliminationBlockState'copy-1 other)
        )
    )

    (defn- #_"void" ReadEliminationClosure'processIdentity-2 [#_"ReadEliminationBlockState" state, #_"LocationIdentity" location]
        (if (LocationIdentity''isAny-1 location)
            (ReadEliminationBlockState''killReadCache-1 state)
            (ReadEliminationBlockState''killReadCache-2 state, location)
        )
        nil
    )

    (defn- #_"GuardingNode" ReadEliminationClosure'getGuard-1 [#_"ValueNode" node]
        (when (satisfies? GuardedNode node)
            (GuardedNode'''getGuard-1 node)
        )
    )

    (defn- #_"boolean" ReadEliminationClosure'areValuesReplaceable-3 [#_"ValueNode" originalValue, #_"ValueNode" replacementValue, #_"boolean" considerGuards]
        (and (Stamp'''isCompatible-2s (:stamp originalValue), (:stamp replacementValue)) (or (not considerGuards) (nil? (ReadEliminationClosure'getGuard-1 originalValue)) (= (ReadEliminationClosure'getGuard-1 originalValue) (ReadEliminationClosure'getGuard-1 replacementValue))))
    )

    (defm ReadEliminationClosure EffectsClosure
        (#_"MergeProcessor<ReadEliminationBlockState>" EffectsClosure'''createMergeProcessor-2 [#_"ReadEliminationClosure" this, #_"Block" merge]
            (ReadEliminationMergeProcessor'new-1 merge)
        )

        (#_"boolean" EffectsClosure'''processNode-5 [#_"ReadEliminationClosure" this, #_"Node" node, #_"ReadEliminationBlockState" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
            (condp satisfies? node
                AccessFieldNode
                    (if (AccessFieldNode''isVolatile-1 node)
                        (do
                            (ReadEliminationClosure'processIdentity-2 state, LocationIdentity'ANY)
                            false
                        )
                        (let [
                            #_"ValueNode" object (GraphUtil'unproxify-1n (:object node))
                            #_"LoadCacheEntry" identifier (LoadCacheEntry'new-2 object, (FieldLocationIdentity'new-1 (:field node)))
                            #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                        ]
                            (if (satisfies? LoadFieldNode node)
                                (if (and (some? cachedValue) (Stamp'''isCompatible-2s (:stamp node), (:stamp cachedValue)))
                                    (do
                                        (GraphEffectList''replaceAtUsages-4 effects, node, cachedValue, node)
                                        (EffectsClosure''addScalarAlias-3 this, node, cachedValue)
                                        true
                                    )
                                    (do
                                        (ReadEliminationBlockState''addCacheEntry-3 state, identifier, node)
                                        false
                                    )
                                )
                                (let [
                                    #_"ValueNode" value (EffectsClosure''getScalarAlias-2 this, (:value node))
                                    #_"boolean" del? (= (GraphUtil'unproxify-1n value) (GraphUtil'unproxify-1n cachedValue))
                                ]
                                    (when del?
                                        (GraphEffectList''deleteNode-2 effects, node)
                                    )
                                    (ReadEliminationBlockState''killReadCache-2 state, (:identity identifier))
                                    (ReadEliminationBlockState''addCacheEntry-3 state, identifier, value)
                                    del?
                                )
                            )
                        )
                    )
                ReadNode
                    (and (LocationIdentity''isSingle-1 (Access'''getLocationIdentity-1 node))
                        (let [
                            #_"ValueNode" object (GraphUtil'unproxify-1n (Access'''getAddress-1 node))
                            #_"LoadCacheEntry" identifier (LoadCacheEntry'new-2 object, (Access'''getLocationIdentity-1 node))
                            #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                        ]
                            (if (and (some? cachedValue) (ReadEliminationClosure'areValuesReplaceable-3 node, cachedValue, (:considerGuards this)))
                                (do
                                    (GraphEffectList''replaceAtUsages-4 effects, node, cachedValue, node)
                                    (EffectsClosure''addScalarAlias-3 this, node, cachedValue)
                                    true
                                )
                                (do
                                    (ReadEliminationBlockState''addCacheEntry-3 state, identifier, node)
                                    false
                                )
                            )
                        )
                    )
                WriteNode
                    (if (LocationIdentity''isSingle-1 (Access'''getLocationIdentity-1 node))
                        (let [
                            #_"ValueNode" object (GraphUtil'unproxify-1n (Access'''getAddress-1 node))
                            #_"LoadCacheEntry" identifier (LoadCacheEntry'new-2 object, (Access'''getLocationIdentity-1 node))
                            #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                            #_"ValueNode" value (EffectsClosure''getScalarAlias-2 this, (:value node))
                            #_"boolean" del? (= (GraphUtil'unproxify-1n value) (GraphUtil'unproxify-1n cachedValue))
                        ]
                            (when del?
                                (GraphEffectList''deleteNode-2 effects, node)
                            )
                            (ReadEliminationClosure'processIdentity-2 state, (Access'''getLocationIdentity-1 node))
                            (ReadEliminationBlockState''addCacheEntry-3 state, identifier, value)
                            del?
                        )
                        (do
                            (ReadEliminationClosure'processIdentity-2 state, (Access'''getLocationIdentity-1 node))
                            false
                        )
                    )
                UnsafeAccessNode
                    (let [
                        #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object node)))
                    ]
                        (and (some? type) (not (#_"ResolvedJavaType" .isArray type))
                            (if (satisfies? RawLoadNode node)
                                (and (LocationIdentity''isSingle-1 (:locationIdentity node))
                                    (let [
                                        #_"ValueNode" object (GraphUtil'unproxify-1n (:object node))
                                        #_"UnsafeLoadCacheEntry" identifier (UnsafeLoadCacheEntry'new-3 object, (:offset node), (:locationIdentity node))
                                        #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                                    ]
                                        (if (and (some? cachedValue) (ReadEliminationClosure'areValuesReplaceable-3 node, cachedValue, (:considerGuards this)))
                                            (do
                                                (GraphEffectList''replaceAtUsages-4 effects, node, cachedValue, node)
                                                (EffectsClosure''addScalarAlias-3 this, node, cachedValue)
                                                true
                                            )
                                            (do
                                                (ReadEliminationBlockState''addCacheEntry-3 state, identifier, node)
                                                false
                                            )
                                        )
                                    )
                                )
                                (if (LocationIdentity''isSingle-1 (:locationIdentity node))
                                    (let [
                                        #_"ValueNode" object (GraphUtil'unproxify-1n (:object node))
                                        #_"UnsafeLoadCacheEntry" identifier (UnsafeLoadCacheEntry'new-3 object, (:offset node), (:locationIdentity node))
                                        #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                                        #_"ValueNode" value (EffectsClosure''getScalarAlias-2 this, (:value node))
                                        #_"boolean" del? (= (GraphUtil'unproxify-1n value) (GraphUtil'unproxify-1n cachedValue))
                                    ]
                                        (when del?
                                            (GraphEffectList''deleteNode-2 effects, node)
                                        )
                                        (ReadEliminationClosure'processIdentity-2 state, (:locationIdentity node))
                                        (ReadEliminationBlockState''addCacheEntry-3 state, identifier, value)
                                        del?
                                    )
                                    (do
                                        (ReadEliminationClosure'processIdentity-2 state, (:locationIdentity node))
                                        false
                                    )
                                )
                            )
                        )
                    )
                Single
                    (let [
                        #_"LocationIdentity" location (Single'''getLocationIdentity-1 node)
                    ]
                        (ReadEliminationClosure'processIdentity-2 state, location)
                        false
                    )
                Multi
                    (do
                        (doseq [#_"LocationIdentity" location (Multi'''getLocationIdentities-1 node)]
                            (ReadEliminationClosure'processIdentity-2 state, location)
                        )
                        false
                    )
                false
            )
        )

        (#_"void" EffectsClosure'''processLoopExit-5 [#_"ReadEliminationClosure" this, #_"LoopExitNode" exitNode, #_"ReadEliminationBlockState" initialState, #_"ReadEliminationBlockState" exitState, #_"GraphEffectList" effects]
            (when (:hasValueProxies (:graph exitNode))
                (let [
                    #_"MapCursor<CacheEntry, ValueNode>" entry (#_"EconomicMap" .getEntries (:readCache exitState))
                ]
                    (while (#_"MapCursor" .advance entry)
                        (when-not (= (get (:readCache initialState) (#_"MapCursor" .getKey entry)) (#_"MapCursor" .getValue entry))
                            (let [
                                #_"ProxyNode" proxy (ValueProxyNode'new-2 (ReadEliminationBlockState''getCacheEntry-2 exitState, (#_"MapCursor" .getKey entry)), exitNode)
                            ]
                                (GraphEffectList''addFloatingNode-3 effects, proxy, "readCacheProxy")
                                (#_"EconomicMap" .put (:readCache exitState), (#_"MapCursor" .getKey entry), proxy)
                            )
                        )
                    )
                )
            )
            nil
        )

        (#_"void" EffectsClosure'''processKilledLoopLocations-4 [#_"ReadEliminationClosure" this, #_"Loop" _loop, #_"ReadEliminationBlockState" initialState, #_"ReadEliminationBlockState" mergedStates]
            (when (seq (:readCache initialState))
                (let [
                    #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) _loop)
                ]
                    ;; we have fully processed this loop the first time, remember to cache it the next time it is visited
                    (if (nil? loopKilledLocations)
                        (do
                            (ยง ass loopKilledLocations (LoopKillCache'new-1 1)) ;; 1.visit
                            (#_"EconomicMap" .put (:loopLocationKillCache this), _loop, loopKilledLocations)
                        )
                        (do
                            (if (< GraalOptions'readEliminationMaxLoopVisits (:visits loopKilledLocations))
                                (do
                                    ;; we have processed the loop too many times: kill all locations, so
                                    ;; the inner loop will never be processed more than once again on visit
                                    (ยง ass! loopKilledLocations (LoopKillCache''setKillsAll-1 loopKilledLocations))
                                )
                                ;; we have fully processed this loop >1 times, update the killed locations
                                (let [
                                    #_"EconomicSet<LocationIdentity>" forwardEndLiveLocations (EconomicSet/create)
                                ]
                                    (doseq [#_"CacheEntry" entry (keys (:readCache initialState))]
                                        (#_"EconomicSet" .add forwardEndLiveLocations, (CacheEntry'''getIdentity-1 entry))
                                    )
                                    (doseq [#_"CacheEntry" entry (keys (:readCache mergedStates))]
                                        (#_"EconomicSet" .remove forwardEndLiveLocations, (CacheEntry'''getIdentity-1 entry))
                                    )
                                    ;; every location that is alive before the loop but not after is killed by the loop
                                    (doseq [#_"LocationIdentity" location forwardEndLiveLocations]
                                        (ยง ass! loopKilledLocations (LoopKillCache''rememberLoopKilledLocation-2 loopKilledLocations, location))
                                    )
                                )
                            )
                            ;; remember the loop visit
                            (ยง ass! loopKilledLocations (LoopKillCache''visited-1 loopKilledLocations))
                        )
                    )
                )
            )
            nil
        )

        (#_"ReadEliminationBlockState" EffectsClosure'''stripKilledLoopLocations-3 [#_"ReadEliminationClosure" this, #_"Loop" _loop, #_"ReadEliminationBlockState" originalInitialState]
            (let [
                #_"ReadEliminationBlockState" initialState (EffectsClosure'''stripKilledLoopLocations-3 (ยง super EffectsClosure'iface), _loop, originalInitialState)
                #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) _loop)
            ]
                (when (and (some? loopKilledLocations) (LoopKillCache''loopKillsLocations-1 loopKilledLocations))
                    (let [
                        #_"Iterator<CacheEntry>" it (#_"Iterable" .iterator (keys (:readCache initialState)))
                    ]
                        (while (#_"Iterator" .hasNext it)
                            (when (LoopKillCache''containsLocation-2 loopKilledLocations, (CacheEntry'''getIdentity-1 (#_"Iterator" .next it)))
                                (#_"Iterator" .remove it)
                            )
                        )
                    )
                )
                initialState
            )
        )
    )
)

(class-ns BlockLoopInfo #_"<T>" []
    (defn #_"BlockLoopInfo" BlockLoopInfo'new-2 [#_"int" endCount, #_"int" exitCount]
        (merge (BlockLoopInfo'class.)
            (hash-map
                #_"List<T>" :endStates (ArrayList.)
                #_"List<T>" :exitStates (ArrayList.)
            )
        )
    )
)

(class-ns BlockMap #_"<T>" []
    (defn #_"BlockMap" BlockMap'new-1 [#_"ControlFlowGraph" cfg]
        (merge (BlockMap'class.)
            (hash-map
                #_"T[]" :data (ยง cast #_"T[]" (make-array Object (count (:reversePostOrder cfg))))
            )
        )
    )

    (defn #_"T" BlockMap''get-2 [#_"BlockMap<T>" this, #_"Block" block]
        (nth (:data this) (:id block))
    )

    (defn #_"void" BlockMap''put-3 [#_"BlockMap<T>" this, #_"Block" block, #_"T" value]
        (aset (:data this) (:id block) value)
        nil
    )
)

;;;
 ; Comparator for sorting blocks based on loop depth and probability.
 ;;
(class-ns BlockOrderComparator [#_"Comparator" #_"<Block>"]
    (defn #_"BlockOrderComparator" BlockOrderComparator'new-0 []
        (BlockOrderComparator'class.)
    )

    (def- #_"double" BlockOrderComparator'EPSILON 1e-6)

    (defm BlockOrderComparator LowerOp
        (#_"int" LowerOp'''compare-3 [#_"BlockOrderComparator" this, #_"Block" a, #_"Block" b]
            ;; Loop blocks before any loop exit block. The only exception are blocks that are (almost) impossible to reach.
            (when (and (< BlockOrderComparator'EPSILON (:probability a)) (< BlockOrderComparator'EPSILON (:probability b)))
                (let [
                    #_"int" diff (- (Block''getLoopDepth-1 b) (Block''getLoopDepth-1 a))
                ]
                    (when-not (zero? diff)
                        (ยง return diff)
                    )
                )
            )

            ;; Blocks with high probability before blocks with low probability.
            (if (< (:probability b) (:probability a)) -1 1)
        )
    )
)

(class-ns BlockScope [#_"AutoCloseable"]
    (defn #_"BlockScope" BlockScope'new-2 [#_"LIRGenerator" gen, #_"Block" block]
        (let [
            #_"BlockScope" this
                (merge (BlockScope'class.)
                    (hash-map
                        #_"LIRGenerator" :gen gen
                    )
                )
        ]
            (ยง ass! (:currentBlock (:gen this)) block)
            this
        )
    )

    (defn #_"void" BlockScope''doBlockStart-1 [#_"BlockScope" this]
        ;; set up the list of LIR instructions
        (LIR''setLIRforBlock-3 (:lir (:res (:gen this))), (:currentBlock (:gen this)), (ArrayList.))

        (LIRGenerator''append-2 (:gen this), (LabelOp'new-2 (Label'new-0), (:aligned? (:currentBlock (:gen this)))))
        nil
    )

    (defn- #_"void" BlockScope''doBlockEnd-1 [#_"BlockScope" this]
        (ยง ass! (:currentBlock (:gen this)) nil)
        nil
    )

    (ยง override! #_"void" #_"AutoCloseable." close [#_"BlockScope" this]
        (BlockScope''doBlockEnd-1 this)
        nil
    )
)

;;;
 ; Holds the entry and exit states for each block for dataflow analysis. The state is an array
 ; with an element for each relevant location (register or stack slot). Each element holds the
 ; global number of the location's definition. A location definition is simply an output of an
 ; instruction. Note that because instructions can have multiple outputs it is not possible to
 ; use the instruction id for value numbering. In addition, the result of merging at block
 ; entries (= phi values) get unique value numbers.
 ;
 ; The value numbers also contain information if it is an object kind value or not: if the
 ; number is negative it is an object kind value.
 ;;
(class-ns BlockStates []
    (defn #_"BlockStates" BlockStates'new-1 [#_"int" stateSize]
        (merge (BlockStates'class.)
            (hash-map
                ;; The state at block entry for global dataflow analysis.
                ;; It contains a global value number for each location to optimize.
                #_"int[]" :entryState (int-array stateSize)
                ;; The state at block exit for global dataflow analysis.
                ;; It contains a global value number for each location to optimize.
                #_"int[]" :exitState (int-array stateSize)
                ;; The starting number for global value numbering in this block.
                #_"int" :entryValueNum 0
            )
        )
    )
)

(class-ns BytecodeParser []
    (defn #_"BytecodeParser" BytecodeParser'new-5 [#_"GraphBuilderInstance" builder, #_"Graph" graph, #_"BytecodeParser" parent, #_"ResolvedJavaMethod" method, #_"IntrinsicContext" context]
        (let [
            #_"BytecodeProvider" bytecodeProvider (if (some? context) (:bytecodeProvider context) ResolvedJavaMethodBytecodeProvider'INSTANCE)
            #_"Bytecode" code (BytecodeProvider'''getBytecode-2 bytecodeProvider, method)
        ]
            (merge (BytecodeParser'class.)
                (hash-map
                    #_"GraphBuilderInstance" :graphBuilderInstance builder
                    #_"OptimisticOptimizations" :optimisticOpts (:optimisticOpts builder)
                    #_"Graph" :graph graph
                    ;;;
                     ; The parsing context for the method that inlines the method being parsed by this context.
                     ;;
                    #_"BytecodeParser" :parent parent
                    #_"IntrinsicContext" :intrinsicContext context
                    #_"BytecodeProvider" :bytecodeProvider bytecodeProvider
                    #_"Bytecode" :code code
                    #_"ResolvedJavaMethod" :method (Bytecode'''getMethod-1 code)
                    #_"ConstantPool" :constantPool (Bytecode'''getConstantPool-1 code)
                    #_"BytecodeStream" :stream (BytecodeStream'new-1 (Bytecode'''getCode-1 code))

                    #_"BciBlockMapping" :blockMap nil
                    #_"LocalLiveness" :liveness nil
                    #_"ValueNode" :methodSynchronizedObject nil
                    #_"List<ReturnToCallerData>" :returnDataList nil
                    #_"FixedWithNextNode" :lastInstr nil ;; the last instruction added
                    #_"boolean" :controlFlowSplit false
                    #_"FixedWithNextNode[]" :firstInstructionArray nil
                    #_"FrameStateBuilder[]" :entryStateArray nil
                    #_"boolean" :finalBarrierRequired false
                    #_"ValueNode" :originalReceiver nil
                    #_"CurrentInvoke" :currentInvoke nil
                    #_"FrameStateBuilder" :frameState nil
                    #_"BciBlock" :currentBlock nil
                )
            )
        )
    )

    (defn- #_"void" BytecodeParser''setEntryState-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FrameStateBuilder" entryState]
        (aset (:entryStateArray this) (:id block) entryState)
        nil
    )

    (defn- #_"FrameStateBuilder" BytecodeParser''getEntryState-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (nth (:entryStateArray this) (:id block))
    )

    (defn- #_"void" BytecodeParser''setFirstInstruction-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FixedWithNextNode" firstInstruction]
        (aset (:firstInstructionArray this) (:id block) firstInstruction)
        nil
    )

    (defn- #_"FixedWithNextNode" BytecodeParser''getFirstInstruction-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (nth (:firstInstructionArray this) (:id block))
    )

    (defn- #_"FrameState" BytecodeParser''createFrameState-3 [#_"BytecodeParser" this, #_"int" bci, #_"StateSplit" forStateSplit]
        (when (and (some? (:currentBlock this)) (< (:endBci (:currentBlock this)) bci))
            (FrameStateBuilder''clearNonLiveLocals-4 (:frameState this), (:currentBlock this), (:liveness this), false)
        )
        (FrameStateBuilder''create-3 (:frameState this), bci, forStateSplit)
    )

    ;;;
     ; Creates the frame state after the start node of a graph for an {@link IntrinsicContext
     ; intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
     ;;
    (defn- #_"FrameState" BytecodeParser''createStateAfterStartOfReplacementGraph-1 [#_"BytecodeParser" this]
        (if (IntrinsicContext''isPostParseInlined-1 (:intrinsicContext this))
            (Graph''add-2 (:graph this), (FrameState'new-1 BytecodeFrame/BEFORE_BCI))
            (let [
                #_"ResolvedJavaMethod" original (:originalMethod (:intrinsicContext this))
                #_"ValueNode[]" locals
                    (if (or (= (#_"ResolvedJavaMethod" .getMaxLocals original) (count (:locals (:frameState this)))) (#_"ResolvedJavaMethod" .isNative original))
                        (let [
                            locals (make-array ValueNode'iface (#_"ResolvedJavaMethod" .getMaxLocals original))
                        ]
                            (dotimes [#_"int" i (count locals)]
                                (let [
                                    #_"ValueNode" node (nth (:locals (:frameState this)) i)
                                ]
                                    (aset locals i (when-not (= node FrameState'TWO_SLOT_MARKER) node))
                                )
                            )
                            locals
                        )
                        (let [
                            locals (make-array ValueNode'iface (#_"ResolvedJavaMethod" .getMaxLocals original))
                            #_"int" n (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature original), (not (#_"ResolvedJavaMethod" .isStatic original)))
                        ]
                            (dotimes [#_"int" i n]
                                (let [
                                    #_"ValueNode" param (nth (:locals (:frameState this)) i)
                                ]
                                    (aset locals i (when-not (= param FrameState'TWO_SLOT_MARKER) param))
                                )
                            )
                            locals
                        )
                    )
            ]
                (Graph''add-2 (:graph this), (FrameState'new-9a nil, (ResolvedJavaMethodBytecode'new-1 original), 0, locals, (make-array ValueNode'iface 0), 0, (make-array ValueNode'iface 0), (Collections/emptyList), false))
            )
        )
    )

    (defn- #_"ValueNode" BytecodeParser''synchronizedObject-3 [#_"BytecodeParser" this, #_"FrameStateBuilder" state, #_"ResolvedJavaMethod" target]
        (if (#_"ResolvedJavaMethod" .isStatic target)
            (BytecodeParser''appendConstant-2 this, (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"ResolvedJavaMethod" .getDeclaringClass target)))
            (FrameStateBuilder''loadLocal-3 state, 0, JavaKind/Object)
        )
    )

    (defn- #_"FixedTarget" BytecodeParser''checkLoopExit-4 [#_"BytecodeParser" this, #_"FixedNode" target, #_"BciBlock" targetBlock, #_"FrameStateBuilder" state]
        (when (some? (:currentBlock this)) => (FixedTarget'new-2 target, state)
            (let [
                #_"long" exits (& (:loops (:currentBlock this)) (bit-not (:loops targetBlock)))
            ]
                (when-not (zero? exits) => (FixedTarget'new-2 target, state)
                    (let [
                        #_"ArrayList<BciBlock>" exitLoops (ArrayList.)
                        exits
                            (loop [exits exits #_"int" i 0]
                                (let [
                                    #_"long" lMask (<< 1 i)
                                    exits
                                        (when-not (zero? (& exits lMask)) => exits
                                            (#_"ArrayList" .add exitLoops, (nth (:loopHeaders (:blockMap this)) i))
                                            (& exits (bit-not lMask))
                                        )
                                ]
                                    (recur-if (not (zero? exits)) [exits (inc i)] => exits)
                                )
                            )
                        _
                            (Collections/sort exitLoops,
                                (reify Comparator #_"<BciBlock>"
                                    (#_"int" compare [#_"Comparator<BciBlock>" _, #_"BciBlock" b1, #_"BciBlock" b2]
                                        (- (Long/bitCount (:loops b2)) (Long/bitCount (:loops b1)))
                                    )
                                )
                            )
                        #_"FrameStateBuilder" newState (FrameStateBuilder'copy-1 state)
                        [#_"LoopExitNode" firstLoopExit #_"LoopExitNode" lastLoopExit]
                            (loop-when [firstLoopExit nil lastLoopExit nil #_"ISeq" s (seq exitLoops)] (some? s) => [firstLoopExit lastLoopExit]
                                (let [
                                    #_"BciBlock" _loop (first s)
                                    #_"LoopBeginNode" loopBegin (BytecodeParser''getFirstInstruction-2 this, _loop)
                                    #_"LoopExitNode" loopExit (Graph''add-2 (:graph this), (LoopExitNode'new-1 loopBegin))
                                ]
                                    (when (some? lastLoopExit)
                                        (ยง ass! lastLoopExit (FixedWithNextNode''setNext-2 lastLoopExit, loopExit))
                                    )
                                    (let [
                                        firstLoopExit (or firstLoopExit loopExit)
                                        lastLoopExit loopExit
                                    ]
                                        (FrameStateBuilder''clearNonLiveLocals-4 newState, targetBlock, (:liveness this), true)
                                        (FrameStateBuilder''insertLoopProxies-3 newState, loopExit, (BytecodeParser''getEntryState-2 this, _loop))
                                        (StateSplit'''setStateAfter-2 loopExit, (FrameStateBuilder''create-3 newState, (:startBci targetBlock), loopExit))
                                        (recur firstLoopExit lastLoopExit (next s))
                                    )
                                )
                            )
                    ]
                        (ยง ass! lastLoopExit (FixedWithNextNode''setNext-2 lastLoopExit, target))
                        (FixedTarget'new-2 firstLoopExit, newState)
                    )
                )
            )
        )
    )

    (defn- #_"FixedNode" BytecodeParser''createTarget-5 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FrameStateBuilder" state, #_"boolean" canReuseInstruction, #_"boolean" canReuseState]
        (when (nil? (BytecodeParser''getFirstInstruction-2 this, block))
            ;; This is the first time we see this block as a branch target. Create and return a
            ;; placeholder that later can be replaced with a MergeNode when we see this block again.
            (if (and canReuseInstruction (or (= (:predecessorCount block) 1) (not (:controlFlowSplit this))) (not (:isLoopHeader block)) (zero? (& (:loops (:currentBlock this)) (bit-not (:loops block)))))
                (do
                    (BytecodeParser''setFirstInstruction-3 this, block, (:lastInstr this))
                    (ยง ass! this (assoc this :lastInstr nil))
                )
                (BytecodeParser''setFirstInstruction-3 this, block, (Graph''add-2 (:graph this), (BeginNode'new-0)))
            )
            (let [
                #_"FixedNode" targetNode (BytecodeParser''getFirstInstruction-2 this, block)
                #_"FixedTarget" target (BytecodeParser''checkLoopExit-4 this, targetNode, block, state)
                #_"FixedNode" result (:fixed target)
                #_"FrameStateBuilder" currentEntryState (cond (not= (:state target) state) (:state target) canReuseState state :else (FrameStateBuilder'copy-1 state))
            ]
                (BytecodeParser''setEntryState-3 this, block, currentEntryState)
                (FrameStateBuilder''clearNonLiveLocals-4 currentEntryState, block, (:liveness this), true)

                (ยง return result)
            )
        )

        ;; We already saw this block before, so we have to merge states.
        (when-not (FrameStateBuilder''isCompatibleWith-2 (BytecodeParser''getEntryState-2 this, block), state)
            (throw! (str "stacks do not match on merge from " (BytecodeParser''bci-1 this) " into " block "; bytecodes would not verify:\nexpect: " (BytecodeParser''getEntryState-2 this, block) "\nactual: " state))
        )

        (when (satisfies? LoopBeginNode (BytecodeParser''getFirstInstruction-2 this, block))
            ;; Backward loop edge. We need to create a special LoopEndNode and merge with the
            ;; loop begin node created before.
            (let [
                #_"LoopBeginNode" loopBegin (BytecodeParser''getFirstInstruction-2 this, block)
                #_"LoopEndNode" loopEnd (Graph''add-2 (:graph this), (LoopEndNode'new-1 loopBegin))
                #_"FixedTarget" target (BytecodeParser''checkLoopExit-4 this, loopEnd, block, state)
                #_"FixedNode" result (:fixed target)
            ]
                (ยง ass! (BytecodeParser''getEntryState-2 this, block) (FrameStateBuilder''merge-3 (BytecodeParser''getEntryState-2 this, block), loopBegin, (:state target)))

                (ยง return result)
            )
        )

        (when (and (satisfies? AbstractBeginNode (BytecodeParser''getFirstInstruction-2 this, block)) (not (satisfies? AbstractMergeNode (BytecodeParser''getFirstInstruction-2 this, block))))
            ;; This is the second time we see this block. Create the actual MergeNode and the
            ;; End Node for the already existing edge.
            (let [
                #_"AbstractBeginNode" beginNode (BytecodeParser''getFirstInstruction-2 this, block)
                ;; The EndNode for the already existing edge.
                #_"EndNode" end (Graph''add-2 (:graph this), (EndNode'new-0))
                ;; The MergeNode that replaces the placeholder.
                #_"AbstractMergeNode" mergeNode (Graph''add-2 (:graph this), (MergeNode'new-0))
                #_"FixedNode" _next (:next beginNode)
            ]
                (if (satisfies? ControlSplitNode (:predecessor beginNode))
                    (ยง ass! beginNode (FixedWithNextNode''setNext-2 beginNode, end))
                    (do
                        (Node''replaceAtPredecessor-2 beginNode, end)
                        (Node''safeDelete-1 beginNode)
                    )
                )

                (AbstractMergeNode''addForwardEnd-2 mergeNode, end)
                (ยง ass! mergeNode (FixedWithNextNode''setNext-2 mergeNode, _next))

                (BytecodeParser''setFirstInstruction-3 this, block, mergeNode)
            )
        )

        (let [
            #_"AbstractMergeNode" mergeNode (BytecodeParser''getFirstInstruction-2 this, block)
            ;; The EndNode for the newly merged edge.
            #_"EndNode" newEnd (Graph''add-2 (:graph this), (EndNode'new-0))
            #_"FixedTarget" target (BytecodeParser''checkLoopExit-4 this, newEnd, block, state)
            #_"FixedNode" result (:fixed target)
        ]
            (ยง ass! (BytecodeParser''getEntryState-2 this, block) (FrameStateBuilder''merge-3 (BytecodeParser''getEntryState-2 this, block), mergeNode, (:state target)))
            (AbstractMergeNode''addForwardEnd-2 mergeNode, newEnd)

            result
        )
    )

    (defn- #_"FixedNode" BytecodeParser''createTarget-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FrameStateBuilder" state]
        (BytecodeParser''createTarget-5 this, block, state, false, false)
    )

    (defn- #_"FixedNode" BytecodeParser''createTarget-4 [#_"BytecodeParser" this, #_"double" probability, #_"BciBlock" block, #_"FrameStateBuilder" state]
        (if (BytecodeParser''isNeverExecutedCode-2 this, probability)
            (Graph''add-2 (:graph this), (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/UnreachedCode))
            (BytecodeParser''createTarget-3 this, block, state)
        )
    )

    ;;;
     ; Returns a block begin node with the specified state. If the specified probability is 0, the block deoptimizes immediately.
     ;;
    (defn- #_"AbstractBeginNode" BytecodeParser''createBlockTarget-4 [#_"BytecodeParser" this, #_"double" probability, #_"BciBlock" block, #_"FrameStateBuilder" state]
        (BeginNode'begin-1 (BytecodeParser''createTarget-4 this, probability, block, state))
    )

    (defn- #_"void" BytecodeParser''appendGoto-2 [#_"BytecodeParser" this, #_"BciBlock" successor]
        (let [
            #_"FixedNode" targetInstr (BytecodeParser''createTarget-5 this, successor, (:frameState this), true, true)
        ]
            (when (and (some? (:lastInstr this)) (not= (:lastInstr this) targetInstr))
                (ยง ass! (:lastInstr this) (FixedWithNextNode''setNext-2 (:lastInstr this), targetInstr))
            )
        )
        nil
    )

    (defn #_"BytecodeParser" BytecodeParser''build-3 [#_"BytecodeParser" this, #_"FixedWithNextNode" startInstruction, #_"FrameStateBuilder" startFrameState]
        ;; compute the block map, setup exception handlers and get the entrypoint(s)
        (let [
            this (assoc this :blockMap (BciBlockMapping'create-2 (:stream this), (:code this)))
            this (assoc this :firstInstructionArray (make-array FixedWithNextNode'iface (count (:blocks (:blockMap this)))))
            this (assoc this :entryStateArray (make-array FrameStateBuilder'iface (count (:blocks (:blockMap this)))))
            this
                (when-not (#_"ResolvedJavaMethod" .isStatic (:method this)) => this
                    (assoc this :originalReceiver (FrameStateBuilder''loadLocal-3 startFrameState, 0, JavaKind/Object))
                )
            this (assoc this :liveness (LocalLiveness'compute-4 (:stream this), (:blocks (:blockMap this)), (#_"ResolvedJavaMethod" .getMaxLocals (:method this)), (:nextLoop (:blockMap this))))
            this (assoc this :lastInstr startInstruction)
            this (BytecodeParser''setCurrentFrameState-2 this, startFrameState)
            _ (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), 0))
            #_"BciBlock" startBlock (:startBlock (:blockMap this))
        ]
            (when (nil? (:parent this))
                (let [
                    #_"StartNode" startNode (:start (:graph this))
                ]
                    (cond
                        (#_"ResolvedJavaMethod" .isSynchronized (:method this))
                            (StateSplit'''setStateAfter-2 startNode, (BytecodeParser''createFrameState-3 this, BytecodeFrame/BEFORE_BCI, startNode))
                        (BytecodeParser''parsingIntrinsic-1 this)
                            (when (nil? (:stateAfter startNode))
                                (StateSplit'''setStateAfter-2 startNode, (BytecodeParser''createStateAfterStartOfReplacementGraph-1 this))
                            )
                        :else
                            (do
                                (FrameStateBuilder''clearNonLiveLocals-4 (:frameState this), startBlock, (:liveness this), true)
                                (StateSplit'''setStateAfter-2 startNode, (BytecodeParser''createFrameState-3 this, (BytecodeParser''bci-1 this), startNode))
                            )
                    )
                )
            )

            (let [
                this
                    (when (#_"ResolvedJavaMethod" .isSynchronized (:method this)) => this
                        ;; add a monitor enter to the start block
                        (let [
                            this (assoc this :methodSynchronizedObject (BytecodeParser''synchronizedObject-3 this, (:frameState this), (:method this)))
                        ]
                            (FrameStateBuilder''clearNonLiveLocals-4 (:frameState this), startBlock, (:liveness this), true)
                            (BytecodeParser''genMonitorEnter-3 this, (:methodSynchronizedObject this), (BytecodeParser''bci-1 this))
                            this
                        )
                    )
                this (assoc this :currentBlock (:startBlock (:blockMap this)))
            ]
                (BytecodeParser''setEntryState-3 this, startBlock, (:frameState this))
                (if (:isLoopHeader startBlock)
                    (BytecodeParser''appendGoto-2 this, startBlock)
                    (BytecodeParser''setFirstInstruction-3 this, startBlock, (:lastInstr this))
                )

                (doseq [#_"BciBlock" block (:blocks (:blockMap this))]
                    (ยง ass! this (BytecodeParser''processBlock-2 this, block))
                )
                this
            )
        )
    )

    ; @SuppressWarnings("try")
    (defn #_"this" BytecodeParser''buildRootMethod-1 [#_"BytecodeParser" this]
        (let [
            #_"FrameStateBuilder" startFrameState (FrameStateBuilder'new-3c this, (:code this), (:graph this))
        ]
            (FrameStateBuilder''initializeForMethodStart-1 startFrameState)

            (try (ยง with [#_"IntrinsicScope" _ (when (some? (:intrinsicContext this)) (IntrinsicScope'new-1 this))])
                (ยง ass! this (BytecodeParser''build-3 this, (:start (:graph this)), startFrameState))
            )

            (BytecodeParser''cleanupFinalGraph-1 this)
            (ComputeLoopFrequenciesClosure'compute-1 (:graph this))
            this
        )
    )

    ;;;
     ; Adds a node to the graph. If the node is in the graph, returns immediately. If the node is a StateSplit
     ; with a nil {@linkplain StateSplit#stateAfter() frame state}, the frame state is initialized.
     ;
     ; @param value the value to add to the graph and push to the stack. The {@code value.getJavaKind()} kind
     ;            is used when type checking this operation.
     ; @return a node equivalent to {@code value} in the graph
     ;;
    (defn #_"ValueNode" BytecodeParser''add-2 [#_"BytecodeParser" this, #_"ValueNode" value]
        (when (nil? (:graph value)) => value
            (let [
                value (BytecodeParser''append-2 this, value)
            ]
                (when (and (satisfies? StateSplit value) (nil? (:stateAfter value)) (StateSplit'''hasSideEffect-1 value))
                    (BytecodeParser''setStateAfter-2 this, value)
                )
                value
            )
        )
    )

    ;;;
     ; Adds a node with a non-void kind to the graph, pushes it to the stack. If the returned node is a StateSplit
     ; with a nil {@linkplain StateSplit#stateAfter() frame state}, the frame state is initialized.
     ;
     ; @param kind the kind to use when type checking this operation
     ; @param value the value to add to the graph and push to the stack
     ; @return a node equivalent to {@code value} in the graph
     ;;
    (defn #_"ValueNode" BytecodeParser''addPush-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"ValueNode" value]
        (let [
            value (if (some? (:graph value)) value (BytecodeParser''append-2 this, value))
        ]
            (BytecodeParser''push-3 this, kind, value)
            (when (and (satisfies? StateSplit value) (nil? (:stateAfter value)) (StateSplit'''hasSideEffect-1 value))
                (BytecodeParser''setStateAfter-2 this, value)
            )
            value
        )
    )

    (defn #_"Stamp" BytecodeParser''getInvokeReturnStamp-1 [#_"BytecodeParser" this]
        (StampFactory'forDeclaredType-2 (BytecodeParser''getInvokeReturnType-1 this), false)
    )

    ;;;
     ; Gets a version of a given value that has a {@linkplain StampTool#isPointerNonNull(ValueNode) non-nil} stamp.
     ;;
    (defn #_"ValueNode" BytecodeParser''nullCheckedValue-3 [#_"BytecodeParser" this, #_"ValueNode" value, #_"DeoptimizationAction" action]
        (when-not (StampTool'isPointerNeverNull-1 (:stamp value)) => value
            (let [
                #_"LogicNode" logic (Graph''add-2 (:graph this), (IsNullNode'create-1 value))
                #_"Stamp" stamp (Stamp'''join-2 (:stamp value), StampFactory'objectNonNullStamp)
                #_"FixedGuardNode" fixedGuard (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/NullCheckException, action, true))
                #_"ValueNode" nonNullReceiver (Graph''addOrUniqueWithInputs-2 (:graph this), (PiNode'create-3 value, stamp, fixedGuard))
            ]
                ;; TODO Propogating the non-nil into the frame state would remove subsequent nil-checks on the same value.
                ;;
                ;; frameState.replace(value, nonNullReceiver);
                nonNullReceiver
            )
        )
    )

    (defn #_"ValueNode" BytecodeParser''nullCheckedValue-2 [#_"BytecodeParser" this, #_"ValueNode" value]
        (BytecodeParser''nullCheckedValue-3 this, value, DeoptimizationAction/InvalidateReprofile)
    )

    (defn #_"void" BytecodeParser''cleanupFinalGraph-1 [#_"BytecodeParser" this]
        (ยง ass! (:graph this) (GraphUtil'normalizeLoops-1 (:graph this)))

        ;; Remove dead parameters.
        (doseq [#_"ParameterNode" param (Graph''getNodes-2 (:graph this), ParameterNode)]
            (when (Node''hasNoUsages-1 param)
                (Node''safeDelete-1 param)
            )
        )

        ;; Remove redundant begin nodes.
        (doseq [#_"BeginNode" beginNode (Graph''getNodes-2 (:graph this), BeginNode)]
            (when (and (not (satisfies? ControlSplitNode (:predecessor beginNode))) (not (Node''hasUsages-1 beginNode)))
                (GraphUtil'unlinkFixedNode-1 beginNode)
                (Node''safeDelete-1 beginNode)
            )
        )
        nil
    )

    ;;;
     ; @param type the unresolved type of the constant
     ;;
    (defn #_"void" BytecodeParser''handleUnresolvedLoadConstant-2 [#_"BytecodeParser" this, #_"JavaType" type]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param type the unresolved type of the type check
     ; @param object the object value whose type is being checked against {@code type}
     ;;
    (defn #_"void" BytecodeParser''handleUnresolvedCheckCast-3 [#_"BytecodeParser" this, #_"JavaType" type, #_"ValueNode" object]
        (BytecodeParser''append-2 this, (FixedGuardNode'new-3 (Graph''addOrUniqueWithInputs-2 (:graph this), (IsNullNode'create-1 object)), DeoptimizationReason/Unresolved, DeoptimizationAction/InvalidateRecompile))
        (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''appendConstant-2 this, JavaConstant/NULL_POINTER)))
        nil
    )

    ;;;
     ; @param type the unresolved type of the type check
     ; @param object the object value whose type is being checked against {@code type}
     ;;
    (defn #_"BytecodeParser" BytecodeParser''handleUnresolvedInstanceOf-3 [#_"BytecodeParser" this, #_"JavaType" type, #_"ValueNode" object]
        (let [
            #_"AbstractBeginNode" successor (Graph''add-2 (:graph this), (BeginNode'new-0))
            #_"DeoptimizeNode" deopt (Graph''add-2 (:graph this), (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        ]
            (BytecodeParser''append-2 this, (IfNode'new-4b (Graph''addOrUniqueWithInputs-2 (:graph this), (IsNullNode'create-1 object)), successor, deopt, 1))
            (let [
                this (assoc this :lastInstr successor)
            ]
                (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, JavaConstant/INT_0)))
                this
            )
        )
    )

    ;;;
     ; @param type the type being instantiated
     ;;
    (defn #_"void" BytecodeParser''handleUnresolvedNewInstance-2 [#_"BytecodeParser" this, #_"JavaType" type]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param type the type of the array being instantiated
     ; @param length the length of the array
     ;;
    (defn #_"void" BytecodeParser''handleUnresolvedNewObjectArray-3 [#_"BytecodeParser" this, #_"JavaType" type, #_"ValueNode" length]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param field the unresolved field
     ; @param receiver the object containing the field or nil if {@code field} is static
     ;;
    (defn #_"void" BytecodeParser''handleUnresolvedLoadField-3 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" receiver]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param field the unresolved field
     ; @param value the value being stored to the field
     ; @param receiver the object containing the field or nil if {@code field} is static
     ;;
    (defn #_"void" BytecodeParser''handleUnresolvedStoreField-4 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" value, #_"ValueNode" receiver]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    (defn #_"void" BytecodeParser''handleUnresolvedInvoke-3 [#_"BytecodeParser" this, #_"JavaMethod" javaMethod, #_"InvokeKind" invokeKind]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    (defn #_"void" BytecodeParser''genStoreIndexed-5 [#_"BytecodeParser" this, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" kind, #_"ValueNode" value]
        (BytecodeParser''add-2 this, (StoreIndexedNode'new-4 array, index, kind, value))
        nil
    )

    (defn #_"void" BytecodeParser''genGoto-1 [#_"BytecodeParser" this]
        (BytecodeParser''appendGoto-2 this, (BciBlock''getSuccessor-2 (:currentBlock this), 0))
        nil
    )

    (defn #_"ValueNode" BytecodeParser''genUnique-2v [#_"BytecodeParser" this, #_"ValueNode" x] (Graph''addOrUniqueWithInputs-2 (:graph this), x))
    (defn #_"LogicNode" BytecodeParser''genUnique-2l [#_"BytecodeParser" this, #_"LogicNode" x] (Graph''addOrUniqueWithInputs-2 (:graph this), x))

    (defn #_"ValueNode" BytecodeParser''genLoadField-3 [#_"BytecodeParser" this, #_"ValueNode" receiver, #_"ResolvedJavaField" field]
        (let [
            #_"Stamp" stamp (Plugins''getOverridingStamp-4 HotSpot'plugins, this, (#_"ResolvedJavaField" .getType field), false)
        ]
            (if (some? stamp)
                (LoadFieldNode'createOverrideStamp-5 stamp, receiver, field, false, false)
                (LoadFieldNode'create-4 receiver, field, false, false)
            )
        )
    )

    (defn #_"void" BytecodeParser''genStoreField-4 [#_"BytecodeParser" this, #_"ValueNode" receiver, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (let [
            #_"StoreFieldNode" storeFieldNode (StoreFieldNode'new-3 receiver, field, value)
        ]
            (BytecodeParser''append-2 this, storeFieldNode)
            (StateSplit'''setStateAfter-2 storeFieldNode, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), storeFieldNode))
        )
        nil
    )

    ;;;
     ; Ensure that concrete classes are at least linked before generating an invoke. Interfaces may
     ; never be linked so simply return true for them.
     ;
     ; @return true if the declared holder is an interface or is linked
     ;;
    (defn- #_"boolean" BytecodeParser'callTargetIsResolved-1 [#_"JavaMethod" target]
        (and (instance? ResolvedJavaMethod target)
            (let [
                #_"ResolvedJavaType" type (#_"ResolvedJavaMethod" .getDeclaringClass target)
            ]
                (or (#_"ResolvedJavaType" .isInterface type) (#_"ResolvedJavaType" .isLinked type))
            )
        )
    )

    (defn- #_"void" BytecodeParser''maybeEagerlyResolve-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" bytecode]
        (if (some? (:intrinsicContext this))
            (#_"ConstantPool" .loadReferencedType (:constantPool this), cpi, bytecode)
            ;; Since we're potentially triggering class initialization here, we need synchronization
            ;; to mitigate the potential for class initialization related deadlock being caused by
            ;; the compiler (e.g. https://github.com/graalvm/graal-core/pull/232/files#r90788550).
            (locking BytecodeParser'iface
                (#_"ConstantPool" .loadReferencedType (:constantPool this), cpi, bytecode)
            )
        )
        nil
    )

    (defn- #_"JavaType" BytecodeParser''lookupType-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" bytecode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, bytecode)
        (#_"ConstantPool" .lookupType (:constantPool this), cpi, bytecode)
    )

    (defn- #_"JavaMethod" BytecodeParser''lookupMethod-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, opcode)
        (#_"ConstantPool" .lookupMethod (:constantPool this), cpi, opcode)
    )

    (defn- #_"void" BytecodeParser'initialize-1 [#_"ResolvedJavaType" resolvedType]
        ;; Since we're potentially triggering class initialization here, we need synchronization
        ;; to mitigate the potential for class initialization related deadlock being caused by
        ;; the compiler (e.g. https://github.com/graalvm/graal-core/pull/232/files#r90788550).
        (locking BytecodeParser'iface
            (#_"ResolvedJavaType" .initialize resolvedType)
        )
        nil
    )

    (defn- #_"JavaField" BytecodeParser''lookupField-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, opcode)
        (let [
            #_"JavaField" result (#_"ConstantPool" .lookupField (:constantPool this), cpi, (:method this), opcode)
        ]
            (when (instance? ResolvedJavaField result)
                (let [
                    #_"ResolvedJavaType" declaringClass (#_"ResolvedJavaField" .getDeclaringClass result)
                ]
                    (when-not (#_"ResolvedJavaType" .isInitialized declaringClass)
                        ;; even with eager initialization, superinterfaces are not always initialized (see StaticInterfaceFieldTest)
                        (BytecodeParser'initialize-1 declaringClass)
                    )
                )
            )
            result
        )
    )

    (defn- #_"Object" BytecodeParser''lookupConstant-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, opcode)
        (#_"ConstantPool" .lookupConstant (:constantPool this), cpi)
    )

    (defn #_"void" BytecodeParser''genInvokeStatic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeStatic-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeStatic-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (if (and (BytecodeParser'callTargetIsResolved-1 target) (or (#_"ResolvedJavaType" .isInitialized (#_"ResolvedJavaMethod" .getDeclaringClass target)) (not GraalOptions'resolveClassBeforeStaticInvoke)))
            (let [
                #_"InvokeNode" invoke (BytecodeParser''appendInvoke-4 this, InvokeKind'Static, target, (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature target), false)))
            ]
                (when (some? invoke)
                    (ยง ass! invoke (InvokeNode''setClassInit-2 invoke, nil))
                )
            )
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Static)
        )
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeInterface-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeInterface-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeInterface-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (if (BytecodeParser'callTargetIsResolved-1 target)
            (BytecodeParser''appendInvoke-4 this, InvokeKind'Interface, target, (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"JavaMethod" .getSignature target), true)))
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Interface)
        )
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeDynamic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeDynamic-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (defn- #_"boolean" BytecodeParser''genDynamicInvokeHelper-4 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" target, #_"int" cpi, #_"int" opcode]
        (let [
            #_"JavaConstant" appendix (#_"ConstantPool" .lookupAppendix (:constantPool this), cpi, opcode)
        ]
            (when (some? appendix)
                (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (ConstantNode'forConstant-2c appendix, (:graph this))))
            )

            (let [
                #_"boolean" hasReceiver (and (not= opcode Bytecodes'INVOKEDYNAMIC) (not (#_"ResolvedJavaMethod" .isStatic target)))
                #_"ValueNode[]" args (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature target), hasReceiver))
            ]
                (BytecodeParser''appendInvoke-4 this, (if hasReceiver InvokeKind'Virtual InvokeKind'Static), target, args)

                true
            )
        )
    )

    (defn #_"void" BytecodeParser''genInvokeDynamic-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (when-not (and (instance? ResolvedJavaMethod target) (BytecodeParser''genDynamicInvokeHelper-4 this, target, (BytecodeStream''readCPI4-1 (:stream this)), Bytecodes'INVOKEDYNAMIC))
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Static)
        )
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeVirtual-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeVirtual-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (defn- #_"boolean" BytecodeParser''genInvokeVirtualHelper-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (and (BytecodeParser'callTargetIsResolved-1 target)
            (let [
                #_"int" cpi (BytecodeStream''readCPI-1 (:stream this))
            ]
                (or (BytecodeParser''genDynamicInvokeHelper-4 this, target, cpi, Bytecodes'INVOKEVIRTUAL)
                    (let [
                        #_"ValueNode[]" args (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"JavaMethod" .getSignature target), true))
                    ]
                        (BytecodeParser''appendInvoke-4 this, InvokeKind'Virtual, target, args)
                        true
                    )
                )
            )
        )
    )

    (defn #_"void" BytecodeParser''genInvokeVirtual-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (when-not (BytecodeParser''genInvokeVirtualHelper-2 this, target)
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Virtual)
        )
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeSpecial-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeSpecial-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (defn #_"void" BytecodeParser''genInvokeSpecial-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (if (BytecodeParser'callTargetIsResolved-1 target)
            (BytecodeParser''appendInvoke-4 this, InvokeKind'Special, target, (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"JavaMethod" .getSignature target), true)))
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Special)
        )
        nil
    )

    ;;;
     ; Gets the kind of invocation currently being parsed.
     ;;
    (defn #_"InvokeKind" BytecodeParser''getInvokeKind-1 [#_"BytecodeParser" this]
        (when (some? (:currentInvoke this)) (:kind (:currentInvoke this)))
    )

    ;;;
     ; Gets the return type of the invocation currently being parsed.
     ;;
    (defn #_"JavaType" BytecodeParser''getInvokeReturnType-1 [#_"BytecodeParser" this]
        (when (some? (:currentInvoke this)) (:returnType (:currentInvoke this)))
    )

    (defn- #_"boolean" BytecodeParser''tryNodePluginForInvocation-3 [#_"BytecodeParser" this, #_"ValueNode[]" args, #_"ResolvedJavaMethod" targetMethod]
        (loop [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))]
            (and (some? s)
                (or (NodePlugin'''handleInvoke-4 (first s), this, targetMethod, args)
                    (recur (next s))
                )
            )
        )
    )

    ;;;
     ; Gets the receiver value with optional nil-check.
     ;;
    (defn- #_"ValueNode" BytecodeParser''getReceiver-3 [#_"BytecodeParser" this, #_"ValueNode[]" args, #_"boolean" nil-check?]
        (when nil-check? => (nth args 0)
            (let [
                #_"ValueNode" value (BytecodeParser''nullCheckedValue-2 this, (nth args 0))
            ]
                (when-not (= value (nth args 0))
                    (ยง aset! args 0 value)
                )
                value
            )
        )
    )

    (defn- #_"void" BytecodeParser''genGetField-3r [#_"BytecodeParser" this, #_"ResolvedJavaField" resolvedField, #_"ValueNode" receiver]
        (or
            (loop-when [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))] (some? s)
                (when (NodePlugin'''handleLoadField-4 (first s), this, receiver, resolvedField) => (recur (next s))
                    :done
                )
            )
            (let [
                #_"ValueNode" fieldRead (BytecodeParser''append-2 this, (BytecodeParser''genLoadField-3 this, receiver, resolvedField))
            ]
                (when (and (= (#_"ResolvedJavaType" .getName (#_"ResolvedJavaField" .getDeclaringClass resolvedField)) "Ljava/lang/ref/Reference;") (= (#_"ResolvedJavaField" .getName resolvedField) "referent"))
                    (BytecodeParser''append-2 this, (MembarNode'new-2 0, (FieldLocationIdentity'new-1 resolvedField)))
                )
                (let [
                    #_"JavaKind" fieldKind (#_"ResolvedJavaField" .getJavaKind resolvedField)
                ]
                    (if (and (#_"ResolvedJavaField" .isVolatile resolvedField) (satisfies? LoadFieldNode fieldRead))
                        (let [
                            #_"StateSplitProxyNode" readProxy (BytecodeParser''append-2 this, (StateSplitProxyNode'new-1 fieldRead))
                        ]
                            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), fieldKind, readProxy))
                            (StateSplit'''setStateAfter-2 readProxy, (FrameStateBuilder''create-3 (:frameState this), (:nextBCI (:stream this)), readProxy))
                        )
                        (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), fieldKind, fieldRead))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genGetField-3f [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" receiver]
        (when (instance? ResolvedJavaField field) => (BytecodeParser''handleUnresolvedLoadField-3 this, field, receiver)
            (BytecodeParser''genGetField-3r this, field, receiver)
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genGetField-4 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode, #_"ValueNode" receiver]
        (BytecodeParser''genGetField-3f this, (BytecodeParser''lookupField-3 this, cpi, opcode), receiver)
        nil
    )

    (defn- #_"void" BytecodeParser''genGetField-3i [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genGetField-4 this, cpi, opcode, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object))
        nil
    )

    (def- #_"int" BytecodeParser'ACCESSOR_BYTECODE_LENGTH 5)

    ;;;
     ; Tries to inline {@code targetMethod} if it is an instance field accessor. This avoids the
     ; overhead of creating and using a nested BytecodeParser object.
     ;;
    (defn- #_"boolean" BytecodeParser''tryFastInlineAccessor-3 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" args]
        (let [
            #_"byte[]" bytecode (#_"ResolvedJavaMethod" .getCode targetMethod)
        ]
            (and (some? bytecode) (= (count bytecode) BytecodeParser'ACCESSOR_BYTECODE_LENGTH) (= (Bytes'beU1-2 bytecode, 0) Bytecodes'ALOAD_0) (= (Bytes'beU1-2 bytecode, 1) Bytecodes'GETFIELD)
                (let [
                    #_"int" b4 (Bytes'beU1-2 bytecode, 4)
                ]
                    (and (<= Bytecodes'IRETURN b4 Bytecodes'ARETURN)
                        (let [
                            #_"int" cpi (Bytes'beU2-2 bytecode, 2)
                            #_"JavaField" field (#_"ConstantPool" .lookupField (#_"ResolvedJavaMethod" .getConstantPool targetMethod), cpi, targetMethod, Bytecodes'GETFIELD)
                        ]
                            (and (instance? ResolvedJavaField field)
                                (do
                                    (BytecodeParser''genGetField-3r this, field, (BytecodeParser''getReceiver-3 this, args, true))
                                    (BytecodeParser'notifyBeforeInline-1 targetMethod)
                                    (BytecodeParser'notifyAfterInline-1 targetMethod)
                                    true
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"boolean" BytecodeParser''inline-5 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaMethod" inlinedMethod, #_"BytecodeProvider" intrinsicBytecodeProvider, #_"ValueNode[]" args]
        (let [
            #_"IntrinsicContext" intrinsic (:intrinsicContext this)
        ]
            (or (and (nil? intrinsic) (= targetMethod inlinedMethod) (zero? (& (#_"ResolvedJavaMethod" .getModifiers targetMethod) (| Modifier/STATIC Modifier/SYNCHRONIZED))) (BytecodeParser''tryFastInlineAccessor-3 this, targetMethod, args))
                (if (and (some? intrinsic) (IntrinsicContext''isCallToOriginal-2 intrinsic, targetMethod))
                    (if (IntrinsicContext''isCompilationRoot-1 intrinsic)
                        (do
                            ;; A root compiled intrinsic needs to deoptimize if the slow path is taken. During frame state
                            ;; assignment, the deopt node will get its stateBefore from the start node of the intrinsic.
                            (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/RuntimeConstraint))
                            true
                        )
                        (and (not (#_"ResolvedJavaMethod" .isNative (:originalMethod intrinsic))) GraalOptions'inlinePartialIntrinsicExitDuringParsing
                            (do
                                ;; Otherwise inline the original method. Any frame state created during the inlining
                                ;; will exclude frame(s) in the intrinsic method (see FrameStateBuilder.create(int bci)).
                                (BytecodeParser'notifyBeforeInline-1 inlinedMethod)
                                (ยง ass! this (BytecodeParser''parseAndInlineCallee-4 this, (:originalMethod intrinsic), args, nil))
                                (BytecodeParser'notifyAfterInline-1 inlinedMethod)
                                true
                            )
                        )
                    )
                    (let [
                        intrinsic
                            (when (and (nil? intrinsic) (some? intrinsicBytecodeProvider)) => intrinsic
                                (IntrinsicContext'new-4 targetMethod, inlinedMethod, intrinsicBytecodeProvider, CompilationContext'INLINE_DURING_PARSING)
                            )
                    ]
                        (and (#_"ResolvedJavaMethod" .hasBytecodes inlinedMethod)
                            (do
                                (BytecodeParser'notifyBeforeInline-1 inlinedMethod)
                                (ยง ass! this (BytecodeParser''parseAndInlineCallee-4 this, inlinedMethod, args, intrinsic))
                                (BytecodeParser'notifyAfterInline-1 inlinedMethod)
                                true
                            )
                        )
                    )
                )
            )
        )
    )

    (def- #_"InlineInvokeInfo" BytecodeParser'SUCCESSFULLY_INLINED (ยง soon InlineInvokeInfo'createStandardInlineInfo-1 nil))

    ;;;
     ; Try to inline a method. If the method was inlined, returns #SUCCESSFULLY_INLINED.
     ; Otherwise, it returns the InlineInvokeInfo that lead to the decision to not inline it,
     ; or nil if there is no InlineInvokeInfo for this method.
     ;;
    (defn- #_"InlineInvokeInfo" BytecodeParser''tryInline-3 [#_"BytecodeParser" this, #_"ValueNode[]" args, #_"ResolvedJavaMethod" targetMethod]
        (when (or (BytecodeParser''parsingIntrinsic-1 this) (#_"ResolvedJavaMethod" .canBeInlined targetMethod))
            (loop [#_"ISeq" s (seq (:inlineInvokePlugins HotSpot'plugins))]
                (if (some? s)
                    (let [
                        #_"InlineInvokeInfo" inlineInfo (InlineInvokePlugin'''shouldInlineInvoke-4 (first s), this, targetMethod, args)
                    ]
                        (when (some? inlineInfo) => (recur (next s))
                            (when (some? (:methodToInline inlineInfo)) => inlineInfo ;; do not inline, and do not ask the remaining plugins
                                (when (BytecodeParser''inline-5 this, targetMethod, (:methodToInline inlineInfo), (:intrinsicBytecodeProvider inlineInfo), args)
                                    BytecodeParser'SUCCESSFULLY_INLINED
                                )
                            )
                        )
                    )
                    ;; There was no inline plugin with a definite answer to whether or not to inline.
                    ;; If we're parsing an intrinsic, then we need to enforce the invariant here
                    ;; that methods are always force inlined in intrinsics/snippets.
                    (when (and (BytecodeParser''parsingIntrinsic-1 this) (BytecodeParser''inline-5 this, targetMethod, targetMethod, (:bytecodeProvider this), args))
                        BytecodeParser'SUCCESSFULLY_INLINED
                    )
                )
            )
        )
    )

    (defn #_"InvokeNode" BytecodeParser''appendInvoke-4 [#_"BytecodeParser" this, #_"InvokeKind" initialInvokeKind, #_"ResolvedJavaMethod" initialTargetMethod, #_"ValueNode[]" args]
        (let [
            [#_"ResolvedJavaMethod" targetMethod #_"InvokeKind" invokeKind]
                (when (InvokeKind''isIndirect-1 initialInvokeKind) => [initialTargetMethod initialInvokeKind]
                    (let [
                        #_"ResolvedJavaType" contextType (#_"ResolvedJavaMethod" .getDeclaringClass (FrameStateBuilder''getMethod-1 (:frameState this)))
                        #_"ResolvedJavaMethod" specialCallTarget (MethodCallTargetNode'findSpecialCallTarget-4 initialInvokeKind, (nth args 0), initialTargetMethod, contextType)
                    ]
                        (when (some? specialCallTarget) => [initialTargetMethod initialInvokeKind]
                            [specialCallTarget InvokeKind'Special]
                        )
                    )
                )
            #_"JavaKind" resultType (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature targetMethod))
            #_"JavaType" returnType (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature targetMethod), (#_"ResolvedJavaMethod" .getDeclaringClass (:method this)))
            returnType (#_"JavaType" .resolve returnType, (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod))
        ]
            (when (and (= initialInvokeKind InvokeKind'Special) (not (#_"ResolvedJavaMethod" .isConstructor targetMethod)))
                (BytecodeParser''emitCheckForInvokeSuperSpecial-2 this, args)
            )
            (try
                (ยง ass! this (assoc this :currentInvoke (CurrentInvoke'new-3 args, invokeKind, returnType)))
                (when (BytecodeParser''tryNodePluginForInvocation-3 this, args, targetMethod)
                    (ยง return nil)
                )

                (when (and (InvokeKind''hasReceiver-1 invokeKind) (ValueNode''isNullConstant-1 (nth args 0)))
                    (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/NullCheckException))
                    (ยง return nil)
                )

                (when (and (:direct invokeKind) (= (BytecodeParser''tryInline-3 this, args, targetMethod) BytecodeParser'SUCCESSFULLY_INLINED))
                    (ยง return nil)
                )
                (finally
                    (ยง ass! this (assoc this :currentInvoke nil))
                )
            )

            (let [
                #_"int" invokeBci (BytecodeParser''bci-1 this)
                #_"boolean" partialIntrinsicExit
                    (when (and (some? (:intrinsicContext this)) (IntrinsicContext''isCallToOriginal-2 (:intrinsicContext this), targetMethod)) => false
                        (let [
                            #_"ResolvedJavaMethod" originalMethod (:originalMethod (:intrinsicContext this))
                            #_"BytecodeParser" intrinsicCallSiteParser (BytecodeParser''getNonIntrinsicAncestor-1 this)
                        ]
                            (if (some? intrinsicCallSiteParser)
                                (do
                                    ;; When exiting a partial intrinsic, the invoke to the original
                                    ;; must use the same context as the call to the intrinsic.
                                    (ยง ass invokeBci (BytecodeParser''bci-1 intrinsicCallSiteParser))
                                )
                                (do
                                    ;; We are parsing the intrinsic for the root compilation or for inlining.
                                    ;; This call is a partial intrinsic exit, and we do not have profile information
                                    ;; for this callsite. We also have to assume that the call needs an exception
                                    ;; edge. Finally, we know that this intrinsic is parsed for late inlining,
                                    ;; so the bci must be set to unknown, so that the inliner patches it later.
                                    (ยง ass invokeBci BytecodeFrame/UNKNOWN_BCI)
                                )
                            )

                            (if (#_"ResolvedJavaMethod" .isStatic originalMethod)
                                (ยง ass invokeKind InvokeKind'Static)
                                ;; The original call to the intrinsic must have been devirtualized,
                                ;; otherwise we wouldn't be here.
                                (ยง ass invokeKind InvokeKind'Special)
                            )
                            (let [
                                #_"Signature" sig (#_"ResolvedJavaMethod" .getSignature originalMethod)
                            ]
                                (ยง ass returnType (#_"Signature" .getReturnType sig, (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))))
                                (ยง ass resultType (#_"Signature" .getReturnKind sig))
                                (ยง ass targetMethod originalMethod)
                                true
                            )
                        )
                    )
                #_"InvokeNode" invoke (BytecodeParser''createNonInlinedInvoke-7 this, invokeBci, args, targetMethod, invokeKind, resultType, returnType)
            ]
                (when partialIntrinsicExit => invoke
                    ;; This invoke must never be later inlined as it might select the intrinsic graph.
                    ;; Until there is a mechanism to guarantee that any late inlining will not select
                    ;; the intrinsic graph, prevent this invoke from being inlined.
                    (InvokeNode''setUseForInlining-2 invoke, false)
                )
            )
        )
    )

    ;;;
     ; Checks that the class of the receiver of an Bytecodes#INVOKESPECIAL in a method
     ; declared in an interface (i.e. a default method) is assignable to the interface.
     ; If not, then deoptimize so that the interpreter can throw an IllegalAccessError.
     ;
     ; This is a check not performed by the verifier and so must be performed at runtime.
     ;
     ; @param args arguments to an Bytecodes#INVOKESPECIAL implementing a direct call to a method in a super class
     ;;
    (defn #_"void" BytecodeParser''emitCheckForInvokeSuperSpecial-2 [#_"BytecodeParser" this, #_"ValueNode[]" args]
        (let [
            #_"ResolvedJavaType" callingClass (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))
            callingClass
                (when (some? (#_"ResolvedJavaType" .getHostClass callingClass)) => callingClass
                    (#_"ResolvedJavaType" .getHostClass callingClass)
                )
        ]
            (when (#_"ResolvedJavaType" .isInterface callingClass)
                (let [
                    #_"ValueNode" receiver (nth args 0)
                    #_"TypeReference" checkedType (TypeReference'createTrusted-1 callingClass)
                    #_"LogicNode" logic (BytecodeParser''genUnique-2l this, (InstanceOfNode'create-2 checkedType, receiver))
                    #_"FixedGuardNode" fixedGuard (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/ClassCastException, DeoptimizationAction/None, false))
                ]
                    (aset args 0 (BytecodeParser''append-2 this, (PiNode'create-3 receiver, (StampFactory'object-2 checkedType, true), fixedGuard)))
                )
            )
        )
        nil
    )

    (defn #_"InvokeNode" BytecodeParser''createNonInlinedInvoke-7 [#_"BytecodeParser" this, #_"int" invokeBci, #_"ValueNode*" invokeArgs, #_"ResolvedJavaMethod" targetMethod, #_"InvokeKind" invokeKind, #_"JavaKind" resultType, #_"JavaType" returnType]
        (let [
            #_"Stamp" returnStamp
                (or (Plugins''getOverridingStamp-4 HotSpot'plugins, this, returnType, false)
                    (StampFactory'forDeclaredType-2 returnType, false)
                )
            #_"MethodCallTargetNode" callTarget (Graph''add-2 (:graph this), (MethodCallTargetNode'new-4 invokeKind, targetMethod, invokeArgs, returnStamp))
            #_"InvokeNode" invoke (BytecodeParser''createInvoke-4 this, invokeBci, callTarget, resultType)
        ]
            (doseq [#_"InlineInvokePlugin" plugin (:inlineInvokePlugins HotSpot'plugins)]
                (InlineInvokePlugin'''notifyNotInlined-4 plugin, this, targetMethod, invoke)
            )

            invoke
        )
    )

    (defn #_"void" BytecodeParser'notifyBeforeInline-1 [#_"ResolvedJavaMethod" inlinedMethod]
        (doseq [#_"InlineInvokePlugin" plugin (:inlineInvokePlugins HotSpot'plugins)]
            (InlineInvokePlugin'''notifyBeforeInline-2 plugin, inlinedMethod)
        )
        nil
    )

    (defn #_"void" BytecodeParser'notifyAfterInline-1 [#_"ResolvedJavaMethod" inlinedMethod]
        (doseq [#_"InlineInvokePlugin" plugin (:inlineInvokePlugins HotSpot'plugins)]
            (InlineInvokePlugin'''notifyAfterInline-2 plugin, inlinedMethod)
        )
        nil
    )

    (defn #_"BytecodeParser" BytecodeParser''parseAndInlineCallee-4 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" args, #_"IntrinsicContext" calleeIntrinsicContext]
        (try (ยง with [#_"IntrinsicScope" s (when (and (some? calleeIntrinsicContext) (not (BytecodeParser''parsingIntrinsic-1 this))) (IntrinsicScope'new-3 this, (#_"Signature" .toParameterKinds (#_"ResolvedJavaMethod" .getSignature targetMethod), (not (#_"ResolvedJavaMethod" .isStatic targetMethod))), args))])
            (let [
                #_"BytecodeParser" parser (BytecodeParser'new-5 (:graphBuilderInstance this), (:graph this), this, targetMethod, calleeIntrinsicContext)
                #_"FrameStateBuilder" startFrameState (FrameStateBuilder'new-3c parser, (:code parser), (:graph this))
            ]
                (when-not (#_"ResolvedJavaMethod" .isStatic targetMethod)
                    (aset args 0 (BytecodeParser''nullCheckedValue-2 this, (nth args 0)))
                )
                (FrameStateBuilder''initializeFromArgumentsArray-2 startFrameState, args)
                (let [
                    parser (BytecodeParser''build-3 parser, (:lastInstr this), startFrameState)
                    this
                        (when (some? (:returnDataList parser)) => (assoc this :lastInstr nil) ;; Callee does not return.
                            (let [s (ร )
                                _
                                    (when (some? s)
                                        (ยง ass! s (assoc s :returnDataList (:returnDataList parser)))
                                    )
                                [this #_"MergeNode" merge #_"ValueNode" calleeReturnValue]
                                    (if (= (count (:returnDataList parser)) 1)
                                        ;; Callee has a single return, we can continue parsing at that point.
                                        (let [
                                            #_"ReturnToCallerData" singleReturnData (nth (:returnDataList parser) 0)
                                            this (assoc this :lastInstr (:beforeReturnNode singleReturnData))
                                        ]
                                            [this nil (:returnValue singleReturnData)]
                                        )
                                        ;; Callee has multiple returns, we need to insert a control flow merge.
                                        (let [
                                            merge (Graph''add-2 (:graph this), (MergeNode'new-0))
                                            calleeReturnValue (ValueMergeUtil'mergeValueProducers-4 merge, (:returnDataList parser), (ร (returnData)  (ยง fun (:beforeReturnNode returnData))), (ร (returnData)  (ยง fun (:returnValue returnData))))
                                        ]
                                            [this merge calleeReturnValue]
                                        )
                                    )
                            ]
                                (when (some? calleeReturnValue)
                                    (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (-> (#_"ResolvedJavaMethod" .getSignature targetMethod) (#_"Signature" .getReturnKind) (#_"JavaKind" .getStackKind)), calleeReturnValue))
                                )
                                (when (some? merge) => this
                                    (StateSplit'''setStateAfter-2 merge, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), merge))
                                    (assoc this :lastInstr merge)
                                )
                            )
                        )
                ]
                    ;; Propagate any side effects into the caller when parsing intrinsics.
                    (when (and (SideEffectsState'''isAfterSideEffect-1 (:frameState parser)) (BytecodeParser''parsingIntrinsic-1 this))
                        (doseq [#_"StateSplit" sideEffect (SideEffectsState'''sideEffects-1 (:frameState parser))]
                            (SideEffectsState'''addSideEffect-2 (:frameState this), sideEffect)
                        )
                    )
                    this
                )
            )
        )
    )

    (defn #_"InvokeNode" BytecodeParser''createInvoke-4 [#_"BytecodeParser" this, #_"int" invokeBci, #_"CallTargetNode" callTarget, #_"JavaKind" resultType]
        (let [
            #_"InvokeNode" invoke (BytecodeParser''append-2 this, (InvokeNode'new-2 callTarget, invokeBci))
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''pushReturn-3 (:frameState this), resultType, invoke))
            (StateSplit'''setStateAfter-2 invoke, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), invoke))
            invoke
        )
    )

    (defn- #_"ValueNode" BytecodeParser''processReturnValue-3 [#_"BytecodeParser" this, #_"ValueNode" value, #_"JavaKind" kind]
        (let [
            #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature (:method this)))
        ]
            (when-not (= kind returnKind) => value
                ;; sub-word integer
                (let [
                    #_"IntegerStamp" stamp (:stamp value)
                ]
                    ;; the bytecode verifier doesn't check that the value is in the correct range
                    (when (or (< (:lowerBound stamp) (#_"JavaKind" .getMinValue returnKind)) (< (#_"JavaKind" .getMaxValue returnKind) (:upperBound stamp))) => value
                        (let [
                            #_"ValueNode" narrow (BytecodeParser''append-2 this, (NarrowNode'create-2 value, (#_"JavaKind" .getBitCount returnKind)))
                        ]
                            (if (#_"JavaKind" .isUnsigned returnKind)
                                (BytecodeParser''append-2 this, (ZeroExtendNode'create-2 narrow, 32))
                                (BytecodeParser''append-2 this, (SignExtendNode'create-2 narrow, 32))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" BytecodeParser''synchronizedEpilogue-4 [#_"BytecodeParser" this, #_"int" bci, #_"ValueNode" currentReturnValue, #_"JavaKind" currentReturnValueKind]
        (when (#_"ResolvedJavaMethod" .isSynchronized (:method this))
            (when (some? currentReturnValue)
                (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), currentReturnValueKind, currentReturnValue))
            )
            (BytecodeParser''genMonitorExit-4 this, (:methodSynchronizedObject this), currentReturnValue, bci)
        )
        (when-not (zero? (FrameStateBuilder''lockDepth-2 (:frameState this), false))
            (throw! "unbalanced monitors: too few exits exiting frame")
        )
        nil
    )

    (defn- #_"void" BytecodeParser''beforeReturn-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"JavaKind" kind]
        (when (:finalBarrierRequired this)
            (BytecodeParser''append-2 this, (FinalFieldBarrierNode'new-1 (:originalReceiver this)))
        )
        (BytecodeParser''synchronizedEpilogue-4 this, BytecodeFrame/AFTER_BCI, x, kind)
        nil
    )

    (defn #_"BytecodeParser" BytecodeParser''genReturn-3 [#_"BytecodeParser" this, #_"ValueNode" returnVal, #_"JavaKind" returnKind]
        (when (and (BytecodeParser''parsingIntrinsic-1 this) (satisfies? StateSplit returnVal) (StateSplit'''hasSideEffect-1 returnVal))
            (let [
                #_"FrameState" stateAfter (:stateAfter returnVal)
            ]
                (when (= (:bci stateAfter) BytecodeFrame/AFTER_BCI) ;; => must be the return value from within a partial intrinsification
                    (let [
                        stateAfter (Node''replaceAtUsages-2 stateAfter, (Graph''add-2 (:graph this), (FrameState'new-2 BytecodeFrame/AFTER_BCI, returnVal)))
                    ]
                        (GraphUtil'killWithUnusedFloatingInputs-1 stateAfter)
                    )
                )
            )
        )
        (let [
            #_"ValueNode" realReturnVal (BytecodeParser''processReturnValue-3 this, returnVal, returnKind)
            _ (ยง ass! (:frameState this) (FrameStateBuilder''clearStack-1 (:frameState this)))
        ]
            (BytecodeParser''beforeReturn-3 this, realReturnVal, returnKind)
            (if (some? (:parent this))
                (let [
                    this
                        (when (nil? (:returnDataList this)) => this
                            (assoc this :returnDataList (ArrayList.))
                        )
                ]
                    (#_"ArrayList" .add (:returnDataList this), (ReturnToCallerData'new-2 realReturnVal, (:lastInstr this)))
                    (assoc this :lastInstr nil)
                )
                (do
                    (BytecodeParser''append-2 this, (ReturnNode'new-1 realReturnVal))
                    this
                )
            )
        )
    )

    (defn #_"void" BytecodeParser''genMonitorEnter-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"int" bci]
        (let [
            #_"MonitorIdNode" monitorId (Graph''add-2 (:graph this), (MonitorIdNode'new-1 (FrameStateBuilder''lockDepth-2 (:frameState this), true)))
            #_"MonitorEnterNode" monitorEnter (BytecodeParser''append-2 this, (MonitorEnterNode'new-2 x, monitorId))
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''pushLock-3 (:frameState this), x, monitorId))
            (StateSplit'''setStateAfter-2 monitorEnter, (BytecodeParser''createFrameState-3 this, bci, monitorEnter))
        )
        nil
    )

    (defn #_"void" BytecodeParser''genMonitorExit-4 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" escapedReturnValue, #_"int" bci]
        (when (zero? (FrameStateBuilder''lockDepth-2 (:frameState this), false))
            (throw! "unbalanced monitors: too many exits")
        )
        (let [
            #_"MonitorIdNode" monitorId (FrameStateBuilder''peekMonitorId-1 (:frameState this))
            #_"ValueNode" lockedObject (FrameStateBuilder''popLock-1 (:frameState this))
        ]
            (when-not (= (GraphUtil'originalValue-1 lockedObject) (GraphUtil'originalValue-1 x))
                (throw! (str "unbalanced monitors: mismatch at monitorexit, " (GraphUtil'originalValue-1 x) " != " (GraphUtil'originalValue-1 lockedObject)))
            )
            (let [
                #_"MonitorExitNode" monitorExit (BytecodeParser''append-2 this, (MonitorExitNode'new-3 lockedObject, monitorId, escapedReturnValue))
            ]
                (StateSplit'''setStateAfter-2 monitorExit, (BytecodeParser''createFrameState-3 this, bci, monitorExit))
            )
        )
        nil
    )

    (defn- #_"ConstantNode" BytecodeParser''getJsrConstant-2 [#_"BytecodeParser" this, #_"long" bci]
        (let [
            #_"JavaConstant" nextBciConstant (RawConstant. bci)
        ]
            (Graph''add-2 (:graph this), (ConstantNode'new-2 nextBciConstant, (StampFactory'forPrimitiveConstant-1 nextBciConstant)))
        )
    )

    (defn #_"void" BytecodeParser''genJsr-2 [#_"BytecodeParser" this, #_"int" dest]
        (let [
            #_"BciBlock" successor (BciBlock''getJsrSuccessor-1 (:currentBlock this))
            #_"JsrScope" scope (BciBlock''getJsrScope-1 (:currentBlock this))
            #_"int" nextBci (:nextBCI (:stream this))
        ]
            (when-not (= (JsrScope''pop-1 (BciBlock''getJsrScope-1 successor)) scope)
                (throw! "unstructured control flow (internal limitation)")
            )
            (when-not (= (JsrScope''nextReturnAddress-1 (BciBlock''getJsrScope-1 successor)) nextBci)
                (throw! "unstructured control flow (internal limitation)")
            )
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''getJsrConstant-2 this, nextBci)))
            (BytecodeParser''appendGoto-2 this, successor)
        )
        nil
    )

    (defn #_"void" BytecodeParser''genRet-2 [#_"BytecodeParser" this, #_"int" localIndex]
        (let [
            #_"BciBlock" successor (BciBlock''getRetSuccessor-1 (:currentBlock this))
            #_"ValueNode" local (FrameStateBuilder''loadLocal-3 (:frameState this), localIndex, JavaKind/Object)
            #_"JsrScope" scope (BciBlock''getJsrScope-1 (:currentBlock this))
            #_"int" retAddress (JsrScope''nextReturnAddress-1 scope)
            #_"ConstantNode" returnBciNode (BytecodeParser''getJsrConstant-2 this, retAddress)
            #_"LogicNode" guard (Graph''addOrUniqueWithInputs-2 (:graph this), (IntegerEqualsNode'create-3 nil, local, returnBciNode))
        ]
            (BytecodeParser''append-2 this, (FixedGuardNode'new-3 guard, DeoptimizationReason/JavaSubroutineMismatch, DeoptimizationAction/InvalidateReprofile))
            (when (= (BciBlock''getJsrScope-1 successor) (JsrScope''pop-1 scope)) => (throw! "unstructured control flow (ret leaves more than one scope)")
                (BytecodeParser''appendGoto-2 this, successor)
            )
        )
        nil
    )

    ;;;
     ; Helper function that sums up the probabilities of all keys that lead to a specific successor.
     ;
     ; @return an array of size successorCount with the accumulated probability for each successor
     ;;
    (defn- #_"double[]" BytecodeParser'successorProbabilites-3 [#_"int" successorCount, #_"int*" keySuccessors, #_"double*" keyProbabilities]
        (let [
            #_"double[]" probability (double-array successorCount)
        ]
            (dotimes [#_"int" i (count keySuccessors)]
                (aswap probability (nth keySuccessors i) + (nth keyProbabilities i))
            )
            probability
        )
    )

    (defn #_"BytecodeParser" BytecodeParser''genIntegerSwitch-6 [#_"BytecodeParser" this, #_"ValueNode" value, #_"ArrayList<BciBlock>" actualSuccessors, #_"int[]" keys, #_"double[]" keyProbabilities, #_"int[]" keySuccessors]
        (if (satisfies? ConstantNode value)
            (let [
                #_"int" constantValue (#_"JavaConstant" .asInt (:value value))
            ]
                (loop-when [#_"int" i 0] (< i (count keys)) => (BytecodeParser''appendGoto-2 this, (nth actualSuccessors (nth keySuccessors i)))
                    (if (= (nth keys i) constantValue)
                        (BytecodeParser''appendGoto-2 this, (nth actualSuccessors (nth keySuccessors i)))
                        (recur (inc i))
                    )
                )
                this
            )
            (let [
                this (assoc this :controlFlowSplit true)
                #_"double[]" successorProbabilities (BytecodeParser'successorProbabilites-3 (count actualSuccessors), keySuccessors, keyProbabilities)
                #_"IntegerSwitchNode" switchNode (BytecodeParser''append-2 this, (IntegerSwitchNode'new-5i value, (count actualSuccessors), keys, keyProbabilities, keySuccessors))
            ]
                (dotimes [#_"int" i (count actualSuccessors)]
                    (SwitchNode''setBlockSuccessor-3 switchNode, i, (BytecodeParser''createBlockTarget-4 this, (nth successorProbabilities i), (nth actualSuccessors i), (:frameState this)))
                )
                this
            )
        )
    )

    (defn #_"ConstantNode" BytecodeParser''appendConstant-2 [#_"BytecodeParser" this, #_"JavaConstant" constant]
        (ConstantNode'forConstant-2c constant, (:graph this))
    )

    (defn- #_"BytecodeParser" BytecodeParser''updateLastInstruction-2 [#_"BytecodeParser" this, #_"ValueNode" node]
        (when (satisfies? FixedNode node) => this
            (let [
                _ (ยง ass! (:lastInstr this) (FixedWithNextNode''setNext-2 (:lastInstr this), node))
            ]
                (assoc this :lastInstr (when (satisfies? FixedWithNextNode node) node))
            )
        )
    )

    ;;;
     ; Adds the given node to the graph and also adds recursively all referenced inputs.
     ;
     ; @param node the node to be added to the graph
     ; @return either the node added or an equivalent node
     ;;
    (defn #_"ValueNode" BytecodeParser''append-2 [#_"BytecodeParser" this, #_"ValueNode" node]
        (if (some? (:graph node))
            node
            (let [
                #_"ValueNode" added (Graph''addOrUniqueWithInputs-2 (:graph this), node)
            ]
                (when (= added node)
                    (ยง ass! this (BytecodeParser''updateLastInstruction-2 this, node))
                )
                added
            )
        )
    )

    (defn- #_"void" BytecodeParser''setMergeStateAfter-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FixedWithNextNode" firstInstruction]
        (when (nil? (:stateAfter firstInstruction))
            (StateSplit'''setStateAfter-2 firstInstruction, (BytecodeParser''createFrameState-3 this, (:startBci block), firstInstruction))
        )
        nil
    )

    (defn #_"BytecodeParser" BytecodeParser''processBlock-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        ;; ignore blocks that have no predecessors by the time their bytecodes are parsed
        (let [
            #_"FixedWithNextNode" firstInstruction (BytecodeParser''getFirstInstruction-2 this, block)
        ]
            (when (some? firstInstruction) => this
                (let [
                    this (assoc this :lastInstr firstInstruction)
                    this (assoc this :frameState (BytecodeParser''getEntryState-2 this, block))
                    this (BytecodeParser''setCurrentFrameState-2 this, (:frameState this))
                    this (assoc this :currentBlock block)
                ]
                    (when (satisfies? AbstractMergeNode firstInstruction)
                        (BytecodeParser''setMergeStateAfter-3 this, block, firstInstruction)
                    )
                    (BytecodeParser''iterateBytecodesForBlock-2 this, block)
                )
            )
        )
    )

    (defn- #_"LoopBeginNode" BytecodeParser''appendLoopBegin-3 [#_"BytecodeParser" this, #_"FixedWithNextNode" fixedWithNext, #_"int" startBci]
        (let [
            #_"EndNode" preLoopEnd (Graph''add-2 (:graph this), (EndNode'new-0))
            #_"LoopBeginNode" loopBegin (Graph''add-2 (:graph this), (LoopBeginNode'new-0))
            loopBegin
                (when (BytecodeParser''parsingIntrinsic-1 this) => loopBegin
                    (LoopBeginNode''disableSafepoint-1 loopBegin)
                )
        ]
            (ยง ass! fixedWithNext (FixedWithNextNode''setNext-2 fixedWithNext, preLoopEnd))
            ;; Add the single non-loop predecessor of the loop header.
            (AbstractMergeNode''addForwardEnd-2 loopBegin, preLoopEnd)
            loopBegin
        )
    )

    (defn #_"BytecodeParser" BytecodeParser''iterateBytecodesForBlock-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (let [
            this
                (if (:isLoopHeader block)
                    ;; Create the loop header block, which later will merge the backward branches of the loop.
                    (let [
                        this (assoc this :controlFlowSplit true)
                        #_"LoopBeginNode" loopBegin (BytecodeParser''appendLoopBegin-3 this, (:lastInstr this), (:startBci block))
                        this (assoc this :lastInstr loopBegin)
                    ]
                        ;; Create phi functions for all local variables and operand stack slots.
                        (FrameStateBuilder''insertLoopPhis-6 (:frameState this), (:liveness this), (:loopId block), loopBegin, false, false)
                        (StateSplit'''setStateAfter-2 loopBegin, (BytecodeParser''createFrameState-3 this, (:startBci block), loopBegin))
                        ;; We have seen all forward branches. All subsequent backward branches will merge to the
                        ;; loop header. This ensures that the loop header has exactly one non-loop predecessor.
                        (BytecodeParser''setFirstInstruction-3 this, block, loopBegin)
                        ;; We need to preserve the frame state builder of the loop header so that we can merge
                        ;; values for phi functions, so make a copy of it.
                        (BytecodeParser''setEntryState-3 this, block, (FrameStateBuilder'copy-1 (:frameState this)))
                        this
                    )
                    (when (satisfies? MergeNode (:lastInstr this)) => this
                        ;; All inputs of non-loop phi nodes are known by now. We can infer the stamp
                        ;; for the phi, so that parsing continues with more precise type information.
                        (FrameStateBuilder''inferPhiStamps-2 (:frameState this), (:lastInstr this))
                        this
                    )
                )
            #_"int" endBCI (BytecodeStream''endBCI-1 (:stream this))
            _ (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        ]
            (loop-when [this this #_"int" bci (:startBci block)] (< bci endBCI) => this
                (let [
                    this (BytecodeParser''processBytecode-3 this, bci, (BytecodeStream''currentBC-1 (:stream this)))
                ]
                    (when (and (some? (:lastInstr this)) (nil? (:next (:lastInstr this)))) => this
                        (let [
                            _ (ยง ass! (:stream this) (BytecodeStream''next-1 (:stream this)))
                            bci (:curBCI (:stream this))
                        ]
                            (when (< (:endBci block) bci endBCI) => (recur this bci)
                                ;; we fell through to the next block, add a goto and break
                                (BytecodeParser''appendGoto-2 this, (BciBlock''getSuccessor-2 block, 0))
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"LogicNode" BytecodeParser'createLogicNode-3 [#_"CanonicalCondition" condition, #_"ValueNode" a, #_"ValueNode" b]
        (condp = condition
            CanonicalCondition'EQ
                (if (= (ValueNode''getStackKind-1 a) JavaKind/Object)
                    (ObjectEqualsNode'createCanonical-2 a, b)
                    (IntegerEqualsNode'create-3 nil, a, b)
                )
            CanonicalCondition'LT
                (IntegerLessThanNode'create-3 nil, a, b)
        )
    )

    (defn- #_"double" BytecodeParser'getProfileProbability-1 [#_"boolean" negate?]
        0.5
    )

    (defn- #_"double" BytecodeParser''clampProbability-2 [#_"BytecodeParser" this, #_"double" probability]
        (when-not (OptimisticOptimizations''removeNeverExecutedCode-1 (:optimisticOpts this)) => probability
            (case probability 0.0 0.0000001 1.0 0.999999 probability)
        )
    )

    (defn #_"BytecodeParser" BytecodeParser''genIf-4 [#_"BytecodeParser" this, #_"ValueNode" x, #_"Condition" condition, #_"ValueNode" y]
        (let [
            #_"BciBlock" then (BciBlock''getSuccessor-2 (:currentBlock this), 0)
            #_"BciBlock" else (BciBlock''getSuccessor-2 (:currentBlock this), 1)
        ]
            (when-not (= then else) => (do (BytecodeParser''appendGoto-2 this, then) this)
                (let [
                    #_"CanonicalizedCondition" canon (Condition''canonicalize-1 condition)
                    [x y] (if (:mirror? canon) [y x] [x y])
                    #_"LogicNode" logic (BytecodeParser'createLogicNode-3 (:canonicalCondition canon), x, y)
                    [then else] (if (:negate? canon) [else then] [then else])
                    #_"double" probability (BytecodeParser'getProfileProbability-1 (:negate? canon))
                    probability (BytecodeParser''clampProbability-2 this, probability)
                ]
                    (BytecodeParser''genIf-5 this, logic, then, else, probability)
                )
            )
        )
    )

    (defn- #_"void" BytecodeParser''genConstantTargetIf-4 [#_"BytecodeParser" this, #_"BciBlock" trueBlock, #_"BciBlock" falseBlock, #_"LogicNode" logic]
        (let [
            #_"BciBlock" nextBlock (if (:value logic) trueBlock falseBlock)
            #_"int" targetAtStart (BytecodeStream''readUByte-2 (:stream this), (:startBci nextBlock))
        ]
            ;; If this is an empty block, skip it.
            (BytecodeParser''appendGoto-2 this, (if (and (= targetAtStart Bytecodes'GOTO) (= (:predecessorCount nextBlock) 1)) (nth (:successors nextBlock) 0) nextBlock))
        )
        nil
    )

    (defn- #_"int" BytecodeParser''checkPositiveIntConstantPushed-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        (let [
            #_"int" currentBC (BytecodeStream''currentBC-1 (:stream this))
        ]
            (if (<= Bytecodes'ICONST_0 currentBC Bytecodes'ICONST_5) (- currentBC Bytecodes'ICONST_0) -1)
        )
    )

    (defn- #_"BytecodeParser" BytecodeParser''genConditionalForIf-7 [#_"BytecodeParser" this, #_"BciBlock" trueBlock, #_"LogicNode" logic, #_"int" oldBci, #_"int" trueBlockInt, #_"int" falseBlockInt, #_"boolean" genReturn]
        (let [
            #_"ConstantNode" trueValue (Graph''add-2 (:graph this), (ConstantNode'forInt-1 trueBlockInt))
            #_"ConstantNode" falseValue (Graph''add-2 (:graph this), (ConstantNode'forInt-1 falseBlockInt))
            #_"ValueNode" conditionalNode (ConditionalNode'create-3 logic, trueValue, falseValue)
            conditionalNode
                (when (nil? (:graph conditionalNode)) => conditionalNode
                    (Graph''addOrUniqueWithInputs-2 (:graph this), conditionalNode)
                )
        ]
            (if genReturn
                (BytecodeParser''genReturn-3 this, conditionalNode, (#_"JavaKind" .getStackKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature (:method this)))))
                (do
                    (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, conditionalNode))
                    (BytecodeParser''appendGoto-2 this, (BciBlock''getSuccessor-2 trueBlock, 0))
                    (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), oldBci))
                    this
                )
            )
        )
    )

    (defn- #_"boolean" BytecodeParser''gotoOrFallThroughAfterConstant-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:nextBCI (:stream this))))
        (or (< (:endBci block) (:curBCI (:stream this))) (any = (BytecodeStream''currentBC-1 (:stream this)) Bytecodes'GOTO Bytecodes'GOTO_W))
    )

    (defn- #_"boolean" BytecodeParser''returnAfterConstant-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        (ยง ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:nextBCI (:stream this))))
        (= (BytecodeStream''currentBC-1 (:stream this)) Bytecodes'IRETURN)
    )

    (defn- #_"boolean" BytecodeParser''tryGenConditionalForIf-7 [#_"BytecodeParser" this, #_"BciBlock" trueBlock, #_"BciBlock" falseBlock, #_"LogicNode" logic, #_"int" oldBci, #_"int" trueBlockInt, #_"int" falseBlockInt]
        (cond
            (and (BytecodeParser''gotoOrFallThroughAfterConstant-2 this, trueBlock) (BytecodeParser''gotoOrFallThroughAfterConstant-2 this, falseBlock) (= (BciBlock''getSuccessor-2 trueBlock, 0) (BciBlock''getSuccessor-2 falseBlock, 0)))
            (do
                (ยง ass! this (BytecodeParser''genConditionalForIf-7 this, trueBlock, logic, oldBci, trueBlockInt, falseBlockInt, false))
                true
            )
            (and (some? (:parent this)) (BytecodeParser''returnAfterConstant-2 this, trueBlock) (BytecodeParser''returnAfterConstant-2 this, falseBlock))
            (do
                (ยง ass! this (BytecodeParser''genConditionalForIf-7 this, trueBlock, logic, oldBci, trueBlockInt, falseBlockInt, true))
                true
            )
            :else
                false
        )
    )

    (defn #_"BytecodeParser" BytecodeParser''genIf-5 [#_"BytecodeParser" this, #_"LogicNode" logic, #_"BciBlock" trueBlock, #_"BciBlock" falseBlock, #_"double" probability]
        ;; Remove a logic negation node.
        (let [
            [logic trueBlock falseBlock probability]
                (when (satisfies? LogicNegationNode logic) => [logic trueBlock falseBlock probability]
                    [(Unary'''getValue-1 logic) falseBlock trueBlock (- 1.0 probability)]
                )
        ]
            (when-not (satisfies? LogicConstantNode logic) => (do (BytecodeParser''genConstantTargetIf-4 this, trueBlock, falseBlock, logic) this)
                (let [
                    logic (if (nil? (:graph logic)) (BytecodeParser''genUnique-2l this, logic) logic)
                ]
                    (cond
                        (BytecodeParser''isNeverExecutedCode-2 this, probability)
                            (do
                                (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/UnreachedCode, DeoptimizationAction/InvalidateReprofile, true))
                                (BytecodeParser''appendGoto-2 this, falseBlock)
                                this
                            )
                        (BytecodeParser''isNeverExecutedCode-2 this, (- 1.0 probability))
                            (do
                                (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/UnreachedCode, DeoptimizationAction/InvalidateReprofile, false))
                                (BytecodeParser''appendGoto-2 this, trueBlock)
                                this
                            )
                        :else
                            (let [
                                #_"int" oldBci (:curBCI (:stream this))
                                #_"int" trueBlockInt (BytecodeParser''checkPositiveIntConstantPushed-2 this, trueBlock)
                            ]
                                (when-not (= trueBlockInt -1)
                                    (let [
                                        #_"int" falseBlockInt (BytecodeParser''checkPositiveIntConstantPushed-2 this, falseBlock)
                                    ]
                                        (when-not (= falseBlockInt -1)
                                            (when (BytecodeParser''tryGenConditionalForIf-7 this, trueBlock, falseBlock, logic, oldBci, trueBlockInt, falseBlockInt)
                                                (ยง return this)
                                            )
                                        )
                                    )
                                )
                                (let [
                                    this (assoc this :controlFlowSplit true)
                                    #_"FixedNode" trueSuccessor (BytecodeParser''createTarget-5 this, trueBlock, (:frameState this), false, false)
                                    #_"FixedNode" falseSuccessor (BytecodeParser''createTarget-5 this, falseBlock, (:frameState this), false, true)
                                ]
                                    (BytecodeParser''append-2 this, (IfNode'new-4f logic, trueSuccessor, falseSuccessor, probability))
                                    this
                                )
                            )
                    )
                )
            )
        )
    )

    ;;;
     ; Pushes a given value to the frame state stack using an explicit kind. This should be used
     ; when {@code value.getJavaKind()} is different from the kind that the bytecode instruction
     ; currently being parsed pushes to the stack.
     ;
     ; @param kind the kind to use when type checking this operation
     ; @param value the value to push to the stack. The value must already have been
     ;            {@linkplain #append(ValueNode) appended}.
     ;;
    (defn #_"void" BytecodeParser''push-3 [#_"BytecodeParser" this, #_"JavaKind" slotKind, #_"ValueNode" value]
        (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), slotKind, value))
        nil
    )

    ;;;
     ; Creates a snap shot of the current frame state with the BCI of the instruction after the one currently
     ; being parsed and assigns it to a given {@linkplain StateSplit#hasSideEffect() side effect} node.
     ;
     ; @param sideEffect a side effect node just appended to the graph
     ;;
    (defn #_"void" BytecodeParser''setStateAfter-2 [#_"BytecodeParser" this, #_"StateSplit" sideEffect]
        (StateSplit'''setStateAfter-2 sideEffect, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), sideEffect))
        nil
    )

    (defn #_"BytecodeParser" BytecodeParser''setCurrentFrameState-2 [#_"BytecodeParser" this, #_"FrameStateBuilder" frameState]
        (assoc this :frameState frameState)
    )

    ;;;
     ; Gets the index of the bytecode instruction currently being parsed.
     ;;
    (defn #_"int" BytecodeParser''bci-1 [#_"BytecodeParser" this]
        (:curBCI (:stream this))
    )

    (defn #_"void" BytecodeParser''loadLocal-3 [#_"BytecodeParser" this, #_"int" index, #_"JavaKind" kind]
        (let [
            #_"ValueNode" value (FrameStateBuilder''loadLocal-3 (:frameState this), index, kind)
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, value))
        )
        nil
    )

    (defn #_"void" BytecodeParser''loadLocalObject-2 [#_"BytecodeParser" this, #_"int" index]
        (let [
            #_"ValueNode" value (FrameStateBuilder''loadLocal-3 (:frameState this), index, JavaKind/Object)
            #_"int" nextBCI (:nextBCI (:stream this))
            #_"int" nextBC (BytecodeStream''readUByte-2 (:stream this), nextBCI)
        ]
            (if (and (<= nextBCI (:endBci (:currentBlock this))) (= nextBC Bytecodes'GETFIELD))
                (do
                    (ยง ass! (:stream this) (BytecodeStream''next-1 (:stream this)))
                    (BytecodeParser''genGetField-4 this, (BytecodeStream''readCPI-1 (:stream this)), Bytecodes'GETFIELD, value)
                )
                (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, value))
            )
        )
        nil
    )

    (defn #_"void" BytecodeParser''storeLocal-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" index]
        (let [
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (FrameStateBuilder''storeLocal-4 (:frameState this), index, kind, value)
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genLoadConstant-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (let [
            #_"Object" constant (BytecodeParser''lookupConstant-3 this, cpi, opcode)
        ]
            (condp instance? constant
                JavaType ;; this is a load of class constant which might be unresolved
                    (if (instance? ResolvedJavaType constant)
                        (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''appendConstant-2 this, (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, constant))))
                        (BytecodeParser''handleUnresolvedLoadConstant-2 this, constant)
                    )
                JavaConstant
                    (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (#_"JavaConstant" .getJavaKind constant), (BytecodeParser''appendConstant-2 this, constant)))
            )
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genLoadIndexed-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" index (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"ValueNode" array (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (loop [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))]
                (if (some? s)
                    (when-not (NodePlugin'''handleLoadIndexed-5 (first s), this, array, index, kind)
                        (recur (next s))
                    )
                    (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, (LoadIndexedNode'create-3 array, index, kind))))
                )
            )
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genStoreIndexed-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" index (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"ValueNode" array (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (loop [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))]
                (if (some? s)
                    (when-not (NodePlugin'''handleStoreIndexed-6 (first s), this, array, index, kind, value)
                        (recur (next s))
                    )
                    (BytecodeParser''genStoreIndexed-5 this, array, index, kind, value)
                )
            )
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genArithmeticOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'IADD Bytecodes'LADD] (AddNode'create-2 x, y)
                    [Bytecodes'ISUB Bytecodes'LSUB] (SubNode'create-2 x, y)
                    [Bytecodes'IMUL Bytecodes'LMUL] (MulNode'create-2 x, y)
                )
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genIntegerDivOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'IDIV Bytecodes'LDIV] (SignedDivNode'create-2 x, y)
                    [Bytecodes'IREM Bytecodes'LREM] (SignedRemNode'create-2 x, y)
                )
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genNegateOp-2k [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, (NegateNode'create-1 x))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genShiftOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" s (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'ISHL  Bytecodes'LSHL ] (LeftShiftNode'create-2 x, s)
                    [Bytecodes'ISHR  Bytecodes'LSHR ] (RightShiftNode'create-2 x, s)
                    [Bytecodes'IUSHR Bytecodes'LUSHR] (UnsignedRightShiftNode'create-2 x, s)
                )
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genLogicOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'IAND Bytecodes'LAND] (AndNode'create-2 x, y)
                    [Bytecodes'IOR  Bytecodes'LOR ] (OrNode'create-2 x, y)
                    [Bytecodes'IXOR Bytecodes'LXOR] (XorNode'create-2 x, y)
                )
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genCompareOp-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''append-2 this, (NormalizeCompareNode'create-3 x, y, JavaKind/Int))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genSignExtend-3k [#_"BytecodeParser" this, #_"JavaKind" from, #_"JavaKind" to]
        (let [
            #_"ValueNode" input (FrameStateBuilder''pop-2 (:frameState this), from)
        ]
            (when-not (= from (#_"JavaKind" .getStackKind from))
                (ยง ass input (BytecodeParser''append-2 this, (NarrowNode'create-2 input, (#_"JavaKind" .getBitCount from))))
            )
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), to, (BytecodeParser''append-2 this, (SignExtendNode'create-2 input, (#_"JavaKind" .getBitCount to)))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genZeroExtend-3k [#_"BytecodeParser" this, #_"JavaKind" from, #_"JavaKind" to]
        (let [
            #_"ValueNode" input (FrameStateBuilder''pop-2 (:frameState this), from)
        ]
            (when-not (= from (#_"JavaKind" .getStackKind from))
                (ยง ass input (BytecodeParser''append-2 this, (NarrowNode'create-2 input, (#_"JavaKind" .getBitCount from))))
            )
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), to, (BytecodeParser''append-2 this, (ZeroExtendNode'create-2 input, (#_"JavaKind" .getBitCount to)))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genNarrow-3k [#_"BytecodeParser" this, #_"JavaKind" from, #_"JavaKind" to]
        (let [
            #_"ValueNode" input (FrameStateBuilder''pop-2 (:frameState this), from)
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), to, (BytecodeParser''append-2 this, (NarrowNode'create-2 input, (#_"JavaKind" .getBitCount to)))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genIncrement-1 [#_"BytecodeParser" this]
        (let [
            #_"int" index (BytecodeStream''readLocalIndex-1 (:stream this))
            #_"int" delta (BytecodeStream''readIncrement-1 (:stream this))
            #_"ValueNode" x (FrameStateBuilder''loadLocal-3 (:frameState this), index, JavaKind/Int)
            #_"ValueNode" y (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt delta))
        ]
            (FrameStateBuilder''storeLocal-4 (:frameState this), index, JavaKind/Int, (BytecodeParser''append-2 this, (AddNode'create-2 x, y)))
        )
        nil
    )

    (defn- #_"BytecodeParser" BytecodeParser''genIfZero-2 [#_"BytecodeParser" this, #_"Condition" cond]
        (let [
            #_"ValueNode" y (BytecodeParser''appendConstant-2 this, JavaConstant/INT_0)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
        ]
            (BytecodeParser''genIf-4 this, x, cond, y)
        )
    )

    (defn- #_"BytecodeParser" BytecodeParser''genIfNull-2 [#_"BytecodeParser" this, #_"Condition" cond]
        (let [
            #_"ValueNode" y (BytecodeParser''appendConstant-2 this, JavaConstant/NULL_POINTER)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (BytecodeParser''genIf-4 this, x, cond, y)
        )
    )

    (defn- #_"BytecodeParser" BytecodeParser''genIfSame-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"Condition" cond]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (BytecodeParser''genIf-4 this, x, cond, y)
        )
    )

    (defn- #_"void" BytecodeParser''genCheckCast-1 [#_"BytecodeParser" this]
        (let [
            #_"int" cpi (BytecodeStream''readCPI-1 (:stream this))
            #_"JavaType" type (BytecodeParser''lookupType-3 this, cpi, Bytecodes'CHECKCAST)
            #_"ValueNode" object (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (when (instance? ResolvedJavaType type) => (BytecodeParser''handleUnresolvedCheckCast-3 this, type, object)
                (let [
                    #_"TypeReference" checkedType (TypeReference'createTrusted-1 type)
                ]
                    (loop [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))]
                        (if (some? s)
                            (when-not (NodePlugin'''handleCheckCast-4 (first s), this, object, (:type checkedType))
                                (recur (next s))
                            )
                            (let [
                                #_"ValueNode" castNode
                                    (let [
                                        #_"LogicNode" logic (BytecodeParser''genUnique-2l this, (InstanceOfNode'createAllowNull-2 checkedType, object))
                                    ]
                                        (if (LogicNode''isTautology-1 logic)
                                            object
                                            (BytecodeParser''append-2 this, (PiNode'create-3 object, (StampFactory'object-2 checkedType, (:never-nil? (:stamp object))), (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/ClassCastException, DeoptimizationAction/InvalidateReprofile, false))))
                                        )
                                    )
                            ]
                                (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, castNode))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"BytecodeParser" BytecodeParser''genInstanceOf-1 [#_"BytecodeParser" this]
        (let [
            #_"int" cpi (BytecodeStream''readCPI-1 (:stream this))
            #_"JavaType" type (BytecodeParser''lookupType-3 this, cpi, Bytecodes'INSTANCEOF)
            #_"ValueNode" object (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (when (instance? ResolvedJavaType type) => (BytecodeParser''handleUnresolvedInstanceOf-3 this, type, object)
                (let [
                    #_"TypeReference" resolvedType (TypeReference'createTrusted-1 type)
                ]
                    (loop [this this #_"ISeq" s (seq (:nodePlugins HotSpot'plugins))]
                        (if (some? s)
                            (when-not (NodePlugin'''handleInstanceOf-4 (first s), this, object, (:type resolvedType)) => this
                                (recur this (next s))
                            )
                            (let [
                                #_"LogicNode" instanceOfNode (InstanceOfNode'create-2 resolvedType, object)
                                #_"LogicNode" logic (BytecodeParser''genUnique-2l this, instanceOfNode)
                                #_"int" _next (:nextBCI (:stream this))
                                #_"int" value (BytecodeStream''readUByte-2 (:stream this), _next)
                            ]
                                (if (and (<= _next (:endBci (:currentBlock this))) (any = value Bytecodes'IFEQ Bytecodes'IFNE))
                                    (let [
                                        _ (ยง ass! (:stream this) (BytecodeStream''next-1 (:stream this)))
                                        #_"BciBlock" succ1 (BciBlock''getSuccessor-2 (:currentBlock this), 0)
                                        #_"BciBlock" succ2 (BciBlock''getSuccessor-2 (:currentBlock this), 1)
                                    ]
                                        (if (= succ1 succ2)
                                            (do
                                                (BytecodeParser''appendGoto-2 this, succ1)
                                                this
                                            )
                                            (let [
                                                #_"boolean" negate? (not= value Bytecodes'IFNE)
                                                [succ1 succ2] (if negate? [succ2 succ1] [succ1 succ2])
                                            ]
                                                (BytecodeParser''genIf-5 this, instanceOfNode, succ1, succ2, (BytecodeParser'getProfileProbability-1 negate?))
                                            )
                                        )
                                    )
                                    ;; Most frequent for value is IRETURN, followed by ISTORE.
                                    (do
                                        (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''append-2 this, (ConditionalNode'create-1 (ยง cast #_"LogicNode" logic)))))
                                        this
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" BytecodeParser''genNewInstance-2t [#_"BytecodeParser" this, #_"JavaType" type]
        (when (and (instance? ResolvedJavaType type) (#_"ResolvedJavaType" .isInitialized type)) => (BytecodeParser''handleUnresolvedNewInstance-2 this, type)
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''append-2 this, (NewInstanceNode'new-1 type))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genNewInstance-2i [#_"BytecodeParser" this, #_"int" cpi]
        (BytecodeParser''genNewInstance-2t this, (BytecodeParser''lookupType-3 this, cpi, Bytecodes'NEW))
        nil
    )

    ;;;
     ; Gets the kind of array elements for the array type code that appears in a Bytecodes#NEWARRAY bytecode.
     ;
     ; @param code the array type code
     ; @return the kind from the array type code
     ;;
    (defn- #_"Class" BytecodeParser'arrayTypeCodeToClass-1 [#_"int" code]
        (case code
             4 boolean'class
             5 char'class
             6 float'class
             7 double'class
             8 byte'class
             9 short'class
            10 int'class
            11 long'class
        )
    )

    (defn- #_"void" BytecodeParser''genNewPrimitiveArray-2 [#_"BytecodeParser" this, #_"int" typeCode]
        (let [
            #_"ResolvedJavaType" elementType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (BytecodeParser'arrayTypeCodeToClass-1 typeCode))
            #_"ValueNode" length (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
        ]
            (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''append-2 this, (NewArrayNode'new-2 elementType, length))))
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genNewObjectArray-2 [#_"BytecodeParser" this, #_"int" cpi]
        (let [
            #_"JavaType" type (BytecodeParser''lookupType-3 this, cpi, Bytecodes'ANEWARRAY)
            #_"ValueNode" length (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
        ]
            (when (instance? ResolvedJavaType type) => (BytecodeParser''handleUnresolvedNewObjectArray-3 this, type, length)
                (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''append-2 this, (NewArrayNode'new-2 type, length))))
            )
        )
        nil
    )

    (defn- #_"this" BytecodeParser''genPutField-3f [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" value]
        (let [
            #_"ValueNode" receiver (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (when (instance? ResolvedJavaField field) => (BytecodeParser''handleUnresolvedStoreField-4 this, field, value, receiver)
                (or
                    (loop-when [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))] (some? s)
                        (when (NodePlugin'''handleStoreField-5 (first s), this, receiver, field, value) => (recur (next s))
                            :done
                        )
                    )
                    (do
                        (when (and (#_"ResolvedJavaField" .isFinal field) (#_"ResolvedJavaMethod" .isConstructor (:method this)))
                            (ยง ass! this (assoc this :finalBarrierRequired true))
                        )
                        (BytecodeParser''genStoreField-4 this, receiver, field, value)
                    )
                )
            )
        )
        this
    )

    (defn- #_"BytecodeParser" BytecodeParser''genPutField-2 [#_"BytecodeParser" this, #_"JavaField" field]
        (BytecodeParser''genPutField-3f this, field, (FrameStateBuilder''pop-2 (:frameState this), (#_"JavaField" .getJavaKind field)))
    )

    (defn- #_"BytecodeParser" BytecodeParser''genPutField-3i [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genPutField-2 this, (BytecodeParser''lookupField-3 this, cpi, opcode))
    )

    (defn- #_"ResolvedJavaField" BytecodeParser''resolveStaticFieldAccess-3 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" value]
        (when (instance? ResolvedJavaField field)
            (when (#_"ResolvedJavaType" .isInitialized (#_"ResolvedJavaField" .getDeclaringClass field))
                (ยง return field)
            )
            ;; Static fields have initialization semantics but may be safely accessed under certain
            ;; conditions while the class is being initialized. Executing in the clinit or init of
            ;; classes which are subtypes of the field holder are sure to be running in a context
            ;; where the access is safe.
            (when (and (#_"ResolvedJavaType" .isAssignableFrom (#_"ResolvedJavaField" .getDeclaringClass field), (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))) (or (#_"ResolvedJavaMethod" .isClassInitializer (:method this)) (#_"ResolvedJavaMethod" .isConstructor (:method this))))
                (ยง return field)
            )
        )
        (if (nil? value)
            (BytecodeParser''handleUnresolvedLoadField-3 this, field, nil)
            (BytecodeParser''handleUnresolvedStoreField-4 this, field, value, nil)
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genGetStatic-2 [#_"BytecodeParser" this, #_"JavaField" field]
        (let [
            #_"ResolvedJavaField" resolvedField (BytecodeParser''resolveStaticFieldAccess-3 this, field, nil)
        ]
            (when (some? resolvedField)
                (or
                    ;; Javac does not allow the use of "$assertionsDisabled" for a field name as Eclipse does.
                    ;; In this case a suffix is added to the generated field.
                    (when (and (#_"ResolvedJavaField" .isSynthetic resolvedField) (#_"String" .startsWith (#_"ResolvedJavaField" .getName resolvedField), "$assertionsDisabled"))
                        (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (#_"JavaField" .getJavaKind field), (ConstantNode'forBoolean-2 true, (:graph this))))
                        :done
                    )
                    (loop-when [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))] (some? s)
                        (when (NodePlugin'''handleLoadStaticField-3 (first s), this, resolvedField) => (recur (next s))
                            :done
                        )
                    )
                    (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (#_"JavaField" .getJavaKind field), (BytecodeParser''append-2 this, (BytecodeParser''genLoadField-3 this, nil, resolvedField))))
                )
            )
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genGetStatic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genGetStatic-2 this, (BytecodeParser''lookupField-3 this, cpi, opcode))
        nil
    )

    (defn- #_"void" BytecodeParser''genPutStatic-2 [#_"BytecodeParser" this, #_"JavaField" field]
        (let [
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), (#_"JavaField" .getJavaKind field))
            #_"ResolvedJavaField" resolvedField (BytecodeParser''resolveStaticFieldAccess-3 this, field, value)
        ]
            (when (some? resolvedField)
                (or
                    (loop-when [#_"ISeq" s (seq (:nodePlugins HotSpot'plugins))] (some? s)
                        (when (NodePlugin'''handleStoreStaticField-4 (first s), this, resolvedField, value) => (recur (next s))
                            :done
                        )
                    )
                    (BytecodeParser''genStoreField-4 this, nil, resolvedField, value)
                )
            )
        )
        nil
    )

    (defn- #_"void" BytecodeParser''genPutStatic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genPutStatic-2 this, (BytecodeParser''lookupField-3 this, cpi, opcode))
        nil
    )

    (defn- #_"double[]" BytecodeParser'switchProbability-2 [#_"int" numberOfCases, #_"int" bci]
        (let [
            #_"double[]" prob (double-array numberOfCases)
        ]
            (dotimes [#_"int" i numberOfCases]
                (aset prob i (/ 1.0 numberOfCases))
            )
            prob
        )
    )

    (defn- #_"BytecodeParser" BytecodeParser''genSwitch-2 [#_"BytecodeParser" this, #_"BytecodeSwitch" bs]
        (let [
            #_"int" bci (BytecodeParser''bci-1 this)
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"int" nofCases (BytecodeSwitch'''numberOfCases-1 bs)
            #_"int" nofCasesPlusDefault (inc nofCases)
            #_"double[]" keyProbabilities (BytecodeParser'switchProbability-2 nofCasesPlusDefault, bci)
            #_"EconomicMap<Integer, SuccessorInfo>" bciToBlockSuccessorIndex (EconomicMap/create)
            _
                (dotimes [#_"int" i (count (:successors (:currentBlock this)))]
                    (#_"EconomicMap" .put bciToBlockSuccessorIndex, (:startBci (BciBlock''getSuccessor-2 (:currentBlock this), i)), (SuccessorInfo'new-1 i))
                )
            #_"ArrayList<BciBlock>" actualSuccessors (ArrayList.)
            #_"int[]" keys (int-array nofCases)
            #_"int[]" keySuccessors (int-array nofCasesPlusDefault)
            [#_"int" deoptSuccessorIndex #_"int" nextSuccessorIndex]
                (loop-when [deoptSuccessorIndex -1 nextSuccessorIndex 0 #_"int" i 0] (< i nofCasesPlusDefault) => [deoptSuccessorIndex nextSuccessorIndex]
                    (when (< i nofCases)
                        (aset keys i (BytecodeSwitch'''keyAt-2 bs, i))
                    )
                    (let [
                        [deoptSuccessorIndex nextSuccessorIndex]
                            (if (and (not (satisfies? ConstantNode value)) (BytecodeParser''isNeverExecutedCode-2 this, (nth keyProbabilities i)))
                                (let [
                                    [deoptSuccessorIndex nextSuccessorIndex]
                                        (when (neg? deoptSuccessorIndex) => [deoptSuccessorIndex nextSuccessorIndex]
                                            (#_"ArrayList" .add actualSuccessors, nil)
                                            [nextSuccessorIndex (inc nextSuccessorIndex)]
                                        )
                                ]
                                    (aset keySuccessors i deoptSuccessorIndex)
                                    [deoptSuccessorIndex nextSuccessorIndex]
                                )
                                (let [
                                    #_"int" targetBci (if (< i nofCases) (BytecodeSwitch''targetAt-2 bs, i) (BytecodeSwitch''defaultTarget-1 bs))
                                    #_"SuccessorInfo" info (get bciToBlockSuccessorIndex targetBci)
                                    [info nextSuccessorIndex]
                                        (when (neg? (:actualIndex info)) => [info nextSuccessorIndex]
                                            (#_"ArrayList" .add actualSuccessors, (BciBlock''getSuccessor-2 (:currentBlock this), (:blockIndex info)))
                                            [(assoc info :actualIndex nextSuccessorIndex) (inc nextSuccessorIndex)]
                                        )
                                ]
                                    (aset keySuccessors i (:actualIndex info))
                                    [deoptSuccessorIndex nextSuccessorIndex]
                                )
                            )
                    ]
                        (recur deoptSuccessorIndex nextSuccessorIndex (inc i))
                    )
                )
        ]
            ;; When the profile indicates a case is never taken, the above code will cause the case to
            ;; deopt should it be subsequently encountered. However, the case may share code with
            ;; another case that is taken according to the profile.
            ;;
            ;; For example:
            ;;
            ;; switch (opcode) {
            ;;     case GOTO:
            ;;     case GOTO_W: {
            ;;         // emit goto code
            ;;         break;
            ;;     }
            ;; }
            ;;
            ;; The profile may indicate the GOTO_W case is never taken, and thus a deoptimization stub
            ;; will be emitted. There might be optimization opportunity if additional branching based
            ;; on opcode is within the case block. Specially, if there is only single case that reaches
            ;; a target, we have better chance cutting out unused branches. Otherwise, it might be
            ;; beneficial routing to the same code instead of deopting.
            ;;
            ;; The following code rewires deoptimization stub to existing resolved branch target if
            ;; the target is connected by more than 1 cases.
            (when (<= 0 deoptSuccessorIndex)
                (let [
                    #_"int[]" connectedCases (int-array nextSuccessorIndex)
                ]
                    (dotimes [#_"int" i nofCasesPlusDefault]
                        (aswap connectedCases (nth keySuccessors i) inc)
                    )

                    (dotimes [#_"int" i nofCasesPlusDefault]
                        (when (= (nth keySuccessors i) deoptSuccessorIndex)
                            (let [
                                #_"int" targetBci (if (< i nofCases) (BytecodeSwitch''targetAt-2 bs, i) (BytecodeSwitch''defaultTarget-1 bs))
                                #_"SuccessorInfo" info (get bciToBlockSuccessorIndex targetBci)
                                #_"int" rewiredIndex (:actualIndex info)
                            ]
                                (when (and (<= 0 rewiredIndex) (< 1 (nth connectedCases rewiredIndex)))
                                    (aset keySuccessors i (:actualIndex info))
                                )
                            )
                        )
                    )
                )
            )

            (BytecodeParser''genIntegerSwitch-6 this, value, actualSuccessors, keys, keyProbabilities, keySuccessors)
        )
    )

    (defn #_"boolean" BytecodeParser''isNeverExecutedCode-2 [#_"BytecodeParser" this, #_"double" probability]
        (and (zero? probability) (OptimisticOptimizations''removeNeverExecutedCode-1 (:optimisticOpts this)))
    )

    (defn #_"this" BytecodeParser''processBytecode-3 [#_"BytecodeParser" this, #_"int" bci, #_"int" opcode]
        (condp =? opcode
            Bytecodes'NOP             nil ;; nothing to do
            Bytecodes'ACONST_NULL     (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''appendConstant-2 this, JavaConstant/NULL_POINTER)))
           [Bytecodes'ICONST_M1
            Bytecodes'ICONST_0
            Bytecodes'ICONST_1
            Bytecodes'ICONST_2
            Bytecodes'ICONST_3
            Bytecodes'ICONST_4
            Bytecodes'ICONST_5]       (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt (- opcode Bytecodes'ICONST_0)))))
           [Bytecodes'LCONST_0
            Bytecodes'LCONST_1]       (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Long, (BytecodeParser''appendConstant-2 this, (JavaConstant/forLong (- opcode Bytecodes'LCONST_0)))))
            Bytecodes'BIPUSH          (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt (BytecodeStream''readByte-1 (:stream this))))))
            Bytecodes'SIPUSH          (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt (BytecodeStream''readShort-1 (:stream this))))))
           [Bytecodes'LDC
            Bytecodes'LDC_W
            Bytecodes'LDC2_W]         (BytecodeParser''genLoadConstant-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'ILOAD           (BytecodeParser''loadLocal-3 this, (BytecodeStream''readLocalIndex-1 (:stream this)), JavaKind/Int)
            Bytecodes'LLOAD           (BytecodeParser''loadLocal-3 this, (BytecodeStream''readLocalIndex-1 (:stream this)), JavaKind/Long)
            Bytecodes'ALOAD           (BytecodeParser''loadLocalObject-2 this, (BytecodeStream''readLocalIndex-1 (:stream this)))
           [Bytecodes'ILOAD_0
            Bytecodes'ILOAD_1
            Bytecodes'ILOAD_2
            Bytecodes'ILOAD_3]        (BytecodeParser''loadLocal-3 this, (- opcode Bytecodes'ILOAD_0), JavaKind/Int)
           [Bytecodes'LLOAD_0
            Bytecodes'LLOAD_1
            Bytecodes'LLOAD_2
            Bytecodes'LLOAD_3]        (BytecodeParser''loadLocal-3 this, (- opcode Bytecodes'LLOAD_0), JavaKind/Long)
           [Bytecodes'ALOAD_0
            Bytecodes'ALOAD_1
            Bytecodes'ALOAD_2
            Bytecodes'ALOAD_3]        (BytecodeParser''loadLocalObject-2 this, (- opcode Bytecodes'ALOAD_0))
            Bytecodes'IALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Int)
            Bytecodes'LALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Long)
            Bytecodes'AALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Object)
            Bytecodes'BALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Byte)
            Bytecodes'CALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Char)
            Bytecodes'SALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Short)
            Bytecodes'ISTORE          (BytecodeParser''storeLocal-3 this, JavaKind/Int, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'LSTORE          (BytecodeParser''storeLocal-3 this, JavaKind/Long, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'ASTORE          (BytecodeParser''storeLocal-3 this, JavaKind/Object, (BytecodeStream''readLocalIndex-1 (:stream this)))
           [Bytecodes'ISTORE_0
            Bytecodes'ISTORE_1
            Bytecodes'ISTORE_2
            Bytecodes'ISTORE_3]       (BytecodeParser''storeLocal-3 this, JavaKind/Int, (- opcode Bytecodes'ISTORE_0))
           [Bytecodes'LSTORE_0
            Bytecodes'LSTORE_1
            Bytecodes'LSTORE_2
            Bytecodes'LSTORE_3]       (BytecodeParser''storeLocal-3 this, JavaKind/Long, (- opcode Bytecodes'LSTORE_0))
           [Bytecodes'ASTORE_0
            Bytecodes'ASTORE_1
            Bytecodes'ASTORE_2
            Bytecodes'ASTORE_3]       (BytecodeParser''storeLocal-3 this, JavaKind/Object, (- opcode Bytecodes'ASTORE_0))
            Bytecodes'IASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Int)
            Bytecodes'LASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Long)
            Bytecodes'AASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Object)
            Bytecodes'BASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Byte)
            Bytecodes'CASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Char)
            Bytecodes'SASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Short)
           [Bytecodes'POP
            Bytecodes'POP2
            Bytecodes'DUP
            Bytecodes'DUP_X1
            Bytecodes'DUP_X2
            Bytecodes'DUP2
            Bytecodes'DUP2_X1
            Bytecodes'DUP2_X2
            Bytecodes'SWAP]           (ยง ass! (:frameState this) (FrameStateBuilder''stackOp-2 (:frameState this), opcode))
           [Bytecodes'IADD
            Bytecodes'ISUB
            Bytecodes'IMUL]           (BytecodeParser''genArithmeticOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'IDIV
            Bytecodes'IREM]           (BytecodeParser''genIntegerDivOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'LADD
            Bytecodes'LSUB
            Bytecodes'LMUL]           (BytecodeParser''genArithmeticOp-3 this, JavaKind/Long, opcode)
           [Bytecodes'LDIV
            Bytecodes'LREM]           (BytecodeParser''genIntegerDivOp-3 this, JavaKind/Long, opcode)
            Bytecodes'INEG            (BytecodeParser''genNegateOp-2k this, JavaKind/Int)
            Bytecodes'LNEG            (BytecodeParser''genNegateOp-2k this, JavaKind/Long)
           [Bytecodes'ISHL
            Bytecodes'ISHR
            Bytecodes'IUSHR]          (BytecodeParser''genShiftOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'IAND
            Bytecodes'IOR
            Bytecodes'IXOR]           (BytecodeParser''genLogicOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'LSHL
            Bytecodes'LSHR
            Bytecodes'LUSHR]          (BytecodeParser''genShiftOp-3 this, JavaKind/Long, opcode)
           [Bytecodes'LAND
            Bytecodes'LOR
            Bytecodes'LXOR]           (BytecodeParser''genLogicOp-3 this, JavaKind/Long, opcode)
            Bytecodes'IINC            (BytecodeParser''genIncrement-1 this)
            Bytecodes'L2I             (BytecodeParser''genNarrow-3k this, JavaKind/Long, JavaKind/Int)
            Bytecodes'I2L             (BytecodeParser''genSignExtend-3k this, JavaKind/Int, JavaKind/Long)
            Bytecodes'I2B             (BytecodeParser''genSignExtend-3k this, JavaKind/Byte, JavaKind/Int)
            Bytecodes'I2S             (BytecodeParser''genSignExtend-3k this, JavaKind/Short, JavaKind/Int)
            Bytecodes'I2C             (BytecodeParser''genZeroExtend-3k this, JavaKind/Char, JavaKind/Int)
            Bytecodes'LCMP            (BytecodeParser''genCompareOp-2 this, JavaKind/Long)
            Bytecodes'IFEQ            (ยง ass! this (BytecodeParser''genIfZero-2 this, Condition'EQ))
            Bytecodes'IFNE            (ยง ass! this (BytecodeParser''genIfZero-2 this, Condition'NE))
            Bytecodes'IFLT            (ยง ass! this (BytecodeParser''genIfZero-2 this, Condition'LT))
            Bytecodes'IFGE            (ยง ass! this (BytecodeParser''genIfZero-2 this, Condition'GE))
            Bytecodes'IFGT            (ยง ass! this (BytecodeParser''genIfZero-2 this, Condition'GT))
            Bytecodes'IFLE            (ยง ass! this (BytecodeParser''genIfZero-2 this, Condition'LE))
            Bytecodes'IF_ICMPEQ       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'EQ))
            Bytecodes'IF_ICMPNE       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'NE))
            Bytecodes'IF_ICMPLT       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'LT))
            Bytecodes'IF_ICMPGE       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'GE))
            Bytecodes'IF_ICMPGT       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'GT))
            Bytecodes'IF_ICMPLE       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'LE))
            Bytecodes'IF_ACMPEQ       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Object, Condition'EQ))
            Bytecodes'IF_ACMPNE       (ยง ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Object, Condition'NE))
            Bytecodes'GOTO            (BytecodeParser''genGoto-1 this)
            Bytecodes'JSR             (BytecodeParser''genJsr-2 this, (BytecodeStream''readBranchDest-1 (:stream this)))
            Bytecodes'RET             (BytecodeParser''genRet-2 this, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'TABLESWITCH     (ยง ass! this (BytecodeParser''genSwitch-2 this, (BytecodeTableSwitch'new-2 (:stream this), (BytecodeParser''bci-1 this))))
            Bytecodes'LOOKUPSWITCH    (ยง ass! this (BytecodeParser''genSwitch-2 this, (BytecodeLookupSwitch'new-2 (:stream this), (BytecodeParser''bci-1 this))))
            Bytecodes'IRETURN         (ยง ass! this (BytecodeParser''genReturn-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int), JavaKind/Int))
            Bytecodes'LRETURN         (ยง ass! this (BytecodeParser''genReturn-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Long), JavaKind/Long))
            Bytecodes'ARETURN         (ยง ass! this (BytecodeParser''genReturn-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object), JavaKind/Object))
            Bytecodes'RETURN          (ยง ass! this (BytecodeParser''genReturn-3 this, nil, JavaKind/Void))
            Bytecodes'GETSTATIC       (BytecodeParser''genGetStatic-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'PUTSTATIC       (BytecodeParser''genPutStatic-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'GETFIELD        (BytecodeParser''genGetField-3i this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'PUTFIELD        (ยง ass! this (BytecodeParser''genPutField-3i this, (BytecodeStream''readCPI-1 (:stream this)), opcode))
            Bytecodes'INVOKEVIRTUAL   (BytecodeParser''genInvokeVirtual-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKESPECIAL   (BytecodeParser''genInvokeSpecial-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKESTATIC    (BytecodeParser''genInvokeStatic-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKEINTERFACE (BytecodeParser''genInvokeInterface-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKEDYNAMIC   (BytecodeParser''genInvokeDynamic-3 this, (BytecodeStream''readCPI4-1 (:stream this)), opcode)
            Bytecodes'NEW             (BytecodeParser''genNewInstance-2i this, (BytecodeStream''readCPI-1 (:stream this)))
            Bytecodes'NEWARRAY        (BytecodeParser''genNewPrimitiveArray-2 this, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'ANEWARRAY       (BytecodeParser''genNewObjectArray-2 this, (BytecodeStream''readCPI-1 (:stream this)))
            Bytecodes'ARRAYLENGTH     (ยง ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''append-2 this, (ArrayLengthNode'create-1 (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)))))
            Bytecodes'CHECKCAST       (BytecodeParser''genCheckCast-1 this)
            Bytecodes'INSTANCEOF      (ยง ass! this (BytecodeParser''genInstanceOf-1 this))
            Bytecodes'MONITORENTER    (BytecodeParser''genMonitorEnter-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object), (:nextBCI (:stream this)))
            Bytecodes'MONITOREXIT     (BytecodeParser''genMonitorExit-4 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object), nil, (:nextBCI (:stream this)))
            Bytecodes'IFNULL          (ยง ass! this (BytecodeParser''genIfNull-2 this, Condition'EQ))
            Bytecodes'IFNONNULL       (ยง ass! this (BytecodeParser''genIfNull-2 this, Condition'NE))
            Bytecodes'GOTO_W          (BytecodeParser''genGoto-1 this)
            Bytecodes'JSR_W           (BytecodeParser''genJsr-2 this, (BytecodeStream''readBranchDest-1 (:stream this)))
        )
        this
    )

    ;;;
     ; Determines if this parsing context is within the bytecode of an intrinsic or a method inlined by an intrinsic.
     ;;
    (defn #_"boolean" BytecodeParser''parsingIntrinsic-1 [#_"BytecodeParser" this]
        (some? (:intrinsicContext this))
    )

    ;;;
     ; Gets the first ancestor parsing context that is not parsing a {@linkplain #parsingIntrinsic() intrinsic}.
     ;;
    (defn #_"BytecodeParser" BytecodeParser''getNonIntrinsicAncestor-1 [#_"BytecodeParser" this]
        (loop-when-recur [#_"BytecodeParser" ancestor (:parent this)]
                         (and (some? ancestor) (BytecodeParser''parsingIntrinsic-1 ancestor))
                         [(:parent ancestor)]
                      => ancestor
        )
    )
)

;;;
 ; A utility class that makes iterating over bytecodes and reading operands simpler and less error prone.
 ; For example, it handles the Bytecodes#WIDE instruction and wide variants of instructions internally.
 ;;
(class-ns BytecodeStream []
    ;;;
     ; Creates a new BytecodeStream for the specified bytecode.
     ;;
    (defn #_"BytecodeStream" BytecodeStream'new-1 [#_"byte[]" code]
        (let [
            #_"BytecodeStream" this
                (merge (BytecodeStream'class.)
                    (hash-map
                        #_"byte[]" :code code
                        #_"int" :opcode 0
                        ;;;
                         ; Current bytecode index.
                         ;;
                        #_"int" :curBCI 0
                        ;;;
                         ; Next bytecode index (no side-effects).
                         ;;
                        #_"int" :nextBCI 0
                    )
                )
            this (BytecodeStream''setBCI-2 this, 0)
        ]
            this
        )
    )

    ;;;
     ; Advances to the next bytecode.
     ;;
    (defn #_"BytecodeStream" BytecodeStream''next-1 [#_"BytecodeStream" this]
        (BytecodeStream''setBCI-2 this, (:nextBCI this))
    )

    ;;;
     ; Gets the bytecode index of the end of the code.
     ;;
    (defn #_"int" BytecodeStream''endBCI-1 [#_"BytecodeStream" this]
        (count (:code this))
    )

    ;;;
     ; Gets the current opcode. This method will never return the {@link Bytecodes#WIDE WIDE}
     ; opcode, but will instead return the opcode that is modified by the WIDE opcode.
     ;
     ; @return the current opcode; Bytecodes#END if at or beyond the end of the code
     ;;
    (defn #_"int" BytecodeStream''currentBC-1 [#_"BytecodeStream" this]
        (when (= (:opcode this) Bytecodes'WIDE) => (:opcode this)
            (Bytes'beU1-2 (:code this), (inc (:curBCI this)))
        )
    )

    ;;;
     ; Reads the index of a local variable for one of the load or store instructions.
     ; The WIDE modifier is handled internally.
     ;
     ; @return the index of the local variable
     ;;
    (defn #_"int" BytecodeStream''readLocalIndex-1 [#_"BytecodeStream" this]
        ;; read local variable index for load/store
        (if (= (:opcode this) Bytecodes'WIDE)
            (Bytes'beU2-2 (:code this), (+ (:curBCI this) 2))
            (Bytes'beU1-2 (:code this), (+ (:curBCI this) 1))
        )
    )

    ;;;
     ; Read the delta for an Bytecodes#IINC bytecode.
     ;
     ; @return the delta for the IINC
     ;;
    (defn #_"int" BytecodeStream''readIncrement-1 [#_"BytecodeStream" this]
        ;; read the delta for the iinc bytecode
        (if (= (:opcode this) Bytecodes'WIDE)
            (Bytes'beS2-2 (:code this), (+ (:curBCI this) 4))
            (Bytes'beS1-2 (:code this), (+ (:curBCI this) 2))
        )
    )

    ;;;
     ; Read the destination of a Bytecodes#GOTO or IF instructions.
     ;
     ; @return the destination bytecode index
     ;;
    (defn #_"int" BytecodeStream''readBranchDest-1 [#_"BytecodeStream" this]
        ;; reads the destination for a branch bytecode
        (if (any = (:opcode this) Bytecodes'GOTO_W Bytecodes'JSR_W)
            (+ (:curBCI this) (Bytes'beS4-2 (:code this), (inc (:curBCI this))))
            (+ (:curBCI this) (Bytes'beS2-2 (:code this), (inc (:curBCI this))))
        )
    )

    ;;;
     ; Read a signed 4-byte integer from the bytecode stream at the specified bytecode index.
     ;
     ; @param bci the bytecode index
     ; @return the integer value
     ;;
    (defn #_"int" BytecodeStream''readInt-2 [#_"BytecodeStream" this, #_"int" bci]
        ;; reads a 4-byte signed value
        (Bytes'beS4-2 (:code this), bci)
    )

    ;;;
     ; Reads an unsigned, 1-byte value from the bytecode stream at the specified bytecode index.
     ;
     ; @param bci the bytecode index
     ; @return the byte
     ;;
    (defn #_"int" BytecodeStream''readUByte-2 [#_"BytecodeStream" this, #_"int" bci]
        (Bytes'beU1-2 (:code this), bci)
    )

    ;;;
     ; Reads a constant pool index for the current instruction.
     ;
     ; @return the constant pool index
     ;;
    (defn #_"char" BytecodeStream''readCPI-1 [#_"BytecodeStream" this]
        (if (= (:opcode this) Bytecodes'LDC)
            (char (Bytes'beU1-2 (:code this), (inc (:curBCI this))))
            (char (Bytes'beU2-2 (:code this), (inc (:curBCI this))))
        )
    )

    ;;;
     ; Reads a constant pool index for an invokedynamic instruction.
     ;
     ; @return the constant pool index
     ;;
    (defn #_"int" BytecodeStream''readCPI4-1 [#_"BytecodeStream" this]
        (Bytes'beS4-2 (:code this), (inc (:curBCI this)))
    )

    ;;;
     ; Reads a signed, 1-byte value for the current instruction (e.g. BIPUSH).
     ;
     ; @return the byte
     ;;
    (defn #_"byte" BytecodeStream''readByte-1 [#_"BytecodeStream" this]
        (nth (:code this) (inc (:curBCI this)))
    )

    ;;;
     ; Reads a signed, 2-byte short for the current instruction (e.g. SIPUSH).
     ;
     ; @return the short value
     ;;
    (defn #_"short" BytecodeStream''readShort-1 [#_"BytecodeStream" this]
        (short (Bytes'beS2-2 (:code this), (inc (:curBCI this))))
    )

    ;;;
     ; Gets the length of the current bytecode.
     ;;
    (defn- #_"int" BytecodeStream''lengthOf-1 [#_"BytecodeStream" this]
        (let [
            #_"int" n (Bytecodes'lengthOf-1 (:opcode this))
        ]
            (when (zero? n) => n
                (condp = (:opcode this)
                    Bytecodes'TABLESWITCH
                        (BytecodeSwitch'''size-1 (BytecodeTableSwitch'new-2 this, (:curBCI this)))
                    Bytecodes'LOOKUPSWITCH
                        (BytecodeSwitch'''size-1 (BytecodeLookupSwitch'new-2 this, (:curBCI this)))
                    Bytecodes'WIDE
                        (condp = (Bytes'beU1-2 (:code this), (inc (:curBCI this)))
                            Bytecodes'RET  4
                            Bytecodes'IINC 6
                                           4 ;; a load or store bytecode
                        )
                )
            )
        )
    )

    ;;;
     ; Sets the bytecode index to the specified value. If {@code bci} is beyond the end of the array,
     ; #currentBC will return Bytecodes#END and other methods may throw ArrayIndexOutOfBoundsException.
     ;
     ; @param bci the new bytecode index
     ;;
    (defn #_"BytecodeStream" BytecodeStream''setBCI-2 [#_"BytecodeStream" this, #_"int" bci]
        (let [
            this (assoc this :curBCI bci)
        ]
            (if (< (:curBCI this) (count (:code this)))
                (let [
                    this (assoc this :opcode (Bytes'beU1-2 (:code this), bci))
                    this (assoc this :nextBCI (+ bci (BytecodeStream''lengthOf-1 this)))
                ]
                    this
                )
                (let [
                    this (assoc this :opcode Bytecodes'END)
                    this (assoc this :nextBCI (:curBCI this))
                ]
                    this
                )
            )
        )
    )
)

(class-ns BytecodeSwitch []
    ;;;
     ; Constructor for a BytecodeStream.
     ;
     ; @param stream the BytecodeStream containing the switch instruction
     ; @param bci the index in the stream of the switch instruction
     ;;
    (defn #_"BytecodeSwitch" BytecodeSwitch'new-2 [#_"BytecodeStream" stream, #_"int" bci]
        (merge (BytecodeSwitch'class.)
            (hash-map
                ;;;
                 ; The BytecodeStream containing the bytecode array.
                 ;;
                #_"BytecodeStream" :stream stream
                ;;;
                 ; Index of start of switch instruction.
                 ;;
                #_"int" :bci bci
                ;;;
                 ; Index of the start of the additional data for the switch instruction, aligned to a multiple
                 ; of four from the method start.
                 ;;
                #_"int" :alignedBci (& (+ bci 4) 0xfffffffc)
            )
        )
    )

    ;;;
     ; Gets the index of the instruction denoted by the {@code i}'th switch target.
     ;
     ; @param i index of the switch target
     ; @return the index of the instruction denoted by the {@code i}'th switch target
     ;;
    (defn #_"int" BytecodeSwitch''targetAt-2 [#_"BytecodeSwitch" this, #_"int" i]
        (+ (:bci this) (BytecodeSwitch'''offsetAt-2 this, i))
    )

    ;;;
     ; Gets the index of the instruction for the default switch target.
     ;
     ; @return the index of the instruction for the default switch target
     ;;
    (defn #_"int" BytecodeSwitch''defaultTarget-1 [#_"BytecodeSwitch" this]
        (+ (:bci this) (BytecodeSwitch''defaultOffset-1 this))
    )

    ;;;
     ; Gets the offset from the start of the switch instruction to the default switch target.
     ;
     ; @return the offset to the default switch target
     ;;
    (defn #_"int" BytecodeSwitch''defaultOffset-1 [#_"BytecodeSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (:alignedBci this))
    )
)

;;;
 ; A utility for processing Bytecodes#LOOKUPSWITCH bytecodes.
 ;;
(class-ns BytecodeLookupSwitch [BytecodeSwitch]
    (def- #_"int" BytecodeLookupSwitch'OFFSET_TO_NUMBER_PAIRS 4)
    (def- #_"int" BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_MATCH 8)
    (def- #_"int" BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_OFFSET 12)
    (def- #_"int" BytecodeLookupSwitch'PAIR_SIZE 8)

    ;;;
     ; Constructor for a BytecodeStream.
     ;
     ; @param stream the BytecodeStream containing the switch instruction
     ; @param bci the index in the stream of the switch instruction
     ;;
    (defn #_"BytecodeLookupSwitch" BytecodeLookupSwitch'new-2 [#_"BytecodeStream" stream, #_"int" bci]
        (merge (BytecodeLookupSwitch'class.) (BytecodeSwitch'new-2 stream, bci))
    )

    (defm BytecodeLookupSwitch BytecodeSwitch
        (#_"int" BytecodeSwitch'''offsetAt-2 [#_"BytecodeLookupSwitch" this, #_"int" i]
            (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_OFFSET (* BytecodeLookupSwitch'PAIR_SIZE i)))
        )

        (#_"int" BytecodeSwitch'''keyAt-2 [#_"BytecodeLookupSwitch" this, #_"int" i]
            (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_MATCH (* BytecodeLookupSwitch'PAIR_SIZE i)))
        )

        (#_"int" BytecodeSwitch'''numberOfCases-1 [#_"BytecodeLookupSwitch" this]
            (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_NUMBER_PAIRS))
        )

        (#_"int" BytecodeSwitch'''size-1 [#_"BytecodeLookupSwitch" this]
            (- (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_MATCH (* BytecodeLookupSwitch'PAIR_SIZE (BytecodeSwitch'''numberOfCases-1 this))) (:bci this))
        )
    )
)

;;;
 ; A utility for processing Bytecodes#TABLESWITCH bytecodes.
 ;;
(class-ns BytecodeTableSwitch [BytecodeSwitch]
    (def- #_"int" BytecodeTableSwitch'OFFSET_TO_LOW_KEY 4)
    (def- #_"int" BytecodeTableSwitch'OFFSET_TO_HIGH_KEY 8)
    (def- #_"int" BytecodeTableSwitch'OFFSET_TO_FIRST_JUMP_OFFSET 12)
    (def- #_"int" BytecodeTableSwitch'JUMP_OFFSET_SIZE 4)

    ;;;
     ; Constructor for a BytecodeStream.
     ;
     ; @param stream the BytecodeStream containing the switch instruction
     ; @param bci the index in the stream of the switch instruction
     ;;
    (defn #_"BytecodeTableSwitch" BytecodeTableSwitch'new-2 [#_"BytecodeStream" stream, #_"int" bci]
        (merge (BytecodeTableSwitch'class.) (BytecodeSwitch'new-2 stream, bci))
    )

    ;;;
     ; Gets the low key of the table switch.
     ;;
    (defn #_"int" BytecodeTableSwitch''lowKey-1 [#_"BytecodeTableSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_LOW_KEY))
    )

    ;;;
     ; Gets the high key of the table switch.
     ;;
    (defn #_"int" BytecodeTableSwitch''highKey-1 [#_"BytecodeTableSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_HIGH_KEY))
    )

    (defm BytecodeTableSwitch BytecodeSwitch
        (#_"int" BytecodeSwitch'''keyAt-2 [#_"BytecodeTableSwitch" this, #_"int" i]
            (+ (BytecodeTableSwitch''lowKey-1 this) i)
        )

        (#_"int" BytecodeSwitch'''offsetAt-2 [#_"BytecodeTableSwitch" this, #_"int" i]
            (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_FIRST_JUMP_OFFSET (* BytecodeTableSwitch'JUMP_OFFSET_SIZE i)))
        )

        (#_"int" BytecodeSwitch'''numberOfCases-1 [#_"BytecodeTableSwitch" this]
            (inc (- (BytecodeTableSwitch''highKey-1 this) (BytecodeTableSwitch''lowKey-1 this)))
        )

        (#_"int" BytecodeSwitch'''size-1 [#_"BytecodeTableSwitch" this]
            (- (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_FIRST_JUMP_OFFSET (* BytecodeTableSwitch'JUMP_OFFSET_SIZE (BytecodeSwitch'''numberOfCases-1 this))) (:bci this))
        )
    )
)

(class-ns CFOptimizer []
    (defn #_"CFOptimizer" CFOptimizer'new-1 [#_"LIR" lir]
        (merge (CFOptimizer'class.)
            (hash-map
                #_"LIR" :lir lir
            )
        )
    )

    ;;;
     ; Checks whether a block can be deleted. Only blocks with exactly one successor and an
     ; unconditional branch to this successor are eligable.
     ;
     ; @param block the block checked for deletion
     ; @return whether the block can be deleted
     ;;
    (defn- #_"boolean" CFOptimizer''canDeleteBlock-2 [#_"CFOptimizer" this, #_"Block" block]
        ;; block must have exactly one successor
        (and (some? block) (= (count (:successors block)) 1) (not (= (nth (:successors block) 0) block)) (seq (:predecessors block))
            (= (count (LIR''getLIRforBlock-2 (:lir this), block)) 2)
        )
    )

    (defn- #_"void" CFOptimizer''alignBlock-2 [#_"CFOptimizer" this, #_"Block" block]
        (when-not (:aligned? block)
            (ยง ass! block (Block''setAlign-2 block, true))
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
            ]
                (#_"ArrayList" .set ops, 0, (LabelOp'new-2 (:label (nth ops 0)), true))
            )
        )
        nil
    )

    (defn #_"void" CFOptimizer''deleteEmptyBlocks-2 [#_"CFOptimizer" this, #_"Block[]" blocks]
        (loop-when-recur [#_"int" i 0] (< i (count blocks)) [(inc i)]
            (let [
                #_"Block" block (nth blocks i)
            ]
                (when (CFOptimizer''canDeleteBlock-2 this, block)
                    (Block''delete-1 block)
                    ;; adjust successor and predecessor lists
                    (when (:aligned? block)
                        (CFOptimizer''alignBlock-2 this, (nth (:successors block) 0))
                    )
                    (ยง aset! blocks i nil)
                )
            )
        )
        nil
    )
)

(class-ns CLOptimization []
    (defn #_"CLOptimization" CLOptimization'new-2 [#_"LIR" lir, #_"LIRGenerator" lirGen]
        (merge (CLOptimization'class.)
            (hash-map
                #_"LIR" :lir lir
                #_"LIRGenerator" :lirGen lirGen
                #_"VariableMap" :map (VariableMap'new-0)
                #_"BitSet" :phiConstants (BitSet.)
                #_"BitSet" :defined (BitSet.)
                #_"BlockMap<LIRInsertionBuffer>" :insertionBuffers (BlockMap'new-1 (:cfg lir))
            )
        )
    )

    (defn- #_"boolean" CLOptimization'isConstantLoad-1 [#_"LIRInstruction" op]
        (and (satisfies? LoadConstantOp op) (satisfies? Variable (MoveOp'''getResult-1 op)))
    )

    ;;;
     ; Collects def-use information for a {@code block}.
     ;;
    (defn- #_"void" CLOptimization''analyzeBlock-2 [#_"CLOptimization" this, #_"Block" block]
        (let [
            #_"ValueConsumer" loadConsumer
                (reify ValueConsumer
                    (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _, #_"LIRInstruction" op, #_"Value" value, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                        (when (and (satisfies? Variable value) (not (#_"BitSet" .get (:phiConstants this), (:index value))))
                            (if (not (#_"BitSet" .get (:defined this), (:index value)))
                                (do
                                    (#_"BitSet" .set (:defined this), (:index value))
                                    (when (CLOptimization'isConstantLoad-1 op)
                                        (VariableMap''put-3 (:map this), value, (DefUseTree'new-2 op, block))
                                    )
                                )
                                (do
                                    ;; Variable is redefined: happens only for constant loads
                                    ;; introduced by phi resolution -> ignore.
                                    (VariableMap''remove-2 (:map this), value)
                                    (#_"BitSet" .set (:phiConstants this), (:index value))
                                )
                            )
                        )
                    )
                )
            #_"ValueConsumer" useConsumer
                (reify ValueConsumer
                    (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _, #_"LIRInstruction" op, #_"Value" value, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                        (when (and (satisfies? Variable value) (not (#_"BitSet" .get (:phiConstants this), (:index value))))
                            (let [
                                #_"DefUseTree" tree (VariableMap''get-2 (:map this), value)
                            ]
                                (when (some? tree)
                                    (DefUseTree''addUsage-4 tree, block, op, value)
                                )
                            )
                        )
                    )
                )
        ]
            (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq (LIR''getLIRforBlock-2 (:lir this), block))] (some? s) [(inc i) (next s)]
                (let [
                    #_"LIRInstruction" op (first s)
                ]
                    ;; set instruction id to the index in the lir instruction list
                    (ยง ass! op (LIRInstruction''setId-2 op, i))
                    (LIRInstruction''visitEachOutput-2 op, loadConsumer)
                    (LIRInstruction''visitEachInput-2 op, useConsumer)
                    (LIRInstruction''visitEachAlive-2 op, useConsumer)
                )
            )
        )
        nil
    )

    (defn- #_"void" CLOptimization''deleteInstruction-2 [#_"CLOptimization" this, #_"DefUseTree" tree]
        (#_"ArrayList" .set (LIR''getLIRforBlock-2 (:lir this), (:block tree)), (:id (:instruction tree)), nil)
        nil
    )

    (defn- #_"LIRInsertionBuffer" CLOptimization''getInsertionBuffer-2 [#_"CLOptimization" this, #_"Block" block]
        (or (BlockMap''get-2 (:insertionBuffers this), block)
            (let [
                #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer'new-0)
            ]
                (BlockMap''put-3 (:insertionBuffers this), block, buffer)
                (LIRInsertionBuffer''init-2 buffer, (LIR''getLIRforBlock-2 (:lir this), block))
            )
        )
    )

    (defn- #_"void" CLOptimization''insertLoad-5 [#_"CLOptimization" this, #_"Constant" constant, #_"ValueKind" kind, #_"Block" block, #_"UseEntry*" usages]
        ;; create variable ;; create move ;; insert instruction ;; update usages
        (let [
            #_"Variable" variable (LIRGenerator''newVariable-2 (:lirGen this), kind)
            #_"LIRInstruction" move (MoveFactory'createLoad-2 variable, constant)
        ]
            (ยง ass! (CLOptimization''getInsertionBuffer-2 this, block) (LIRInsertionBuffer''append-3 (CLOptimization''getInsertionBuffer-2 this, block), 1, move))
            (doseq [#_"UseEntry" usage usages]
                (UseEntry''setValue-2 usage, variable)
            )
        )
        nil
    )

    (defn- #_"void" CLOptimization''createLoads-4 [#_"CLOptimization" this, #_"DefUseTree" tree, #_"ConstantTree" constTree, #_"Block" startBlock]
        (loop-when [#_"(Block)" s (list startBlock)] (seq s)
            (let [
                [#_"Block" block & s] s
                s
                    (if (DominatorOptimizationProblem''get-3 constTree, Flags'CANDIDATE, block)
                        (let [
                            _ (DominatorOptimizationProblem''set-3 constTree, Flags'MATERIALIZE, block)
                            #_"Constant" constant (DefUseTree''getConstant-1 tree)
                            #_"ValueKind" kind (#_"Value" .getValueKind (DefUseTree''getVariable-1 tree))
                        ]
                            ;; create and insert load
                            (CLOptimization''insertLoad-5 this, constant, kind, block, (:usages (DominatorOptimizationProblem''getCost-2 constTree, block)))
                            s
                        )
                        (->> (:firstDominated block) (iterate :dominatedSibling) (take-while some?) (filter #(ConstantTree''isMarked-2 constTree, %)) (into s))
                    )
            ]
                (recur s)
            )
        )
        nil
    )

    ;;;
     ; Creates the dominator tree and searches for an solution.
     ;;
    (defn- #_"void" CLOptimization''createConstantTree-2 [#_"CLOptimization" this, #_"DefUseTree" tree]
        (let [
            #_"ConstantTree" constTree (ConstantTree'new-2 (:cfg (:lir this)), tree)
        ]
            (DominatorOptimizationProblem''set-3 constTree, Flags'IN_SUBTREE, (:block tree))
            (run! #(DominatorOptimizationProblem''set-3 constTree, Flags'HAS_USAGE, (:block %)) (:uses tree))

            (when-not (DominatorOptimizationProblem''get-3 constTree, Flags'HAS_USAGE, (:block tree)) ;; => usage in the definition block -> no optimization
                (ConstantTree''markBlocks-1 constTree)

                (let [
                    #_"NodeCost" cost (ConstantTreeAnalyzer'analyze-2 constTree, (:block tree))
                ]
                    (when (or (< 1 (:numMat cost)) (< (:bestCost cost) (:probability (:block tree)))) ;; => no better solution found
                        ;; mark original load for removal
                        (CLOptimization''deleteInstruction-2 this, tree)
                        ;; collect result
                        (CLOptimization''createLoads-4 this, tree, constTree, (:block tree))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Inserts the constant loads created in #createConstantTree and deletes the original definition.
     ;;
    (defn- #_"void" CLOptimization''rewriteBlock-2 [#_"CLOptimization" this, #_"Block" block]
        ;; insert moves
        (let [
            #_"LIRInsertionBuffer" buffer (BlockMap''get-2 (:insertionBuffers this), block)
        ]
            (when (some? buffer)
                (ยง ass! buffer (LIRInsertionBuffer''finish-1 buffer))
            )
            ;; delete instructions
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
                #_"boolean" hasDead
                    (loop-when [hasDead false #_"ISeq" s (seq ops)] (some? s) => hasDead
                        (let [
                            #_"LIRInstruction" op (first s)
                            hasDead
                                (when (some? op) => true
                                    (ยง ass! op (LIRInstruction''setId-2 op, -1))
                                    hasDead
                                )
                        ]
                            (recur hasDead (next s))
                        )
                    )
            ]
                (when hasDead
                    ;; Remove nil values from the list.
                    (#_"ArrayList" .removeAll ops, (Collections/singleton nil))
                )
            )
        )
        nil
    )

    (defn #_"void" CLOptimization''apply-1 [#_"CLOptimization" this]
        ;; build DefUseTree
        (doseq [#_"Block" b (:reversePostOrder (:cfg (:lir this)))]
            (CLOptimization''analyzeBlock-2 this, b)
        )
        ;; remove all with only one use
        (VariableMap''filter-2 (:map this), (ร (tree)  (ยง fun (< 1 (DefUseTree''usageCount-1 tree)))))
        ;; create ConstantTree
        (VariableMap''forEach-2 (:map this), (ยง ffun CLOptimization''createConstantTree-2))
        ;; insert moves, delete nil instructions and reset instruction ids
        (doseq [#_"Block" b (:reversePostOrder (:cfg (:lir this)))]
            (CLOptimization''rewriteBlock-2 this, b)
        )
        nil
    )
)

(class-ns CacheEntry #_"<T>" []
    (defn #_"CacheEntry" CacheEntry'new-2 [#_"ValueNode" object, #_"T" identity]
        (merge (CacheEntry'class.)
            (hash-map
                #_"ValueNode" :object object
                #_"T" :identity identity
            )
        )
    )
)

(class-ns LoadCacheEntry [CacheEntry #_"<LocationIdentity>"]
    (defn #_"LoadCacheEntry" LoadCacheEntry'new-2 [#_"ValueNode" object, #_"LocationIdentity" identity]
        (merge (LoadCacheEntry'class.) (CacheEntry'new-2 object, identity))
    )

    (defm LoadCacheEntry CacheEntry
        (#_"CacheEntry<LocationIdentity>" CacheEntry'''duplicateWithObject-2 [#_"LoadCacheEntry" this, #_"ValueNode" newObject]
            (LoadCacheEntry'new-2 newObject, (:identity this))
        )

        (#_"boolean" CacheEntry'''conflicts-2 [#_"LoadCacheEntry" this, #_"LocationIdentity" other]
            (= (:identity this) other)
        )

        (#_"LocationIdentity" CacheEntry'''getIdentity-1 [#_"LoadCacheEntry" this]
            (:identity this)
        )
    )
)

;;;
 ; CacheEntry describing an Unsafe memory reference. The memory location and the location identity
 ; are separate so both must be considered when looking for optimizable memory accesses.
 ;;
(class-ns UnsafeLoadCacheEntry [CacheEntry #_"<ValueNode>"]
    (defn #_"UnsafeLoadCacheEntry" UnsafeLoadCacheEntry'new-3 [#_"ValueNode" object, #_"ValueNode" location, #_"LocationIdentity" locationIdentity]
        (merge (UnsafeLoadCacheEntry'class.) (CacheEntry'new-2 object, location)
            (hash-map
                #_"LocationIdentity" :locationIdentity locationIdentity
            )
        )
    )

    (defm UnsafeLoadCacheEntry CacheEntry
        (#_"CacheEntry<ValueNode>" CacheEntry'''duplicateWithObject-2 [#_"UnsafeLoadCacheEntry" this, #_"ValueNode" newObject]
            (UnsafeLoadCacheEntry'new-3 newObject, (:identity this), (:locationIdentity this))
        )

        (#_"boolean" CacheEntry'''conflicts-2 [#_"UnsafeLoadCacheEntry" this, #_"LocationIdentity" other]
            (= (:locationIdentity this) other)
        )

        (#_"LocationIdentity" CacheEntry'''getIdentity-1 [#_"UnsafeLoadCacheEntry" this]
            (:locationIdentity this)
        )
    )
)

;;;
 ; Information about a graph that will potentially be inlined, esp. tracking the invocations that will subject to inlining themselves.
 ;;
(class-ns CallsiteHolder []
    (defn- #_"{ParameterNode}" CallsiteHolder'fixedParamsAt-2 [#_"Graph" graph, #_"BitSet" freshArgs]
        (when (and (some? freshArgs) (not (#_"BitSet" .isEmpty freshArgs)))
            (into #{} (filter #(#_"BitSet" .get freshArgs, (AbstractLocalNode''index-1 %)) (Graph''getNodes-2 graph, ParameterNode)))
        )
    )

    (defn #_"CallsiteHolder" CallsiteHolder'new-4 [#_"Graph" graph, #_"double" probability, #_"double" relevance, #_"BitSet" freshArgs]
        (let [
            #_"CallsiteHolder" this
                (merge (CallsiteHolder'class.)
                    (hash-map
                        ;;;
                         ; Graph in which inlining may be performed at one or more of the callsites containined in #remainingInvokes.
                         ;;
                        #_"Graph" :graph graph
                        #_"LinkedList<InvokeNode>" :remainingInvokes (InliningIterator''apply-1 (InliningIterator'new-1 graph))
                        #_"double" :probability probability
                        #_"double" :relevance relevance
                        ;;;
                         ; Parameters for which the callsite targeting #graph() provides "fixed" arguments. That callsite isn't referenced
                         ; by this instance. Instead, it belongs to the graph of the caller of this CallsiteHolderExplorable.
                         ;
                         ; Constant arguments don't contribute to fixed-params: those params have been removed already, see InlineableGraph.
                         ; Instead, fixed-params are those receiving freshly instantiated arguments (possibly instantiated several levels
                         ; up in the call-hierarchy).
                         ;;
                        #_"{ParameterNode}" :fixedParams (CallsiteHolder'fixedParamsAt-2 graph, freshArgs)
                        #_"ToDoubleFunction<FixedNode>" :probabilities nil
                        #_"ComputeInliningRelevance" :computeInliningRelevance nil
                    )
                )
        ]
            (when (seq (:remainingInvokes this)) => this
                (let [
                    #_"ToDoubleFunction<FixedNode>" probabilities (FixedNodeProbabilityCache'new-0)
                ]
                    (assoc this :probabilities probabilities, :computeInliningRelevance (ComputeInliningRelevance''compute-1 (ComputeInliningRelevance'new-2 graph, probabilities)))
                )
            )
        )
    )

    ;;;
     ; Gets the method associated with the {@linkplain #graph() graph} represented by this object.
     ;;
    (defn #_"ResolvedJavaMethod" CallsiteHolder''method-1 [#_"CallsiteHolder" this]
        (when (some? (:graph this)) (:rootMethod (:graph this)))
    )

    ;;;
     ; The stack realized by InliningData grows upon InliningData#moveForward() deciding
     ; to explore (depth-first) a callsite of the graph associated to this CallsiteHolder.
     ; The list of not-yet-considered callsites is managed by CallsiteHolderExplorable,
     ; and this method reports whether any such candidates remain.
     ;;
    (defn #_"boolean" CallsiteHolder''hasRemainingInvokes-1 [#_"CallsiteHolder" this]
        (seq (:remainingInvokes this))
    )

    (defn #_"InvokeNode" CallsiteHolder''popInvoke-1 [#_"CallsiteHolder" this]
        (#_"LinkedList" .removeFirst (:remainingInvokes this))
    )

    (defn #_"void" CallsiteHolder''pushInvoke-2 [#_"CallsiteHolder" this, #_"InvokeNode" invoke]
        (#_"LinkedList" .push (:remainingInvokes this), invoke)
        nil
    )

    (defn #_"CallsiteHolder" CallsiteHolder''computeProbabilities-1 [#_"CallsiteHolder" this]
        (update this :computeInliningRelevance ComputeInliningRelevance''compute-1)
    )

    (defn #_"double" CallsiteHolder''invokeProbability-2 [#_"CallsiteHolder" this, #_"InvokeNode" invoke]
        (* (:probability this) (#_"ToDoubleFunction" .applyAsDouble (:probabilities this), invoke))
    )

    (defn #_"double" CallsiteHolder''invokeRelevance-2 [#_"CallsiteHolder" this, #_"InvokeNode" invoke]
        (* (min InliningPolicy'CapInheritedRelevance (:relevance this)) (ComputeInliningRelevance''getRelevance-2 (:computeInliningRelevance this), invoke))
    )
)

(class-ns CanonicalCondition []
    (defn- #_"CanonicalCondition" CanonicalCondition'new-1 [#_"Condition" condition]
        (merge (CanonicalCondition'class.)
            (hash-map
                #_"Condition" :canonical condition
            )
        )
    )

    (ยง def #_"CanonicalCondition" CanonicalCondition'EQ (CanonicalCondition'new-1 Condition'EQ))
    (ยง def #_"CanonicalCondition" CanonicalCondition'LT (CanonicalCondition'new-1 Condition'LT))
    (ยง def #_"CanonicalCondition" CanonicalCondition'BT (CanonicalCondition'new-1 Condition'BT))
)

(class-ns CanonicalizedCondition []
    (defn #_"CanonicalizedCondition" CanonicalizedCondition'new-3 [#_"CanonicalCondition" canonicalCondition, #_"boolean" mirror?, #_"boolean" negate?]
        (merge (CanonicalizedCondition'class.)
            (hash-map
                #_"CanonicalCondition" :canonicalCondition canonicalCondition
                #_"boolean" :mirror? mirror?
                #_"boolean" :negate? negate?
            )
        )
    )
)

(class-ns CanonicalizerInstance [Phase]
    (defn #_"CanonicalizerInstance" CanonicalizerInstance'new-3 [#_"CanonicalizerPhase" phase, #_"Node*" workingSet, #_"int" newNodesMark]
        (merge (CanonicalizerInstance'class.)
            (hash-map
                #_"CanonicalizerPhase" :phase phase
                #_"int" :newNodesMark newNodesMark
                #_"Node*" :initWorkingSet workingSet
                #_"NodeWorkList" :workList nil
                #_"Tool" :tool nil
            )
        )
    )

    ;;;
     ; Calls ValueNode#inferStamp() on the node and if it returns true (which means that the stamp has changed),
     ; re-queues the node's usages. If the stamp has changed, then this method also checks
     ; if the stamp now describes a constant integer value, in which case the node is replaced with a constant.
     ;;
    (defn- #_"boolean" CanonicalizerInstance''tryInferStamp-2 [#_"CanonicalizerInstance" this, #_"ValueNode" node]
        (and (Node''isAlive-1 node) (ValueNode'''inferStamp-1 node)
            (do
                (doseq [#_"Node" usage (:nodeUsages node)]
                    (NodeWorkList'''add-2 (:workList this), usage)
                )
                true
            )
        )
    )

    ;;;
     ; @return true if the graph was changed
     ;;
    (defn- #_"boolean" CanonicalizerInstance''processNode-2 [#_"CanonicalizerInstance" this, #_"Node" node]
        (and (Node''isAlive-1 node)
            (or (GraphUtil'tryKillUnused-1 node)
                (CanonicalizerInstance''tryCanonicalize-3 this, node, (:nodeClass node))
                (and (satisfies? ValueNode node)
                    (let [
                        #_"boolean" improved? (CanonicalizerInstance''tryInferStamp-2 this, node)
                        #_"Constant" constant (Stamp'''asConstant-1 (:stamp node))
                    ]
                        (if (and (some? constant) (not (satisfies? ConstantNode node)))
                            (do
                                (Node''replaceAtUsages-3 node, InputType'Value, (ConstantNode'forConstant-3s (:stamp node), constant, (:graph node)))
                                (GraphUtil'tryKillUnused-1 node)
                                true
                            )
                            (and improved?
                                ;; the improved stamp may enable additional canonicalization
                                (or (CanonicalizerInstance''tryCanonicalize-3 this, node, (:nodeClass node))
                                    (do
                                        (doseq [#_"Node" usage (:nodeUsages node)]
                                            (NodeWorkList'''add-2 (:workList this), usage)
                                        )
                                        false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ; @SuppressWarnings("try")
    (defn- #_"void" CanonicalizerInstance''processWorkSet-2 [#_"CanonicalizerInstance" this, #_"Graph" graph]
        (let [
            #_"CanonicalizerInstance" instance this
            #_"NodeEventListener" listener
                (ยง proxy #_"NodeEventListener" (NodeEventListener'new-0)
                    (#_"void" NodeEventListener'''nodeAdded-2 [#_"NodeEventListener" this, #_"Node" node]
                        (NodeWorkList'''add-2 (:workList instance), node)
                        nil
                    )

                    (#_"void" NodeEventListener'''inputChanged-2 [#_"NodeEventListener" this, #_"Node" node]
                        (NodeWorkList'''add-2 (:workList instance), node)
                        (when (satisfies? IndirectCanonicalization node)
                            (doseq [#_"Node" usage (:nodeUsages node)]
                                (NodeWorkList'''add-2 (:workList instance), usage)
                            )
                        )
                        nil
                    )

                    (#_"void" NodeEventListener'''usagesDroppedToZero-2 [#_"NodeEventListener" this, #_"Node" node]
                        (NodeWorkList'''add-2 (:workList instance), node)
                        nil
                    )
                )
        ]
            (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                (doseq [#_"Node" node (:workList this)]
                    (CanonicalizerInstance''processNode-2 this, node)
                )
            )
        )
        nil
    )

    (def- #_"int" CanonicalizerInstance'MAX_ITERATION_PER_NODE 10)

    (defm CanonicalizerInstance Phase
        (#_"Graph" Phase'''run-3 [#_"CanonicalizerInstance" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"boolean" whole-graph? (zero? (:newNodesMark this))
            ]
                (if (nil? (:initWorkingSet this))
                    (ยง ass! this (assoc this :workList (IterativeNodeWorkList'new-3 graph, whole-graph?, CanonicalizerInstance'MAX_ITERATION_PER_NODE)))
                    (do
                        (ยง ass! this (assoc this :workList (IterativeNodeWorkList'new-3 graph, false, CanonicalizerInstance'MAX_ITERATION_PER_NODE)))
                        (NodeWorkList''addAll-2 (:workList this), (:initWorkingSet this))
                    )
                )
                (when-not whole-graph?
                    (NodeWorkList''addAll-2 (:workList this), (Graph''getNodesSince-2 graph, (:newNodesMark this)))
                )
                (ยง ass! this (assoc this :tool (Tool'new-1 this)))
                (CanonicalizerInstance''processWorkSet-2 this, graph)
                graph
            )
        )
    )

    ;; cases:                                           original node:
    ;;                                     |Floating|Fixed-unconnected|Fixed-connected|
    ;;                                     --------------------------------------------
    ;;                                  nil|   1    |        X        |       3       |
    ;;                                     --------------------------------------------
    ;;                             Floating|   2    |        X        |       4       |
    ;;   canonical node:                   --------------------------------------------
    ;;                    Fixed-unconnected|   X    |        X        |       5       |
    ;;                                     --------------------------------------------
    ;;                      Fixed-connected|   2    |        X        |       6       |
    ;;                                     --------------------------------------------
    ;;                          ControlSink|   X    |        X        |       7       |
    ;;                                     --------------------------------------------
    ;;   X: must not happen

    (defn- #_"boolean" CanonicalizerInstance''performReplacement-3 [#_"CanonicalizerInstance" this, #_"Node" node, #_"Node" newCanonical]
        (and (not= newCanonical node)
            (let [
                #_"Graph" graph (:graph node)
                #_"Node" canonical
                    (when (and (some? newCanonical) (not (Node''isAlive-1 newCanonical))) => newCanonical
                        (Graph''addOrUniqueWithInputs-2 graph, newCanonical)
                    )
            ]
                (cond
                    (satisfies? FloatingNode node)
                    (do
                        (ยง ass! node (Node''replaceAtUsages-2 node, canonical))
                        (GraphUtil'killWithUnusedFloatingInputs-2 node, true)
                    )
                    (satisfies? ControlSinkNode canonical)
                    (do
                        (Node''replaceAtPredecessor-2 node, canonical)
                        (GraphUtil'killCFG-1 node)
                    )
                    :else
                    (do
                        ;; when removing a fixed node, new canonicalization opportunities for its successor may arise
                        (SimplifierTool'''addToWorkList-2n (:tool this), (:next node))
                        (cond
                            (nil? canonical)
                            (do
                                (ยง ass! node (Node''replaceAtUsages-2 node, nil))
                                (GraphUtil'removeFixedWithUnusedInputs-1 node)
                            )
                            (satisfies? FloatingNode canonical)
                            (do
                                (ยง ass! graph (Graph''replaceFixedWithFloating-3 graph, node, canonical))
                            )
                            (nil? (:predecessor canonical))
                            (do
                                (ยง ass! graph (Graph''replaceFixedWithFixed-3 graph, node, canonical))
                            )
                            :else
                            (do
                                (ยง ass! node (Node''replaceAtUsages-2 node, canonical))
                                (GraphUtil'removeFixedWithUnusedInputs-1 node)
                            )
                        )
                    )
                )
                true
            )
        )
    )

    (defn #_"boolean" CanonicalizerInstance''tryCanonicalize-3 [#_"CanonicalizerInstance" this, #_"Node" node, #_"NodeClass" nodeClass]
        (or
            (and (:canonicalizable? nodeClass)
                (let [
                    #_"Node" canonical
                        (let [
                            canonical (Canonicalizable'''canonical-2 node, (:tool this))
                        ]
                            (when (and (= canonical node) (:commutative? nodeClass)) => canonical
                                (Binary'''maybeCommuteInputs-1 node)
                            )
                        )
                ]
                    (CanonicalizerInstance''performReplacement-3 this, node, canonical)
                )
            )
            (and (:simplifiable? nodeClass)
                (do
                    (Simplifiable'''simplify-2 node, (:tool this))
                    (Node''isDeleted-1 node)
                )
            )
        )
    )
)

(class-ns CanonicalizerPhase [Phase]
    (defn #_"CanonicalizerPhase" CanonicalizerPhase'new-0 []
        (CanonicalizerPhase'class.)
    )

    ;;;
     ; @param newNodesMark only the {@linkplain Graph#getNodesSince(int) new nodes} specified by this mark are processed
     ;;
    (defn #_"void" CanonicalizerPhase''applyIncremental-3m [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"int" newNodesMark]
        (ยง ass! graph (Phase'''run-3 (CanonicalizerInstance'new-3 this, nil, newNodesMark), graph, nil))
        nil
    )

    ;;;
     ; @param workingSet the initial working set of nodes on which the canonicalizer works, should be an auto-grow node bitmap
     ;;
    (defn #_"void" CanonicalizerPhase''applyIncremental-3i [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"Node*" workingSet]
        (ยง ass! graph (Phase'''run-3 (CanonicalizerInstance'new-3 this, workingSet, 0), graph, nil))
        nil
    )

    (defm CanonicalizerPhase Phase
        (#_"Graph" Phase'''run-3 [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (Phase'''run-3 (CanonicalizerInstance'new-3 this, nil, 0), graph, nil)
        )
    )
)

;;;
 ; Container for objects representing the Code attributes parsed from a class file.
 ;;
(class-ns Classfile []
    (def- #_"int" Classfile'MAGIC 0xcafebabe)
    (def- #_"int" Classfile'MAJOR_VERSION_JAVA_MIN 51) ;; JDK7
    (def- #_"int" Classfile'MAJOR_VERSION_JAVA_MAX 55) ;; JDK11

    (defn #_"void" Classfile'skipFully-2 [#_"DataInputStream" stream, #_"int" n]
        (loop [#_"long" i 0]
            (let [
                #_"long" skipped (#_"DataInputStream" .skip stream, (- n i))
                i (+ i skipped)
                i
                    (when (and (zero? skipped) (< i n)) => i
                        ;; check for EOF (i.e. truncated class file)
                        (when (= (#_"DataInputStream" .read stream) -1)
                            (throw (IOException. "truncated stream"))
                        )
                        (inc i)
                    )
            ]
                (recur-if (< i n) [i])
            )
        )
        nil
    )

    (defn- #_"void" Classfile'skipAttributes-1 [#_"DataInputStream" stream]
        (dotimes [_ (#_"DataInputStream" .readUnsignedShort stream)]
            (Classfile'skipFully-2 stream, 2) ;; name_index
            (Classfile'skipFully-2 stream, (#_"DataInputStream" .readInt stream))
        )
        nil
    )

    (defn- #_"void" Classfile'skipFields-1 [#_"DataInputStream" stream]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
        ]
            (dotimes [#_"int" i n]
                (Classfile'skipFully-2 stream, 6) ;; access_flags, name_index, descriptor_index
                (Classfile'skipAttributes-1 stream)
            )
        )
        nil
    )

    (defn- #_"ClassfileBytecode" Classfile'findCodeAttribute-6 [#_"DataInputStream" stream, #_"ClassfileConstantPool" cp, #_"ResolvedJavaType" type, #_"String" name, #_"String" descriptor, #_"boolean" static?]
        (let [
            #_"int" attributesCount (#_"DataInputStream" .readUnsignedShort stream)
        ]
            (loop-when [#_"ClassfileBytecode" code nil #_"int" i 0] (< i attributesCount) => code
                (let [
                    #_"String" attributeName (:value (ClassfileConstantPool''get-3 cp, Utf8'iface, (#_"DataInputStream" .readUnsignedShort stream)))
                    #_"int" attributeLength (#_"DataInputStream" .readInt stream)
                    code
                        (if (and (nil? code) (= attributeName "Code"))
                            (let [
                                #_"ResolvedJavaMethod" method (ClassfileBytecodeProvider''findMethod-5 (:context cp), type, name, descriptor, static?)
                                ;; Even if we will discard the Code attribute (see below), we still
                                ;; need to parse it to reach the following class file content.
                                code (ClassfileBytecode'new-3 method, stream, cp)
                            ]
                                (when (some? method) ;; => this is a method hidden from reflection (see sun.reflect.Reflection.filterMethods)
                                    code
                                )
                            )
                            (do
                                (Classfile'skipFully-2 stream, attributeLength)
                                code
                            )
                        )
                ]
                    (recur code (inc i))
                )
            )
        )
    )

    (defn- #_"List<ClassfileBytecode>" Classfile'readMethods-3 [#_"DataInputStream" stream, #_"ClassfileConstantPool" cp, #_"ResolvedJavaType" type]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
            #_"List<ClassfileBytecode>" methods (ArrayList.)
        ]
            (dotimes [#_"int" i n]
                (let [
                    #_"int" accessFlags (#_"DataInputStream" .readUnsignedShort stream)
                    #_"boolean" static? (Modifier/isStatic accessFlags)
                    #_"String" name (:value (ClassfileConstantPool''get-3 cp, Utf8'iface, (#_"DataInputStream" .readUnsignedShort stream)))
                    #_"String" descriptor (:value (ClassfileConstantPool''get-3 cp, Utf8'iface, (#_"DataInputStream" .readUnsignedShort stream)))
                    #_"ClassfileBytecode" code (Classfile'findCodeAttribute-6 stream, cp, type, name, descriptor, static?)
                ]
                    (when (some? code)
                        (#_"List" .add methods, code)
                    )
                )
            )
            methods
        )
    )

    ;;;
     ; Creates a Classfile by parsing the class file bytes for {@code type} loadable from {@code context}.
     ;
     ; @throws NoClassDefFoundError if there is an IO error while parsing the class file
     ;;
    (defn #_"Classfile" Classfile'new-3 [#_"ResolvedJavaType" type, #_"DataInputStream" stream, #_"ClassfileBytecodeProvider" context]
        (let [
            #_"int" magic (#_"DataInputStream" .readInt stream)
            #_"int" minor (#_"DataInputStream" .readUnsignedShort stream)
            #_"int" major (#_"DataInputStream" .readUnsignedShort stream)
            _
                (when-not (<= Classfile'MAJOR_VERSION_JAVA_MIN major Classfile'MAJOR_VERSION_JAVA_MAX)
                    (throw (UnsupportedClassVersionError. (str "unsupported class file version: " major "." minor)))
                )
            #_"ClassfileConstantPool" cp (ClassfileConstantPool'new-2 stream, context)
            _ (Classfile'skipFully-2 stream, 6)                                                     ;; access_flags, this_class, super_class
            _ (Classfile'skipFully-2 stream, (* (#_"DataInputStream" .readUnsignedShort stream) 2)) ;; interfaces
            _ (Classfile'skipFields-1 stream)                                                       ;; fields
            #_"List<ClassfileBytecode>" methods (Classfile'readMethods-3 stream, cp, type)          ;; methods
            _ (Classfile'skipAttributes-1 stream)                                                   ;; attributes
        ]
            (merge (Classfile'class.)
                (hash-map
                    #_"ResolvedJavaType" :type type
                    #_"List<ClassfileBytecode>" :codeAttributes methods
                )
            )
        )
    )

    (defn #_"ClassfileBytecode" Classfile''getCode-3 [#_"Classfile" this, #_"String" name, #_"String" descriptor]
        (loop-when [#_"ISeq" s (seq (:codeAttributes this))] (some? s) => (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName (:type this)) "." name descriptor)))
            (let [
                #_"ClassfileBytecode" code (first s)
                #_"ResolvedJavaMethod" method (Bytecode'''getMethod-1 code)
            ]
                (when (and (= (#_"ResolvedJavaMethod" .getName method) name) (= (#_"Signature" .toMethodDescriptor (#_"ResolvedJavaMethod" .getSignature method)) descriptor)) => (recur (next s))
                    code
                )
            )
        )
    )
)

;;;
 ; The bytecode properties of a method as parsed directly from a class file without any
 ; instrumentation or other rewriting performed on the bytecode.
 ;;
(class-ns ClassfileBytecode [Bytecode]
    (def- #_"int" ClassfileBytecode'EXCEPTION_HANDLER_TABLE_SIZE_IN_BYTES 8)

    (defn- #_"void" ClassfileBytecode'skipCodeAttributes-1 [#_"DataInputStream" stream]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
        ]
            (dotimes [#_"int" i n]
                (#_"DataInputStream" .readUnsignedShort stream)
                (Classfile'skipFully-2 stream, (#_"DataInputStream" .readInt stream))
            )
        )
        nil
    )

    (defn #_"ClassfileBytecode" ClassfileBytecode'new-3 [#_"ResolvedJavaMethod" method, #_"DataInputStream" stream, #_"ClassfileConstantPool" constantPool]
        (let [
            #_"int" maxStack (#_"DataInputStream" .readUnsignedShort stream)
            #_"int" maxLocals (#_"DataInputStream" .readUnsignedShort stream)
            #_"int" codeLength (#_"DataInputStream" .readInt stream)
            #_"byte[]" code (byte-array codeLength)
            _ (#_"DataInputStream" .readFully stream, code)
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
            _ (Classfile'skipFully-2 stream, (* n ClassfileBytecode'EXCEPTION_HANDLER_TABLE_SIZE_IN_BYTES))
            _ (ClassfileBytecode'skipCodeAttributes-1 stream)
        ]
            (merge (ClassfileBytecode'class.)
                (hash-map
                    #_"ResolvedJavaMethod" :method method
                    #_"ClassfileConstantPool" :constantPool constantPool
                    #_"byte[]" :code code
                    #_"int" :maxStack maxStack
                    #_"int" :maxLocals maxLocals
                )
            )
        )
    )

    (defm ClassfileBytecode Bytecode
        (#_"byte[]" Bytecode'''getCode-1 [#_"ClassfileBytecode" this]
            (:code this)
        )

        (#_"int" Bytecode'''getCodeSize-1 [#_"ClassfileBytecode" this]
            (count (:code this))
        )

        (#_"int" Bytecode'''getMaxLocals-1 [#_"ClassfileBytecode" this]
            (:maxLocals this)
        )

        (#_"int" Bytecode'''getMaxStackSize-1 [#_"ClassfileBytecode" this]
            (:maxStack this)
        )

        (#_"ConstantPool" Bytecode'''getConstantPool-1 [#_"ClassfileBytecode" this]
            (:constantPool this)
        )

        (#_"ResolvedJavaMethod" Bytecode'''getMethod-1 [#_"ClassfileBytecode" this]
            (:method this)
        )
    )
)

;;;
 ; A BytecodeProvider that provides bytecode properties of a ResolvedJavaMethod as parsed from a class file.
 ; This avoids all {@linkplain java.lang.instrument.Instrumentation instrumentation} and any bytecode
 ; rewriting performed by the VM.
 ;
 ; This mechanism retrieves class files based on the name and ClassLoader of existing Class instances.
 ; It bypasses all VM parsing and verification of the class file and assumes the class files are well formed.
 ; As such, it should only be used for classes from a trusted source such as the boot class (or module) path.
 ;
 ; A combination of Class#forName(String) and an existing MetaAccessProvider is used to resolve
 ; constant pool references. This opens up the opportunity for linkage errors if the referee is structurally
 ; changed through redefinition (e.g. a referred to method is renamed or deleted). This will result in an
 ; appropriate LinkageError being thrown. The only way to avoid this is to have a completely isolated
 ; {@code jdk.vm.ci.meta} implementation for parsing snippet/intrinsic bytecodes.
 ;;
(class-ns ClassfileBytecodeProvider [BytecodeProvider]
    (defn #_"ClassfileBytecodeProvider" ClassfileBytecodeProvider'new-0 []
        (let [
            #_"ClassfileBytecodeProvider" this
                (merge (ClassfileBytecodeProvider'class.)
                    (hash-map
                        #_"ClassLoader" :loader nil
                        #_"EconomicMap<Class, Classfile>" :classfiles (EconomicMap/create)
                        #_"EconomicMap<String, Class>" :classes (EconomicMap/create)
                        #_"EconomicMap<ResolvedJavaType, FieldsCache>" :fields (EconomicMap/create)
                        #_"EconomicMap<ResolvedJavaType, MethodsCache>" :methods (EconomicMap/create)
                    )
                )
            this (assoc this :loader (or (#_"Class" .getClassLoader (#_"Object" .getClass this)) (ClassLoader/getSystemClassLoader)))
        ]
            this
        )
    )

    ;;;
     ; Gets the class file bytes for {@code c}.
     ;;
    (defn- #_"InputStream" ClassfileBytecodeProvider'getClassfileAsStream-1 [#_"Class" c]
        (#_"Module" .getResourceAsStream (#_"Class" .getModule c), (str (#_"String" .replace (#_"Class" .getName c), (ยง char "."), (ยง char "/")) ".class"))
    )

    ;;;
     ; Gets a Classfile created by parsing the class file bytes for {@code c}.
     ;
     ; @throws NoClassDefFoundError if the class file cannot be found
     ;;
    (defn- #_"Classfile" ClassfileBytecodeProvider''getClassfile-2 [#_"ClassfileBytecodeProvider" this, #_"Class" c]
        (locking this
            (or (get (:classfiles this) c)
                (let [
                    #_"ResolvedJavaType" type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, c)
                    #_"InputStream" in (ClassfileBytecodeProvider'getClassfileAsStream-1 c)
                ]
                    (when (some? in) => (throw (NoClassDefFoundError. (#_"Class" .getName c)))
                        (let [
                            #_"Classfile" classfile (Classfile'new-3 type, (DataInputStream. in), this)
                        ]
                            (#_"EconomicMap" .put (:classfiles this), c, classfile)
                            classfile
                        )
                    )
                )
            )
        )
    )

    (defn #_"Class" ClassfileBytecodeProvider''resolveToClass-2 [#_"ClassfileBytecodeProvider" this, #_"String" descriptor]
        (locking this
            (or (get (:classes this) descriptor)
                (if (= (count descriptor) 1)
                    (#_"JavaKind" .toJavaClass (JavaKind/fromPrimitiveOrVoidTypeChar (nth descriptor 0)))
                    (let [
                        #_"int" dims (loop-when-recur [dims 0] (= (nth descriptor dims) (ยง char "[")) [(inc dims)] => dims)
                        #_"String" name
                            (if (and (zero? dims) (#_"String" .startsWith descriptor, "L") (#_"String" .endsWith descriptor, ";"))
                                (#_"String" .replace (#_"String" .substring descriptor, 1, (dec (count descriptor))), (ยง char "/"), (ยง char "."))
                                (#_"String" .replace                        descriptor,                               (ยง char "/"), (ยง char "."))
                            )
                        #_"Class" c (Class/forName name, true, (:loader this))
                    ]
                        (#_"EconomicMap" .put (:classes this), descriptor, c)
                        c
                    )
                )
            )
        )
    )

    (defm ClassfileBytecodeProvider BytecodeProvider
        (#_"Bytecode" BytecodeProvider'''getBytecode-2 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaMethod" method]
            (let [
                #_"Classfile" classfile (ClassfileBytecodeProvider''getClassfile-2 this, (ClassfileBytecodeProvider''resolveToClass-2 this, (#_"ResolvedJavaType" .getName (#_"ResolvedJavaMethod" .getDeclaringClass method))))
            ]
                (Classfile''getCode-3 classfile, (#_"ResolvedJavaMethod" .getName method), (#_"Signature" .toMethodDescriptor (#_"ResolvedJavaMethod" .getSignature method)))
            )
        )
    )

    ;;;
     ; Gets the methods cache for {@code type}.
     ;
     ; Synchronized since the cache is lazily created.
     ;;
    (defn- #_"MethodsCache" ClassfileBytecodeProvider''getMethods-2 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type]
        (locking this
            (let [
                #_"MethodsCache" methodsCache (get (:methods this) type)
            ]
                (when (nil? methodsCache)
                    (ยง ass methodsCache (MethodsCache'new-0))
                    (#_"EconomicMap" .put (:methods this), type, methodsCache)
                )
                methodsCache
            )
        )
    )

    ;;;
     ; Gets the fields cache for {@code type}.
     ;
     ; Synchronized since the cache is lazily created.
     ;;
    (defn- #_"FieldsCache" ClassfileBytecodeProvider''getFields-2 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type]
        (locking this
            (let [
                #_"FieldsCache" fieldsCache (get (:fields this) type)
            ]
                (when (nil? fieldsCache)
                    (ยง ass fieldsCache (FieldsCache'new-0))
                    (#_"EconomicMap" .put (:fields this), type, fieldsCache)
                )
                fieldsCache
            )
        )
    )

    (defn #_"ResolvedJavaField" ClassfileBytecodeProvider''findField-5 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" fieldType, #_"boolean" static?]
        (FieldsCache''lookup-5 (ClassfileBytecodeProvider''getFields-2 this, type), type, name, fieldType, static?)
    )

    (defn #_"ResolvedJavaMethod" ClassfileBytecodeProvider''findMethod-5 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" descriptor, #_"boolean" static?]
        (let [
            #_"ResolvedJavaMethod" method (MethodsCache''lookup-4 (ClassfileBytecodeProvider''getMethods-2 this, type), type, name, descriptor)
        ]
            (when (and (some? method) (= (#_"ResolvedJavaMethod" .isStatic method) static?))
                method
            )
        )
    )
)

(class-ns ClassfileConstant []
    (def #_"byte" ClassfileConstant'CONSTANT_Utf8               1)
    (def #_"byte" ClassfileConstant'CONSTANT_Integer            3)
    (def #_"byte" ClassfileConstant'CONSTANT_Float              4)
    (def #_"byte" ClassfileConstant'CONSTANT_Long               5)
    (def #_"byte" ClassfileConstant'CONSTANT_Double             6)
    (def #_"byte" ClassfileConstant'CONSTANT_Class              7)
    (def #_"byte" ClassfileConstant'CONSTANT_Fieldref           9)
    (def #_"byte" ClassfileConstant'CONSTANT_String             8)
    (def #_"byte" ClassfileConstant'CONSTANT_Methodref          10)
    (def #_"byte" ClassfileConstant'CONSTANT_InterfaceMethodref 11)
    (def #_"byte" ClassfileConstant'CONSTANT_NameAndType        12)
    (def #_"byte" ClassfileConstant'CONSTANT_MethodHandle       15)
    (def #_"byte" ClassfileConstant'CONSTANT_MethodType         16)
    (def #_"byte" ClassfileConstant'CONSTANT_Dynamic            17)
    (def #_"byte" ClassfileConstant'CONSTANT_InvokeDynamic      18)

    (defn #_"ClassfileConstant" ClassfileConstant'new-1 [#_"byte" tag]
        (merge (ClassfileConstant'class.)
            (hash-map
                #_"byte" :tag tag
            )
        )
    )

    (defm ClassfileConstant ClassfileConstant
        (#_"void" ClassfileConstant'''loadReferencedType-4 [#_"ClassfileConstant" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
            nil
        )
    )

    (defn #_"ResolvedJavaMethod" ClassfileConstant'resolveMethod-5 [#_"ClassfileBytecodeProvider" context, #_"ResolvedJavaType" type, #_"String" name, #_"String" descriptor, #_"boolean" static?]
        (or (ClassfileBytecodeProvider''findMethod-5 context, type, name, descriptor, static?)
            (when-not (or (#_"ResolvedJavaType" .isJavaLangObject type) (#_"ResolvedJavaType" .isInterface type))
                (ClassfileConstant'resolveMethod-5 context, (#_"ResolvedJavaType" .getSuperclass type), name, descriptor, static?)
            )
            (loop-when [#_"ISeq" s (seq (#_"ResolvedJavaType" .getInterfaces type))] (some? s)
                (or (ClassfileConstant'resolveMethod-5 context, (first s), name, descriptor, static?)
                    (recur (next s))
                )
            )
        )
    )

    (defn #_"ResolvedJavaField" ClassfileConstant'resolveField-5 [#_"ClassfileBytecodeProvider" context, #_"ResolvedJavaType" type, #_"String" name, #_"String" fieldType, #_"boolean" static?]
        (or (ClassfileBytecodeProvider''findField-5 context, type, name, fieldType, static?)
            (when-not (or (#_"ResolvedJavaType" .isJavaLangObject type) (#_"ResolvedJavaType" .isInterface type))
                (ClassfileConstant'resolveField-5 context, (#_"ResolvedJavaType" .getSuperclass type), name, fieldType, static?)
            )
            (loop-when [#_"ISeq" s (seq (#_"ResolvedJavaType" .getInterfaces type))] (some? s)
                (or (ClassfileConstant'resolveField-5 context, (first s), name, fieldType, static?)
                    (recur (next s))
                )
            )
        )
    )
)

(class-ns ClassRef [ClassfileConstant]
    (defn #_"ClassRef" ClassRef'new-1 [#_"DataInputStream" stream]
        (merge (ClassRef'class.) (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_Class)
            (hash-map
                #_"int" :nameIndex (#_"DataInputStream" .readUnsignedShort stream)
                #_"ResolvedJavaType" :type nil
            )
        )
    )

    (defm ClassRef ClassfileConstant
        (#_"void" ClassfileConstant'''loadReferencedType-4 [#_"ClassRef" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
            (ClassRef''resolve-2 this, cp)
            nil
        )
    )

    (defn #_"ResolvedJavaType" ClassRef''resolve-2 [#_"ClassRef" this, #_"ClassfileConstantPool" cp]
        (when (nil? (:type this))
            (ยง ass! this (assoc this :type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (ClassfileBytecodeProvider''resolveToClass-2 (:context cp), (:value (ClassfileConstantPool''get-3 cp, Utf8'iface, (:nameIndex this)))))))
        )
        (:type this)
    )
)

(class-ns MemberRef [ClassfileConstant]
    (defn #_"MemberRef" MemberRef'new-2 [#_"byte" tag, #_"DataInputStream" stream]
        (merge (MemberRef'class.) (ClassfileConstant'new-1 tag)
            (hash-map
                #_"int" :classIndex (#_"DataInputStream" .readUnsignedShort stream)
                #_"int" :nameAndTypeIndex (#_"DataInputStream" .readUnsignedShort stream)
            )
        )
    )

    (defm MemberRef ClassfileConstant
        (#_"void" ClassfileConstant'''loadReferencedType-4 [#_"MemberRef" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
            (ClassfileConstant'''loadReferencedType-4 (ClassfileConstantPool''get-3 cp, ClassRef'iface, (:classIndex this)), cp, (:classIndex this), opcode)
            nil
        )
    )
)

(class-ns ExecutableRef [MemberRef, ClassfileConstant]
    (defn #_"ExecutableRef" ExecutableRef'new-2 [#_"byte" tag, #_"DataInputStream" stream]
        (merge (ExecutableRef'class.) (MemberRef'new-2 tag, stream)
            (hash-map
                #_"ResolvedJavaMethod" :method nil
            )
        )
    )

    (defn #_"ResolvedJavaMethod" ExecutableRef''resolve-3 [#_"ExecutableRef" this, #_"ClassfileConstantPool" cp, #_"int" opcode]
        (when (nil? (:method this))
            (let [
                #_"ResolvedJavaType" cls (ClassRef''resolve-2 (ClassfileConstantPool''get-3 cp, ClassRef'iface, (:classIndex this)), cp)
                #_"NameAndType" nameAndType (ClassfileConstantPool''get-3 cp, NameAndType'iface, (:nameAndTypeIndex this))
                #_"String" name (NameAndType''getName-2 nameAndType, cp)
                #_"String" type (NameAndType''getType-2 nameAndType, cp)
            ]
                (cond
                    (= opcode Bytecodes'INVOKEINTERFACE)
                        (do
                            (ยง ass! this (assoc this :method (ClassfileConstant'resolveMethod-5 (:context cp), cls, name, type, false)))
                            (when (nil? (:method this))
                                (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name type)))
                            )
                            (when (or (not (#_"ResolvedJavaMethod" .isPublic (:method this))) (not (or (#_"ResolvedJavaType" .isInterface (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))) (#_"ResolvedJavaType" .isJavaLangObject (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))))))
                                (throw (IncompatibleClassChangeError. (str "cannot invokeinterface " (#_"ResolvedJavaMethod" .format (:method this), "%H.\n(%P)%R"))))
                            )
                        )
                    (any = opcode Bytecodes'INVOKEVIRTUAL Bytecodes'INVOKESPECIAL)
                        (do
                            (ยง ass! this (assoc this :method (ClassfileConstant'resolveMethod-5 (:context cp), cls, name, type, false)))
                            (when (nil? (:method this))
                                (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name type)))
                            )
                        )
                    :else
                        (do
                            (ยง ass! this (assoc this :method (ClassfileConstant'resolveMethod-5 (:context cp), cls, name, type, true)))
                            (when (nil? (:method this))
                                (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name type)))
                            )
                        )
                )
            )
        )
        (:method this)
    )
)

(class-ns InterfaceMethodRef [ExecutableRef, MemberRef, ClassfileConstant]
    (defn #_"InterfaceMethodRef" InterfaceMethodRef'new-1 [#_"DataInputStream" stream]
        (merge (InterfaceMethodRef'class.) (ExecutableRef'new-2 ClassfileConstant'CONSTANT_InterfaceMethodref, stream))
    )
)

(class-ns MethodRef [ExecutableRef, MemberRef, ClassfileConstant]
    (defn #_"MethodRef" MethodRef'new-1 [#_"DataInputStream" stream]
        (merge (MethodRef'class.) (ExecutableRef'new-2 ClassfileConstant'CONSTANT_Methodref, stream))
    )
)

(class-ns FieldRef [MemberRef, ClassfileConstant]
    (defn #_"FieldRef" FieldRef'new-1 [#_"DataInputStream" stream]
        (merge (FieldRef'class.) (MemberRef'new-2 ClassfileConstant'CONSTANT_Fieldref, stream)
            (hash-map
                #_"ResolvedJavaField" :field nil
            )
        )
    )

    (defn #_"ResolvedJavaField" FieldRef''resolve-3 [#_"FieldRef" this, #_"ClassfileConstantPool" cp, #_"int" opcode]
        (when (nil? (:field this))
            (let [
                #_"ResolvedJavaType" cls (ClassRef''resolve-2 (ClassfileConstantPool''get-3 cp, ClassRef'iface, (:classIndex this)), cp)
                #_"NameAndType" nameAndType (ClassfileConstantPool''get-3 cp, NameAndType'iface, (:nameAndTypeIndex this))
                #_"String" name (NameAndType''getName-2 nameAndType, cp)
                #_"String" type (NameAndType''getType-2 nameAndType, cp)
            ]
                (ยง ass! this (assoc this :field (ClassfileConstant'resolveField-5 (:context cp), cls, name, type, (any = opcode Bytecodes'GETSTATIC Bytecodes'PUTSTATIC))))
                (when (nil? (:field this))
                    (throw (NoSuchFieldError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name " " type)))
                )
            )
        )
        (:field this)
    )
)

(class-ns NameAndType [ClassfileConstant]
    (defn #_"NameAndType" NameAndType'new-1 [#_"DataInputStream" stream]
        (merge (NameAndType'class.) (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_NameAndType)
            (hash-map
                #_"int" :nameIndex (#_"DataInputStream" .readUnsignedShort stream)
                #_"int" :typeIndex (#_"DataInputStream" .readUnsignedShort stream)
                #_"String" :name nil
                #_"String" :type nil
            )
        )
    )

    (defn #_"String" NameAndType''getName-2 [#_"NameAndType" this, #_"ClassfileConstantPool" cp]
        (when (nil? (:name this))
            (ยง ass! this (assoc this :name (:value (ClassfileConstantPool''get-3 cp, Utf8'iface, (:nameIndex this)))))
        )
        (:name this)
    )

    (defn #_"String" NameAndType''getType-2 [#_"NameAndType" this, #_"ClassfileConstantPool" cp]
        (when (nil? (:type this))
            (ยง ass! this (assoc this :type (:value (ClassfileConstantPool''get-3 cp, Utf8'iface, (:typeIndex this)))))
        )
        (:type this)
    )
)

(class-ns Primitive [ClassfileConstant]
    (defn #_"Primitive" Primitive'new-2 [#_"byte" tag, #_"JavaConstant" value]
        (merge (Primitive'class.) (ClassfileConstant'new-1 tag)
            (hash-map
                #_"JavaConstant" :value value
            )
        )
    )
)

(class-ns StringRef [ClassfileConstant]
    (defn #_"StringRef" StringRef'new-1 [#_"DataInputStream" stream]
        (merge (StringRef'class.) (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_String)
            (hash-map
                #_"int" :stringIndex (#_"DataInputStream" .readUnsignedShort stream)
                #_"JavaConstant" :value nil
            )
        )
    )

    (defn #_"JavaConstant" StringRef''getValue-2 [#_"StringRef" this, #_"ClassfileConstantPool" pool]
        (when (nil? (:value this))
            (ยง ass! this (assoc this :value (SnippetReflection'forObject-1 (#_"ConstantPool" .lookupUtf8 pool, (:stringIndex this)))))
        )
        (:value this)
    )
)

(class-ns Unsupported [ClassfileConstant]
    (defn #_"Unsupported" Unsupported'new-2 [#_"byte" tag, #_"String" name]
        (merge (Unsupported'class.) (ClassfileConstant'new-1 tag)
            (hash-map
                #_"String" :name name
            )
        )
    )

    (defm Unsupported ClassfileConstant
        (#_"void" ClassfileConstant'''loadReferencedType-4 [#_"Unsupported" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
            (throw! (str "Resolution of " (:name this) " constant pool entries not supported by " (#_"Class" .getSimpleName ClassfileBytecodeProvider'iface)))
        )
    )
)

(class-ns Utf8 [ClassfileConstant]
    (defn #_"Utf8" Utf8'new-1 [#_"String" value]
        (merge (Utf8'class.) (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_Utf8)
            (hash-map
                #_"String" :value value
            )
        )
    )
)

(class-ns ClassfileConstantPool [#_"ConstantPool"]
    (defn- #_"ClassfileConstant" ClassfileConstantPool'readConstant-1 [#_"DataInputStream" stream]
        (let [
            #_"byte" tag (#_"DataInputStream" .readByte stream)
        ]
            (condp = tag
                ClassfileConstant'CONSTANT_Class              (ClassRef'new-1 stream)
                ClassfileConstant'CONSTANT_Fieldref           (FieldRef'new-1 stream)
                ClassfileConstant'CONSTANT_Methodref          (MethodRef'new-1 stream)
                ClassfileConstant'CONSTANT_InterfaceMethodref (InterfaceMethodRef'new-1 stream)
                ClassfileConstant'CONSTANT_String             (StringRef'new-1 stream)
                ClassfileConstant'CONSTANT_Integer            (Primitive'new-2 tag, (JavaConstant/forInt (#_"DataInputStream" .readInt stream)))
                ClassfileConstant'CONSTANT_Long               (Primitive'new-2 tag, (JavaConstant/forLong (#_"DataInputStream" .readLong stream)))
                ClassfileConstant'CONSTANT_NameAndType        (NameAndType'new-1 stream)
                ClassfileConstant'CONSTANT_Utf8               (Utf8'new-1 (#_"DataInputStream" .readUTF stream))
                ClassfileConstant'CONSTANT_MethodHandle
                (do
                    (Classfile'skipFully-2 stream, 3) ;; reference_kind, reference_index
                    (Unsupported'new-2 tag, "CONSTANT_MethodHandle_info")
                )
                ClassfileConstant'CONSTANT_MethodType
                (do
                    (Classfile'skipFully-2 stream, 2) ;; descriptor_index
                    (Unsupported'new-2 tag, "CONSTANT_MethodType_info")
                )
                ClassfileConstant'CONSTANT_Dynamic
                (do
                    (Classfile'skipFully-2 stream, 4) ;; bootstrap_method_attr_index, name_and_type_index
                    (Unsupported'new-2 tag, "CONSTANT_Dynamic_info")
                )
                ClassfileConstant'CONSTANT_InvokeDynamic
                (do
                    (Classfile'skipFully-2 stream, 4) ;; bootstrap_method_attr_index, name_and_type_index
                    (Unsupported'new-2 tag, "CONSTANT_InvokeDynamic_info")
                )
            )
        )
    )

    (defn #_"ClassfileConstantPool" ClassfileConstantPool'new-2 [#_"DataInputStream" stream, #_"ClassfileBytecodeProvider" context]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
            #_"ClassfileConstant[]" entries (make-array ClassfileConstant'iface n)
            _
                (loop-when-recur [#_"int" i 1] (< i n) [(+ i (if (any = (:tag (nth entries i)) ClassfileConstant'CONSTANT_Double ClassfileConstant'CONSTANT_Long) 2 1))]
                    (aset entries i (ClassfileConstantPool'readConstant-1 stream))
                )
        ]
            (merge (ClassfileConstantPool'class.)
                (hash-map
                    #_"ClassfileConstant[]" :entries entries
                    #_"ClassfileBytecodeProvider" :context context
                )
            )
        )
    )

    (ยง override! #_"int" #_"ConstantPool." length [#_"ClassfileConstantPool" this]
        (count (:entries this))
    )

    (defn #_"<T implements ClassfileConstant> T" ClassfileConstantPool''get-3 [#_"ClassfileConstantPool" this, #_"Class<T>" c, #_"int" index]
        (#_"Class" .cast c, (nth (:entries this) index))
    )

    (ยง override! #_"void" #_"ConstantPool." loadReferencedType [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (when (= opcode Bytecodes'INVOKEDYNAMIC)
            (throw! (str "INVOKEDYNAMIC not supported by " (#_"Class" .getSimpleName ClassfileBytecodeProvider'iface)))
        )
        (ClassfileConstant'''loadReferencedType-4 (nth (:entries this) index), this, index, opcode)
        nil
    )

    (ยง override! #_"JavaField" #_"ConstantPool." lookupField [#_"ClassfileConstantPool" this, #_"int" index, #_"ResolvedJavaMethod" method, #_"int" opcode]
        (FieldRef''resolve-3 (ClassfileConstantPool''get-3 this, FieldRef'iface, index), this, opcode)
    )

    (ยง override! #_"JavaMethod" #_"ConstantPool." lookupMethod [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (when (= opcode Bytecodes'INVOKEDYNAMIC)
            (throw! (str "INVOKEDYNAMIC not supported by" (#_"Class" .getSimpleName ClassfileBytecodeProvider'iface)))
        )
        (ExecutableRef''resolve-3 (ClassfileConstantPool''get-3 this, ExecutableRef'iface, index), this, opcode)
    )

    (ยง override! #_"JavaType" #_"ConstantPool." lookupType [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (ClassRef''resolve-2 (ClassfileConstantPool''get-3 this, ClassRef'iface, index), this)
    )

    (ยง override! #_"String" #_"ConstantPool." lookupUtf8 [#_"ClassfileConstantPool" this, #_"int" index]
        (:value (ยง cast #_"Utf8" (nth (:entries this) index)))
    )

    (ยง override! #_"Object" #_"ConstantPool." lookupConstant [#_"ClassfileConstantPool" this, #_"int" index]
        (let [
            #_"ClassfileConstant" c (nth (:entries this) index)
        ]
            (if (satisfies? Primitive c)
                (:value c)
                (condp = (:tag c)
                    ClassfileConstant'CONSTANT_Class  (#_"ConstantPool" .lookupType this, index, -1)
                    ClassfileConstant'CONSTANT_String (StringRef''getValue-2 this, c)
                    (throw! (str "unexpected constant pool tag " (:tag c)))
                )
            )
        )
    )

    (ยง override! #_"JavaConstant" #_"ConstantPool." lookupAppendix [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (when-not (= opcode Bytecodes'INVOKEVIRTUAL)
            (throw! "should not reach here")
        )
    )
)

;;;
 ; Code buffer management for the assembler.
 ;;
(class-ns CodeBuffer []
    (def #_"int" CodeBuffer'InitialSize 232)

    (defn #_"CodeBuffer" CodeBuffer'new-1 [#_"ByteOrder" order]
        (let [
            #_"CodeBuffer" this
                (merge (CodeBuffer'class.)
                    (hash-map
                        #_"ByteBuffer" :data (ByteBuffer/allocate CodeBuffer'InitialSize)
                    )
                )
        ]
            (#_"ByteBuffer" .order (:data this), order)
            this
        )
    )

    (defn #_"int" CodeBuffer''position-1 [#_"CodeBuffer" this]
        (#_"ByteBuffer" .position (:data this))
    )

    (defn- #_"CodeBuffer" CodeBuffer''ensureSize-2 [#_"CodeBuffer" this, #_"int" n]
        (when (<= (#_"ByteBuffer" .limit (:data this)) n) => this
            (let [
                #_"ByteBuffer" data (ByteBuffer/wrap (Arrays/copyOf (#_"ByteBuffer" .array (:data this)), (* n 4)))
            ]
                (#_"ByteBuffer" .order data, (#_"ByteBuffer" .order (:data this)))
                (#_"ByteBuffer" .position data, (#_"ByteBuffer" .position (:data this)))
                (assoc this :data data)
            )
        )
    )

    (defn #_"this" CodeBuffer''emitByte-2 [#_"CodeBuffer" this, #_"int" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 1))
        ]
            (#_"ByteBuffer" .put (:data this), (byte (& b 0xff)))
            this
        )
    )

    (defn #_"this" CodeBuffer''emitShort-2 [#_"CodeBuffer" this, #_"int" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 2))
        ]
            (#_"ByteBuffer" .putShort (:data this), (short b))
            this
        )
    )

    (defn #_"this" CodeBuffer''emitInt-2 [#_"CodeBuffer" this, #_"int" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 4))
        ]
            (#_"ByteBuffer" .putInt (:data this), b)
            this
        )
    )

    (defn #_"this" CodeBuffer''emitLong-2 [#_"CodeBuffer" this, #_"long" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 8))
        ]
            (#_"ByteBuffer" .putLong (:data this), b)
            this
        )
    )

    (defn #_"this" CodeBuffer''emitByte-3 [#_"CodeBuffer" this, #_"int" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 1))
        ]
            (#_"ByteBuffer" .put (:data this), i, (byte (& b 0xff)))
            this
        )
    )

    (defn #_"this" CodeBuffer''emitShort-3 [#_"CodeBuffer" this, #_"int" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 2))
        ]
            (#_"ByteBuffer" .putShort (:data this), i, (short b))
            this
        )
    )

    (defn #_"this" CodeBuffer''emitInt-3 [#_"CodeBuffer" this, #_"int" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 4))
        ]
            (#_"ByteBuffer" .putInt (:data this), i, b)
            this
        )
    )

    (defn #_"this" CodeBuffer''emitLong-3 [#_"CodeBuffer" this, #_"long" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 8))
        ]
            (#_"ByteBuffer" .putLong (:data this), i, b)
            this
        )
    )

    (defn #_"int" CodeBuffer''getByte-2 [#_"CodeBuffer" this, #_"int" i]
        (let [
            #_"int" b (#_"ByteBuffer" .get (:data this), i)
        ]
            (& b 0xff)
        )
    )

    (defn #_"int" CodeBuffer''getShort-2 [#_"CodeBuffer" this, #_"int" i]
        (let [
            #_"short" s (#_"ByteBuffer" .getShort (:data this), i)
        ]
            (& s 0xffff)
        )
    )

    (defn #_"int" CodeBuffer''getInt-2 [#_"CodeBuffer" this, #_"int" i]
        (#_"ByteBuffer" .getInt (:data this), i)
    )

    ;;;
     ; Closes this buffer. Any further operations on a closed buffer will result in a NullPointerException.
     ;
     ; @param trim? if true, then a copy of the underlying byte array up to (but not including) {@code position()} is returned
     ; @return the data in this buffer or a trimmed copy if {@code trim?} is true
     ;;
    (defn #_"byte[]" CodeBuffer''close-2 [#_"CodeBuffer" this, #_"boolean" trim?]
        (let [
            #_"byte[]" a (#_"ByteBuffer" .array (:data this))
            a
                (when trim? => a
                    ;; Make a copy even if a.length == data.position(),
                    ;; since the API for trim? states a copy is always made.
                    (Arrays/copyOf a, (#_"ByteBuffer" .position (:data this)))
                )
        ]
            (ยง ass! this (assoc this :data nil))
            a
        )
    )
)

(class-ns CompareOp []
    (defn #_"CompareOp" CompareOp'new-0 []
        (CompareOp'class.)
    )

    (defn- #_"LogicNode" CompareOp'optimizeConditional-3 [#_"Constant" constant, #_"ConditionalNode" conditionalNode, #_"Condition" condition]
        (let [
            #_"Constant" trueConstant (ValueNode''asConstant-1 (:trueValue conditionalNode))
            #_"Constant" falseConstant (ValueNode''asConstant-1 (:falseValue conditionalNode))
        ]
            (when (and (some? falseConstant) (some? trueConstant) (some? HotSpot'constantReflection))
                (let [
                    #_"boolean" trueResult (Condition''foldCondition-3c condition, trueConstant, constant)
                    #_"boolean" falseResult (Condition''foldCondition-3c condition, falseConstant, constant)
                ]
                    (cond
                        (= trueResult falseResult) (LogicConstantNode'forBoolean-1 trueResult)
                        trueResult                 (:logic conditionalNode)
                        :else                      (LogicNegationNode'create-1 (:logic conditionalNode))
                    )
                )
            )
        )
    )

    (defn- #_"ConstantNode" CompareOp'canonicalConvertConstant-3 [#_"CanonicalCondition" condition, #_"ConvertNode" convert, #_"Constant" constant]
        (when (ConvertNode'''preservesOrder-3 convert, condition, constant)
            (let [
                #_"Constant" reverseConverted (ConvertNode'''reverse-2 convert, constant)
            ]
                (when (and (some? reverseConverted) (= (ConvertNode'''convert-2 convert, reverseConverted) constant))
                    (ConstantNode'forConstant-2s (:stamp (ConvertNode'''getValue-1 convert)), reverseConverted)
                )
            )
        )
    )

    (defm CompareOp CompareOp
        (#_"LogicNode" CompareOp'''canonical-5 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareNode'tryConstantFold-3 condition, forX, forY)
                (cond
                    (satisfies? ConstantNode forX)
                        (CompareOp'''canonicalizeSymmetricConstant-6 this, smallestCompareWidth, condition, (:value forX), forY, true)
                    (satisfies? ConstantNode forY)
                        (CompareOp'''canonicalizeSymmetricConstant-6 this, smallestCompareWidth, condition, (:value forY), forX, false)
                    (and (satisfies? ConvertNode forX) (satisfies? ConvertNode forY))
                        (when (and (ConvertNode'''preservesOrder-2 forX, condition) (ConvertNode'''preservesOrder-2 forY, condition) (Stamp'''isCompatible-2s (:stamp (ConvertNode'''getValue-1 forX)), (:stamp (ConvertNode'''getValue-1 forY))))
                            (let [
                                #_"boolean" supported?
                                    (when (satisfies? IntegerStamp (:stamp (ConvertNode'''getValue-1 forX))) => true
                                        (and (some? smallestCompareWidth) (<= smallestCompareWidth (:bits (:stamp (ConvertNode'''getValue-1 forX)))))
                                    )
                            ]
                                (when supported?
                                    ;; do not perform for zero or sign extend if there are multiple usages of the value
                                    (when-not (and (or (satisfies? ZeroExtendNode forX) (satisfies? SignExtendNode forX)) (or (Node''hasMoreThanOneUsage-1 forX) (Node''hasMoreThanOneUsage-1 forY)))
                                        (CompareOp'''duplicateModified-3 this, (ConvertNode'''getValue-1 forX), (ConvertNode'''getValue-1 forY))
                                    )
                                )
                            )
                        )
                )
            )
        )

        (#_"LogicNode" CompareOp'''canonicalizeSymmetricConstant-6 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?]
            (condp satisfies? node
                ConditionalNode
                    (CompareOp'optimizeConditional-3 constant, node, (if mirrored? (Condition''mirror-1 (:canonical condition)) (:canonical condition)))
                NormalizeCompareNode
                    (CompareOp'''optimizeNormalizeCompare-5 this, smallestCompareWidth, constant, node, mirrored?)
                ConvertNode
                    ;; do not perform for zero or sign extend if it could introduce new live values
                    (when-not (and (or (satisfies? ZeroExtendNode node) (satisfies? SignExtendNode node)) (Node''hasMoreThanOneUsage-1 node) (Node''hasExactlyOneUsage-1 (ConvertNode'''getValue-1 node)))
                        (let [
                            #_"Stamp" stamp (:stamp (ConvertNode'''getValue-1 node))
                            #_"boolean" supported?
                                (when (satisfies? IntegerStamp stamp) => true
                                    (and (some? smallestCompareWidth) (< smallestCompareWidth (:bits stamp)))
                                )
                        ]
                            (when supported?
                                (let [
                                    #_"ConstantNode" newConstant (CompareOp'canonicalConvertConstant-3 condition, node, constant)
                                ]
                                    (when (some? newConstant)
                                        (if mirrored?
                                            (CompareOp'''duplicateModified-3 this, newConstant, (ConvertNode'''getValue-1 node))
                                            (CompareOp'''duplicateModified-3 this, (ConvertNode'''getValue-1 node), newConstant)
                                        )
                                    )
                                )
                            )
                        )
                    )
                nil
            )
        )

        (#_"LogicNode" CompareOp'''optimizeNormalizeCompare-5 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?]
            (throw! (str "NormalizeCompareNode connected to " this " (" constant " " normalizeNode " " mirrored? ")"))
        )
    )
)

(class-ns IntegerEqualsOp [CompareOp]
    (defn #_"IntegerEqualsOp" IntegerEqualsOp'new-0 []
        (merge (IntegerEqualsOp'class.) (CompareOp'new-0))
    )

    (defm IntegerEqualsOp CompareOp
        (#_"LogicNode" CompareOp'''optimizeNormalizeCompare-5 [#_"IntegerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?]
            (let [
                #_"ValueNode" a (:x normalizeNode)
                #_"ValueNode" b (:y normalizeNode)
            ]
                (condp = (#_"PrimitiveConstant" .asLong constant)
                    0 (IntegerEqualsNode'create-3   smallestCompareWidth, a, b)
                    1 (IntegerLessThanNode'create-3 smallestCompareWidth, b, a)
                   -1 (IntegerLessThanNode'create-3 smallestCompareWidth, a, b)
                      (LogicConstantNode'contradiction-0)
                )
            )
        )

        (#_"CompareNode" CompareOp'''duplicateModified-3 [#_"IntegerEqualsOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
            (cond
                (and (satisfies? IntegerStamp (:stamp newX)) (satisfies? IntegerStamp (:stamp newY)))                 (IntegerEqualsNode'new-2 newX, newY)
                (and (satisfies? AbstractPointerStamp (:stamp newX)) (satisfies? AbstractPointerStamp (:stamp newY))) (IntegerEqualsNode'new-2 newX, newY)
                :else                                                                                                 (throw! "should not reach here")
            )
        )

        (#_"LogicNode" CompareOp'''canonical-5 [#_"IntegerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
            (cond
                (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY)) (LogicConstantNode'tautology-0)
                (Stamp'''alwaysDistinct-2 (:stamp forX), (:stamp forY))         (LogicConstantNode'contradiction-0)
                :else
                    (do
                        (when (and (satisfies? AddNode forX) (satisfies? AddNode forY))
                            (let [
                                [#_"ValueNode" v1 #_"ValueNode" v2]
                                    (cond
                                        (= (:x forX) (:x forY)) [(:y forX) (:y forY)]
                                        (= (:x forX) (:y forY)) [(:y forX) (:x forY)]
                                        (= (:y forX) (:x forY)) [(:x forX) (:y forY)]
                                        (= (:y forX) (:y forY)) [(:x forX) (:x forY)]
                                    )
                            ]
                                (when (some? v1)
                                    (ยง return (IntegerEqualsNode'create-2 v1, v2))
                                )
                            )
                        )

                        (CompareOp'''canonical-5 (ยง super CompareOp'iface), smallestCompareWidth, condition, forX, forY)
                    )
            )
        )

        (#_"LogicNode" CompareOp'''canonicalizeSymmetricConstant-6 [#_"IntegerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?]
            (or
                (when (instance? PrimitiveConstant constant)
                    (or
                        (cond
                            (or (and (= (UnsignedLong''asLong-1 constant)  1) (= (:upperBound (:stamp node)) 1) (= (:lowerBound (:stamp node))  0))
                                (and (= (UnsignedLong''asLong-1 constant) -1) (= (:upperBound (:stamp node)) 0) (= (:lowerBound (:stamp node)) -1))
                            )
                                ;; nonConstant can only be 0 or 1 (respective -1), test against 0 instead of 1 (respective -1)
                                ;; for a more canonical graph and also to allow for faster execution on specific platforms
                                (LogicNegationNode'create-1 (IntegerEqualsNode'create-3 smallestCompareWidth, node, (ConstantNode'forIntegerKind-2 (ValueNode''getStackKind-1 node), 0)))
                            (zero? (UnsignedLong''asLong-1 constant))
                                (cond
                                    (satisfies? AndNode node)
                                        (IntegerTestNode'new-2 (:x node), (:y node))
                                    (satisfies? SubNode node)
                                        (IntegerEqualsNode'create-3 smallestCompareWidth, (:x node), (:y node))
                                    (and (satisfies? ShiftNode node) (satisfies? IntegerStamp (:stamp node)))
                                        (let [
                                            #_"int" mask (ShiftNode''getShiftAmountMask-1 node)
                                            #_"int" amount (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y node))) mask)
                                        ]
                                            (condp satisfies? node
                                                LeftShiftNode
                                                    (when (satisfies? ConstantNode (:y node))
                                                        (if (= (ValueNode''getStackKind-1 (:x node)) JavaKind/Int)
                                                            (IntegerTestNode'new-2 (:x node), (ConstantNode'forInt-1 (>>> -1 amount)))
                                                            (IntegerTestNode'new-2 (:x node), (ConstantNode'forLong-1 (>>> -1 amount)))
                                                        )
                                                    )
                                                RightShiftNode
                                                    (when (and (satisfies? ConstantNode (:y node)) (IntegerStamp''isPositive-1 (:stamp (:x node))))
                                                        (if (= (ValueNode''getStackKind-1 (:x node)) JavaKind/Int)
                                                            (IntegerTestNode'new-2 (:x node), (ConstantNode'forInt-1 (<< -1 amount)))
                                                            (IntegerTestNode'new-2 (:x node), (ConstantNode'forLong-1 (<< -1 amount)))
                                                        )
                                                    )
                                                UnsignedRightShiftNode
                                                    (when (satisfies? ConstantNode (:y node))
                                                        (if (= (ValueNode''getStackKind-1 (:x node)) JavaKind/Int)
                                                            (IntegerTestNode'new-2 (:x node), (ConstantNode'forInt-1 (<< -1 amount)))
                                                            (IntegerTestNode'new-2 (:x node), (ConstantNode'forLong-1 (<< -1 amount)))
                                                        )
                                                    )
                                                nil
                                            )
                                        )
                                )
                        )
                        (when (and (satisfies? AddNode node) (ValueNode''isJavaConstant-1 (:y node)))
                            (IntegerEqualsNode'new-2 (:x node), (ConstantNode'forIntegerStamp-2 (:stamp node), (- (UnsignedLong''asLong-1 constant) (UnsignedLong''asLong-1 (ValueNode''asJavaConstant-1 (:y node))))))
                        )
                        ;; a & c == c is the same as a & c != 0, if c is a single bit
                        (when (and (satisfies? AndNode node) (= (Long/bitCount (UnsignedLong''asLong-1 constant)) 1) (satisfies? ConstantNode (:y node)) (= (ValueNode''asJavaConstant-1 (:y node)) constant))
                            (LogicNegationNode'new-1 (IntegerTestNode'new-2 (:x node), (:y node)))
                        )
                        ;; x ^ 1 == 0 is the same as x == 1 if x in [0, 1]
                        ;; x ^ 1 == 1 is the same as x == 0 if x in [0, 1]
                        (when (and (satisfies? XorNode node) (satisfies? IntegerStamp (:stamp node)) (ValueNode''isJavaConstant-1 (:y node)) (= (UnsignedLong''asLong-1 (ValueNode''asJavaConstant-1 (:y node))) 1) (= (:upMask (:stamp (:x node))) 1))
                            (IntegerEqualsNode'new-2 (:x node), (ConstantNode'forIntegerStamp-2 (:stamp (:x node)), (bit-xor (UnsignedLong''asLong-1 constant) 1)))
                        )
                    )
                )
                (CompareOp'''canonicalizeSymmetricConstant-6 (ยง super CompareOp'iface), smallestCompareWidth, condition, constant, node, mirrored?)
            )
        )
    )
)

(class-ns LowerOp [CompareOp]
    (defn #_"LowerOp" LowerOp'new-0 []
        (merge (LowerOp'class.) (CompareOp'new-0))
    )

    (defm LowerOp CompareOp
        (#_"LogicNode" CompareOp'''canonical-5 [#_"LowerOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareOp'''canonical-5 (ยง super #_"CompareOp"), smallestCompareWidth, condition, forX, forY)
                (LowerOp'''findSynonym-3 this, forX, forY)
            )
        )
    )

    (defn #_"long" LowerOp''min-4 [#_"LowerOp" this, #_"long" a, #_"long" b, #_"int" bits]
        (LowerOp'''min-3 this, (LowerOp'''cast-3 this, a, bits), (LowerOp'''cast-3 this, b, bits))
    )

    (defn #_"long" LowerOp''max-4 [#_"LowerOp" this, #_"long" a, #_"long" b, #_"int" bits]
        (LowerOp'''max-3 this, (LowerOp'''cast-3 this, a, bits), (LowerOp'''cast-3 this, b, bits))
    )

    (defn- #_"LogicNode" LowerOp''canonicalizeXLowerXPlusA-5 [#_"LowerOp" this, #_"ValueNode" forX, #_"AddNode" addNode, #_"boolean" mirrored?, #_"boolean" strict?]
        ;; x < x + a
        (let [
            [#_"IntegerStamp" succeedingXStamp #_"boolean" exact?]
                (cond
                    (and (= (:x addNode) forX) (satisfies? IntegerStamp (:stamp (:y addNode))))
                        [(LowerOp''getSucceedingStampForXLowerXPlusA-4 this, mirrored?, strict?, (:stamp (:y addNode))) (= (:lowerBound (:stamp (:y addNode))) (:upperBound (:stamp (:y addNode))))]
                    (and (= (:y addNode) forX) (satisfies? IntegerStamp (:stamp (:x addNode))))
                        [(LowerOp''getSucceedingStampForXLowerXPlusA-4 this, mirrored?, strict?, (:stamp (:x addNode))) (= (:lowerBound (:stamp (:x addNode))) (:upperBound (:stamp (:x addNode))))]
                    :else
                        (ยง return nil)
                )
        ]
            (cond
                (Stamp''isEmpty-1 (Stamp'''join-2 succeedingXStamp, (:stamp forX)))
                    (LogicConstantNode'contradiction-0)
                (and exact? (not (Stamp''isEmpty-1 succeedingXStamp)))
                    (cond
                        (pos? (LowerOp'''compare-3 this, (LowerOp'''lowerBound-2 this, succeedingXStamp), (LowerOp'''minValue-2 this, (:bits succeedingXStamp))))
                            ;; x must be in [L..MAX] <=> x >= L <=> !(x < L)
                            (LogicNegationNode'create-1 (LowerOp'''create-3 this, forX, (ConstantNode'forIntegerStamp-2 succeedingXStamp, (LowerOp'''lowerBound-2 this, succeedingXStamp))))
                        (neg? (LowerOp'''compare-3 this, (LowerOp'''upperBound-2 this, succeedingXStamp), (LowerOp'''maxValue-2 this, (:bits succeedingXStamp))))
                            ;; x must be in [MIN..H] <=> x <= H <=> !(H < x)
                            (LogicNegationNode'create-1 (LowerOp'''create-3 this, (ConstantNode'forIntegerStamp-2 succeedingXStamp, (LowerOp'''upperBound-2 this, succeedingXStamp)), forX))
                    )
            )
        )
    )

    (defm LowerOp LowerOp
        (#_"LogicNode" LowerOp'''create-3 [#_"LowerOp" this, #_"ValueNode" x, #_"ValueNode" y]
            (or (CompareNode'tryConstantFoldPrimitive-3 (LowerOp'''getCondition-1 this), x, y)
                (LowerOp'''findSynonym-3 this, x, y)
                (LowerOp'''createNode-3 this, x, y)
            )
        )

        (#_"LogicNode" LowerOp'''findSynonym-3 [#_"LowerOp" this, #_"ValueNode" forX, #_"ValueNode" forY]
            (when-not (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY)) => (LogicConstantNode'contradiction-0)
                (let [
                    #_"TriState" fold (LowerOp''tryFold-3 this, (:stamp forX), (:stamp forY))
                ]
                    (cond
                        (#_"TriState" .isTrue fold)  (LogicConstantNode'tautology-0)
                        (#_"TriState" .isFalse fold) (LogicConstantNode'contradiction-0)
                        (satisfies? IntegerStamp (:stamp forY))
                            (let [
                                #_"IntegerStamp" yStamp (:stamp forY)
                                #_"int" bits (:bits yStamp)
                            ]
                                (when (and (ValueNode''isJavaConstant-1 forX) (not (satisfies? ConstantNode forY)))
                                    ;; bring the constant on the right
                                    (let [
                                        #_"long" xValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX))
                                    ]
                                        (when-not (= xValue (LowerOp'''maxValue-2 this, bits))
                                            ;; c < x <=> !(c >= x) <=> !(x <= c) <=> !(x < c + 1)
                                            (ยง return (LogicNegationNode'create-1 (LowerOp'''create-3 this, forY, (ConstantNode'forIntegerStamp-2 yStamp, (inc xValue)))))
                                        )
                                    )
                                )
                                (cond
                                    (ValueNode''isJavaConstant-1 forY)
                                        (let [
                                            #_"long" yValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                                        ]
                                            (when (= yValue (LowerOp'''maxValue-2 this, bits))
                                                ;; x < MAX <=> x != MAX
                                                (ยง return (LogicNegationNode'create-1 (IntegerEqualsNode'create-2 forX, forY)))
                                            )
                                            (when (= yValue (inc (LowerOp'''minValue-2 this, bits)))
                                                ;; x < MIN + 1 <=> x <= MIN <=> x == MIN
                                                (ยง return (IntegerEqualsNode'create-2 forX, (ConstantNode'forIntegerStamp-2 yStamp, (LowerOp'''minValue-2 this, bits))))
                                            )
                                        )
                                    (satisfies? AddNode forY)
                                        (let [
                                            #_"LogicNode" canonical (LowerOp''canonicalizeXLowerXPlusA-5 this, forX, forY, false, true)
                                        ]
                                            (when (some? canonical)
                                                (ยง return canonical)
                                            )
                                        )
                                )
                                (when (satisfies? AddNode forX)
                                    (LowerOp''canonicalizeXLowerXPlusA-5 this, forY, forX, true, false)
                                )
                            )
                    )
                )
            )
        )
    )

    (defn #_"TriState" LowerOp''tryFold-3 [#_"LowerOp" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (satisfies? IntegerStamp xStamp) (satisfies? IntegerStamp yStamp)) => TriState/UNKNOWN
            (cond
                (<    (LowerOp'''compare-3 this, (LowerOp'''upperBound-2 this, xStamp), (LowerOp'''lowerBound-2 this, yStamp)) 0) TriState/TRUE
                (<= 0 (LowerOp'''compare-3 this, (LowerOp'''lowerBound-2 this, xStamp), (LowerOp'''upperBound-2 this, yStamp))  ) TriState/FALSE
                :else                                                                                                          TriState/UNKNOWN
            )
        )
    )

    (defn #_"IntegerStamp" LowerOp''getSucceedingStampForX-5 [#_"LowerOp" this, #_"IntegerStamp" xStamp, #_"IntegerStamp" yStamp, #_"boolean" mirror, #_"boolean" strict?]
        (let [
            #_"int" bits (:bits xStamp)
        ]
            (if mirror
                (let [
                    #_"long" low (LowerOp'''lowerBound-2 this, yStamp)
                ]
                    (when strict?
                        (when (= low (LowerOp'''maxValue-2 this, bits))
                            (ยง return nil)
                        )
                        (ยง ass low (inc low))
                    )
                    (when (or (pos? (LowerOp'''compare-3 this, low, (LowerOp'''lowerBound-2 this, xStamp))) (not= (LowerOp'''upperBound-2 this, xStamp) (& (:upperBound xStamp) (CodeUtil/mask (:bits xStamp)))))
                        (LowerOp'''forInteger-4 this, bits, low, (LowerOp'''upperBound-2 this, xStamp))
                    )
                )
                ;; x < y, i.e. x < y <= Y_UPPER_BOUND, so x <= Y_UPPER_BOUND - 1
                (let [
                    #_"long" low (LowerOp'''upperBound-2 this, yStamp)
                ]
                    (when strict?
                        (when (= low (LowerOp'''minValue-2 this, bits))
                            (ยง return nil)
                        )
                        (ยง ass low (dec low))
                    )
                    (when (or (neg? (LowerOp'''compare-3 this, low, (LowerOp'''upperBound-2 this, xStamp))) (not= (LowerOp'''lowerBound-2 this, xStamp) (& (:lowerBound xStamp) (CodeUtil/mask (:bits xStamp)))))
                        (LowerOp'''forInteger-4 this, bits, (LowerOp'''lowerBound-2 this, xStamp), low)
                    )
                )
            )
        )
    )

    (defn #_"IntegerStamp" LowerOp''getSucceedingStampForXLowerXPlusA-4 [#_"LowerOp" this, #_"boolean" mirrored?, #_"boolean" strict?, #_"IntegerStamp" a]
        (let [
            #_"int" bits (:bits a)
            #_"long" min (LowerOp'''minValue-2 this, bits)
            #_"long" max (LowerOp'''maxValue-2 this, bits)
        ]
            ;; if x < x + a <=> x + a didn't overflow:
            ;;
            ;; x is outside ]MAX - a, MAX], i.e. inside [MIN, MAX - a]
            ;;
            ;; if a is negative those bounds wrap around correctly.
            ;;
            ;; If a is exactly zero this gives an unbounded stamp (any integer) in the positive case
            ;; and an empty stamp in the negative case: if x |<| x is true, then either x has no
            ;; value or any value...
            ;;
            ;; This does not use upper/lowerBound from LowerOp, because it's about
            ;; the (signed) addition not the comparison.
            (if mirrored?
                (if (IntegerStamp''contains-2 a, 0)
                    (Stamp'''unrestricted-1 a) ;; a may be zero
                    (LowerOp'''forInteger-4 this, bits, (LowerOp''min-4 this, (inc (- max (:lowerBound a))), (inc (- max (:upperBound a))), bits), max)
                )
                (let [
                    #_"long" aLower (:lowerBound a)
                    #_"long" aUpper (:upperBound a)
                ]
                    (when strict?
                        (when (zero? aLower)
                            (ยง ass aLower 1)
                        )
                        (when (zero? aUpper)
                            (ยง ass aUpper -1)
                        )
                        (when (< aUpper aLower)
                            ;; impossible
                            (ยง return (Stamp'''empty-1 a))
                        )
                    )
                    (if (and (neg? aLower) (pos? aUpper))
                        (Stamp'''unrestricted-1 a) ;; a may be zero
                        (LowerOp'''forInteger-4 this, bits, min, (LowerOp''max-4 this, (- max aLower), (- max aUpper), bits))
                    )
                )
            )
        )
    )
)

(class-ns BelowOp [LowerOp, CompareOp]
    (defn #_"BelowOp" BelowOp'new-0 []
        (merge (BelowOp'class.) (LowerOp'new-0))
    )

    (defm BelowOp CompareOp
        (#_"CompareNode" CompareOp'''duplicateModified-3 [#_"BelowOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
            (IntegerBelowNode'new-2 newX, newY)
        )
    )

    (defm BelowOp LowerOp
        (#_"long" LowerOp'''upperBound-2 [#_"BelowOp" this, #_"IntegerStamp" stamp]
            (IntegerStamp''unsignedUpperBound-1 stamp)
        )

        (#_"long" LowerOp'''lowerBound-2 [#_"BelowOp" this, #_"IntegerStamp" stamp]
            (IntegerStamp''unsignedLowerBound-1 stamp)
        )

        (#_"int" LowerOp'''compare-3 [#_"BelowOp" this, #_"long" a, #_"long" b]
            (Long/compareUnsigned a, b)
        )

        (#_"long" LowerOp'''min-3 [#_"BelowOp" this, #_"long" a, #_"long" b]
            (NumUtil'minUnsigned-2 a, b)
        )

        (#_"long" LowerOp'''max-3 [#_"BelowOp" this, #_"long" a, #_"long" b]
            (NumUtil'maxUnsigned-2 a, b)
        )

        (#_"long" LowerOp'''cast-3 [#_"BelowOp" this, #_"long" a, #_"int" bits]
            (CodeUtil/zeroExtend a, bits)
        )

        (#_"long" LowerOp'''minValue-2 [#_"BelowOp" this, #_"int" bits]
            0
        )

        (#_"long" LowerOp'''maxValue-2 [#_"BelowOp" this, #_"int" bits]
            (NumUtil'maxValueUnsigned-1 bits)
        )

        (#_"IntegerStamp" LowerOp'''forInteger-4 [#_"BelowOp" this, #_"int" bits, #_"long" min, #_"long" max]
            (StampFactory'forUnsignedInteger-3 bits, min, max)
        )

        (#_"CanonicalCondition" LowerOp'''getCondition-1 [#_"BelowOp" this]
            CanonicalCondition'BT
        )

        (#_"IntegerLowerThanNode" LowerOp'''createNode-3 [#_"BelowOp" this, #_"ValueNode" x, #_"ValueNode" y]
            (IntegerBelowNode'new-2 x, y)
        )
    )
)

(class-ns LessThanOp [LowerOp, CompareOp]
    (defn #_"LessThanOp" LessThanOp'new-0 []
        (merge (LessThanOp'class.) (LowerOp'new-0))
    )

    (defm LessThanOp CompareOp
        (#_"CompareNode" CompareOp'''duplicateModified-3 [#_"LessThanOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
            (when (and (satisfies? IntegerStamp (:stamp newX)) (satisfies? IntegerStamp (:stamp newY))) => (throw! "should not reach here")
                (IntegerLessThanNode'new-2 newX, newY)
            )
        )

        (#_"LogicNode" CompareOp'''optimizeNormalizeCompare-5 [#_"LessThanOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?]
            ;; a NC b < c  (not mirrored)
            ;; cases for c:
            ;;  0         -> a < b
            ;;  [MIN, -1] -> false
            ;;  1         -> a <= b
            ;;  [2, MAX]  -> true
            ;; unordered-is-less means unordered-is-true.
            ;;
            ;; c < a NC b  (mirrored)
            ;; cases for c:
            ;;  0         -> a > b
            ;;  [1, MAX]  -> false
            ;;  -1        -> a >= b
            ;;  [MIN, -2] -> true
            ;; unordered-is-less means unordered-is-false.
            ;;
            ;; We can handle mirroring by swapping a & b and negating the constant.
            (let [
                #_"ValueNode" a (if mirrored? (:y normalizeNode) (:x normalizeNode))
                #_"ValueNode" b (if mirrored? (:x normalizeNode) (:y normalizeNode))
                #_"long" cst (if mirrored? (- (#_"PrimitiveConstant" .asLong constant)) (#_"PrimitiveConstant" .asLong constant))
            ]
                (cond
                    (= cst 0)   (IntegerLessThanNode'create-3 smallestCompareWidth, a, b)
                                ;; a <= b <=> !(a > b)
                    (= cst 1)   (LogicNegationNode'create-1 (IntegerLessThanNode'create-3 smallestCompareWidth, b, a))
                    (<= cst -1) (LogicConstantNode'contradiction-0)
                    :else       (LogicConstantNode'tautology-0)
                )
            )
        )
    )

    (defm LessThanOp LowerOp
        (#_"LogicNode" LowerOp'''findSynonym-3 [#_"LessThanOp" this, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (LowerOp'''findSynonym-3 (ยง super LowerOp'iface), forX, forY)
                (when (and (satisfies? IntegerStamp (:stamp forX)) (satisfies? IntegerStamp (:stamp forY)) (IntegerStamp'sameSign-2 (:stamp forX), (:stamp forY)))
                    (IntegerBelowNode'new-2 forX, forY)
                )
                (when (and (satisfies? ConstantNode forY) (satisfies? SubNode forX))
                    (let [
                        [#_"ValueNode" vx #_"ValueNode" vy #_"boolean" negate?]
                            (cond
                                (#_"Constant" .isDefaultForKind (:value forY))
                                    [(:x forX) (:y forX) false] ;; (x - y) < 0 when x - y is known not to underflow <=> x < y
                                (and (ValueNode''isJavaConstant-1 forY) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)) 1))
                                    [(:y forX) (:x forX) true]  ;; (x - y) < 1 when x - y is known not to underflow <=> !(y < x)
                            )
                    ]
                        (when (some? vx)
                            (let [
                                #_"IntegerStamp" sx (:stamp (:x forX))
                                #_"IntegerStamp" sy (:stamp (:y forX))
                            ]
                                (when (and (not (IntegerLessThanNode'subtractMayUnderflow-3 (:lowerBound sx), (:upperBound sy), (CodeUtil/minValue (:bits sx))))
                                        (not (IntegerLessThanNode'subtractMayOverflow-3  (:upperBound sx), (:lowerBound sy), (CodeUtil/maxValue (:bits sx))))
                                    )
                                    (let [
                                        #_"LogicNode" logic (IntegerLessThanNode'new-2 vx, vy)
                                    ]
                                        (if negate? (LogicNegationNode'create-1 logic) logic)
                                    )
                                )
                            )
                        )
                    )
                )
                (when (satisfies? IntegerStamp (:stamp forX))
                    (let [
                        #_"int" bits (:bits (:stamp forX))
                        #_"long" min (LowerOp'''minValue-2 IntegerLessThanNode'OP, bits)
                        #_"long" xResidue 0
                        #_"ValueNode" left nil
                        #_"JavaConstant" leftCst nil
                    ]
                        (cond
                            (satisfies? AddNode forX)
                                (when (ValueNode''isJavaConstant-1 (:y forX))
                                    (ยง ass xResidue (- (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y forX))) min))
                                    (ยง ass left (:x forX))
                                )
                            (ValueNode''isJavaConstant-1 forX)
                                (ยง ass leftCst (ValueNode''asJavaConstant-1 forX))
                        )
                        (when (or (some? left) (some? leftCst))
                            (let [
                                #_"long" yResidue 0
                                #_"ValueNode" right nil
                                #_"JavaConstant" rightCst nil
                            ]
                                (cond
                                    (satisfies? AddNode forY)
                                        (when (ValueNode''isJavaConstant-1 (:y forY))
                                            (ยง ass yResidue (- (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y forY))) min))
                                            (ยง ass right (:x forY))
                                        )
                                    (ValueNode''isJavaConstant-1 forY)
                                        (ยง ass rightCst (ValueNode''asJavaConstant-1 forY))
                                )
                                (when (and (or (some? right) (some? rightCst)) (or (and (zero? xResidue) (some? left)) (and (zero? yResidue) (some? right))))
                                    (cond
                                        (nil? left)
                                            (ยง ass left (ConstantNode'forIntegerBits-2l bits, (- (#_"JavaConstant" .asLong leftCst) min)))
                                        (not= xResidue 0)
                                            (ยง ass left (AddNode'create-2 left, (ConstantNode'forIntegerBits-2l bits, xResidue)))
                                    )
                                    (cond
                                        (nil? right)
                                            (ยง ass right (ConstantNode'forIntegerBits-2l bits, (- (#_"JavaConstant" .asLong rightCst) min)))
                                        (not= yResidue 0)
                                            (ยง ass right (AddNode'create-2 right, (ConstantNode'forIntegerBits-2l bits, yResidue)))
                                    )
                                    (IntegerBelowNode'new-2 left, right)
                                )
                            )
                        )
                    )
                )
            )
        )

        (#_"CanonicalCondition" LowerOp'''getCondition-1 [#_"LessThanOp" this]
            CanonicalCondition'LT
        )

        (#_"IntegerLowerThanNode" LowerOp'''createNode-3 [#_"LessThanOp" this, #_"ValueNode" x, #_"ValueNode" y]
            (IntegerLessThanNode'new-2 x, y)
        )

        (#_"long" LowerOp'''upperBound-2 [#_"LessThanOp" this, #_"IntegerStamp" stamp]
            (:upperBound stamp)
        )

        (#_"long" LowerOp'''lowerBound-2 [#_"LessThanOp" this, #_"IntegerStamp" stamp]
            (:lowerBound stamp)
        )

        (#_"int" LowerOp'''compare-3 [#_"LessThanOp" this, #_"long" a, #_"long" b]
            (Long/compare a, b)
        )

        (#_"long" LowerOp'''min-3 [#_"LessThanOp" this, #_"long" a, #_"long" b]
            (min a b)
        )

        (#_"long" LowerOp'''max-3 [#_"LessThanOp" this, #_"long" a, #_"long" b]
            (max a b)
        )

        (#_"long" LowerOp'''cast-3 [#_"LessThanOp" this, #_"long" a, #_"int" bits]
            (CodeUtil/signExtend a, bits)
        )

        (#_"long" LowerOp'''minValue-2 [#_"LessThanOp" this, #_"int" bits]
            (NumUtil'minValue-1 bits)
        )

        (#_"long" LowerOp'''maxValue-2 [#_"LessThanOp" this, #_"int" bits]
            (NumUtil'maxValue-1 bits)
        )

        (#_"IntegerStamp" LowerOp'''forInteger-4 [#_"LessThanOp" this, #_"int" bits, #_"long" min, #_"long" max]
            (StampFactory'forInteger-3i bits, (LowerOp'''cast-3 this, min, bits), (LowerOp'''cast-3 this, max, bits))
        )
    )
)

(class-ns PointerEqualsOp [CompareOp]
    (defn #_"PointerEqualsOp" PointerEqualsOp'new-0 []
        (merge (PointerEqualsOp'class.) (CompareOp'new-0))
    )

    (defm PointerEqualsOp CompareOp
        (#_"LogicNode" CompareOp'''canonical-5 [#_"PointerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (PointerEqualsNode'findSynonym-2 forX, forY)
                (CompareOp'''canonical-5 (ยง super CompareOp'iface), smallestCompareWidth, condition, forX, forY)
            )
        )

        (#_"CompareNode" CompareOp'''duplicateModified-3 [#_"PointerEqualsOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
            (PointerEqualsNode'new-2 newX, newY)
        )
    )
)

(class-ns ObjectEqualsOp [PointerEqualsOp, CompareOp]
    (defn #_"ObjectEqualsOp" ObjectEqualsOp'new-0 []
        (merge (ObjectEqualsOp'class.) (PointerEqualsOp'new-0))
    )

    (defm ObjectEqualsOp CompareOp
        (#_"LogicNode" CompareOp'''canonicalizeSymmetricConstant-6 [#_"ObjectEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?]
            (let [
                #_"ResolvedJavaType" type (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant)
            ]
                (if (and (some? type) (satisfies? GetClassNode node))
                    (if (and (not (#_"ResolvedJavaType" .isPrimitive type)) (or (#_"ResolvedJavaType" .isConcrete type) (#_"ResolvedJavaType" .isArray type)))
                        (InstanceOfNode'create-2 (TypeReference'createExactTrusted-1 type), (:object node))
                        (LogicConstantNode'forBoolean-1 false)
                    )
                    (CompareOp'''canonicalizeSymmetricConstant-6 (ยง super #_"PointerEqualsOp"), smallestCompareWidth, condition, constant, node, mirrored?)
                )
            )
        )

        (#_"CompareNode" CompareOp'''duplicateModified-3 [#_"ObjectEqualsOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
            (cond
                (and (satisfies? ObjectStamp (:stamp newX)) (satisfies? ObjectStamp (:stamp newY)))                   (ObjectEqualsNode'new-2 newX, newY)
                (and (satisfies? AbstractPointerStamp (:stamp newX)) (satisfies? AbstractPointerStamp (:stamp newY))) (PointerEqualsNode'new-2 newX, newY)
                :else                                                                                                 (throw! "should not reach here")
            )
        )
    )
)

;;;
 ; Represents the output from compiling a method, including the compiled machine code, associated
 ; data and references, relocation information, deoptimization information, etc.
 ;;
(class-ns CompilationResult []
    (defn #_"CompilationResult" CompilationResult'new-1 [#_"int" totalFrameSize]
        (merge (CompilationResult'class.)
            (hash-map
                #_"boolean" :closed false
                #_"DataSection" :dataSection (DataSection'new-0)
                #_"List<DataPatch>" :dataPatches (ArrayList.)
                #_"List<Mark>" :marks (ArrayList.)
                ;;;
                 ; Total frame size in bytes. This includes the return address pushed onto the stack, if any.
                 ;;
                #_"int" :totalFrameSize totalFrameSize
                ;;;
                 ; The buffer containing the emitted machine code.
                 ;;
                #_"byte[]" :targetCode nil
                ;;;
                 ; The leading number of bytes in #targetCode containing the emitted machine code.
                 ;;
                #_"int" :targetCodeSize 0
            )
        )
    )

    (defn- #_"void" CompilationResult''checkOpen-1 [#_"CompilationResult" this]
        (when (:closed this)
            (throw (IllegalStateException.))
        )
        nil
    )

    ;;;
     ; Records a data patch in the code section. The data patch can refer to something in the
     ; {@link DataSectionReference data section} or directly to an {@link ConstantReference inlined constant}.
     ;
     ; @param codePos the position in the code that needs to be patched
     ; @param ref the reference that should be inserted in the code
     ;;
    (defn #_"void" CompilationResult''recordDataPatch-3 [#_"CompilationResult" this, #_"int" codePos, #_"jdk.vm.ci.code.site.Reference" ref]
        (CompilationResult''checkOpen-1 this)
        (#_"List" .add (:dataPatches this), (DataPatch. codePos, ref))
        nil
    )

    ;;;
     ; Records an instruction mark within this method.
     ;
     ; @param codePos the position in the code that is covered by the handler
     ; @param markId the identifier for this mark
     ;;
    (defn #_"Mark" CompilationResult''recordMark-3 [#_"CompilationResult" this, #_"int" codePos, #_"Object" markId]
        (CompilationResult''checkOpen-1 this)
        (let [
            #_"Mark" mark (Mark. codePos, markId)
        ]
            (#_"List" .add (:marks this), mark)
            mark
        )
    )

    ;;;
     ; Sets the machine that has been generated by the compiler.
     ;
     ; @param code the machine code generated
     ; @param size the size of the machine code
     ;;
    (defn #_"this" CompilationResult''setTargetCode-3 [#_"CompilationResult" this, #_"byte[]" code, #_"int" size]
        (CompilationResult''checkOpen-1 this)
        (let [
            this (assoc this :targetCode code)
            this (assoc this :targetCodeSize size)
        ]
            this
        )
    )

    ;;;
     ; Closes this compilation result to future updates.
     ;;
    (defn #_"this" CompilationResult''close-1 [#_"CompilationResult" this]
        (CompilationResult''checkOpen-1 this)
        (let [
            this (update this :dataSection DataSection''close-1)
        ]
            (assoc this :closed true)
        )
    )
)

;;;
 ; A compact representation of the different encoding strategies for objects and metadata.
 ;;
(class-ns CompressEncoding []
    (defn #_"CompressEncoding" CompressEncoding'new-2 [#_"long" base, #_"int" shift]
        (merge (CompressEncoding'class.)
            (hash-map
                #_"long" :base base
                #_"int" :shift shift
            )
        )
    )

    (defn #_"boolean" CompressEncoding''hasBase-1 [#_"CompressEncoding" this]
        (not= (:base this) 0)
    )

    #_unused
    (defn #_"boolean" CompressEncoding''hasShift-1 [#_"CompressEncoding" this]
        (not= (:shift this) 0)
    )
)

(class-ns ComputeInliningRelevance []
    (def- #_"double" ComputeInliningRelevance'EPSILON (/ 1.0 Integer/MAX_VALUE))
    (def- #_"double" ComputeInliningRelevance'UNINITIALIZED -1.0)

    (defn #_"ComputeInliningRelevance" ComputeInliningRelevance'new-2 [#_"Graph" graph, #_"ToDoubleFunction<FixedNode>" nodeProbabilities]
        (merge (ComputeInliningRelevance'class.)
            (hash-map
                #_"Graph" :graph graph
                #_"ToDoubleFunction<FixedNode>" :nodeProbabilities nodeProbabilities
                ;;;
                 ; Node relevances are pre-computed for all invokes if the graph contains loops.
                 ; If there are no loops, the computation happens lazily based on #rootScope.
                 ;;
                #_"EconomicMap<FixedNode, Double>" :nodeRelevances nil
                ;;;
                 ; This scope is non-nil if (and only if) there are no loops in the graph.
                 ; In this case, the root scope is used to compute invoke relevances on the fly.
                 ;;
                #_"Scope" :rootScope nil
            )
        )
    )

    ;;;
     ; Determines the parent of the given loop and creates a Scope object for each one.
     ; This method will call itself recursively if no Scope for the parent loop exists.
     ;;
    (defn- #_"Scope" ComputeInliningRelevance''createLoopScope-4 [#_"ComputeInliningRelevance" this, #_"LoopBeginNode" loopBegin, #_"EconomicMap<LoopBeginNode, Scope>" loops, #_"Scope" topScope]
        (or (get loops loopBegin)
            ;; look for the parent scope
            (let [
                #_"Scope" parent
                    (loop [#_"FixedNode" node (LoopBeginNode''forwardEnd-1 loopBegin)]
                        (cond
                            (nil? (:predecessor node))
                                (condp satisfies? node
                                    LoopBeginNode
                                        ;; if we reach a LoopBeginNode then we're within this loop
                                        (ComputeInliningRelevance''createLoopScope-4 this, node, loops, topScope)
                                    StartNode
                                        ;; we're within the outermost scope
                                        topScope
                                    ;; follow any path upwards - it doesn't matter which one
                                    (recur (AbstractMergeNode''forwardEndAt-2 node, 0))
                                )
                            (satisfies? LoopExitNode node)
                                ;; if we reach a loop exit then we follow this loop and have the same parent
                                (:parent (ComputeInliningRelevance''createLoopScope-4 this, (:loopBegin node), loops, topScope))
                            :else
                                (recur (:predecessor node))
                        )
                    )
                #_"Scope" scope (Scope'new-3 this, loopBegin, parent)
            ]
                (#_"EconomicMap" .put loops, loopBegin, scope)
                scope
            )
        )
    )

    ;;;
     ; Initializes or updates the relevance computation. If there are no loops within the graph,
     ; most computation happens lazily.
     ;;
    (defn #_"ComputeInliningRelevance" ComputeInliningRelevance''compute-1 [#_"ComputeInliningRelevance" this]
        (when (Graph''hasLoops-1 (:graph this)) => (assoc this :rootScope (Scope'new-3 this, (:start (:graph this)), nil))
            (let [
                this (assoc this :rootScope nil)
                this
                    (when (nil? (:nodeRelevances this)) => this
                        (assoc this :nodeRelevances (EconomicMap/create))
                    )
                #_"NodeWorkList" workList (SingletonNodeWorkList'new-1 (:graph this))
                #_"EconomicMap<LoopBeginNode, Scope>" loops (EconomicMap/create)
                #_"Scope" topScope (Scope'new-3 this, (:start (:graph this)), nil)
            ]
                (doseq [#_"LoopBeginNode" loopBegin (Graph''getNodes-2 (:graph this), LoopBeginNode)]
                    (ComputeInliningRelevance''createLoopScope-4 this, loopBegin, loops, topScope)
                )
                (Scope''process-2 topScope, workList)
                (doseq [#_"Scope" scope (vals loops)]
                    (Scope''process-2 scope, workList)
                )
                this
            )
        )
    )

    (defn #_"double" ComputeInliningRelevance''getRelevance-2 [#_"ComputeInliningRelevance" this, #_"InvokeNode" invoke]
        (if (some? (:rootScope this))
            (Scope''computeInvokeRelevance-2 (:rootScope this), invoke)
            (get (:nodeRelevances this) invoke)
        )
    )

    (defn- #_"void" ComputeInliningRelevance'truncate-2 [#_"ArrayList<FixedNode>" pathBeginNodes, #_"int" pathBeginCount]
        (loop-when-recur [#_"int" i (- (count pathBeginNodes) pathBeginCount)] (pos? i) [(dec i)]
            (#_"ArrayList" .remove pathBeginNodes, (dec (count pathBeginNodes)))
        )
        nil
    )

    ;;;
     ; Returns the most probable loop exit. If multiple successors share the maximum probability,
     ; one is returned and the others are enqueued in pathBeginNodes.
     ;;
    (defn- #_"Node" ComputeInliningRelevance''getMaxProbabilityLoopExit-3 [#_"ComputeInliningRelevance" this, #_"LoopBeginNode" loopBegin, #_"ArrayList<FixedNode>" pathBeginNodes]
        (let [
            #_"int" pathBeginCount (count pathBeginNodes)
        ]
            (loop-when [#_"Node" maxSux nil #_"double" maxProbability 0.0 #_"ISeq" s (seq (LoopBeginNode''loopExits-1 loopBegin))] (some? s) => maxSux
                (let [
                    #_"LoopExitNode" sux (first s)
                    #_"double" probability (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities this), sux)
                    [maxSux maxProbability]
                        (if (< maxProbability probability)
                            (do
                                (ComputeInliningRelevance'truncate-2 pathBeginNodes, pathBeginCount)
                                [sux probability]
                            )
                            (do
                                (when (= probability maxProbability)
                                    (#_"ArrayList" .add pathBeginNodes, sux)
                                )
                                [maxSux maxProbability]
                            )
                        )
                ]
                    (recur maxSux maxProbability (next s))
                )
            )
        )
    )

    (defn- #_"double" ComputeInliningRelevance''getMinPathProbability-3 [#_"ComputeInliningRelevance" this, #_"FixedNode" node, #_"double" minPathProbability]
        (if (some? node) (min minPathProbability (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities this), node)) minPathProbability)
    )

    ;;;
     ; Returns the most probable successor. If multiple successors share the maximum probability,
     ; one is returned and the others are enqueued in pathBeginNodes.
     ;;
    (defn- #_"Node" ComputeInliningRelevance'getMaxProbabilitySux-2 [#_"ControlSplitNode" controlSplit, #_"ArrayList<FixedNode>" pathBeginNodes]
        (let [
            #_"int" pathBeginCount (count pathBeginNodes)
        ]
            (loop-when [#_"Node" maxSux nil #_"double" maxProbability 0.0 #_"ISeq" s (seq (Node''successors-1 controlSplit))] (some? s) => maxSux
                (let [
                    #_"Node" sux (first s)
                    #_"double" probability (ControlSplitNode'''probability-2 controlSplit, (ยง cast #_"AbstractBeginNode" sux))
                    [maxSux maxProbability]
                        (if (< maxProbability probability)
                            (do
                                (ComputeInliningRelevance'truncate-2 pathBeginNodes, pathBeginCount)
                                [sux probability]
                            )
                            (do
                                (when (= probability maxProbability)
                                    (#_"ArrayList" .add pathBeginNodes, sux)
                                )
                                [maxSux maxProbability]
                            )
                        )
                ]
                    (recur maxSux maxProbability (next s))
                )
            )
        )
    )

    ;;;
     ; Computes the minimum probability along the most probable path within the scope.
     ; During iteration, the method returns immediately once a loop exit is discovered.
     ;;
    (defn- #_"double" ComputeInliningRelevance''computeFastPathMinProbability-2 [#_"ComputeInliningRelevance" this, #_"FixedNode" scopeStart]
        (let [
            #_"ArrayList<FixedNode>" pathBeginNodes (ArrayList.)
            _ (#_"ArrayList" .add pathBeginNodes, scopeStart)
        ]
            (loop [#_"double" minPathProbability (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities this), scopeStart)]
                (let [
                    minPathProbability
                        (loop [#_"Node" node (#_"ArrayList" .remove pathBeginNodes, (dec (count pathBeginNodes))) minPathProbability minPathProbability]
                            (let [
                                [node minPathProbability]
                                    (cond
                                        (and (satisfies? LoopBeginNode scopeStart) (satisfies? LoopExitNode node) (some #(= % node) (LoopBeginNode''loopExits-1 scopeStart)))
                                            (ยง return minPathProbability)
                                        (and (satisfies? LoopBeginNode node) (not= node scopeStart))
                                            (let [
                                                node (ComputeInliningRelevance''getMaxProbabilityLoopExit-3 this, node, pathBeginNodes)
                                            ]
                                                [node (ComputeInliningRelevance''getMinPathProbability-3 this, node, minPathProbability)]
                                            )
                                        (satisfies? ControlSplitNode node)
                                            (let [
                                                node (ComputeInliningRelevance'getMaxProbabilitySux-2 node, pathBeginNodes)
                                            ]
                                                [node (ComputeInliningRelevance''getMinPathProbability-3 this, node, minPathProbability)]
                                            )
                                        :else
                                            [(first (Node''successors-1 node)) minPathProbability]
                                    )
                            ]
                                (recur-if (some? node) [node minPathProbability] => minPathProbability)
                            )
                        )
                ]
                    (recur-if (seq pathBeginNodes) [minPathProbability] => minPathProbability)
                )
            )
        )
    )
)

(class-ns ComputeLoopFrequencyPhase [Phase]
    (defn #_"ComputeLoopFrequencyPhase" ComputeLoopFrequencyPhase'new-0 []
        (ComputeLoopFrequencyPhase'class.)
    )

    (defm ComputeLoopFrequencyPhase Phase
        (#_"Graph" Phase'''run-3 [#_"ComputeLoopFrequencyPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (ComputeLoopFrequenciesClosure'compute-1 graph)
            graph
        )
    )
)

;;;
 ; Condition codes used in conditionals.
 ;;
(class-ns Condition []
    (defn- #_"Condition" Condition'new-1 [#_"String" operator]
        (merge (Condition'class.)
            (hash-map
                #_"String" :operator operator
            )
        )
    )

    (def #_"Condition" Condition'EQ (Condition'new-1 "=="))   ;; equal
    (def #_"Condition" Condition'NE (Condition'new-1 "!="))   ;; not equal
    (def #_"Condition" Condition'LT (Condition'new-1 "<"))    ;; signed less than
    (def #_"Condition" Condition'LE (Condition'new-1 "<="))   ;; signed less than or equal
    (def #_"Condition" Condition'GT (Condition'new-1 ">"))    ;; signed greater than
    (def #_"Condition" Condition'GE (Condition'new-1 ">="))   ;; signed greater than or equal
    (def #_"Condition" Condition'AE (Condition'new-1 "|>=|")) ;; unsigned greater than or equal ("above than or equal")
    (def #_"Condition" Condition'BE (Condition'new-1 "|<=|")) ;; unsigned less than or equal ("below than or equal")
    (def #_"Condition" Condition'AT (Condition'new-1 "|>|"))  ;; unsigned greater than ("above than")
    (def #_"Condition" Condition'BT (Condition'new-1 "|<|"))  ;; unsigned less than ("below than")

    ;;;
     ; Given a condition and its negation, this method returns true for one of the two and false
     ; for the other one. This can be used to keep comparisons in a canonical form.
     ;
     ; @return true if this condition is considered to be the canonical form, false otherwise
     ;;
    #_unused
    (defn #_"boolean" Condition''isCanonical-1 [#_"Condition" this]
        (condp = this
            Condition'EQ true
            Condition'NE false
            Condition'LT true
            Condition'LE false
            Condition'GT false
            Condition'GE false
            Condition'BT true
            Condition'BE false
            Condition'AT false
            Condition'AE false
        )
    )

    ;;;
     ; Returns true if the condition needs to be mirrored to get to a canonical condition. The
     ; result of the mirroring operation might still need to be negated to achieve a canonical form.
     ;;
    (defn- #_"boolean" Condition''canonicalMirror-1 [#_"Condition" this]
        (condp = this
            Condition'EQ false
            Condition'NE false
            Condition'LT false
            Condition'LE true
            Condition'GT true
            Condition'GE false
            Condition'BT false
            Condition'BE true
            Condition'AT true
            Condition'AE false
        )
    )

    ;;;
     ; Returns true if the condition needs to be negated to get to a canonical condition. The result
     ; of the negation might still need to be mirrored to achieve a canonical form.
     ;;
    (defn- #_"boolean" Condition''canonicalNegate-1 [#_"Condition" this]
        (condp = this
            Condition'EQ false
            Condition'NE true
            Condition'LT false
            Condition'LE true
            Condition'GT false
            Condition'GE true
            Condition'BT false
            Condition'BE true
            Condition'AT false
            Condition'AE true
        )
    )

    (defn #_"CanonicalizedCondition" Condition''canonicalize-1 [#_"Condition" this]
        (let [
            #_"CanonicalCondition" canonicalCondition
                (condp =? this
                    [Condition'EQ Condition'NE]                           CanonicalCondition'EQ
                    [Condition'LT Condition'LE Condition'GT Condition'GE] CanonicalCondition'LT
                    [Condition'BT Condition'BE Condition'AT Condition'AE] CanonicalCondition'BT
                )
        ]
            (CanonicalizedCondition'new-3 canonicalCondition, (Condition''canonicalMirror-1 this), (Condition''canonicalNegate-1 this))
        )
    )

    ;;;
     ; Negate this conditional.
     ;
     ; @return the condition that represents the negation
     ;;
    (defn #_"Condition" Condition''negate-1 [#_"Condition" this]
        (condp = this
            Condition'EQ Condition'NE
            Condition'NE Condition'EQ
            Condition'LT Condition'GE
            Condition'LE Condition'GT
            Condition'GT Condition'LE
            Condition'GE Condition'LT
            Condition'BT Condition'AE
            Condition'BE Condition'AT
            Condition'AT Condition'BE
            Condition'AE Condition'BT
        )
    )

    #_unused
    (defn #_"boolean" Condition''implies-2 [#_"Condition" this, #_"Condition" other]
        (condp = this
            other        true
            Condition'EQ (any = other Condition'LE Condition'GE Condition'BE Condition'AE)
            Condition'NE false
            Condition'LT (any = other Condition'LE Condition'NE)
            Condition'LE false
            Condition'GT (any = other Condition'GE Condition'NE)
            Condition'GE false
            Condition'BT (any = other Condition'BE Condition'NE)
            Condition'BE false
            Condition'AT (any = other Condition'AE Condition'NE)
            Condition'AE false
        )
    )

    ;;;
     ; Mirror this conditional (i.e. commute "a op b" to "b op' a")
     ;
     ; @return the condition representing the equivalent commuted operation
     ;;
    (defn #_"Condition" Condition''mirror-1 [#_"Condition" this]
        (condp = this
            Condition'EQ Condition'EQ
            Condition'NE Condition'NE
            Condition'LT Condition'GT
            Condition'LE Condition'GE
            Condition'GT Condition'LT
            Condition'GE Condition'LE
            Condition'BT Condition'AT
            Condition'BE Condition'AE
            Condition'AT Condition'BT
            Condition'AE Condition'BE
        )
    )

    ;;;
     ; Returns true if this condition represents an unsigned comparison.
     ; EQ and NE are not considered to be unsigned.
     ;;
    #_unused
    (defn #_"boolean" Condition''isUnsigned-1 [#_"Condition" this]
        (any = this Condition'BT Condition'BE Condition'AT Condition'AE)
    )

    ;;;
     ; Checks if this conditional operation is commutative.
     ;
     ; @return true if this operation is commutative
     ;;
    #_unused
    (defn #_"boolean" Condition''isCommutative-1 [#_"Condition" this]
        (any = this Condition'EQ Condition'NE)
    )

    ;;;
     ; Attempts to fold a comparison between two constants and return the result.
     ;
     ; @param lt the constant on the left side of the comparison
     ; @param rt the constant on the right side of the comparison
     ; @return Boolean#TRUE if the comparison is known to be true,
     ;         Boolean#FALSE if the comparison is known to be false
     ;;
    (defn #_"boolean" Condition''foldCondition-3c [#_"Condition" this, #_"Constant" lt, #_"Constant" rt]
        (if (instance? PrimitiveConstant lt)
            (Condition''foldCondition-3p this, lt, rt)
            (let [
                #_"Boolean" equal (#_"ConstantReflectionProvider" .constantEquals HotSpot'constantReflection, lt, rt)
            ]
                (when (some? equal) => (throw! (str "could not fold " lt " " this " " rt))
                    (condp = this
                        Condition'EQ      (#_"Boolean" .booleanValue equal)
                        Condition'NE (not (#_"Boolean" .booleanValue equal))
                    )
                )
            )
        )
    )

    ;;;
     ; Attempts to fold a comparison between two primitive constants and return the result.
     ;
     ; @param lp the constant on the left side of the comparison
     ; @param rp the constant on the right side of the comparison
     ; @return true if the comparison is known to be true, false if the comparison is known to be false
     ;;
    (defn #_"boolean" Condition''foldCondition-3p [#_"Condition" this, #_"PrimitiveConstant" lp, #_"PrimitiveConstant" rp]
        (condp =? (#_"PrimitiveConstant" .getJavaKind lp)
           [JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Short JavaKind/Int]
            (let [
                #_"int" x (#_"PrimitiveConstant" .asInt lp)
                #_"int" y (#_"PrimitiveConstant" .asInt rp)
            ]
                (condp = this
                    Condition'EQ (= x y)
                    Condition'NE (not= x y)
                    Condition'LT (< x y)
                    Condition'LE (<= x y)
                    Condition'GT (< y x)
                    Condition'GE (<= y x)
                    Condition'AE (UnsignedMath'aboveOrEqual-2i x, y)
                    Condition'BE (UnsignedMath'belowOrEqual-2i x, y)
                    Condition'AT (UnsignedMath'aboveThan-2i x, y)
                    Condition'BT (UnsignedMath'belowThan-2i x, y)
                )
            )
            JavaKind/Long
            (let [
                #_"long" x (#_"PrimitiveConstant" .asLong lp)
                #_"long" y (#_"PrimitiveConstant" .asLong rp)
            ]
                (condp = this
                    Condition'EQ (= x y)
                    Condition'NE (not= x y)
                    Condition'LT (< x y)
                    Condition'LE (<= x y)
                    Condition'GT (< y x)
                    Condition'GE (<= y x)
                    Condition'AE (UnsignedMath'aboveOrEqual-2l x, y)
                    Condition'BE (UnsignedMath'belowOrEqual-2l x, y)
                    Condition'AT (UnsignedMath'aboveThan-2l x, y)
                    Condition'BT (UnsignedMath'belowThan-2l x, y)
                )
            )
        )
    )

    (defn #_"Condition" Condition''join-2 [#_"Condition" this, #_"Condition" other]
        (condp = this
            other this
            Condition'EQ
                (cond
                    (any = other Condition'LE Condition'GE Condition'BE Condition'AE) Condition'EQ
                )
            Condition'NE
                (cond
                    (any = other Condition'LT Condition'GT Condition'BT Condition'AT) other
                    (= other Condition'LE) Condition'LT
                    (= other Condition'GE) Condition'GT
                    (= other Condition'BE) Condition'BT
                    (= other Condition'AE) Condition'AT
                )
            Condition'LE
                (cond
                    (any = other Condition'GE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'LT) Condition'LT
                )
            Condition'LT
                (cond
                    (any = other Condition'NE Condition'LE) Condition'LT
                )
            Condition'GE
                (cond
                    (any = other Condition'LE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'GT) Condition'GT
                )
            Condition'GT
                (cond
                    (any = other Condition'NE Condition'GE) Condition'GT
                )
            Condition'BE
                (cond
                    (any = other Condition'AE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'BT) Condition'BT
                )
            Condition'BT
                (cond
                    (any = other Condition'NE Condition'BE) Condition'BT
                )
            Condition'AE
                (cond
                    (any = other Condition'BE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'AT) Condition'AT
                )
            Condition'AT
                (cond
                    (any = other Condition'NE Condition'AE) Condition'AT
                )
        )
    )

    #_unused
    (defn #_"Condition" Condition''meet-2 [#_"Condition" this, #_"Condition" other]
        (condp = this
            other this
            Condition'EQ
                (cond
                    (any = other Condition'LE Condition'GE Condition'BE Condition'AE) other
                    (= other Condition'LT) Condition'LE
                    (= other Condition'GT) Condition'GE
                    (= other Condition'BT) Condition'BE
                    (= other Condition'AT) Condition'AE
                )
            Condition'NE
                (cond
                    (any = other Condition'LT Condition'GT Condition'BT Condition'AT) Condition'NE
                )
            Condition'LE
                (cond
                    (any = other Condition'EQ Condition'LT) Condition'LE
                )
            Condition'LT
                (cond
                    (any = other Condition'EQ Condition'LE) Condition'LE
                    (any = other Condition'NE Condition'GT) Condition'NE
                )
            Condition'GE
                (cond
                    (any = other Condition'EQ Condition'GT) Condition'GE
                )
            Condition'GT
                (cond
                    (any = other Condition'EQ Condition'GE) Condition'GE
                    (any = other Condition'NE Condition'LT) Condition'NE
                )
            Condition'BE
                (cond
                    (any = other Condition'EQ Condition'BT) Condition'BE
                )
            Condition'BT
                (cond
                    (any = other Condition'EQ Condition'BE) Condition'BE
                    (any = other Condition'NE Condition'AT) Condition'NE
                )
            Condition'AE
                (cond
                    (any = other Condition'EQ Condition'AT) Condition'AE
                )
            Condition'AT
                (cond
                    (any = other Condition'EQ Condition'AE) Condition'AE
                    (any = other Condition'NE Condition'BT) Condition'NE
                )
        )
    )
)

;;;
 ; The x86 condition codes used for conditional jumps/moves.
 ;;
(class-ns ConditionFlag []
    (defn- #_"ConditionFlag" ConditionFlag'new-2 [#_"int" value, #_"String" operator]
        (merge (ConditionFlag'class.)
            (hash-map
                #_"int" :value value
                #_"String" :operator operator
            )
        )
    )

    (ยง def #_"ConditionFlag" ConditionFlag'Zero         (ConditionFlag'new-2 0x4, "|zero|"))
    (ยง def #_"ConditionFlag" ConditionFlag'NotZero      (ConditionFlag'new-2 0x5, "|nzero|"))
    (ยง def #_"ConditionFlag" ConditionFlag'Equal        (ConditionFlag'new-2 0x4, "="))
    (ยง def #_"ConditionFlag" ConditionFlag'NotEqual     (ConditionFlag'new-2 0x5, "!="))
    (ยง def #_"ConditionFlag" ConditionFlag'Less         (ConditionFlag'new-2 0xc, "<"))
    (ยง def #_"ConditionFlag" ConditionFlag'LessEqual    (ConditionFlag'new-2 0xe, "<="))
    (ยง def #_"ConditionFlag" ConditionFlag'Greater      (ConditionFlag'new-2 0xf, ">"))
    (ยง def #_"ConditionFlag" ConditionFlag'GreaterEqual (ConditionFlag'new-2 0xd, ">="))
    (ยง def #_"ConditionFlag" ConditionFlag'Below        (ConditionFlag'new-2 0x2, "|<|"))
    (ยง def #_"ConditionFlag" ConditionFlag'BelowEqual   (ConditionFlag'new-2 0x6, "|<=|"))
    (ยง def #_"ConditionFlag" ConditionFlag'Above        (ConditionFlag'new-2 0x7, "|>|"))
    (ยง def #_"ConditionFlag" ConditionFlag'AboveEqual   (ConditionFlag'new-2 0x3, "|>=|"))
    (ยง def #_"ConditionFlag" ConditionFlag'Overflow     (ConditionFlag'new-2 0x0, "|of|"))
    (ยง def #_"ConditionFlag" ConditionFlag'NoOverflow   (ConditionFlag'new-2 0x1, "|nof|"))
    (ยง def #_"ConditionFlag" ConditionFlag'CarrySet     (ConditionFlag'new-2 0x2, "|carry|"))
    (ยง def #_"ConditionFlag" ConditionFlag'CarryClear   (ConditionFlag'new-2 0x3, "|ncarry|"))
    (ยง def #_"ConditionFlag" ConditionFlag'Negative     (ConditionFlag'new-2 0x8, "|neg|"))
    (ยง def #_"ConditionFlag" ConditionFlag'Positive     (ConditionFlag'new-2 0x9, "|pos|"))
    (ยง def #_"ConditionFlag" ConditionFlag'Parity       (ConditionFlag'new-2 0xa, "|par|"))
    (ยง def #_"ConditionFlag" ConditionFlag'NoParity     (ConditionFlag'new-2 0xb, "|npar|"))

    (defn #_"ConditionFlag" ConditionFlag''negate-1 [#_"ConditionFlag" this]
        (condp = this
            ConditionFlag'Zero         ConditionFlag'NotZero
            ConditionFlag'NotZero      ConditionFlag'Zero
            ConditionFlag'Equal        ConditionFlag'NotEqual
            ConditionFlag'NotEqual     ConditionFlag'Equal
            ConditionFlag'Less         ConditionFlag'GreaterEqual
            ConditionFlag'LessEqual    ConditionFlag'Greater
            ConditionFlag'Greater      ConditionFlag'LessEqual
            ConditionFlag'GreaterEqual ConditionFlag'Less
            ConditionFlag'Below        ConditionFlag'AboveEqual
            ConditionFlag'BelowEqual   ConditionFlag'Above
            ConditionFlag'Above        ConditionFlag'BelowEqual
            ConditionFlag'AboveEqual   ConditionFlag'Below
            ConditionFlag'Overflow     ConditionFlag'NoOverflow
            ConditionFlag'NoOverflow   ConditionFlag'Overflow
            ConditionFlag'CarrySet     ConditionFlag'CarryClear
            ConditionFlag'CarryClear   ConditionFlag'CarrySet
            ConditionFlag'Negative     ConditionFlag'Positive
            ConditionFlag'Positive     ConditionFlag'Negative
            ConditionFlag'Parity       ConditionFlag'NoParity
            ConditionFlag'NoParity     ConditionFlag'Parity
        )
    )
)

(class-ns ConditionalEliminationInstance [RecursiveVisitor #_"<Integer>"]
    (defn #_"ConditionalEliminationInstance" ConditionalEliminationInstance'new-3 [#_"Graph" graph, #_"BlockMap<List<Node>>" blockToNodes, #_"NodeMap<Block>" nodeToBlock]
        (merge (ConditionalEliminationInstance'class.)
            (hash-map
                #_"Graph" :graph graph
                #_"NodeMap<InfoElement>" :map (NodeMap'new-1g graph)
                #_"BlockMap<List<Node>>" :blockToNodes blockToNodes
                #_"NodeMap<Block>" :nodeToBlock nodeToBlock
                #_"[Node]" :undo []
                #_"EconomicMap<MergeNode, EconomicMap<ValuePhiNode, PhiInfoElement>>" :mergeMaps (EconomicMap/create)
                ;;;
                 ; Tests which may be eliminated because post dominating tests to prove a broader condition.
                 ;;
                #_"Deque<DeoptimizingGuard>" :pendingTests (ArrayDeque.)
            )
        )
    )

    (defn- #_"InfoElement" ConditionalEliminationInstance''getInfoElements-2 [#_"ConditionalEliminationInstance" this, #_"ValueNode" proxiedValue]
        (let [
            #_"ValueNode" value (GraphUtil'skipPi-1 proxiedValue)
        ]
            (when (some? value)
                (NodeMap''getAndGrow-2 (:map this), value)
            )
        )
    )

    (defn- #_"InfoElement" ConditionalEliminationInstance''nextElement-2 [#_"ConditionalEliminationInstance" this, #_"InfoElement" ie]
        (or (:parent ie)
            (let [
                #_"ValueNode" proxifiedInput (:proxifiedInput ie)
            ]
                (when (satisfies? PiNode proxifiedInput)
                    (ConditionalEliminationInstance''getInfoElements-2 this, (Proxy'''getOriginalNode-1 proxifiedInput))
                )
            )
        )
    )

    (defn- #_"Pair<InfoElement, Stamp>" ConditionalEliminationInstance''recursiveFoldStamp-2 [#_"ConditionalEliminationInstance" this, #_"Node" node]
        (condp satisfies? node
            UnaryNode
                (loop-when [#_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, (Unary'''getValue-1 node))] (some? ie)
                    (let [
                        #_"Stamp" result (UnaryNode'''foldStamp-2 node, (:stamp ie))
                    ]
                        (when (some? result) => (recur (ConditionalEliminationInstance''nextElement-2 this, ie))
                            (Pair/create ie, result)
                        )
                    )
                )
            BinaryNode
                (when (satisfies? ConstantNode (:y node))
                    (loop-when [#_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, (:x node))] (some? ie)
                        (let [
                            #_"Stamp" result (BinaryNode'''foldStamp-3 node, (:stamp ie), (:stamp (:y node)))
                        ]
                            (when (some? result) => (recur (ConditionalEliminationInstance''nextElement-2 this, ie))
                                (Pair/create ie, result)
                            )
                        )
                    )
                )
            nil
        )
    )

    (defn- #_"boolean" ConditionalEliminationInstance''canScheduleAbove-4 [#_"ConditionalEliminationInstance" this, #_"Node" test, #_"Node" target, #_"ValueNode" knownToBeAbove]
        (let [
            #_"Block" targetBlock (get (:nodeToBlock this) target)
            #_"Block" testBlock (get (:nodeToBlock this) test)
        ]
            (or
                (when (and (some? targetBlock) (some? testBlock))
                    (cond
                        (= targetBlock testBlock)
                            (loop-when [#_"ISeq" s (seq (BlockMap''get-2 (:blockToNodes this), targetBlock))] (some? s)
                                (condp = (first s)
                                    test   true
                                    target nil
                                    (recur (next s))
                                )
                            )
                        (ControlFlowGraph'dominates-2 testBlock, targetBlock)
                            true
                    )
                )
                ;; Checking for safe nodes when moving pending tests up.
                (let [
                    #_"boolean'" v'can? (volatile! true)
                ]
                    (Node''applyInputs-2 test,
                        (reify EdgeVisitor
                            (#_"Node" EdgeVisitor'''apply-3 [#_"EdgeVisitor" self, #_"Node" source, #_"Node" target]
                                (when @v'can? ;; => abort the recursion
                                    (cond
                                        (not (satisfies? ValueNode target))                                                               (vreset! v'can? false)
                                        (or (satisfies? ConstantNode target) (= target knownToBeAbove) (satisfies? ParameterNode target)) nil
                                        (or (satisfies? BinaryNode target) (satisfies? UnaryNode target))                                 (Node''applyInputs-2 target, self)
                                        :else                                                                                             (vreset! v'can? false)
                                    )
                                )
                                target
                            )
                        )
                    )
                    @v'can?
                )
            )
        )
    )

    (defn- #_"DeoptimizationAction" ConditionalEliminationInstance'mergeActions-2 [#_"DeoptimizationAction" a1, #_"DeoptimizationAction" a2]
        (when-not (= a1 a2) => a1
            (when (or (and (= a1 DeoptimizationAction/InvalidateRecompile) (= a2 DeoptimizationAction/InvalidateReprofile))
                      (and (= a1 DeoptimizationAction/InvalidateReprofile) (= a2 DeoptimizationAction/InvalidateRecompile))
                  )
                DeoptimizationAction/InvalidateReprofile
            )
        )
    )

    (defn- #_"boolean" ConditionalEliminationInstance'foldGuard-5 [#_"DeoptimizingGuard" thisGuard, #_"DeoptimizingGuard" otherGuard, #_"boolean" outcome, #_"Stamp" guardedValueStamp, #_"GuardRewirer" guardRewirer]
        (let [
            #_"DeoptimizationAction" action (ConditionalEliminationInstance'mergeActions-2 (:action otherGuard), (:action thisGuard))
        ]
            (and (some? action) (= (:speculation otherGuard) (:speculation thisGuard))
                (let [
                    #_"LogicNode" logic (Node''copyWithInputs-1 (DeoptimizingGuard'''getCondition-1 thisGuard))
                ]
                    ;; We have ...; guard(C1); guard(C2);...
                    ;;
                    ;; Where the first guard is 'otherGuard' and the second one 'thisGuard'.
                    ;;
                    ;; Depending on 'outcome', we have C2 => C1 or C2 => !C1.
                    ;;
                    ;; - If C2 => C1, 'mustDeopt' below is false and we transform to ...; guard(C2); ...
                    ;;
                    ;; - If C2 => !C1, 'mustDeopt' is true and we transform to ..; guard(C1); deopt;

                    ;; for the second case, the action of the deopt is copied from there:
                    (StaticDeoptimizingNode'''setAction-2 thisGuard, action)
                    (let [
                        #_"GuardRewirer" rewirer
                            (ร (guard, result, innerGuardedValueStamp, newInput) 
                                (ยง fun
                                    ;; 'result' is 'outcome', 'guard' is 'otherGuard'
                                    (let [
                                        #_"boolean" mustDeopt (= result (:negated? otherGuard))
                                    ]
                                        (if (GuardRewirer'''rewire-5 guardRewirer, guard, (= mustDeopt (:negated? thisGuard)), innerGuardedValueStamp, newInput)
                                            (do
                                                (when-not mustDeopt
                                                    (DeoptimizingGuard'''setCondition-3 otherGuard, logic, (:negated? thisGuard))
                                                    (StaticDeoptimizingNode'''setAction-2 otherGuard, action)
                                                    (StaticDeoptimizingNode'''setReason-2 otherGuard, (:reason thisGuard))
                                                )
                                                true
                                            )
                                            (do
                                                (Node''safeDelete-1 logic)
                                                false
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        ;; move the later test up
                        (GuardRewirer'''rewire-5 rewirer, otherGuard, outcome, guardedValueStamp, nil)
                    )
                )
            )
        )
    )

    ;;;
     ; Get the stamp that may be used for the value for which we are registering the condition.
     ; We may directly use the stamp here without restriction, because any later lookup of the
     ; registered info elements is in the same chain of pi nodes.
     ;;
    (defn- #_"Stamp" ConditionalEliminationInstance'getSafeStamp-1 [#_"ValueNode" value]
        (:stamp value)
    )

    ;;;
     ; We can only use the stamp of a second value involved in the condition if we are sure that
     ; we are not implicitly creating a dependency on a pi node that is responsible for that stamp.
     ; For now, we are conservatively only using the stamps of constants. Under certain circumstances,
     ; we may also be able to use the stamp of the value after skipping pi nodes (e.g. the stamp
     ; of a parameter after inlining, or the stamp of a fixed node that can never be replaced
     ; with a pi node via canonicalization).
     ;;
    (defn- #_"Stamp" ConditionalEliminationInstance'getOtherSafeStamp-1 [#_"ValueNode" value]
        (if (or (satisfies? ConstantNode value) (:isAfterFixedReadPhase (:graph value)))
            (:stamp value)
            (Stamp'''unrestricted-1 (:stamp value))
        )
    )

    ;;;
     ; Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
     ; one, try to move this guard just above that preceding guard so that we can fold it:
     ;
     ;     guard(C1); // preceding guard
     ;     ...
     ;     guard(C2); // thisGuard
     ;
     ; If C2 => C1, transform to:
     ;
     ;     guard(C2);
     ;     ...
     ;;
    (defn- #_"boolean" ConditionalEliminationInstance''foldPendingTest-5 [#_"ConditionalEliminationInstance" this, #_"DeoptimizingGuard" thisGuard, #_"ValueNode" original, #_"Stamp" stamp, #_"GuardRewirer" guardRewirer]
        (loop-when [#_"ISeq" s (seq (:pendingTests this))] (some? s) => false
            (let [
                #_"DeoptimizingGuard" pendingGuard (first s)
                #_"LogicNode" pendingCondition (DeoptimizingGuard'''getCondition-1 pendingGuard)
                #_"TriState" result
                    (condp satisfies? pendingCondition
                        UnaryOpLogicNode
                            (when (= (Unary'''getValue-1 pendingCondition) original) => TriState/UNKNOWN
                                (UnaryOpLogicNode'''tryFold-2 pendingCondition, stamp)
                            )
                        BinaryOpLogicNode
                            (let [
                                #_"ValueNode" x (:x pendingCondition)
                                #_"ValueNode" y (:y pendingCondition)
                            ]
                                (condp = original
                                    x (BinaryOpLogicNode'''tryFold-3 pendingCondition, stamp, (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                                    y (BinaryOpLogicNode'''tryFold-3 pendingCondition, (ConditionalEliminationInstance'getOtherSafeStamp-1 x), stamp)
                                    (when (and (satisfies? IntegerEqualsNode pendingCondition) (satisfies? ConstantNode y) (satisfies? AndNode x) (= (:y x) y) (= (:x x) original)) => TriState/UNKNOWN
                                        (BinaryOpLogicNode'''tryFold-3 pendingCondition, (BinaryOp'''foldStamp-3 (:and (ArithmeticOpTable'forStamp-1 stamp)), stamp, (ConditionalEliminationInstance'getOtherSafeStamp-1 y)), (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                                    )
                                )
                            )
                        TriState/UNKNOWN
                    )
            ]
                ;; The test can be folded using the information available,
                ;; but it can only be moved up if we're sure there's no schedule dependence.
                (or (and (#_"TriState" .isKnown result)
                        (ConditionalEliminationInstance''canScheduleAbove-4 this, (DeoptimizingGuard'''getCondition-1 thisGuard), pendingGuard, original)
                        (ConditionalEliminationInstance'foldGuard-5 thisGuard, pendingGuard, (#_"TriState" .toBoolean result), stamp, guardRewirer)
                    )
                    (recur (next s))
                )
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''registerNewStamp-5 [#_"ConditionalEliminationInstance" this, #_"ValueNode" maybeProxiedValue, #_"Stamp" stamp, #_"GuardingNode" guard, #_"boolean" propagateThroughPis]
        (when (and (some? stamp) (not (Stamp'''isUnrestricted-1 stamp))) => this
            (loop-when [#_"ValueNode" value maybeProxiedValue stamp stamp] (and (some? stamp) (some? value)) => this
                (let [
                    this (update this :map #(NodeMap''setAndGrow-3 %, value, (InfoElement'new-4 stamp, guard, (when (satisfies? PiNode value) value), (NodeMap''getAndGrow-2 %, value))))
                    this (update this :undo conj value)
                ]
                    (cond
                        (and propagateThroughPis (satisfies? PiNode value))
                            (recur (Proxy'''getOriginalNode-1 value) stamp)
                        (satisfies? StampInverter value)
                            (let [
                                value (Unary'''getValue-1 value)
                            ]
                                (recur value (StampInverter'''invertStamp-2 value, stamp))
                            )
                        :else
                            this
                    )
                )
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''registerNewStamp-4 [#_"ConditionalEliminationInstance" this, #_"ValueNode" maybeProxiedValue, #_"Stamp" stamp, #_"GuardingNode" guard]
        (ConditionalEliminationInstance''registerNewStamp-5 this, maybeProxiedValue, stamp, guard, false)
    )

    (defn- #_"this" ConditionalEliminationInstance''registerCondition-4 [#_"ConditionalEliminationInstance" this, #_"LogicNode" logic, #_"boolean" negated?, #_"GuardingNode" guard]
        (when (Node''hasMoreThanOneUsage-1 logic) => this
            (ConditionalEliminationInstance''registerNewStamp-4 this, logic, (if negated? StampFactory'booleanFalse StampFactory'booleanTrue), guard)
        )
    )

    (declare ConditionalEliminationInstance''tryProveGuardCondition-4)

    (defn- #_"boolean" ConditionalEliminationInstance''tryProveCondition-3 [#_"ConditionalEliminationInstance" this, #_"LogicNode" node, #_"GuardRewirer" guardRewirer]
        (ConditionalEliminationInstance''tryProveGuardCondition-4 this, nil, node, guardRewirer)
    )

    (defn- #_"boolean" ConditionalEliminationInstance''tryProveGuardCondition-4 [#_"ConditionalEliminationInstance" this, #_"DeoptimizingGuard" thisGuard, #_"LogicNode" node, #_"GuardRewirer" guardRewirer]
        (loop [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, node)]
            (if (some? infoElement)
                (let [
                    #_"JavaConstant" constant (Stamp'''asConstant-1 (:stamp infoElement))
                ]
                    (when (some? constant) => (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                        ;; No proxified input and stamp required.
                        (GuardRewirer'''rewire-5 guardRewirer, (:guard infoElement), (#_"JavaConstant" .asBoolean constant), nil, nil)
                    )
                )
                (condp satisfies? node
                    UnaryOpLogicNode
                        (let [
                            #_"ValueNode" value (Unary'''getValue-1 node)
                        ]
                            (loop-when [#_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, value)] (some? ie)
                                (let [
                                    #_"TriState" result (UnaryOpLogicNode'''tryFold-2 node, (:stamp ie))
                                ]
                                    (if (#_"TriState" .isKnown result)
                                        (ยง return (GuardRewirer'''rewire-5 guardRewirer, (:guard ie), (#_"TriState" .toBoolean result), (:stamp ie), (:proxifiedInput ie)))
                                        (recur (ConditionalEliminationInstance''nextElement-2 this, ie))
                                    )
                                )
                            )

                            (let [
                                #_"Pair<InfoElement, Stamp>" foldResult (ConditionalEliminationInstance''recursiveFoldStamp-2 this, value)
                            ]
                                (when (some? foldResult)
                                    (let [
                                        #_"TriState" result (UnaryOpLogicNode'''tryFold-2 node, (#_"Pair" .getRight foldResult))
                                    ]
                                        (when (#_"TriState" .isKnown result)
                                            (ยง return (GuardRewirer'''rewire-5 guardRewirer, (:guard (#_"Pair" .getLeft foldResult)), (#_"TriState" .toBoolean result), (#_"Pair" .getRight foldResult), (:proxifiedInput (#_"Pair" .getLeft foldResult))))
                                        )
                                    )
                                )
                                (and (some? thisGuard)
                                    (let [
                                        #_"Stamp" stamp (UnaryOpLogicNode'''getSucceedingStampForValue-2 node, (:negated? thisGuard))
                                    ]
                                        (and (some? stamp) (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, value, stamp, guardRewirer))
                                    )
                                )
                            )
                        )
                    BinaryOpLogicNode
                        (do
                            (loop-when [#_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, (:x node))] (some? ie)
                                (let [
                                    #_"TriState" result (BinaryOpLogicNode'''tryFold-3 node, (:stamp ie), (:stamp (:y node)))
                                ]
                                    (if (#_"TriState" .isKnown result)
                                        (ยง return (GuardRewirer'''rewire-5 guardRewirer, (:guard ie), (#_"TriState" .toBoolean result), (:stamp ie), (:proxifiedInput ie)))
                                        (recur (ConditionalEliminationInstance''nextElement-2 this, ie))
                                    )
                                )
                            )

                            (if (satisfies? ConstantNode (:y node))
                                (let [
                                    #_"Pair<InfoElement, Stamp>" foldResult (ConditionalEliminationInstance''recursiveFoldStamp-2 this, (:x node))
                                ]
                                    (when (some? foldResult)
                                        (let [
                                            #_"TriState" result (BinaryOpLogicNode'''tryFold-3 node, (#_"Pair" .getRight foldResult), (:stamp (:y node)))
                                        ]
                                            (when (#_"TriState" .isKnown result)
                                                (ยง return (GuardRewirer'''rewire-5 guardRewirer, (:guard (#_"Pair" .getLeft foldResult)), (#_"TriState" .toBoolean result), (#_"Pair" .getRight foldResult), (:proxifiedInput (#_"Pair" .getLeft foldResult))))
                                            )
                                        )
                                    )
                                )
                                (loop-when [#_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, (:y node))] (some? ie)
                                    (let [
                                        #_"TriState" result (BinaryOpLogicNode'''tryFold-3 node, (:stamp (:x node)), (:stamp ie))
                                    ]
                                        (if (#_"TriState" .isKnown result)
                                            (ยง return (GuardRewirer'''rewire-5 guardRewirer, (:guard ie), (#_"TriState" .toBoolean result), (:stamp ie), (:proxifiedInput ie)))
                                            (recur (ConditionalEliminationInstance''nextElement-2 this, ie))
                                        )
                                    )
                                )
                            )

                            ;; For complex expressions involving constants, see if it's possible to fold the
                            ;; tests by using stamps one level up in the expression. For instance, (x + n < y)
                            ;; might fold if something is known about x and all other values are constants. The
                            ;; reason for the constant restriction is that if more than 1 real value is involved
                            ;; the code might need to adopt multiple guards to have proper dependences.
                            (when (and (satisfies? BinaryArithmeticNode (:x node)) (satisfies? ConstantNode (:y node)) (satisfies? ConstantNode (:y (:x node))))
                                (loop-when [#_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, (:x (:x node)))] (some? ie)
                                    (let [
                                        #_"Stamp" sx (BinaryNode'''foldStamp-3 (:x node), (:stamp ie), (:stamp (:y (:x node))))
                                        #_"TriState" result (BinaryOpLogicNode'''tryFold-3 node, sx, (:stamp (:y node)))
                                    ]
                                        (if (#_"TriState" .isKnown result)
                                            (ยง return (GuardRewirer'''rewire-5 guardRewirer, (:guard ie), (#_"TriState" .toBoolean result), sx, (:proxifiedInput ie)))
                                            (recur (ConditionalEliminationInstance''nextElement-2 this, ie))
                                        )
                                    )
                                )
                            )

                            (when (and (some? thisGuard) (satisfies? IntegerEqualsNode node) (not (:negated? thisGuard)) (satisfies? ConstantNode (:y node)) (satisfies? AndNode (:x node)) (= (:y (:x node)) (:y node)))
                                ;; This 'and' proves something about some of the bits in and.getX().
                                ;; It's equivalent to or'ing in the mask value since those values are known to be set.
                                (let [
                                    #_"BinaryOp<Or>" op (:or (ArithmeticOpTable'forStamp-1 (:stamp (:x node))))
                                    #_"IntegerStamp" sx (BinaryOp'''foldStamp-3 op, (ConditionalEliminationInstance'getSafeStamp-1 (:x (:x node))), (ConditionalEliminationInstance'getOtherSafeStamp-1 (:y node)))
                                ]
                                    (when (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, (:x (:x node)), sx, guardRewirer)
                                        (ยง return true)
                                    )
                                )
                            )

                            (and (some? thisGuard)
                                (or
                                    (when-not (satisfies? ConstantNode (:x node))
                                        (let [
                                            #_"Stamp" sx (BinaryOpLogicNode'''getSucceedingStampForX-4 node, (:negated? thisGuard), (ConditionalEliminationInstance'getSafeStamp-1 (:x node)), (ConditionalEliminationInstance'getOtherSafeStamp-1 (:y node)))
                                        ]
                                            (when (and (some? sx) (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, (:x node), sx, guardRewirer))
                                                true
                                            )
                                        )
                                    )
                                    (when-not (satisfies? ConstantNode (:y node))
                                        (let [
                                            #_"Stamp" sy (BinaryOpLogicNode'''getSucceedingStampForY-4 node, (:negated? thisGuard), (ConditionalEliminationInstance'getOtherSafeStamp-1 (:x node)), (ConditionalEliminationInstance'getSafeStamp-1 (:y node)))
                                        ]
                                            (when (and (some? sy) (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, (:y node), sy, guardRewirer))
                                                true
                                            )
                                        )
                                    )
                                    false
                                )
                            )
                        )
                    ShortCircuitOrNode
                        (ConditionalEliminationInstance''tryProveCondition-3 this, (:x node),
                            (reify GuardRewirer
                                (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" _, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput]
                                    (if (= result (not (:xNegated node)))
                                        (GuardRewirer'''rewire-5 guardRewirer, guard, true, guardedValueStamp, newInput)
                                        (ConditionalEliminationInstance''tryProveCondition-3 this, (:y node),
                                            (reify GuardRewirer
                                                (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" _, #_"GuardingNode" innerGuard, #_"boolean" innerResult, #_"Stamp" innerGuardedValueStamp, #_"ValueNode" innerNewInput]
                                                    (let [
                                                        #_"ValueNode" proxifiedInput
                                                            (cond
                                                                (nil? newInput)                                      innerNewInput
                                                                (or (nil? innerNewInput) (= innerNewInput newInput)) newInput
                                                                :else (ยง return false) ;; Cannot canonicalize due to different proxied inputs.
                                                            )
                                                    ]
                                                        ;; Can only canonicalize if the guards are equal.
                                                        (and (= innerGuard guard)
                                                            (GuardRewirer'''rewire-5 guardRewirer, guard, (ยง xor innerResult (:yNegated node)), guardedValueStamp, proxifiedInput)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    false
                )
            )
        )
    )

    (defn- #_"void" ConditionalEliminationInstance''introducePisForPhis-2 [#_"ConditionalEliminationInstance" this, #_"MergeNode" merge]
        (let [
            #_"EconomicMap<ValuePhiNode, PhiInfoElement>" mergeMap (get (:mergeMaps this) merge)
        ]
            (when (some? mergeMap)
                (let [
                    #_"MapCursor<ValuePhiNode, PhiInfoElement>" entries (#_"EconomicMap" .getEntries mergeMap)
                ]
                    (loop-when-recur [] (#_"MapCursor" .advance entries) []
                        (let [
                            #_"ValuePhiNode" phi (#_"MapCursor" .getKey entries)
                        ]
                            ;; Phi might have been killed already via a conditional elimination in another branch.
                            (when-not (Node''isDeleted-1 phi)
                                (let [
                                    #_"PhiInfoElement" phiInfoElements (#_"MapCursor" .getValue entries)
                                    #_"Stamp" bestPossibleStamp
                                        (loop-when [bestPossibleStamp nil #_"int" i 0] (< i (PhiNode''valueCount-1 phi)) => bestPossibleStamp
                                            (let [
                                                #_"ValueNode" valueAt (PhiNode''valueAt-2i phi, i)
                                                #_"InfoElement" ie (PhiInfoElement''get-2 phiInfoElements, (AbstractMergeNode''forwardEndAt-2 merge, i))
                                                #_"Stamp" curBestStamp
                                                    (when (some? ie) => (:stamp valueAt)
                                                        (Stamp'''join-2 (:stamp valueAt), (:stamp ie))
                                                    )
                                            ]
                                                (recur (if (some? bestPossibleStamp) (Stamp'''meet-2 bestPossibleStamp, curBestStamp) curBestStamp) (inc i))
                                            )
                                        )
                                ]
                                    (when (some? (Stamp''tryImproveWith-2 (:stamp phi), bestPossibleStamp))
                                        ;; Need to be careful to not run into stamp update cycles with the iterative canonicalization.
                                        (let [
                                            #_"boolean" allow?
                                                (condp satisfies? bestPossibleStamp
                                                    ObjectStamp
                                                        ;; Always allow object stamps.
                                                        true
                                                    IntegerStamp
                                                        (or
                                                            (not= (IntegerStamp''isPositive-1 bestPossibleStamp) (IntegerStamp''isPositive-1 (:stamp phi)))
                                                            (not= (IntegerStamp''isNegative-1 bestPossibleStamp) (IntegerStamp''isNegative-1 (:stamp phi)))
                                                            (not= (IntegerStamp''isStrictlyPositive-1 bestPossibleStamp) (IntegerStamp''isStrictlyPositive-1 (:stamp phi)))
                                                            (not= (IntegerStamp''isStrictlyNegative-1 bestPossibleStamp) (IntegerStamp''isStrictlyNegative-1 (:stamp phi)))
                                                            (some? (Stamp'''asConstant-1 bestPossibleStamp))
                                                            (Stamp'''isUnrestricted-1 (:stamp phi))
                                                        )
                                                    #_else
                                                        (some? (Stamp'''asConstant-1 bestPossibleStamp))
                                                )
                                        ]
                                            (when allow?
                                                (let [
                                                    #_"ValuePhiNode" newPhi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 bestPossibleStamp, merge))
                                                ]
                                                    (dotimes [#_"int" i (PhiNode''valueCount-1 phi)]
                                                        (let [
                                                            #_"ValueNode" valueAt (PhiNode''valueAt-2i phi, i)
                                                            valueAt
                                                                (if (= (Stamp'''meet-2 bestPossibleStamp, (:stamp valueAt)) bestPossibleStamp)
                                                                    valueAt ;; Pi not required here.
                                                                    (let [
                                                                        #_"InfoElement" ie (PhiInfoElement''get-2 phiInfoElements, (AbstractMergeNode''forwardEndAt-2 merge, i))
                                                                    ]
                                                                        (Graph''maybeAddOrUnique-2 (:graph this), (PiNode'create-3 (or (:proxifiedInput ie) valueAt), (:stamp ie), (:guard ie)))
                                                                    )
                                                                )
                                                        ]
                                                            (PhiNode''addInput-2 newPhi, valueAt)
                                                        )
                                                    )
                                                    (ยง ass! phi (Node''replaceAtUsagesAndDelete-2 phi, newPhi))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"boolean" ConditionalEliminationInstance'maybeMultipleUsages-1 [#_"ValueNode" value]
        (or (Node''hasMoreThanOneUsage-1 value) (satisfies? ProxyNode value) (satisfies? PiNode value) (satisfies? StampInverter value))
    )

    (defn- #_"this" ConditionalEliminationInstance''registerNewCondition-4 [#_"ConditionalEliminationInstance" this, #_"LogicNode" logic, #_"boolean" negated?, #_"GuardingNode" guard]
        (let [
            this
                (condp satisfies? logic
                    UnaryOpLogicNode
                        (let [
                            #_"ValueNode" value (Unary'''getValue-1 logic)
                        ]
                            (when (ConditionalEliminationInstance'maybeMultipleUsages-1 value) => this
                                ;; getSucceedingStampForValue doesn't take the (potentially a Pi Node) input stamp into account,
                                ;; so it can be safely propagated.
                                (let [
                                    #_"Stamp" stamp (UnaryOpLogicNode'''getSucceedingStampForValue-2 logic, negated?)
                                ]
                                    (ConditionalEliminationInstance''registerNewStamp-5 this, value, stamp, guard, true)
                                )
                            )
                        )
                    BinaryOpLogicNode
                        (let [
                            #_"ValueNode" x (:x logic)
                            #_"ValueNode" y (:y logic)
                            this
                                (when (and (not (satisfies? ConstantNode x)) (ConditionalEliminationInstance'maybeMultipleUsages-1 x)) => this
                                    (let [
                                        #_"Stamp" stamp (BinaryOpLogicNode'''getSucceedingStampForX-4 logic, negated?, (ConditionalEliminationInstance'getSafeStamp-1 x), (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                                    ]
                                        (ConditionalEliminationInstance''registerNewStamp-4 this, x, stamp, guard)
                                    )
                                )
                            this
                                (when (and (not (satisfies? ConstantNode y)) (ConditionalEliminationInstance'maybeMultipleUsages-1 y)) => this
                                    (let [
                                        #_"Stamp" stamp (BinaryOpLogicNode'''getSucceedingStampForY-4 logic, negated?, (ConditionalEliminationInstance'getOtherSafeStamp-1 x), (ConditionalEliminationInstance'getSafeStamp-1 y))
                                    ]
                                        (ConditionalEliminationInstance''registerNewStamp-4 this, y, stamp, guard)
                                    )
                                )
                        ]
                            (when (and (satisfies? IntegerEqualsNode logic) (satisfies? DeoptimizingGuard guard) (not negated?) (satisfies? ConstantNode y) (satisfies? AndNode x) (= (:y x) y) (ConditionalEliminationInstance'maybeMultipleUsages-1 (:x x))) => this
                                ;; This 'and' proves something about some of the bits in and.getX().
                                ;; It's equivalent to or'ing in the mask value since those values are known to be set.
                                (let [
                                    #_"IntegerStamp" stamp (BinaryOp'''foldStamp-3 (:or (ArithmeticOpTable'forStamp-1 (:stamp x))), (ConditionalEliminationInstance'getSafeStamp-1 (:x x)), (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                                ]
                                    (ConditionalEliminationInstance''registerNewStamp-4 this, (:x x), stamp, guard)
                                )
                            )
                        )
                    this
                )
        ]
            (when (satisfies? DeoptimizingGuard guard)
                (#_"Deque" .push (:pendingTests this), guard)
            )
            (ConditionalEliminationInstance''registerCondition-4 this, logic, negated?, guard)
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processIntegerSwitch-3 [#_"ConditionalEliminationInstance" this, #_"AbstractBeginNode" beginNode, #_"IntegerSwitchNode" integerSwitchNode]
        (let [
            #_"ValueNode" value (:value integerSwitchNode)
        ]
            (when (ConditionalEliminationInstance'maybeMultipleUsages-1 value) => this
                (let [
                    #_"Stamp" stamp (SwitchNode'''getValueStampForSuccessor-2 integerSwitchNode, beginNode)
                ]
                    (when (some? stamp) => this
                        (ConditionalEliminationInstance''registerNewStamp-4 this, value, stamp, beginNode)
                    )
                )
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processAbstractBegin-2 [#_"ConditionalEliminationInstance" this, #_"AbstractBeginNode" beginNode]
        (let [
            #_"Node" predecessor (:predecessor beginNode)
        ]
            (condp satisfies? predecessor
                IfNode            (ConditionalEliminationInstance''registerNewCondition-4 this, (:logic predecessor), (= (:falseSuccessor predecessor) beginNode), beginNode)
                IntegerSwitchNode (ConditionalEliminationInstance''processIntegerSwitch-3 this, beginNode, predecessor)
                                  this
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processFixedGuard-2 [#_"ConditionalEliminationInstance" this, #_"FixedGuardNode" node]
        (let [
            ?
                (ConditionalEliminationInstance''tryProveGuardCondition-4 this, node, (DeoptimizingGuard'''getCondition-1 node),
                    (reify GuardRewirer
                        (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" _, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput]
                            (if (= result (:negated? node))
                                (let [
                                    #_"DeoptimizeNode" deopt (Graph''add-2 (:graph node), (DeoptimizeNode'new-3 (:action node), (:reason node), (:speculation node)))
                                ]
                                    (DeoptBefore'''setStateBefore-2 deopt, (:stateBefore node))
                                    (Node''replaceAtPredecessor-2 node, deopt)
                                    (GraphUtil'killCFG-1 node)
                                )
                                (do
                                    (ยง ass! node (Node''replaceAtUsages-2 node, guard))
                                    (GraphUtil'unlinkFixedNode-1 node)
                                    (GraphUtil'killWithUnusedFloatingInputs-1 node)
                                )
                            )
                            true
                        )
                    )
                )
        ]
            (when-not ? => this
                (ConditionalEliminationInstance''registerNewCondition-4 this, (DeoptimizingGuard'''getCondition-1 node), (:negated? node), node)
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processGuard-2 [#_"ConditionalEliminationInstance" this, #_"GuardNode" node]
        (let [
            ?
                (ConditionalEliminationInstance''tryProveGuardCondition-4 this, node, (DeoptimizingGuard'''getCondition-1 node),
                    (reify GuardRewirer
                        (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" _, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput]
                            (when (= result (:negated? node)) => (ยง ass! node (Node''replaceAndDelete-2 node, guard))
                                (let [
                                    #_"DeoptimizeNode" deopt (Graph''add-2 (:graph node), (DeoptimizeNode'new-3 (:action node), (:reason node), (:speculation node)))
                                    #_"AbstractBeginNode" beginNode (FloatingAnchoredNode''getAnchor-1 node)
                                    #_"FixedNode" _next (:next beginNode)
                                ]
                                    (ยง ass! beginNode (FixedWithNextNode''setNext-2 beginNode, deopt))
                                    (GraphUtil'killCFG-1 _next)
                                )
                            )
                            true
                        )
                    )
                )
        ]
            (when-not ? => this
                (ConditionalEliminationInstance''registerNewCondition-4 this, (DeoptimizingGuard'''getCondition-1 node), (:negated? node), node)
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processConditionAnchor-2 [#_"ConditionalEliminationInstance" this, #_"ConditionAnchorNode" node]
        (ConditionalEliminationInstance''tryProveCondition-3 this, (:logic node),
            (reify GuardRewirer
                (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" _, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput]
                    (if (= result (:negated? node))
                        (let [
                            #_"ValueAnchorNode" anchor (Graph''add-2 (:graph node), (ValueAnchorNode'new-1 nil))
                        ]
                            (ยง ass! node (Node''replaceAtUsages-2 node, anchor))
                            (ยง ass! (:graph node) (Graph''replaceFixedWithFixed-3 (:graph node), node, anchor))
                        )
                        (do
                            (ยง ass! node (Node''replaceAtUsages-2 node, guard))
                            (GraphUtil'unlinkFixedNode-1 node)
                            (GraphUtil'killWithUnusedFloatingInputs-1 node)
                        )
                    )
                    true
                )
            )
        )
        this
    )

    (defn- #_"this" ConditionalEliminationInstance''processIf-2 [#_"ConditionalEliminationInstance" this, #_"IfNode" node]
        (ConditionalEliminationInstance''tryProveCondition-3 this, (:logic node),
            (reify GuardRewirer
                (#_"boolean" GuardRewirer'''rewire-5 [#_"GuardRewirer" _, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput]
                    (let [
                        #_"AbstractBeginNode" survivingSuccessor (IfNode''getSuccessor-2 node, result)
                    ]
                        (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, guard)
                        (Node''replaceAtPredecessor-2 survivingSuccessor, nil)
                        (Node''replaceAtPredecessor-2 node, survivingSuccessor)
                        (GraphUtil'killCFG-1 node)
                        true
                    )
                )
            )
        )
        this
    )

    (defn- #_"this" ConditionalEliminationInstance''processEnd-2 [#_"ConditionalEliminationInstance" this, #_"EndNode" end]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 end)
        ]
            (when (satisfies? MergeNode merge) => this
                (loop-when [#_"EconomicMap<ValuePhiNode, PhiInfoElement>" m (get (:mergeMaps this) merge) #_"ISeq" s (seq (AbstractMergeNode''valuePhis-1 merge))] (some? s)
                    (let [
                        #_"ValuePhiNode" phi (first s)
                        m
                            (loop-when [m m #_"InfoElement" ie (ConditionalEliminationInstance''getInfoElements-2 this, (PhiNode''valueAt-2n phi, end))] (some? ie) => m
                                (let [
                                    #_"Stamp" stamp (:stamp ie)
                                ]
                                    (when (some? (Stamp''tryImproveWith-2 (:stamp phi), stamp)) => (recur m (ConditionalEliminationInstance''nextElement-2 this, ie))
                                        (let [
                                            m (or m (let [m (EconomicMap/create)] (#_"EconomicMap" .put (:mergeMaps this), merge, m) m))
                                            #_"PhiInfoElement" pie
                                                (or (get m phi)
                                                    (let [
                                                        pie (PhiInfoElement'new-0)
                                                    ]
                                                        (#_"EconomicMap" .put m, phi, pie)
                                                        pie
                                                    )
                                                )
                                        ]
                                            (ยง ass! pie (PhiInfoElement''set-3 pie, end, ie))
                                            m
                                        )
                                    )
                                )
                            )
                    ]
                        (recur m (next s))
                    )
                )
                this
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processNode-2 [#_"ConditionalEliminationInstance" this, #_"Node" node]
        (when (and (satisfies? NodeWithState node) (not (satisfies? GuardingNode node)))
            (#_"Deque" .clear (:pendingTests this))
        )
        (when (satisfies? MergeNode node)
            (ConditionalEliminationInstance''introducePisForPhis-2 this, node)
        )
        (condp satisfies? node
            AbstractBeginNode
                (if (and (satisfies? LoopExitNode node) (:hasValueProxies (:graph this)))
                    this ;; condition must not be used down this path
                    (ConditionalEliminationInstance''processAbstractBegin-2 this, node)
                )
            FixedGuardNode      (ConditionalEliminationInstance''processFixedGuard-2      this, node)
            GuardNode           (ConditionalEliminationInstance''processGuard-2           this, node)
            ConditionAnchorNode (ConditionalEliminationInstance''processConditionAnchor-2 this, node)
            IfNode              (ConditionalEliminationInstance''processIf-2              this, node)
            EndNode             (ConditionalEliminationInstance''processEnd-2             this, node)
                                this
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processBlock-2 [#_"ConditionalEliminationInstance" this, #_"Block" block]
        (let [
            #_"FixedNode" end (:endNode block)
        ]
            (loop [this this #_"FixedNode" begin (:beginNode block)]
                (if (= begin end)
                    (when (Node''isAlive-1 end) => this
                        (ConditionalEliminationInstance''processNode-2 this, end)
                    )
                    (when-not (or (Node''isDeleted-1 begin) (Node''isDeleted-1 end)) => this ;; branch was deleted
                        (recur (ConditionalEliminationInstance''processNode-2 this, begin) (:next begin))
                    )
                )
            )
        )
    )

    (defn- #_"this" ConditionalEliminationInstance''processNodes-2 [#_"ConditionalEliminationInstance" this, #_"Block" block]
        (if (some? (:blockToNodes this))
            (reduce ConditionalEliminationInstance''processNode-2 this (filter Node''isAlive-1 (BlockMap''get-2 (:blockToNodes this), block)))
            (ConditionalEliminationInstance''processBlock-2 this, block)
        )
    )

    (defm ConditionalEliminationInstance RecursiveVisitor
        (#_"Integer" RecursiveVisitor'''enter-2 [#_"ConditionalEliminationInstance" this, #_"Block" block]
            (let [
                #_"int" mark (count (:undo this))
            ]
                ;; For now conservatively collect guards only within the same block.
                (#_"Deque" .clear (:pendingTests this))
                (ยง ass! this (ConditionalEliminationInstance''processNodes-2 this, block))
                mark
            )
        )

        (#_"this" RecursiveVisitor'''exit-3 [#_"ConditionalEliminationInstance" this, #_"Block" block, #_"Integer" state]
            (let [
                #_"int" mark state
            ]
                (loop-when this (< mark (count (:undo this))) => this
                    (let [
                        [#_"Node" node this] [(peek (:undo this)) (update this :undo pop)]
                    ]
                        (when (Node''isAlive-1 node)
                            (NodeMap''set-3 (:map this), node, (:parent (get (:map this) node)))
                        )
                        (recur this)
                    )
                )
            )
        )
    )
)

(class-ns ConditionalEliminationPhase [Phase]
    (defn #_"ConditionalEliminationPhase" ConditionalEliminationPhase'new-1 [#_"boolean" fullSchedule]
        (merge (ConditionalEliminationPhase'class.)
            (hash-map
                #_"boolean" :fullSchedule fullSchedule
            )
        )
    )

    (defm ConditionalEliminationPhase Phase
        (#_"Graph" Phase'''run-3 [#_"ConditionalEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"ControlFlowGraph" cfg (ControlFlowGraph'compute-5 graph, true, true, true, true)
                [#_"BlockMap<List<Node>>" blockToNodes #_"NodeMap<Block>" nodeToBlock]
                    (when (:fullSchedule this) => [nil (:nodeToBlock cfg)]
                        (ControlFlowGraph''visitDominatorTree-3 cfg, (MoveGuardsUpwards'new-0), (:hasValueProxies graph))
                        (SchedulePhase'run-3 graph, SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER, cfg)
                        [(:blockToNodesMap (:lastSchedule graph)) (:nodeToBlockMap (:lastSchedule graph))]
                    )
            ]
                (ControlFlowGraph''visitDominatorTree-3 cfg, (ConditionalEliminationInstance'new-3 graph, blockToNodes, nodeToBlock), (:hasValueProxies graph))
                graph
            )
        )
    )
)

;;;
 ; This optimization tries to improve the handling of constants by replacing a single definition of a constant, which is
 ; potentially scheduled into a block with high probability, with one or more definitions in blocks with a lower probability.
 ;;
(class-ns ConstantLoadOptimization [LIRPhase #_"<LIRPhaseContext>"] ;; PreAllocationPhase
    (defn #_"ConstantLoadOptimization" ConstantLoadOptimization'new-0 []
        (ConstantLoadOptimization'class.)
    )

    (defm ConstantLoadOptimization LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"ConstantLoadOptimization" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (CLOptimization''apply-1 (CLOptimization'new-2 (:lir lirGenRes), (:lirGen context)))
            nil
        )
    )
)

;;;
 ; Analyzes a ConstantTree and marks potential materialization positions.
 ;;
(class-ns ConstantTreeAnalyzer []
    (defn- #_"ConstantTreeAnalyzer" ConstantTreeAnalyzer'new-1 [#_"ConstantTree" tree]
        (merge (ConstantTreeAnalyzer'class.)
            (hash-map
                #_"ConstantTree" :tree tree
                #_"BitSet" :visited (BitSet.)
            )
        )
    )

    (defn- #_"boolean" ConstantTreeAnalyzer''isLeafBlock-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (ConstantTree''isLeafBlock-2 (:tree this), block)
    )

    (defn- #_"boolean" ConstantTreeAnalyzer''isMarked-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (ConstantTree''isMarked-2 (:tree this), block)
    )

    (defn- #_"void" ConstantTreeAnalyzer''leafCost-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (DominatorOptimizationProblem''set-3 (:tree this), Flags'CANDIDATE, block)
        (ConstantTree''getOrInitCost-2 (:tree this), block)
        nil
    )

    ;;;
     ; This is the cost function that decides whether a materialization should be inserted in the
     ; current block.
     ;
     ; Note that this function does not take into account if a materialization is required despite
     ; the probabilities (e.g. there are usages in the current block).
     ;
     ; @param probabilityBlock Probability of the current block.
     ; @param probabilityChildren Accumulated probability of the children.
     ; @param numMat Number of materializations along the subtrees. We use {@code numMat - 1} to
     ;            insert materializations as late as possible if the probabilities are the same.
     ;;
    (defn- #_"boolean" ConstantTreeAnalyzer'shouldMaterializerInCurrentBlock-3 [#_"double" probabilityBlock, #_"double" probabilityChildren, #_"int" numMat]
        (< (* probabilityBlock (Math/pow 0.9, (dec numMat))) probabilityChildren)
    )

    ;;;
     ; Calculates the cost of a {@code block}. It is assumed that all {@code children} have already
     ; been {@linkplain #process processed}.
     ;;
    (defn- #_"void" ConstantTreeAnalyzer''process-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (let [
            ;; collect children costs
            [#_"double" bestCost #_"[UseEntry]" usages #_"int" numMat]
                (loop-when [bestCost 0.0 usages [] numMat 0 #_"Block" child (:firstDominated block)] (some? child) => [bestCost usages numMat]
                    (let [
                        [bestCost usages numMat]
                            (when (ConstantTreeAnalyzer''isMarked-2 this, child) => [bestCost usages numMat]
                                (let [
                                    #_"NodeCost" cost (DominatorOptimizationProblem''getCost-2 (:tree this), child)
                                ]
                                    [(+ bestCost (:bestCost cost)) (into usages (:usages cost)) (+ numMat (:numMat cost))]
                                )
                            )
                    ]
                        (recur bestCost usages numMat (:dominatedSibling child))
                    )
                )
            ;; choose block
            #_"[UseEntry]" usagesBlock (ConstantTree''getUsages-2 (:tree this), block)
            [bestCost usages numMat]
                (when (or (seq usagesBlock) (ConstantTreeAnalyzer'shouldMaterializerInCurrentBlock-3 (:probability block), bestCost, numMat)) => [bestCost usages numMat]
                    ;; mark current block as potential materialization position
                    (DominatorOptimizationProblem''set-3 (:tree this), Flags'CANDIDATE, block)
                    [(:probability block) (into usages usagesBlock) 1]
                )
        ]
            (DominatorOptimizationProblem''setCost-3 (:tree this), block, (NodeCost'new-3 bestCost, usages, numMat))
        )
        nil
    )

    (defn- #_"void" ConstantTreeAnalyzer''filteredPush-3 [#_"ConstantTreeAnalyzer" this, #_"Deque<Block>" worklist, #_"Block" block]
        (when (ConstantTreeAnalyzer''isMarked-2 this, block)
            (#_"Deque" .offerLast worklist, block)
        )
        nil
    )

    ;;;
     ; Queues all relevant blocks for {@linkplain #process processing}.
     ;
     ; This is a worklist-style algorithm because a (more elegant) recursive implementation may
     ; cause stack overflows on larger graphs.
     ;
     ; @param startBlock The start block of the dominator subtree.
     ;;
    (defn- #_"void" ConstantTreeAnalyzer''analyzeBlocks-2 [#_"ConstantTreeAnalyzer" this, #_"Block" startBlock]
        (let [
            #_"Deque<Block>" worklist (ArrayDeque.)
        ]
            (loop-when-recur [#_"Block" block startBlock] (some? block) [(#_"Deque" .pollLast worklist)]
                (cond
                    (ConstantTreeAnalyzer''isLeafBlock-2 this, block) (ConstantTreeAnalyzer''leafCost-2 this, block)
                    (#_"BitSet" .get (:visited this), (:id block))    (ConstantTreeAnalyzer''process-2 this, block)
                    :else
                        (do ;; If not yet visited (and not a leaf block), process all children first!
                            (#_"Deque" .offerLast worklist, block)
                            (loop-when-recur [#_"Block" dominated (:firstDominated block)] (some? dominated) [(:dominatedSibling dominated)]
                                (ConstantTreeAnalyzer''filteredPush-3 this, worklist, dominated)
                            )
                            (#_"BitSet" .set (:visited this), (:id block))
                        )
                )
            )
        )
        nil
    )

    (defn #_"NodeCost" ConstantTreeAnalyzer'analyze-2 [#_"ConstantTree" tree, #_"Block" startBlock]
        (let [
            #_"ConstantTreeAnalyzer" analyzer (ConstantTreeAnalyzer'new-1 tree)
        ]
            (ConstantTreeAnalyzer''analyzeBlocks-2 analyzer, startBlock)
            (DominatorOptimizationProblem''getCost-2 tree, startBlock)
        )
    )
)

(class-ns ControlFlowGraph []
    (def #_"int" ControlFlowGraph'BLOCK_ID_INITIAL -1)
    (def #_"int" ControlFlowGraph'BLOCK_ID_VISITED -2)

    ;;;
     ; Don't allow probability values to be become too small or too high as this makes frequency
     ; calculations over- or underflow the range of a double. This commonly happens with infinite
     ; loops within infinite loops. The value is chosen a bit lower than half the maximum exponent
     ; supported by double. That way we can never overflow to infinity when multiplying two
     ; probability values.
     ;;
    (def #_"double" ControlFlowGraph'MIN_PROBABILITY #_"0x1.0p-500" 3.0549363634996047e-151)
    (def #_"double" ControlFlowGraph'MAX_PROBABILITY (/ 1.0 ControlFlowGraph'MIN_PROBABILITY))

    (defn- #_"ControlFlowGraph" ControlFlowGraph'new-1 [#_"Graph" graph]
        (merge (ControlFlowGraph'class.)
            (hash-map
                #_"Graph" :graph graph
                #_"NodeMap<Block>" :nodeToBlock (NodeMap'new-1g graph)
                ;;;
                 ; The list of blocks contained in this control flow graph.
                 ;
                 ; It is guaranteed that the blocks are numbered and ordered according
                 ; to a reverse post order traversal of the control flow graph.
                 ;;
                #_"Block[]" :reversePostOrder nil
                #_"List<Loop>" :loops nil
                #_"int" :maxDominatorDepth 0
            )
        )
    )

    (defn #_"ControlFlowGraph" ControlFlowGraph''setNodeToBlock-2 [#_"ControlFlowGraph" this, #_"NodeMap<Block>" nodeMap]
        (assoc this :nodeToBlock nodeMap)
    )

    (defn #_"Block" ControlFlowGraph''blockFor-2 [#_"ControlFlowGraph" this, #_"Node" node]
        (get (:nodeToBlock this) node)
    )

    (defn #_"Block" ControlFlowGraph''getStartBlock-1 [#_"ControlFlowGraph" this]
        (nth (:reversePostOrder this) 0)
    )

    (defn- #_"void" ControlFlowGraph''identifyBlock-2 [#_"ControlFlowGraph" this, #_"Block" block]
        (loop [#_"FixedWithNextNode" node (:beginNode block)]
            (NodeMap''set-3 (:nodeToBlock this), node, block)
            (let [
                #_"FixedNode" _next (:next node)
            ]
                (condp satisfies? _next
                    AbstractBeginNode
                        (ยง ass! block (assoc block :endNode node))
                    FixedWithNextNode
                        (recur _next)
                    (do
                        (NodeMap''set-3 (:nodeToBlock this), _next, block)
                        (ยง ass! block (assoc block :endNode _next))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" ControlFlowGraph'computeLoopPredecessors-3 [#_"NodeMap<Block>" nodeMap, #_"Block" block, #_"LoopBeginNode" loopBeginNode]
        (let [
            #_"int" forwardEndCount (AbstractMergeNode''forwardEndCount-1 loopBeginNode)
            #_"LoopEndNode[]" loopEnds (LoopBeginNode''orderedLoopEnds-1 loopBeginNode)
            #_"Block[]" predecessors (make-array Block'iface (+ forwardEndCount (count loopEnds)))
        ]
            (dotimes [#_"int" i forwardEndCount]
                (aset predecessors i (get nodeMap (AbstractMergeNode''forwardEndAt-2 loopBeginNode, i)))
            )
            (dotimes [#_"int" i (count loopEnds)]
                (aset predecessors (+ i forwardEndCount) (get nodeMap (nth loopEnds i)))
            )
            (ยง ass! block (Block''setPredecessors-2 block, predecessors))
        )
        nil
    )

    ;;;
     ; Identify and connect blocks (including loop backward edges). Predecessors need to be in the
     ; order expected when iterating phi inputs.
     ;;
    (defn- #_"this" ControlFlowGraph''identifyBlocks-1 [#_"ControlFlowGraph" this]
        ;; Find all block headers.
        (let [
            #_"int" numBlocks
                (loop-when-recur [numBlocks 0 #_"ISeq" s (seq (Graph''getNodes-2 (:graph this), AbstractBeginNode))] (some? s) [(inc numBlocks) (next s)] => numBlocks
                    (ControlFlowGraph''identifyBlock-2 this, (Block'new-1 (first s)))
                )
            ;; Compute reverse post order.
            #_"NodeMap<Block>" nodeMap (:nodeToBlock this)
            #_"Block[]" stack (make-array Block'iface numBlocks)
            #_"Block" startBlock (ControlFlowGraph''blockFor-2 this, (:start (:graph this)))
            _ (aset stack 0 startBlock)
            startBlock (Block''setPredecessors-2 startBlock, Block'EMPTY_ARRAY)
        ]
            (loop [#_"int" tos 0 #_"int" total 0]
                (let [
                    #_"Block" block (nth stack tos)
                    [tos total]
                        (condp = (:id block)
                            ControlFlowGraph'BLOCK_ID_INITIAL
                                ;; First time we see this block: push all successors.
                                (let [
                                    #_"FixedNode" end (:endNode block)
                                    tos
                                        (condp satisfies? end
                                            EndNode
                                                (let [
                                                    #_"Block" suxBlock (get nodeMap (AbstractEndNode'''merge-1 end))
                                                ]
                                                    (when (= (:id suxBlock) ControlFlowGraph'BLOCK_ID_INITIAL)
                                                        (ยง ass tos (inc tos))
                                                        (aset stack tos suxBlock)
                                                    )
                                                    (ยง ass! block (Block''setSuccessors-2 block, (into-array Block'iface [ suxBlock ])))
                                                    tos
                                                )
                                            IfNode
                                                (let [
                                                    #_"Block" trueSucc (get nodeMap (:trueSuccessor end))
                                                ]
                                                    (ยง ass tos (inc tos))
                                                    (aset stack tos trueSucc)
                                                    (let [
                                                        #_"Block" falseSucc (get nodeMap (:falseSuccessor end))
                                                    ]
                                                        (ยง ass tos (inc tos))
                                                        (aset stack tos falseSucc)
                                                        (ยง ass! block (Block''setSuccessors-2 block, (into-array Block'iface [ trueSucc, falseSucc ])))
                                                        (let [
                                                            #_"Block[]" ifPred (into-array Block'iface [ block ])
                                                        ]
                                                            (ยง ass! trueSucc (Block''setPredecessors-2 trueSucc, ifPred))
                                                            (ยง ass! falseSucc (Block''setPredecessors-2 falseSucc, ifPred))
                                                        )
                                                        tos
                                                    )
                                                )
                                            LoopEndNode
                                                (do
                                                    (ยง ass! block (Block''setSuccessors-2 block, (into-array Block'iface [ (get nodeMap (:loopBegin end)) ])))
                                                    tos
                                                )
                                            ControlSinkNode
                                                (do
                                                    (ยง ass! block (Block''setSuccessors-2 block, Block'EMPTY_ARRAY))
                                                    tos
                                                )
                                            #_else
                                                (let [
                                                    #_"int" startTos tos
                                                    #_"Block[]" ifPred (into-array Block'iface [ block ])
                                                    tos
                                                        (loop-when [tos tos #_"ISeq" s (seq (Node''successors-1 end))] (some? s) => tos
                                                            (let [
                                                                #_"Block" sux (get nodeMap (first s))
                                                                tos (inc tos)
                                                            ]
                                                                (aset stack tos sux)
                                                                (ยง ass! sux (Block''setPredecessors-2 sux, ifPred))
                                                                (recur tos (next s))
                                                            )
                                                        )
                                                    #_"int" n (- tos startTos)
                                                    #_"Block[]" successors (make-array Block'iface n)
                                                ]
                                                    (System/arraycopy stack, (inc startTos), successors, 0, n)
                                                    (ยง ass! block (Block''setSuccessors-2 block, successors))
                                                    tos
                                                )
                                        )
                                ]
                                    (ยง ass! block (Block''setId-2 block, ControlFlowGraph'BLOCK_ID_VISITED))
                                    (let [
                                        #_"AbstractBeginNode" beginNode (:beginNode block)
                                    ]
                                        (condp satisfies? beginNode
                                            LoopBeginNode
                                                (ControlFlowGraph'computeLoopPredecessors-3 nodeMap, block, beginNode)
                                            MergeNode
                                                (let [
                                                    #_"int" n (AbstractMergeNode''forwardEndCount-1 beginNode)
                                                    #_"Block[]" predecessors (make-array Block'iface n)
                                                ]
                                                    (dotimes [#_"int" i n]
                                                        (aset predecessors i (get nodeMap (AbstractMergeNode''forwardEndAt-2 beginNode, i)))
                                                    )
                                                    (ยง ass! block (Block''setPredecessors-2 block, predecessors))
                                                )
                                            nil
                                        )
                                    )
                                    [tos total]
                                )
                            ControlFlowGraph'BLOCK_ID_VISITED
                                ;; Second time we see this block: All successors have been processed,
                                ;; so add block to result list. Can safely reuse the stack for this.
                                (let [
                                    tos (dec tos)
                                    total (inc total)
                                    #_"int" i (- numBlocks total)
                                ]
                                    (aset stack i block)
                                    (ยง ass! block (Block''setId-2 block, i))
                                    [tos total]
                                )
                        )
                ]
                    (recur-if (<= 0 tos) [tos total])
                )
            )
            ;; Compute reverse postorder and number blocks.
            (assoc this :reversePostOrder stack)
        )
    )

    (defn- #_"void" ControlFlowGraph''computeProbabilities-1 [#_"ControlFlowGraph" this]
        (doseq [#_"Block" block (:reversePostOrder this)]
            (let [
                #_"Block[]" predecessors (:predecessors block)
                #_"double" probability
                    (case (count predecessors)
                        0   1.0
                        1   (let [
                                #_"Block" pred (nth predecessors 0)
                            ]
                                (when (< 1 (count (:successors pred))) => (:probability pred)
                                    (let [
                                        #_"ControlSplitNode" controlSplit (:endNode pred)
                                    ]
                                        (ControlFlowGraph'multiplyProbabilities-2 (:probability pred), (ControlSplitNode'''probability-2 controlSplit, (:beginNode block)))
                                    )
                                )
                            )
                            (let [
                                probability
                                    (loop-when-recur [probability (:probability (nth predecessors 0)) #_"int" i 1]
                                                     (< i (count predecessors))
                                                     [(+ probability (:probability (nth predecessors i))) (inc i)]
                                                  => probability
                                    )
                            ]
                                (when (satisfies? LoopBeginNode (:beginNode block)) => probability
                                    (ControlFlowGraph'multiplyProbabilities-2 probability, (:loopFrequency (:beginNode block)))
                                )
                            )
                    )
                probability
                    (cond
                        (< probability ControlFlowGraph'MIN_PROBABILITY) ControlFlowGraph'MIN_PROBABILITY
                        (< ControlFlowGraph'MAX_PROBABILITY probability) ControlFlowGraph'MAX_PROBABILITY
                        :else                                            probability
                    )
            ]
                (ยง ass! block (Block''setProbability-2 block, probability))
            )
        )
        nil
    )

    (defn- #_"void" ControlFlowGraph'computeLoopBlocks-4 [#_"Block" start, #_"Loop" looq, #_"Block[]" stack, #_"boolean" usePred]
        (when-not (= (:loop start) looq)
            (ยง ass! start (Block''setLoop-2 start, looq))
            (ยง aset! stack 0 start)
            (#_"List" .add (:blocks looq), start)
            (loop [#_"int" tos 0]
                (let [
                    #_"Block" block (nth stack tos)
                    tos (dec tos)
                    ;; Add predecessors or successors to the loop.
                    tos
                        (loop-when [tos tos #_"ISeq" s (seq (if usePred (:predecessors block) (:successors block)))] (some? s) => tos
                            (let [
                                #_"Block" b (first s)
                                tos
                                    (when-not (= (:loop b) looq) => tos
                                        (let [
                                            tos (inc tos)
                                        ]
                                            (ยง aset! stack tos b)
                                            (ยง ass! b (Block''setLoop-2 b, looq))
                                            (#_"List" .add (:blocks looq), b)
                                            tos
                                        )
                                    )
                            ]
                                (recur tos (next s))
                            )
                        )
                ]
                    (recur-if (<= 0 tos) [tos])
                )
            )
        )
        nil
    )

    (defn- #_"this" ControlFlowGraph''computeLoopInformation-1 [#_"ControlFlowGraph" this]
        (let [
            this (assoc this :loops (ArrayList.))
        ]
            (when (Graph''hasLoops-1 (:graph this))
                (let [
                    #_"Block[]" stack (make-array Block'iface (count (:reversePostOrder this)))
                ]
                    (doseq [#_"Block" block (:reversePostOrder this)]
                        (let [
                            #_"AbstractBeginNode" beginNode (:beginNode block)
                        ]
                            (when (satisfies? LoopBeginNode beginNode)
                                (let [
                                    #_"Loop" parent (:loop block)
                                    #_"Loop" _loop (Loop'new-3 parent, (count (:loops this)), block)
                                ]
                                    (when (some? parent)
                                        (#_"List" .add (:children parent), _loop)
                                    )
                                    (#_"List" .add (:loops this), _loop)
                                    (ยง ass! block (Block''setLoop-2 block, _loop))
                                    (#_"List" .add (:blocks _loop), block)

                                    (doseq [#_"LoopEndNode" end (LoopBeginNode''loopEnds-1 beginNode)]
                                        (ControlFlowGraph'computeLoopBlocks-4 (get (:nodeToBlock this) end), _loop, stack, true)
                                    )

                                    (when-not (= (:guardsStage (:graph this)) GuardsStage'AFTER_FSA)
                                        (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 beginNode)]
                                            (let [
                                                #_"Block" exitBlock (get (:nodeToBlock this) exit)
                                            ]
                                                (ControlFlowGraph'computeLoopBlocks-4 (Block''getFirstPredecessor-1 exitBlock), _loop, stack, true)
                                                (Loop''addExit-2 _loop, exitBlock)
                                            )
                                        )

                                        ;; The following loop can add new blocks to the end of the loop's block list.
                                        (dotimes [#_"int" i (count (:blocks _loop))]
                                            (doseq [#_"Block" sux (:successors (nth (:blocks _loop) i))]
                                                (when-not (or (= (:loop sux) _loop) (and (satisfies? LoopExitNode (:beginNode sux)) (= (:loopBegin (:beginNode sux)) beginNode)))
                                                    (ControlFlowGraph'computeLoopBlocks-4 sux, _loop, stack, false)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            ;; Compute the loop exit blocks after FSA.
            (when (= (:guardsStage (:graph this)) GuardsStage'AFTER_FSA)
                (doseq [#_"Block" b (:reversePostOrder this)]
                    (when (some? (:loop b))
                        (doseq [#_"Block" succ (:successors b)]
                            ;; if the loop of the succ is a different one (or none)
                            (when-not (= (:loop b) (:loop succ))
                                ;; and the succ loop is not a child loop of the curr one
                                (if (nil? (:loop succ))
                                    ;; we might exit multiple loops if b.loops is not a loop at depth 0
                                    (loop-when-recur [#_"Loop" curr (:loop b)] (some? curr) [(:parent curr)]
                                        (Loop''addExit-2 curr, succ)
                                    )
                                    ;; succ also has a loop, might be a child loop
                                    ;;
                                    ;; if it is a child loop, we do not exit a loop. if it is a loop
                                    ;; different than b.loop and not a child loop, it must be a parent
                                    ;; loop, thus we exit all loops between b.loop and succ.loop
                                    ;;
                                    ;; if we exit multiple loops immediately after each other, the bytecode parser
                                    ;; might generate loop exit nodes after another and the CFG will identify them
                                    ;; as separate blocks, we just take the first one and exit all loops at this one
                                    (when-not (= (:parent (:loop succ)) (:loop b))
                                        ;; b.loop must not be a transitive parent of succ.loop
                                        (loop-when-recur [#_"Loop" curr (:loop b)] (and (some? curr) (not= curr (:loop succ))) [(:parent curr)]
                                            (Loop''addExit-2 curr, succ)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            this
        )
    )

    (defn- #_"Block" ControlFlowGraph'commonDominatorRawSameDepth-2 [#_"Block" a, #_"Block" b]
        (loop-when-recur [a a b b] (not= a b) [(:dominator a) (:dominator b)] => a)
    )

    (defn- #_"Block" ControlFlowGraph'commonDominatorRaw-2 [#_"Block" a, #_"Block" b]
        (if (< (:domDepth b) (:domDepth a))
            (ControlFlowGraph'commonDominatorRawSameDepth-2 (Block''getDominator-2 a, (- (:domDepth a) (:domDepth b))), b)
            (ControlFlowGraph'commonDominatorRawSameDepth-2 a, (Block''getDominator-2 b, (- (:domDepth b) (:domDepth a))))
        )
    )

    (defn- #_"void" ControlFlowGraph'calcDominatorRanges-2 [#_"Block" block, #_"int" size]
        (let [
            #_"Block[]" stack (make-array Block'iface size)
        ]
            (aset stack 0 block)
            (let [
                #_"int" tos 0
                #_"int" n 0
            ]
                (loop []
                    (let [
                        #_"Block" cur (nth stack tos)
                        #_"Block" dominated (:firstDominated cur)
                    ]
                        (if (= (:domNumber cur) -1)
                            (do
                                (ยง ass! cur (Block''setDominatorNumber-2 cur, n))
                                (if (some? dominated)
                                    (do
                                        ;; Push children onto stack.
                                        (loop []
                                            (ยง ass tos (inc tos))
                                            (aset stack tos dominated)
                                            (ยง ass dominated (:dominatedSibling dominated))
                                            (recur-if (some? dominated) [])
                                        )
                                    )
                                    (do
                                        (ยง ass! cur (Block''setMaxChildDomNumber-2 cur, n))
                                        (ยง ass tos (dec tos))
                                    )
                                )
                                (ยง ass n (inc n))
                            )
                            (do
                                (ยง ass! cur (Block''setMaxChildDomNumber-2 cur, (:maxChildDomNumber dominated)))
                                (ยง ass tos (dec tos))
                            )
                        )
                        (recur-if (<= 0 tos) [])
                    )
                )
            )
        )
        nil
    )

    (defn- #_"this" ControlFlowGraph''computeDominators-1 [#_"ControlFlowGraph" this]
        (let [
            #_"Block[]" blocks (:reversePostOrder this)
            #_"int" curMaxDominatorDepth
                (loop-when [curMaxDominatorDepth 0 #_"int" i 1] (< i (count blocks)) => curMaxDominatorDepth
                    (let [
                        #_"Block" block (nth blocks i)
                        #_"Block" dominator
                            (loop-when [dominator nil #_"ISeq" s (seq (:predecessors block))] (some? s) => dominator
                                (let [
                                    #_"Block" pred (first s)
                                    dominator
                                        (when-not (Block''isLoopEnd-1 pred) => dominator
                                            (if (some? dominator) (ControlFlowGraph'commonDominatorRaw-2 dominator, pred) pred)
                                        )
                                ]
                                    (recur dominator (next s))
                                )
                            )
                    ]
                        ;; Set dominator.
                        (ยง ass! block (Block''setDominator-2 block, dominator))

                        ;; Keep dominated linked list sorted by block ID such that predecessor blocks are always
                        ;; before successor blocks.
                        (let [
                            #_"Block" currentDominated (:firstDominated dominator)
                        ]
                            (if (and (some? currentDominated) (< (:id currentDominated) (:id block)))
                                (let [
                                    currentDominated
                                        (loop-when-recur currentDominated
                                                         (and (some? (:dominatedSibling currentDominated)) (< (:id (:dominatedSibling currentDominated)) (:id block)))
                                                         (:dominatedSibling currentDominated)
                                                      => currentDominated
                                        )
                                ]
                                    (ยง ass! block (Block''setDominatedSibling-2 block, (:dominatedSibling currentDominated)))
                                    (ยง ass! currentDominated (Block''setDominatedSibling-2 currentDominated, block))
                                )
                                (do
                                    (ยง ass! block (Block''setDominatedSibling-2 block, (:firstDominated dominator)))
                                    (ยง ass! dominator (Block''setFirstDominated-2 dominator, block))
                                )
                            )

                            (recur (max curMaxDominatorDepth (:domDepth block)) (inc i))
                        )
                    )
                )
            this (assoc this :maxDominatorDepth curMaxDominatorDepth)
        ]
            (ControlFlowGraph'calcDominatorRanges-2 (ControlFlowGraph''getStartBlock-1 this), (count (:reversePostOrder this)))
            this
        )
    )

    (defn- #_"Block" ControlFlowGraph'commonPostdominator-2 [#_"Block" a, #_"Block" b]
        (loop-when [a a b b] (not= a b) => a
            (if (< (:id a) (:id b))
                (let [
                    a (:postdominator a)
                ]
                    (recur-if (some? a) [a b])
                )
                (let [
                    b (:postdominator b)
                ]
                    (recur-if (some? b) [a b])
                )
            )
        )
    )

    (defn #_"void" ControlFlowGraph''computePostdominators-1 [#_"ControlFlowGraph" this]
        (loop-when [#_"int" i (dec (count (:reversePostOrder this)))] (<= 0 i)
            (let [
                #_"Block" block (nth (:reversePostOrder this) i)
            ]
                ;; => We do not want the loop header registered as the postdominator of the loop end. ;; => No successors => no postdominator.
                (when (and (not (Block''isLoopEnd-1 block)) (seq (:successors block)))
                    (let [
                        #_"Block" firstSucc (nth (:successors block) 0)
                    ]
                        (if (= (count (:successors block)) 1)
                            (ยง ass! block (assoc block :postdominator firstSucc))
                            (loop-when [#_"Block" postdominator firstSucc #_"ISeq" s (seq (:successors block))] (some? s) => (ยง ass! block (Block''setPostDominator-2 block, postdominator))
                                (let [
                                    postdominator (ControlFlowGraph'commonPostdominator-2 postdominator, (first s))
                                ]
                                    (when (some? postdominator) ;; => There is a dead end => no postdominator available.
                                        (recur postdominator (next s))
                                    )
                                )
                            )
                        )
                    )
                )
                (recur (dec i))
            )
        )
        nil
    )

    (defn #_"ControlFlowGraph" ControlFlowGraph'compute-5 [#_"Graph" graph, #_"boolean" connectBlocks, #_"boolean" computeLoops, #_"boolean" computeDominators, #_"boolean" computePostdominators]
        (let [
            #_"ControlFlowGraph" cfg (ControlFlowGraph'new-1 graph)
        ]
            (ยง ass! cfg (ControlFlowGraph''identifyBlocks-1 cfg))
            (ControlFlowGraph''computeProbabilities-1 cfg)

            (when computeLoops
                (ยง ass! cfg (ControlFlowGraph''computeLoopInformation-1 cfg))
            )
            (when computeDominators
                (ยง ass! cfg (ControlFlowGraph''computeDominators-1 cfg))
            )
            (when computePostdominators
                (ControlFlowGraph''computePostdominators-1 cfg)
            )

            cfg
        )
    )

    (defn- #_"Block" ControlFlowGraph'skipPostDom-1 [#_"Block" block]
        (when (and (some? block) (= (:postdominator (:dominator block)) block)) => block
            ;; This is an always reached block.
            (:dominatedSibling block)
        )
    )

    (defn #_"<V> void" ControlFlowGraph''visitDominatorTreeDefault-2 [#_"ControlFlowGraph" this, #_"RecursiveVisitor<V>" visitor]
        (let [
            #_"Block[]" stack (make-array Block'iface (inc (:maxDominatorDepth this)))
        ]
            (loop-when [#_"Block" block (ControlFlowGraph''getStartBlock-1 this) #_"Object[]" values nil #_"int" j 0 #_"int" i 0] (<= 0 i)
                (let [
                    #_"Block" state (nth stack i)
                ]
                    (when-not (and (some? state) (some? (:dominator state)) (= (:postdominator (:dominator state)) state))
                        (if (nil? state)
                            ;; We enter this block for the first time.
                            (let [
                                #_"V" value (RecursiveVisitor'''enter-2 visitor, block)
                            ]
                                (when (or (some? value) (some? values))
                                    (when (nil? values)
                                        (ยง ass values (make-array Object (inc (:maxDominatorDepth this))))
                                    )
                                    (aset values j value)
                                    (ยง ass j (inc j))
                                )

                                (let [
                                    #_"Block" dominated (ControlFlowGraph'skipPostDom-1 (:firstDominated block))
                                ]
                                    (when (some? dominated)
                                        ;; Descend into dominated.
                                        (aset stack i dominated)
                                        (ยง ass block dominated)
                                        (ยง ass i (inc i))
                                        (aset stack i nil)
                                        (ยง continue )
                                    )
                                )
                            )
                            (let [
                                #_"Block" _next (ControlFlowGraph'skipPostDom-1 (:dominatedSibling state))
                            ]
                                (when (some? _next)
                                    ;; Descend into dominated.
                                    (aset stack i _next)
                                    (ยง ass block _next)
                                    (ยง ass i (inc i))
                                    (aset stack i nil)
                                    (ยง continue )
                                )
                            )
                        )

                        ;; Finished processing all normal dominators.
                        (let [
                            #_"Block" postDom (:postdominator block)
                        ]
                            (when (and (some? postDom) (= (:dominator postDom) block))
                                ;; Descend into post dominator.
                                (aset stack i postDom)
                                (ยง ass block postDom)
                                (ยง ass i (inc i))
                                (aset stack i nil)
                                (ยง continue )
                            )
                        )
                    )

                    ;; Finished processing this node, exit and pop from stack.
                    (let [
                        [j #_"V" value]
                            (when (and (some? values) (pos? j)) => [j nil]
                                (let [
                                    j (dec j)
                                ]
                                    [j (ยง cast #_"V" (nth values j))]
                                )
                            )
                    ]
                        (ยง ass! visitor (RecursiveVisitor'''exit-3 visitor, block, value))
                        (recur (:dominator block) values j (dec i))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" ControlFlowGraph'addDeferredExit-2 [#_"DeferredExit[]" deferredExits, #_"Block" block]
        (let [
            #_"Loop" exitBlockLoop (:loop block)
            #_"int" i
                (loop-when-recur [#_"Loop" outermostExited (:loop (:dominator block))]
                                 (and (some? (:parent outermostExited)) (not= (:parent outermostExited) exitBlockLoop))
                                 [(:parent outermostExited)]
                              => (:index outermostExited)
                )
        ]
            (aset deferredExits i (DeferredExit'new-2 block, (nth deferredExits i)))
        )
        nil
    )

    (defn #_"<V> void" ControlFlowGraph''visitDominatorTreeDeferLoopExits-2 [#_"ControlFlowGraph" this, #_"RecursiveVisitor<V>" visitor]
        (let [
            #_"Block[]" stack (make-array Block'iface (count (:reversePostOrder this)))
            _ (aset stack 0 (ControlFlowGraph''getStartBlock-1 this))
            #_"BitSet" visited (BitSet.)
            #_"DeferredExit[]" deferredExits (make-array DeferredExit'iface (count (:loops this)))
        ]
            (loop-when [#_"Object[]" values nil #_"int" j 0 #_"int" i 0] (<= 0 i)
                (let [
                    #_"Block" block (nth stack i)
                ]
                    (if (#_"BitSet" .get visited, (:id block))
                        (let [
                            [j #_"V" value]
                                (when (and (some? values) (pos? j)) => [j nil]
                                    (let [
                                        j (dec j)
                                    ]
                                        [j (nth values j)]
                                    )
                                )
                            _ (ยง ass! visitor (RecursiveVisitor'''exit-3 visitor, block, value))
                            i (dec i)
                            i
                                (when (Block''isLoopHeader-1 block) => i
                                    (let [
                                        #_"int" loopIndex (:index (:loop block))
                                        #_"DeferredExit" deferredExit (nth deferredExits loopIndex)
                                    ]
                                        (when (some? deferredExit) => i
                                            (let [
                                                i
                                                    (loop-when [i i deferredExit deferredExit] (some? deferredExit) => i
                                                        (let [
                                                            i (inc i)
                                                        ]
                                                            (aset stack i (:block deferredExit))
                                                            (recur i (:next deferredExit))
                                                        )
                                                    )
                                            ]
                                                (aset deferredExits loopIndex nil)
                                                i
                                            )
                                        )
                                    )
                                )
                        ]
                            (recur values j i)
                        )
                        (let [
                            _ (#_"BitSet" .set visited, (:id block))
                            #_"V" value (RecursiveVisitor'''enter-2 visitor, block)
                            [values j]
                                (when (or (some? value) (some? values)) => [values j]
                                    (let [
                                        values (or values (make-array Object (inc (:maxDominatorDepth this))))
                                    ]
                                        (aset values j value)
                                        [values (inc j)]
                                    )
                                )
                            #_"Block" alwaysReached (:postdominator block)
                            [alwaysReached i]
                                (when (and (some? alwaysReached) (= (:dominator alwaysReached) block)) => [nil i]
                                    (if (ControlFlowGraph'isDominatorTreeLoopExit-1 alwaysReached)
                                        (do
                                            (ControlFlowGraph'addDeferredExit-2 deferredExits, alwaysReached)
                                            [alwaysReached i]
                                        )
                                        (let [
                                            i (inc i)
                                        ]
                                            (aset stack i alwaysReached)
                                            [alwaysReached i]
                                        )
                                    )
                                )
                            i
                                (loop-when [i i #_"Block" b (:firstDominated block)] (some? b) => i
                                    (let [
                                        i
                                            (when-not (= b alwaysReached) => i
                                                (if (ControlFlowGraph'isDominatorTreeLoopExit-1 b)
                                                    (do
                                                        (ControlFlowGraph'addDeferredExit-2 deferredExits, b)
                                                        i
                                                    )
                                                    (let [
                                                        i (inc i)
                                                    ]
                                                        (aset stack i b)
                                                        i
                                                    )
                                                )
                                            )
                                    ]
                                        (recur i (:dominatedSibling b))
                                    )
                                )
                        ]
                            (recur values j i)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"<V> void" ControlFlowGraph''visitDominatorTree-3 [#_"ControlFlowGraph" this, #_"RecursiveVisitor<V>" visitor, #_"boolean" deferLoopExits]
        (if (and deferLoopExits (seq (:loops this)))
            (ControlFlowGraph''visitDominatorTreeDeferLoopExits-2 this, visitor)
            (ControlFlowGraph''visitDominatorTreeDefault-2 this, visitor)
        )
        nil
    )

    (defn #_"boolean" ControlFlowGraph'isDominatorTreeLoopExit-1 [#_"Block" b]
        (let [
            #_"Block" dominator (:dominator b)
        ]
            (and (some? dominator) (not= (:loop b) (:loop dominator)) (or (not (Block''isLoopHeader-1 b)) (<= (Block''getLoopDepth-1 b) (Block''getLoopDepth-1 dominator))))
        )
    )

    ;;;
     ; Multiplies a and b and clamps the between ControlFlowGraph#MIN_PROBABILITY and
     ; ControlFlowGraph#MAX_PROBABILITY.
     ;;
    (defn #_"double" ControlFlowGraph'multiplyProbabilities-2 [#_"double" a, #_"double" b]
        (let [
            #_"double" r (* a b)
        ]
            (cond
                (< ControlFlowGraph'MAX_PROBABILITY r) ControlFlowGraph'MAX_PROBABILITY
                (< r ControlFlowGraph'MIN_PROBABILITY) ControlFlowGraph'MIN_PROBABILITY
                :else                                  r
            )
        )
    )

    ;;;
     ; True if block {@code a} is dominated by block {@code b}.
     ;;
    (defn #_"boolean" ControlFlowGraph'isDominatedBy-2 [#_"Block" a, #_"Block" b]
        (<= (:domNumber b) (:domNumber a) (:maxChildDomNumber b))
    )

    ;;;
     ; True if block {@code a} dominates block {@code b}.
     ;;
    (defn #_"boolean" ControlFlowGraph'dominates-2 [#_"Block" a, #_"Block" b]
        (ControlFlowGraph'isDominatedBy-2 b, a)
    )

    ;;;
     ; True if block {@code a} dominates block {@code b} and {@code a} is not identical block to {@code b}.
     ;;
    #_unused
    (defn #_"boolean" ControlFlowGraph'strictlyDominates-2 [#_"Block" a, #_"Block" b]
        (and (not= a b) (ControlFlowGraph'dominates-2 a, b))
    )

    ;;;
     ; Calculates the common dominator of two blocks.
     ;
     ; Note that this algorithm makes use of special properties regarding the numbering of blocks.
     ;;
    (defn #_"Block" ControlFlowGraph'commonDominator-2 [#_"Block" a, #_"Block" b]
        (cond
            (nil? a) b (nil? b) a (= a b) a
            :else
                (let [
                    [a b] (if (< (:domDepth b) (:domDepth a)) [a b] [b a])
                    b (loop-when-recur b (< (:domNumber a)         (:domNumber b)) (:dominator b) => b)
                    b (loop-when-recur b (< (:maxChildDomNumber b) (:domNumber a)) (:dominator b) => b)
                ]
                    b
                )
        )
    )
)

;;;
 ; This class performs basic optimizations on the control flow graph after LIR generation.
 ;;
(class-ns ControlFlowOptimizer [LIRPhase #_"<LIRPhaseContext>"] ;; PostAllocationPhase
    (defn #_"ControlFlowOptimizer" ControlFlowOptimizer'new-0 []
        (ControlFlowOptimizer'class.)
    )

    ;;;
     ; Performs control flow optimizations on the given LIR graph.
     ;;
    (defm ControlFlowOptimizer LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"ControlFlowOptimizer" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (let [
                #_"LIR" lir (:lir lirGenRes)
            ]
                (CFOptimizer''deleteEmptyBlocks-2 (CFOptimizer'new-1 lir), (:codeEmittingOrder lir))
            )
            nil
        )
    )
)

;;;
 ; This phase will find branches which always end with a DeoptimizeNode and replace their
 ; ControlSplitNodes with FixedGuardNodes.
 ;
 ; This is useful because FixedGuardNodes will be lowered to GuardNodes, which can later
 ; be optimized more aggressively than control-flow constructs.
 ;
 ; This is currently only done for branches that start from a IfNode. If it encounters
 ; a branch starting at an other kind of ControlSplitNode, it will only bring the
 ; DeoptimizeNode as close to the ControlSplitNode as possible.
 ;;
(class-ns ConvertDeoptimizeToGuardPhase [Phase]
    (defn #_"ConvertDeoptimizeToGuardPhase" ConvertDeoptimizeToGuardPhase'new-0 []
        (ConvertDeoptimizeToGuardPhase'class.)
    )

    (defn- #_"void" ConvertDeoptimizeToGuardPhase'moveAsDeoptAfter-2 [#_"FixedWithNextNode" node, #_"StaticDeoptimizingNode" deopt]
        (let [
            #_"FixedNode" _next (:next node)
        ]
            (when-not (= _next deopt)
                (ยง ass! node (FixedWithNextNode''setNext-2 node, (Graph''add-2 (:graph node), (DeoptimizeNode'new-3 (:action deopt), (:reason deopt), (:speculation deopt)))))
                (GraphUtil'killCFG-1 _next)
            )
        )
        nil
    )

    (defn- #_"void" ConvertDeoptimizeToGuardPhase''propagateFixed-3 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedNode" from, #_"StaticDeoptimizingNode" deopt]
        (loop-when [#_"Node" node from] (some? node)
            (let [
                #_"Node" predecessor (:predecessor node)
            ]
                (if (and GraalOptions'guardPriorities (satisfies? FixedGuardNode node))
                    (when (GuardPriority'isHigherPriorityThan-2 (StaticDeoptimizingNode'''computePriority-1 node), (StaticDeoptimizingNode'''computePriority-1 deopt)) => (recur predecessor)
                        (ConvertDeoptimizeToGuardPhase'moveAsDeoptAfter-2 node, deopt)
                    )
                    (when (satisfies? AbstractBeginNode node) => (recur predecessor)
                        (cond
                            (satisfies? AbstractMergeNode node)
                                (let [
                                    #_"FixedNode" _next (:next node)
                                ]
                                    (while (Node''isAlive-1 node)
                                        (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, (first (:ends node)), deopt)
                                    )
                                    (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, _next, deopt)
                                )
                            (satisfies? IfNode predecessor)
                                (let [
                                    ;; prioritize the source position of the IfNode
                                    #_"Graph" graph (:graph predecessor)
                                    #_"boolean" negateGuardCondition (= node (:trueSuccessor predecessor))
                                    #_"FixedGuardNode" guard (Graph''add-2 graph, (FixedGuardNode'new-5 (:logic predecessor), (:reason deopt), (:action deopt), (:speculation deopt), negateGuardCondition))
                                    #_"FixedWithNextNode" pred (:predecessor predecessor)
                                    #_"AbstractBeginNode" survivingSuccessor (if negateGuardCondition (:falseSuccessor predecessor) (:trueSuccessor predecessor))
                                ]
                                    (Graph''removeSplitPropagate-3 graph, predecessor, survivingSuccessor)
                                    (let [
                                        #_"Node" newGuard (if (satisfies? LoopExitNode survivingSuccessor) (ProxyNode'forGuard-3 guard, survivingSuccessor, graph) guard)
                                    ]
                                        (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, newGuard)
                                        (let [
                                            #_"FixedNode" _next (:next pred)
                                        ]
                                            (ยง ass! pred (FixedWithNextNode''setNext-2 pred, guard))
                                            (ยง ass! guard (FixedWithNextNode''setNext-2 guard, _next))
                                            (Simplifiable'''simplify-2 survivingSuccessor, (DefaultSimplifierTool'new-0))
                                        )
                                    )
                                )
                            :else
                                (when (or (nil? predecessor) (satisfies? ControlSplitNode predecessor)) => (recur predecessor)
                                    (ConvertDeoptimizeToGuardPhase'moveAsDeoptAfter-2 (ยง cast #_"AbstractBeginNode" node), deopt)
                                )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" ConvertDeoptimizeToGuardPhase''processFixedGuardAndMerge-8 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedGuardNode" fixedGuard, #_"CompareNode" compare, #_"ValueNode" x, #_"ValuePhiNode" xPhi, #_"ValueNode" y, #_"ValuePhiNode" yPhi, #_"AbstractMergeNode" merge]
        (let [
            #_"EndNode*" predecessors (ยง snap (Node'''cfgPredecessors-1 merge))
        ]
            (loop-when [#_"int" i 0] (< i (count predecessors))
                (let [
                    #_"AbstractEndNode" pred (nth predecessors i)
                ]
                    (when (Node''isAlive-1 pred)
                        (let [
                            #_"Constant" xs (ValueNode''asConstant-1 (if (some? xPhi) (PhiNode''valueAt-2n xPhi, pred) x))
                            #_"Constant" ys (ValueNode''asConstant-1 (if (some? yPhi) (PhiNode''valueAt-2n yPhi, pred) y))
                        ]
                            (when (and (some? xs) (some? ys) (= (Condition''foldCondition-3c (:condition compare), xs, ys) (:negated? fixedGuard)))
                                (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, pred, fixedGuard)
                            )
                            (recur (inc i))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" ConvertDeoptimizeToGuardPhase''processFixedGuardAndPhis-7 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedGuardNode" fixedGuard, #_"CompareNode" compare, #_"ValueNode" x, #_"ValuePhiNode" xPhi, #_"ValueNode" y, #_"ValuePhiNode" yPhi]
        (let [
            #_"AbstractBeginNode" pred (AbstractBeginNode'prevBegin-1 fixedGuard)
        ]
            (when (and (satisfies? AbstractMergeNode pred) (or (nil? xPhi) (= (:merge xPhi) pred)) (or (nil? yPhi) (= (:merge yPhi) pred)))
                (ConvertDeoptimizeToGuardPhase''processFixedGuardAndMerge-8 this, fixedGuard, compare, x, xPhi, y, yPhi, pred)
            )
        )
        nil
    )

    (defn- #_"void" ConvertDeoptimizeToGuardPhase''trySplitFixedGuard-2 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedGuardNode" fixedGuard]
        (let [
            #_"LogicNode" logic (DeoptimizingGuard'''getCondition-1 fixedGuard)
        ]
            (when (satisfies? CompareNode logic)
                (let [
                    #_"ValueNode" x (:x logic)
                    #_"ValuePhiNode" xPhi (when (satisfies? ValuePhiNode x) x)
                ]
                    (when (or (satisfies? ConstantNode x) (some? xPhi))
                        (let [
                            #_"ValueNode" y (:y logic)
                            #_"ValuePhiNode" yPhi (when (satisfies? ValuePhiNode y) y)
                        ]
                            (when (or (satisfies? ConstantNode y) (some? yPhi))
                                (ConvertDeoptimizeToGuardPhase''processFixedGuardAndPhis-7 this, fixedGuard, logic, x, xPhi, y, yPhi)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defm ConvertDeoptimizeToGuardPhase Phase
        (#_"Graph" Phase'''run-3 [#_"ConvertDeoptimizeToGuardPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (doseq [#_"DeoptimizeNode" d (Graph''getNodes-2 graph, DeoptimizeNode)]
                (when-not (= (:action d) DeoptimizationAction/None)
                    (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, d, d)
                )
            )
            (when (some? context)
                (doseq [#_"FixedGuardNode" fixedGuard (Graph''getNodes-2 graph, FixedGuardNode)]
                    (ConvertDeoptimizeToGuardPhase''trySplitFixedGuard-2 this, fixedGuard)
                )
            )
            (Phase'''run-3 (DeadCodeEliminationPhase'new-1 Optionality'Optional), graph, nil)
        )
    )
)

(class-ns CountedLoopInfo []
    (defn #_"CountedLoopInfo" CountedLoopInfo'new-6 [#_"LoopEx" _loop, #_"InductionVariable" iv, #_"IfNode" ifNode, #_"ValueNode" end, #_"boolean" oneOff, #_"AbstractBeginNode" body]
        (merge (CountedLoopInfo'class.)
            (hash-map
                #_"LoopEx" :loop _loop
                #_"InductionVariable" :iv iv
                #_"ValueNode" :end end
                #_"boolean" :oneOff oneOff
                #_"AbstractBeginNode" :body body
                #_"IfNode" :ifNode ifNode
            )
        )
    )

    ;;;
     ; Returns a node that computes the maximum trip count of this loop. That is the trip count of
     ; this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
     ; count check}.
     ;
     ; This count is exact if #isExactTripCount() returns true.
     ;
     ; THIS VALUE SHOULD BE TREATED AS UNSIGNED.
     ;;
    (defn #_"ValueNode" CountedLoopInfo''maxTripCountNode-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''maxTripCountNode-2 this, false)
    )

    ;;;
     ; Returns a node that computes the maximum trip count of this loop. That is the trip count of
     ; this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
     ; count check}.
     ;
     ; This count is exact if #isExactTripCount() returns true.
     ;
     ; THIS VALUE SHOULD BE TREATED AS UNSIGNED.
     ;
     ; @param assumePositive if true the check that the loop is entered at all will be omitted.
     ;;
    (defn #_"ValueNode" CountedLoopInfo''maxTripCountNode-2 [#_"CountedLoopInfo" this, #_"boolean" assumePositive]
        (let [
            #_"Graph" graph (:graph (InductionVariable'''valueNode-1 (:iv this)))
            #_"Stamp" stamp (:stamp (InductionVariable'''valueNode-1 (:iv this)))
            [#_"ValueNode" absStride #_"ValueNode" range #_"ValueNode" max #_"ValueNode" min]
                (if (= (InductionVariable'''direction-1 (:iv this)) :Direction'Up)
                    [
                        (InductionVariable'''strideNode-1 (:iv this))
                        (MathUtil'sub-3 graph, (:end this), (InductionVariable'''initNode-1 (:iv this)))
                        (:end this)
                        (InductionVariable'''initNode-1 (:iv this))
                    ]
                    [
                        (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 (InductionVariable'''strideNode-1 (:iv this))))
                        (MathUtil'sub-3 graph, (InductionVariable'''initNode-1 (:iv this)), (:end this))
                        (InductionVariable'''initNode-1 (:iv this))
                        (:end this)
                    ]
                )
            #_"ConstantNode" one (ConstantNode'forIntegerStamp-3 stamp, 1, graph)
            range (if (:oneOff this) (MathUtil'add-3 graph, range, one) range)
            ;; round-away-from-zero divison: (range + stride -/+ 1) / stride
            #_"ValueNode" denominator (MathUtil'add-3 graph, range, (MathUtil'sub-3 graph, absStride, one))
            #_"ValueNode" div (MathUtil'unsignedDivBefore-4 graph, (LoopEx''entryPoint-1 (:loop this)), denominator, absStride)
        ]
            (if assumePositive
                div
                (Graph''add-2 graph, (ConditionalNode'new-3 (Graph''add-2 graph, (IntegerLessThanNode'new-2 max, min)), (ConstantNode'forIntegerStamp-3 stamp, 0, graph), div))
            )
        )
    )

    ;;;
     ; @return true if the loop has constant bounds
     ;;
    (defn #_"boolean" CountedLoopInfo''isConstantMaxTripCount-1 [#_"CountedLoopInfo" this]
        (and (satisfies? ConstantNode (:end this)) (InductionVariable'''isConstantInit-1 (:iv this)) (InductionVariable'''isConstantStride-1 (:iv this)))
    )

    ;;;
     ; Compute the raw value of the trip count for this loop. THIS IS AN UNSIGNED VALUE!
     ;;
    (defn- #_"long" CountedLoopInfo''rawConstantMaxTripCount-1 [#_"CountedLoopInfo" this]
        (let [
            #_"long" endValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:end this)))
            #_"long" initValue (InductionVariable'''constantInit-1 (:iv this))
            [#_"long" range #_"long" absStride]
                (if (= (InductionVariable'''direction-1 (:iv this)) :Direction'Up)
                    (if (< endValue initValue)
                        (ยง return 0)
                        [(- endValue (InductionVariable'''constantInit-1 (:iv this))) (InductionVariable'''constantStride-1 (:iv this))]
                    )
                    (if (< initValue endValue)
                        (ยง return 0)
                        [(- (InductionVariable'''constantInit-1 (:iv this)) endValue) (- (InductionVariable'''constantStride-1 (:iv this)))]
                    )
                )
            range (if (:oneOff this) (inc range) range)
        ]
            (Long/divideUnsigned (dec (+ range absStride)), absStride)
        )
    )

    (defn #_"UnsignedLong" CountedLoopInfo''constantMaxTripCount-1 [#_"CountedLoopInfo" this]
        (UnsignedLong'new-1 (CountedLoopInfo''rawConstantMaxTripCount-1 this))
    )

    (defn #_"boolean" CountedLoopInfo''isExactTripCount-1 [#_"CountedLoopInfo" this]
        (= (count (LoopBeginNode''loopExits-1 (LoopEx''loopBegin-1 (:loop this)))) 1)
    )

    #_unused
    (defn #_"ValueNode" CountedLoopInfo''exactTripCountNode-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''maxTripCountNode-1 this)
    )

    (defn #_"boolean" CountedLoopInfo''isConstantExactTripCount-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''isConstantMaxTripCount-1 this)
    )

    #_unused
    (defn #_"UnsignedLong" CountedLoopInfo''constantExactTripCount-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''constantMaxTripCount-1 this)
    )

    (defn #_"ValueNode" CountedLoopInfo''getStart-1 [#_"CountedLoopInfo" this]
        (InductionVariable'''initNode-1 (:iv this))
    )

    (defn #_"GuardingNode" CountedLoopInfo''getOverFlowGuard-1 [#_"CountedLoopInfo" this]
        (:overflowGuard (LoopEx''loopBegin-1 (:loop this)))
    )

    (defn #_"GuardingNode" CountedLoopInfo''createOverFlowGuard-1 [#_"CountedLoopInfo" this]
        (or (CountedLoopInfo''getOverFlowGuard-1 this)
            (let [
                #_"IntegerStamp" stamp (:stamp (InductionVariable'''valueNode-1 (:iv this)))
                #_"Graph" graph (:graph (InductionVariable'''valueNode-1 (:iv this)))
                #_"ConstantNode" one (ConstantNode'forIntegerStamp-3 stamp, 1, graph)
                #_"CompareNode" cond ;; we use a negated guard with a < condition to achieve a >=
                    (if (= (InductionVariable'''direction-1 (:iv this)) :Direction'Up)
                        (let [
                            #_"ValueNode" v1 (MathUtil'sub-3 graph, (ConstantNode'forIntegerStamp-3 stamp, (CodeUtil/maxValue (:bits stamp)), graph), (MathUtil'sub-3 graph, (InductionVariable'''strideNode-1 (:iv this)), one))
                        ]
                            (Graph''add-2 graph, (IntegerLessThanNode'new-2 (if (:oneOff this) (MathUtil'sub-3 graph, v1, one) v1), (:end this)))
                        )
                        (let [
                            #_"ValueNode" v1 (MathUtil'add-3 graph, (ConstantNode'forIntegerStamp-3 stamp, (CodeUtil/minValue (:bits stamp)), graph), (MathUtil'sub-3 graph, one, (InductionVariable'''strideNode-1 (:iv this))))
                        ]
                            (Graph''add-2 graph, (IntegerLessThanNode'new-2 (:end this), (if (:oneOff this) (MathUtil'add-3 graph, v1, one) v1)))
                        )
                    )
                #_"GuardingNode" overflowGuard (Graph''add-2 graph, (GuardNode'new-6 cond, (AbstractBeginNode'prevBegin-1 (LoopEx''entryPoint-1 (:loop this))), DeoptimizationReason/LoopLimitCheck, DeoptimizationAction/InvalidateRecompile, true, JavaConstant/NULL_POINTER))
            ]
                (ยง ass! (LoopEx''loopBegin-1 (:loop this)) (LoopBeginNode''setOverflowGuard-2 (LoopEx''loopBegin-1 (:loop this)), overflowGuard))
                overflowGuard
            )
        )
    )

    (defn #_"IntegerStamp" CountedLoopInfo''getStamp-1 [#_"CountedLoopInfo" this]
        (:stamp (InductionVariable'''valueNode-1 (:iv this)))
    )
)

(class-ns CurrentInvoke []
    (defn #_"CurrentInvoke" CurrentInvoke'new-3 [#_"ValueNode[]" args, #_"InvokeKind" kind, #_"JavaType" returnType]
        (merge (CurrentInvoke'class.)
            (hash-map
                #_"ValueNode[]" :args args
                #_"InvokeKind" :kind kind
                #_"JavaType" :returnType returnType
            )
        )
    )
)

(class-ns Data []
    (defn #_"Data" Data'new-2 [#_"int" alignment, #_"int" size]
        (merge (Data'class.)
            (hash-map
                #_"int" :alignment alignment
                #_"int" :size size
                ;; initialized in DataSection.insertData(Data)
                #_"DataSectionReference" :ref nil
            )
        )
    )

    (defn #_"this" Data''updateAlignment-2 [#_"Data" this, #_"int" alignment]
        (when-not (= alignment (:alignment this)) => this
            (update this :alignment DataSection'lcm-2 alignment)
        )
    )
)

(class-ns RawData [Data]
    (defn #_"RawData" RawData'new-2 [#_"byte[]" data, #_"int" alignment]
        (merge (RawData'class.) (Data'new-2 alignment, (count data))
            (hash-map
                #_"byte[]" :data data
            )
        )
    )

    (defm RawData Data
        (#_"void" Data'''emit-3 [#_"RawData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
            (#_"ByteBuffer" .put buffer, (:data this))
            nil
        )
    )
)

(class-ns ZeroData [Data]
    (defn #_"ZeroData" ZeroData'new-2 [#_"int" alignment, #_"int" size]
        (merge (ZeroData'class.) (Data'new-2 alignment, size))
    )

    (defn #_"ZeroData" ZeroData'create-2 [#_"int" alignment, #_"int" size]
        (case size
            1   (ยง proxy #_"ZeroData" (ZeroData'new-2 alignment, size)
                    (defm ZeroData Data
                        (#_"void" Data'''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                            (#_"ByteBuffer" .put buffer, (byte 0))
                            nil
                        )
                    )
                )
            2   (ยง proxy #_"ZeroData" (ZeroData'new-2 alignment, size)
                    (defm ZeroData Data
                        (#_"void" Data'''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                            (#_"ByteBuffer" .putShort buffer, (short 0))
                            nil
                        )
                    )
                )
            4   (ยง proxy #_"ZeroData" (ZeroData'new-2 alignment, size)
                    (defm ZeroData Data
                        (#_"void" Data'''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                            (#_"ByteBuffer" .putInt buffer, 0)
                            nil
                        )
                    )
                )
            8   (ยง proxy #_"ZeroData" (ZeroData'new-2 alignment, size)
                    (defm ZeroData Data
                        (#_"void" Data'''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                            (#_"ByteBuffer" .putLong buffer, 0)
                            nil
                        )
                    )
                )
            (ZeroData'new-2 alignment, size)
        )
    )

    (defm ZeroData Data
        (#_"void" Data'''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
            (let [
                #_"int" n
                    (loop-when-recur [n (:size this)] (< 8 n) [(- n 8)] => n
                        (#_"ByteBuffer" .putLong buffer, 0)
                    )
            ]
                (loop-when-recur n (pos? n) (dec n)
                    (#_"ByteBuffer" .put buffer, (byte 0))
                )
            )
            nil
        )
    )
)

(class-ns DataSection []
    (defn #_"DataSection" DataSection'new-0 []
        (merge (DataSection'class.)
            (hash-map
                #_"ArrayList<Data>" :dataItems (ArrayList.)
                #_"boolean" :closed false
                #_"int" :sectionAlignment 0
                #_"int" :sectionSize 0
            )
        )
    )

    (defn- #_"void" DataSection''checkOpen-1 [#_"DataSection" this]
        (when (:closed this)
            (throw (IllegalStateException.))
        )
        nil
    )

    (defn- #_"void" DataSection''checkClosed-1 [#_"DataSection" this]
        (when-not (:closed this)
            (throw (IllegalStateException.))
        )
        nil
    )

    ;;;
     ; Inserts a Data item into the data section. If the item is already in the
     ; data section, the same DataSectionReference is returned.
     ;
     ; @param data the Data item to be inserted
     ; @return a unique DataSectionReference identifying the Data item
     ;;
    (defn #_"DataSectionReference" DataSection''insertData-2 [#_"DataSection" this, #_"Data" data]
        (DataSection''checkOpen-1 this)
        (locking data
            (when (nil? (:ref data))
                (ยง ass data (assoc data :ref (DataSectionReference.)))
                (#_"ArrayList" .add (:dataItems this), data)
            )
            (:ref data)
        )
    )

    (defn #_"int" DataSection'lcm-2 [#_"int" x, #_"int" y]
        (cond
            (zero? x) y
            (zero? y) x
            :else     (loop-when-recur [#_"int" a (max x y) #_"int" b (min x y)] (pos? b) [b (% a b)] => (quot (* x y) a))
        )
    )

    (defn- #_"int" DataSection'align-2 [#_"int" position, #_"int" alignment]
        (* (quot (dec (+ position alignment)) alignment) alignment)
    )

    ;;;
     ; Computes the layout of the data section and closes this object to further updates.
     ;
     ; This must be called exactly once.
     ;;
    (defn #_"this" DataSection''close-1 [#_"DataSection" this]
        (DataSection''checkOpen-1 this)
        (let [
            this (assoc this :closed true)
            ;; simple heuristic: put items with larger alignment requirement first
            this (update this :dataItems #(sort-by :alignment (comp - compare) %))
            [#_"int" alignment #_"int" position]
                (loop-when [alignment 1 position 0 #_"ISeq" s (seq (:dataItems this))] (some? s) => [alignment position]
                    (let [
                        #_"Data" d (first s)
                        alignment (DataSection'lcm-2 alignment, (:alignment d))
                        position (DataSection'align-2 position, (:alignment d))
                    ]
                        (#_"DataSectionReference" .setOffset (:ref d), position)
                        (recur alignment (+ position (:size d)) (next s))
                    )
                )
            this (assoc this :sectionAlignment alignment)
            this (assoc this :sectionSize position)
        ]
            this
        )
    )

    ;;;
     ; Gets the size of the data section.
     ;
     ; This must only be called once this object has been {@linkplain #closed() closed}.
     ;;
    (defn #_"int" DataSection''getSectionSize-1 [#_"DataSection" this]
        (DataSection''checkClosed-1 this)
        (:sectionSize this)
    )

    ;;;
     ; Gets the minimum alignment requirement of the data section.
     ;
     ; This must only be called once this object has been {@linkplain #closed() closed}.
     ;;
    (defn #_"int" DataSection''getSectionAlignment-1 [#_"DataSection" this]
        (DataSection''checkClosed-1 this)
        (:sectionAlignment this)
    )

    ;;;
     ; Builds the data section into a given buffer.
     ;
     ; This must only be called once this object has been {@linkplain #closed() closed}.
     ; When this method returns, the buffers' position is just after the last data item.
     ;
     ; @param buffer the ByteBuffer where the data section should be built, that must hold at least #getSectionSize() bytes
     ; @param patch a Patches instance to receive {@link VMConstant constants} for relocations in the data section
     ;;
    (defn #_"void" DataSection''buildDataSection-3 [#_"DataSection" this, #_"ByteBuffer" buffer, #_"Patches" patch]
        (DataSection''checkClosed-1 this)
        (let [
            #_"int" start (#_"ByteBuffer" .position buffer)
        ]
            (doseq [#_"Data" data (:dataItems this)]
                (#_"ByteBuffer" .position buffer, (+ start (#_"DataSectionReference" .getOffset (:ref data))))
                (Data'''emit-3 data, buffer, patch)
            )
            (#_"ByteBuffer" .position buffer, (+ start (:sectionSize this)))
        )
        nil
    )
)

(class-ns DeadCodeEliminationPhase [Phase]
    ;;;
     ; Creates a dead code elimination phase that will be run only if it is
     ; {@linkplain Optionality#Required non-optional} or GraalOptions#reduceDCE is false.
     ;;
    (defn #_"DeadCodeEliminationPhase" DeadCodeEliminationPhase'new-1 [#_"Optionality" optionality]
        (merge (DeadCodeEliminationPhase'class.)
            (hash-map
                #_"boolean" :optional (= optionality Optionality'Optional)
            )
        )
    )

    ;;;
     ; Creates a dead code elimination phase that will be run irrespective of GraalOptions#reduceDCE.
     ;;
    #_unused
    (defn #_"DeadCodeEliminationPhase" DeadCodeEliminationPhase'new-0 []
        (DeadCodeEliminationPhase'new-1 Optionality'Required)
    )

    (defn- #_"void" DeadCodeEliminationPhase'iterateSuccessorsAndInputs-1 [#_"NodeFlood" flood]
        (let [
            #_"EdgeVisitor" consumer
                (reify EdgeVisitor
                    (#_"Node" EdgeVisitor'''apply-3 [#_"EdgeVisitor" _, #_"Node" source, #_"Node" target]
                        (ยง ass! flood (NodeFlood''add-2 flood, target))
                        target
                    )
                )
        ]
            (doseq [#_"Node" current flood]
                (if (satisfies? AbstractEndNode current)
                    (ยง ass! flood (NodeFlood''add-2 flood, (AbstractEndNode'''merge-1 current)))
                    (do
                        (Node''applySuccessors-2 current, consumer)
                        (Node''applyInputs-2 current, consumer)
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" DeadCodeEliminationPhase'deleteNodes-2 [#_"NodeFlood" flood, #_"Graph" graph]
        (let [
            #_"EdgeVisitor" consumer
                (reify EdgeVisitor
                    (#_"Node" EdgeVisitor'''apply-3 [#_"EdgeVisitor" _, #_"Node" source, #_"Node" target]
                        (when (and (Node''isAlive-1 target) (NodeFlood''isMarked-2 flood, target)) => target
                            (Node''removeUsage-2 target, source)
                        )
                    )
                )
        ]
            (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                (when-not (NodeFlood''isMarked-2 flood, node)
                    (Node''markDeleted-1 node)
                    (Node''applyInputs-2 node, consumer)
                )
            )
        )
        nil
    )

    (defm DeadCodeEliminationPhase Phase
        (#_"Graph" Phase'''run-3 [#_"DeadCodeEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when-not (and (:optional this) GraalOptions'reduceDCE)
                (let [
                    #_"NodeFlood" flood (NodeFlood'new-1 graph)
                    #_"int" totalNodeCount (Graph''getNodeCount-1 graph)
                ]
                    (ยง ass! flood (NodeFlood''add-2 flood, (:start graph)))
                    (DeadCodeEliminationPhase'iterateSuccessorsAndInputs-1 flood)
                    (let [
                        #_"boolean" changed?
                            (loop-when [changed? false #_"ISeq" s (seq (Graph''getNodes-2 graph, GuardNode))] (some? s) => changed?
                                (let [
                                    #_"GuardNode" guard (first s)
                                    changed?
                                        (when (NodeFlood''isMarked-2 flood, (FloatingAnchoredNode''getAnchor-1 guard)) => changed?
                                            (ยง ass! flood (NodeFlood''add-2 flood, guard))
                                            true
                                        )
                                ]
                                    (recur changed? (next s))
                                )
                            )
                    ]
                        (when changed?
                            (DeadCodeEliminationPhase'iterateSuccessorsAndInputs-1 flood)
                        )
                        (if (= totalNodeCount (:totalMarkedCount flood))
                            ;; all nodes are live => nothing more to do
                            nil
                            ;; some nodes are not marked alive and therefore dead => proceed
                            (DeadCodeEliminationPhase'deleteNodes-2 flood, graph)
                        )
                    )
                )
            )
            graph
        )
    )
)

;;;
 ; Represents def-use tree of a constant.
 ;;
(class-ns DefUseTree []
    (defn #_"DefUseTree" DefUseTree'new-2 [#_"LIRInstruction" instruction, #_"Block" block]
        (merge (DefUseTree'class.)
            (hash-map
                #_"LoadConstantOp" :instruction instruction
                #_"Block" :block block
                #_"List<UseEntry>" :uses (ArrayList.)
            )
        )
    )

    (defn #_"Variable" DefUseTree''getVariable-1 [#_"DefUseTree" this]
        (MoveOp'''getResult-1 (:instruction this))
    )

    (defn #_"Constant" DefUseTree''getConstant-1 [#_"DefUseTree" this]
        (LoadConstantOp'''getConstant-1 (:instruction this))
    )

    (defn #_"void" DefUseTree''addUsage-4 [#_"DefUseTree" this, #_"Block" block, #_"LIRInstruction" op, #_"Value" value]
        (#_"List" .add (:uses this), (UseEntry'new-3 block, op, value))
        nil
    )

    (defn #_"int" DefUseTree''usageCount-1 [#_"DefUseTree" this]
        (count (:uses this))
    )
)

(class-ns DefaultLoopPolicies [LoopPolicies]
    (defn #_"DefaultLoopPolicies" DefaultLoopPolicies'new-0 []
        (DefaultLoopPolicies'class.)
    )

    (defm DefaultLoopPolicies LoopPolicies
        (#_"boolean" LoopPolicies'''shouldPeel-3 [#_"DefaultLoopPolicies" this, #_"LoopEx" _loop, #_"ControlFlowGraph" cfg]
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 _loop)
            ]
                (and (< GraalOptions'minimumPeelProbability (:probability (ControlFlowGraph''blockFor-2 cfg, (LoopBeginNode''forwardEnd-1 loopBegin))))
                    (< (+ (LoopEx''size-1 _loop) (Graph''getNodeCount-1 (:graph loopBegin))) GraalOptions'maximumDesiredSize)
                    ;; check whether we're allowed to peel this loop
                    (LoopEx''canDuplicateLoop-1 _loop)
                )
            )
        )

        (#_"boolean" LoopPolicies'''shouldFullUnroll-2 [#_"DefaultLoopPolicies" this, #_"LoopEx" _loop]
            (and (LoopEx''isCounted-1 _loop) (CountedLoopInfo''isConstantMaxTripCount-1 (:counted _loop))
                (let [
                    #_"CountedLoopInfo" counted (:counted _loop)
                    #_"UnsignedLong" maxTrips (CountedLoopInfo''constantMaxTripCount-1 counted)
                ]
                    (if (zero? maxTrips)
                        (LoopEx''canDuplicateLoop-1 _loop)
                        (let [
                            #_"int" maxNodes (if (and (CountedLoopInfo''isExactTripCount-1 counted) (CountedLoopInfo''isConstantExactTripCount-1 counted)) GraalOptions'exactFullUnrollMaxNodes GraalOptions'fullUnrollMaxNodes)
                            maxNodes (min maxNodes (max 0 (- GraalOptions'maximumDesiredSize (Graph''getNodeCount-1 (:graph (LoopEx''loopBegin-1 _loop))))))
                            #_"int" size (max 1 (- (LoopEx''size-1 _loop) 1 (count (AbstractMergeNode''phis-1 (LoopEx''loopBegin-1 _loop)))))
                        ]
                            ;; The check below should not throw ArithmeticException because:
                            ;; maxTrips is guaranteed to be >= 1 by the check above
                            ;; - maxTrips * size can not overfow because:
                            ;;   - maxTrips <= FullUnrollMaxIterations <= Integer.MAX_VALUE
                            ;;   - 1 <= size <= Integer.MAX_VALUE
                            (and (UnsignedLong''isLessOrEqualTo-2 maxTrips, GraalOptions'fullUnrollMaxIterations)
                                (UnsignedLong''isLessOrEqualTo-2 (UnsignedLong''times-2 (UnsignedLong''minus-2 maxTrips, 1), size), maxNodes)
                                ;; check whether we're allowed to unroll this loop
                                (LoopEx''canDuplicateLoop-1 _loop)
                            )
                        )
                    )
                )
            )
        )

        (#_"boolean" LoopPolicies'''shouldPartiallyUnroll-2 [#_"DefaultLoopPolicies" this, #_"LoopEx" _loop]
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 _loop)
            ]
                (and (LoopEx''isCounted-1 _loop)
                    (let [
                        #_"int" maxNodes GraalOptions'exactPartialUnrollMaxNodes
                        maxNodes (min maxNodes (max 0 (- GraalOptions'maximumDesiredSize (Graph''getNodeCount-1 (:graph (LoopEx''loopBegin-1 _loop))))))
                        #_"int" size (max 1 (- (LoopEx''size-1 _loop) 1 (count (AbstractMergeNode''phis-1 (LoopEx''loopBegin-1 _loop)))))
                        #_"int" unrollFactor (:unrollFactor loopBegin)
                    ]
                        (when (= unrollFactor 1)
                            (let [
                                #_"double" loopFrequency (:loopFrequency loopBegin)
                            ]
                                (when (and (LoopBeginNode''isSimpleLoop-1 loopBegin) (< loopFrequency 5.0))
                                    (ยง return false)
                                )
                                (ยง ass! loopBegin (LoopBeginNode''setLoopOrigFrequency-2 loopBegin, loopFrequency))
                            )
                        )
                        (let [
                            #_"int" maxUnroll GraalOptions'unrollMaxIterations
                            ;; Now correct size for the next unroll. UnrollMaxIterations == 1 means perform
                            ;; the pre/main/post transformation but don't actually unroll the main loop.
                            size (+ size size)
                        ]
                            (and (or (and (= maxUnroll 1) (LoopBeginNode''isSimpleLoop-1 loopBegin)) (and (<= size maxNodes) (< unrollFactor maxUnroll)))
                                ;; Will the next unroll fit?
                                (<= (* unrollFactor 2) (int (:loopOrigFrequency loopBegin)))
                                ;; check whether we're allowed to unroll this loop
                                (loop-when [#_"ISeq" s (seq (LoopFragment'''nodes-1 (LoopEx''inside-1 _loop)))] (some? s) => true
                                    (let [
                                        #_"Node" node (first s)
                                    ]
                                        (when-not (or (satisfies? ControlFlowAnchorNode node) (satisfies? InvokeNode node)) => false
                                            (recur (next s))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (#_"boolean" LoopPolicies'''shouldTryUnswitch-2 [#_"DefaultLoopPolicies" this, #_"LoopEx" _loop]
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 _loop)
            ]
                (and (< 1.0 (:loopFrequency loopBegin)) (<= (:unswitches loopBegin) GraalOptions'loopMaxUnswitch))
            )
        )

        (#_"boolean" LoopPolicies'''shouldUnswitch-3 [#_"DefaultLoopPolicies" this, #_"LoopEx" _loop, #_"List<ControlSplitNode>" controlSplits]
            (let [
                #_"Graph" graph (:graph (LoopEx''loopBegin-1 _loop))
                #_"NodeBitMap" branchNodes (NodeBitMap'new-1 graph)
                #_"int" phis
                    (loop-when [phis 0 #_"ISeq" s (seq controlSplits)] (some? s) => phis
                        (let [
                            #_"ControlSplitNode" controlSplit (first s)
                        ]
                            (doseq [#_"Node" successor (Node''successors-1 controlSplit)]
                                ;; this may count twice because of fall-through in switches
                                (LoopEx''nodesInLoopBranch-3 _loop, branchNodes, successor)
                            )
                            (let [
                                #_"Block" postDomBlock (:postdominator (ControlFlowGraph''blockFor-2 (:cfg (:data _loop)), controlSplit))
                                phis
                                    (when (some? postDomBlock) => phis
                                        (+ phis (count (AbstractMergeNode''phis-1 (:beginNode postDomBlock))))
                                    )
                            ]
                                (recur phis (next s))
                            )
                        )
                    )
                #_"int" maxDiff
                    (min (+ GraalOptions'loopUnswitchTrivial (int (* GraalOptions'loopUnswitchFrequencyBoost (+ (:loopFrequency (LoopEx''loopBegin-1 _loop)) -1.0 phis))))
                        GraalOptions'loopUnswitchMaxIncrease
                        (- GraalOptions'maximumDesiredSize (Graph''getNodeCount-1 graph))
                    )
                #_"int" inBranchTotal (count branchNodes)
                #_"int'" v'stateNodesCount (volatile! 0)
            ]
                (VirtualState'''applyToVirtual-2 (:stateAfter (LoopEx''loopBegin-1 _loop)),
                    (reify VirtualClosure
                        (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" _, #_"VirtualState" vs]
                            (vswap! v'stateNodesCount inc)
                            nil
                        )
                    )
                )
                (and (<= (- (LoopEx''size-1 _loop) (count (AbstractMergeNode''phis-1 (LoopEx''loopBegin-1 _loop))) @v'stateNodesCount 1 inBranchTotal) maxDiff)
                    ;; check whether we're allowed to unswitch this loop
                    (LoopEx''canDuplicateLoop-1 _loop)
                )
            )
        )
    )
)

(class-ns DefaultSimplifierTool [SimplifierTool, CanonicalizerTool]
    (defn #_"DefaultSimplifierTool" DefaultSimplifierTool'new-0 []
        (DefaultSimplifierTool'class.)
    )

    (defm DefaultSimplifierTool CanonicalizerTool
        (#_"boolean" CanonicalizerTool'''canonicalizeReads-1 [#_"DefaultSimplifierTool" this]
            false
        )

        (#_"boolean" CanonicalizerTool'''allUsagesAvailable-1 [#_"DefaultSimplifierTool" this]
            true
        )
    )

    (defm DefaultSimplifierTool SimplifierTool
        (#_"void" SimplifierTool'''deleteBranch-2 [#_"DefaultSimplifierTool" this, #_"Node" branch]
            (Node''replaceFirstSuccessor-3 (:predecessor branch), branch, nil)
            (GraphUtil'killCFG-1 branch)
            nil
        )

        (#_"void" SimplifierTool'''removeIfUnused-2 [#_"DefaultSimplifierTool" this, #_"Node" node]
            (GraphUtil'tryKillUnused-1 node)
            nil
        )

        (#_"void" SimplifierTool'''addToWorkList-2n [#_"DefaultSimplifierTool" this, #_"Node" node]
            nil
        )

        (#_"void" SimplifierTool'''addToWorkList-2s [#_"DefaultSimplifierTool" this, #_"Node*" nodes]
            nil
        )
    )

    (defm DefaultSimplifierTool CanonicalizerTool
        (#_"Integer" CanonicalizerTool'''smallestCompareWidth-1 [#_"DefaultSimplifierTool" this]
            (Lowerer'smallestCompareWidth-0)
        )
    )
)

(class-ns DeferredExit []
    (defn #_"DeferredExit" DeferredExit'new-2 [#_"Block" block, #_"DeferredExit" _next]
        (merge (DeferredExit'class.)
            (hash-map
                #_"Block" :block block
                #_"DeferredExit" :next _next
            )
        )
    )
)

;;;
 ; This phase tries to find {@link AbstractDeoptimizeNode DeoptimizeNodes} which use the same
 ; FrameState and merges them together.
 ;;
(class-ns DeoptimizationGroupingPhase [Phase]
    (defn #_"DeoptimizationGroupingPhase" DeoptimizationGroupingPhase'new-0 []
        (DeoptimizationGroupingPhase'class.)
    )

    (defn- #_"void" DeoptimizationGroupingPhase'exitLoops-3 [#_"AbstractDeoptimizeNode" deopt, #_"EndNode" end, #_"ControlFlowGraph" cfg]
        (loop-when-recur [#_"Loop" _loop (:loop (ControlFlowGraph''blockFor-2 cfg, deopt))] (some? _loop) [(:parent _loop)]
            (Graph''addBeforeFixed-3 (:graph end), end, (Graph''add-2 (:graph end), (LoopExitNode'new-1 (:beginNode (:header _loop)))))
        )
        nil
    )

    (defm DeoptimizationGroupingPhase Phase
        (#_"Graph" Phase'''run-3 [#_"DeoptimizationGroupingPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (loop-when [#_"ControlFlowGraph" cfg nil #_"ISeq" s (seq (Graph''getNodes-2 graph, FrameState))] (some? s)
                (let [
                    #_"FrameState" fs (first s)
                    [cfg #_"FixedNode" target #_"List<AbstractDeoptimizeNode>" obsoletes]
                        (loop-when [cfg cfg target nil obsoletes nil #_"ISeq" s (seq (filter #(satisfies? AbstractDeoptimizeNode %) (:nodeUsages fs)))] (some? s) => [cfg target obsoletes]
                            (let [
                                #_"AbstractDeoptimizeNode" deopt (first s)
                                [cfg target obsoletes]
                                    (when (some? target) => [cfg deopt obsoletes]
                                        (let [
                                            cfg (or cfg (ControlFlowGraph'compute-5 graph, true, true, false, false))
                                            [target obsoletes #_"PhiNode" reasonActionPhi #_"PhiNode" speculationPhi]
                                                (when (satisfies? AbstractDeoptimizeNode target) => [target obsoletes nil nil]
                                                    (let [
                                                        #_"AbstractMergeNode" merge (Graph''add-2 graph, (MergeNode'new-0))
                                                        #_"EndNode" firstEnd (Graph''add-2 graph, (EndNode'new-0))
                                                        #_"ValueNode" actionAndReason (AbstractDeoptimizeNode'''getActionAndReason-1 target)
                                                        #_"ValueNode" speculation (AbstractDeoptimizeNode'''getSpeculation-1 target)
                                                        reasonActionPhi (Graph''add-2 graph, (ValuePhiNode'new-2 (StampFactory'forKind-1 (ValueNode''getStackKind-1 actionAndReason)), merge))
                                                        speculationPhi (Graph''add-2 graph, (ValuePhiNode'new-2 (StampFactory'forKind-1 (ValueNode''getStackKind-1 speculation)), merge))
                                                    ]
                                                        (AbstractMergeNode''addForwardEnd-2 merge, firstEnd)
                                                        (PhiNode''addInput-2 reasonActionPhi, actionAndReason)
                                                        (PhiNode''addInput-2 speculationPhi, speculation)
                                                        (Node''replaceAtPredecessor-2 target, firstEnd)
                                                        (DeoptimizationGroupingPhase'exitLoops-3 target, firstEnd, cfg)
                                                        (ยง ass! merge (FixedWithNextNode''setNext-2 merge, (Graph''add-2 graph, (DynamicDeoptimizeNode'new-2 reasonActionPhi, speculationPhi))))
                                                        (let [
                                                            obsoletes (LinkedList.)
                                                        ]
                                                            (#_"List" .add obsoletes, target)
                                                            [merge obsoletes reasonActionPhi speculationPhi]
                                                        )
                                                    )
                                                )
                                            #_"EndNode" newEnd (Graph''add-2 graph, (EndNode'new-0))
                                        ]
                                            (AbstractMergeNode''addForwardEnd-2 target, newEnd)
                                            (PhiNode''addInput-2 reasonActionPhi, (AbstractDeoptimizeNode'''getActionAndReason-1 deopt))
                                            (PhiNode''addInput-2 speculationPhi, (AbstractDeoptimizeNode'''getSpeculation-1 deopt))
                                            (Node''replaceAtPredecessor-2 deopt, newEnd)
                                            (DeoptimizationGroupingPhase'exitLoops-3 deopt, newEnd, cfg)
                                            (#_"List" .add obsoletes, deopt)
                                            [cfg target obsoletes]
                                        )
                                    )
                            ]
                                (recur cfg target obsoletes (next s))
                            )
                        )
                ]
                    (when (some? obsoletes)
                        (DeoptBefore'''setStateBefore-2 (:next target), fs)
                        (doseq [#_"AbstractDeoptimizeNode" obsolete obsoletes]
                            (Node''safeDelete-1 obsolete)
                        )
                    )
                    (recur cfg (next s))
                )
            )
            graph
        )
    )
)

;;;
 ; This class represents a dominator tree problem, i.e. a problem which can be solved by traversing
 ; the dominator (sub-)tree.
 ;
 ; @param <E> An enum that describes the flags that can be associated with a block.
 ; @param <C> An arbitrary cost type that is associated with a block. It is intended to carry
 ;            information needed to calculate the solution. Note that C should not contain
 ;            boolean flags. Use an enum entry in E instead.
 ;;
(class-ns DominatorOptimizationProblem #_"<E extends Enum<E>, C>" []
    (defn #_"DominatorOptimizationProblem" DominatorOptimizationProblem'new-2 [#_"Class<E>" flagType, #_"ControlFlowGraph" cfg]
        (merge (DominatorOptimizationProblem'class.)
            (hash-map
                #_"Block[]" :blocks (:reversePostOrder cfg)
                #_"EnumMap<E, BitSet>" :flags (EnumMap. flagType)
                #_"BlockMap<C>" :costs (BlockMap'new-1 cfg)
            )
        )
    )

    ;;;
     ; Sets a flag for a block.
     ;;
    (defn #_"void" DominatorOptimizationProblem''set-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag, #_"Block" block]
        (let [
            #_"BitSet" bitSet (get (:flags this) flag)
        ]
            (when (nil? bitSet)
                (ยง ass bitSet (BitSet.))
                (#_"EnumMap" .put (:flags this), flag, bitSet)
            )
            (#_"BitSet" .set bitSet, (:id block))
        )
        nil
    )

    ;;;
     ; Checks whether a flag is set for a block.
     ;;
    (defn #_"boolean" DominatorOptimizationProblem''get-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag, #_"Block" block]
        (let [
            #_"BitSet" bitSet (get (:flags this) flag)
        ]
            (and (some? bitSet) (#_"BitSet" .get bitSet, (:id block)))
        )
    )

    ;;;
     ; Returns the cost object associated with {@code block}. Might return nil if not set.
     ;;
    (defn #_"C" DominatorOptimizationProblem''getCost-2 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"Block" block]
        (BlockMap''get-2 (:costs this), block)
    )

    ;;;
     ; Sets the cost for a {@code block}.
     ;;
    (defn #_"void" DominatorOptimizationProblem''setCost-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"Block" block, #_"C" cost]
        (BlockMap''put-3 (:costs this), block, cost)
        nil
    )

    ;;;
     ; Sets {@code flag} for all blocks along the dominator path from {@code block} to the root
     ; until a block it finds a block where {@code flag} is already set.
     ;;
    (defn #_"void" DominatorOptimizationProblem''setDominatorPath-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag, #_"Block" block]
        (let [
            #_"BitSet" bitSet (get (:flags this) flag)
        ]
            (when (nil? bitSet)
                (ยง ass bitSet (BitSet.))
                (#_"EnumMap" .put (:flags this), flag, bitSet)
            )
            (loop-when-recur [#_"Block" b block] (and (some? b) (not (#_"BitSet" .get bitSet, (:id b)))) [(:dominator b)]
                ;; mark block
                (#_"BitSet" .set bitSet, (:id b))
            )
        )
        nil
    )
)

;;;
 ; Represents a dominator (sub-)tree for a constant definition.
 ;;
(class-ns ConstantTree [DominatorOptimizationProblem #_"<Flags, NodeCost>"]
    (defn #_"ConstantTree" ConstantTree'new-2 [#_"ControlFlowGraph" cfg, #_"DefUseTree" tree]
        (merge (ConstantTree'class.) (DominatorOptimizationProblem'new-2 Flags, cfg)
            (hash-map
                #_"{int [UseEntry]}" :usageMap (reduce #(assoc %1 (:id (:block %2)) (conj (vec (get %1 (:id (:block %2)))) %2)) {} (:uses tree))
            )
        )
    )

    (defn #_"[UseEntry]" ConstantTree''getUsages-2 [#_"ConstantTree" this, #_"Block" block]
        (get (:usageMap this) (:id block))
    )

    ;;;
     ; Returns the cost object associated with {@code block}. If there is none, a new cost object is created.
     ;;
    (defn #_"NodeCost" ConstantTree''getOrInitCost-2 [#_"ConstantTree" this, #_"Block" block]
        (or (DominatorOptimizationProblem''getCost-2 this, block)
            (let [
                #_"NodeCost" cost (NodeCost'new-3 (:probability block), (ConstantTree''getUsages-2 this, block), 1)
            ]
                (DominatorOptimizationProblem''setCost-3 this, block, cost)
                cost
            )
        )
    )

    (defn #_"void" ConstantTree''markBlocks-1 [#_"ConstantTree" this]
        (doseq [#_"Block" block (:blocks this)]
            (when (DominatorOptimizationProblem''get-3 this, Flags'HAS_USAGE, block)
                (DominatorOptimizationProblem''setDominatorPath-3 this, Flags'IN_SUBTREE, block)
            )
        )
        nil
    )

    (defn #_"boolean" ConstantTree''isMarked-2 [#_"ConstantTree" this, #_"Block" block]
        (DominatorOptimizationProblem''get-3 this, Flags'IN_SUBTREE, block)
    )

    (defn #_"boolean" ConstantTree''isLeafBlock-2 [#_"ConstantTree" this, #_"Block" block]
        (loop-when [#_"Block" dom (:firstDominated block)] (some? dom) => true
            (and (not (ConstantTree''isMarked-2 this, dom))
                (recur (:dominatedSibling dom))
            )
        )
    )

    (defn #_"void" ConstantTree''traverseTreeWhileTrue-3 [#_"ConstantTree" this, #_"Block" block, #_"fn boolean [Block]" f'action-1]
        (when (f'action-1 block)
            (loop-when-recur [#_"Block" dom (:firstDominated block)] (some? dom) [(:dominatedSibling dom)]
                (when (ConstantTree''isMarked-2 this, dom)
                    (ConstantTree''traverseTreeWhileTrue-3 this, dom, f'action-1)
                )
            )
        )
        nil
    )
)

(class-ns EMOptimizer []
    (defn #_"EMOptimizer" EMOptimizer'new-1 [#_"LIR" lir]
        (merge (EMOptimizer'class.)
            (hash-map
                #_"LIR" :lir lir
                #_"List<List<LIRInstruction>>" :edgeInstructionSeqences (ArrayList.)
            )
        )
    )

    ;;;
     ; Determines if two operations are both moves that have the
     ; same source and {@linkplain MoveOp#getResult() destination} operands.
     ;
     ; @param op1 the first instruction to compare
     ; @param op2 the second instruction to compare
     ; @return true if {@code op1} and {@code op2} are the same by the above algorithm
     ;;
    (defn- #_"boolean" EMOptimizer'same-2 [#_"LIRInstruction" op1, #_"LIRInstruction" op2]
        (cond
            (and (satisfies? ValueMoveOp op1) (satisfies? ValueMoveOp op2))
                ;; these moves are exactly equal and can be optimized
                (and (= (ValueMoveOp'''getInput-1 op1) (ValueMoveOp'''getInput-1 op2))
                     (= (MoveOp'''getResult-1 op1) (MoveOp'''getResult-1 op2))
                )
            (and (satisfies? LoadConstantOp op1) (satisfies? LoadConstantOp op2))
                ;; these moves are exactly equal and can be optimized
                (and (= (LoadConstantOp'''getConstant-1 op1) (LoadConstantOp'''getConstant-1 op2))
                     (= (MoveOp'''getResult-1 op1) (MoveOp'''getResult-1 op2))
                )
            :else
                false
        )
    )

    ;;;
     ; Move the longest common subsequence at the end of predecessors to the start of block.
     ;;
    (defn #_"void" EMOptimizer''optimizeMovesAtBlockEnd-2 [#_"EMOptimizer" this, #_"Block" block]
        ;; currently we can't handle this correctly.
        (when-not (loop [#_"ISeq" s (seq (:predecessors block))] (and (some? s) (or (= (first s) block) (recur (next s)))))
            ;; clear all internal data structures
            (#_"List" .clear (:edgeInstructionSeqences this))
            (let [
                #_"int" n (count (:predecessors block))
            ]
                (or
                    ;; setup a list with the LIR instructions of all predecessors
                    (loop-when [#_"ISeq" s (seq (:predecessors block))] (some? s)
                        (let [
                            #_"Block" b (first s)
                        ]
                            ;; => can happen with switch-statements where multiple edges are between the same blocks
                            (when (= (count (:successors b)) 1) => :abort
                                ;; ignore the unconditional branch at the end of the block
                                (let [
                                    #_"List<LIRInstruction>" l (LIR''getLIRforBlock-2 (:lir this), b)
                                ]
                                    (#_"List" .add (:edgeInstructionSeqences this), (#_"ArrayList" .subList l, 0, (dec (count l))))
                                    (recur (next s))
                                )
                            )
                        )
                    )
                    ;; process LIR instructions while all predecessors end with the same instruction
                    (loop []
                        (let [
                            #_"List<LIRInstruction>" s (nth (:edgeInstructionSeqences this) 0)
                        ]
                            (when (seq s)
                                (let [
                                    #_"LIRInstruction" op (nth s (dec (count s)))
                                ]
                                    (or
                                        (loop-when [#_"int" i 1] (< i n)
                                            (let [
                                                #_"List<LIRInstruction>" s' (nth (:edgeInstructionSeqences this) i)
                                            ]
                                                (when (and (seq s') (EMOptimizer'same-2 op, (nth s' (dec (count s'))))) => :abort
                                                    (recur (inc i))
                                                )
                                            )
                                        )
                                        (do
                                            ;; insert the instruction at the beginning of the current block
                                            (#_"ArrayList" .add (LIR''getLIRforBlock-2 (:lir this), block), 1, op)
                                            ;; delete the instructions at the end of all predecessors
                                            (dotimes [#_"int" i n]
                                                (#_"List" .remove (nth (:edgeInstructionSeqences this) i), (dec (count (nth (:edgeInstructionSeqences this) i))))
                                            )
                                            (recur)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Move the longest common subsequence at the start of successors to the end of block
     ; just prior to the branch instruction ending block.
     ;;
    (defn #_"void" EMOptimizer''optimizeMovesAtBlockBegin-2 [#_"EMOptimizer" this, #_"Block" block]
        (#_"List" .clear (:edgeInstructionSeqences this))
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
            #_"LIRInstruction" branch (nth ops (dec (count ops)))
        ]
            ;; Only blocks that end with a conditional branch are optimized. In addition,
            ;; a conditional branch with operands (including state) cannot be optimized.
            ;; Moving a successor instruction before such a branch may interfere with the operands.
            ;; For example, a successive move instruction may redefine an input operand.
            (when (and (satisfies? StandardBranchOp branch) (not (LIRInstruction''hasOperands-1 branch)))
                ;; Now it is guaranteed that the block ends with a conditional branch.
                ;; The instructions are inserted at the end of the block before the branch.
                (let [
                    #_"int" n (count (:successors block))
                ]
                    (or
                        ;; setup a list with the LIR instructions of all successors
                        (loop-when [#_"ISeq" s (seq (:successors block))] (some? s)
                            (let [
                                #_"Block" b (first s)
                            ]
                                ;; => can happen with switch-statements where multiple edges are between the same blocks
                                (when (= (count (:predecessors b)) 1) => :abort
                                    ;; ignore the label at the beginning of the block
                                    (let [
                                        #_"List<LIRInstruction>" l (LIR''getLIRforBlock-2 (:lir this), b)
                                    ]
                                        (#_"List" .add (:edgeInstructionSeqences this), (#_"ArrayList" .subList l, 1, (count l)))
                                        (recur (next s))
                                    )
                                )
                            )
                        )
                        ;; process LIR instructions while all successors begin with the same instruction
                        (loop [#_"int" insertAt (dec (count ops))]
                            (let [
                                #_"List<LIRInstruction>" s (nth (:edgeInstructionSeqences this) 0)
                            ]
                                (when (seq s)
                                    (let [
                                        #_"LIRInstruction" op (nth s 0)
                                    ]
                                        (or
                                            (loop-when [#_"int" i 1] (< i n)
                                                (let [
                                                    #_"List<LIRInstruction>" s' (nth (:edgeInstructionSeqences this) i)
                                                ]
                                                    ;; => these instructions are different and cannot be optimized
                                                    (when (and (seq s') (EMOptimizer'same-2 op, (nth s' 0))) => :abort
                                                        (recur (inc i))
                                                    )
                                                )
                                            )
                                            (do
                                                ;; insert the instruction at the end of the current block
                                                (#_"ArrayList" .add (LIR''getLIRforBlock-2 (:lir this), block), insertAt, op)
                                                ;; delete the instructions at the beginning of all successors
                                                (dotimes [#_"int" i n]
                                                    (#_"List" .remove (nth (:edgeInstructionSeqences this) i), 0)
                                                )
                                                (recur (inc insertAt))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; This class optimizes moves, particularly those that result from eliminating SSA form.
 ;
 ; When a block has more than one predecessor, and all predecessors end with the
 ; {@linkplain EMOptimizer#same(LIRInstruction, LIRInstruction) same} sequence of
 ; move instructions, then these sequences can be replaced with a
 ; single copy of the sequence at the beginning of the block.
 ;
 ; Similarly, when a block has more than one successor, then same sequences of moves at the
 ; beginning of the successors can be placed once at the end of the block. But because the moves
 ; must be inserted before all branch instructions, this works only when there is exactly one
 ; conditional branch at the end of the block (because the moves must be inserted before all
 ; branches, but after all compares).
 ;
 ; This optimization affects all kind of moves (reg->reg, reg->stack and stack->reg).
 ; Because this optimization works best when a block contains only a few moves, it has a huge impact
 ; on the number of blocks that are totally empty.
 ;;
(class-ns EdgeMoveOptimizer [LIRPhase #_"<LIRPhaseContext>"] ;; PostAllocationPhase
    (defn #_"EdgeMoveOptimizer" EdgeMoveOptimizer'new-0 []
        (EdgeMoveOptimizer'class.)
    )

    (defm EdgeMoveOptimizer LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"EdgeMoveOptimizer" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (let [
                #_"EMOptimizer" optimizer (EMOptimizer'new-1 (:lir lirGenRes))
                #_"Block[]" blockList (:linearScanOrder (:lir lirGenRes))
            ]
                ;; ignore the first block in the list (index 0 is not processed)
                (loop-when-recur [#_"int" i (dec (count blockList))] (<= 1 i) [(dec i)]
                    (let [
                        #_"Block" block (nth blockList i)
                    ]
                        (when (< 1 (count (:predecessors block)))
                            (EMOptimizer''optimizeMovesAtBlockEnd-2 optimizer, block)
                        )
                        (when (= (count (:successors block)) 2)
                            (EMOptimizer''optimizeMovesAtBlockBegin-2 optimizer, block)
                        )
                    )
                )
            )
            nil
        )
    )
)

(class-ns EffectList [#_"Iterable" #_"<Effect>"]
    (def- #_"Effect[]" EffectList'EMPTY_ARRAY (make-array Effect'iface 0))
    (def- #_"String[]" EffectList'EMPTY_STRING_ARRAY (make-array String 0))

    (defn #_"EffectList" EffectList'new-0 []
        (merge (EffectList'class.)
            (hash-map
                #_"Effect[]" :effects EffectList'EMPTY_ARRAY
                #_"int" :size 0
            )
        )
    )

    (defn- #_"EffectList" EffectList''enlarge-2 [#_"EffectList" this, #_"int" elements]
        (let [
            #_"int" n (count (:effects this))
        ]
            (when (< n (+ (:size this) elements)) => this
                (let [
                    n (loop-when-recur n (< n (+ (:size this) elements)) (max (<< n 1) 4) => n)
                ]
                    (assoc this :effects (Arrays/copyOf (:effects this), n))
                )
            )
        )
    )

    (defn #_"void" EffectList''add-3 [#_"EffectList" this, #_"String" name, #_"Effect" effect]
        (ยง ass! this (EffectList''enlarge-2 this, 1))
        (aset (:effects this) (:size this) effect)
        (ยง ass! this (update this :size inc))
        nil
    )

    (defn #_"void" EffectList''addAll-2 [#_"EffectList" this, #_"EffectList" list]
        (ยง ass! this (EffectList''enlarge-2 this, (:size list)))
        (System/arraycopy (:effects list), 0, (:effects this), (:size this), (:size list))
        (ยง ass! this (assoc this :size (+ (:size this) (:size list))))
        nil
    )

    (defn #_"this" EffectList''insertAll-3 [#_"EffectList" this, #_"EffectList" list, #_"int" position]
        (let [
            this (EffectList''enlarge-2 this, (:size list))
            _ (System/arraycopy (:effects this), position, (:effects this), (+ position (:size list)), (- (:size this) position))
            _ (System/arraycopy (:effects list), 0, (:effects this), position, (:size list))
            this (assoc this :size (+ (:size this) (:size list)))
        ]
            this
        )
    )

    (defn #_"int" EffectList''size-1 [#_"EffectList" this]
        (:size this)
    )

    (ยง override #_"Iterator<Effect>" #_"Iterable." iterator [#_"EffectList" this]
        (let [
            #_"EffectList" owner this
            #_"int" i 0
        ]
            (reify Iterator #_"<Effect>"
                (#_"boolean" hasNext [#_"Iterator<Effect>" this]
                    (< i (:size owner))
                )

                (#_"Effect" next [#_"Iterator<Effect>" this]
                    (let [
                        _ (nth (:effects owner) i)
                    ]
                        (ยง ass! i (inc i))
                        _
                    )
                )
            )
        )
    )

    (defm EffectList EffectList
        (#_"void" EffectList'''clear-1 [#_"EffectList" this]
            (ยง ass! this (assoc this :size 0))
            nil
        )
    )

    (defn #_"boolean" EffectList''isEmpty-1 [#_"EffectList" this]
        (zero? (:size this))
    )

    (defn #_"void" EffectList''apply-4 [#_"EffectList" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes, #_"boolean" cfgKills]
        (dotimes [#_"int" i (EffectList''size-1 this)]
            (let [
                #_"Effect" effect (nth (:effects this) i)
            ]
                (when (= (Effect'''isCfgKill-1 effect) cfgKills)
                    (Effect'''apply-3 effect, graph, obsoleteNodes)
                )
            )
        )
        nil
    )
)

(class-ns GraphEffectList [EffectList, #_"Iterable" #_"<Effect>"]
    (defn #_"GraphEffectList" GraphEffectList'new-0 []
        (merge (GraphEffectList'class.) (EffectList'new-0)
            (hash-map
                ;;;
                 ; Determines how many objects are virtualized (positive) or materialized (negative) by this effect.
                 ;;
                #_"int" :virtualizationDelta 0
            )
        )
    )

    (defm GraphEffectList EffectList
        (#_"void" EffectList'''clear-1 [#_"GraphEffectList" this]
            (EffectList'''clear-1 (ยง super EffectList'iface))
            (ยง ass! this (assoc this :virtualizationDelta 0))
            nil
        )
    )

    ;;;
     ; Adds the given fixed node to the graph's control flow, before position (so that the original
     ; predecessor of position will then be node's predecessor).
     ;
     ; @param node The fixed node to be added to the graph.
     ; @param position The fixed node before which the node should be added.
     ;;
    (defn #_"void" GraphEffectList''addFixedNodeBefore-3 [#_"GraphEffectList" this, #_"FixedWithNextNode" node, #_"FixedNode" position]
        (EffectList''add-3 this, "add fixed node",
            (ร (graph) 
                (ยง fun
                    (Graph''addBeforeFixed-3 graph, position, (Graph''add-2 graph, node))
                )
            )
        )
        nil
    )

    (defn #_"GraphEffectList" GraphEffectList''addVirtualizationDelta-2 [#_"GraphEffectList" this, #_"int" delta]
        (update this :virtualizationDelta + delta)
    )

    ;;;
     ; Add the given floating node to the graph.
     ;
     ; @param node The floating node to be added.
     ;;
    (defn #_"void" GraphEffectList''addFloatingNode-3 [#_"GraphEffectList" this, #_"ValueNode" node, #_"String" cause]
        (EffectList''add-3 this, "add floating node",
            (ร (graph) 
                (ยง fun
                    (Graph''addInputs-2 graph, node)
                    (Graph''add-2 graph, node)
                )
            )
        )
        nil
    )

    ;;;
     ; Sets the phi node's input at the given index to the given value, adding new phi inputs as needed.
     ;
     ; @param node The phi node whose input should be changed.
     ; @param index The index of the phi input to be changed.
     ; @param value The new value for the phi input.
     ;;
    (defn #_"void" GraphEffectList''initializePhiInput-4 [#_"GraphEffectList" this, #_"PhiNode" node, #_"int" index, #_"ValueNode" value]
        (EffectList''add-3 this, "set phi input",
            (ร (graph, obsoleteNodes) 
                (ยง fun
                    (PhiNode''initializeValueAt-3 node, index, (Graph''addOrUniqueWithInputs-2 graph, value))
                )
            )
        )
        nil
    )

    ;;;
     ; Adds a virtual object's state to the given frame state. If the given reusedVirtualObjects set
     ; contains the virtual object then old states for this object will be removed.
     ;
     ; @param node The frame state to which the state should be added.
     ; @param state The virtual object state to add.
     ;;
    (defn #_"void" GraphEffectList''addVirtualMapping-3 [#_"GraphEffectList" this, #_"FrameState" node, #_"EscapeObjectState" state]
        (EffectList''add-3 this, "add virtual mapping",
            (reify Effect
                (#_"void" Effect'''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (when (Node''isAlive-1 node)
                        (dotimes [#_"int" i (FrameState''virtualObjectMappingCount-1 node)]
                            (when (= (:object (FrameState''virtualObjectMappingAt-2 node, i)) (:object state))
                                (#_"List" .remove (:virtualObjectMappings node), i)
                            )
                        )
                        (ยง ass! node (FrameState''addVirtualObjectMapping-2 node, (Graph''addOrUniqueWithInputs-2 graph, state)))
                    )
                    nil
                )

                (#_"boolean" Effect'''isCfgKill-1 [#_"Effect" this]
                    false
                )
            )
        )
        nil
    )

    ;;;
     ; Removes the given fixed node from the control flow and deletes it.
     ;
     ; @param node The fixed node that should be deleted.
     ;;
    (defn #_"void" GraphEffectList''deleteNode-2 [#_"GraphEffectList" this, #_"Node" node]
        (EffectList''add-3 this, "delete fixed node",
            (ร (graph, obsoleteNodes) 
                (ยง fun
                    (when (satisfies? FixedWithNextNode node)
                        (GraphUtil'unlinkFixedNode-1 node)
                    )
                    (#_"ArrayList" .add obsoleteNodes, node)
                )
            )
        )
        nil
    )

    (defn #_"void" GraphEffectList''killIfBranch-3 [#_"GraphEffectList" this, #_"IfNode" ifNode, #_"boolean" constantCondition]
        (EffectList''add-3 this, "kill if branch",
            (reify Effect
                (#_"void" Effect'''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (Graph''removeSplitPropagate-3 graph, ifNode, (IfNode''getSuccessor-2 ifNode, constantCondition))
                    nil
                )

                (#_"boolean" Effect'''isCfgKill-1 [#_"Effect" this]
                    true
                )
            )
        )
        nil
    )

    (defn #_"void" GraphEffectList''replaceWithSink-3 [#_"GraphEffectList" this, #_"FixedWithNextNode" node, #_"ControlSinkNode" sink]
        (EffectList''add-3 this, "kill if branch",
            (reify Effect
                (#_"void" Effect'''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (Graph''add-2 graph, sink)
                    (Node''replaceAtPredecessor-2 node, sink)
                    (GraphUtil'killCFG-1 node)
                    nil
                )

                (#_"boolean" Effect'''isCfgKill-1 [#_"Effect" this]
                    true
                )
            )
        )
        nil
    )

    ;;;
     ; Replaces the given node at its usages without deleting it. If the current node is a fixed
     ; node it will be disconnected from the control flow, so that it will be deleted by a
     ; subsequent DeadCodeEliminationPhase
     ;
     ; @param node The node to be replaced.
     ; @param replacement The node that should replace the original value. If the replacement is a
     ;            non-connected FixedWithNextNode it will be added to the control flow.
     ;;
    (defn #_"void" GraphEffectList''replaceAtUsages-4 [#_"GraphEffectList" this, #_"ValueNode" node, #_"ValueNode" replacement, #_"FixedNode" insertBefore]
        (EffectList''add-3 this, "replace at usages",
            (ร (graph, obsoleteNodes) 
                (ยง fun
                    (let [
                        #_"ValueNode" replacementNode (Graph''addOrUniqueWithInputs-2 graph, replacement)
                    ]
                        (when (and (satisfies? FixedWithNextNode replacementNode) (nil? (:next replacementNode)))
                            (Graph''addBeforeFixed-3 graph, insertBefore, replacementNode)
                        )
                        ;; Keep the (better) stamp information when replacing a node with another one if the
                        ;; replacement has a less precise stamp than the original node. This can happen for
                        ;; example in the context of read nodes and unguarded pi nodes where the pi will be used
                        ;; to improve the stamp information of the read. Such a read might later be replaced
                        ;; with a read with a less precise stamp.
                        (when-not (= (:stamp node) (:stamp replacementNode))
                            (ยง ass replacementNode (Graph''add-2 graph, (PiNode'new-2 replacementNode, (:stamp node))))
                        )
                        (ยง ass! node (Node''replaceAtUsages-2 node, replacementNode))
                        (when (satisfies? FixedWithNextNode node)
                            (GraphUtil'unlinkFixedNode-1 node)
                        )
                        (#_"ArrayList" .add obsoleteNodes, node)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Replaces the first occurrence of oldInput in node with newInput.
     ;
     ; @param node The node whose input should be changed.
     ; @param oldInput The value to look for.
     ; @param newInput The value to replace with.
     ;;
    (defn #_"void" GraphEffectList''replaceFirstInput-4 [#_"GraphEffectList" this, #_"Node" node, #_"Node" oldInput, #_"Node" newInput]
        (EffectList''add-3 this, "replace first input",
            (reify Effect
                (#_"void" Effect'''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (when (Node''isAlive-1 node)
                        (Node''replaceFirstInput-3 node, oldInput, newInput)
                    )
                    nil
                )

                (#_"boolean" Effect'''isCfgKill-1 [#_"Effect" this]
                    false
                )
            )
        )
        nil
    )
)

(class-ns EffectsBlockState #_"<T implements EffectsBlockState<T>>" []
    (defn #_"EffectsBlockState" EffectsBlockState'new-0 []
        (merge (EffectsBlockState'class.)
            (hash-map
                ;; emtpy
                #_"boolean" :dead false
            )
        )
    )

    (defn #_"EffectsBlockState" EffectsBlockState'copy-1 [#_"EffectsBlockState<T>" other]
        (merge (EffectsBlockState'class.)
            (hash-map
                ;;;
                 ; This flag specifies whether this block is unreachable, which can happen during analysis
                 ; if conditions turn constant or nodes canonicalize to cfg sinks.
                 ;;
                #_"boolean" :dead (:dead other)
            )
        )
    )

    (defn #_"boolean" EffectsBlockState''isDead-1 [#_"EffectsBlockState<T>" this]
        (:dead this)
    )

    (defn #_"EffectsBlockState<T>" EffectsBlockState''markAsDead-1 [#_"EffectsBlockState<T>" this]
        (assoc this :dead true)
    )

    ;;;
     ; Returns true if every value in subMap is also present in the superMap (according to "equals" semantics).
     ;;
    (defn #_"<K, V> boolean" EffectsBlockState'isSubMapOf-2 [#_"EconomicMap<K, V>" superMap, #_"EconomicMap<K, V>" subMap]
        (or (= superMap subMap)
            (loop-when [#_"UnmodifiableMapCursor<K, V>" cursor (#_"EconomicMap" .getEntries subMap)] (#_"UnmodifiableMapCursor" .advance cursor) => true
                (let [
                    #_"K" key (#_"UnmodifiableMapCursor" .getKey cursor)
                    #_"V" value (#_"UnmodifiableMapCursor" .getValue cursor)
                    #_"V" otherValue (get superMap key)
                ]
                    (and (or (= otherValue value) (= value otherValue)) ;; %% oops!
                        (recur cursor)
                    )
                )
            )
        )
    )
)

(class-ns PartialEscapeBlockState #_"<T implements PartialEscapeBlockState<T>>" [EffectsBlockState #_"<T>"]
    (defn- #_"PartialEscapeBlockState" PartialEscapeBlockState'init-0 []
        (hash-map
            ;;;
             ; This array contains the state of all virtual objects, indexed by VirtualObjectNode#getObjectId().
             ; Entries in this array may be nil if the corresponding virtual object is not alive or reachable currently.
             ;;
            #_"ObjectState[]" :objectStates nil
            ;;;
             ; Usage count for the objectStates array, to avoid unnecessary copying.
             ;;
            #_"RefCount" :arrayRefCount nil
        )
    )

    (defn #_"PartialEscapeBlockState" PartialEscapeBlockState'new-0 []
        (let [
            #_"PartialEscapeBlockState" this
                (merge (PartialEscapeBlockState'class.) (EffectsBlockState'new-0)
                    (PartialEscapeBlockState'init-0)
                )
            this (assoc this :objectStates (make-array ObjectState'iface 0))
            this (assoc this :arrayRefCount (RefCount'new-0))
        ]
            this
        )
    )

    (defn #_"PartialEscapeBlockState" PartialEscapeBlockState'copy-1 [#_"PartialEscapeBlockState<T>" other]
        (let [
            #_"PartialEscapeBlockState" this
                (merge (PartialEscapeBlockState'class.) (EffectsBlockState'copy-1 other)
                    (PartialEscapeBlockState'init-0)
                )
        ]
            (PartialEscapeBlockState''adoptAddObjectStates-2 this, other)
        )
    )

    (defn #_"boolean" PartialEscapeBlockState''contains-2 [#_"PartialEscapeBlockState<T>" this, #_"VirtualObjectNode" value]
        (loop [#_"ISeq" s (seq (:objectStates this))]
            (and (some? s)
                (or
                    (let [
                        #_"ObjectState" state (first s)
                    ]
                        (when (and (some? state) (ObjectState''isVirtual-1 state))
                            (loop-when [#_"ISeq" s (seq (:entries state))] (some? s)
                                (or (= (first s) value)
                                    (recur (next s))
                                )
                            )
                        )
                    )
                    (recur (next s))
                )
            )
        )
    )

    (defn- #_"ObjectState[]" PartialEscapeBlockState''getObjectStateArrayForModification-1 [#_"PartialEscapeBlockState<T>" this]
        (when (< 1 (:refCount (:arrayRefCount this)))
            (ยง ass! this (assoc this :objectStates (#_"Object" .clone (:objectStates this))))
            (ยง ass! (:refCount (:arrayRefCount this)) (dec (:refCount (:arrayRefCount this))))
            (ยง ass! this (assoc this :arrayRefCount (RefCount'new-0)))
        )
        (:objectStates this)
    )

    (defn- #_"ObjectState" PartialEscapeBlockState''getObjectStateForModification-2 [#_"PartialEscapeBlockState<T>" this, #_"int" object]
        (let [
            #_"ObjectState[]" array (PartialEscapeBlockState''getObjectStateArrayForModification-1 this)
            #_"ObjectState" objectState (nth array object)
        ]
            (when (:copyOnWrite objectState)
                (ยง ass objectState (ObjectState'copy-1 objectState))
                (aset array object objectState)
            )
            objectState
        )
    )

    (defn #_"void" PartialEscapeBlockState''setEntry-4 [#_"PartialEscapeBlockState<T>" this, #_"int" object, #_"int" entryIndex, #_"ValueNode" value]
        (when-not (= (ObjectState''getEntry-2 (nth (:objectStates this) object), entryIndex) value)
            (let [
                #_"ObjectState" state (PartialEscapeBlockState''getObjectStateForModification-2 this, object)
            ]
                (ยง ass! state (ObjectState''setEntry-3 state, entryIndex, value))
            )
        )
        nil
    )

    (defn #_"void" PartialEscapeBlockState''escape-3 [#_"PartialEscapeBlockState<T>" this, #_"int" object, #_"ValueNode" materialized]
        (let [
            #_"ObjectState" state (PartialEscapeBlockState''getObjectStateForModification-2 this, object)
        ]
            (ยง ass! state (ObjectState''escape-2 state, materialized))
        )
        nil
    )

    (defn #_"void" PartialEscapeBlockState''addLock-3 [#_"PartialEscapeBlockState<T>" this, #_"int" object, #_"MonitorIdNode" monitorId]
        (let [
            #_"ObjectState" state (PartialEscapeBlockState''getObjectStateForModification-2 this, object)
        ]
            (ยง ass! state (ObjectState''addLock-2 state, monitorId))
        )
        nil
    )

    (defn #_"MonitorIdNode" PartialEscapeBlockState''removeLock-2 [#_"PartialEscapeBlockState<T>" this, #_"int" object]
        (ObjectState''removeLock-1 (PartialEscapeBlockState''getObjectStateForModification-2 this, object))
    )

    (defn #_"void" PartialEscapeBlockState''updateMaterializedValue-3 [#_"PartialEscapeBlockState<T>" this, #_"int" object, #_"ValueNode" value]
        (when-not (= (:materializedValue (nth (:objectStates this) object)) value)
            (let [
                #_"ObjectState" state (PartialEscapeBlockState''getObjectStateForModification-2 this, object)
            ]
                (ยง ass! state (ObjectState''updateMaterializedValue-2 state, value))
            )
        )
        nil
    )

    (defn- #_"void" PartialEscapeBlockState''materializeWithCommit-8 [#_"PartialEscapeBlockState<T>" this, #_"FixedNode" fixed, #_"VirtualObjectNode" virtual, #_"List<AllocatedObjectNode>" objects, #_"List<List<MonitorIdNode>>" locks, #_"List<ValueNode>" values, #_"List<Boolean>" ensureVirtual, #_"List<ValueNode>" otherAllocations]
        (let [
            #_"ObjectState" obj (nth (:objectStates this) (:oid virtual))
            #_"ValueNode[]" entries (:entries obj)
            #_"ValueNode" representation (VirtualObjectNode'''getMaterializedRepresentation-4 virtual, fixed, entries, (:locks obj))
            _ (PartialEscapeBlockState''escape-3 this, (:oid virtual), representation)
            obj (nth (:objectStates this) (:oid virtual))
            _ (PartialEscapeClosure'updateStatesForMaterialized-3 this, virtual, (:materializedValue obj))
        ]
            (when (satisfies? AllocatedObjectNode representation) => (#_"List" .add otherAllocations, representation)
                (#_"List" .add objects, representation)
                (#_"List" .add locks, (LockState'asList-1 (:locks obj)))
                (#_"List" .add ensureVirtual, (:ensureVirtualized obj))
                (let [
                    #_"int" pos (count values)
                ]
                    (while (< (count values) (+ pos (count entries)))
                        (#_"List" .add values, nil)
                    )
                    (dotimes [#_"int" i (count entries)]
                        (if (satisfies? VirtualObjectNode (nth entries i))
                            (let [
                                #_"VirtualObjectNode" entryVirtual (nth entries i)
                                #_"ObjectState" entryObj (nth (:objectStates this) (:oid entryVirtual))
                                entryObj
                                    (when (ObjectState''isVirtual-1 entryObj) => entryObj
                                        (PartialEscapeBlockState''materializeWithCommit-8 this, fixed, entryVirtual, objects, locks, values, ensureVirtual, otherAllocations)
                                        (nth (:objectStates this) (:oid entryVirtual))
                                    )
                            ]
                                (#_"List" .set values, (+ pos i), (:materializedValue entryObj))
                            )
                            (#_"List" .set values, (+ pos i), (nth entries i))
                        )
                    )
                    (PartialEscapeBlockState'''objectMaterialized-4 this, virtual, (ยง cast #_"AllocatedObjectNode" representation), (#_"List" .subList values, pos, (+ pos (count entries))))
                )
            )
        )
        nil
    )

    ;;;
     ; Materializes the given virtual object and produces the necessary effects in the effects list.
     ; This transitively also materializes all other virtual objects that are reachable from the entries.
     ;;
    (defn #_"void" PartialEscapeBlockState''materializeBefore-4 [#_"PartialEscapeBlockState<T>" this, #_"FixedNode" fixed, #_"VirtualObjectNode" virtual, #_"GraphEffectList" materializeEffects]
        (let [
            #_"List<AllocatedObjectNode>" objects (ArrayList.)
            #_"List<ValueNode>" values (ArrayList.)
            #_"List<List<MonitorIdNode>>" locks (ArrayList.)
            #_"List<ValueNode>" otherAllocations (ArrayList.)
            #_"List<Boolean>" ensureVirtual (ArrayList.)
        ]
            (PartialEscapeBlockState''materializeWithCommit-8 this, fixed, virtual, objects, locks, values, ensureVirtual, otherAllocations)

            (ยง ass! materializeEffects (GraphEffectList''addVirtualizationDelta-2 materializeEffects, (- (+ (count objects) (count otherAllocations)))))

            (EffectList''add-3 materializeEffects, "materializeBefore",
                (reify Effect
                    (#_"void" Effect'''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                        (doseq [#_"ValueNode" alloc otherAllocations]
                            (let [
                                #_"ValueNode" otherAllocation (Graph''addOrUniqueWithInputs-2 graph, alloc)
                            ]
                                (when (satisfies? FixedWithNextNode otherAllocation)
                                    (Graph''addBeforeFixed-3 graph, fixed, otherAllocation)
                                )
                            )
                        )
                        (when (seq objects)
                            (let [
                                #_"CommitAllocationNode" commit
                                    (if (satisfies? CommitAllocationNode (:predecessor fixed))
                                        (:predecessor fixed)
                                        (let [
                                            commit (Graph''add-2 graph, (CommitAllocationNode'new-0))
                                        ]
                                            (Graph''addBeforeFixed-3 graph, fixed, commit)
                                            commit
                                        )
                                    )
                            ]
                                (doseq [#_"AllocatedObjectNode" obj objects]
                                    (Graph''add-2 graph, obj)
                                    (#_"List" .add (:virtualObjects commit), (:virtualObject obj))
                                    (ยง ass! obj (AllocatedObjectNode''setCommit-2 obj, commit))
                                )
                                (doseq [#_"ValueNode" value values]
                                    (#_"List" .add (:values commit), (Graph''addOrUniqueWithInputs-2 graph, value))
                                )
                                (doseq [#_"List<MonitorIdNode>" monitorIds locks]
                                    (CommitAllocationNode''addLocks-2 commit, monitorIds)
                                )
                                (#_"List" .addAll (:ensureVirtual commit), ensureVirtual)

                                (let [
                                    #_"#{AllocatedObjectNode}" materializedValues (into #{} (filter #(satisfies? AllocatedObjectNode %) (:nodeUsages commit)))
                                ]
                                    (dotimes [#_"int" i (count (:values commit))]
                                        (when (contains? materializedValues (nth (:values commit) i))
                                            (#_"List" .set (:values commit), i, (:virtualObject (nth (:values commit) i)))
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )

                    (#_"boolean" Effect'''isCfgKill-1 [#_"Effect" this]
                        false
                    )
                )
            )
        )
        nil
    )

    (defm PartialEscapeBlockState #_"<T>" PartialEscapeBlockState
        (#_"void" PartialEscapeBlockState'''objectMaterialized-4 [#_"PartialEscapeBlockState<T>" this, #_"VirtualObjectNode" virtual, #_"AllocatedObjectNode" representation, #_"List<ValueNode>" values]
            nil
        )
    )

    (defn- #_"ObjectState[]" PartialEscapeBlockState''ensureSize-2 [#_"PartialEscapeBlockState<T>" this, #_"int" objectId]
        (if (< objectId (count (:objectStates this)))
            (PartialEscapeBlockState''getObjectStateArrayForModification-1 this)
            (do
                (ยง ass! this (assoc this :objectStates (Arrays/copyOf (:objectStates this), (max (<< objectId 1) 4))))
                (ยง ass! (:refCount (:arrayRefCount this)) (dec (:refCount (:arrayRefCount this))))
                (ยง ass! this (assoc this :arrayRefCount (RefCount'new-0)))
                (:objectStates this)
            )
        )
    )

    (defn #_"void" PartialEscapeBlockState''addObject-3 [#_"PartialEscapeBlockState<T>" this, #_"int" virtual, #_"ObjectState" state]
        (aset (PartialEscapeBlockState''ensureSize-2 this, virtual) virtual state)
        nil
    )

    (defm PartialEscapeBlockState #_"<T>" EffectsBlockState
        (#_"boolean" EffectsBlockState'''equivalentTo-2 [#_"PartialEscapeBlockState<T>" this, #_"T" other]
            (let [
                #_"int" n (max (count (:objectStates this)) (count (:objectStates other)))
            ]
                (loop-when [#_"int" i 0] (< i n) => true
                    (and (= (when (< i (count (:objectStates this))) (nth (:objectStates this) i)) (when (< i (count (:objectStates other))) (nth (:objectStates other) i)))
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (defn #_"PartialEscapeBlockState<T>" PartialEscapeBlockState''resetObjectStates-2 [#_"PartialEscapeBlockState<T>" this, #_"int" size]
        (assoc this :objectStates (make-array ObjectState'iface size))
    )

    (defn #_"boolean" PartialEscapeBlockState'identicalObjectStates-1 [#_"PartialEscapeBlockState[]" states]
        (loop-when [#_"int" i 1] (< i (count states)) => true
            (and (= (:objectStates (nth states 0)) (:objectStates (nth states i)))
                (recur (inc i))
            )
        )
    )

    (defn #_"boolean" PartialEscapeBlockState'identicalObjectStates-2 [#_"PartialEscapeBlockState[]" states, #_"int" object]
        (loop-when [#_"int" i 1] (< i (count states)) => true
            (and (= (nth (:objectStates (nth states 0)) object) (nth (:objectStates (nth states i)) object))
                (recur (inc i))
            )
        )
    )

    (defn #_"PartialEscapeBlockState<T>" PartialEscapeBlockState''adoptAddObjectStates-2 [#_"PartialEscapeBlockState<T>" this, #_"PartialEscapeBlockState" other]
        (let [
            this
                (when (some? (:objectStates this)) => this
                    (update-in this [:arrayRefCount :refCount] dec)
                )
            this (assoc this :objectStates (:objectStates other))
            this (assoc this :arrayRefCount (:arrayRefCount other))
        ]
            (when (= (:refCount (:arrayRefCount this)) 1)
                (doseq [#_"ObjectState" state (:objectStates this)]
                    (when (some? state)
                        (ObjectState''share-1 state)
                    )
                )
            )
            (update-in this [:arrayRefCount :refCount] inc)
        )
    )
)

;;;
 ; Final subclass of PartialEscapeBlockState, for performance and to make everything
 ; behave nicely with generics.
 ;;
(class-ns FinalState [PartialEscapeBlockState #_"<FinalState>", EffectsBlockState #_"<FinalState>"]
    (defn #_"FinalState" FinalState'new-0 []
        (merge (FinalState'class.) (PartialEscapeBlockState'new-0))
    )

    (defn #_"FinalState" FinalState'copy-1 [#_"FinalState" other]
        (merge (FinalState'class.) (PartialEscapeBlockState'copy-1 other))
    )
)

(class-ns PEReadEliminationBlockState [PartialEscapeBlockState #_"<PEReadEliminationBlockState>", EffectsBlockState #_"<PEReadEliminationBlockState>"]
    (defn #_"PEReadEliminationBlockState" PEReadEliminationBlockState'new-0 []
        (merge (PEReadEliminationBlockState'class.) (PartialEscapeBlockState'new-0)
            (hash-map
                #_"EconomicMap<ReadCacheEntry, ValueNode>" :readCache (EconomicMap/create)
            )
        )
    )

    (defn #_"PEReadEliminationBlockState" PEReadEliminationBlockState'copy-1 [#_"PEReadEliminationBlockState" other]
        (merge (PEReadEliminationBlockState'class.) (PartialEscapeBlockState'copy-1 other)
            (hash-map
                #_"EconomicMap<ReadCacheEntry, ValueNode>" :readCache (EconomicMap/create (:readCache other))
            )
        )
    )

    (defn- #_"JavaKind" PEReadEliminationBlockState'stampToJavaKind-1 [#_"Stamp" stamp]
        (if (satisfies? IntegerStamp stamp)
            (case (:bits stamp)
                 1 JavaKind/Boolean
                 8 JavaKind/Byte
                16 (if (IntegerStamp''isPositive-1 stamp) JavaKind/Char JavaKind/Short)
                32 JavaKind/Int
                64 JavaKind/Long
            )
            (Stamp'''getStackKind-1 stamp)
        )
    )

    (defm PEReadEliminationBlockState PartialEscapeBlockState
        (#_"void" PartialEscapeBlockState'''objectMaterialized-4 [#_"PEReadEliminationBlockState" this, #_"VirtualObjectNode" virtual, #_"AllocatedObjectNode" representation, #_"List<ValueNode>" values]
            (when (satisfies? VirtualInstanceNode virtual)
                (dotimes [#_"int" i (VirtualObjectNode'''entryCount-1 virtual)]
                    (let [
                        #_"JavaKind" declaredKind (#_"ResolvedJavaField" .getJavaKind (VirtualInstanceNode''field-2 virtual, i))
                    ]
                        (when (= declaredKind (PEReadEliminationBlockState'stampToJavaKind-1 (:stamp (nth values i))))
                            ;; We won't cache unaligned field writes upon instantiation unless we add
                            ;; support for non-array objects in PEReadEliminationClosure.processUnsafeLoad.
                            (#_"EconomicMap" .put (:readCache this), (ReadCacheEntry'new-5 (FieldLocationIdentity'new-1 (VirtualInstanceNode''field-2 virtual, i)), representation, -1, declaredKind, false), (nth values i))
                        )
                    )
                )
            )
            nil
        )
    )

    (defm PEReadEliminationBlockState EffectsBlockState
        (#_"boolean" EffectsBlockState'''equivalentTo-2 [#_"PEReadEliminationBlockState" this, #_"PEReadEliminationBlockState" other]
            (and (EffectsBlockState'isSubMapOf-2 (:readCache this), (:readCache other)) (EffectsBlockState'''equivalentTo-2 (ยง super PartialEscapeBlockState'iface), other))
        )
    )

    (defn #_"void" PEReadEliminationBlockState''addReadCache-8 [#_"PEReadEliminationBlockState" this, #_"ValueNode" object, #_"LocationIdentity" location, #_"int" index, #_"JavaKind" kind, #_"boolean" overflowAccess, #_"ValueNode" value, #_"PartialEscapeClosure" closure]
        (let [
            #_"ObjectState" obj (PartialEscapeClosure''getObjectState-3 closure, this, object)
            #_"ValueNode" cacheObject (if (some? obj) (:materializedValue obj) object)
        ]
            (#_"EconomicMap" .put (:readCache this), (ReadCacheEntry'new-5 location, cacheObject, index, kind, overflowAccess), value)
        )
        nil
    )

    (defn #_"ValueNode" PEReadEliminationBlockState''getReadCache-6 [#_"PEReadEliminationBlockState" this, #_"ValueNode" object, #_"LocationIdentity" location, #_"int" index, #_"JavaKind" kind, #_"PartialEscapeClosure" closure]
        (let [
            #_"ObjectState" obj (PartialEscapeClosure''getObjectState-3 closure, this, object)
            #_"ValueNode" cacheObject (if (some? obj) (:materializedValue obj) object)
            #_"ValueNode" cacheValue (get (:readCache this) (ReadCacheEntry'new-5 location, cacheObject, index, kind, false))
            obj (PartialEscapeClosure''getObjectState-3 closure, this, cacheValue)
        ]
            (if (some? obj)
                (:materializedValue obj)
                ;; assert !scalarAliases.containsKey(cacheValue);
                (EffectsClosure''getScalarAlias-2 closure, cacheValue)
            )
        )
    )

    (defn #_"void" PEReadEliminationBlockState''killReadCache-1 [#_"PEReadEliminationBlockState" this]
        (#_"EconomicMap" .clear (:readCache this))
        nil
    )

    (defn #_"void" PEReadEliminationBlockState''killReadCache-3 [#_"PEReadEliminationBlockState" this, #_"LocationIdentity" location, #_"int" index]
        (let [
            #_"Iterator<ReadCacheEntry>" it (#_"Iterable" .iterator (keys (:readCache this)))
        ]
            (while (#_"Iterator" .hasNext it)
                (let [
                    #_"ReadCacheEntry" entry (#_"Iterator" .next it)
                ]
                    (when (and (= (:identity entry) location) (or (= index -1) (= (:index entry) -1) (= index (:index entry)) (:overflowAccess entry)))
                        (#_"Iterator" .remove it)
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; This class maintains a set of known values, identified by base object, locations and offset.
 ;;
(class-ns ReadEliminationBlockState [EffectsBlockState #_"<ReadEliminationBlockState>"]
    (defn #_"ReadEliminationBlockState" ReadEliminationBlockState'new-0 []
        (merge (ReadEliminationBlockState'class.) (EffectsBlockState'new-0)
            (hash-map
                #_"EconomicMap<CacheEntry, ValueNode>" :readCache (EconomicMap/create)
            )
        )
    )

    (defn #_"ReadEliminationBlockState" ReadEliminationBlockState'copy-1 [#_"ReadEliminationBlockState" other]
        (merge (ReadEliminationBlockState'class.) (EffectsBlockState'new-0)
            (hash-map
                #_"EconomicMap<CacheEntry, ValueNode>" :readCache (EconomicMap/create (:readCache other))
            )
        )
    )

    (defm ReadEliminationBlockState EffectsBlockState
        (#_"boolean" EffectsBlockState'''equivalentTo-2 [#_"ReadEliminationBlockState" this, #_"ReadEliminationBlockState" other]
            (EffectsBlockState'isSubMapOf-2 (:readCache this), (:readCache other))
        )
    )

    (defn #_"void" ReadEliminationBlockState''addCacheEntry-3 [#_"ReadEliminationBlockState" this, #_"CacheEntry" identifier, #_"ValueNode" value]
        (#_"EconomicMap" .put (:readCache this), identifier, value)
        nil
    )

    (defn #_"ValueNode" ReadEliminationBlockState''getCacheEntry-2 [#_"ReadEliminationBlockState" this, #_"CacheEntry" identifier]
        (get (:readCache this) identifier)
    )

    (defn #_"void" ReadEliminationBlockState''killReadCache-1 [#_"ReadEliminationBlockState" this]
        (#_"EconomicMap" .clear (:readCache this))
        nil
    )

    (defn #_"void" ReadEliminationBlockState''killReadCache-2 [#_"ReadEliminationBlockState" this, #_"LocationIdentity" location]
        (let [
            #_"Iterator<CacheEntry>" it (#_"Iterable" .iterator (keys (:readCache this)))
        ]
            (while (#_"Iterator" .hasNext it)
                (when (CacheEntry'''conflicts-2 (#_"Iterator" .next it), location)
                    (#_"Iterator" .remove it)
                )
            )
        )
        nil
    )
)

(class-ns EffectsPhase [Phase]
    (defn #_"EffectsPhase" EffectsPhase'new-2 [#_"int" maxIterations, #_"CanonicalizerPhase" canonicalizer]
        (EffectsPhase'new-3 maxIterations, canonicalizer, false)
    )

    (defn #_"EffectsPhase" EffectsPhase'new-3 [#_"int" maxIterations, #_"CanonicalizerPhase" canonicalizer, #_"boolean" unscheduled]
        (merge (EffectsPhase'class.)
            (hash-map
                #_"int" :maxIterations maxIterations
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
                #_"boolean" :unscheduled unscheduled
            )
        )
    )

    (defn #_"boolean" EffectsPhase''runAnalysis-2 [#_"EffectsPhase" this, #_"Graph" graph]
        (loop-when [#_"boolean" changed? false #_"int" iteration 0] (< iteration (:maxIterations this)) => changed?
            (let [
                [#_"ScheduleResult" schedule #_"ControlFlowGraph" cfg]
                    (if (:unscheduled this)
                        [nil (ControlFlowGraph'compute-5 graph, true, true, false, false)]
                        (do
                            (ยง ass! graph (Phase'''run-3 (SchedulePhase'new-1 SchedulingStrategy'EARLIEST), graph, nil))
                            (let [
                                schedule (:lastSchedule graph)
                            ]
                                [schedule (:cfg schedule)]
                            )
                        )
                    )
                #_"EffectsClosure" closure (EffectsPhase'''createEffectsClosure-3 this, schedule, cfg)
            ]
                (ReentrantBlockIterator'apply-2 closure, (ControlFlowGraph''getStartBlock-1 cfg))

                (when (EffectsClosure'''needsApplyEffects-1 closure)
                    ;; apply the effects collected during this iteration
                    (let [
                        #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
                    ]
                        (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                            (EffectsClosure'''applyEffects-1 closure)
                        )
                        (ยง ass! graph (Phase'''run-3 (DeadCodeEliminationPhase'new-1 Optionality'Required), graph, nil))
                        (let [
                            #_"EconomicSet<Node>" changedNodes (:nodes listener)
                        ]
                            (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                                (when (satisfies? Simplifiable node)
                                    (#_"EconomicSet" .add changedNodes, node)
                                )
                            )
                            (EffectsPhase''postIteration-3 this, graph, changedNodes)
                        )
                    )
                )
                (when (:changed? closure) => changed?
                    (recur true (inc iteration))
                )
            )
        )
    )

    (defm EffectsPhase Phase
        (#_"Graph" Phase'''run-3 [#_"EffectsPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (EffectsPhase''runAnalysis-2 this, graph)
            graph
        )
    )

    (defn #_"void" EffectsPhase''postIteration-3 [#_"EffectsPhase" this, #_"Graph" graph, #_"EconomicSet<Node>" changedNodes]
        (when (some? (:canonicalizer this))
            (CanonicalizerPhase''applyIncremental-3i (:canonicalizer this), graph, changedNodes)
        )
        nil
    )
)

(class-ns EarlyReadEliminationPhase [EffectsPhase, Phase]
    (defn #_"EarlyReadEliminationPhase" EarlyReadEliminationPhase'new-1 [#_"CanonicalizerPhase" canonicalizer]
        (merge (EarlyReadEliminationPhase'class.) (EffectsPhase'new-3 1, canonicalizer, true))
    )

    (defm EarlyReadEliminationPhase EffectsPhase
        (#_"EffectsClosure" EffectsPhase'''createEffectsClosure-3 [#_"EarlyReadEliminationPhase" this, #_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg]
            (ReadEliminationClosure'new-2 cfg, true)
        )
    )

    (defm EarlyReadEliminationPhase Phase
        (#_"Graph" Phase'''run-3 [#_"EarlyReadEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (EffectsPhase''runAnalysis-2 this, graph)
            graph
        )
    )
)

(class-ns PartialEscapePhase [EffectsPhase, Phase]
    (defn #_"PartialEscapePhase" PartialEscapePhase'new-2 [#_"boolean" iterative, #_"CanonicalizerPhase" canonicalizer]
        (PartialEscapePhase'new-3 iterative, GraalOptions'optEarlyReadElimination, canonicalizer)
    )

    (defn #_"PartialEscapePhase" PartialEscapePhase'new-3 [#_"boolean" iterative, #_"boolean" readElimination, #_"CanonicalizerPhase" canonicalizer]
        (merge (PartialEscapePhase'class.) (EffectsPhase'new-2 (if iterative GraalOptions'escapeAnalysisIterations 1), canonicalizer)
            (hash-map
                #_"boolean" :readElimination readElimination
            )
        )
    )

    (defm PartialEscapePhase Phase
        (#_"Graph" Phase'''run-3 [#_"PartialEscapePhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (or (:readElimination this) (Graph''hasVirtualizableAllocation-1 graph))
                (EffectsPhase''runAnalysis-2 this, graph)
            )
            graph
        )
    )

    (defm PartialEscapePhase EffectsPhase
        (#_"EffectsClosure" EffectsPhase'''createEffectsClosure-3 [#_"PartialEscapePhase" this, #_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg]
            (doseq [#_"VirtualObjectNode" virtual (Graph''getNodes-2 (:graph cfg), VirtualObjectNode)]
                (ยง ass! virtual (VirtualObjectNode''resetObjectId-1 virtual))
            )
            (if (:readElimination this)
                (PEReadEliminationClosure'new-1 schedule)
                (FinalClosure'new-1 schedule)
            )
        )
    )
)

;;;
 ; This closure is used internally to determine the average effort for a certain strategy on a
 ; given switch instruction.
 ;;
(class-ns EffortClosure [SwitchClosure]
    (defn #_"EffortClosure" EffortClosure'new-2 [#_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets]
        (merge (EffortClosure'class.)
            (hash-map
                #_"SwitchStrategy" :strategy strategy
                #_"int" :defaultEffort 0
                #_"int" :defaultCount 0
                #_"int[]" :keyEfforts (int-array (count (:keyProbabilities strategy)))
                #_"int[]" :keyCounts (int-array (count (:keyProbabilities strategy)))
                #_"LabelRef[]" :keyTargets keyTargets
            )
        )
    )

    (defm EffortClosure SwitchClosure
        (#_"void" SwitchClosure'''conditionalJump-4 [#_"EffortClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" defaultTarget]
            ;; nothing to do
            nil
        )

        (#_"void" SwitchClosure'''conditionalJumpOrDefault-4 [#_"EffortClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" canFallThrough]
            ;; nothing to do
            nil
        )

        (#_"Label" SwitchClosure'''conditionalJump-3 [#_"EffortClosure" this, #_"int" index, #_"Condition" condition]
            ;; nothing to do
            nil
        )

        (#_"void" SwitchClosure'''bind-2 [#_"EffortClosure" this, #_"Label" label]
            ;; nothing to do
            nil
        )

        (#_"boolean" SwitchClosure'''isSameTarget-3 [#_"EffortClosure" this, #_"int" index1, #_"int" index2]
            (= (nth (:keyTargets this) index1) (nth (:keyTargets this) index2))
        )
    )

    (defn #_"double" EffortClosure''getAverageEffort-1 [#_"EffortClosure" this]
        (loop-when-recur [#_"double" effort 0.0 #_"double" defaultProbability 1.0 #_"int" i 0]
                         (< i (count (:keyProbabilities (:strategy this))))
                         [(+ effort (/ (* (nth (:keyEfforts this) i) (nth (:keyProbabilities (:strategy this)) i)) (nth (:keyCounts this) i)))
                          (- defaultProbability (nth (:keyProbabilities (:strategy this)) i))
                          (inc i)]
                      => (+ effort (/ (* (:defaultEffort this) defaultProbability) (:defaultCount this)))
        )
    )
)

(class-ns ExpandLogicPhase [Phase]
    (defn #_"ExpandLogicPhase" ExpandLogicPhase'new-0 []
        (ExpandLogicPhase'class.)
    )

    (defn- #_"double" ExpandLogicPhase'sanitizeProbability-1 [#_"double" value]
        (let [
            #_"double" newValue (min 1.0 (max 0.0 value))
        ]
            (if (Double/isNaN newValue) 0.5 newValue)
        )
    )

    (def- #_"double" ExpandLogicPhase'EPSILON 1e-6)

    (defn- #_"boolean" ExpandLogicPhase'doubleEquals-2 [#_"double" a, #_"double" b]
        (< (- a ExpandLogicPhase'EPSILON) b (+ a ExpandLogicPhase'EPSILON))
    )

    (defn- #_"void" ExpandLogicPhase'processIf-6 [#_"LogicNode" x, #_"boolean" xNegated, #_"LogicNode" y, #_"boolean" yNegated, #_"IfNode" ifNode, #_"double" shortCircuitProbability]
        ;; This method splits an IfNode, which has a ShortCircuitOrNode as its condition,
        ;; into two separate IfNodes: if(X) and if(Y)
        ;;
        ;; For computing the probabilities P(X) and P(Y), we use two different approaches.
        ;; The first one assumes that the shortCircuitProbability and the probability on the
        ;; IfNode were created with each other in mind. If this assumption does not hold,
        ;; we fall back to another mechanism for computing the probabilities.
        (let [
            #_"AbstractBeginNode" trueTarget (:trueSuccessor ifNode)
            #_"AbstractBeginNode" falseTarget (:falseSuccessor ifNode)
            ;; 1st approach
            ;; assumption: P(originalIf.trueSuccessor) == P(X) + ((1 - P(X)) * P(Y))
            #_"double" firstIfTrueProbability shortCircuitProbability
            #_"double" secondIfTrueProbability (ExpandLogicPhase'sanitizeProbability-1 (/ (- (:trueSuccessorProbability ifNode) shortCircuitProbability) (- 1.0 shortCircuitProbability)))
        ]
            (when-not (ExpandLogicPhase'doubleEquals-2 (:trueSuccessorProbability ifNode), (+ firstIfTrueProbability (* (- 1.0 firstIfTrueProbability) secondIfTrueProbability)))
                ;; 2nd approach
                ;;
                ;; the assumption above did not hold, so we either used an artificial probability as
                ;; shortCircuitProbability or the ShortCircuitOrNode was moved to some other IfNode.
                ;;
                ;; so, we distribute the if's trueSuccessorProbability between the newly generated if
                ;; nodes according to the shortCircuitProbability. the following invariant is always
                ;; true in this case: P(originalIf.trueSuccessor) == P(X) + ((1 - P(X)) * P(Y))
                (ยง ass firstIfTrueProbability (* (:trueSuccessorProbability ifNode) shortCircuitProbability))
                (ยง ass secondIfTrueProbability (ExpandLogicPhase'sanitizeProbability-1 (- 1.0 (/ (ControlSplitNode'''probability-2 ifNode, falseTarget) (- 1.0 firstIfTrueProbability)))))
            )

            (Node''clearSuccessors-1 ifNode)
            (let [
                #_"Graph" graph (:graph ifNode)
                #_"AbstractMergeNode" trueTargetMerge (Graph''add-2 graph, (MergeNode'new-0))
            ]
                (ยง ass! trueTargetMerge (FixedWithNextNode''setNext-2 trueTargetMerge, trueTarget))
                (let [
                    #_"EndNode" firstTrueEnd (Graph''add-2 graph, (EndNode'new-0))
                    #_"EndNode" secondTrueEnd (Graph''add-2 graph, (EndNode'new-0))
                ]
                    (AbstractMergeNode''addForwardEnd-2 trueTargetMerge, firstTrueEnd)
                    (AbstractMergeNode''addForwardEnd-2 trueTargetMerge, secondTrueEnd)
                    (let [
                        #_"AbstractBeginNode" firstTrueTarget (BeginNode'begin-1 firstTrueEnd)
                        #_"AbstractBeginNode" secondTrueTarget (BeginNode'begin-1 secondTrueEnd)
                    ]
                        (when yNegated
                            (ยง ass secondIfTrueProbability (- 1.0 secondIfTrueProbability))
                        )
                        (when xNegated
                            (ยง ass firstIfTrueProbability (- 1.0 firstIfTrueProbability))
                        )
                        (let [
                            #_"IfNode" secondIf (IfNode'new-4b y, (if yNegated falseTarget secondTrueTarget), (if yNegated secondTrueTarget falseTarget), secondIfTrueProbability)
                            #_"AbstractBeginNode" secondIfBegin (BeginNode'begin-1 (Graph''add-2 graph, secondIf))
                            #_"IfNode" firstIf (Graph''add-2 graph, (IfNode'new-4b x, (if xNegated secondIfBegin firstTrueTarget), (if xNegated firstTrueTarget secondIfBegin), firstIfTrueProbability))
                        ]
                            (Node''replaceAtPredecessor-2 ifNode, firstIf)
                            (Node''safeDelete-1 ifNode)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" ExpandLogicPhase'processConditional-5 [#_"LogicNode" x, #_"boolean" xNegated, #_"LogicNode" y, #_"boolean" yNegated, #_"ConditionalNode" conditional]
        (let [
            #_"ValueNode" trueTarget (:trueValue conditional)
            #_"ValueNode" falseTarget (:falseValue conditional)
            #_"Graph" graph (:graph conditional)
            #_"ConditionalNode" secondConditional (Graph''add-2 graph, (ConditionalNode'new-3 y, (if yNegated falseTarget trueTarget), (if yNegated trueTarget falseTarget)))
            #_"ConditionalNode" firstConditional (Graph''add-2 graph, (ConditionalNode'new-3 x, (if xNegated secondConditional trueTarget), (if xNegated trueTarget secondConditional)))
        ]
            (ยง ass! conditional (Node''replaceAndDelete-2 conditional, firstConditional))
        )
        nil
    )

    (defn- #_"void" ExpandLogicPhase'processBinary-1 [#_"ShortCircuitOrNode" binary]
        (while (seq (:nodeUsages binary)) ;; %% ouch!
            (let [
                #_"Node" usage (first (:nodeUsages binary))
            ]
                (condp satisfies? usage
                    ShortCircuitOrNode (ExpandLogicPhase'processBinary-1 usage)
                    IfNode             (ExpandLogicPhase'processIf-6 (:x binary), (:xNegated binary), (:y binary), (:yNegated binary), usage, (:shortCircuitProbability binary))
                    ConditionalNode    (ExpandLogicPhase'processConditional-5 (:x binary), (:xNegated binary), (:y binary), (:yNegated binary), usage)
                )
            )
        )
        (Node''safeDelete-1 binary)
        nil
    )

    (defn- #_"void" ExpandLogicPhase'processNormalizeCompareNode-1 [#_"NormalizeCompareNode" normalize]
        (let [
            #_"Graph" graph (:graph normalize)
            #_"ValueNode" x (:x normalize)
            #_"ValueNode" y (:y normalize)
            #_"LogicNode" equalComp (Graph''addOrUniqueWithInputs-2 graph, (IntegerEqualsNode'create-2 x, y))
            #_"LogicNode" lessComp (Graph''addOrUniqueWithInputs-2 graph, (IntegerLessThanNode'create-2 x, y))
            #_"Stamp" stamp (:stamp normalize)
            #_"ConditionalNode" equalValue (Graph''add-2 graph, (ConditionalNode'new-3 equalComp, (ConstantNode'forIntegerStamp-3 stamp, 0, graph), (ConstantNode'forIntegerStamp-3 stamp, 1, graph)))
            #_"ConditionalNode" value (Graph''add-2 graph, (ConditionalNode'new-3 lessComp, (ConstantNode'forIntegerStamp-3 stamp, -1, graph), equalValue))
        ]
            (ยง ass! normalize (Node''replaceAtUsagesAndDelete-2 normalize, value))
        )
        nil
    )

    (defm ExpandLogicPhase Phase
        (#_"Graph" Phase'''run-3 [#_"ExpandLogicPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (doseq [#_"ShortCircuitOrNode" logic (Graph''getNodes-2 graph, ShortCircuitOrNode)]
                (ExpandLogicPhase'processBinary-1 logic)
            )
            (doseq [#_"NormalizeCompareNode" logic (Graph''getNodes-2 graph, NormalizeCompareNode)]
                (ExpandLogicPhase'processNormalizeCompareNode-1 logic)
            )
            (Graph''setAfterExpandLogic-1 graph)
        )
    )
)

;;;
 ; Describes a field in a class during scanning.
 ;;
(class-ns FieldInfo [#_"Comparable" #_"<FieldInfo>"]
    (defn #_"FieldInfo" FieldInfo'new-4 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass]
        (merge (FieldInfo'class.)
            (hash-map
                #_"long" :offset offset
                #_"String" :name name
                #_"Class" :type type
                #_"Class" :declaringClass declaringClass
            )
        )
    )

    ;;;
     ; Sorts fields in ascending order by their #offsets.
     ;;
    (ยง override #_"int" #_"Comparable." compareTo [#_"FieldInfo" this, #_"FieldInfo" o]
        (cond (< (:offset this) (:offset o)) -1 (< (:offset o) (:offset this)) 1 :else 0)
    )
)

;;;
 ; Describes a field representing an input or successor edge in a node.
 ;;
(class-ns EdgeInfo [FieldInfo, #_"Comparable" #_"<FieldInfo>"]
    (defn #_"EdgeInfo" EdgeInfo'new-4 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass]
        (merge (EdgeInfo'class.) (FieldInfo'new-4 offset, name, type, declaringClass))
    )

    ;;;
     ; Sorts non-list edges before list edges.
     ;;
    (ยง override #_"int" #_"Comparable." compareTo [#_"EdgeInfo" this, #_"FieldInfo" o]
        (if (#_"Class" .isAssignableFrom NodeList'iface, (:type o))
            (when-not (#_"Class" .isAssignableFrom NodeList'iface, (:type this))
                (ยง return -1)
            )
            (when (#_"Class" .isAssignableFrom NodeList'iface, (:type this))
                (ยง return 1)
            )
        )
        (#_"Comparable" .compareTo (ยง super #_"FieldInfo"), o)
    )
)

;;;
 ; Describes a field representing an {@linkplain EdgesType#Inputs input} edge in a node.
 ;;
(class-ns InputInfo [EdgeInfo, FieldInfo, #_"Comparable" #_"<FieldInfo>"]
    (defn #_"InputInfo" InputInfo'new-6 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass, #_"InputType" inputType, #_"boolean" optional]
        (merge (InputInfo'class.) (EdgeInfo'new-4 offset, name, type, declaringClass)
            (hash-map
                #_"InputType" :inputType inputType
                #_"boolean" :optional optional
            )
        )
    )
)

(class-ns ValueFieldInfo [FieldInfo, #_"Comparable" #_"<FieldInfo>"]
    (defn #_"ValueFieldInfo" ValueFieldInfo'new-5 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass, #_"{OperandFlag}" flags]
        (merge (ValueFieldInfo'class.) (FieldInfo'new-4 offset, name, type, declaringClass)
            (hash-map
                #_"{OperandFlag}" :flags flags
            )
        )
    )

    ;;;
     ; Sorts non-array fields before array fields.
     ;;
    (ยง override! #_"int" #_"Comparable." compareTo [#_"ValueFieldInfo" this, #_"FieldInfo" o]
        (if (#_"Class" .isAssignableFrom (ร Value'array), (:type o))
            (when-not (#_"Class" .isAssignableFrom (ร Value'array), (:type this))
                (ยง return -1)
            )
            (when (#_"Class" .isAssignableFrom (ร Value'array), (:type this))
                (ยง return 1)
            )
        )
        (#_"Comparable" .compareTo (ยง super #_"FieldInfo"), o)
    )
)

(class-ns LIRInstructionClass []
    #_unused
    (defn #_"LIRInstructionClass" LIRInstructionClass'new-1 [#_"Class" clazz]
        (let [
            #_"LIRFieldsScanner" ifs (FieldsScanner''scan-3 (LIRFieldsScanner'new-0), clazz, LIRInstruction'iface)
        ]
            (merge (LIRInstructionClass'class.)
                (hash-map
                    #_"Class" :class clazz
                    ;;;
                     ; The set of fields in #clazz that do long belong to a more specific category.
                     ;;
                    #_"Fields" :data (Fields'new-1 (:data ifs))
                    ;;;
                     ; The component values in an LIRInstruction or CompositeValue.
                     ;;
                    #_"Values" :values nil
                    #_"Values" :uses (Values'new-1 (get (:valueAnnotations ifs) Use))
                    #_"Values" :alives (Values'new-1 (get (:valueAnnotations ifs) Alive))
                    #_"Values" :temps (Values'new-1 (get (:valueAnnotations ifs) Temp))
                    #_"Values" :defs (Values'new-1 (get (:valueAnnotations ifs) Def))
                )
            )
        )
    )

    (defn #_"boolean" LIRInstructionClass''hasOperands-1 [#_"LIRInstructionClass" this]
        (or (seq (:offsets (:uses this))) (seq (:offsets (:alives this))) (seq (:offsets (:temps this))) (seq (:offsets (:defs this))))
    )

    (defn- #_"void" LIRInstructionClass'forEach-4 [#_"LIRInstruction" op, #_"Values" values, #_"OperandMode" mode, #_"ValueProcedure" proc]
        (dotimes [#_"int" i (count (:offsets values))]
            (if (< i (:directCount values))
                (let [
                    #_"Value" value (Values''getValue-3 values, op, i)
                    #_"Value" newValue
                        (if (satisfies? CompositeValue value)
                            (CompositeValue'''forEachComponent-4 value, op, mode, proc)
                            (ValueProcedure'''doValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                        )
                ]
                    (when-not (= value newValue)
                        (Values''setValue-4 values, op, i, newValue)
                    )
                )
                (let [
                    #_"Value[]" valueArray (Values''getValue-3 values, op, i)
                ]
                    (dotimes [#_"int" j (count valueArray)]
                        (let [
                            #_"Value" value (nth valueArray j)
                            #_"Value" newValue
                                (if (satisfies? CompositeValue value)
                                    (CompositeValue'''forEachComponent-4 value, op, mode, proc)
                                    (ValueProcedure'''doValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                                )
                        ]
                            (when-not (= value newValue)
                                (aset valueArray j newValue)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" LIRInstructionClass''forEachUse-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueProcedure" proc]
        (LIRInstructionClass'forEach-4 op, (:uses this), OperandMode'USE, proc)
        nil
    )

    (defn #_"void" LIRInstructionClass''forEachAlive-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueProcedure" proc]
        (LIRInstructionClass'forEach-4 op, (:alives this), OperandMode'ALIVE, proc)
        nil
    )

    (defn #_"void" LIRInstructionClass''forEachTemp-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueProcedure" proc]
        (LIRInstructionClass'forEach-4 op, (:temps this), OperandMode'TEMP, proc)
        nil
    )

    (defn #_"void" LIRInstructionClass''forEachDef-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueProcedure" proc]
        (LIRInstructionClass'forEach-4 op, (:defs this), OperandMode'DEF, proc)
        nil
    )

    (defn- #_"void" LIRInstructionClass'visitEach-4 [#_"LIRInstruction" op, #_"Values" values, #_"OperandMode" mode, #_"ValueConsumer" proc]
        (dotimes [#_"int" i (count (:offsets values))]
            (if (< i (:directCount values))
                (let [
                    #_"Value" value (Values''getValue-3 values, op, i)
                ]
                    (if (satisfies? CompositeValue value)
                        (CompositeValue'''visitEachComponent-4 value, op, mode, proc)
                        (ValueConsumer'''visitValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                    )
                )
                (let [
                    #_"Value[]" valueArray (Values''getValue-3 values, op, i)
                ]
                    (dotimes [#_"int" j (count valueArray)]
                        (let [
                            #_"Value" value (nth valueArray j)
                        ]
                            (if (satisfies? CompositeValue value)
                                (CompositeValue'''visitEachComponent-4 value, op, mode, proc)
                                (ValueConsumer'''visitValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" LIRInstructionClass''visitEachUse-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueConsumer" proc]
        (LIRInstructionClass'visitEach-4 op, (:uses this), OperandMode'USE, proc)
        nil
    )

    (defn #_"void" LIRInstructionClass''visitEachAlive-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueConsumer" proc]
        (LIRInstructionClass'visitEach-4 op, (:alives this), OperandMode'ALIVE, proc)
        nil
    )

    (defn #_"void" LIRInstructionClass''visitEachTemp-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueConsumer" proc]
        (LIRInstructionClass'visitEach-4 op, (:temps this), OperandMode'TEMP, proc)
        nil
    )

    (defn #_"void" LIRInstructionClass''visitEachDef-3 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"ValueConsumer" proc]
        (LIRInstructionClass'visitEach-4 op, (:defs this), OperandMode'DEF, proc)
        nil
    )

    (defn #_"Value" LIRInstructionClass''forEachRegisterHint-4 [#_"LIRInstructionClass" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"ValueProcedure" proc]
        (let [
            #_"Values" hints
                (condp = mode
                    OperandMode'USE (:defs this)
                    OperandMode'DEF (:uses this)
                    nil
                )
        ]
            (when (some? hints)
                (loop-when [#_"int" i 0] (< i (count (:offsets hints)))
                    (or (when (<= (:directCount hints) i) => (ValueProcedure'''doValue-5 proc, op, (Values''getValue-3 hints, op, i), nil, nil)
                            (let [
                                #_"Value[]" hintValues (Values''getValue-3 hints, op, i)
                            ]
                                (loop-when [#_"int" j 0] (< j (count hintValues))
                                    (or (ValueProcedure'''doValue-5 proc, op, (nth hintValues j), nil, nil)
                                        (recur (inc j))
                                    )
                                )
                            )
                        )
                        (recur (inc i))
                    )
                )
            )
        )
    )
)

;;;
 ; Metadata for every Node type. The metadata includes the offsets of fields annotated with Input and
 ; Successor as well as methods for iterating over such fields.
 ;;
(class-ns NodeClass []
    (def- #_"long" NodeClass'MAX_EDGES 8)
    (def- #_"long" NodeClass'MAX_LIST_EDGES 6)
    (def- #_"long" NodeClass'OFFSET_MASK 0xfc)
    (def- #_"long" NodeClass'LIST_MASK 0x01)
    (def #_"long" NodeClass'NEXT_EDGE 0x08)

    (defn- #_"long" NodeClass'computeIterationMask-2 [#_"int" directCount, #_"long[]" offsets]
        (when (< NodeClass'MAX_EDGES (count offsets))
            (throw! (str "Exceeded maximum of " NodeClass'MAX_EDGES " edges"))
        )
        (when (< NodeClass'MAX_LIST_EDGES (- (count offsets) directCount))
            (throw! (str "Exceeded maximum of " NodeClass'MAX_LIST_EDGES " list edges"))
        )

        (loop-when [#_"long" mask 0 #_"int" i (dec (count offsets))] (<= 0 i) => mask
            (let [
                mask (| (<< mask NodeClass'NEXT_EDGE) (nth offsets i))
                mask (if (<= directCount i) (| mask 0x3) mask)
            ]
                (recur mask (dec i))
            )
        )
    )

    #_unused
    (defn #_"NodeClass" NodeClass'new-2 [#_"Class" clazz, #_"NodeClass" superNodeClass]
        (let [
            #_"NodeFieldsScanner" fs (FieldsScanner''scan-3 (NodeFieldsScanner'new-1 superNodeClass), clazz, (#_"Class" .getSuperclass clazz))
            #_"InputEdges" inputs (InputEdges'new-2 (:directInputs fs), (:inputs fs))
            #_"SuccessorEdges" successors (SuccessorEdges'new-2 (:directSuccessors fs), (:successors fs))
        ]
            (merge (NodeClass'class.)
                (hash-map
                    #_"Class" :class clazz
                    ;;;
                     ; The set of fields in #clazz that do long belong to a more specific category.
                     ;;
                    #_"Fields" :data (Fields'new-1 (:data fs))
                    #_"InputEdges" :inputs inputs
                    #_"SuccessorEdges" :successors successors
                    #_"NodeClass" :superNodeClass superNodeClass
                    #_"long" :inputsIteration (NodeClass'computeIterationMask-2 (:directCount inputs), (:offsets inputs))
                    #_"long" :successorIteration (NodeClass'computeIterationMask-2 (:directCount successors), (:offsets successors))
                    #_"boolean" :canonicalizable? (#_"Class" .isAssignableFrom Canonicalizable'iface, clazz)
                    #_"boolean" :commutative? (#_"Class" .isAssignableFrom BinaryCommutative'iface, clazz)
                    #_"boolean" :simplifiable? (#_"Class" .isAssignableFrom Simplifiable'iface, clazz)
                    ;;;
                     ; Determines if the node has no inputs, nor successors.
                     ;;
                    #_"boolean" :isLeafNode (zero? (+ (count (:offsets inputs)) (count (:offsets successors))))
                )
            )
        )
    )

    (defn #_"boolean" NodeClass''dataEquals-3 [#_"NodeClass" this, #_"Node" a, #_"Node" b]
        (loop-when [#_"int" i 0] (< i (count (:offsets (:data this)))) => true
            (let [
                #_"Class" type (Fields''getType-2 (:data this), i)
            ]
                (and
                    (if (#_"Class" .isPrimitive type)
                        (condp = type
                            int'class     (= (Fields''getInt-3     (:data this), a, i) (Fields''getInt-3     (:data this), b, i))
                            boolean'class (= (Fields''getBoolean-3 (:data this), a, i) (Fields''getBoolean-3 (:data this), b, i))
                            long'class    (= (Fields''getLong-3    (:data this), a, i) (Fields''getLong-3    (:data this), b, i))
                            short'class   (= (Fields''getShort-3   (:data this), a, i) (Fields''getShort-3   (:data this), b, i))
                            char'class    (= (Fields''getChar-3    (:data this), a, i) (Fields''getChar-3    (:data this), b, i))
                            byte'class    (= (Fields''getByte-3    (:data this), a, i) (Fields''getByte-3    (:data this), b, i))
                        )
                        (let [
                            #_"Object" objectA (Fields''getObject-3 (:data this), a, i)
                            #_"Object" objectB (Fields''getObject-3 (:data this), b, i)
                        ]
                            (or (= objectA objectB) (and (some? objectA) (some? objectB) (ร NodeClass'deepEquals0-2 objectA, objectB)))
                        )
                    )
                    (recur (inc i))
                )
            )
        )
    )

    (defn #_"boolean" NodeClass''isValid-4 [#_"NodeClass" this, #_"Position" pos, #_"NodeClass" from, #_"Edges" fromEdges]
        (or (= this from)
            (let [
                #_"Edges" toEdges (NodeClass''getEdges-2 this, (:type fromEdges))
            ]
                (and (< (:index pos) (count (:offsets toEdges)))
                     (< (:index pos) (count (:offsets fromEdges)))
                     (Fields''isSame-3 toEdges, fromEdges, (:index pos))
                )
            )
        )
    )

    (defn- #_"NodeList" NodeClass'updateEdgeListCopy-4 [#_"Node" node, #_"NodeList" list, #_"InplaceUpdateClosure" duplicationReplacement, #_"EdgesType" type]
        (let [
            #_"NodeList" result (if (= type EdgesType'Inputs) (NodeInputList'new-2i node, (count list)) (NodeSuccessorList'new-2i node, (count list)))
        ]
            (dotimes [#_"int" i (count list)]
                (let [
                    #_"Node" oldNode (nth list i)
                ]
                    (when (some? oldNode)
                        (#_"List" .set result, i, (InplaceUpdateClosure'''replacement-3 duplicationReplacement, oldNode, type))
                    )
                )
            )
            result
        )
    )

    (defn #_"void" NodeClass'updateEdgesInPlace-3 [#_"Node" node, #_"InplaceUpdateClosure" duplicationReplacement, #_"Edges" edges]
        (let [
            #_"EdgesType" type (:type edges)
            #_"long[]" offsets (:offsets edges)
            #_"int" i
                (loop-when-recur [i 0] (< i (:directCount edges)) [(inc i)] => i
                    (let [
                        #_"Node" edge (Edges'getNode-3 node, offsets, i)
                    ]
                        (when (some? edge)
                            (let [
                                #_"Node" newEdge (InplaceUpdateClosure'''replacement-3 duplicationReplacement, edge, type)
                            ]
                                (if (= type EdgesType'Inputs)
                                    (Node''updateUsages-3 node, nil, newEdge)
                                    (Node''updatePredecessor-3 node, nil, newEdge)
                                )
                                (Edges''initializeNode-4 edges, node, i, newEdge)
                            )
                        )
                    )
                )
        ]
            (loop-when-recur i (< i (count (:offsets edges))) (inc i)
                (let [
                    #_"NodeList" list (Edges'getNodeList-3 node, offsets, i)
                ]
                    (when (some? list)
                        (Edges''initializeList-4 edges, node, i, (NodeClass'updateEdgeListCopy-4 node, list, duplicationReplacement, type))
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" NodeClass''updateInputSuccInPlace-3 [#_"NodeClass" this, #_"Node" node, #_"InplaceUpdateClosure" duplicationReplacement]
        (NodeClass'updateEdgesInPlace-3 node, duplicationReplacement, (:inputs this))
        (NodeClass'updateEdgesInPlace-3 node, duplicationReplacement, (:successors this))
        nil
    )

    ;;;
     ; Gets the input or successor edges defined by this node class.
     ;;
    (defn #_"Edges" NodeClass''getEdges-2 [#_"NodeClass" this, #_"EdgesType" type]
        (if (= type EdgesType'Inputs) (:inputs this) (:successors this))
    )

    (defn- #_"void" NodeClass'createNodeDuplicates-4 [#_"Graph" graph, #_"Node*" nodes, #_"DuplicationReplacement" replacements, #_"EconomicMap<Node, Node>" newNodes]
        (doseq [#_"Node" node nodes]
            (when (some? node)
                (let [
                    #_"Node" replacement (if (some? replacements) (DuplicationReplacement'''replacement-2 replacements, node) node)
                ]
                    (#_"EconomicMap" .put newNodes, node, (if (not= replacement node) replacement (Node''clone-3 node, graph, Node'WithAllEdges)))
                )
            )
        )
        nil
    )

    (defn- #_"void" NodeClass'transferEdges-6 [#_"Graph" graph, #_"DuplicationReplacement" replacements, #_"EconomicMap<Node, Node>" newNodes, #_"Node" oldNode, #_"Node" node, #_"EdgesType" type]
        (let [
            #_"NodeClass" nodeClass (:nodeClass node)
            #_"NodeClass" oldNodeClass (:nodeClass oldNode)
            #_"Edges" oldEdges (NodeClass''getEdges-2 oldNodeClass, type)
        ]
            (doseq [#_"Position" pos (Edges''getPositions-2 oldEdges, oldNode)]
                (when (NodeClass''isValid-4 nodeClass, pos, oldNodeClass, oldEdges)
                    (let [
                        #_"Node" oldEdge (Position''get-2 pos, oldNode)
                    ]
                        (when (some? oldEdge)
                            (let [
                                #_"Node" target
                                    (or (get newNodes oldEdge)
                                        (let [
                                            #_"Node" replacement (if (some? replacements) (DuplicationReplacement'''replacement-2 replacements, oldEdge) oldEdge)
                                        ]
                                            (cond
                                                (not= replacement oldEdge)                                 replacement
                                                (and (= (:graph oldEdge) graph) (= type EdgesType'Inputs)) oldEdge ;; patch to the outer world
                                            )
                                        )
                                    )
                            ]
                                (Position''set-3 pos, node, target)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" NodeClass'transferEdgesDifferentNodeClass-5 [#_"Graph" graph, #_"DuplicationReplacement" replacements, #_"EconomicMap<Node, Node>" newNodes, #_"Node" oldNode, #_"Node" node]
        (NodeClass'transferEdges-6 graph, replacements, newNodes, oldNode, node, EdgesType'Inputs)
        (NodeClass'transferEdges-6 graph, replacements, newNodes, oldNode, node, EdgesType'Successors)
        nil
    )

    (defn #_"EconomicMap<Node, Node>" NodeClass'addGraphDuplicate-5 [#_"Graph" graph, #_"Graph" oldGraph, #_"int" estimatedNodeCount, #_"Node*" nodes, #_"DuplicationReplacement" replacements]
        (let [
            #_"int" denseThreshold (+ (Graph''getNodeCount-1 oldGraph) (>> (:nodesDeleted oldGraph) 4))
            #_"EconomicMap<Node, Node>" newNodes
                (if (< denseThreshold estimatedNodeCount)
                    (NodeMap'new-1g oldGraph) ;; use dense map
                    (EconomicMap/create)      ;; use sparse map
                )
            _ (NodeClass'createNodeDuplicates-4 graph, nodes, replacements, newNodes)
            #_"InplaceUpdateClosure" replacementClosure
                (reify InplaceUpdateClosure
                    (#_"Node" InplaceUpdateClosure'''replacement-3 [#_"InplaceUpdateClosure" this, #_"Node" node, #_"EdgesType" type]
                        (or (get newNodes node)
                            (let [
                                #_"Node" replacement (if (some? replacements) (DuplicationReplacement'''replacement-2 replacements, node) node)
                            ]
                                (cond
                                    (not= replacement node)                                 replacement
                                    (and (= (:graph node) graph) (= type EdgesType'Inputs)) node ;; patch to the outer world
                                )
                            )
                        )
                    )
                )
        ]
            ;; re-wire inputs
            (doseq [#_"Node" oldNode nodes]
                (let [
                    #_"Node" node (get newNodes oldNode)
                    #_"NodeClass" nodeClass (:nodeClass node)
                ]
                    (if (or (nil? replacements) (= (DuplicationReplacement'''replacement-2 replacements, oldNode) oldNode))
                        (NodeClass''updateInputSuccInPlace-3 nodeClass, node, replacementClosure)
                        (NodeClass'transferEdgesDifferentNodeClass-5 graph, replacements, newNodes, oldNode, node)
                    )
                )
            )

            newNodes
        )
    )

    (defn- #_"boolean" NodeClass'equalEdges-3 [#_"Node" node, #_"Node" other, #_"long" mask]
        (loop [mask mask]
            (or (zero? mask)
                (let [
                    #_"long" offset (& mask NodeClass'OFFSET_MASK)
                ]
                    (if (zero? (& mask NodeClass'LIST_MASK))
                        (let [
                            #_"Object" v1 (Edges'getNodeUnsafe-2 node, offset)
                            #_"Object" v2 (Edges'getNodeUnsafe-2 other, offset)
                        ]
                            (and (= v1 v2) (recur (>>> mask NodeClass'NEXT_EDGE)))
                        )
                        (let [
                            #_"Object" v1 (Edges'getNodeListUnsafe-2 node, offset)
                            #_"Object" v2 (Edges'getNodeListUnsafe-2 other, offset)
                        ]
                            (and (= v1 v2) (recur (>>> mask NodeClass'NEXT_EDGE)))
                        )
                    )
                )
            )
        )
    )

    #_unused
    (defn #_"boolean" NodeClass''equalSuccessors-3 [#_"NodeClass" this, #_"Node" node, #_"Node" other]
        (NodeClass'equalEdges-3 node, other, (:successorIteration this))
    )

    (defn #_"boolean" NodeClass''equalInputs-3 [#_"NodeClass" this, #_"Node" node, #_"Node" other]
        (NodeClass'equalEdges-3 node, other, (:inputsIteration this))
    )

    (defn- #_"void" NodeClass'applyEdges-3 [#_"Node" node, #_"EdgeVisitor" consumer, #_"long" mask]
        (loop-when-recur [mask mask] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (let [
                                #_"Node" newNode (EdgeVisitor'''apply-3 consumer, node, n)
                            ]
                                (when-not (= newNode n)
                                    (Edges'putNodeUnsafe-3 node, offset, newNode)
                                )
                            )
                        )
                    )
                    (let [
                        #_"NodeList" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (let [
                                            #_"Node" newNode (EdgeVisitor'''apply-3 consumer, node, n)
                                        ]
                                            (when-not (= newNode n)
                                                (NodeList''initialize-3 list, i, newNode)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" NodeClass''applySuccessors-3 [#_"NodeClass" this, #_"Node" node, #_"EdgeVisitor" consumer]
        (NodeClass'applyEdges-3 node, consumer, (:successorIteration this))
        nil
    )

    (defn #_"void" NodeClass''applyInputs-3 [#_"NodeClass" this, #_"Node" node, #_"EdgeVisitor" consumer]
        (NodeClass'applyEdges-3 node, consumer, (:inputsIteration this))
        nil
    )

    (defn #_"void" NodeClass''unregisterAtSuccessorsAsPredecessor-2 [#_"NodeClass" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:successorIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (Node''updatePredecessor-3 node, n, nil)
                            (Edges'putNodeUnsafe-3 node, offset, nil)
                        )
                    )
                    (let [
                        #_"NodeList" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (Node''updatePredecessor-3 node, n, nil)
                                    )
                                )
                            )
                            (ยง ass! list (NodeList''clearWithoutUpdate-1 list))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" NodeClass''registerAtSuccessorsAsPredecessor-2 [#_"NodeClass" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:successorIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (Node''updatePredecessor-3 node, nil, n)
                        )
                    )
                    (let [
                        #_"NodeList" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (Node''updatePredecessor-3 node, nil, n)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"boolean" NodeClass''replaceFirstInput-4 [#_"NodeClass" this, #_"Node" node, #_"Node" key, #_"Node" replacement]
        (NodeClass'replaceFirstEdge-4 node, key, replacement, (:inputsIteration this))
    )

    (defn #_"boolean" NodeClass''replaceFirstSuccessor-4 [#_"NodeClass" this, #_"Node" node, #_"Node" key, #_"Node" replacement]
        (NodeClass'replaceFirstEdge-4 node, key, replacement, (:successorIteration this))
    )

    (defn #_"boolean" NodeClass'replaceFirstEdge-4 [#_"Node" node, #_"Node" key, #_"Node" replacement, #_"long" mask]
        (loop [mask mask]
            (and (not (zero? mask))
                (or
                    (if (zero? (& mask NodeClass'LIST_MASK))
                        (let [
                            #_"long" offset (& mask NodeClass'OFFSET_MASK)
                        ]
                            (when (= (Edges'getNodeUnsafe-2 node, offset) key)
                                (Edges'putNodeUnsafe-3 node, offset, replacement)
                                true
                            )
                        )
                        (let [
                            #_"NodeList" list (Edges'getNodeListUnsafe-2 node, (& mask NodeClass'OFFSET_MASK))
                        ]
                            (when (and (some? list) (NodeList''replaceFirst-3 list, key, replacement))
                                true
                            )
                        )
                    )
                    (recur (>>> mask NodeClass'NEXT_EDGE))
                )
            )
        )
    )

    (defn #_"void" NodeClass''registerAtInputsAsUsage-2 [#_"NodeClass" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:inputsIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (ยง ass! n (Node''addUsage-2 n, node))
                        )
                    )
                    (let [
                        #_"NodeList" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (ยง ass! n (Node''addUsage-2 n, node))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" NodeClass''unregisterAtInputsAsUsage-2 [#_"NodeClass" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:inputsIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (ยง ass! n (Node''removeUsage-2 n, node))
                            (when (Node''hasNoUsages-1 n)
                                (Node''maybeNotifyZeroUsages-2 node, n)
                            )
                            (Edges'putNodeUnsafe-3 node, offset, nil)
                        )
                    )
                    (let [
                        #_"NodeList" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (ยง ass! n (Node''removeUsage-2 n, node))
                                        (when (Node''hasNoUsages-1 n)
                                            (Node''maybeNotifyZeroUsages-2 node, n)
                                        )
                                    )
                                )
                            )
                            (ยง ass! list (NodeList''clearWithoutUpdate-1 list))
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Name and type of a field.
 ;;
(class-ns FieldKey []
    (defn #_"FieldKey" FieldKey'new-2 [#_"String" name, #_"String" type]
        (merge (FieldKey'class.)
            (hash-map
                #_"String" :name name
                #_"String" :type type
            )
        )
    )
)

;;;
 ; Describes fields in a class, primarily for access via Unsafe.
 ;;
(class-ns Fields []
    (defn #_"Fields" Fields'new-1 [#_"ArrayList<FieldInfo>" fields]
        (Collections/sort fields)
        (let [
            #_"int" n (count fields)
            #_"Fields" this
                (merge (Fields'class.)
                    (hash-map
                        #_"long[]" :offsets (long-array n)
                        #_"String[]" :names (make-array String n)
                        #_"Class[]" :types (make-array Class n)
                        #_"Class[]" :declaringClasses (make-array Class n)
                    )
                )
            _
                (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq fields)] (some? s) [(inc i) (next s)]
                    (let [
                        #_"FieldInfo" f (first s)
                    ]
                        (aset (:offsets this) i (:offset f))
                        (aset (:names this) i (:name f))
                        (aset (:types this) i (:type f))
                        (aset (:declaringClasses this) i (:declaringClass f))
                    )
                )
        ]
            this
        )
    )

    (defn #_"void" Fields'translateInto-2 [#_"Fields" fields, #_"ArrayList<FieldInfo>" infos]
        (dotimes [#_"int" i (count (:offsets fields))]
            (#_"ArrayList" .add infos, (FieldInfo'new-4 (nth (:offsets fields) i), (nth (:names fields) i), (nth (:types fields) i), (nth (:declaringClasses fields) i)))
        )
        nil
    )

    ;;;
     ; Copies fields from {@code from} to {@code to}, both of which must be of the same type.
     ;
     ; @param from the object from which the fields should be copied
     ; @param to the object to which the fields should be copied
     ;;
    (defn #_"void" Fields''copy-3 [#_"Fields" this, #_"Object" from, #_"Object" to]
        (dotimes [#_"int" index (count (:offsets this))]
            (let [
                #_"Class" type (nth (:types this) index)
                #_"long" offset (nth (:offsets this) index)
            ]
                (if (#_"Class" .isPrimitive type)
                    (condp = type
                        int'class     (.putInt     HotSpot'unsafe, to, offset, (.getInt     HotSpot'unsafe, from, offset))
                        long'class    (.putLong    HotSpot'unsafe, to, offset, (.getLong    HotSpot'unsafe, from, offset))
                        boolean'class (.putBoolean HotSpot'unsafe, to, offset, (.getBoolean HotSpot'unsafe, from, offset))
                        short'class   (.putShort   HotSpot'unsafe, to, offset, (.getShort   HotSpot'unsafe, from, offset))
                        char'class    (.putChar    HotSpot'unsafe, to, offset, (.getChar    HotSpot'unsafe, from, offset))
                        byte'class    (.putByte    HotSpot'unsafe, to, offset, (.getByte    HotSpot'unsafe, from, offset))
                    )
                    (.putObject HotSpot'unsafe, to, offset, (.getObject HotSpot'unsafe, from, offset))
                )
            )
        )
        nil
    )

    ;;;
     ; Determines if a field in the domain of this object is the same as the field denoted by
     ; the same index in another Fields object.
     ;;
    (defn #_"boolean" Fields''isSame-3 [#_"Fields" this, #_"Fields" other, #_"int" index]
        (= (nth (:offsets other) index) (nth (:offsets this) index))
    )

    (defn #_"String" Fields''getName-2 [#_"Fields" this, #_"int" index]
        (nth (:names this) index)
    )

    (defn #_"Class" Fields''getType-2 [#_"Fields" this, #_"int" index]
        (nth (:types this) index)
    )

    (defn #_"Class" Fields''getDeclaringClass-2 [#_"Fields" this, #_"int" index]
        (nth (:declaringClasses this) index)
    )

    (defn #_"boolean" Fields''getBoolean-3 [#_"Fields" this, #_"Object" o, #_"int" i] (.getBoolean HotSpot'unsafe, o, (nth (:offsets this) i)))
    (defn #_"byte"    Fields''getByte-3    [#_"Fields" this, #_"Object" o, #_"int" i] (.getByte    HotSpot'unsafe, o, (nth (:offsets this) i)))
    (defn #_"short"   Fields''getShort-3   [#_"Fields" this, #_"Object" o, #_"int" i] (.getShort   HotSpot'unsafe, o, (nth (:offsets this) i)))
    (defn #_"char"    Fields''getChar-3    [#_"Fields" this, #_"Object" o, #_"int" i] (.getChar    HotSpot'unsafe, o, (nth (:offsets this) i)))
    (defn #_"int"     Fields''getInt-3     [#_"Fields" this, #_"Object" o, #_"int" i] (.getInt     HotSpot'unsafe, o, (nth (:offsets this) i)))
    (defn #_"long"    Fields''getLong-3    [#_"Fields" this, #_"Object" o, #_"int" i] (.getLong    HotSpot'unsafe, o, (nth (:offsets this) i)))
    (defn #_"Object"  Fields''getObject-3  [#_"Fields" this, #_"Object" o, #_"int" i] (.getObject  HotSpot'unsafe, o, (nth (:offsets this) i)))

    (defn #_"void" Fields''putObject-4 [#_"Fields" this, #_"Object" object, #_"int" i, #_"Object" value]
        (.putObject HotSpot'unsafe, object, (nth (:offsets this) i), value)
        nil
    )
)

(class-ns Edges [Fields]
    (defn #_"Edges" Edges'new-3 [#_"EdgesType" type, #_"int" directCount, #_"ArrayList<FieldInfo>" edges]
        (merge (Edges'class.) (Fields'new-1 edges)
            (hash-map
                #_"EdgesType" :type type
                ;;;
                 ; Number of direct edges represented by this object. A direct edge goes directly
                 ; to another Node. An indirect edge goes via a NodeList.
                 ;;
                #_"int" :directCount directCount
            )
        )
    )

    (defn #_"void" Edges'translateInto-2 [#_"Edges" edges, #_"ArrayList<EdgeInfo>" infos]
        (dotimes [#_"int" i (count (:offsets edges))]
            (#_"ArrayList" .add infos, (EdgeInfo'new-4 (nth (:offsets edges) i), (Fields''getName-2 edges, i), (Fields''getType-2 edges, i), (Fields''getDeclaringClass-2 edges, i)))
        )
        nil
    )

    (defn #_"Node" Edges'getNodeUnsafe-2 [#_"Node" node, #_"long" offset]
        (ยง cast #_"Node" (.getObject HotSpot'unsafe, node, offset))
    )

    (defn #_"NodeList" Edges'getNodeListUnsafe-2 [#_"Node" node, #_"long" offset]
        (ยง cast #_"NodeList" (.getObject HotSpot'unsafe, node, offset))
    )

    (defn #_"void" Edges'putNodeUnsafe-3 [#_"Node" node, #_"long" offset, #_"Node" value]
        (.putObject HotSpot'unsafe, node, offset, value)
        nil
    )

    (defn #_"void" Edges'putNodeListUnsafe-3 [#_"Node" node, #_"long" offset, #_"NodeList" value]
        (.putObject HotSpot'unsafe, node, offset, value)
        nil
    )

    ;;;
     ; Gets the Node at the end point of a {@linkplain #getDirectCount() direct} edge.
     ;
     ; @param node one end point of the edge
     ; @param index the index of a non-list the edge (must be less than #getDirectCount())
     ; @return the Node at the other edge of the requested edge
     ;;
    (defn #_"Node" Edges'getNode-3 [#_"Node" node, #_"long[]" offsets, #_"int" index]
        (Edges'getNodeUnsafe-2 node, (nth offsets index))
    )

    ;;;
     ; Gets the NodeList at the end point of a {@linkplain #getDirectCount() direct} edge.
     ;
     ; @param node one end point of the edge
     ; @param index the index of a non-list the edge (must be equal to or greater than #getDirectCount())
     ; @return the NodeList at the other edge of the requested edge
     ;;
    (defn #_"NodeList" Edges'getNodeList-3 [#_"Node" node, #_"long[]" offsets, #_"int" index]
        (Edges'getNodeListUnsafe-2 node, (nth offsets index))
    )

    ;;;
     ; Initializes the list edges in a given node based on the size of the list edges in a prototype node.
     ;
     ; @param node the node whose list edges are to be initialized
     ; @param prototype the node whose list edge sizes are used when creating new edge lists
     ;;
    (defn #_"void" Edges''initializeLists-3 [#_"Edges" this, #_"Node" node, #_"Node" prototype]
        (loop-when-recur [#_"int" i (:directCount this)] (< i (count (:offsets this))) [(inc i)]
            (let [
                #_"NodeList" list (Edges'getNodeList-3 prototype, (:offsets this), i)
            ]
                (when (some? list)
                    (let [
                        #_"int" size (:initialSize list)
                    ]
                        (Edges''initializeList-4 this, node, i, (if (= (:type this) EdgesType'Inputs) (NodeInputList'new-2i node, size) (NodeSuccessorList'new-2i node, size)))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Copies edges from {@code fromNode} to {@code toNode}. The nodes are expected to be of the exact same type.
     ;
     ; @param fromNode the node from which the edges should be copied.
     ; @param toNode the node to which the edges should be copied.
     ;;
    (defn #_"void" Edges''copy-3 [#_"Edges" this, #_"Node" fromNode, #_"Node" toNode]
        (let [
            #_"int" i
                (loop-when-recur [i 0] (< i (:directCount this)) [(inc i)] => i
                    (Edges''initializeNode-4 this, toNode, i, (Edges'getNode-3 fromNode, (:offsets this), i))
                )
        ]
            (loop-when-recur i (< i (count (:offsets this))) (inc i)
                (let [
                    #_"NodeList" list (Edges'getNodeList-3 toNode, (:offsets this), i)
                    #_"NodeList" from (Edges'getNodeList-3 fromNode, (:offsets this), i)
                ]
                    (when (or (nil? list) (= list from)) => (NodeList''copy-2 list, from)
                        (Edges''initializeList-4 this, toNode, i, (if (= (:type this) EdgesType'Inputs) (NodeInputList'new-2s toNode, from) (NodeSuccessorList'new-2s toNode, from)))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" Edges''verifyUpdateValid-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"Object" newValue]
        (when (and (some? newValue) (not (#_"Class" .isAssignableFrom (Fields''getType-2 this, index), (#_"Object" .getClass newValue))))
            (throw (IllegalArgumentException. (str "Can not assign " (#_"Object" .getClass newValue) " to " (Fields''getType-2 this, index) " in " node)))
        )
        nil
    )

    ;;;
     ; Sets the value of a given edge without notifying the new and old nodes on the other end of the edge of the change.
     ;
     ; @param node the node whose edge is to be updated
     ; @param index the index of the edge (between 0 and #getCount())
     ; @param value the node to be written to the edge
     ;;
    (defn #_"void" Edges''initializeNode-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"Node" value]
        (Edges''verifyUpdateValid-4 this, node, index, value)
        (Edges'putNodeUnsafe-3 node, (nth (:offsets this) index), value)
        nil
    )

    (defn #_"void" Edges''initializeList-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"NodeList" value]
        (Edges''verifyUpdateValid-4 this, node, index, value)
        (Edges'putNodeListUnsafe-3 node, (nth (:offsets this) index), value)
        nil
    )

    ;;;
     ; Sets the value of a given edge and notifies the new and old nodes on the other end of the edge of the change.
     ;
     ; @param node the node whose edge is to be updated
     ; @param index the index of the edge (between 0 and #getCount())
     ; @param value the node to be written to the edge
     ;;
    (defn #_"void" Edges''setNode-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"Node" value]
        (let [
            #_"Node" old (Edges'getNodeUnsafe-2 node, (nth (:offsets this) index))
        ]
            (Edges''initializeNode-4 this, node, index, value)
            (Edges'''update-4 this, node, old, value)
        )
        nil
    )

    ;;;
     ; A sequence that is iterable over edges.
     ;;
    (defn #_"Position*" Edges''getPositions-2 [#_"Edges" this, #_"Node" node]
        (iterator-seq
            (let [
                #_"Edges" edges this
                #_"int" i -1
                #_"int" j 0
                #_"boolean" forward? true
                forward-
                    (ร fn #_"void" []
                        (ยง ass! forward? false)
                        (if (< i (:directCount edges))
                            (do
                                (ยง ass! i (inc i))
                                (when (< i (:directCount edges))
                                    (ยง return )
                                )
                            )
                            (ยง ass! j (inc j))
                        )
                        (loop-when [] (< i (count (:offsets edges)))
                            (let [
                                #_"NodeList" list (Edges'getNodeList-3 node, (:offsets edges), i)
                            ]
                                (when-not (and (some? list) (< j (count list)))
                                    (ยง ass! j 0)
                                    (ยง ass! i (inc i))
                                    (recur)
                                )
                            )
                        )
                        nil
                    )
            ]
                (reify Iterator #_"<Position>"
                    (#_"boolean" hasNext [#_"Iterator<Position>" this]
                        (when forward?
                            (forward-)
                        )
                        (< i (count (:offsets edges)))
                    )

                    (#_"Position" next [#_"Iterator<Position>" this]
                        (when forward?
                            (forward-)
                        )
                        (ยง ass! forward? true)
                        (Position'new-3 edges, i, (if (< i (:directCount edges)) -1 j))
                    )
                )
            )
        )
    )
)

(class-ns InputEdges [Edges, Fields]
    (defn #_"InputEdges" InputEdges'new-2 [#_"int" directCount, #_"ArrayList<InputInfo>" edges]
        (let [
            #_"InputEdges" this
                (merge (InputEdges'class.) (Edges'new-3 EdgesType'Inputs, directCount, edges)
                    (hash-map
                        #_"InputType[]" :inputTypes (make-array InputType (count edges))
                        #_"boolean[]" :isOptional (boolean-array (count edges))
                    )
                )
        ]
            (dotimes [#_"int" i (count edges)]
                (aset (:inputTypes this) i (:inputType (nth edges i)))
                (aset (:isOptional this) i (:optional (nth edges i)))
            )
            this
        )
    )

    (defn #_"void" InputEdges'translateInto-2 [#_"InputEdges" inputs, #_"ArrayList<InputInfo>" infos]
        (dotimes [#_"int" i (count (:offsets inputs))]
            (#_"ArrayList" .add infos, (InputInfo'new-6 (nth (:offsets inputs) i), (Fields''getName-2 inputs, i), (Fields''getType-2 inputs, i), (Fields''getDeclaringClass-2 inputs, i), (nth (:inputTypes inputs) i), (InputEdges''isOptional-2 inputs, i)))
        )
        nil
    )

    (defn #_"InputType" InputEdges''getInputType-2 [#_"InputEdges" this, #_"int" index]
        (nth (:inputTypes this) index)
    )

    (defn #_"boolean" InputEdges''isOptional-2 [#_"InputEdges" this, #_"int" index]
        (nth (:isOptional this) index)
    )

    (defm InputEdges Edges
        (#_"void" Edges'''update-4 [#_"InputEdges" this, #_"Node" node, #_"Node" oldValue, #_"Node" newValue]
            (Node''updateUsages-3 node, oldValue, newValue)
            nil
        )
    )
)

(class-ns SuccessorEdges [Edges, Fields]
    (defn #_"SuccessorEdges" SuccessorEdges'new-2 [#_"int" directCount, #_"ArrayList<EdgeInfo>" edges]
        (merge (SuccessorEdges'class.) (Edges'new-3 EdgesType'Successors, directCount, edges))
    )

    (defm SuccessorEdges Edges
        (#_"void" Edges'''update-4 [#_"SuccessorEdges" this, #_"Node" node, #_"Node" oldValue, #_"Node" newValue]
            (Node''updatePredecessor-3 node, oldValue, newValue)
            nil
        )
    )
)

(class-ns Values [Fields]
    (defn #_"Values" Values'new-1 [#_"OperandModeAnnotation" mode]
        (merge (Values'class.) (Fields'new-1 (:values mode))
            (hash-map
                #_"int" :directCount (:directCount mode)
                #_"{OperandFlag}*" :flags* (map :flags (:values mode))
            )
        )
    )

    (defn #_"{OperandFlag}" Values''getFlags-2 [#_"Values" this, #_"int" i]
        (nth (:flags* this) i)
    )

    (defn #_"Value" Values''getValue-3 [#_"Values" this, #_"Object" obj, #_"int" index]
        (Fields''getObject-3 this, obj, index)
    )

    (defn #_"void" Values''setValue-4 [#_"Values" this, #_"Object" obj, #_"int" index, #_"Value" value]
        (Fields''putObject-4 this, obj, index, value)
        nil
    )
)

;;;
 ; Field cache for a ResolvedJavaType.
 ;;
(class-ns FieldsCache []
    (defn #_"FieldsCache" FieldsCache'new-0 []
        (FieldsCache'class.)
    )

    (ยง volatile #_"EconomicMap<FieldKey, ResolvedJavaField>" :instanceFields nil)
    (ยง volatile #_"EconomicMap<FieldKey, ResolvedJavaField>" :staticFields nil)

    (defn- #_"EconomicMap<FieldKey, ResolvedJavaField>" FieldsCache'createFieldMap-1 [#_"ResolvedJavaField*" fields]
        (let [
            #_"EconomicMap<FieldKey, ResolvedJavaField>" map (EconomicMap/create)
        ]
            (doseq [#_"ResolvedJavaField" f fields]
                (#_"EconomicMap" .put map, (FieldKey'new-2 (#_"ResolvedJavaField" .getName f), (#_"JavaType" .getName (#_"ResolvedJavaField" .getType f))), f)
            )
            map
        )
    )

    (defn #_"ResolvedJavaField" FieldsCache''lookup-5 [#_"FieldsCache" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" fieldType, #_"boolean" static?]
        (let [
            #_"FieldKey" key (FieldKey'new-2 name, fieldType)
        ]
            (if static?
                (do
                    (when (nil? (:staticFields this))
                        ;; racy initialization is safe since staticFields is volatile
                        (ยง ass! this (assoc this :staticFields (FieldsCache'createFieldMap-1 (#_"ResolvedJavaType" .getStaticFields type))))
                    )
                    (get (:staticFields this) key)
                )
                (do
                    (when (nil? (:instanceFields this))
                        ;; racy initialization is safe since instanceFields is volatile
                        (ยง ass! this (assoc this :instanceFields (FieldsCache'createFieldMap-1 (#_"ResolvedJavaType" .getInstanceFields type, false))))
                    )
                    (get (:instanceFields this) key)
                )
            )
        )
    )
)

(class-ns FieldsScanner []
    (defn #_"FieldsScanner" FieldsScanner'new-0 []
        (merge (FieldsScanner'class.)
            (hash-map
                ;;;
                 ; Fields not belonging to a more specific category defined by scanner subclasses are added to this list.
                 ;;
                #_"ArrayList<FieldInfo>" :data (ArrayList.)
            )
        )
    )

    ;;;
     ; Scans the fields in a class hierarchy.
     ;
     ; @param clazz the class at which to start scanning
     ; @param endClazz scanning stops when this class is encountered (i.e. {@code endClazz} is not scanned)
     ;;
    (defn #_"this" FieldsScanner''scan-3 [#_"FieldsScanner" this, #_"Class" clazz, #_"Class" endClazz]
        (loop-when-recur clazz (not= clazz endClazz) (#_"Class" .getSuperclass clazz)
            (doseq [#_"Field" field (#_"Class" .getDeclaredFields clazz)]
                (let [
                    #_"int" modifiers (#_"Field" .getModifiers field)
                ]
                    (when (and (not (Modifier/isStatic modifiers)) (not (Modifier/isTransient modifiers)))
                        (FieldsScanner'''scanField-3 this, field, (.objectFieldOffset HotSpot'unsafe, field))
                    )
                )
            )
        )
        this
    )
)

(class-ns LIRFieldsScanner [FieldsScanner]
    (defn #_"LIRFieldsScanner" LIRFieldsScanner'new-0 []
        (merge (LIRFieldsScanner'class.) (FieldsScanner'new-0)
            (hash-map
                #_"{Class<Annotation> OperandModeAnnotation}" :valueAnnotations (into {} (map #(vector % (OperandModeAnnotation'new-0)) [ Use Alive Temp Def ]))
            )
        )
    )

    (defn- #_"OperandModeAnnotation" LIRFieldsScanner''getOperandModeAnnotation-2 [#_"LIRFieldsScanner" this, #_"Field" field]
        (some #(when (some? (#_"Field" .getAnnotation field, (key %))) (val %)) (:valueAnnotations this))
    )

    (defn- #_"{OperandFlag}" LIRFieldsScanner'getFlags-1 [#_"Field" field]
        (hash-set
            (#_"Annotation" .value (#_"Field" .getAnnotation field, (some #(when (#_"Field" .isAnnotationPresent field, %) %) [ Use Alive Temp Def ])))
        )
    )

    (defm LIRFieldsScanner FieldsScanner
        (#_"void" FieldsScanner'''scanField-3 [#_"LIRFieldsScanner" this, #_"Field" field, #_"long" offset]
            (let [
                #_"String" name (#_"Field" .getName field)
                #_"Class" type (#_"Field" .getType field)
                #_"Class" declaringClass (#_"Field" .getDeclaringClass field)
            ]
                (cond
                    (and (#_"Class" .isAssignableFrom Value, type) (not (#_"Class" .isAssignableFrom ConstantValue'iface, type)))
                        (let [
                            #_"OperandModeAnnotation" annotation (LIRFieldsScanner''getOperandModeAnnotation-2 this, field)
                        ]
                            (#_"ArrayList" .add (:values annotation), (ValueFieldInfo'new-5 offset, name, type, declaringClass, (LIRFieldsScanner'getFlags-1 field)))
                            (ยง ass annotation (update annotation :directCount inc))
                        )
                    (#_"Class" .isAssignableFrom (ร Value'array), type)
                        (let [
                            #_"OperandModeAnnotation" annotation (LIRFieldsScanner''getOperandModeAnnotation-2 this, field)
                        ]
                            (#_"ArrayList" .add (:values annotation), (ValueFieldInfo'new-5 offset, name, type, declaringClass, (LIRFieldsScanner'getFlags-1 field)))
                        )
                    :else
                        (#_"ArrayList" .add (:data this), (FieldInfo'new-4 offset, name, type, declaringClass))
                )
            )
            nil
        )
    )
)

(class-ns NodeFieldsScanner [FieldsScanner]
    (defn #_"NodeFieldsScanner" NodeFieldsScanner'new-1 [#_"NodeClass" superNodeClass]
        (let [
            #_"NodeFieldsScanner" this
                (merge (NodeFieldsScanner'class.) (FieldsScanner'new-0)
                    (hash-map
                        #_"ArrayList<InputInfo>" :inputs (ArrayList.)
                        #_"ArrayList<EdgeInfo>" :successors (ArrayList.)
                        #_"int" :directInputs 0
                        #_"int" :directSuccessors 0
                    )
                )
            this
                (when (some? superNodeClass) => this
                    (InputEdges'translateInto-2 (:inputs superNodeClass), (:inputs this))
                    (Edges'translateInto-2 (:successors superNodeClass), (:successors this))
                    (Fields'translateInto-2 (:data superNodeClass), (:data this))
                    (let [
                        this (assoc this :directInputs (:directCount (:inputs superNodeClass)))
                        this (assoc this :directSuccessors (:directCount (:successors superNodeClass)))
                    ]
                        this
                    )
                )
        ]
            this
        )
    )

    (defm NodeFieldsScanner FieldsScanner
        (#_"void" FieldsScanner'''scanField-3 [#_"NodeFieldsScanner" this, #_"Field" field, #_"long" offset]
            (let [
                #_"Input" inputAnnotation (#_"AnnotatedElement" .getAnnotation field, Input)
                #_"OptionalInput" optionalInputAnnotation (#_"AnnotatedElement" .getAnnotation field, OptionalInput)
                #_"Successor" successorAnnotation (#_"AnnotatedElement" .getAnnotation field, Successor)
                #_"Class" type (#_"Field" .getType field)
                #_"int" modifiers (#_"Field" .getModifiers field)
            ]
                (cond
                    (or (some? inputAnnotation) (some? optionalInputAnnotation))
                    (do
                        (if (#_"Class" .isAssignableFrom NodeInputList'iface, type)
                            (do
                                ;; NodeInputList fields should not be final, since they are written (via Unsafe) in clearInputs()
                                (when (Modifier/isFinal modifiers)
                                    (throw! (str "NodeInputList input field " field " should not be final"))
                                )
                                (when (Modifier/isPublic modifiers)
                                    (throw! (str "NodeInputList input field " field " should not be public"))
                                )
                            )
                            (do
                                (when-not (or (#_"Class" .isAssignableFrom Node'iface, type) (#_"Class" .isInterface type))
                                    (throw! (str "invalid input type: " type))
                                )
                                (when (Modifier/isFinal modifiers)
                                    (throw! (str "Node input field " field " should not be final"))
                                )
                                (ยง ass! this (update this :directInputs inc))
                            )
                        )
                        (let [
                            #_"InputType" inputType (if (some? inputAnnotation) (#_"Input" .value inputAnnotation) (#_"OptionalInput" .value optionalInputAnnotation))
                        ]
                            (#_"ArrayList" .add (:inputs this), (InputInfo'new-6 offset, (#_"Field" .getName field), type, (#_"Field" .getDeclaringClass field), inputType, (#_"Field" .isAnnotationPresent field, OptionalInput)))
                        )
                    )
                    (some? successorAnnotation)
                    (do
                        (if (#_"Class" .isAssignableFrom NodeSuccessorList'iface, type)
                            (do
                                ;; NodeSuccessorList fields should not be final, since they are written (via Unsafe) in clearSuccessors()
                                (when (Modifier/isFinal modifiers)
                                    (throw! (str "NodeSuccessorList successor field " field "should not be final"))
                                )
                                (when (Modifier/isPublic modifiers)
                                    (throw! (str "NodeSuccessorList successor field " field " should not be public"))
                                )
                            )
                            (do
                                (when-not (#_"Class" .isAssignableFrom Node'iface, type)
                                    (throw! (str "invalid successor type: " type))
                                )
                                (when (Modifier/isFinal modifiers)
                                    (throw! (str "Node successor field " field " should not be final"))
                                )
                                (ยง ass! this (update this :directSuccessors inc))
                            )
                        )
                        (#_"ArrayList" .add (:successors this), (EdgeInfo'new-4 offset, (#_"Field" .getName field), type, (#_"Field" .getDeclaringClass field)))
                    )
                    :else
                    (do
                        (when (and (#_"Class" .isAssignableFrom Node'iface, type) (not (= (#_"Field" .getName field) "Null")))
                            (throw! (str "suspicious node field: " field))
                        )
                        (when (#_"Class" .isAssignableFrom NodeInputList'iface, type)
                            (throw! (str "suspicious node input list field: " field))
                        )
                        (when (#_"Class" .isAssignableFrom NodeSuccessorList'iface, type)
                            (throw! (str "suspicious node successor list field: " field))
                        )
                        (#_"ArrayList" .add (:data this), (FieldInfo'new-4 offset, (#_"Field" .getName field), (#_"Field" .getType field), (#_"Field" .getDeclaringClass field)))
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Calculates the stack intervals using a worklist-based backwards data-flow analysis.
 ;;
(class-ns FixPointIntervalBuilder []
    (defn #_"FixPointIntervalBuilder" FixPointIntervalBuilder'new-3 [#_"LIR" lir, #_"StackInterval[]" stackSlotMap, #_"int" maxOpId]
        (merge (FixPointIntervalBuilder'class.)
            (hash-map
                #_"LIR" :lir lir
                #_"StackInterval[]" :stackSlotMap stackSlotMap
                #_"int" :maxOpId maxOpId
                #_"BlockMap<BitSet>" :liveInMap (BlockMap'new-1 (:cfg lir))
                #_"BlockMap<BitSet>" :liveOutMap (BlockMap'new-1 (:cfg lir))
                #_"EconomicSet<LIRInstruction>" :usePos (EconomicSet/create)
            )
        )
    )

    (defn- #_"StackInterval" FixPointIntervalBuilder''get-2 [#_"FixPointIntervalBuilder" this, #_"VirtualStackSlot" stackSlot]
        (nth (:stackSlotMap this) (:id stackSlot))
    )

    (defn- #_"void" FixPointIntervalBuilder''put-3 [#_"FixPointIntervalBuilder" this, #_"VirtualStackSlot" stackSlot, #_"StackInterval" interval]
        (aset (:stackSlotMap this) (:id stackSlot) interval)
        nil
    )

    ;;;
     ; Merge outSet with in-set of successors.
     ;;
    (defn- #_"boolean" FixPointIntervalBuilder''updateOutBlock-2 [#_"FixPointIntervalBuilder" this, #_"Block" block]
        (let [
            #_"BitSet" union (BitSet.)
        ]
            (doseq [#_"Block" succ (:successors block)]
                (#_"BitSet" .or union, (BlockMap''get-2 (:liveInMap this), succ))
            )
            (let [
                #_"BitSet" outSet (BlockMap''get-2 (:liveOutMap this), block)
            ]
                ;; check if changed
                (when-not (and (some? outSet) (= union outSet)) => false
                    (BlockMap''put-3 (:liveOutMap this), block, union)
                    true
                )
            )
        )
    )

    (defn- #_"void" FixPointIntervalBuilder''markOutInterval-3 [#_"FixPointIntervalBuilder" this, #_"BitSet" outSet, #_"int" blockEndOpId]
        (loop-when-recur [#_"int" i (#_"BitSet" .nextSetBit outSet, 0)] (<= 0 i) [(#_"BitSet" .nextSetBit outSet, (inc i))]
            (ยง ass! (nth (:stackSlotMap this) i) (StackInterval''addTo-2 (nth (:stackSlotMap this) i), blockEndOpId))
        )
        nil
    )

    (defn- #_"void" FixPointIntervalBuilder''markInInterval-3 [#_"FixPointIntervalBuilder" this, #_"BitSet" inSet, #_"int" blockFirstOpId]
        (loop-when-recur [#_"int" i (#_"BitSet" .nextSetBit inSet, 0)] (<= 0 i) [(#_"BitSet" .nextSetBit inSet, (inc i))]
            (ยง ass! (nth (:stackSlotMap this) i) (StackInterval''addFrom-2 (nth (:stackSlotMap this) i), blockFirstOpId))
        )
        nil
    )

    (defn #_"StackInterval" FixPointIntervalBuilder''getOrCreateInterval-2 [#_"FixPointIntervalBuilder" this, #_"VirtualStackSlot" stackSlot]
        (let [
            #_"StackInterval" interval (FixPointIntervalBuilder''get-2 this, stackSlot)
        ]
            (when (nil? interval)
                (ยง ass interval (StackInterval'new-2 stackSlot, (#_"Value" .getValueKind stackSlot)))
                (FixPointIntervalBuilder''put-3 this, stackSlot, interval)
            )
            interval
        )
    )

    (defn- #_"int" FixPointIntervalBuilder'getBlockBegin-1 [#_"List<LIRInstruction>" ops]
        (:id (nth ops 0))
    )

    (defn- #_"int" FixPointIntervalBuilder'getBlockEnd-1 [#_"List<LIRInstruction>" ops]
        (inc (:id (nth ops (dec (count ops)))))
    )

    (defn- #_"void" FixPointIntervalBuilder''processBlock-3 [#_"FixPointIntervalBuilder" this, #_"Block" block, #_"Deque<Block>" worklist]
        (when (FixPointIntervalBuilder''updateOutBlock-2 this, block)
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
                ;; get out set and mark intervals
                #_"BitSet" outSet (BlockMap''get-2 (:liveOutMap this), block)
            ]
                (FixPointIntervalBuilder''markOutInterval-3 this, outSet, (FixPointIntervalBuilder'getBlockEnd-1 ops))

                ;; process instructions
                (let [
                    #_"BlockClosure" closure (BlockClosure'new-2 this, (#_"Object" .clone outSet))
                ]
                    (loop-when-recur [#_"int" i (dec (count ops))] (<= 0 i) [(dec i)]
                        (BlockClosure''processInstructionBottomUp-2 closure, (nth ops i))
                    )

                    ;; add predecessors to work list
                    (doseq [#_"Block" b (:predecessors block)]
                        (#_"Deque" .add worklist, b)
                    )
                    ;; set in set and mark intervals
                    (let [
                        #_"BitSet" inSet (:currentSet closure)
                    ]
                        (BlockMap''put-3 (:liveInMap this), block, inSet)
                        (FixPointIntervalBuilder''markInInterval-3 this, inSet, (FixPointIntervalBuilder'getBlockBegin-1 ops))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Builds the lifetime intervals for {@link VirtualStackSlot virtual stack slots}, sets up #stackSlotMap
     ; and returns a set of use positions, i.e. instructions that contain virtual stack slots.
     ;;
    (defn #_"EconomicSet<LIRInstruction>" FixPointIntervalBuilder''build-1 [#_"FixPointIntervalBuilder" this]
        (let [
            #_"Deque<Block>" worklist (ArrayDeque.)
            #_"Block[]" blocks (:reversePostOrder (:cfg (:lir this)))
        ]
            (loop-when-recur [#_"int" i (dec (count blocks))] (<= 0 i) [(dec i)]
                (#_"Deque" .add worklist, (nth blocks i))
            )
            (doseq [#_"Block" block (:reversePostOrder (:cfg (:lir this)))]
                (BlockMap''put-3 (:liveInMap this), block, (BitSet.))
            )
            (while (seq worklist)
                (FixPointIntervalBuilder''processBlock-3 this, (#_"Deque" .poll worklist), worklist)
            )
            (:usePos this)
        )
    )
)

;;;
 ; This phase lowers FloatingReadNodes into corresponding fixed reads.
 ;;
(class-ns FixReadsPhase [Phase]
    (defn #_"FixReadsPhase" FixReadsPhase'new-1 [#_"Phase" schedulePhase]
        (merge (FixReadsPhase'class.)
            (hash-map
                #_"Phase" :schedulePhase schedulePhase
            )
        )
    )

    (defm FixReadsPhase Phase
        (#_"Graph" Phase'''run-3 [#_"FixReadsPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (ยง ass! graph (Phase'''run-3 (:schedulePhase this), graph, nil))
            (let [
                #_"ScheduleResult" schedule (:lastSchedule graph)
                #_"FixReadsClosure" fixReadsClosure (FixReadsClosure'new-0)
            ]
                (doseq [#_"Block" block (:reversePostOrder (:cfg schedule))]
                    (ScheduledNodeIterator''processNodes-3 fixReadsClosure, block, schedule)
                )
                (when GraalOptions'rawConditionalElimination
                    (ControlFlowGraph''visitDominatorTree-3 (:cfg schedule), (RawConditionalEliminationVisitor'new-2 graph, schedule), false)
                )
                (Graph''setAfterFixReadPhase-2 graph, true)
            )
        )
    )
)

;;;
 ; Compute probabilities for fixed nodes on the fly and cache them at AbstractBeginNodes.
 ;;
(class-ns FixedNodeProbabilityCache [#_"ToDoubleFunction" #_"<FixedNode>"]
    (defn #_"FixedNodeProbabilityCache" FixedNodeProbabilityCache'new-0 []
        (merge (FixedNodeProbabilityCache'class.)
            (hash-map
                #_"EconomicMap<FixedNode, Double>" :cache (EconomicMap/create)
            )
        )
    )

    (defn- #_"FixedNode" FixedNodeProbabilityCache'findBegin-1 [#_"FixedNode" node]
        (loop [node node]
            (let [
                #_"Node" predecessor (:predecessor node)
            ]
                (if (satisfies? AbstractBeginNode node)
                    (when (and (some? predecessor) (= (count (Node''successors-1 predecessor)) 1)) => node
                        (recur predecessor)
                    )
                    (when (some? predecessor)
                        (recur predecessor)
                    )
                )
            )
        )
    )

    (defn- #_"double" FixedNodeProbabilityCache''handleMerge-3 [#_"FixedNodeProbabilityCache" this, #_"FixedNode" node, #_"double" probability]
        ;; Use simple iteration instead of streams, since the stream infrastructure adds many frames
        ;; which causes the recursion to overflow the stack earlier than it would otherwise.
        (let [
            probability
                (loop-when-recur [probability probability #_"ISeq" s (seq (:ends node))]
                                 (some? s)
                                 [(+ probability (FixedNodeProbabilityCache''applyAsDouble-2 this, (first s))) (next s)]
                              => probability
                )
        ]
            (when (satisfies? LoopBeginNode node) => probability
                (ControlFlowGraph'multiplyProbabilities-2 probability, (:loopFrequency node))
            )
        )
    )

    ;;;
     ; Given a FixedNode this method finds the most immediate AbstractBeginNode preceding it that either:
     ;
     ; - has no predecessor (i.e. the begin-node is a merge, in particular a loop-begin, or the start-node)
     ; - has a control-split predecessor
     ;
     ; The thus found AbstractBeginNode is equi-probable with the FixedNode it was obtained from.
     ; When computed for the first time (afterwards a cache lookup returns it) that probability
     ; is computed as follows, again depending on the begin-node's predecessor:
     ;
     ; - No predecessor. In this case the begin-node is either:
     ; -- a merge-node, whose probability adds up those of its forward-ends
     ; -- a loop-begin, with probability as above multiplied by the loop-frequency
     ; - Control-split predecessor: probability of the branch times that of the control-split
     ;
     ; As an exception to all the above, a probability of 1 is assumed for a FixedNode that
     ; appears to be dead-code (i.e. lacks a predecessor).
     ;;
    (defn #_"double" FixedNodeProbabilityCache''applyAsDouble-2 [#_"FixedNodeProbabilityCache" this, #_"FixedNode" node]
        (let [
            node (FixedNodeProbabilityCache'findBegin-1 node)
        ]
            (when (some? node) => 1.0 ;; this should only appear for dead code
                (or (get (:cache this) node)
                    (let [
                        #_"Node" predecessor (:predecessor node)
                        #_"double" probability
                            (if (some? predecessor)
                                (ControlFlowGraph'multiplyProbabilities-2 (ControlSplitNode'''probability-2 predecessor, node), (FixedNodeProbabilityCache''applyAsDouble-2 this, predecessor))
                                (if (satisfies? AbstractMergeNode node)
                                    (FixedNodeProbabilityCache''handleMerge-3 this, node, 0.0)
                                    1.0
                                )
                            )
                    ]
                        (#_"EconomicMap" .put (:cache this), node, probability)
                        probability
                    )
                )
            )
        )
    )
)

(class-ns FixedTarget []
    (defn #_"FixedTarget" FixedTarget'new-2 [#_"FixedNode" fixed, #_"FrameStateBuilder" state]
        (merge (FixedTarget'class.)
            (hash-map
                #_"FixedNode" :fixed fixed
                #_"FrameStateBuilder" :state state
            )
        )
    )
)

(class-ns FloatingReadPhase [Phase]
    (defn #_"FloatingReadPhase" FloatingReadPhase'new-0 []
        (FloatingReadPhase'new-2 true, false)
    )

    ;;;
     ; @param createFloatingReads specifies whether FloatableAccessNodes like ReadNode
     ;            should be converted into floating nodes (e.g. FloatingReadNodes) where possible
     ; @param createMemoryMapNodes a MemoryMapNode will be created for each return if this is true
     ;;
    (defn #_"FloatingReadPhase" FloatingReadPhase'new-2 [#_"boolean" createFloatingReads, #_"boolean" createMemoryMapNodes]
        (merge (FloatingReadPhase'class.)
            (hash-map
                #_"boolean" :createFloatingReads createFloatingReads
                #_"boolean" :createMemoryMapNodes createMemoryMapNodes
            )
        )
    )

    (defn- #_"{LocationIdentity}" FloatingReadPhase'processIdentity-2 [#_"{LocationIdentity}" state, #_"LocationIdentity" location]
        (when-not (:immutable location) => state
            (conj state location)
        )
    )

    (defn- #_"{LocationIdentity}" FloatingReadPhase'processNode-2 [#_"{LocationIdentity}" state, #_"FixedNode" node]
        (condp satisfies? node
            Single        (FloatingReadPhase'processIdentity-2 state, (Single'''getLocationIdentity-1 node))
            Multi  (reduce FloatingReadPhase'processIdentity-2 state (Multi'''getLocationIdentities-1 node))
                                                               state
        )
    )

    (defn- #_"{LocationIdentity}" FloatingReadPhase'processBlock-2 [#_"{LocationIdentity}" state, #_"Block" block]
        (reduce FloatingReadPhase'processNode-2 state (Block''getNodes-1 block))
    )

    (defn- #_"{LoopBeginNode {LocationIdentity}}" FloatingReadPhase'processLoop-2 [#_"{LoopBeginNode {LocationIdentity}}" m, #_"Loop" _loop]
        (let [
            #_"LoopBeginNode" loopBegin (:beginNode (:header _loop))
        ]
            (when-not (contains? m loopBegin) => m
                (let [
                    m (reduce FloatingReadPhase'processLoop-2 m (:children _loop))
                    #_"{LocationIdentity}" s (into #{} (mapcat #(get m (:beginNode (:header %))) (:children _loop)))
                    s (reduce FloatingReadPhase'processBlock-2 s (filter #(= (:loop %) _loop) (:blocks _loop)))
                ]
                    (assoc m loopBegin s)
                )
            )
        )
    )

    ;;;
     ; Removes nodes from a given set that (transitively) have a usage outside the set.
     ;;
    (defn- #_"EconomicSet<Node>" FloatingReadPhase'removeExternallyUsedNodes-1 [#_"EconomicSet<Node>" set]
        (loop []
            (let [
                #_"boolean" changed?
                    (loop-when [changed? false #_"Iterator<Node>" it (#_"EconomicSet" .iterator set)] (#_"Iterator" .hasNext it) => changed?
                        (let [
                            changed?
                                (loop-when [changed? changed? #_"ISeq" s (seq (:nodeUsages (#_"Iterator" .next it)))] (some? s) => changed?
                                    (when-not (contains? set (first s)) => (recur changed? (next s))
                                        (#_"Iterator" .remove it)
                                        true
                                    )
                                )
                        ]
                            (recur changed? it)
                        )
                    )
            ]
                (recur-if changed? [])
            )
        )
        set
    )

    ; @SuppressWarnings("try")
    (defm FloatingReadPhase Phase
        (#_"Graph" Phase'''run-3 [#_"FloatingReadPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"{LoopBeginNode {LocationIdentity}}" modifiedInLoops
                    (when (Graph''hasLoops-1 graph)
                        (reduce FloatingReadPhase'processLoop-2 {} (:loops (ControlFlowGraph'compute-5 graph, true, true, false, false)))
                    )
                #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-1 (EnumSet/of NodeEvent'NODE_ADDED, NodeEvent'ZERO_USAGES))
            ]
                (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                    (ReentrantNodeIterator'apply-3 (FloatingReadClosure'new-3 modifiedInLoops, (:createFloatingReads this), (:createMemoryMapNodes this)), (:start graph), (MemoryMap0'new-1 (:start graph)))
                )
                (doseq [#_"Node" node (FloatingReadPhase'removeExternallyUsedNodes-1 (:nodes listener))]
                    (when (and (Node''isAlive-1 node) (satisfies? FloatingNode node))
                        (ยง ass! node (Node''replaceAtUsages-2 node, nil))
                        (GraphUtil'killWithUnusedFloatingInputs-1 node)
                    )
                )
                (when (:createFloatingReads this) => graph
                    (Graph''setAfterFloatingReadPhase-2 graph, true)
                )
            )
        )
    )

    (defn #_"MemoryMap0" FloatingReadPhase'mergeMemoryMaps-2 [#_"AbstractMergeNode" merge, #_"List<MemoryMap>" states]
        (let [
            #_"MemoryMap0" newState (MemoryMap0'new-0)
        ]
            (doseq [#_"LocationIdentity" key (into #{} (mapcat MemoryMap'''getLocations-1 states))]
                (let [
                    #_"MemoryNode" merged
                        (loop-when [merged nil #_"boolean" isPhi false #_"int" n 0 #_"ISeq" s (seq states)] (some? s) => merged
                            (let [
                                #_"MemoryMap" state (first s)
                                #_"MemoryNode" last (MemoryMap'''getLastLocationAccess-2 state, key)
                                [merged isPhi]
                                    (cond
                                        isPhi
                                            (do
                                                (PhiNode''addInput-2 merged, last)
                                                [merged isPhi]
                                            )
                                        (or (nil? merged) (= merged last))
                                            [last isPhi] ;; nothing to do
                                        :else
                                            (let [
                                                #_"MemoryPhiNode" phi (Graph''add-2 (:graph merge), (MemoryPhiNode'new-2 merge, key))
                                            ]
                                                (dotimes [_ n]
                                                    (PhiNode''addInput-2 phi, merged)
                                                )
                                                (PhiNode''addInput-2 phi, last)
                                                [phi true]
                                            )
                                    )
                            ]
                                (recur merged isPhi (inc n) (next s))
                            )
                        )
                ]
                    (#_"EconomicMap" .put (:lastMemorySnapshot newState), key, merged)
                )
            )
            newState
        )
    )
)

;;;
 ; The name and signature of a foreign call. A foreign call differs from a normal compiled Java call
 ; in at least one of these aspects:
 ;
 ; (1) The call is to C/C++/assembler code.
 ; (2) The call uses different conventions for passing parameters or returning values.
 ; (3) The callee has different register saving semantics. For example, the callee may save all
 ; registers (apart from some specified temporaries) in which case the register allocator doesn't
 ; not need to spill all live registers around the call site.
 ; (4) The call does not occur at an INVOKE* bytecode. Such a call could be transformed into a
 ; standard Java call if the foreign routine is a normal Java method and the runtime supports
 ; linking Java calls at arbitrary bytecodes.
 ;;
(class-ns ForeignCallDescriptor []
    (defn #_"ForeignCallDescriptor" ForeignCallDescriptor'new-2* [#_"Class" resultType & #_"Class..." argumentTypes]
        (merge (ForeignCallDescriptor'class.)
            (hash-map
                #_"Class" :resultType resultType
                #_"Class*" :argumentTypes argumentTypes
            )
        )
    )

    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'DEOPTIMIZATION_HANDLER (ForeignCallDescriptor'new-2* void'class))
    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER  (ForeignCallDescriptor'new-2* void'class))

    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'NEW_INSTANCE (ForeignCallDescriptor'new-2* void'class, Word'iface, #_"KlassPointer" Word'iface))
    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'NEW_ARRAY    (ForeignCallDescriptor'new-2* void'class, Word'iface, #_"KlassPointer" Word'iface, int'class))

    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'MONITORENTER (ForeignCallDescriptor'new-2* void'class, Word'iface, Object, Word'iface))
    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'MONITOREXIT  (ForeignCallDescriptor'new-2* void'class, Word'iface, Object, Word'iface))

    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'G1WBPRECALL  (ForeignCallDescriptor'new-2* void'class, Word'iface, Object))
    (def #_"ForeignCallDescriptor" ForeignCallDescriptor'G1WBPOSTCALL (ForeignCallDescriptor'new-2* void'class, Word'iface, Word'iface))
)

;;;
 ; The runtime specific details of a foreign call.
 ;;
(class-ns ForeignCallLinkage [#_"InvokeTarget"]
    (defn #_"ForeignCallLinkage" ForeignCallLinkage'new-8* [#_"ForeignCallDescriptor" descriptor, #_"long" address, #_"RegisterEffect" effect, #_"Transition" transition, #_"CallingConvention" outgoingCallingConvention, #_"CallingConvention" incomingCallingConvention, #_"boolean" reexecutable & #_"LocationIdentity..." killedLocations]
        (merge (ForeignCallLinkage'class.)
            (hash-map
                ;;;
                 ; The descriptor of the call.
                 ;;
                #_"ForeignCallDescriptor" :descriptor descriptor
                #_"long" :address address
                #_"RegisterEffect" :effect effect
                #_"Transition" :transition transition
                ;;;
                 ; The calling convention for this call.
                 ; The details of where parameters are passed and value(s) are returned from the caller's perspective.
                 ;;
                #_"CallingConvention" :outgoingCallingConvention outgoingCallingConvention
                ;;;
                 ; The calling convention for incoming arguments to the stub, iff this call uses a compiled stub.
                 ; The details of where parameters are passed and value(s) are returned from the callee's perspective.
                 ;;
                #_"CallingConvention" :incomingCallingConvention (or incomingCallingConvention outgoingCallingConvention)
                #_"boolean" :reexecutable reexecutable
                ;;;
                 ; The memory locations killed by the call.
                 ;;
                #_"LocationIdentity[]" :killedLocations killedLocations
                ;;;
                 ; The registers and stack slots defined/killed by the call.
                 ;;
                #_"Value[]" :temporaries AllocatableValue/NONE
            )
        )
    )

    ;;;
     ; Creates a ForeignCallLinkage.
     ;
     ; @param descriptor the descriptor of the call
     ; @param address the address of the code to call
     ; @param effect specifies if the call destroys or preserves all registers (apart from temporaries which are always destroyed)
     ; @param outgoingCcType outgoing (caller) calling convention type
     ; @param incomingCcType incoming (callee) calling convention type (can be nil)
     ; @param transition specifies if this is a {@linkplain #needsDebugInfo() leaf} call
     ; @param reexecutable specifies if the call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a call that cannot be re-executed.
     ; @param killedLocations the memory locations killed by the call
     ;;
    (defn #_"ForeignCallLinkage" ForeignCallLinkage'create-8* [#_"ForeignCallDescriptor" descriptor, #_"long" address, #_"RegisterEffect" effect, #_"CallingConvention$Type" outgoingCcType, #_"CallingConvention$Type" incomingCcType, #_"Transition" transition, #_"boolean" reexecutable & #_"LocationIdentity..." killedLocations]
        (let [
            #_"CallingConvention" outgoingCc (ForeignCallLinkage'createCallingConvention-2 descriptor, outgoingCcType)
            #_"CallingConvention" incomingCc (when (some? incomingCcType) (ForeignCallLinkage'createCallingConvention-2 descriptor, incomingCcType))
            #_"ForeignCallLinkage" linkage (apply ForeignCallLinkage'new-8* descriptor, address, effect, transition, outgoingCc, incomingCc, reexecutable, killedLocations)
        ]
            (when (= outgoingCcType HotSpotCallingConventionType/NativeCall) => linkage
                (assoc linkage :temporaries ForeignCalls'nativeABICallerSaveRegisters)
            )
        )
    )

    (defn- #_"JavaType" ForeignCallLinkage'asJavaType-1 [#_"Class" type]
        (let [
            #_"ResolvedJavaType" javaType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, type)
        ]
            (when (WordTypes'isWord-1j javaType) => javaType
                (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (#_"JavaKind" .toJavaClass WordTypes'wordKind))
            )
        )
    )

    ;;;
     ; Gets a calling convention for a given descriptor and call type.
     ;;
    (defn #_"CallingConvention" ForeignCallLinkage'createCallingConvention-2 [#_"ForeignCallDescriptor" descriptor, #_"CallingConvention$Type" ccType]
        (let [
            #_"JavaType[]" parameterTypes (make-array JavaType (count (:argumentTypes descriptor)))
            _
                (dotimes [#_"int" i (count parameterTypes)]
                    (aset parameterTypes i (ForeignCallLinkage'asJavaType-1 (nth (:argumentTypes descriptor) i)))
                )
            #_"JavaType" returnType (ForeignCallLinkage'asJavaType-1 (:resultType descriptor))
        ]
            (#_"RegisterConfig" .getCallingConvention HotSpot'registerConfig, ccType, returnType, parameterTypes, HotSpot'valueKindFactory)
        )
    )

    ;;;
     ; Identifies foreign calls which are guaranteed to include a safepoint check.
     ;;
    (defn #_"boolean" ForeignCallLinkage''isGuaranteedSafepoint-1 [#_"ForeignCallLinkage" this]
        (= (:transition this) Transition'SAFEPOINT)
    )

    ;;;
     ; Returns the maximum absolute offset of a PC relative call to this stub from any position in the code cache
     ; or -1 when not applicable. Intended for determining the required size of address/offset fields.
     ;;
    (defn #_"long" ForeignCallLinkage''getMaxCallTargetOffset-1 [#_"ForeignCallLinkage" this]
        (#_"CodeCacheProvider" .getMaxCallTargetOffset HotSpot'codeCache, (:address this))
    )

    ;;;
     ; Determines if the foreign call target destroys all registers.
     ;
     ; @return true if the register allocator must save all live registers around a call to this target
     ;;
    (defn #_"boolean" ForeignCallLinkage''destroysRegisters-1 [#_"ForeignCallLinkage" this]
        (= (:effect this) RegisterEffect'DESTROYS_REGISTERS)
    )

    ;;;
     ; Determines if a JavaFrameAnchor needs to be set up and torn down around this call.
     ;;
    (defn #_"boolean" ForeignCallLinkage''needsJavaFrameAnchor-1 [#_"ForeignCallLinkage" this]
        (any = (:transition this) Transition'SAFEPOINT Transition'STACK_INSPECTABLE_LEAF)
    )
)

;;;
 ; Details about a set of supported {@link ForeignCallDescriptor foreign calls}.
 ;;
(class-ns ForeignCalls []
    ;;;
     ; System V Application Binary Interface, AMD64 Architecture Processor Supplement, Draft Version 0.96, 3.2.1
     ;
     ; http://www.uclibc.org/docs/psABI-x86_64.pdf
     ;
     ; "This subsection discusses usage of each register. Registers %rbp, %rbx and %r12 through %r15 "belong" to the calling
     ; function and the called function is required to preserve their values. In other words, a called function must preserve
     ; these registers' values for its caller. Remaining registers "belong" to the called function. If a calling function
     ; wants to preserve such a register value across a function call, it must save the value in its local stack frame."
     ;;
    (defn- #_"Value[]" ForeignCalls'createNativeABICallerSaveRegisters-0 []
        (let [
            #_"List<Register>" registers (#_"RegisterArray" .asList (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))
        ]
            (into-array Value (map #(#_"Register" .asValue %) (remove #{ AMD64/rbp, AMD64/rbx, AMD64/r12, AMD64/r13, AMD64/r14, AMD64/r15 } registers)))
        )
    )

    ;;;
     ; Registers that must be saved across a foreign call into the runtime.
     ;;
    (def #_"Value[]" ForeignCalls'nativeABICallerSaveRegisters (ForeignCalls'createNativeABICallerSaveRegisters-0))

    ;;;
     ; Creates and registers the linkage for a foreign call.
     ;
     ; @param descriptor the signature of the foreign call
     ; @param address the address of the foreign code to call
     ; @param effect specifies if the call destroys or preserves all registers (apart from temporaries which are always destroyed)
     ; @param transition specifies if this is a {@linkplain Transition#LEAF leaf} call
     ; @param reexecutable specifies if the foreign call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a foreign call that cannot be re-executed.
     ; @param killedLocations the memory locations killed by the foreign call
     ;;
    (defn- #_"this" ForeignCalls''register-7* [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor, #_"long" address, #_"RegisterEffect" effect, #_"Transition" transition, #_"boolean" reexecutable & #_"LocationIdentity..." killedLocations]
        (let [
            #_"CallingConvention" callingConvention HotSpotCallingConventionType/NativeCall
            #_"ForeignCallLinkage" linkage (apply ForeignCallLinkage'create-8* descriptor, address, effect, callingConvention, nil, transition, reexecutable, killedLocations)
        ]
            (update this :foreignCalls assoc (:descriptor linkage) linkage)
        )
    )

    (defn #_"ForeignCalls" ForeignCalls'new-0 []
        (let [
            #_"ForeignCalls" this
                (merge (ForeignCalls'class.)
                    (hash-map
                        #_"{ForeignCallDescriptor ForeignCallLinkage}" :foreignCalls {}
                    )
                )
        ]
            (reduce #(apply ForeignCalls''register-7* %1, %2) this
                [
                    [ForeignCallDescriptor'DEOPTIMIZATION_HANDLER HotSpot'handleDeoptStub  RegisterEffect'PRESERVES_REGISTERS Transition'LEAF_NOFP true]
                    [ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER  HotSpot'uncommonTrapStub RegisterEffect'PRESERVES_REGISTERS Transition'LEAF_NOFP true]

                    [ForeignCallDescriptor'NEW_INSTANCE HotSpot'newInstanceAddress RegisterEffect'DESTROYS_REGISTERS Transition'SAFEPOINT true LocationIdentity'ANY]
                    [ForeignCallDescriptor'NEW_ARRAY    HotSpot'newArrayAddress    RegisterEffect'DESTROYS_REGISTERS Transition'SAFEPOINT true LocationIdentity'ANY]

                    [ForeignCallDescriptor'MONITORENTER HotSpot'monitorenterAddress RegisterEffect'DESTROYS_REGISTERS Transition'SAFEPOINT              false LocationIdentity'ANY]
                    [ForeignCallDescriptor'MONITOREXIT  HotSpot'monitorexitAddress  RegisterEffect'DESTROYS_REGISTERS Transition'STACK_INSPECTABLE_LEAF false LocationIdentity'ANY]

                    [ForeignCallDescriptor'G1WBPRECALL  HotSpot'writeBarrierPreAddress  RegisterEffect'DESTROYS_REGISTERS Transition'LEAF_NOFP true]
                    [ForeignCallDescriptor'G1WBPOSTCALL HotSpot'writeBarrierPostAddress RegisterEffect'DESTROYS_REGISTERS Transition'LEAF_NOFP true]
                ]
            )
        )
    )

    ;;;
     ; Gets the linkage for a foreign call.
     ;;
    (defn #_"ForeignCallLinkage" ForeignCalls''lookupForeignCall-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (get (:foreignCalls this) descriptor)
    )

    ;;;
     ; Determines if a given foreign call is side-effect free. Deoptimization cannot return
     ; execution to a point before a foreign call that has a side effect.
     ;;
    #_unused
    (defn #_"boolean" ForeignCalls''isReexecutable-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (:reexecutable (get (:foreignCalls this) descriptor))
    )

    ;;;
     ; Identifies foreign calls which are guaranteed to include a safepoint check.
     ;;
    #_unused
    (defn #_"boolean" ForeignCalls''isGuaranteedSafepoint-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (ForeignCallLinkage''isGuaranteedSafepoint-1 (get (:foreignCalls this) descriptor))
    )

    ;;;
     ; Gets the set of memory locations killed by a given foreign call. Returning the special
     ; value LocationIdentity#any() denotes that the call kills all memory locations.
     ; Returning any empty array denotes that the call does not kill any memory locations.
     ;;
    (defn #_"LocationIdentity[]" ForeignCalls''getKilledLocations-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (:killedLocations (get (:foreignCalls this) descriptor))
    )
)

;;;
 ; Code for managing a method's native frame.
 ; Emits code at the verified entry point and return point(s) of a method.
 ;;
(class-ns FrameContext []
    ;;;
     ; The size of the instruction used to patch the verified entry point of an nmethod when the
     ; nmethod is made non-entrant or a zombie (e.g. during deopt or class unloading). The first
     ; instruction emitted at an nmethod's verified entry point must be at least this length to
     ; ensure mt-safe patching.
     ;;
    (def #_"int" FrameContext'PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE 5)

    (defn #_"FrameContext" FrameContext'new-1 [#_"boolean" omitFrame]
        (merge (FrameContext'class.)
            (hash-map
                #_"boolean" :omitFrame omitFrame
            )
        )
    )

    ;;;
     ; Emits code common to all entry points of a method. This may include:
     ;
     ; - setting up the stack frame
     ; - saving callee-saved registers
     ; - stack overflow checking
     ;;
    (defn #_"void" FrameContext''enter-2 [#_"FrameContext" this, #_"Assembler" asm]
        (if (:omitFrame this)
            (Assembler''nop-2 asm, FrameContext'PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE)
            (let [
                #_"int" verifiedEntryPosition (Assembler''position-1 asm)
                #_"int" frameSize (:frameSize (:frameMap asm))
            ]
                (Compiler'emitStackOverflowCheck-1 asm)
                (if (= (Assembler''position-1 asm) verifiedEntryPosition)
                    (Assembler''subqWide-3 asm, AMD64/rsp, frameSize)
                    (Assembler''decrementq-3r asm, AMD64/rsp, frameSize)
                )
                (when GraalOptions'zapStackOnMethodEntry
                    (let [
                        #_"int" intSize 4
                    ]
                        (dotimes [#_"int" i (quot frameSize intSize)]
                            (Assembler''movl-3ai asm, (AMD64Address'new-2 AMD64/rsp, (* i intSize)), 0xc1c1c1c1)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Emits code to be executed just prior to returning from a method. This may include:
     ;
     ; - restoring callee-saved registers
     ; - performing a safepoint
     ; - destroying the stack frame
     ;;
    (defn #_"void" FrameContext''leave-2 [#_"FrameContext" this, #_"Assembler" asm]
        (when-not (:omitFrame this)
            (Assembler''incrementq-3r asm, AMD64/rsp, (:frameSize (:frameMap asm)))
        )
        nil
    )
)

;;;
 ; A FrameMapBuilder is used to collect all information necessary to {@linkplain #buildFrameMap create} a FrameMap.
 ;;
(class-ns FrameMapBuilder []
    (defn #_"FrameMapBuilder" FrameMapBuilder'new-0 []
        (merge (FrameMapBuilder'class.)
            (hash-map
                #_"FrameMap" :frameMap (FrameMap'new-0)
                #_"List<VirtualStackSlot>" :stackSlots (ArrayList.)
                #_"List<CallingConvention>" :calls (ArrayList.)
                ;;;
                 ; The number of VirtualStackSlots created by this FrameMapBuilder.
                 ; Can be used as an upper bound for an array indexed by VirtualStackSlot#getId().
                 ;;
                #_"int" :numStackSlots 0
            )
        )
    )

    ;;;
     ; Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
     ; on its natural alignment, i.e. an 8-byte spill slot is aligned at an 8-byte boundary, unless
     ; overridden by a subclass.
     ;
     ; @param kind The kind of the spill slot to be reserved.
     ; @return a spill slot denoting the reserved memory area
     ;;
    (defn #_"VirtualStackSlot" FrameMapBuilder''allocateSpillSlot-2 [#_"FrameMapBuilder" this, #_"ValueKind" kind]
        (let [
            #_"VirtualStackSlot" slot (VirtualStackSlot'new-2 (:numStackSlots this), kind)
        ]
            (ยง ass! this (update this :numStackSlots inc))
            (#_"List" .add (:stackSlots this), slot)
            slot
        )
    )

    ;;;
     ; Informs the frame map that the compiled code calls a particular method, which may need stack
     ; space for outgoing arguments.
     ;
     ; @param cc The calling convention for the called method.
     ;;
    (defn #_"this" FrameMapBuilder''callsMethod-2 [#_"FrameMapBuilder" this, #_"CallingConvention" cc]
        (#_"List" .add (:calls this), cc)
        this
    )

    ;;;
     ; Creates a FrameMap based on the information collected by this FrameMapBuilder.
     ;;
    (defn #_"FrameMap" FrameMapBuilder''buildFrameMap-2 [#_"FrameMapBuilder" this, #_"LIRGenerationResult" res]
        (doseq [#_"CallingConvention" cc (:calls this)]
            (FrameMap''callsMethod-2 (:frameMap this), cc)
        )
        (ยง ass! (:frameMap this) (FrameMap''finish-1 (:frameMap this)))
        (:frameMap this)
    )

    ;;;
     ; For non-leaf methods, RBP is preserved in the special stack slot required by the HotSpot
     ; runtime for walking/inspecting frames of such methods.
     ;;
    (defn #_"StackSlot" FrameMapBuilder''allocateRBPSpillSlot-1 [#_"FrameMapBuilder" this]
        (FrameMap''allocateRBPSpillSlot-1 (:frameMap this))
    )

    (defn #_"this" FrameMapBuilder''freeRBPSpillSlot-1 [#_"FrameMapBuilder" this]
        (ยง ass! (:frameMap this) (FrameMap''freeRBPSpillSlot-1 (:frameMap this)))
        this
    )
)

;;;
 ; This class is used to build the stack frame layout for a compiled method. A StackSlot is used to index slots of the frame
 ; relative to the stack pointer. The frame size is only fixed after register allocation when all spill slots have been allocated.
 ; Both the outgoing argument area and the spill are can grow until then. Therefore, outgoing arguments are indexed from the
 ; stack pointer, while spill slots are indexed from the beginning of the frame (and the total frame size has to be added to get
 ; the actual offset from the stack pointer).
 ;
 ; This is the format of an AMD64 stack frame:
 ;
 ;   Base       Contents
 ;
 ;            :                                :  -----
 ;   caller   | incoming overflow argument n   |    ^
 ;   frame    :     ...                        :    | positive
 ;            | incoming overflow argument 0   |    | offsets
 ;   ---------+--------------------------------+---------------------
 ;            | return address                 |    |            ^
 ;   current  +--------------------------------+    |            |    -----
 ;   frame    |                                |    |            |      ^
 ;            : callee save area               :    |            |      |
 ;            |                                |    |            |      |
 ;            +--------------------------------+    |            |      |
 ;            | spill slot 0                   |    | negative   |      |
 ;            :     ...                        :    v offsets    |      |
 ;            | spill slot n                   |  -----        total  frame
 ;            +--------------------------------+               frame  size
 ;            | alignment padding              |               size     |
 ;            +--------------------------------+  -----          |      |
 ;            | outgoing overflow argument n   |    ^            |      |
 ;            :     ...                        :    | positive   |      |
 ;            | outgoing overflow argument 0   |    | offsets    v      v
 ;    %sp-->  +--------------------------------+---------------------------
 ;
 ; The spill slot area also includes stack allocated memory blocks (ALLOCA blocks). The size of such a block may be greater than
 ; the size of a normal spill slot or the word size.
 ;
 ; A runtime can reserve space at the beginning of the overflow argument area. The calling convention can specify that the first
 ; overflow stack argument is not at offset 0, but at a specified offset. Use CodeCacheProvider#getMinimumOutgoingSize() to make sure
 ; that call-free methods also have this space reserved. Then the VM can use the memory at offset 0 relative to the stack pointer.
 ;;
(class-ns FrameMap []
    (def #_"int" FrameMap'RETURN_ADDRESS_SIZE (#_"Architecture" .getReturnAddressSize (.arch HotSpot'target)))

    (defn #_"FrameMap" FrameMap'new-0 []
        (merge (FrameMap'class.)
            (hash-map
                ;;;
                 ; The final frame size, not including the size of the {@link Architecture#getReturnAddressSize() return address slot}.
                 ; The value is only set after register allocation is complete, i.e. after all spill slots have been allocated.
                 ;;
                #_"int" :frameSize -1
                ;;;
                 ; Initial size of the area occupied by spill slots and other stack-allocated memory blocks.
                 ;;
                #_"int" :initialSpillSize FrameMap'RETURN_ADDRESS_SIZE
                ;;;
                 ; Size of the area occupied by spill slots and other stack-allocated memory blocks.
                 ;;
                #_"int" :spillSize FrameMap'RETURN_ADDRESS_SIZE
                ;;;
                 ; Size of the area occupied by outgoing overflow arguments. This value is adjusted as calling conventions for outgoing
                 ; calls are retrieved. On some platforms, there is a minimum outgoing size even if no overflow arguments are on the stack.
                 ;;
                #_"int" :outgoingSize (#_"CodeCacheProvider" .getMinimumOutgoingSize HotSpot'codeCache)
                ;;;
                 ; Determines if this frame has values on the stack for outgoing calls.
                 ;;
                #_"boolean" :hasOutgoingStackArguments false
                ;;;
                 ; The list of stack slots allocated in this frame that are present in every reference map.
                 ;;
                #_"List<StackSlot>" :objectStackSlots (ArrayList.)
                ;;;
                 ; For non-leaf methods, RBP is preserved in the special stack slot required by the HotSpot
                 ; runtime for walking/inspecting frames of such methods.
                 ;;
                #_"StackSlot" :rbpSpillSlot nil
            )
        )
    )

    ;;;
     ; Determines if any space is used in the frame apart from the {@link Architecture#getReturnAddressSize() return address slot}.
     ;;
    (defn #_"boolean" FrameMap''frameNeedsAllocating-1 [#_"FrameMap" this]
        (or (:hasOutgoingStackArguments this) (< FrameMap'RETURN_ADDRESS_SIZE (:spillSize this)))
    )

    ;;;
     ; Gets the total frame size of the compiled frame, including the size of the {@link Architecture#getReturnAddressSize() return address slot}.
     ;;
    (defn #_"int" FrameMap''totalFrameSize-1 [#_"FrameMap" this]
        (+ (:frameSize this) FrameMap'RETURN_ADDRESS_SIZE)
    )

    ;;;
     ; Aligns the given frame size to the stack alignment size and return the aligned size.
     ;;
    (defn- #_"int" FrameMap'alignFrameSize-1 [#_"int" size]
        (- (NumUtil'roundUp-2i (+ size FrameMap'RETURN_ADDRESS_SIZE), (.stackAlignment HotSpot'target)) FrameMap'RETURN_ADDRESS_SIZE)
    )

    ;;;
     ; Gets the current size of this frame. This is the size that would be returned by #frameSize() if #finish() were called now.
     ;;
    (defn #_"int" FrameMap''currentFrameSize-1 [#_"FrameMap" this]
        (FrameMap'alignFrameSize-1 (- (+ (:outgoingSize this) (:spillSize this)) FrameMap'RETURN_ADDRESS_SIZE))
    )

    ;;;
     ; Computes the final size of this frame. After this method has been called, methods that change the frame size cannot be called anymore,
     ; e.g. no more spill slots or outgoing arguments can be requested.
     ;;
    (defn #_"this" FrameMap''finish-1 [#_"FrameMap" this]
        (let [
            this (assoc this :frameSize (FrameMap''currentFrameSize-1 this))
        ]
            (when (< (#_"RegisterConfig" .getMaximumFrameSize HotSpot'registerConfig) (:frameSize this))
                (throw! (str "frame size (" (:frameSize this) ") exceeded maximum allowed frame size (" (#_"RegisterConfig" .getMaximumFrameSize HotSpot'registerConfig) ")"))
            )
            this
        )
    )

    ;;;
     ; Computes the offset of a stack slot relative to the frame register.
     ;;
    (defn #_"int" FrameMap''offsetForStackSlot-2 [#_"FrameMap" this, #_"StackSlot" slot]
        (#_"StackSlot" .getOffset slot, (FrameMap''totalFrameSize-1 this))
    )

    ;;;
     ; Informs the frame map that the compiled code calls a particular method, which may need stack space for outgoing arguments.
     ;;
    (defn #_"void" FrameMap''callsMethod-2 [#_"FrameMap" this, #_"CallingConvention" cc]
        (ยง ass! this (FrameMap''reserveOutgoing-2 this, (#_"CallingConvention" .getStackSize cc)))
        nil
    )

    ;;;
     ; Reserves space for stack-based outgoing arguments.
     ;
     ; @param argsSize The amount of space (in bytes) to reserve for stack-based outgoing arguments.
     ;;
    (defn #_"this" FrameMap''reserveOutgoing-2 [#_"FrameMap" this, #_"int" argsSize]
        (let [
            this (assoc this :outgoingSize (max (:outgoingSize this) argsSize))
            this (assoc this :hasOutgoingStackArguments (or (:hasOutgoingStackArguments this) (pos? argsSize)))
        ]
            this
        )
    )

    ;;;
     ; Reserves a new spill slot in the frame of the method being compiled. The returned slot is
     ; aligned on its natural alignment, i.e. an 8-byte spill slot is aligned at an 8-byte boundary.
     ;
     ; @param kind The kind of the spill slot to be reserved.
     ; @return a spill slot denoting the reserved memory area
     ;;
    (defn #_"StackSlot" FrameMap''allocateNewSpillSlot-3 [#_"FrameMap" this, #_"ValueKind" kind, #_"int" additionalOffset]
        (StackSlot/get kind, (+ (- (:spillSize this)) additionalOffset), true)
    )

    ;;;
     ; Returns the spill slot size for the given ValueKind. The default value is the size in
     ; bytes for the target architecture.
     ;
     ; @param kind The ValueKind to be stored in the spill slot.
     ; @return the size in bytes
     ;;
    (defn #_"int" FrameMap'spillSlotSize-1 [#_"ValueKind" kind]
        (#_"PlatformKind" .getSizeInBytes (#_"ValueKind" .getPlatformKind kind))
    )

    ;;;
     ; Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
     ; on its natural alignment, i.e. an 8-byte spill slot is aligned at an 8-byte boundary, unless
     ; overridden by a subclass.
     ;
     ; @param kind The kind of the spill slot to be reserved.
     ; @return a spill slot denoting the reserved memory area
     ;;
    (defn #_"StackSlot" FrameMap''allocateSpillSlot-2 [#_"FrameMap" this, #_"ValueKind" kind]
        (let [
            #_"int" size (FrameMap'spillSlotSize-1 kind)
        ]
            (ยง ass! this (assoc this :spillSize (NumUtil'roundUp-2i (+ (:spillSize this) size), size)))
            (FrameMap''allocateNewSpillSlot-3 this, kind, 0)
        )
    )

    ;;;
     ; Reserves a number of contiguous slots in the frame of the method being compiled. If the
     ; requested number of slots is 0, this method returns nil.
     ;
     ; @param n the number of slots to reserve
     ; @param objects specifies the indexes of the object pointer slots. The caller is responsible
     ;            for guaranteeing that each such object pointer slot is initialized before any
     ;            instruction that uses a reference map. Without this guarantee, the garbage
     ;            collector could see garbage object values.
     ; @return the first reserved stack slot (i.e. at the lowest address)
     ;;
    #_unused
    (defn #_"StackSlot" FrameMap''allocateStackSlots-3 [#_"FrameMap" this, #_"int" n, #_"BitSet" objects]
        (when (pos? n)
            (let [
                #_"int" wordSize (.wordSize HotSpot'target)
                #_"PlatformKind" wordKind (#_"Architecture" .getWordKind (.arch HotSpot'target))
            ]
                (ยง ass! this (assoc this :spillSize (+ (:spillSize this) (* n wordSize))))

                (when-not (#_"BitSet" .isEmpty objects) => (FrameMap''allocateNewSpillSlot-3 this, (LIRKind'value-1 wordKind), 0)
                    (loop-when [#_"StackSlot" slot nil #_"int" i 0] (< i n) => slot
                        (let [
                            #_"StackSlot" objectSlot
                                (when (#_"BitSet" .get objects, i)
                                    (let [
                                        objectSlot (FrameMap''allocateNewSpillSlot-3 this, (LIRKind'reference-1 wordKind), (* i wordSize))
                                    ]
                                        (#_"List" .add (:objectStackSlots this), objectSlot)
                                        objectSlot
                                    )
                                )
                            slot
                                (when (zero? i) => slot
                                    (or objectSlot
                                        (FrameMap''allocateNewSpillSlot-3 this, (LIRKind'value-1 wordKind), 0)
                                    )
                                )
                        ]
                            (recur slot (inc i))
                        )
                    )
                )
            )
        )
    )

    (defn #_"StackSlot" FrameMap''allocateRBPSpillSlot-1 [#_"FrameMap" this]
        (ยง ass! this (assoc this :rbpSpillSlot (FrameMap''allocateSpillSlot-2 this, (LIRKind'value-1 AMD64Kind/QWORD))))
        (:rbpSpillSlot this)
    )

    (defn #_"FrameMap" FrameMap''freeRBPSpillSlot-1 [#_"FrameMap" this]
        (assoc this :spillSize (:initialSpillSize this))
    )
)

;;;
 ; This phase transfers FrameState nodes from StateSplit nodes to DeoptimizingNodes.
 ;
 ; This allow to enter the {@link GuardsStage#AFTER_FSA AFTER_FSA} stage of the graph where
 ; no new node that may cause deoptimization can be introduced anymore.
 ;
 ; This Phase processes the graph in post order, assigning the FrameState from the last
 ; StateSplit node to DeoptimizingNodes.
 ;;
(class-ns FrameStateAssignmentPhase [Phase]
    (defn #_"FrameStateAssignmentPhase" FrameStateAssignmentPhase'new-0 []
        (FrameStateAssignmentPhase'class.)
    )

    (defm FrameStateAssignmentPhase Phase
        (#_"Graph" Phase'''run-3 [#_"FrameStateAssignmentPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (GuardsStage'areFrameStatesAtSideEffects-1 (:guardsStage graph)) => graph
                (ReentrantNodeIterator'apply-3 (FrameStateAssignmentClosure'new-0), (:start graph), nil)
                (let [
                    graph (Graph''setGuardsStage-2 graph, GuardsStage'AFTER_FSA)
                ]
                    (doseq [#_"Node" node (filter Node''hasNoUsages-1 (Graph''getNodes-2 graph, FrameState))]
                        (ร GraphUtil'killWithUnusedFloatingInputs node)
                    )
                    graph
                )
            )
        )
    )
)

(class-ns FrameStateBuilder [SideEffectsState]
    (defn- #_"FrameStateBuilder" FrameStateBuilder'init-0 []
        (hash-map
            #_"BytecodeParser" :parser nil
            #_"Bytecode" :code nil
            ;;;
             ; Current size (height) of the stack.
             ;;
            #_"int" :stackSize 0
            #_"ValueNode[]" :locals nil
            #_"ValueNode[]" :stack nil
            #_"ValueNode[]" :lockedObjects nil
            #_"MonitorIdNode[]" :monitorIds nil
            #_"Graph" :graph nil
            #_"FrameState" :outerFrameState nil
            ;;;
             ; The closest {@link StateSplit#hasSideEffect() side-effect} predecessors. There will be more
             ; than one when the current block contains no side-effects but merging predecessor blocks do.
             ;;
            #_"List<StateSplit>" :sideEffects nil
        )
    )

    ;;;
     ; Creates a new frame state builder for the given code attribute, method and the given target graph.
     ;
     ; @param code the bytecode in which the frame exists
     ; @param graph the target graph of Graal nodes created by the builder
     ;;
    (defn #_"FrameStateBuilder" FrameStateBuilder'new-3c [#_"BytecodeParser" parser, #_"Bytecode" code, #_"Graph" graph]
        (let [
            #_"FrameStateBuilder" this
                (merge (FrameStateBuilder'class.)
                    (FrameStateBuilder'init-0)
                )
            this (assoc this :parser parser)
            this (assoc this :code code)
            this (assoc this :locals (make-array ValueNode'iface (Bytecode'''getMaxLocals-1 code)))
            this (assoc this :stack (make-array ValueNode'iface (max 1 (Bytecode'''getMaxStackSize-1 code))))
            this (assoc this :lockedObjects (make-array ValueNode'iface 0))
            this (assoc this :monitorIds (make-array MonitorIdNode'iface 0))
            this (assoc this :graph graph)
        ]
            this
        )
    )

    ;;;
     ; Creates a new frame state builder for the given method and the given target graph.
     ;
     ; @param method the method whose frame is simulated
     ; @param graph the target graph of Graal nodes created by the builder
     ;;
    #_unused
    (defn #_"FrameStateBuilder" FrameStateBuilder'new-3m [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"Graph" graph]
        (FrameStateBuilder'new-3c parser, (ResolvedJavaMethodBytecode'new-1 method), graph)
    )

    (defn #_"FrameStateBuilder" FrameStateBuilder'copy-1 [#_"FrameStateBuilder" other]
        (let [
            #_"FrameStateBuilder" this
                (merge (FrameStateBuilder'class.)
                    (FrameStateBuilder'init-0)
                )
            this (assoc this :parser (:parser other))
            this (assoc this :code (:code other))
            this (assoc this :stackSize (:stackSize other))
            this (assoc this :locals (#_"Object" .clone (:locals other)))
            this (assoc this :stack (#_"Object" .clone (:stack other)))
            this (assoc this :lockedObjects (#_"Object" .clone (:lockedObjects other)))
            this (assoc this :graph (:graph other))
            this (assoc this :monitorIds (#_"Object" .clone (:monitorIds other)))
        ]
            this
        )
    )

    (defn #_"void" FrameStateBuilder''initializeFromArgumentsArray-2 [#_"FrameStateBuilder" this, #_"ValueNode*" arguments]
        (let [
            #_"ResolvedJavaMethod" method (FrameStateBuilder''getMethod-1 this)
            [#_"int" i #_"int" j]
                (when-not (#_"ResolvedJavaMethod" .isStatic method) => [0 0]
                    ;; set the receiver
                    (aset (:locals this) 0 (nth arguments 0))
                    [1 1]
                )
            #_"Signature" sig (#_"ResolvedJavaMethod" .getSignature method)
        ]
            (loop-when [i i j j #_"int" k 0] (< k (#_"Signature" .getParameterCount sig, false))
                (aset (:locals this) j (nth arguments i))
                (let [
                    j (inc j)
                    j
                        (when (#_"JavaKind" .needsTwoSlots (#_"Signature" .getParameterKind sig, k)) => j
                            (aset (:locals this) j FrameState'TWO_SLOT_MARKER)
                            (inc j)
                        )
                ]
                    (recur (inc i) j (inc k))
                )
            )
        )
        nil
    )

    (defn #_"void" FrameStateBuilder''initializeForMethodStart-1 [#_"FrameStateBuilder" this]
        (let [
            #_"ResolvedJavaMethod" method (FrameStateBuilder''getMethod-1 this)
            #_"ResolvedJavaType" originalType (#_"ResolvedJavaMethod" .getDeclaringClass method)
            [#_"int" i #_"int" j]
                (when-not (#_"ResolvedJavaMethod" .isStatic method) => [0 0]
                    (let [
                        #_"Stamp" receiverStamp
                            (or (Plugins''getOverridingStamp-4 HotSpot'plugins, (:parser this), originalType, true)
                                (StampFactory'forDeclaredType-2 originalType, true)
                            )
                    ]
                        (aset (:locals this) 0 (Graph''addOrUniqueWithInputs-2 (:graph this), (ParameterNode'new-2 0, receiverStamp)))
                        [1 1]
                    )
                )
            #_"Signature" sig (#_"ResolvedJavaMethod" .getSignature method)
        ]
            (loop-when [i i j j #_"int" k 0] (< k (#_"Signature" .getParameterCount sig, false))
                (let [
                    #_"JavaType" type (#_"JavaType" .resolve (#_"Signature" .getParameterType sig, k, originalType), originalType)
                    #_"JavaKind" kind (#_"JavaType" .getJavaKind type)
                    #_"Stamp" stamp
                        (or (Plugins''getOverridingStamp-4 HotSpot'plugins, (:parser this), type, false)
                            (StampFactory'forDeclaredType-2 type, false)
                        )
                ]
                    (aset (:locals this) j (Graph''addOrUniqueWithInputs-2 (:graph this), (ParameterNode'new-2 i, stamp)))
                    (let [
                        j (inc j)
                        j
                            (when (#_"JavaKind" .needsTwoSlots kind) => j
                                (aset (:locals this) j FrameState'TWO_SLOT_MARKER)
                                (inc j)
                            )
                    ]
                        (recur (inc i) j (inc k))
                    )
                )
            )
        )
        nil
    )

    (defn #_"ResolvedJavaMethod" FrameStateBuilder''getMethod-1 [#_"FrameStateBuilder" this]
        (Bytecode'''getMethod-1 (:code this))
    )

    (defn #_"FrameState" FrameStateBuilder''create-3 [#_"FrameStateBuilder" this, #_"int" bci, #_"StateSplit" forStateSplit]
        (if (and (some? (:parser this)) (BytecodeParser''parsingIntrinsic-1 (:parser this)))
            (IntrinsicContext'createFrameState-3 (:graph (:parser this)), this, forStateSplit)
            ;; skip intrinsic frames
            (FrameStateBuilder''create-6 this, bci, (when (some? (:parser this)) (BytecodeParser''getNonIntrinsicAncestor-1 (:parser this))), false, nil, nil)
        )
    )

    ;;;
     ; @param pushedValues if non-nil, values to #push(JavaKind, ValueNode) to the stack before creating the FrameState
     ;;
    (defn #_"FrameState" FrameStateBuilder''create-6 [#_"FrameStateBuilder" this, #_"int" bci, #_"BytecodeParser" parent, #_"boolean" duringCall, #_"JavaKind[]" pushedSlotKinds, #_"ValueNode[]" pushedValues]
        (when (and (nil? (:outerFrameState this)) (some? parent))
            (ยง ass! this (assoc this :outerFrameState (FrameStateBuilder''create-6 (:frameState parent), (BytecodeParser''bci-1 parent), (BytecodeParser''getNonIntrinsicAncestor-1 parent), true, nil, nil)))
        )
        (when-not (= bci BytecodeFrame/INVALID_FRAMESTATE_BCI) => (throw! "should not reach here")
            (if (some? pushedValues)
                (let [
                    #_"int" o'stackSize (:stackSize this)
                ]
                    (dotimes [#_"int" i (count pushedValues)]
                        (ยง ass! this (FrameStateBuilder''push-3 this, (nth pushedSlotKinds i), (nth pushedValues i)))
                    )
                    (let [
                        #_"FrameState" res (Graph''add-2 (:graph this), (FrameState'new-9a (:outerFrameState this), (:code this), bci, (:locals this), (:stack this), (:stackSize this), (:lockedObjects this), (Arrays/asList (:monitorIds this)), duringCall))
                    ]
                        (ยง ass! this (assoc this :stackSize o'stackSize))
                        res
                    )
                )
                (Graph''add-2 (:graph this), (FrameState'new-9a (:outerFrameState this), (:code this), bci, (:locals this), (:stack this), (:stackSize this), (:lockedObjects this), (Arrays/asList (:monitorIds this)), duringCall))
            )
        )
    )

    (defn #_"boolean" FrameStateBuilder''isCompatibleWith-2 [#_"FrameStateBuilder" this, #_"FrameStateBuilder" other]
        (and (= (:stackSize this) (:stackSize other))
            (loop [#_"int" i 0]
                (if (< i (:stackSize this))
                    (let [
                        #_"ValueNode" x (nth (:stack this) i)
                        #_"ValueNode" y (nth (:stack other) i)
                    ]
                        (if (and (not= x y) (or (= x FrameState'TWO_SLOT_MARKER) (Node''isDeleted-1 x) (= y FrameState'TWO_SLOT_MARKER) (Node''isDeleted-1 y) (not= (ValueNode''getStackKind-1 x) (ValueNode''getStackKind-1 y))))
                            false
                            (recur (inc i))
                        )
                    )
                    (and (= (count (:lockedObjects this)) (count (:lockedObjects other)))
                        (loop-when-recur [#_"int" i 0] (< i (count (:lockedObjects this))) [(inc i)] => true
                            (when (or (not= (GraphUtil'originalValue-1 (nth (:lockedObjects this) i)) (GraphUtil'originalValue-1 (nth (:lockedObjects other) i))) (not= (nth (:monitorIds this) i) (nth (:monitorIds other) i)))
                                (throw! "unbalanced monitors")
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"ValuePhiNode" FrameStateBuilder''createValuePhi-4 [#_"FrameStateBuilder" this, #_"ValueNode" currentValue, #_"ValueNode" otherValue, #_"AbstractMergeNode" block]
        (let [
            #_"ValuePhiNode" phi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 (Stamp'''unrestricted-1 (:stamp currentValue)), block))
        ]
            (dotimes [#_"int" i (AbstractMergeNode'''phiPredecessorCount-1 block)]
                (PhiNode''addInput-2 phi, currentValue)
            )
            (PhiNode''addInput-2 phi, otherValue)
            phi
        )
    )

    (defn- #_"ValueNode" FrameStateBuilder''merge-4 [#_"FrameStateBuilder" this, #_"ValueNode" currentValue, #_"ValueNode" otherValue, #_"AbstractMergeNode" block]
        (when (and (some? currentValue) (not (Node''isDeleted-1 currentValue)))
            (cond
                (AbstractMergeNode''isPhiAtMerge-2 block, currentValue)
                (do
                    (if (and (some? otherValue) (not= otherValue FrameState'TWO_SLOT_MARKER) (not (Node''isDeleted-1 otherValue)) (= (ValueNode''getStackKind-1 currentValue) (ValueNode''getStackKind-1 otherValue)))
                        (PhiNode''addInput-2 currentValue, otherValue)
                        ;; This phi must be dead anyway, add input of correct stack kind to keep the graph invariants.
                        (PhiNode''addInput-2 currentValue, (ConstantNode'defaultForKind-2 (ValueNode''getStackKind-1 currentValue), (:graph this)))
                    )
                    currentValue
                )
                (= currentValue otherValue)
                    currentValue
                (or (= currentValue FrameState'TWO_SLOT_MARKER) (= otherValue FrameState'TWO_SLOT_MARKER))
                    nil
                (and (some? otherValue) (not (Node''isDeleted-1 otherValue)) (= (ValueNode''getStackKind-1 currentValue) (ValueNode''getStackKind-1 otherValue)))
                    (FrameStateBuilder''createValuePhi-4 this, currentValue, otherValue, block)
            )
        )
    )

    (defn #_"this" FrameStateBuilder''merge-3 [#_"FrameStateBuilder" this, #_"AbstractMergeNode" block, #_"FrameStateBuilder" other]
        (dotimes [#_"int" i (count (:locals this))]
            (aset (:locals this) i (FrameStateBuilder''merge-4 this, (nth (:locals this) i), (nth (:locals other) i), block))
        )
        (dotimes [#_"int" i (:stackSize this)]
            (aset (:stack this) i (FrameStateBuilder''merge-4 this, (nth (:stack this) i), (nth (:stack other) i), block))
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (aset (:lockedObjects this) i (FrameStateBuilder''merge-4 this, (nth (:lockedObjects this) i), (nth (:lockedObjects other) i), block))
        )

        (when (some? (:sideEffects this)) => (assoc this :sideEffects (:sideEffects other))
            (when (some? (:sideEffects other))
                (#_"List" .addAll (:sideEffects this), (:sideEffects other))
            )
            this
        )
    )

    (defn- #_"void" FrameStateBuilder'inferPhiStamp-2 [#_"AbstractMergeNode" block, #_"ValueNode" node]
        (when (AbstractMergeNode''isPhiAtMerge-2 block, node)
            (ValueNode'''inferStamp-1 node)
        )
        nil
    )

    (defn #_"void" FrameStateBuilder''inferPhiStamps-2 [#_"FrameStateBuilder" this, #_"AbstractMergeNode" block]
        (dotimes [#_"int" i (count (:locals this))]
            (FrameStateBuilder'inferPhiStamp-2 block, (nth (:locals this) i))
        )
        (dotimes [#_"int" i (:stackSize this)]
            (FrameStateBuilder'inferPhiStamp-2 block, (nth (:stack this) i))
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (FrameStateBuilder'inferPhiStamp-2 block, (nth (:lockedObjects this) i))
        )
        nil
    )

    (defn- #_"ValueNode" FrameStateBuilder''createLoopPhi-4 [#_"FrameStateBuilder" this, #_"AbstractMergeNode" block, #_"ValueNode" value, #_"boolean" stampFromValue]
        (when (and (some? value) (not= value FrameState'TWO_SLOT_MARKER)) => value
            (let [
                #_"ValuePhiNode" phi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 (if stampFromValue (:stamp value) (Stamp'''unrestricted-1 (:stamp value))), block))
            ]
                (PhiNode''addInput-2 phi, value)
                phi
            )
        )
    )

    (defn #_"void" FrameStateBuilder''insertLoopPhis-6 [#_"FrameStateBuilder" this, #_"LocalLiveness" liveness, #_"int" loopId, #_"LoopBeginNode" loopBegin, #_"boolean" forcePhis, #_"boolean" stampFromValueForForcedPhis]
        (dotimes [#_"int" i (count (:locals this))]
            (let [
                #_"boolean" changedInLoop (LocalLiveness'''localIsChangedInLoop-3 liveness, loopId, i)
            ]
                (when (or forcePhis changedInLoop)
                    (aset (:locals this) i (FrameStateBuilder''createLoopPhi-4 this, loopBegin, (nth (:locals this) i), (and stampFromValueForForcedPhis (not changedInLoop))))
                )
            )
        )
        (dotimes [#_"int" i (:stackSize this)]
            (aset (:stack this) i (FrameStateBuilder''createLoopPhi-4 this, loopBegin, (nth (:stack this) i), false))
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (aset (:lockedObjects this) i (FrameStateBuilder''createLoopPhi-4 this, loopBegin, (nth (:lockedObjects this) i), false))
        )
        nil
    )

    (defn #_"void" FrameStateBuilder''insertLoopProxies-3 [#_"FrameStateBuilder" this, #_"LoopExitNode" loopExit, #_"FrameStateBuilder" loopEntryState]
        (dotimes [#_"int" i (count (:locals this))]
            (let [
                #_"ValueNode" value (nth (:locals this) i)
            ]
                (when (and (some? value) (not= value FrameState'TWO_SLOT_MARKER) (or (not (FrameStateBuilder''contains-2 loopEntryState, value)) (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)))
                    (aset (:locals this) i (ProxyNode'forValue-3 value, loopExit, (:graph this)))
                )
            )
        )
        (dotimes [#_"int" i (:stackSize this)]
            (let [
                #_"ValueNode" value (nth (:stack this) i)
            ]
                (when (and (some? value) (not= value FrameState'TWO_SLOT_MARKER) (or (not (FrameStateBuilder''contains-2 loopEntryState, value)) (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)))
                    (aset (:stack this) i (ProxyNode'forValue-3 value, loopExit, (:graph this)))
                )
            )
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (let [
                #_"ValueNode" value (nth (:lockedObjects this) i)
            ]
                (when (and (some? value) (or (not (FrameStateBuilder''contains-2 loopEntryState, value)) (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)))
                    (aset (:lockedObjects this) i (ProxyNode'forValue-3 value, loopExit, (:graph this)))
                )
            )
        )
        nil
    )

    ;;;
     ; Adds a locked monitor to this frame state.
     ;
     ; @param object the object whose monitor will be locked.
     ;;
    (defn #_"this" FrameStateBuilder''pushLock-3 [#_"FrameStateBuilder" this, #_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (let [
            this (assoc this :lockedObjects (Arrays/copyOf (:lockedObjects this), (inc (count (:lockedObjects this)))))
            this (assoc this :monitorIds (Arrays/copyOf (:monitorIds this), (inc (count (:monitorIds this)))))
        ]
            (aset (:lockedObjects this) (dec (count (:lockedObjects this))) object)
            (aset (:monitorIds this) (dec (count (:monitorIds this))) monitorId)
            this
        )
    )

    ;;;
     ; Removes a locked monitor from this frame state.
     ;
     ; @return the object whose monitor was removed from the locks list
     ;;
    (defn #_"ValueNode" FrameStateBuilder''popLock-1 [#_"FrameStateBuilder" this]
        (try
            (nth (:lockedObjects this) (dec (count (:lockedObjects this))))
            (finally
                (ยง ass! this (assoc this :lockedObjects (if (= (count (:lockedObjects this)) 1) (make-array ValueNode'iface 0) (Arrays/copyOf (:lockedObjects this), (dec (count (:lockedObjects this)))))))
                (ยง ass! this (assoc this :monitorIds (if (= (count (:monitorIds this)) 1) (make-array MonitorIdNode'iface 0) (Arrays/copyOf (:monitorIds this), (dec (count (:monitorIds this)))))))
            )
        )
    )

    (defn #_"MonitorIdNode" FrameStateBuilder''peekMonitorId-1 [#_"FrameStateBuilder" this]
        (nth (:monitorIds this) (dec (count (:monitorIds this))))
    )

    (defn #_"int" FrameStateBuilder''lockDepth-2 [#_"FrameStateBuilder" this, #_"boolean" includeParents]
        (let [
            #_"int" depth (count (:lockedObjects this))
        ]
            (when (and includeParents (some? (:parent (:parser this)))) => depth
                (+ depth (FrameStateBuilder''lockDepth-2 (:frameState (:parent (:parser this))), true))
            )
        )
    )

    (defn #_"boolean" FrameStateBuilder''contains-2 [#_"FrameStateBuilder" this, #_"ValueNode" value]
        (or
            (loop-when [#_"int" i 0] (< i (count (:locals this))) => false
                (or (= (nth (:locals this) i) value)
                    (recur (inc i))
                )
            )
            (loop-when [#_"int" i 0] (< i (:stackSize this)) => false
                (or (= (nth (:stack this) i) value)
                    (recur (inc i))
                )
            )
            (loop-when [#_"int" i 0] (< i (count (:lockedObjects this))) => false
                (or (= (nth (:lockedObjects this) i) value) (= (nth (:monitorIds this) i) value)
                    (recur (inc i))
                )
            )
        )
    )

    (defn #_"void" FrameStateBuilder''clearNonLiveLocals-4 [#_"FrameStateBuilder" this, #_"BciBlock" block, #_"LocalLiveness" liveness, #_"boolean" liveIn]
        ;; If somebody is tempted to remove/disable this clearing code: it's possible to remove it for normal compilations,
        ;; but not for OSR, as dead object slots at the OSR entry aren't cleared then. It is also not enough to rely on
        ;; PiNodes with Kind.Illegal, because the conflicting branch might not have been parsed.
        (when GraalOptions'optClearNonLiveLocals
            (if liveIn
                (dotimes [#_"int" i (count (:locals this))]
                    (when-not (LocalLiveness'''localIsLiveIn-3 liveness, block, i)
                        (aset (:locals this) i nil)
                    )
                )
                (dotimes [#_"int" i (count (:locals this))]
                    (when-not (LocalLiveness'''localIsLiveOut-3 liveness, block, i)
                        (aset (:locals this) i nil)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Loads the local variable at the specified index, checking that the returned value is non-nil
     ; and that two-stack values are properly handled.
     ;
     ; @param i the index of the local variable to load
     ; @param slotKind the kind of the local variable from the point of view of the bytecodes
     ;
     ; @return the instruction that produced the specified local
     ;;
    (defn #_"ValueNode" FrameStateBuilder''loadLocal-3 [#_"FrameStateBuilder" this, #_"int" i, #_"JavaKind" slotKind]
        (nth (:locals this) i)
    )

    ;;;
     ; Stores a given local variable at the specified index. If the value occupies two slots, then
     ; the next local variable index is also overwritten.
     ;
     ; @param i the index at which to store
     ; @param slotKind the kind of the local variable from the point of view of the bytecodes
     ; @param x the instruction which produces the value for the local
     ;;
    (defn #_"void" FrameStateBuilder''storeLocal-4 [#_"FrameStateBuilder" this, #_"int" i, #_"JavaKind" slotKind, #_"ValueNode" x]
        (when (= (nth (:locals this) i) FrameState'TWO_SLOT_MARKER)
            ;; Writing the second slot of a two-slot value invalidates the first slot.
            (aset (:locals this) (dec i) nil)
        )
        (aset (:locals this) i x)
        (cond
            (#_"JavaKind" .needsTwoSlots slotKind)
            (do
                ;; Writing a two-slot value: mark the second slot.
                (aset (:locals this) (inc i) FrameState'TWO_SLOT_MARKER)
            )
            (and (< i (dec (count (:locals this)))) (= (nth (:locals this) (inc i)) FrameState'TWO_SLOT_MARKER))
            (do
                ;; Writing a one-slot value to an index previously occupied by a two-slot value: clear the old marker of the second slot.
                (aset (:locals this) (inc i) nil)
            )
        )
        nil
    )

    (defn- #_"FrameStateBuilder" FrameStateBuilder''xpush-2 [#_"FrameStateBuilder" this, #_"ValueNode" x]
        (aset (:stack this) (:stackSize this) x)
        (update this :stackSize inc)
    )

    (defn- #_"ValueNode" FrameStateBuilder''xpop-1 [#_"FrameStateBuilder" this]
        (ยง ass! this (update this :stackSize dec))
        (nth (:stack this) (:stackSize this))
    )

    (defn- #_"ValueNode" FrameStateBuilder''xpeek-1 [#_"FrameStateBuilder" this]
        (nth (:stack this) (dec (:stackSize this)))
    )

    ;;;
     ; Pushes an instruction onto the stack with the expected type.
     ;
     ; @param slotKind the kind of the stack element from the point of view of the bytecodes
     ; @param x the instruction to push onto the stack
     ;;
    (defn #_"FrameStateBuilder" FrameStateBuilder''push-3 [#_"FrameStateBuilder" this, #_"JavaKind" slotKind, #_"ValueNode" x]
        (let [
            this (FrameStateBuilder''xpush-2 this, x)
        ]
            (when (#_"JavaKind" .needsTwoSlots slotKind) => this
                (FrameStateBuilder''xpush-2 this, FrameState'TWO_SLOT_MARKER)
            )
        )
    )

    (defn #_"FrameStateBuilder" FrameStateBuilder''pushReturn-3 [#_"FrameStateBuilder" this, #_"JavaKind" slotKind, #_"ValueNode" x]
        (when-not (= slotKind JavaKind/Void) => this
            (FrameStateBuilder''push-3 this, slotKind, x)
        )
    )

    ;;;
     ; Pops an instruction off the stack with the expected type.
     ;
     ; @param slotKind the kind of the stack element from the point of view of the bytecodes
     ; @return the instruction on the top of the stack
     ;;
    (defn #_"ValueNode" FrameStateBuilder''pop-2 [#_"FrameStateBuilder" this, #_"JavaKind" slotKind]
        (when (#_"JavaKind" .needsTwoSlots slotKind)
            (FrameStateBuilder''xpop-1 this)
        )
        (FrameStateBuilder''xpop-1 this)
    )

    ;;;
     ; Pop the specified number of slots off of this stack and return them as an array of instructions.
     ;
     ; @return an array containing the arguments off of the stack
     ;;
    (defn #_"ValueNode[]" FrameStateBuilder''popArguments-2 [#_"FrameStateBuilder" this, #_"int" argSize]
        (let [
            #_"ValueNode[]" result (make-array ValueNode'iface argSize)
        ]
            (loop-when-recur [#_"int" i (dec argSize)] (<= 0 i) [(dec i)]
                (let [
                    #_"ValueNode" x (FrameStateBuilder''xpop-1 this)
                    x
                        (when (= x FrameState'TWO_SLOT_MARKER) => x
                            ;; Ignore second slot of two-slot value.
                            (FrameStateBuilder''xpop-1 this)
                        )
                ]
                    (aset result i x)
                )
            )
            result
        )
    )

    ;;;
     ; Clears all values on this stack.
     ;;
    (defn #_"FrameStateBuilder" FrameStateBuilder''clearStack-1 [#_"FrameStateBuilder" this]
        (assoc this :stackSize 0)
    )

    ;;;
     ; Performs a raw stack operation as defined in the Java bytecode specification.
     ;
     ; @param opcode The Java bytecode.
     ;;
    (defn #_"FrameStateBuilder" FrameStateBuilder''stackOp-2 [#_"FrameStateBuilder" this, #_"int" opcode]
        (condp = opcode
            Bytecodes'POP
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                ]
                    this
                )
            Bytecodes'POP2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                ]
                    this
                )
            Bytecodes'DUP
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpeek-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP_X1
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP_X2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w3 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w3)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP2_X1
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w3 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w3)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP2_X2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w3 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w4 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w4)
                    this (FrameStateBuilder''xpush-2 this, w3)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'SWAP
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w2)
                ]
                    this
                )
        )
    )

    (defm FrameStateBuilder SideEffectsState
        (#_"boolean" SideEffectsState'''isAfterSideEffect-1 [#_"FrameStateBuilder" this]
            (some? (:sideEffects this))
        )

        (#_"Iterable<StateSplit>" SideEffectsState'''sideEffects-1 [#_"FrameStateBuilder" this]
            (:sideEffects this)
        )

        (#_"void" SideEffectsState'''addSideEffect-2 [#_"FrameStateBuilder" this, #_"StateSplit" sideEffect]
            (when (nil? (:sideEffects this))
                (ยง ass! this (assoc this :sideEffects (ArrayList.)))
            )
            (#_"List" .add (:sideEffects this), sideEffect)
            nil
        )
    )
)

;;;
 ; This class is a graph container, it contains the set of nodes that belong to this graph.
 ; A graph contains at least one distinguished node, the {@link #start() start} node.
 ; This node is the start of the control flow of the graph.
 ;;
(class-ns Graph []
    (defn #_"Graph" Graph'new-1 [#_"ResolvedJavaMethod" method]
        (let [
            #_"Graph" this
                (merge (Graph'class.)
                    (hash-map
                        ;;;
                         ; The set of nodes in the graph, ordered by {@linkplain #register(Node) registration} time.
                         ;;
                        #_"[Node]" :gNodes []
                        ;;;
                         ; The number of nodes which have been deleted from this graph.
                         ;;
                        #_"int" :nodesDeleted 0
                        #_"NodeEventListener" :nodeEventListener nil
                        ;;;
                         ; Indicates that the graph should no longer be modified. Frozen graphs can be used by multiple
                         ; threads so it's only safe to read them.
                         ;;
                        #_"boolean" :frozen false
                        #_"StartNode" :start nil
                        ;;;
                         ; The root method from which this graph was built, or nil
                         ; if this method was not built from a method or the method is not available.
                         ;;
                        #_"ResolvedJavaMethod" :rootMethod method
                        #_"GuardsStage" :guardsStage GuardsStage'FLOATING_GUARDS
                        #_"boolean" :isAfterFloatingReadPhase false
                        #_"boolean" :isAfterFixedReadPhase false
                        #_"boolean" :hasValueProxies true
                        #_"boolean" :isAfterExpandLogic false
                        #_"ScheduleResult" :lastSchedule nil
                    )
                )
            this (Graph''setStart-2 this, (Graph''add-2 this, (StartNode'new-0)))
        ]
            this
        )
    )

    (defn #_"Graph" Graph'copy-1 [#_"Graph" other]
        (let [
            #_"Graph" this (Graph'new-1 (:rootMethod other))
            this (Graph''setGuardsStage-2 this, (:guardsStage other))
            this (assoc this :isAfterFloatingReadPhase (:isAfterFloatingReadPhase other))
            this (assoc this :hasValueProxies (:hasValueProxies other))
            this (assoc this :isAfterExpandLogic (:isAfterExpandLogic other))
        ]
            this
        )
    )

    (defn #_"int" Graph''getMark-1 [#_"Graph" this]
        (count (:gNodes this))
    )

    ;;;
     ; Gets the number of live nodes in this graph. That is the number of nodes which have been
     ; added to the graph minus the number of deleted nodes.
     ;
     ; @return the number of live nodes in this graph
     ;;
    (defn #_"int" Graph''getNodeCount-1 [#_"Graph" this]
        (- (count (:gNodes this)) (:nodesDeleted this))
    )

    ;;;
     ; Adds a new node to the graph.
     ;;
    (defn #_"Node" Graph''add-2 [#_"Graph" this, #_"Node" node]
        (ยง ass! node (assoc node :graph this))
        (ยง ass! this (Graph''register-2 this, node))
        (let [
            #_"NodeClass<? implements Node>" c (:nodeClass node)
        ]
            (NodeClass''registerAtInputsAsUsage-2 c, node)
            (NodeClass''registerAtSuccessorsAsPredecessor-2 c, node)
        )
        node
    )

    (defn #_"Node" Graph''maybeAddOrUnique-2 [#_"Graph" this, #_"Node" node]
        (when-not (Node''isAlive-1 node) => node
            (Graph''add-2 this, node)
        )
    )

    (declare Graph''addOrUniqueWithInputs-2)

    (defn- #_"void" Graph''addInputs-2 [#_"Graph" this, #_"Node" node]
        (let [
            #_"Graph" graph this
            #_"EdgeVisitor" addInputsFilter
                (reify EdgeVisitor
                    (#_"Node" EdgeVisitor'''apply-3 [#_"EdgeVisitor" this, #_"Node" source, #_"Node" target]
                        (if (Node''isAlive-1 target) target (Graph''addOrUniqueWithInputs-2 graph, target))
                    )
                )
        ]
            (Node''applyInputs-2 node, addInputsFilter)
        )
        nil
    )

    (defn #_"Node" Graph''addOrUniqueWithInputs-2 [#_"Graph" this, #_"Node" node]
        (when-not (Node''isAlive-1 node) => node
            (Graph''addInputs-2 this, node)
            (Graph''add-2 this, node)
        )
    )

    ;;;
     ; Registers a given NodeEventListener with this graph. This should be used in
     ; conjunction with try-with-resources statement as follows:
     ;
     ; try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
     ;     // make changes to the graph
     ; }
     ;;
    (defn #_"NodeEventScope" Graph''trackNodeEvents-2 [#_"Graph" this, #_"NodeEventListener" listener]
        (NodeEventScope'new-2 this, listener)
    )

    ;;;
     ; Returns a sequence of all nodes added since the last {@link Graph#getMark() mark}.
     ;;
    (defn #_"Node*" Graph''getNodesSince-2 [#_"Graph" this, #_"int" mark]
        (remove nil? (subvec (:gNodes this) mark))
    )

    ;;;
     ; Returns a sequence of all the live nodes.
     ;;
    (defn #_"Node*" Graph''getNodes-1 [#_"Graph" this]
        (Graph''getNodesSince-2 this, 0)
    )

    ;;;
     ; Returns an Iterable providing all the live nodes whose type is compatible with {@code type}.
     ;;
    (defn #_"Node*" Graph''getNodes-2 [#_"Graph" this, #_"protocol" type]
        (filter #(satisfies? type %) (Graph''getNodes-1 this))
    )

    (defn #_"this" Graph''register-2 [#_"Graph" this, #_"Node" node]
        (let [
            #_"int" id (count (:gNodes this))
            _ (ยง ass! node (assoc node :nid id))
            this (update this :gNodes assoc id node)
        ]
            (when (some? (:nodeEventListener this))
                (NodeEventListener''event-3 (:nodeEventListener this), NodeEvent'NODE_ADDED, node)
            )
            this
        )
    )

    (defn #_"this" Graph''unregister-2 [#_"Graph" this, #_"Node" node]
        (let [
            this (update this :gNodes assoc (:nid node) nil)
            this (update this :nodesDeleted inc)
        ]
            (when (some? (:nodeEventListener this))
                (NodeEventListener''event-3 (:nodeEventListener this), NodeEvent'NODE_ADDED, node)
            )
            this
        )
    )

    ;;;
     ; Adds duplicates of the nodes in {@code newNodes} to this graph. This will recreate any edges
     ; between the duplicate nodes. The {@code replacement} map can be used to replace a node from
     ; the source graph by a given node (which must already be in this graph). Edges between
     ; duplicate and replacement nodes will also be recreated so care should be taken regarding the
     ; matching of node types in the replacement map.
     ;
     ; @param newNodes the nodes to be duplicated
     ; @param replacementsMap the replacement map (can be nil if no replacement is to be performed)
     ; @return a map which associates the original nodes from {@code nodes} to their duplicates
     ;;
    (defn #_"{Node Node}" Graph''addDuplicates-5m [#_"Graph" this, #_"Node*" newNodes, #_"Graph" oldGraph, #_"int" estimatedNodeCount, #_"EconomicMap<Node, Node>" replacementsMap]
        (Graph''addDuplicates-5r this, newNodes, oldGraph, estimatedNodeCount, (when (some? replacementsMap) (MapReplacement'new-1 replacementsMap)))
    )

    (defn #_"EconomicMap<Node, Node>" Graph''addDuplicates-5r [#_"Graph" this, #_"Node*" newNodes, #_"Graph" oldGraph, #_"int" estimatedNodeCount, #_"DuplicationReplacement" replacements]
        (NodeClass'addGraphDuplicate-5 this, oldGraph, estimatedNodeCount, newNodes, replacements)
    )

    (defn #_"boolean" Graph''isFrozen-1 [#_"Graph" this]
        (:frozen this)
    )

    (defn #_"Graph" Graph''freeze-1 [#_"Graph" this]
        (assoc this :frozen true)
    )

    (defn #_"Graph" Graph''setLastSchedule-2 [#_"Graph" this, #_"ScheduleResult" result]
        (assoc this :lastSchedule result)
    )

    #_unused
    (defn #_"Stamp" Graph''getReturnStamp-1 [#_"Graph" this]
        (loop-when [#_"Stamp" stamp nil #_"ISeq" s (seq (Graph''getNodes-2 this, ReturnNode))] (some? s) => stamp
            (let [
                #_"ValueNode" result (:result (first s))
                stamp
                    (cond
                        (nil? result) stamp
                        (nil? stamp)  (:stamp result)
                        :else         (Stamp'''meet-2 stamp, (:stamp result))
                    )
            ]
                (recur stamp (next s))
            )
        )
    )

    (defn #_"Graph" Graph''setStart-2 [#_"Graph" this, #_"StartNode" start]
        (assoc this :start start)
    )

    (defn #_"ParameterNode" Graph''getParameter-2 [#_"Graph" this, #_"int" index]
        (loop-when [#_"ISeq" s (seq (Graph''getNodes-2 this, ParameterNode))] (some? s)
            (let [
                #_"ParameterNode" param (first s)
            ]
                (if (= (AbstractLocalNode''index-1 param) index)
                    param
                    (recur (next s))
                )
            )
        )
    )

    (defn #_"InvokeNode*" Graph''getInvokes-1 [#_"Graph" this]
        (->> (Graph''getNodes-2 this, MethodCallTargetNode) (map MethodCallTargetNode''invoke-1) (remove nil?))
    )

    (defn #_"boolean" Graph''hasLoops-1 [#_"Graph" this]
        (seq (Graph''getNodes-2 this, LoopBeginNode))
    )

    ;;;
     ; Unlinks a node from all its control flow neighbors and then removes it from its graph.
     ; The node must have no {@linkplain Node#usages() usages}.
     ;
     ; @param node the node to be unlinked and removed
     ;;
    (defn #_"void" Graph''removeFixed-2 [#_"Graph" this, #_"FixedWithNextNode" node]
        (when (satisfies? AbstractBeginNode node)
            (AbstractBeginNode''prepareDelete-1 node)
        )
        (GraphUtil'unlinkFixedNode-1 node)
        (Node''safeDelete-1 node)
        nil
    )

    (defn #_"Graph" Graph''replaceFixedWithFixed-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"FixedWithNextNode" replacement]
        (let [
            #_"FixedNode" _next (:next node)
            _ (ยง ass! node (FixedWithNextNode''setNext-2 node, nil))
            _ (ยง ass! replacement (FixedWithNextNode''setNext-2 replacement, _next))
            _ (ยง ass! node (Node''replaceAndDelete-2 node, replacement))
        ]
            (when (= node (:start this)) => this
                (Graph''setStart-2 this, (ยง cast #_"StartNode" replacement))
            )
        )
    )

    (defn #_"this" Graph''replaceFixedWithFloating-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"ValueNode" replacement]
        (GraphUtil'unlinkFixedNode-1 node)
        (ยง ass! node (Node''replaceAtUsagesAndDelete-2 node, replacement))
        this
    )

    (defn #_"Graph" Graph''replaceFixed-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"Node" replacement]
        (if (satisfies? FixedWithNextNode replacement)
            (Graph''replaceFixedWithFixed-3 this, node, replacement)
            (Graph''replaceFixedWithFloating-3 this, node, replacement)
        )
    )

    (defn #_"void" Graph''removeSplit-3 [#_"Graph" this, #_"ControlSplitNode" node, #_"AbstractBeginNode" survivingSuccessor]
        (Node''clearSuccessors-1 node)
        (Node''replaceAtPredecessor-2 node, survivingSuccessor)
        (Node''safeDelete-1 node)
        nil
    )

    (defn #_"void" Graph''removeSplitPropagate-3 [#_"Graph" this, #_"ControlSplitNode" node, #_"AbstractBeginNode" survivingSuccessor]
        (let [
            #_"Node*" snapshot (ยง snap (Node''successors-1 node))
        ]
            (Node''clearSuccessors-1 node)
            (Node''replaceAtPredecessor-2 node, survivingSuccessor)
            (Node''safeDelete-1 node)
            (doseq [#_"Node" successor snapshot]
                (when (and (some? successor) (Node''isAlive-1 successor) (not (= successor survivingSuccessor)))
                    (GraphUtil'killCFG-1 successor)
                )
            )
        )
        nil
    )

    (defn #_"void" Graph''replaceSplit-4 [#_"Graph" this, #_"ControlSplitNode" node, #_"Node" replacement, #_"AbstractBeginNode" survivingSuccessor]
        (if (satisfies? FixedWithNextNode replacement)
            (Graph''replaceSplitWithFixed-4 this, node, replacement, survivingSuccessor)
            (Graph''replaceSplitWithFloating-4 this, node, replacement, survivingSuccessor)
        )
        nil
    )

    (defn #_"void" Graph''replaceSplitWithFixed-4 [#_"Graph" this, #_"ControlSplitNode" node, #_"FixedWithNextNode" replacement, #_"AbstractBeginNode" survivingSuccessor]
        (Node''clearSuccessors-1 node)
        (ยง ass! replacement (FixedWithNextNode''setNext-2 replacement, survivingSuccessor))
        (ยง ass! node (Node''replaceAndDelete-2 node, replacement))
        nil
    )

    (defn #_"void" Graph''replaceSplitWithFloating-4 [#_"Graph" this, #_"ControlSplitNode" node, #_"FloatingNode" replacement, #_"AbstractBeginNode" survivingSuccessor]
        (Node''clearSuccessors-1 node)
        (Node''replaceAtPredecessor-2 node, survivingSuccessor)
        (ยง ass! node (Node''replaceAtUsagesAndDelete-2 node, replacement))
        nil
    )

    (defn #_"void" Graph''addAfterFixed-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"FixedNode" newNode]
        (let [
            #_"FixedNode" _next (:next node)
        ]
            (ยง ass! node (FixedWithNextNode''setNext-2 node, newNode))
            (when (some? _next)
                (ยง ass! newNode (FixedWithNextNode''setNext-2 newNode, _next))
            )
        )
        nil
    )

    (defn #_"void" Graph''addBeforeFixed-3 [#_"Graph" this, #_"FixedNode" node, #_"FixedWithNextNode" newNode]
        (ยง ass! (:predecessor node) (FixedWithNextNode''setNext-2 (:predecessor node), newNode))
        (ยง ass! newNode (FixedWithNextNode''setNext-2 newNode, node))
        nil
    )

    (defn #_"Graph" Graph''reduceDegenerateLoopBegin-2 [#_"Graph" this, #_"LoopBeginNode" begin]
        (if (= (AbstractMergeNode''forwardEndCount-1 begin) 1)
            ;; bypass merge and remove
            (do
                (Graph''reduceTrivialMerge-2 this, begin)
                this
            )
            ;; convert to merge
            (let [
                #_"AbstractMergeNode" merge (Graph''add-2 this, (MergeNode'new-0))
            ]
                (doseq [#_"EndNode" end (:ends begin)]
                    (AbstractMergeNode''addForwardEnd-2 merge, end)
                )
                (Graph''replaceFixedWithFixed-3 this, begin, merge)
            )
        )
    )

    (defn #_"void" Graph''reduceTrivialMerge-2 [#_"Graph" this, #_"AbstractMergeNode" merge]
        (doseq [#_"PhiNode" phi (ยง snap (AbstractMergeNode''phis-1 merge))]
            (let [
                #_"ValueNode" singleValue (PhiNode''valueAt-2i phi, 0)
            ]
                (if (Node''hasUsages-1 phi)
                    (ยง ass! phi (Node''replaceAtUsagesAndDelete-2 phi, singleValue))
                    (do
                        (Node''safeDelete-1 phi)
                        (when (some? singleValue)
                            (GraphUtil'tryKillUnused-1 singleValue)
                        )
                    )
                )
            )
        )
        ;; remove loop exits
        (when (satisfies? LoopBeginNode merge)
            (LoopBeginNode''removeExits-1 merge)
        )
        (let [
            #_"AbstractEndNode" singleEnd (AbstractMergeNode''forwardEndAt-2 merge, 0)
            #_"FixedNode" sux (:next merge)
            #_"FrameState" stateAfter (:stateAfter merge)
        ]
            ;; evacuateGuards
            (AbstractBeginNode'''prepareDelete-2 merge, (:predecessor singleEnd))
            (Node''safeDelete-1 merge)
            (when (some? stateAfter)
                (GraphUtil'tryKillUnused-1 stateAfter)
            )
            (when (nil? sux) => (ยง ass! singleEnd (Node''replaceAndDelete-2 singleEnd, sux))
                (Node''replaceAtPredecessor-2 singleEnd, nil)
                (Node''safeDelete-1 singleEnd)
            )
        )
        nil
    )

    (defn #_"Graph" Graph''setGuardsStage-2 [#_"Graph" this, #_"GuardsStage" guardsStage]
        (assoc this :guardsStage guardsStage)
    )

    (defn #_"Graph" Graph''setAfterFloatingReadPhase-2 [#_"Graph" this, #_"boolean" state]
        (assoc this :isAfterFloatingReadPhase state)
    )

    (defn #_"Graph" Graph''setAfterFixReadPhase-2 [#_"Graph" this, #_"boolean" state]
        (assoc this :isAfterFixedReadPhase state)
    )

    (defn #_"Graph" Graph''setHasValueProxies-2 [#_"Graph" this, #_"boolean" state]
        (assoc this :hasValueProxies state)
    )

    (defn #_"Graph" Graph''setAfterExpandLogic-1 [#_"Graph" this]
        (assoc this :isAfterExpandLogic true)
    )

    (defn #_"boolean" Graph''hasVirtualizableAllocation-1 [#_"Graph" this]
        (loop [#_"ISeq" s (seq (Graph''getNodes-1 this))]
            (and (some? s)
                (or (satisfies? VirtualizableAllocation (first s))
                    (recur (next s))
                )
            )
        )
    )
)

(class-ns GraphBuilderInstance [Phase]
    (defn #_"GraphBuilderInstance" GraphBuilderInstance'new-2 [#_"OptimisticOptimizations" optimisticOpts, #_"IntrinsicContext" initialIntrinsicContext]
        (merge (GraphBuilderInstance'class.)
            (hash-map
                #_"OptimisticOptimizations" :optimisticOpts optimisticOpts
                #_"IntrinsicContext" :initialIntrinsicContext initialIntrinsicContext
            )
        )
    )

    (defm GraphBuilderInstance Phase
        (#_"Graph" Phase'''run-3 [#_"GraphBuilderInstance" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"BytecodeParser" parser (BytecodeParser'new-5 this, graph, nil, (:rootMethod graph), (:initialIntrinsicContext this))
            ]
                (ยง ass! parser (BytecodeParser''buildRootMethod-1 parser))
                graph
            )
        )
    )
)

;;;
 ; Parses the bytecodes of a method and builds the IR graph.
 ;;
(class-ns GraphBuilderPhase [Phase]
    (defn #_"GraphBuilderPhase" GraphBuilderPhase'new-0 []
        (GraphBuilderPhase'class.)
    )

    (defm GraphBuilderPhase Phase
        (#_"Graph" Phase'''run-3 [#_"GraphBuilderPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (Phase'''run-3 (GraphBuilderInstance'new-2 (:optimisticOpts context), nil), graph, nil)
        )
    )
)

;;;
 ; This phase lowers GuardNodes into corresponding control-flow structure and DeoptimizeNodes.
 ;
 ; This allow to enter the {@link GuardsStage#FIXED_DEOPTS FIXED_DEOPTS} stage of the graph
 ; where all node that may cause deoptimization are fixed.
 ;
 ; It first makes a schedule in order to know where the control flow should be placed. Then,
 ; for each block, it applies two passes. The first one tries to replace nil-check guards with
 ; implicit nil-checks performed by access to the objects that need to be nil-checked.
 ; The second phase does the actual control-flow expansion of the remaining GuardNodes.
 ;;
(class-ns GuardLoweringPhase [Phase]
    (defn #_"GuardLoweringPhase" GuardLoweringPhase'new-0 []
        (GuardLoweringPhase'class.)
    )

    (defm GuardLoweringPhase Phase
        (#_"Graph" Phase'''run-3 [#_"GuardLoweringPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (GuardsStage'allowsFloatingGuards-1 (:guardsStage graph)) => graph
                (let [
                    graph (Phase'''run-3 (SchedulePhase'new-1 SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER), graph, nil)
                ]
                    (doseq [#_"Block" block (:reversePostOrder (:cfg (:lastSchedule graph)))]
                        (ScheduledNodeIterator''processNodes-3 (LowerGuards'new-1 block), block, (:lastSchedule graph))
                    )
                    (Graph''setGuardsStage-2 graph, GuardsStage'FIXED_DEOPTS)
                )
            )
        )
    )
)

;;;
 ; This plugin handles the HotSpot-specific customizations of bytecode parsing:
 ;
 ; Word-type rewriting for {@link BytecodeParser#parsingIntrinsic intrinsic} functions (snippets and
 ; method substitutions), by forwarding to the WordOperationPlugin. Note that we forward the NodePlugin
 ; and TypePlugin methods, but not the InlineInvokePlugin methods implemented by WordOperationPlugin.
 ; The latter is not necessary because HotSpot only uses the Word type in methods that are force-inlined,
 ; i.e. there are never non-inlined invokes that involve the Word type.
 ;
 ; Constant folding of field loads.
 ;;
(class-ns HotSpotNodePlugin [NodePlugin, TypePlugin]
    (defn #_"HotSpotNodePlugin" HotSpotNodePlugin'new-1 [#_"WordOperationPlugin" wordOperationPlugin]
        (merge (HotSpotNodePlugin'class.)
            (hash-map
                #_"WordOperationPlugin" :wordOperationPlugin wordOperationPlugin
            )
        )
    )

    (defm HotSpotNodePlugin TypePlugin
        (#_"Stamp" TypePlugin'''interceptType-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"JavaType" declaredType, #_"boolean" never-nil?]
            (when (BytecodeParser''parsingIntrinsic-1 parser)
                (TypePlugin'''interceptType-4 (:wordOperationPlugin this), parser, declaredType, never-nil?)
            )
        )
    )

    (defn- #_"boolean" HotSpotNodePlugin'tryConstantFold-3 [#_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"JavaConstant" object]
        (let [
            #_"ConstantNode" constant (ConstantFields'tryConstantFold-2 field, object)
        ]
            (and (some? constant)
                (do
                    (BytecodeParser''push-3 parser, (#_"ResolvedJavaField" .getJavaKind field), (Graph''add-2 (:graph parser), constant))
                    true
                )
            )
        )
    )

    (defn- #_"boolean" HotSpotNodePlugin'tryReadField-3 [#_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"JavaConstant" object]
        (HotSpotNodePlugin'tryConstantFold-3 parser, field, object)
    )

    (defm HotSpotNodePlugin NodePlugin
        (#_"boolean" NodePlugin'''handleInvoke-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleInvoke-4 (:wordOperationPlugin this), parser, method, args)
            )
        )

        (#_"boolean" NodePlugin'''handleLoadField-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field]
            (or (and (satisfies? ConstantNode object)
                    (HotSpotNodePlugin'tryReadField-3 parser, field, (ValueNode''asJavaConstant-1 object))
                )
                (and (BytecodeParser''parsingIntrinsic-1 parser)
                    (NodePlugin'''handleLoadField-4 (:wordOperationPlugin this), parser, object, field)
                )
            )
        )

        (#_"boolean" NodePlugin'''handleLoadStaticField-3 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field]
            (or (HotSpotNodePlugin'tryReadField-3 parser, field, nil)
                (and (BytecodeParser''parsingIntrinsic-1 parser)
                    (NodePlugin'''handleLoadStaticField-3 (:wordOperationPlugin this), parser, field)
                )
            )
        )

        (#_"boolean" NodePlugin'''handleStoreField-5 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleStoreField-5 (:wordOperationPlugin this), parser, object, field, value)
            )
        )

        (#_"boolean" NodePlugin'''handleStoreStaticField-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"ValueNode" value]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleStoreStaticField-4 (:wordOperationPlugin this), parser, field, value)
            )
        )

        (#_"boolean" NodePlugin'''handleLoadIndexed-5 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleLoadIndexed-5 (:wordOperationPlugin this), parser, array, index, elementKind)
            )
        )

        (#_"boolean" NodePlugin'''handleStoreIndexed-6 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleStoreIndexed-6 (:wordOperationPlugin this), parser, array, index, elementKind, value)
            )
        )

        (#_"boolean" NodePlugin'''handleCheckCast-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleCheckCast-4 (:wordOperationPlugin this), parser, object, type)
            )
        )

        (#_"boolean" NodePlugin'''handleInstanceOf-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (NodePlugin'''handleInstanceOf-4 (:wordOperationPlugin this), parser, object, type)
            )
        )
    )
)

(class-ns InductionVariable []
    (defn #_"InductionVariable" InductionVariable'new-1 [#_"LoopEx" _loop]
        (merge (InductionVariable'class.)
            (hash-map
                #_"LoopEx" :loop _loop
            )
        )
    )
)

(class-ns BasicInductionVariable [InductionVariable]
    (defn #_"BasicInductionVariable" BasicInductionVariable'new-5 [#_"LoopEx" _loop, #_"ValuePhiNode" phi, #_"ValueNode" init, #_"ValueNode" rawStride, #_"BinaryArithmeticNode" op]
        (merge (BasicInductionVariable'class.) (InductionVariable'new-1 _loop)
            (hash-map
                #_"ValuePhiNode" :phi phi
                #_"ValueNode" :init init
                #_"ValueNode" :rawStride rawStride
                #_"BinaryArithmeticNode" :op op
            )
        )
    )

    (defm BasicInductionVariable InductionVariable
        (#_"Graph" InductionVariable'''graph-1 [#_"BasicInductionVariable" this]
            (:graph (:phi this))
        )

        (#_"Direction" InductionVariable'''direction-1 [#_"BasicInductionVariable" this]
            (let [
                #_"Stamp" stamp (:stamp (:rawStride this))
            ]
                (when (satisfies? IntegerStamp stamp)
                    (let [
                        #_"Direction" dir
                            (cond
                                (IntegerStamp''isStrictlyPositive-1 stamp) :Direction'Up
                                (IntegerStamp''isStrictlyNegative-1 stamp) :Direction'Down
                            )
                    ]
                        (when (some? dir)
                            (if (satisfies? AddNode (:op this)) dir (Direction''opposite-1 dir))
                        )
                    )
                )
            )
        )

        (#_"ValuePhiNode" InductionVariable'''valueNode-1 [#_"BasicInductionVariable" this]
            (:phi this)
        )

        (#_"ValueNode" InductionVariable'''initNode-1 [#_"BasicInductionVariable" this]
            (:init this)
        )

        (#_"ValueNode" InductionVariable'''strideNode-1 [#_"BasicInductionVariable" this]
            (condp satisfies? (:op this)
                AddNode (:rawStride this)
                SubNode (Graph''add-2 (InductionVariable'''graph-1 this), (NegateNode'new-1 (:rawStride this)))
            )
        )

        (#_"boolean" InductionVariable'''isConstantInit-1 [#_"BasicInductionVariable" this]
            (satisfies? ConstantNode (:init this))
        )

        (#_"boolean" InductionVariable'''isConstantStride-1 [#_"BasicInductionVariable" this]
            (satisfies? ConstantNode (:rawStride this))
        )

        (#_"long" InductionVariable'''constantInit-1 [#_"BasicInductionVariable" this]
            (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:init this)))
        )

        (#_"long" InductionVariable'''constantStride-1 [#_"BasicInductionVariable" this]
            (condp satisfies? (:op this)
                AddNode    (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:rawStride this)))
                SubNode (- (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:rawStride this))))
            )
        )

        (#_"ValueNode" InductionVariable'''exitValueNode-1 [#_"BasicInductionVariable" this]
            (let [
                #_"Stamp" stamp (:stamp (:phi this))
                #_"ValueNode" maxTripCount (CountedLoopInfo''maxTripCountNode-1 (:counted (:loop this)))
            ]
                (when-not (Stamp'''isCompatible-2s (:stamp maxTripCount), stamp)
                    (ยง ass maxTripCount (IntegerConvertNode'convert-3g maxTripCount, stamp, (InductionVariable'''graph-1 this)))
                )
                (MathUtil'add-3 (InductionVariable'''graph-1 this), (MathUtil'mul-3 (InductionVariable'''graph-1 this), (InductionVariable'''strideNode-1 this), maxTripCount), (InductionVariable'''initNode-1 this))
            )
        )

        (#_"boolean" InductionVariable'''isConstantExtremum-1 [#_"BasicInductionVariable" this]
            (and (InductionVariable'''isConstantInit-1 this) (InductionVariable'''isConstantStride-1 this) (CountedLoopInfo''isConstantMaxTripCount-1 (:counted (:loop this))))
        )

        (#_"long" InductionVariable'''constantExtremum-1 [#_"BasicInductionVariable" this]
            (let [
                #_"UnsignedLong" tripCount (CountedLoopInfo''constantMaxTripCount-1 (:counted (:loop this)))
            ]
                (if (UnsignedLong''isLessThan-2 tripCount, 1)
                    (InductionVariable'''constantInit-1 this)
                    (UnsignedLong''asLong-1 (UnsignedLong''wrappingPlus-2 (UnsignedLong''wrappingTimes-2 (UnsignedLong''minus-2 tripCount, 1), (InductionVariable'''constantStride-1 this)), (InductionVariable'''constantInit-1 this)))
                )
            )
        )

        (#_"void" InductionVariable'''deleteUnusedNodes-1 [#_"BasicInductionVariable" this]
            nil
        )
    )
)

;;;
 ; Base class of the derived induction variables.
 ;;
(class-ns DerivedInductionVariable [InductionVariable]
    (defn #_"DerivedInductionVariable" DerivedInductionVariable'new-2 [#_"LoopEx" _loop, #_"InductionVariable" base]
        (merge (DerivedInductionVariable'class.) (InductionVariable'new-1 _loop)
            (hash-map
                #_"InductionVariable" :base base
            )
        )
    )

    (defm DerivedInductionVariable InductionVariable
        (#_"Graph" InductionVariable'''graph-1 [#_"DerivedInductionVariable" this]
            (InductionVariable'''graph-1 (:base this))
        )
    )

    (defn #_"InductionVariable" DerivedInductionVariable''getBase-1 [#_"DerivedInductionVariable" this]
        (:base this)
    )
)

(class-ns DerivedConvertedInductionVariable [DerivedInductionVariable, InductionVariable]
    (defn #_"DerivedConvertedInductionVariable" DerivedConvertedInductionVariable'new-4 [#_"LoopEx" _loop, #_"InductionVariable" base, #_"Stamp" stamp, #_"ValueNode" value]
        (merge (DerivedConvertedInductionVariable'class.) (DerivedInductionVariable'new-2 _loop, base)
            (hash-map
                #_"Stamp" :stamp stamp
                #_"ValueNode" :value value
            )
        )
    )

    (defm DerivedConvertedInductionVariable InductionVariable
        (#_"ValueNode" InductionVariable'''valueNode-1 [#_"DerivedConvertedInductionVariable" this]
            (:value this)
        )

        (#_"Direction" InductionVariable'''direction-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''direction-1 (:base this))
        )

        (#_"ValueNode" InductionVariable'''initNode-1 [#_"DerivedConvertedInductionVariable" this]
            (IntegerConvertNode'convert-3g (InductionVariable'''initNode-1 (:base this)), (:stamp this), (InductionVariable'''graph-1 this))
        )

        (#_"ValueNode" InductionVariable'''strideNode-1 [#_"DerivedConvertedInductionVariable" this]
            (IntegerConvertNode'convert-3g (InductionVariable'''strideNode-1 (:base this)), (:stamp this), (InductionVariable'''graph-1 this))
        )

        (#_"boolean" InductionVariable'''isConstantInit-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''isConstantInit-1 (:base this))
        )

        (#_"boolean" InductionVariable'''isConstantStride-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''isConstantStride-1 (:base this))
        )

        (#_"long" InductionVariable'''constantInit-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''constantInit-1 (:base this))
        )

        (#_"long" InductionVariable'''constantStride-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''constantStride-1 (:base this))
        )

        (#_"ValueNode" InductionVariable'''exitValueNode-1 [#_"DerivedConvertedInductionVariable" this]
            (IntegerConvertNode'convert-3g (InductionVariable'''exitValueNode-1 (:base this)), (:stamp this), (InductionVariable'''graph-1 this))
        )

        (#_"boolean" InductionVariable'''isConstantExtremum-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''isConstantExtremum-1 (:base this))
        )

        (#_"long" InductionVariable'''constantExtremum-1 [#_"DerivedConvertedInductionVariable" this]
            (InductionVariable'''constantExtremum-1 (:base this))
        )

        (#_"void" InductionVariable'''deleteUnusedNodes-1 [#_"DerivedConvertedInductionVariable" this]
            nil
        )
    )
)

(class-ns DerivedOffsetInductionVariable [DerivedInductionVariable, InductionVariable]
    (defn #_"DerivedOffsetInductionVariable" DerivedOffsetInductionVariable'new-4 [#_"LoopEx" _loop, #_"InductionVariable" base, #_"ValueNode" offset, #_"BinaryArithmeticNode" value]
        (merge (DerivedOffsetInductionVariable'class.) (DerivedInductionVariable'new-2 _loop, base)
            (hash-map
                #_"ValueNode" :offset offset
                #_"BinaryArithmeticNode" :value value
            )
        )
    )

    (defn- #_"long" DerivedOffsetInductionVariable''op-3l [#_"DerivedOffsetInductionVariable" this, #_"long" b, #_"long" o]
        (condp satisfies? (:value this)
            AddNode
                (+ b o)
            SubNode
                (if (= (InductionVariable'''valueNode-1 (:base this)) (:x (:value this)))
                    (- b o)
                    (- o b)
                )
        )
    )

    (defn- #_"ValueNode" DerivedOffsetInductionVariable''op-3v [#_"DerivedOffsetInductionVariable" this, #_"ValueNode" b, #_"ValueNode" o]
        (condp satisfies? (:value this)
            AddNode
                (MathUtil'add-3 (InductionVariable'''graph-1 this), b, o)
            SubNode
                (if (= (InductionVariable'''valueNode-1 (:base this)) (:x (:value this)))
                    (MathUtil'sub-3 (InductionVariable'''graph-1 this), b, o)
                    (MathUtil'sub-3 (InductionVariable'''graph-1 this), o, b)
                )
        )
    )

    (defm DerivedOffsetInductionVariable InductionVariable
        (#_"Direction" InductionVariable'''direction-1 [#_"DerivedOffsetInductionVariable" this]
            (InductionVariable'''direction-1 (:base this))
        )

        (#_"ValueNode" InductionVariable'''valueNode-1 [#_"DerivedOffsetInductionVariable" this]
            (:value this)
        )

        (#_"boolean" InductionVariable'''isConstantInit-1 [#_"DerivedOffsetInductionVariable" this]
            (and (satisfies? ConstantNode (:offset this)) (InductionVariable'''isConstantInit-1 (:base this)))
        )

        (#_"boolean" InductionVariable'''isConstantStride-1 [#_"DerivedOffsetInductionVariable" this]
            (InductionVariable'''isConstantStride-1 (:base this))
        )

        (#_"long" InductionVariable'''constantInit-1 [#_"DerivedOffsetInductionVariable" this]
            (DerivedOffsetInductionVariable''op-3l this, (InductionVariable'''constantInit-1 (:base this)), (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this))))
        )

        (#_"long" InductionVariable'''constantStride-1 [#_"DerivedOffsetInductionVariable" this]
            (if (and (satisfies? SubNode (:value this)) (= (InductionVariable'''valueNode-1 (:base this)) (:y (:value this))))
                (- (InductionVariable'''constantStride-1 (:base this)))
                (InductionVariable'''constantStride-1 (:base this))
            )
        )

        (#_"ValueNode" InductionVariable'''initNode-1 [#_"DerivedOffsetInductionVariable" this]
            (DerivedOffsetInductionVariable''op-3v this, (InductionVariable'''initNode-1 (:base this)), (:offset this))
        )

        (#_"ValueNode" InductionVariable'''strideNode-1 [#_"DerivedOffsetInductionVariable" this]
            (if (and (satisfies? SubNode (:value this)) (= (InductionVariable'''valueNode-1 (:base this)) (:y (:value this))))
                (Graph''addOrUniqueWithInputs-2 (InductionVariable'''graph-1 this), (NegateNode'create-1 (InductionVariable'''strideNode-1 (:base this))))
                (InductionVariable'''strideNode-1 (:base this))
            )
        )

        (#_"ValueNode" InductionVariable'''exitValueNode-1 [#_"DerivedOffsetInductionVariable" this]
            (DerivedOffsetInductionVariable''op-3v this, (InductionVariable'''exitValueNode-1 (:base this)), (:offset this))
        )

        (#_"boolean" InductionVariable'''isConstantExtremum-1 [#_"DerivedOffsetInductionVariable" this]
            (and (satisfies? ConstantNode (:offset this)) (InductionVariable'''isConstantExtremum-1 (:base this)))
        )

        (#_"long" InductionVariable'''constantExtremum-1 [#_"DerivedOffsetInductionVariable" this]
            (DerivedOffsetInductionVariable''op-3l this, (InductionVariable'''constantExtremum-1 (:base this)), (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this))))
        )

        (#_"void" InductionVariable'''deleteUnusedNodes-1 [#_"DerivedOffsetInductionVariable" this]
            nil
        )
    )
)

(class-ns DerivedScaledInductionVariable [DerivedInductionVariable, InductionVariable]
    (defn #_"DerivedScaledInductionVariable" DerivedScaledInductionVariable'new-4 [#_"LoopEx" _loop, #_"InductionVariable" base, #_"ValueNode" scale, #_"ValueNode" value]
        (merge (DerivedScaledInductionVariable'class.) (DerivedInductionVariable'new-2 _loop, base)
            (hash-map
                #_"ValueNode" :scale scale
                #_"ValueNode" :value value
            )
        )
    )

    (defn #_"DerivedScaledInductionVariable" DerivedScaledInductionVariable'new-3 [#_"LoopEx" _loop, #_"InductionVariable" base, #_"NegateNode" value]
        (DerivedScaledInductionVariable'new-4 _loop, base, (ConstantNode'forIntegerStamp-3 (:stamp value), -1, (:graph value)), value)
    )

    (defm DerivedScaledInductionVariable InductionVariable
        (#_"ValueNode" InductionVariable'''valueNode-1 [#_"DerivedScaledInductionVariable" this]
            (:value this)
        )

        (#_"Direction" InductionVariable'''direction-1 [#_"DerivedScaledInductionVariable" this]
            (let [
                #_"Stamp" stamp (:stamp (:scale this))
            ]
                (when (satisfies? IntegerStamp stamp)
                    (cond
                        (IntegerStamp''isStrictlyPositive-1 stamp)                        (InductionVariable'''direction-1 (:base this))
                        (IntegerStamp''isStrictlyNegative-1 stamp) (Direction''opposite-1 (InductionVariable'''direction-1 (:base this)))
                    )
                )
            )
        )

        (#_"ValueNode" InductionVariable'''initNode-1 [#_"DerivedScaledInductionVariable" this]
            (MathUtil'mul-3 (InductionVariable'''graph-1 this), (InductionVariable'''initNode-1 (:base this)), (:scale this))
        )

        (#_"ValueNode" InductionVariable'''strideNode-1 [#_"DerivedScaledInductionVariable" this]
            (MathUtil'mul-3 (InductionVariable'''graph-1 this), (InductionVariable'''strideNode-1 (:base this)), (:scale this))
        )

        (#_"boolean" InductionVariable'''isConstantInit-1 [#_"DerivedScaledInductionVariable" this]
            (and (satisfies? ConstantNode (:scale this)) (InductionVariable'''isConstantInit-1 (:base this)))
        )

        (#_"boolean" InductionVariable'''isConstantStride-1 [#_"DerivedScaledInductionVariable" this]
            (and (satisfies? ConstantNode (:scale this)) (InductionVariable'''isConstantStride-1 (:base this)))
        )

        (#_"long" InductionVariable'''constantInit-1 [#_"DerivedScaledInductionVariable" this]
            (* (InductionVariable'''constantInit-1 (:base this)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:scale this))))
        )

        (#_"long" InductionVariable'''constantStride-1 [#_"DerivedScaledInductionVariable" this]
            (* (InductionVariable'''constantStride-1 (:base this)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:scale this))))
        )

        (#_"ValueNode" InductionVariable'''exitValueNode-1 [#_"DerivedScaledInductionVariable" this]
            (MathUtil'mul-3 (InductionVariable'''graph-1 this), (InductionVariable'''exitValueNode-1 (:base this)), (:scale this))
        )

        (#_"boolean" InductionVariable'''isConstantExtremum-1 [#_"DerivedScaledInductionVariable" this]
            (and (satisfies? ConstantNode (:scale this)) (InductionVariable'''isConstantExtremum-1 (:base this)))
        )

        (#_"long" InductionVariable'''constantExtremum-1 [#_"DerivedScaledInductionVariable" this]
            (* (InductionVariable'''constantExtremum-1 (:base this)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:scale this))))
        )

        (#_"void" InductionVariable'''deleteUnusedNodes-1 [#_"DerivedScaledInductionVariable" this]
            (GraphUtil'tryKillUnused-1 (:scale this))
            nil
        )
    )
)

(class-ns InfoElement []
    (defn #_"InfoElement" InfoElement'new-4 [#_"Stamp" stamp, #_"GuardingNode" guard, #_"ValueNode" proxifiedInput, #_"InfoElement" parent]
        (merge (InfoElement'class.)
            (hash-map
                #_"Stamp" :stamp stamp
                #_"GuardingNode" :guard guard
                #_"ValueNode" :proxifiedInput proxifiedInput
                #_"InfoElement" :parent parent
            )
        )
    )
)

(class-ns InlineDuringParsingPlugin [InlineInvokePlugin]
    (defn #_"InlineDuringParsingPlugin" InlineDuringParsingPlugin'new-0 []
        (InlineDuringParsingPlugin'class.)
    )

    ;;;
     ; Budget which when exceeded reduces the effective value of
     ; GraalOptions#inlineDuringParsingMaxDepth to #maxDepthAfterBudgetExceeded.
     ;;
    (def- #_"int" InlineDuringParsingPlugin'nodeBudget 2000)
    (def- #_"int" InlineDuringParsingPlugin'maxDepthAfterBudgetExceeded 3)

    (defn- #_"boolean" InlineDuringParsingPlugin'checkSize-3 [#_"ResolvedJavaMethod" method, #_"ValueNode*" args, #_"Graph" graph]
        (let [
            #_"int" n (loop-when-recur [n 1 #_"ISeq" s (seq args)] (some? s) [(if (satisfies? ConstantNode (first s)) (inc n) n) (next s)] => n)
        ]
            (<= (count (#_"ResolvedJavaMethod" .getCode method)) (* n GraalOptions'trivialInliningSize))
        )
    )

    ;;;
     ; Gets the inline depth of this context. A return value of 0 implies that this is the context for the parse root.
     ;;
    (defn- #_"int" InlineDuringParsingPlugin'getDepth-1 [#_"BytecodeParser" parser]
        (loop-when-recur [#_"int" depth 0 parser (:parent parser)] (some? parser) [(inc depth) (:parent parser)] => depth)
    )

    (defn- #_"boolean" InlineDuringParsingPlugin'checkInliningDepth-1 [#_"BytecodeParser" parser]
        (let [
            #_"int" nodeCount (Graph''getNodeCount-1 (:graph parser))
            #_"int" maxDepth GraalOptions'inlineDuringParsingMaxDepth
            maxDepth
                (if (and (< InlineDuringParsingPlugin'nodeBudget nodeCount) (< InlineDuringParsingPlugin'maxDepthAfterBudgetExceeded maxDepth))
                    InlineDuringParsingPlugin'maxDepthAfterBudgetExceeded
                    maxDepth
                )
        ]
            (< (InlineDuringParsingPlugin'getDepth-1 parser) maxDepth)
        )
    )

    (defm InlineDuringParsingPlugin InlineInvokePlugin
        (#_"InlineInvokeInfo" InlineInvokePlugin'''shouldInlineInvoke-4 [#_"InlineDuringParsingPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode*" args]
            (when (and (#_"ResolvedJavaMethod" .hasBytecodes method) (#_"ResolvedJavaType" .isLinked (#_"ResolvedJavaMethod" .getDeclaringClass method)) (#_"ResolvedJavaMethod" .canBeInlined method))
                ;; test force inlining first
                (cond
                    (#_"ResolvedJavaMethod" .shouldBeInlined method)
                        (InlineInvokeInfo'createStandardInlineInfo-1 method)
                    (and (not (#_"ResolvedJavaMethod" .isSynchronized method))
                        (InlineDuringParsingPlugin'checkSize-3 method, args, (:graph parser))
                        (InlineDuringParsingPlugin'checkInliningDepth-1 parser)
                    )
                        (InlineInvokeInfo'createStandardInlineInfo-1 method)
                )
            )
        )

        (#_"void" InlineInvokePlugin'''notifyBeforeInline-2 [#_"InlineDuringParsingPlugin" this, #_"ResolvedJavaMethod" methodToInline]
            nil
        )

        (#_"void" InlineInvokePlugin'''notifyAfterInline-2 [#_"InlineDuringParsingPlugin" this, #_"ResolvedJavaMethod" methodToInline]
            nil
        )

        (#_"void" InlineInvokePlugin'''notifyNotInlined-4 [#_"InlineDuringParsingPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke]
            nil
        )
    )
)

;;;
 ; Result of a {@link #shouldInlineInvoke inlining decision}.
 ;;
(class-ns InlineInvokeInfo []
    (defn- #_"InlineInvokeInfo" InlineInvokeInfo'new-2 [#_"ResolvedJavaMethod" methodToInline, #_"BytecodeProvider" intrinsicBytecodeProvider]
        (merge (InlineInvokeInfo'class.)
            (hash-map
                ;;;
                 ; The method to be inlined, or nil if the call site must not be inlined.
                 ;;
                #_"ResolvedJavaMethod" :methodToInline methodToInline
                ;;;
                 ; The provider of bytecode to be parsed for #getMethodToInline() if it is
                 ; an intrinsic for the original method (i.e. the {@code method} passed to
                 ; InlineInvokePlugin#shouldInlineInvoke).
                 ; A nil value indicates that this is not an intrinsic inlining.
                 ;;
                #_"BytecodeProvider" :intrinsicBytecodeProvider intrinsicBytecodeProvider
            )
        )
    )

    (defn #_"InlineInvokeInfo" InlineInvokeInfo'createStandardInlineInfo-1 [#_"ResolvedJavaMethod" methodToInline]
        (InlineInvokeInfo'new-2 methodToInline, nil)
    )

    (defn #_"InlineInvokeInfo" InlineInvokeInfo'createIntrinsicInlineInfo-1 [#_"ResolvedJavaMethod" methodToInline]
        (InlineInvokeInfo'new-2 methodToInline, HotSpot'defaultBytecodeProvider)
    )

    #_unused
    (defn #_"boolean" InlineInvokeInfo''allowsInlining-1 [#_"InlineInvokeInfo" this]
        (some? (:methodToInline this))
    )
)

;;;
 ; Represents a feasible concrete target for inlining, whose graph has been copied already and thus
 ; can be modified without affecting the original (usually cached) version.
 ;
 ; Instances of this class don't make sense in isolation but as part of an InlineInfo.
 ;;
(class-ns InlineableGraph [Inlineable]
    ;;;
     ; This method builds the IR nodes for the given {@code method} and canonicalizes them.
     ; Provided profiling info is mature, the resulting graph is cached. The caller is responsible
     ; for cloning before modification.
     ;;
    (defn- #_"Graph" InlineableGraph'parseBytecodes-3 [#_"ResolvedJavaMethod" method, #_"PhaseContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"Graph" graph (Graph'new-1 method)
            graph (Phase'''run-3 HotSpot'graphBuilderSuite, graph, context)
            graph (Phase'''run-3 (DeadCodeEliminationPhase'new-1 Optionality'Optional), graph, nil)
            graph (Phase'''run-3 canonicalizer, graph, context)
        ]
            graph
        )
    )

    (defn- #_"ArrayList<Node>" InlineableGraph'trackParameterUsages-2 [#_"ParameterNode" param, #_"ArrayList<Node>" parameterUsages]
        (let [
            #_"ArrayList<Node>" nodes (or parameterUsages (ArrayList.))
        ]
            (doseq [#_"Node" node (:nodeUsages param)]
                (#_"ArrayList" .add nodes, node)
            )
            nodes
        )
    )

    (defn- #_"Stamp" InlineableGraph'improvedStamp-2 [#_"ValueNode" arg, #_"ParameterNode" param]
        (let [
            #_"Stamp" joinedStamp (Stamp'''join-2 (:stamp param), (:stamp arg))
        ]
            (when (and (some? joinedStamp) (not= joinedStamp (:stamp param)))
                joinedStamp
            )
        )
    )

    ;;;
     ; This method detects:
     ;
     ; (1) constants among the arguments to the {@code invoke}
     ; (2) arguments with more precise type than that declared by the corresponding parameter
     ;
     ; The corresponding parameters are updated to reflect the above information. Before doing so,
     ; their usages are added to {@code parameterUsages} for later incremental canonicalization.
     ;
     ; @return nil if no incremental canonicalization is need, otherwise a list of nodes for such canonicalization
     ;;
    (defn- #_"ArrayList<Node>" InlineableGraph''replaceParamsWithMoreInformativeArguments-2 [#_"InlineableGraph" this, #_"InvokeNode" invoke]
        (let [
            #_"NodeInputList<ValueNode>" args (:arguments (:callTarget invoke))
        ]
            ;; param-nodes that aren't used (e.g. as a result of canonicalization) don't occur in 'params'.
            ;; Thus, in general, the sizes of 'params' and 'args' don't always match. Still, it's always possible
            ;; to pair a param-node with its corresponding arg-node using param.index() as index into 'args'.
            (loop-when [#_"ArrayList<Node>" usages nil #_"ISeq" s (seq (Graph''getNodes-2 (:graph this), ParameterNode))] (some? s) => usages
                (let [
                    #_"ParameterNode" param (first s)
                    usages
                        (when (seq (:nodeUsages param)) => usages
                            (let [
                                #_"ValueNode" arg (nth args (AbstractLocalNode''index-1 param))
                            ]
                                (if (satisfies? ConstantNode arg)
                                    (let [
                                        usages (InlineableGraph'trackParameterUsages-2 param, usages)
                                    ]
                                        ;; collect param usages before replacing the param
                                        (ยง ass! param (Node''replaceAtUsagesAndDelete-2 param, (Graph''add-2 (:graph this), (ConstantNode'forConstant-4 (:stamp arg), (:value arg), (:stableDimension arg), (:isDefaultStable arg)))))
                                        ;; param-node gone, leaving a gap in the sequence given by param.index()
                                        usages
                                    )
                                    (let [
                                        #_"Stamp" improved (InlineableGraph'improvedStamp-2 arg, param)
                                    ]
                                        (when (some? improved) => usages
                                            (ยง ass! param (ValueNode''setStamp-2 param, improved))
                                            (InlineableGraph'trackParameterUsages-2 param, usages)
                                        )
                                    )
                                )
                            )
                        )
                ]
                    (recur usages (next s))
                )
            )
        )
    )

    ;;;
     ; @return true iff one or more parameters {@code newGraph} were specialized to account for
     ;         a constant argument, or an argument with a more specific stamp
     ;;
    (defn- #_"boolean" InlineableGraph''specializeGraphToArguments-3 [#_"InlineableGraph" this, #_"InvokeNode" invoke, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"ArrayList<Node>" parameterUsages (InlineableGraph''replaceParamsWithMoreInformativeArguments-2 this, invoke)
        ]
            (if (some? parameterUsages)
                (do
                    (CanonicalizerPhase''applyIncremental-3i canonicalizer, (:graph this), parameterUsages)
                    true
                )
                (do
                    ;; TODO if args are not more concrete, inlining should be avoided in most cases or we
                    ;; could at least use the previous graph size + invoke probability to check the inlining
                    false
                )
            )
        )
    )

    (defn #_"InlineableGraph" InlineableGraph'new-4 [#_"ResolvedJavaMethod" method, #_"InvokeNode" invoke, #_"PhaseContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"InlineableGraph" this
                (merge (InlineableGraph'class.)
                    (hash-map
                        ;; TODO copying the graph is only necessary if it is modified or if it contains any invokes
                        #_"Graph" :graph (Graph'copy-1 (InlineableGraph'parseBytecodes-3 method, context, canonicalizer))
                        #_"FixedNodeProbabilityCache" :probabilites (FixedNodeProbabilityCache'new-0)
                    )
                )
        ]
            (InlineableGraph''specializeGraphToArguments-3 this, invoke, canonicalizer)
            this
        )
    )

    (defm InlineableGraph Inlineable
        (#_"int" Inlineable'''getNodeCount-1 [#_"InlineableGraph" this]
            (Graph''getNodeCount-1 (:graph this))
        )

        (#_"InvokeNode*" Inlineable'''getInvokes-1 [#_"InlineableGraph" this]
            (Graph''getInvokes-1 (:graph this))
        )

        (#_"double" Inlineable'''getProbability-2 [#_"InlineableGraph" this, #_"InvokeNode" invoke]
            (FixedNodeProbabilityCache''applyAsDouble-2 (:probabilites this), invoke)
        )
    )
)

;;;
 ; The space of inlining decisions is explored depth-first with the help of a stack realized by InliningData.
 ; At any point in time, the topmost element of that stack consists of:
 ;
 ; (1) the callsite under consideration is tracked as a MethodInvocation.
 ; (2) one or more CallsiteHolders, all of them associated to the callsite above. Why more than one?
 ; Depending on the type-profile for the receiver more than one concrete method may be feasible target.
 ;
 ; The bottom element in the stack consists of:
 ;
 ; (1) a single MethodInvocation (the {@link MethodInvocation#isRoot root} one, i.e. the unknown caller of the root graph)
 ; (2) a single CallsiteHolder (the root one, for the method on which inlining was called)
 ;;
(class-ns InliningData []
    (defn #_"InliningData" InliningData'new-3 [#_"Graph" rootGraph, #_"PhaseContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"InliningData" this
                (merge (InliningData'class.)
                    (hash-map
                        ;;;
                         ; Call hierarchy from outer most call (i.e. compilation unit) to inner most callee.
                         ;;
                        #_"ArrayDeque<CallsiteHolder>" :graphQueue (ArrayDeque.)
                        #_"ArrayDeque<MethodInvocation>" :invocationQueue (ArrayDeque.)
                        #_"PhaseContext" :context context
                        #_"CanonicalizerPhase" :canonicalizer canonicalizer
                        #_"Graph" :rootGraph rootGraph
                        #_"int" :maxGraphs 1
                    )
                )
        ]
            (#_"ArrayDeque" .push (:invocationQueue this), (MethodInvocation'new-4 nil, 1.0, 1.0, nil))
            (#_"ArrayDeque" .push (:graphQueue this), (CallsiteHolder'new-4 rootGraph, 1.0, 1.0, nil))
            this
        )
    )

    (defn #_"boolean" InliningData''hasUnprocessedGraphs-1 [#_"InliningData" this]
        (not (#_"ArrayDeque" .isEmpty (:graphQueue this)))
    )

    (defn- #_"CallsiteHolder" InliningData''currentGraph-1 [#_"InliningData" this]
        (#_"ArrayDeque" .peek (:graphQueue this))
    )

    (defn- #_"void" InliningData''popGraph-1 [#_"InliningData" this]
        (#_"ArrayDeque" .pop (:graphQueue this))
        nil
    )

    (defn- #_"void" InliningData''popGraphs-2 [#_"InliningData" this, #_"int" n]
        (dotimes [#_"int" i n]
            (#_"ArrayDeque" .pop (:graphQueue this))
        )
        nil
    )

    (defn- #_"MethodInvocation" InliningData''currentInvocation-1 [#_"InliningData" this]
        (#_"ArrayDeque" .peekFirst (:invocationQueue this))
    )

    (defn #_"boolean" InliningData'isFreshInstantiation-1 [#_"ValueNode" arg]
        (or (satisfies? AbstractNewObjectNode arg) (satisfies? AllocatedObjectNode arg) (satisfies? VirtualObjectNode arg))
    )

    (defn- #_"String" InliningData''checkTargetConditionsHelper-2 [#_"InliningData" this, #_"ResolvedJavaMethod" method]
        (cond
            (nil? method)
                "the method is not resolved"
            (#_"ResolvedJavaMethod" .isNative method)
                "it is a non-intrinsic native method"
            (#_"ResolvedJavaMethod" .isAbstract method)
                "it is an abstract method"
            (not (#_"ResolvedJavaType" .isInitialized (#_"ResolvedJavaMethod" .getDeclaringClass method)))
                "the method's class is not initialized"
            (not (#_"ResolvedJavaMethod" .canBeInlined method))
                "it is marked non-inlinable"
            (< GraalOptions'maximumRecursiveInlining (InliningData''countRecursiveInlining-2 this, method))
                "it exceeds the maximum recursive inlining depth"
            (OptimisticOptimizations''lessOptimisticThan-2 OptimisticOptimizations'ALL, (:optimisticOpts (:context this)))
                "the callee uses less optimistic optimizations than caller"
        )
    )

    (defn- #_"boolean" InliningData''checkTargetConditions-2 [#_"InliningData" this, #_"ResolvedJavaMethod" method]
        (nil? (InliningData''checkTargetConditionsHelper-2 this, method))
    )

    (defn- #_"InlineInfo" InliningData''getExactInlineInfo-3 [#_"InliningData" this, #_"InvokeNode" invoke, #_"ResolvedJavaMethod" targetMethod]
        (when (InliningData''checkTargetConditions-2 this, targetMethod)
            (ExactInlineInfo'new-2 invoke, targetMethod)
        )
    )

    ;;;
     ; Determines if inlining is possible at the given invoke node.
     ;
     ; @param invoke the invoke that should be inlined
     ; @return an instance of InlineInfo, or nil if no inlining is possible at the given invoke
     ;;
    (defn- #_"InlineInfo" InliningData''getInlineInfo-2 [#_"InliningData" this, #_"InvokeNode" invoke]
        (when (nil? (InliningUtil'checkInvokeConditions-1 invoke))
            (let [
                #_"MethodCallTargetNode" callTarget (:callTarget invoke)
                #_"ResolvedJavaMethod" targetMethod (:targetMethod callTarget)
            ]
                (cond
                    (or (= (:invokeKind callTarget) InvokeKind'Special) (#_"ResolvedJavaMethod" .canBeStaticallyBound targetMethod))
                        (InliningData''getExactInlineInfo-3 this, invoke, targetMethod)
                    (satisfies? ObjectStamp (:stamp (MethodCallTargetNode''receiver-1 callTarget)))
                        (let [
                            #_"ObjectStamp" receiverStamp (:stamp (MethodCallTargetNode''receiver-1 callTarget))
                        ]
                            (when-not (:always-nil? receiverStamp) ;; => don't inline if receiver is known to be nil
                                (let [
                                    #_"ResolvedJavaType" contextType (InvokeNode''getContextType-1 invoke)
                                    #_"ResolvedJavaType" holder (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod)
                                    holder
                                        (when (some? (:type receiverStamp)) => holder
                                            ;; the invoke target might be more specific than the holder (happens after inlining:
                                            ;; parameters lose their declared type...)
                                            (let [
                                                #_"ResolvedJavaType" receiverType (:type receiverStamp)
                                            ]
                                                (when (and (some? receiverType) (#_"ResolvedJavaType" .isAssignableFrom holder, receiverType)) => holder
                                                    (let [
                                                        holder receiverType
                                                    ]
                                                        (when (AbstractObjectStamp''isExactType-1 receiverStamp)
                                                            (let [
                                                                #_"ResolvedJavaMethod" resolvedMethod (#_"ResolvedJavaType" .resolveConcreteMethod holder, targetMethod, contextType)
                                                            ]
                                                                (when (some? resolvedMethod)
                                                                    (ยง return (InliningData''getExactInlineInfo-3 this, invoke, resolvedMethod))
                                                                )
                                                            )
                                                        )
                                                        holder
                                                    )
                                                )
                                            )
                                        )
                                ]
                                    (when (#_"ResolvedJavaType" .isArray holder)
                                        ;; arrays can be treated as objects
                                        (let [
                                            #_"ResolvedJavaMethod" resolvedMethod (#_"ResolvedJavaType" .resolveConcreteMethod holder, targetMethod, contextType)
                                        ]
                                            (when (some? resolvedMethod)
                                                (InliningData''getExactInlineInfo-3 this, invoke, resolvedMethod)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                )
            )
        )
    )

    (defn- #_"void" InliningData''doInline-3 [#_"InliningData" this, #_"CallsiteHolder" callerCallsiteHolder, #_"MethodInvocation" calleeInvocation]
        (let [
            #_"Graph" callerGraph (:graph callerCallsiteHolder)
            #_"EconomicSet<Node>" canonicalizedNodes (EconomicSet/create)
            _ (#_"EconomicSet" .addAll canonicalizedNodes, (:nodeUsages (InlineInfo'''invoke-1 (:callee calleeInvocation))))
            _ (#_"EconomicSet" .addAll canonicalizedNodes, (InlineInfo'''inline-1 (:callee calleeInvocation)))
            #_"int" mark (Graph''getMark-1 callerGraph)
        ]
            (CanonicalizerPhase''applyIncremental-3i (:canonicalizer this), callerGraph, canonicalizedNodes)

            ;; process invokes that are possibly created during canonicalization
            (doseq [#_"Node" newNode (Graph''getNodesSince-2 callerGraph, mark)]
                (when (satisfies? InvokeNode newNode)
                    (CallsiteHolder''pushInvoke-2 callerCallsiteHolder, newNode)
                )
            )

            (ยง ass! callerCallsiteHolder (CallsiteHolder''computeProbabilities-1 callerCallsiteHolder))
        )
        nil
    )

    ;;;
     ; This method attempts:
     ;
     ; (1) to inline at the callsite given by {@code calleeInvocation}, where that callsite belongs
     ; to the CallsiteHolderExplorable at the top of the #graphQueue maintained in this class
     ; (2) otherwise, to devirtualize the callsite in question
     ;
     ; @return true iff inlining was actually performed
     ;;
    (defn- #_"boolean" InliningData''tryToInline-3 [#_"InliningData" this, #_"MethodInvocation" calleeInvocation, #_"int" inliningDepth]
        (if (InliningPolicy'isWorthInlining-3 calleeInvocation, inliningDepth, true)
            (do
                (InliningData''doInline-3 this, (InliningData''currentGraph-1 this), calleeInvocation)
                true
            )
            (do
                (when (OptimisticOptimizations''devirtualizeInvokes-1 (:optimisticOpts (:context this)))
                    (InlineInfo'''tryToDevirtualizeInvoke-1 (:callee calleeInvocation))
                )
                false
            )
        )
    )

    (defn- #_"this" InliningData''pushInvocationAndGraphs-2 [#_"InliningData" this, #_"MethodInvocation" methodInvocation]
        (#_"ArrayDeque" .addFirst (:invocationQueue this), methodInvocation)
        (let [
            #_"int" n (InlineInfo'''numberOfMethods-1 (:callee methodInvocation))
            this (assoc this :maxGraphs (+ (:maxGraphs this) n))
        ]
            (dotimes [#_"int" i n]
                (#_"ArrayDeque" .push (:graphQueue this), (MethodInvocation''buildCallsiteHolderForElement-2 methodInvocation, i))
            )
            this
        )
    )

    ;;;
     ; Gets the freshly instantiated arguments.
     ;
     ; A freshly instantiated argument is either:
     ;
     ; (1) an InliningData#isFreshInstantiation(ValueNode)
     ; (2) a fixed-param, i.e. a ParameterNode receiving a freshly instantiated argument
     ;
     ; @return the positions of freshly instantiated arguments in the argument list of the
     ;         {@code invoke}, or nil if no such positions exist.
     ;;
    (defn- #_"BitSet" InliningData'freshlyInstantiatedArguments-2 [#_"InvokeNode" invoke, #_"{ParameterNode}" fixedParams]
        (loop-when [#_"BitSet" bits nil #_"int" i 0 #_"ISeq" s (seq (:arguments (:callTarget invoke)))] (some? s) => bits
            (let [
                #_"ValueNode" arg (first s)
                bits
                    (when (or (InliningData'isFreshInstantiation-1 arg) (and (satisfies? ParameterNode arg) (contains? fixedParams arg))) => bits
                        (let [
                            bits (or bits (BitSet.))
                        ]
                            (#_"BitSet" .set bits, i)
                            bits
                        )
                    )
            ]
                (recur bits (inc i) (next s))
            )
        )
    )

    ;;;
     ; This method picks one of the callsites belonging to the current CallsiteHolderExplorable.
     ; Provided the callsite qualifies to be analyzed for inlining, this method prepares a new
     ; stack top in InliningData for such callsite, which comprises:
     ;
     ; - preparing a summary of feasible targets, i.e. preparing an InlineInfo
     ; - based on it, preparing the stack top proper which consists of:
     ;
     ; -- one MethodInvocation
     ; -- a CallsiteHolder for each feasible target
     ;
     ; The thus prepared "stack top" is needed by #moveForward() to explore the space of
     ; inlining decisions (each decision one of: backtracking, delving, inlining).
     ;
     ; The InlineInfo used to get things rolling is kept around in the MethodInvocation,
     ; it will be needed in case of inlining.
     ;;
    (defn- #_"InliningData" InliningData''processNextInvoke-1 [#_"InliningData" this]
        (let [
            #_"CallsiteHolder" callsiteHolder (InliningData''currentGraph-1 this)
            #_"InvokeNode" invoke (CallsiteHolder''popInvoke-1 callsiteHolder)
            #_"InlineInfo" info (InliningData''getInlineInfo-2 this, invoke)
        ]
            (when (some? info) => this
                (InlineInfo'''populateInlinableElements-4 info, (:context this), (:graph (InliningData''currentGraph-1 this)), (:canonicalizer this))
                (let [
                    #_"double" invokeProbability (CallsiteHolder''invokeProbability-2 callsiteHolder, invoke)
                    #_"double" invokeRelevance (CallsiteHolder''invokeRelevance-2 callsiteHolder, invoke)
                ]
                    (InliningData''pushInvocationAndGraphs-2 this, (MethodInvocation'new-4 info, invokeProbability, invokeRelevance, (InliningData'freshlyInstantiatedArguments-2 invoke, (:fixedParams callsiteHolder))))
                )
            )
        )
    )

    (defn- #_"this" InliningData''popInvocation-1 [#_"InliningData" this]
        (let [
            this (assoc this :maxGraphs (- (:maxGraphs this) (InlineInfo'''numberOfMethods-1 (:callee (#_"ArrayDeque" .peekFirst (:invocationQueue this))))))
        ]
            (#_"ArrayDeque" .removeFirst (:invocationQueue this))
            this
        )
    )

    (defn #_"int" InliningData''countRecursiveInlining-2 [#_"InliningData" this, #_"ResolvedJavaMethod" method]
        (loop-when-recur [#_"int" n 0 #_"ISeq" s (seq (:graphQueue this))]
                         (some? s)
                         [(if (= method (CallsiteHolder''method-1 (first s))) (inc n) n) (next s)]
                      => n
        )
    )

    (defn #_"int" InliningData''inliningDepth-1 [#_"InliningData" this]
        (dec (#_"ArrayDeque" .size (:invocationQueue this)))
    )

    ;;;
     ; The stack realized by InliningData grows and shrinks as choices are made among the
     ; alternatives below:
     ;
     ; (1) not worth inlining: pop stack top, which comprises:
     ;
     ; - pop any remaining graphs not yet delved into
     ; - pop the current invocation
     ;
     ; (2) {@link #processNextInvoke() delve} into one of the callsites hosted in the current graph,
     ; such callsite is explored next by #moveForward()
     ;
     ; (3) {@link #tryToInline(MethodInvocation, int) try to inline}: move past the current graph
     ; (remove it from the topmost element)
     ;
     ; - if that was the last one then {@link #tryToInline(MethodInvocation, int) try to inline}
     ; the callsite under consideration (i.e. the "current invocation")
     ; - whether inlining occurs or not, that callsite is removed from the top of InliningData
     ;
     ; Some facts about the alternatives above:
     ;
     ; - the first step amounts to backtracking, the 2nd one to depth-search, and the 3rd one also
     ; involves backtracking (however possibly after inlining)
     ; - the choice of abandon-and-backtrack or delve-into depends on
     ; InliningPolicy#isWorthInlining and InliningPolicy#continueInlining
     ; - the 3rd choice is picked whenever none of the previous choices are made
     ;
     ; @return true iff inlining was actually performed
     ;;
    (defn #_"boolean" InliningData''moveForward-1 [#_"InliningData" this]
        (let [
            #_"MethodInvocation" currentInvocation (InliningData''currentInvocation-1 this)
        ]
            (cond
                (and (not (MethodInvocation''isRoot-1 currentInvocation)) (not (InliningPolicy'isWorthInlining-3 currentInvocation, (InliningData''inliningDepth-1 this), false)))
                    (do
                        (InliningData''popGraphs-2 this, (- (MethodInvocation''totalGraphs-1 currentInvocation) (:processedGraphs currentInvocation)))
                        (ยง ass! this (InliningData''popInvocation-1 this))
                        false
                    )
                (and (CallsiteHolder''hasRemainingInvokes-1 (InliningData''currentGraph-1 this)) (InliningPolicy'continueInlining-1 (:graph (InliningData''currentGraph-1 this))))
                    (do
                        (ยง ass! this (InliningData''processNextInvoke-1 this))
                        false
                    )
                :else
                    (do
                        (InliningData''popGraph-1 this)
                        (and (not (MethodInvocation''isRoot-1 currentInvocation))
                            (do
                                ;; try to inline
                                (ยง ass! currentInvocation (MethodInvocation''incrementProcessedGraphs-1 currentInvocation))
                                (and (= (:processedGraphs currentInvocation) (MethodInvocation''totalGraphs-1 currentInvocation))
                                    (do
                                        ;; "all of currentInvocation's graphs processed" amounts to
                                        ;; "all concrete methods that come into question already had the callees they contain analyzed for inlining"
                                        (ยง ass! this (InliningData''popInvocation-1 this))
                                        (and (InliningData''tryToInline-3 this, currentInvocation, (inc (InliningData''inliningDepth-1 this)))
                                            ;; report real progress only if we inline into the root graph
                                            (= (:graph (InliningData''currentGraph-1 this)) (:rootGraph this))
                                        )
                                    )
                                )
                            )
                        )
                    )
            )
        )
    )
)

;;;
 ; Given a graph, visit all fixed nodes in dominator-based order, collecting in the process
 ; the InvokeNodes with MethodCallTargetNode. Such list of callsites is returned by #apply().
 ;;
(class-ns InliningIterator []
    (defn #_"InliningIterator" InliningIterator'new-1 [#_"Graph" graph]
        (merge (InliningIterator'class.)
            (hash-map
                #_"StartNode" :start (:start graph)
                #_"Deque<FixedNode>" :nodeQueue (ArrayDeque.)
                #_"NodeBitMap" :queuedNodes (NodeBitMap'new-1 graph)
            )
        )
    )

    (defn- #_"void" InliningIterator''forcedQueue-2 [#_"InliningIterator" this, #_"Node" node]
        (NodeBitMap''mark-2 (:queuedNodes this), node)
        (#_"Deque" .addFirst (:nodeQueue this), node)
        nil
    )

    (defn- #_"FixedNode" InliningIterator''nextQueuedNode-1 [#_"InliningIterator" this]
        (when (seq (:nodeQueue this))
            (#_"Deque" .removeFirst (:nodeQueue this))
        )
    )

    (defn- #_"boolean" InliningIterator''visitedAllEnds-2 [#_"InliningIterator" this, #_"AbstractMergeNode" merge]
        (loop-when [#_"int" i 0] (< i (AbstractMergeNode''forwardEndCount-1 merge)) => true
            (and (NodeBitMap''isMarked-2n (:queuedNodes this), (AbstractMergeNode''forwardEndAt-2 merge, i))
                (recur (inc i))
            )
        )
    )

    (defn- #_"void" InliningIterator''queueMerge-2 [#_"InliningIterator" this, #_"AbstractEndNode" end]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 end)
        ]
            (when (and (not (NodeBitMap''isMarked-2n (:queuedNodes this), merge)) (InliningIterator''visitedAllEnds-2 this, merge))
                (NodeBitMap''mark-2 (:queuedNodes this), merge)
                (#_"Deque" .add (:nodeQueue this), merge)
            )
        )
        nil
    )

    (defn- #_"void" InliningIterator''queue-2 [#_"InliningIterator" this, #_"Node" node]
        (when (and (some? node) (not (NodeBitMap''isMarked-2n (:queuedNodes this), node)))
            (InliningIterator''forcedQueue-2 this, node)
        )
        nil
    )

    (defn- #_"void" InliningIterator''queueSuccessors-2 [#_"InliningIterator" this, #_"FixedNode" x]
        (doseq [#_"Node" node (Node''successors-1 x)]
            (InliningIterator''queue-2 this, node)
        )
        nil
    )

    (defn #_"LinkedList<InvokeNode>" InliningIterator''apply-1 [#_"InliningIterator" this]
        (let [
            #_"LinkedList<InvokeNode>" invokes (LinkedList.)
        ]
            (InliningIterator''forcedQueue-2 this, (:start this))

            (loop-when-recur [#_"FixedNode" node (InliningIterator''nextQueuedNode-1 this)] (some? node) [(InliningIterator''nextQueuedNode-1 this)]
                (if (and (satisfies? InvokeNode node) (satisfies? MethodCallTargetNode (:callTarget node)))
                    (do
                        (when-not (= node (:start this))
                            (#_"LinkedList" .addLast invokes, node)
                        )
                        (InliningIterator''queueSuccessors-2 this, node)
                    )
                    (condp satisfies? node
                        LoopBeginNode     (InliningIterator''queueSuccessors-2 this, node)
                        LoopEndNode       nil ;; nothing to do
                        AbstractMergeNode (InliningIterator''queueSuccessors-2 this, node)
                        FixedWithNextNode (InliningIterator''queueSuccessors-2 this, node)
                        EndNode           (InliningIterator''queueMerge-2 this, node)
                        ControlSinkNode   nil ;; nothing to do
                        ControlSplitNode  (InliningIterator''queueSuccessors-2 this, node)
                        nil
                    )
                )
            )

            invokes
        )
    )
)

(class-ns InliningPhase [Phase]
    (defn #_"InliningPhase" InliningPhase'new-1 [#_"CanonicalizerPhase" canonicalizer]
        (merge (InliningPhase'class.)
            (hash-map
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
            )
        )
    )

    ;;;
     ; This method sets in motion the inlining machinery.
     ;;
    (defm InliningPhase Phase
        (#_"Graph" Phase'''run-3 [#_"InliningPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"InliningData" data (InliningData'new-3 graph, context, (:canonicalizer this))
            ]
                (loop-when [#_"int" n 1] (InliningData''hasUnprocessedGraphs-1 data)
                    (when (or (InliningData''moveForward-1 data) (< n GraalOptions'methodInlineBailoutLimit))
                        (recur (inc n))
                    )
                )
                graph
            )
        )
    )
)

(class-ns InstanceOfUsageReplacer [UsageReplacer]
    (defn #_"InstanceOfUsageReplacer" InstanceOfUsageReplacer'new-4 [#_"Instantiation" instantiation, #_"FloatingNode" instanceOf, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (merge (InstanceOfUsageReplacer'class.)
            (hash-map
                #_"Instantiation" :instantiation instantiation
                #_"FloatingNode" :instanceOf instanceOf
                #_"ValueNode" :trueValue trueValue
                #_"ValueNode" :falseValue falseValue
            )
        )
    )
)

;;;
 ; Replaces the usage of an InstanceOfNode or InstanceOfDynamicNode that does
 ; materializes the result of the type test.
 ;;
(class-ns MaterializationUsageReplacer [InstanceOfUsageReplacer, UsageReplacer]
    (defn #_"MaterializationUsageReplacer" MaterializationUsageReplacer'new-5 [#_"Instantiation" instantiation, #_"ValueNode" trueValue, #_"ValueNode" falseValue, #_"FloatingNode" instanceOf, #_"ConditionalNode" usage]
        (merge (MaterializationUsageReplacer'class.) (InstanceOfUsageReplacer'new-4 instantiation, instanceOf, trueValue, falseValue)
            (hash-map
                #_"ConditionalNode" :usage usage
            )
        )
    )

    (defm MaterializationUsageReplacer InstanceOfUsageReplacer
        (#_"void" InstanceOfUsageReplacer'''replaceUsingInstantiation-1 [#_"MaterializationUsageReplacer" this]
            (let [
                #_"ValueNode" newValue (Instantiation''asMaterialization-4 (:instantiation this), (:graph (:usage this)), (:trueValue this), (:falseValue this))
            ]
                (ยง ass! (:usage this) (Node''replaceAtUsages-2 (:usage this), newValue))
                (GraphUtil'killWithUnusedFloatingInputs-1 (:usage this))
            )
            nil
        )
    )

    (defm MaterializationUsageReplacer UsageReplacer
        (#_"void" UsageReplacer'''replace-3 [#_"MaterializationUsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode]
            (ValueNode'''inferStamp-1 newNode)
            (ยง ass! (:instantiation this) (Instantiation''initialize-4 (:instantiation this), newNode, (:trueValue this), (:falseValue this)))
            (ยง ass! (:usage this) (Node''replaceAtUsages-2 (:usage this), newNode))
            (GraphUtil'killWithUnusedFloatingInputs-1 (:usage this))
            nil
        )
    )
)

;;;
 ; Replaces the usage of an InstanceOfNode or InstanceOfDynamicNode that does
 ; not materialize the result of the type test.
 ;;
(class-ns NonMaterializationUsageReplacer [InstanceOfUsageReplacer, UsageReplacer]
    (defn #_"NonMaterializationUsageReplacer" NonMaterializationUsageReplacer'new-5 [#_"Instantiation" instantiation, #_"ValueNode" trueValue, #_"ValueNode" falseValue, #_"FloatingNode" instanceOf, #_"Node" usage]
        (merge (NonMaterializationUsageReplacer'class.) (InstanceOfUsageReplacer'new-4 instantiation, instanceOf, trueValue, falseValue)
            (hash-map
                #_"Node" :usage usage
            )
        )
    )

    (defm NonMaterializationUsageReplacer InstanceOfUsageReplacer
        (#_"void" InstanceOfUsageReplacer'''replaceUsingInstantiation-1 [#_"NonMaterializationUsageReplacer" this]
            (Node''replaceFirstInput-3 (:usage this), (:instanceOf this), (Instantiation''asCondition-2 (:instantiation this), (:trueValue this)))
            nil
        )
    )

    (defm NonMaterializationUsageReplacer UsageReplacer
        (#_"void" UsageReplacer'''replace-3 [#_"NonMaterializationUsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode]
            (ValueNode'''inferStamp-1 newNode)
            (ยง ass! (:instantiation this) (Instantiation''initialize-4 (:instantiation this), newNode, (:trueValue this), (:falseValue this)))
            (Node''replaceFirstInput-3 (:usage this), oldNode, (Instantiation''asCondition-2 (:instantiation this), (:trueValue this)))
            nil
        )
    )
)

;;;
 ; The result of instantiating an instanceof snippet. This enables a snippet instantiation to be
 ; re-used which reduces compile time and produces better code.
 ;;
(class-ns Instantiation []
    (defn #_"Instantiation" Instantiation'new-0 []
        (merge (Instantiation'class.)
            (hash-map
                #_"ValueNode" :result nil
                #_"LogicNode" :logic nil
                #_"ValueNode" :trueValue nil
                #_"ValueNode" :falseValue nil
            )
        )
    )

    ;;;
     ; Determines if the instantiation has occurred.
     ;;
    (defn #_"boolean" Instantiation''isInitialized-1 [#_"Instantiation" this]
        (some? (:result this))
    )

    (defn #_"this" Instantiation''initialize-4 [#_"Instantiation" this, #_"ValueNode" r, #_"ValueNode" t, #_"ValueNode" f]
        (let [
            this (assoc this :result r)
            this (assoc this :trueValue t)
            this (assoc this :falseValue f)
        ]
            this
        )
    )

    ;;;
     ; Gets the result of this instantiation as a condition.
     ;
     ; @param testValue the returned condition is true if the result is equal to this value
     ;;
    (defn #_"LogicNode" Instantiation''asCondition-2 [#_"Instantiation" this, #_"ValueNode" testValue]
        (if (satisfies? ConstantNode (:result this))
            (LogicConstantNode'forBoolean-2 (= (:value (:result this)) (ValueNode''asConstant-1 testValue)), (:graph (:result this)))
            (do
                (when-not (and (some? (:logic this)) (satisfies? CompareNode (:logic this)) (= (:y (:logic this)) testValue))
                    ;; re-use previously generated condition if the trueValue for the test is the same
                    (ยง ass! this (assoc this :logic (CompareNode'createCompareNode-4g (:graph (:result this)), CanonicalCondition'EQ, (:result this), testValue)))
                )
                (:logic this)
            )
        )
    )

    ;;;
     ; Gets the result of the instantiation as a materialized value.
     ;
     ; @param t the true value for the materialization
     ; @param f the false value for the materialization
     ;;
    (defn #_"ValueNode" Instantiation''asMaterialization-4 [#_"Instantiation" this, #_"Graph" graph, #_"ValueNode" t, #_"ValueNode" f]
        (if (and (= t (:trueValue this)) (= f (:falseValue this)))
            ;; Can simply use the phi result if the same materialized values are expected.
            (:result this)
            (Graph''add-2 graph, (ConditionalNode'new-3 (Instantiation''asCondition-2 this, (:trueValue this)), t, f))
        )
    )
)

;;;
 ; An expandable and indexable list of {@code int}s.
 ;
 ; This class avoids the boxing/unboxing incurred by {@code ArrayList<Integer>}.
 ;;
(class-ns IntList []
    ;;;
     ; Creates an int list with a specified initial array.
     ;
     ; @param array the initial array used for the list (no copy is made)
     ; @param size the initial {@linkplain #size() size} of the list (must be less than or equal to {@code array.length})
     ;;
    (defn #_"IntList" IntList'new-2 [#_"int[]" array, #_"int" size]
        (merge (IntList'class.)
            (hash-map
                #_"int[]" :array array
                #_"int" :size size
            )
        )
    )

    ;;;
     ; Creates an int list with a specified initial capacity.
     ;;
    (defn #_"IntList" IntList'new-1 [#_"int" capacity]
        (IntList'new-2 (int-array capacity), 0)
    )

    ;;;
     ; Makes a new int list by copying a range from a given int list.
     ;
     ; @param other the list from which a range of values is to be copied into the new list
     ; @param startIndex the index in {@code other} at which to start copying
     ; @param length the number of values to copy from {@code other}
     ; @return a new int list whose {@linkplain #size() size} and capacity is {@code length}
     ;;
    (defn #_"IntList" IntList'copy-3 [#_"IntList" other, #_"int" startIndex, #_"int" length]
        (IntList'copy-4 other, startIndex, length, length)
    )

    ;;;
     ; Makes a new int list by copying a range from a given int list.
     ;
     ; @param other the list from which a range of values is to be copied into the new list
     ; @param startIndex the index in {@code other} at which to start copying
     ; @param length the number of values to copy from {@code other}
     ; @param capacity the initial capacity of the new int list (must be greater or equal to {@code length})
     ; @return a new int list whose {@linkplain #size() size} is {@code length}
     ;;
    (defn #_"IntList" IntList'copy-4 [#_"IntList" other, #_"int" startIndex, #_"int" length, #_"int" capacity]
        (if (zero? capacity)
            (IntList'new-2 (int-array 0), 0)
            (let [
                #_"int[]" array (int-array capacity)
            ]
                (System/arraycopy (:array other), startIndex, array, 0, length)
                (IntList'new-2 array, length)
            )
        )
    )

    ;;;
     ; Appends a value to the end of this list, increasing its {@linkplain #size() size} by 1.
     ;
     ; @param value the value to append
     ;;
    (defn #_"this" IntList''add-2 [#_"IntList" this, #_"int" value]
        (let [
            this
                (when (= (:size this) (count (:array this))) => this
                    (assoc this :array (Arrays/copyOf (:array this), (inc (quot (* (:size this) 3) 2))))
                )
        ]
            (aset (:array this) (:size this) value)
            (update this :size inc)
        )
    )

    ;;;
     ; Gets the value in this list at a given index.
     ;;
    (defn #_"int" IntList''get-2 [#_"IntList" this, #_"int" index]
        (when (< index (:size this)) => (throw (IndexOutOfBoundsException. (str "Index: " index ", Size: " (:size this))))
            (nth (:array this) index)
        )
    )

    ;;;
     ; Sets a value at a given index in this list.
     ;;
    (defn #_"void" IntList''set-3 [#_"IntList" this, #_"int" index, #_"int" value]
        (when (< index (:size this)) => (throw (IndexOutOfBoundsException. (str "Index: " index ", Size: " (:size this))))
            (aset (:array this) index value)
        )
        nil
    )

    ;;;
     ; Adjusts the {@linkplain #size() size} of this int list.
     ;
     ; If {@code size < size()}, the size is changed to {@code size}. If {@code size > size()},
     ; sufficient 0 elements are {@linkplain #add(int) added} until {@code size() == size}.
     ;
     ; @param size the new size of this int list
     ;;
    (defn #_"IntList" IntList''setSize-2 [#_"IntList" this, #_"int" size]
        (cond
            (< size (:size this)) (assoc this :size size)
            (< (:size this) size) (assoc this :array (Arrays/copyOf (:array this), size))
            :else                        this
        )
    )
)

;;;
 ; Represents an interval in the linear scan register allocator.
 ;;
(class-ns Interval []
    (def #_"int" Interval'END_MARKER_OPERAND_NUMBER Integer/MIN_VALUE)

    (defn #_"Interval" Interval''assignLocation-2 [#_"Interval" this, #_"AllocatableValue" newLocation]
        (assoc this :location (if (and (instance? RegisterValue newLocation) (= (#_"Value" .getValueKind newLocation) LIRKind'Illegal) (not (= (:kind this) LIRKind'Illegal))) (#_"Register" .asValue (#_"RegisterValue" .getRegister newLocation), (:kind this)) newLocation))
    )

    ;;;
     ; Returns true is this is the sentinel interval that denotes the end of an interval list.
     ;;
    (defn #_"boolean" Interval''isEndMarker-1 [#_"Interval" this]
        (= (:operandNumber this) Interval'END_MARKER_OPERAND_NUMBER)
    )

    (defn #_"Interval" Interval''setKind-2 [#_"Interval" this, #_"ValueKind" kind]
        (assoc this :kind kind)
    )

    (defn #_"int" Interval''from-1 [#_"Interval" this]
        (:from (:first this))
    )

    (defn #_"int" Interval''to-1 [#_"Interval" this]
        (when (= (:cachedTo this) -1)
            (ยง ass! this (assoc this :cachedTo (Interval''calcTo-1 this)))
        )
        (:cachedTo this)
    )

    (defn #_"Interval" Interval''setLocationHint-2 [#_"Interval" this, #_"Interval" interval]
        (assoc this :locationHint interval)
    )

    (defn #_"boolean" Interval''isSplitParent-1 [#_"Interval" this]
        (= (:splitParent this) this)
    )

    (defn #_"boolean" Interval''isSplitChild-1 [#_"Interval" this]
        (not= (:splitParent this) this)
    )

    ;;;
     ; Gets the canonical spill slot for this interval.
     ;;
    (defn #_"AllocatableValue" Interval''spillSlot-1 [#_"Interval" this]
        (:spillSlot (:splitParent this))
    )

    (defn #_"void" Interval''setSpillSlot-2 [#_"Interval" this, #_"AllocatableValue" slot]
        (ยง ass! (:spillSlot (:splitParent this)) slot)
        nil
    )

    (defn #_"Interval" Interval''currentSplitChild-1 [#_"Interval" this]
        (:currentSplitChild (:splitParent this))
    )

    (defn #_"void" Interval''makeCurrentSplitChild-1 [#_"Interval" this]
        (ยง ass! (:currentSplitChild (:splitParent this)) this)
        nil
    )

    (defn #_"Interval" Interval''setInsertMoveWhenActivated-2 [#_"Interval" this, #_"boolean" b]
        (assoc this :insertMoveWhenActivated b)
    )

    ;; for spill optimization
    (defn #_"SpillState" Interval''spillState-1 [#_"Interval" this]
        (:spillState (:splitParent this))
    )

    (defn #_"int" Interval''spillDefinitionPos-1 [#_"Interval" this]
        (:spillDefinitionPos (:splitParent this))
    )

    (defn #_"void" Interval''setSpillState-2 [#_"Interval" this, #_"SpillState" state]
        (ยง ass! (:spillState (:splitParent this)) state)
        nil
    )

    (defn #_"void" Interval''setSpillDefinitionPos-2 [#_"Interval" this, #_"int" pos]
        (ยง ass! (:spillDefinitionPos (:splitParent this)) pos)
        nil
    )

    ;; returns true if this interval has a shadow copy on the stack that is always correct
    (defn #_"boolean" Interval''alwaysInMemory-1 [#_"Interval" this]
        (and (contains? SpillState'ALWAYS_IN_MEMORY (Interval''spillState-1 this)) (not (Interval''canMaterialize-1 this)))
    )

    (defn #_"void" Interval''removeFirstUsePos-1 [#_"Interval" this]
        (UsePosList''removeLowestUsePos-1 (:usePosList this))
        nil
    )

    (defn #_"Interval" Interval''rewindRange-1 [#_"Interval" this]
        (assoc this :current (:first this))
    )

    (defn #_"Interval" Interval''nextRange-1 [#_"Interval" this]
        (assoc this :current (:next (:current this)))
    )

    (defn #_"int" Interval''currentFrom-1 [#_"Interval" this]
        (:from (:current this))
    )

    (defn #_"int" Interval''currentTo-1 [#_"Interval" this]
        (:to (:current this))
    )

    (defn #_"boolean" Interval''currentAtEnd-1 [#_"Interval" this]
        (Range''isEndMarker-1 (:current this))
    )

    (defn #_"boolean" Interval''currentIntersects-2 [#_"Interval" this, #_"Interval" it]
        (Range''intersects-2 (:current this), (:current it))
    )

    (defn #_"int" Interval''currentIntersectsAt-2 [#_"Interval" this, #_"Interval" it]
        (Range''intersectsAt-2 (:current this), (:current it))
    )

    (defn #_"Interval" Interval'new-4 [#_"AllocatableValue" operand, #_"int" operandNumber, #_"Interval" intervalEndMarker, #_"Range" rangeEndMarker]
        (let [
            #_"Interval" this
                (merge (Interval'class.)
                    (hash-map
                        ;;;
                         ; The register or variable for this interval prior to register allocation.
                         ;;
                        #_"AllocatableValue" :operand operand
                        ;;;
                         ; The operand number for this interval's {@linkplain #operand operand}.
                         ;;
                        #_"int" :operandNumber operandNumber
                        ;;;
                         ; The register or spill slot assigned to this interval.
                         ; In case of a spilled interval which is re-materialized this is Value#ILLEGAL.
                         ;;
                        #_"AllocatableValue" :location (when (instance? RegisterValue operand) operand)
                        ;;;
                         ; The stack slot to which all splits of this interval are spilled if necessary.
                         ;;
                        #_"AllocatableValue" :spillSlot nil
                        ;;;
                         ; The kind of this interval.
                         ;;
                        #_"ValueKind" :kind LIRKind'Illegal
                        ;;;
                         ; The head of the list of ranges describing this interval. This list is sorted by
                         ; {@linkplain LIRInstruction#id instruction ids}.
                         ;;
                        #_"Range" :first rangeEndMarker
                        ;;;
                         ; List of (use-positions, register-priorities) pairs, sorted by use-positions.
                         ;;
                        #_"UsePosList" :usePosList (UsePosList'new-1i 4)
                        ;;;
                         ; Iterator used to traverse the ranges of an interval.
                         ;;
                        #_"Range" :current rangeEndMarker
                        ;;;
                         ; Link to next interval in a sorted list of intervals that ends with LinearScan.intervalEndMarker.
                         ;;
                        #_"Interval" :next intervalEndMarker
                        ;;;
                         ; The linear-scan state of this interval.
                         ;;
                        #_"IntervalState" :state nil
                        #_"int" :cachedTo -1 ;; cached value: to of last range (-1: not cached)
                        ;;;
                         ; The interval from which this one is derived. If this is a {@linkplain #isSplitParent() split parent}, it points to itself.
                         ;;
                        #_"Interval" :splitParent nil
                        ;;;
                         ; List of all intervals that are split off from this interval. This is only used if this is a {@linkplain #isSplitParent() split parent}.
                         ;;
                        #_"List<Interval>" :splitChildren (Collections/emptyList)
                        ;;;
                         ; Current split child that has been active or inactive last (always stored in split parents).
                         ;;
                        #_"Interval" :currentSplitChild nil
                        ;;;
                         ; Specifies if move is inserted between currentSplitChild and this interval when interval gets active the first time.
                         ;;
                        #_"boolean" :insertMoveWhenActivated false
                        ;;;
                         ; For spill move optimization.
                         ;;
                        #_"SpillState" :spillState SpillState'NoDefinitionFound
                        ;;;
                         ; Position where this interval is defined (if defined only once).
                         ;;
                        #_"int" :spillDefinitionPos -1
                        ;;;
                         ; This interval should be assigned the same location as the hint interval.
                         ;;
                        #_"Interval" :locationHint nil
                        ;;;
                         ; The value with which a spilled child interval can be re-materialized. Currently this must be a Constant.
                         ;;
                        #_"Constant" :materializedValue nil
                        ;;;
                         ; The number of times #addMaterializationValue(Constant) is called.
                         ;;
                        #_"int" :numMaterializationValuesAdded 0
                    )
                )
            this (assoc this :splitParent this)
            this (assoc this :currentSplitChild this)
        ]
            this
        )
    )

    ;;;
     ; Sets the value which is used for re-materialization.
     ;;
    (defn #_"this" Interval''addMaterializationValue-2 [#_"Interval" this, #_"Constant" value]
        (let [
            ;; => Interval is defined on multiple places -> no materialization is possible.
            this (assoc this :materializedValue (when (zero? (:numMaterializationValuesAdded this)) value))
        ]
            (update this :numMaterializationValuesAdded inc)
        )
    )

    ;;;
     ; Returns true if this interval can be re-materialized when spilled. This means that no
     ; spill-moves are needed. Instead of restore-moves the #materializedValue is restored.
     ;;
    (defn #_"boolean" Interval''canMaterialize-1 [#_"Interval" this]
        (some? (Interval''getMaterializedValue-1 this))
    )

    ;;;
     ; Returns a value which can be moved to a register instead of a restore-move from stack.
     ;;
    (defn #_"Constant" Interval''getMaterializedValue-1 [#_"Interval" this]
        (:materializedValue (:splitParent this))
    )

    (defn #_"int" Interval''calcTo-1 [#_"Interval" this]
        (loop-when-recur [#_"Range" r (:first this)] (not (Range''isEndMarker-1 (:next r))) [(:next r)] => (:to r))
    )

    (defn #_"Interval" Interval''locationHint-2 [#_"Interval" this, #_"boolean" searchSplitChild]
        (let [
            #_"Interval" hint (:locationHint this)
        ]
            (when searchSplitChild => hint
                (when (some? hint) ;; => no hint interval found that has a register assigned
                    (cond
                        (and (some? (:location hint)) (instance? RegisterValue (:location hint)))
                            hint
                        (seq (:splitChildren hint))
                            ;; search the first split child that has a register assigned
                            (loop-when [#_"int" i 0] (< i (count (:splitChildren hint)))
                                (let [
                                    #_"Interval" interval (nth (:splitChildren hint) i)
                                ]
                                    (if (and (some? (:location interval)) (instance? RegisterValue (:location interval)))
                                        interval
                                        (recur (inc i))
                                    )
                                )
                            )
                    )
                )
            )
        )
    )

    ;;;
     ; Sets the element at a given position of a list and ensures that this position exists.
     ;
     ; @param list the list to put the element into
     ; @param pos the position at which to insert the element
     ; @param x the element that should be inserted
     ;;
    (defn- #_"<T> void" Interval'atPutGrow-3 [#_"List<T>" list, #_"int" pos, #_"T" x]
        (while (< (count list) (inc pos))
            (#_"List" .add list, nil)
        )
        (#_"List" .set list, pos, x)
        nil
    )

    (defn #_"Interval" Interval''getSplitChildAtOpId-4 [#_"Interval" this, #_"int" opId, #_"OperandMode" mode, #_"LinearScan" allocator]
        (when (seq (:splitChildren this)) => this
            (let [
                ;; in outputMode, the end of the interval (opId == cur.to()) is not valid
                #_"int" toOffset (if (= mode OperandMode'DEF) 0 1)
            ]
                (loop-when [#_"int" i 0] (< i (count (:splitChildren this)))
                    (let [
                        #_"Interval" interval (nth (:splitChildren this) i)
                    ]
                        (when (and (<= (Interval''from-1 interval) opId) (< opId (+ (Interval''to-1 interval) toOffset))) => (recur (inc i))
                            (when (pos? i)
                                ;; exchange current split child to start of list (faster access for next call)
                                (Interval'atPutGrow-3 (:splitChildren this), i, (nth (:splitChildren this) 0))
                                (Interval'atPutGrow-3 (:splitChildren this), 0, interval)
                            )
                            interval ;; found
                        )
                    )
                )
            )
        )
    )

    ;; returns the interval that covers the given opId or nil if there is none
    (defn #_"Interval" Interval''getIntervalCoveringOpId-2 [#_"Interval" this, #_"int" opId]
        (when (< opId (Interval''from-1 this)) => this
            (let [
                #_"Interval" parent (:splitParent this)
            ]
                (loop-when [#_"Interval" result nil #_"int" i (dec (count (:splitChildren parent)))] (<= 0 i) => result
                    (let [
                        #_"Interval" interval (nth (:splitChildren parent) i)
                        result
                            (when (and (<= (Interval''from-1 interval) opId) (< opId (Interval''to-1 interval))) => result
                                interval
                            )
                    ]
                        (recur result (dec i))
                    )
                )
            )
        )
    )

    ;; returns the last split child that ends before the given opId
    (defn #_"Interval" Interval''getSplitChildBeforeOpId-2 [#_"Interval" this, #_"int" opId]
        (let [
            #_"Interval" parent (:splitParent this)
        ]
            (loop-when [#_"Interval" result nil #_"int" i (dec (count (:splitChildren parent)))] (<= 0 i) => result
                (let [
                    #_"Interval" interval (nth (:splitChildren parent) i)
                    result
                        (when (and (<= (Interval''to-1 interval) opId) (or (nil? result) (< (Interval''to-1 result) (Interval''to-1 interval)))) => result
                            interval
                        )
                ]
                    (recur result (dec i))
                )
            )
        )
    )

    (defn- #_"RegisterPriority" Interval''adaptPriority-2 [#_"Interval" this, #_"RegisterPriority" priority]
        ;; In case of re-materialized values we require that use-operands are registers,
        ;; because we don't have the value in a stack location.
        ;; (Note that ShouldHaveRegister means that the operand can also be a StackSlot).
        (when (and (= priority RegisterPriority'ShouldHaveRegister) (Interval''canMaterialize-1 this)) => priority
            RegisterPriority'MustHaveRegister
        )
    )

    ;; note: use positions are sorted descending = first use has highest index
    (defn #_"int" Interval''firstUsage-2 [#_"Interval" this, #_"RegisterPriority" minRegisterPriority]
        (loop-when [#_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => Integer/MAX_VALUE
            (let [
                #_"RegisterPriority" registerPriority (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i))
            ]
                (when (RegisterPriority'greaterEqual-2 registerPriority, minRegisterPriority) => (recur (dec i))
                    (UsePosList''usePos-2 (:usePosList this), i)
                )
            )
        )
    )

    (defn #_"int" Interval''nextUsage-3 [#_"Interval" this, #_"RegisterPriority" minRegisterPriority, #_"int" from]
        (loop-when [#_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => Integer/MAX_VALUE
            (let [
                #_"int" usePos (UsePosList''usePos-2 (:usePosList this), i)
            ]
                (when (and (<= from usePos) (RegisterPriority'greaterEqual-2 (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i)), minRegisterPriority)) => (recur (dec i))
                    usePos
                )
            )
        )
    )

    (defn #_"int" Interval''nextUsageExact-3 [#_"Interval" this, #_"RegisterPriority" exactRegisterPriority, #_"int" from]
        (loop-when [#_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => Integer/MAX_VALUE
            (let [
                #_"int" usePos (UsePosList''usePos-2 (:usePosList this), i)
            ]
                (when (and (<= from usePos) (= (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i)) exactRegisterPriority)) => (recur (dec i))
                    usePos
                )
            )
        )
    )

    (defn #_"int" Interval''previousUsage-3 [#_"Interval" this, #_"RegisterPriority" minRegisterPriority, #_"int" from]
        (loop-when [#_"int" prev -1 #_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => prev
            (let [
                #_"int" usePos (UsePosList''usePos-2 (:usePosList this), i)
            ]
                (when (<= usePos from) => prev
                    (let [
                        prev
                            (when (RegisterPriority'greaterEqual-2 (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i)), minRegisterPriority) => prev
                                usePos
                            )
                    ]
                        (recur prev (dec i))
                    )
                )
            )
        )
    )

    (defn #_"void" Interval''addUsePos-3 [#_"Interval" this, #_"int" pos, #_"RegisterPriority" registerPriority]
        ;; do not add use positions for precolored intervals because they are never used
        (when (and (not= registerPriority RegisterPriority'None) (satisfies? Variable (:operand this)))
            ;; note: addUse is called in descending order, so list gets sorted automatically by just appending new use positions
            (let [
                #_"int" len (UsePosList''size-1 (:usePosList this))
            ]
                (cond
                    (or (zero? len) (< pos (UsePosList''usePos-2 (:usePosList this), (dec len))))
                        (UsePosList''add-3 (:usePosList this), pos, registerPriority)
                    (RegisterPriority'lessThan-2 (UsePosList''registerPriority-2 (:usePosList this), (dec len)), registerPriority)
                        (UsePosList''setRegisterPriority-3 (:usePosList this), (dec len), registerPriority)
                )
            )
        )
        nil
    )

    (defn #_"this" Interval''addRange-3 [#_"Interval" this, #_"int" from, #_"int" to]
        (if (<= (:from (:first this)) to)
            ;; join intersecting ranges
            (let [
                _ (ยง ass! (:from (:first this)) (min from (:from (:first this))))
                _ (ยง ass! (:to (:first this)) (max to (:to (:first this))))
            ]
                this
            )
            ;; insert new range
            (assoc this :first (Range'new-3 from, to, (:first this)))
        )
    )

    (defn #_"Interval" Interval''newSplitChild-2 [#_"Interval" this, #_"LinearScan" allocator]
        ;; allocate new interval
        (let [
            #_"Interval" parent (:splitParent this)
            #_"Interval" result (LinearScan''createDerivedInterval-2 allocator, parent)
        ]
            (ยง ass! result (Interval''setKind-2 result, (:kind this)))

            (ยง ass result (assoc result :splitParent parent))
            (ยง ass! result (Interval''setLocationHint-2 result, parent))

            ;; insert new interval in children-list of parent
            (when (empty? (:splitChildren parent))
                ;; create new non-shared list
                (ยง ass parent (assoc parent :splitChildren (ArrayList.)))
                (#_"List" .add (:splitChildren parent), this)
            )
            (#_"List" .add (:splitChildren parent), result)

            result
        )
    )

    ;;;
     ; Splits this interval at a specified position and returns the remainder as a new <i>child</i>
     ; interval of this interval's {@linkplain #splitParent() parent} interval.
     ;
     ; When an interval is split, a bi-directional link is established between the original
     ; <i>parent</i> interval and the <i>children</i> intervals that are split off this interval.
     ; When a split child is split again, the new created interval is a direct child of the original
     ; parent. That is, there is no tree of split children stored, just a flat list. All split
     ; children are spilled to the same {@linkplain #spillSlot spill slot}.
     ;
     ; @param splitPos the position at which to split this interval
     ; @param allocator the register allocator context
     ; @return the child interval split off from this interval
     ;;
    (defn #_"Interval" Interval''split-3 [#_"Interval" this, #_"int" splitPos, #_"LinearScan" allocator]
        ;; allocate new interval
        (let [
            #_"Interval" result (Interval''newSplitChild-2 this, allocator)
            ;; split the ranges
            [#_"Range" prev #_"Range" cur]
                (loop-when-recur [prev nil cur (:first this)] (and (not (Range''isEndMarker-1 cur)) (<= (:to cur) splitPos)) [cur (:next cur)] => [prev cur])
        ]
            (if (< (:from cur) splitPos)
                (do
                    (ยง ass result (assoc result :first (Range'new-3 splitPos, (:to cur), (:next cur))))
                    (ยง ass! cur (assoc cur :to splitPos :next (:rangeEndMarker allocator)))
                )
                (do
                    (ยง ass result (assoc result :first cur))
                    (ยง ass! prev (assoc prev :next (:rangeEndMarker allocator)))
                )
            )
            (ยง ass result (assoc result :current (:first result)))
            (ยง ass! this (assoc this :cachedTo -1)) ;; clear cached value

            ;; split list of use positions
            (ยง ass result (assoc result :usePosList (UsePosList''splitAt-2 (:usePosList this), splitPos)))

            result
        )
    )

    ;; Returns true if the interval has any hole between holeFrom and holeTo
    ;; (even if the hole has only the length 1).
    (defn #_"boolean" Interval''hasHoleBetween-3 [#_"Interval" this, #_"int" holeFrom, #_"int" holeTo]
        (loop-when [#_"Range" r (:first this)] (not (Range''isEndMarker-1 r)) => false
            (cond
                (< holeFrom (:from r)) true  ;; hole-range starts before this range . hole
                (<= holeTo (:to r))    false ;; hole-range completely inside this range . no hole
                (<= holeFrom (:to r))  true  ;; overlapping of hole-range with this range . hole
                :else                  (recur (:next r))
            )
        )
    )

    (defn #_"List<Interval>" Interval''getSplitChildren-1 [#_"Interval" this]
        (ยง snap (:splitChildren this))
    )
)

;;;
 ; Iterate over all {@link Block blocks} of an interval.
 ;;
(class-ns IntervalBlockIterator [#_"Iterator" #_"<Block>"]
    (defn #_"IntervalBlockIterator" IntervalBlockIterator'new-2 [#_"LinearScan" allocator, #_"Interval" interval]
        (merge (IntervalBlockIterator'class.)
            (hash-map
                #_"LinearScan" :allocator allocator
                #_"Range" :range (:first interval)
                #_"Block" :block (LinearScan''blockForId-2 allocator, (:from (:first interval)))
            )
        )
    )

    (ยง override! #_"boolean" #_"Iterator." hasNext [#_"IntervalBlockIterator" this]
        (some? (:block this))
    )

    (ยง override! #_"Block" #_"Iterator." next [#_"IntervalBlockIterator" this]
        (let [
            #_"Block" currentBlock (:block this)
            #_"int" nextBlockIndex (inc (:linearScanNumber (:block this)))
        ]
            (if (< nextBlockIndex (count (LinearScan''sortedBlocks-1 (:allocator this))))
                (do
                    (ยง ass! this (assoc this :block (nth (LinearScan''sortedBlocks-1 (:allocator this)) nextBlockIndex)))
                    (when (<= (:to (:range this)) (LinearScan''getFirstLirInstructionId-2 (:allocator this), (:block this)))
                        (ยง ass! this (assoc this :range (:next (:range this))))
                        (if (Range''isEndMarker-1 (:range this))
                            (ยง ass! this (assoc this :block nil))
                            (ยง ass! this (assoc this :block (LinearScan''blockForId-2 (:allocator this), (:from (:range this)))))
                        )
                    )
                )
                (ยง ass! this (assoc this :block nil))
            )
            currentBlock
        )
    )
)

(class-ns IntervalWalker []
    ;;;
     ; Creates a new interval walker.
     ;
     ; @param allocator the register allocator context
     ; @param unhandledFixed the list of unhandled {@linkplain RegisterBinding#Fixed fixed} intervals
     ; @param unhandledAny the list of unhandled {@linkplain RegisterBinding#Any non-fixed} intervals
     ;;
    (defn #_"IntervalWalker" IntervalWalker'new-3 [#_"LinearScan" allocator, #_"Interval" unhandledFixed, #_"Interval" unhandledAny]
        (merge (IntervalWalker'class.)
            (hash-map
                #_"LinearScan" :allocator allocator
                ;;;
                 ; Sorted list of intervals, not live before the current position.
                 ;;
                #_"RegisterBindingLists" :unhandledLists (RegisterBindingLists'new-3 unhandledFixed, unhandledAny, (:intervalEndMarker allocator))
                ;;;
                 ; Sorted list of intervals, live at the current position.
                 ;;
                #_"RegisterBindingLists" :activeLists (RegisterBindingLists'new-3 (:intervalEndMarker allocator), (:intervalEndMarker allocator), (:intervalEndMarker allocator))
                ;;;
                 ; Sorted list of intervals in a life time hole at the current position.
                 ;;
                #_"RegisterBindingLists" :inactiveLists (RegisterBindingLists'new-3 (:intervalEndMarker allocator), (:intervalEndMarker allocator), (:intervalEndMarker allocator))
                ;;;
                 ; The current position (intercept point through the intervals).
                 ;;
                #_"int" :currentPosition -1
                ;;;
                 ; The binding of the current interval being processed.
                 ;;
                #_"RegisterBinding" :currentBinding nil
            )
        )
    )

    (defm IntervalWalker IntervalWalker
        (#_"boolean" IntervalWalker'''activateCurrent-2 [#_"IntervalWalker" this, #_"Interval" currentInterval]
            true
        )

        (#_"void" IntervalWalker'''walk-1 [#_"IntervalWalker" this]
            (ยง ass! this (IntervalWalker''walkTo-2 this, Integer/MAX_VALUE))
            nil
        )
    )

    (defn #_"void" IntervalWalker''removeFromList-2 [#_"IntervalWalker" this, #_"Interval" interval]
        (if (= (:state interval) IntervalState'Active)
            (ยง ass! (:activeLists this) (RegisterBindingLists''remove-3 (:activeLists this), RegisterBinding'Any, interval))
            (ยง ass! (:inactiveLists this) (RegisterBindingLists''remove-3 (:inactiveLists this), RegisterBinding'Any, interval))
        )
        nil
    )

    (defn- #_"void" IntervalWalker''intervalMoved-4 [#_"IntervalWalker" this, #_"Interval" interval, #_"IntervalState" from, #_"IntervalState" to]
        ;; intervalMoved() is called whenever an interval moves from one interval list to another.
        ;; In the implementation of this method it is prohibited to move the interval to any list.
        nil
    )

    (defn- #_"void" IntervalWalker''walkTo-4 [#_"IntervalWalker" this, #_"IntervalState" state, #_"int" from, #_"RegisterBinding" binding]
        (let [
            #_"Interval" prev (if (= state IntervalState'Active) (RegisterBindingLists''get-2 (:activeLists this), binding) (RegisterBindingLists''get-2 (:inactiveLists this), binding))
        ]
            (loop-when [#_"Interval" prevprev nil prev prev #_"Interval" _next prev] (<= (Interval''currentFrom-1 _next) from)
                (let [
                    #_"Interval" cur _next
                    _next (:next cur)
                    #_"boolean" rangeHasChanged
                        (loop-when-recur [rangeHasChanged false] (<= (Interval''currentTo-1 cur) from) [true] => rangeHasChanged
                            (ยง ass! cur (Interval''nextRange-1 cur))
                        )
                    ;; also handle move from inactive list to active list
                    rangeHasChanged (or rangeHasChanged (and (= state IntervalState'Inactive) (<= (Interval''currentFrom-1 cur) from)))
                ]
                    (when rangeHasChanged => (recur prev (:next cur) _next)
                        ;; remove cur from list
                        (if (nil? prevprev)
                            (if (= state IntervalState'Active)
                                (ยง ass! (:activeLists this) (RegisterBindingLists''set-3 (:activeLists this), binding, _next))
                                (ยง ass! (:inactiveLists this) (RegisterBindingLists''set-3 (:inactiveLists this), binding, _next))
                            )
                            (ยง ass! prevprev (assoc prevprev :next _next))
                        )
                        (let [
                            prev _next
                            [prevprev prev #_"IntervalState" newState]
                                (if (Interval''currentAtEnd-1 cur)
                                    ;; move to handled state (not maintained as a list)
                                    (let [
                                        newState IntervalState'Handled
                                    ]
                                        (ยง ass! cur (assoc cur :state newState))
                                        [prevprev prev newState]
                                    )
                                    (let [
                                        newState
                                            (if (<= (Interval''currentFrom-1 cur) from)
                                                (do
                                                    ;; sort into active list
                                                    (ยง ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), binding, cur))
                                                    IntervalState'Active
                                                )
                                                (do
                                                    ;; sort into inactive list
                                                    (ยง ass! (:inactiveLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:inactiveLists this), binding, cur))
                                                    IntervalState'Inactive
                                                )
                                            )
                                    ]
                                        (ยง ass! cur (assoc cur :state newState))
                                        (when (= prev cur) => [prevprev prev newState]
                                            [prev (:next cur) newState]
                                        )
                                    )
                                )
                        ]
                            (IntervalWalker''intervalMoved-4 this, cur, state, newState)
                            (recur prevprev prev _next)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" IntervalWalker''walkTo-3 [#_"IntervalWalker" this, #_"IntervalState" state, #_"int" from]
        (doseq [#_"RegisterBinding" binding RegisterBinding'VALUES]
            (IntervalWalker''walkTo-4 this, state, from, binding)
        )
        nil
    )

    ;;;
     ; Get the next interval from {@linkplain #unhandledLists} which starts before or at
     ; {@code toOpId}. The returned interval is removed and #currentBinding is set.
     ;
     ; @postcondition all intervals in {@linkplain #unhandledLists} start after {@code toOpId}.
     ;
     ; @return the next interval or nil if there is no {@linkplain #unhandledLists unhandled}
     ;         interval at position {@code toOpId}.
     ;;
    (defn- #_"Interval" IntervalWalker''nextInterval-2 [#_"IntervalWalker" this, #_"int" toOpId]
        (let [
            #_"Interval" any (:any (:unhandledLists this))
            #_"Interval" fixed (:fixed (:unhandledLists this))
            #_"RegisterBinding" binding
                (cond
                    (not (Interval''isEndMarker-1 any))
                        ;; intervals may start at same position . prefer fixed interval
                        (if (and (not (Interval''isEndMarker-1 fixed)) (<= (Interval''from-1 fixed) (Interval''from-1 any))) RegisterBinding'Fixed RegisterBinding'Any)
                    (not (Interval''isEndMarker-1 fixed))
                        RegisterBinding'Fixed
                    :else
                        (ยง return nil)
                )
            #_"Interval" interval (RegisterBindingLists''get-2 (:unhandledLists this), binding)
        ]
            (when-not (< toOpId (Interval''from-1 interval))
                (ยง ass! this (assoc this :currentBinding binding))
                (ยง ass! (:unhandledLists this) (RegisterBindingLists''set-3 (:unhandledLists this), binding, (:next interval)))
                (ยง ass! interval (assoc interval :next (:intervalEndMarker (:allocator this))))
                (ยง ass! interval (Interval''rewindRange-1 interval))
                interval
            )
        )
    )

    ;;;
     ; Move {@linkplain #unhandledLists unhandled} stack intervals to {@linkplain IntervalWalker #activeLists active}.
     ;
     ; Note that for {@linkplain RegisterBinding#Fixed fixed} and {@linkplain RegisterBinding#Any any} intervals
     ; this is done in #nextInterval(int).
     ;;
    (defn- #_"void" IntervalWalker''updateUnhandledStackIntervals-2 [#_"IntervalWalker" this, #_"int" opId]
        (let [
            #_"Interval" interval
                (loop-when [interval (RegisterBindingLists''get-2 (:unhandledLists this), RegisterBinding'Stack)] (and (not (Interval''isEndMarker-1 interval)) (<= (Interval''from-1 interval) opId)) => interval
                    (let [
                        #_"Interval" _next (:next interval)
                    ]
                        (if (< opId (Interval''to-1 interval))
                            (do
                                (ยง ass! interval (assoc interval :state IntervalState'Active))
                                (ยง ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), RegisterBinding'Stack, interval))
                                (IntervalWalker''intervalMoved-4 this, interval, IntervalState'Unhandled, IntervalState'Active)
                            )
                            (do
                                (ยง ass! interval (assoc interval :state IntervalState'Handled))
                                (IntervalWalker''intervalMoved-4 this, interval, IntervalState'Unhandled, IntervalState'Handled)
                            )
                        )
                        (recur _next)
                    )
                )
        ]
            (ยง ass! (:unhandledLists this) (RegisterBindingLists''set-3 (:unhandledLists this), RegisterBinding'Stack, interval))
        )
        nil
    )

    ;;;
     ; Walk up to {@code toOpId}.
     ;
     ; @postcondition #currentPosition is set to {@code toOpId}, #activeLists and #inactiveLists
     ;                are populated and Interval#states are up to date
     ;;
    (defn #_"this" IntervalWalker''walkTo-2 [#_"IntervalWalker" this, #_"int" toOpId]
        (let [
            this
                (loop-when [this this #_"Interval" interval (IntervalWalker''nextInterval-2 this, toOpId)] (some? interval) => this
                    (let [
                        #_"int" opId (Interval''from-1 interval)
                        ;; set currentPosition prior to call of walkTo
                        this (assoc this :currentPosition opId)
                    ]
                        ;; update unhandled stack intervals
                        (IntervalWalker''updateUnhandledStackIntervals-2 this, opId)

                        ;; call walkTo even if currentPosition == id
                        (IntervalWalker''walkTo-3 this, IntervalState'Active, opId)
                        (IntervalWalker''walkTo-3 this, IntervalState'Inactive, opId)

                        (ยง ass! interval (assoc interval :state IntervalState'Active))
                        (when (IntervalWalker'''activateCurrent-2 this, interval)
                            (ยง ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), (:currentBinding this), interval))
                            (IntervalWalker''intervalMoved-4 this, interval, IntervalState'Unhandled, IntervalState'Active)
                        )
                        (recur this (IntervalWalker''nextInterval-2 this, toOpId))
                    )
                )
            ;; set currentPosition prior to call of walkTo
            this (assoc this :currentPosition toOpId)
        ]
            (when (<= (:currentPosition this) (LinearScan''maxOpId-1 (:allocator this)))
                ;; update unhandled stack intervals
                (IntervalWalker''updateUnhandledStackIntervals-2 this, toOpId)

                ;; call walkTo if still in range
                (IntervalWalker''walkTo-3 this, IntervalState'Active, toOpId)
                (IntervalWalker''walkTo-3 this, IntervalState'Inactive, toOpId)
            )
            this
        )
    )
)

(class-ns LinearScanWalker [IntervalWalker]
    ;;;
     ; Only 10% of the lists in #spillIntervals are actually used. But when they are used,
     ; they can grow quite long. The maximum length observed was 45 (all numbers taken from a
     ; bootstrap run of Graal). Therefore, we initialize #spillIntervals with this marker
     ; value, and allocate a "real" list only on demand in #setUsePos.
     ;;
    (def- #_"List<Interval>" LinearScanWalker'EMPTY_LIST (Collections/emptyList))

    (defn #_"LinearScanWalker" LinearScanWalker'new-3 [#_"LinearScan" allocator, #_"Interval" unhandledFixedFirst, #_"Interval" unhandledAnyFirst]
        (let [
            #_"int" n (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator))
        ]
            (merge (LinearScanWalker'class.) (IntervalWalker'new-3 allocator, unhandledFixedFirst, unhandledAnyFirst)
                (hash-map
                    #_"Register[]" :availableRegs nil
                    #_"int[]" :usePos (int-array n)
                    #_"int[]" :blockPos (int-array n)
                    #_"List<Interval>[]" :spillIntervals (let [a (make-array List n) _ (dotimes [#_"int" i n] (aset a i LinearScanWalker'EMPTY_LIST))] a)
                    #_"MoveResolver" :moveResolver (LinearScan'''createMoveResolver-1 allocator) ;; for ordering spill moves
                    #_"int" :minReg 0
                    #_"int" :maxReg 0
                )
            )
        )
    )

    (defn #_"void" LinearScanWalker''initUseLists-2 [#_"LinearScanWalker" this, #_"boolean" onlyProcessUsePos]
        (doseq [#_"Register" register (:availableRegs this)]
            (let [
                #_"int" i (.number register)
            ]
                (aset (:usePos this) i Integer/MAX_VALUE)

                (when-not onlyProcessUsePos
                    (aset (:blockPos this) i Integer/MAX_VALUE)
                    (#_"List" .clear (nth (:spillIntervals this) i))
                )
            )
        )
        nil
    )

    (defn #_"int" LinearScanWalker''maxRegisterNumber-1 [#_"LinearScanWalker" this]
        (:maxReg this)
    )

    (defn #_"int" LinearScanWalker''minRegisterNumber-1 [#_"LinearScanWalker" this]
        (:minReg this)
    )

    (defn #_"boolean" LinearScanWalker''isRegisterInRange-2 [#_"LinearScanWalker" this, #_"int" reg]
        (<= (LinearScanWalker''minRegisterNumber-1 this) reg (LinearScanWalker''maxRegisterNumber-1 this))
    )

    (defn #_"void" LinearScanWalker''excludeFromUse-2 [#_"LinearScanWalker" this, #_"Interval" i]
        (let [
            #_"Value" location (:location i)
            #_"int" i1 (.number (#_"RegisterValue" .getRegister location))
        ]
            (when (LinearScanWalker''isRegisterInRange-2 this, i1)
                (aset (:usePos this) i1 0)
            )
        )
        nil
    )

    (defn #_"void" LinearScanWalker''setUsePos-4 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" usePos, #_"boolean" onlyProcessUsePos]
        (when-not (= usePos -1)
            (let [
                #_"int" i (.number (#_"RegisterValue" .getRegister (:location interval)))
            ]
                (when (LinearScanWalker''isRegisterInRange-2 this, i)
                    (when (< usePos (nth (:usePos this) i))
                        (aset (:usePos this) i usePos)
                    )
                    (when-not onlyProcessUsePos
                        (let [
                            #_"List<Interval>" list (nth (:spillIntervals this) i)
                        ]
                            (when (= list LinearScanWalker'EMPTY_LIST)
                                (ยง ass list (ArrayList.))
                                (aset (:spillIntervals this) i list)
                            )
                            (#_"List" .add list, interval)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" LinearScanWalker''setBlockPos-3 [#_"LinearScanWalker" this, #_"Interval" i, #_"int" blockPos]
        (when-not (= blockPos -1)
            (let [
                #_"int" reg (.number (#_"RegisterValue" .getRegister (:location i)))
            ]
                (when (LinearScanWalker''isRegisterInRange-2 this, reg)
                    (when (< blockPos (nth (:blockPos this) reg))
                        (aset (:blockPos this) reg blockPos)
                    )
                    (when (< blockPos (nth (:usePos this) reg))
                        (aset (:usePos this) reg blockPos)
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" LinearScanWalker''freeExcludeActiveFixed-1 [#_"LinearScanWalker" this]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''excludeFromUse-2 this, interval)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''freeExcludeActiveAny-1 [#_"LinearScanWalker" this]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''excludeFromUse-2 this, interval)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''freeCollectInactiveFixed-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (if (<= (Interval''to-1 current) (Interval''currentFrom-1 interval))
                (LinearScanWalker''setUsePos-4 this, interval, (Interval''currentFrom-1 interval), true)
                (LinearScanWalker''setUsePos-4 this, interval, (Interval''currentIntersectsAt-2 interval, current), true)
            )
        )
        nil
    )

    (defn #_"void" LinearScanWalker''freeCollectInactiveAny-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''setUsePos-4 this, interval, (Interval''currentIntersectsAt-2 interval, current), true)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''spillExcludeActiveFixed-1 [#_"LinearScanWalker" this]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''excludeFromUse-2 this, interval)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''spillBlockInactiveFixed-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (when (< (Interval''currentFrom-1 interval) (Interval''to-1 current))
                (LinearScanWalker''setBlockPos-3 this, interval, (Interval''currentIntersectsAt-2 interval, current))
            )
        )
        nil
    )

    (defn #_"void" LinearScanWalker''spillCollectActiveAny-2 [#_"LinearScanWalker" this, #_"RegisterPriority" registerPriority]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''setUsePos-4 this, interval, (min (Interval''nextUsage-3 interval, registerPriority, (:currentPosition this)) (Interval''to-1 interval)), false)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''spillCollectInactiveAny-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (when (Interval''currentIntersects-2 interval, current)
                (LinearScanWalker''setUsePos-4 this, interval, (min (Interval''nextUsage-3 interval, RegisterPriority'LiveAtLoopEnd, (:currentPosition this)) (Interval''to-1 interval)), false)
            )
        )
        nil
    )

    (defn #_"void" LinearScanWalker''insertMove-4 [#_"LinearScanWalker" this, #_"int" operandId, #_"Interval" srcIt, #_"Interval" dstIt]
        ;; Output all moves here. When source and target are equal, the move is optimized away later in assignRegNums.
        (let [
            #_"int" opId (& (inc operandId) (bit-not 1))
            #_"Block" opBlock (LinearScan''blockForId-2 (:allocator this), opId)
            ;; Calculate index of instruction inside instruction list of current block. The minimal index
            ;; (for a block with no spill moves) can be calculated, because the numbering of instructions is known.
            ;; When the block already contains spill moves, the index must be increased until the correct index is reached.
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), opBlock)
            #_"int" i
                (loop-when-recur [i (>> (- opId (:id (nth ops 0))) 1)]
                                   (not (= opId (:id (nth ops i))))
                                 (inc i)
                              => i
                )
        ]
            ;; insert new instruction before instruction at position index
            (ยง ass! (:moveResolver this) (MoveResolver''moveInsertPosition-3 (:moveResolver this), ops, i))
            (MoveResolver''addMapping-3i (:moveResolver this), srcIt, dstIt)
        )
        nil
    )

    (defn #_"int" LinearScanWalker''findOptimalSplitPos-4 [#_"LinearScanWalker" this, #_"Block" minBlock, #_"Block" maxBlock, #_"int" maxSplitPos]
        (let [
            #_"int" fromBlockNr (:linearScanNumber minBlock)
            #_"int" toBlockNr (:linearScanNumber maxBlock)
            ;; Try to split at end of maxBlock. If this would be after maxSplitPos, then use the begin of maxBlock.
            #_"int" optimalSplitPos (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), maxBlock) 2)
            optimalSplitPos
                (when (< maxSplitPos optimalSplitPos) => optimalSplitPos
                    (LinearScan''getFirstLirInstructionId-2 (:allocator this), maxBlock)
                )
        ]
            (loop-when [#_"int" minLoopDepth (Block''getLoopDepth-1 maxBlock) optimalSplitPos optimalSplitPos #_"int" i (dec toBlockNr)] (and (pos? minLoopDepth) (<= fromBlockNr i)) => optimalSplitPos
                (let [
                    #_"Block" block (LinearScan''blockAt-2 (:allocator this), i)
                    [minLoopDepth optimalSplitPos]
                        (when (< (Block''getLoopDepth-1 block) minLoopDepth) => [minLoopDepth optimalSplitPos]
                            ;; block with lower loop-depth found . split at the end of this block
                            [(Block''getLoopDepth-1 block) (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), block) 2)]
                        )
                ]
                    (recur minLoopDepth optimalSplitPos (dec i))
                )
            )
        )
    )

    (defn #_"int" LinearScanWalker''findOptimalSplitPos-5 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" minSplitPos, #_"int" maxSplitPos, #_"boolean" doLoopOptimization]
        ;; => Trivial case, no optimization of split position possible.
        (when-not (= minSplitPos maxSplitPos) => minSplitPos
            ;; Reason for using minSplitPos - 1: when the minimal split pos is exactly at the beginning of a block,
            ;; then minSplitPos is also a possible split position.
            ;; Use the block before as minBlock, because then minBlock.lastLirInstructionId() + 2 == minSplitPos.
            (let [
                #_"Block" minBlock (LinearScan''blockForId-2 (:allocator this), (dec minSplitPos))
                ;; Reason for using maxSplitPos - 1: otherwise there would be an assert on failure when an interval
                ;; ends at the end of the last block of the method
                ;; (in this case, maxSplitPos == allocator().maxLirOpId() + 2, and there is no block at this opId).
                #_"Block" maxBlock (LinearScan''blockForId-2 (:allocator this), (dec maxSplitPos))
            ]
                ;; => Split position cannot be moved to block boundary, so split as late as possible.
                (when-not (= minBlock maxBlock) => maxSplitPos
                    ;; => Do not move split position if the interval has a hole before maxSplitPos.
                    ;; Intervals resulting from Phi-functions have more than one definition (marked
                    ;; as mustHaveRegister) with a hole before each definition. When the register
                    ;; is needed for the second definition, an earlier reloading is unnecessary.
                    (when-not (and (Interval''hasHoleBetween-3 interval, (dec maxSplitPos), maxSplitPos) (not (LinearScan''isBlockBegin-2 (:allocator this), maxSplitPos))) => maxSplitPos
                        ;; Seach optimal block boundary between minSplitPos and maxSplitPos.
                        (let [
                            #_"int" optimalSplitPos
                                (when doLoopOptimization => -1
                                    ;; Loop optimization: if a loop-end marker is found between min- and max-position,
                                    ;; then split before this loop.
                                    (let [
                                        #_"int" loopEndPos (Interval''nextUsageExact-3 interval, RegisterPriority'LiveAtLoopEnd, (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), minBlock) 2))
                                    ]
                                        (when (< loopEndPos maxSplitPos) => -1
                                            ;; Loop-end marker found between min- and max-position. If it is not the end marker
                                            ;; for the same loop as the min-position, move the max-position to this loop block.
                                            ;; Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
                                            ;; of the interval (normally, only mustHaveRegister causes a reloading).
                                            (let [
                                                #_"Block" loopBlock (LinearScan''blockForId-2 (:allocator this), loopEndPos)
                                                #_"int" maxSpillPos (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), loopBlock) 2)
                                                optimalSplitPos (LinearScanWalker''findOptimalSplitPos-4 this, minBlock, loopBlock, maxSpillPos)
                                            ]
                                                (when-not (= optimalSplitPos maxSpillPos) => -1
                                                    optimalSplitPos
                                                )
                                            )
                                        )
                                    )
                                )
                        ]
                            (when (= optimalSplitPos -1) => optimalSplitPos
                                ;; not calculated by loop optimization
                                (LinearScanWalker''findOptimalSplitPos-4 this, minBlock, maxBlock, maxSplitPos)
                            )
                        )
                    )
                )
            )
        )
    )

    ;; Split an interval at the optimal position between minSplitPos and maxSplitPos in two parts:
    ;; (1) the left part has already a location assigned
    ;; (2) the right part is sorted into to the unhandled-list
    (defn #_"void" LinearScanWalker''splitBeforeUsage-4 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" minSplitPos, #_"int" maxSplitPos]
        (let [
            #_"int" optimalSplitPos (LinearScanWalker''findOptimalSplitPos-5 this, interval, minSplitPos, maxSplitPos, true)
        ]
            ;; => the split position would be just before the end of the interval, so no split necessary at all
            (when-not (and (= optimalSplitPos (Interval''to-1 interval)) (= (Interval''nextUsage-3 interval, RegisterPriority'MustHaveRegister, minSplitPos) Integer/MAX_VALUE))
                ;; must calculate this before the actual split is performed and before split position is moved to odd opId
                (let [
                    #_"boolean" moveNecessary (and (not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos)) (not (Interval''hasHoleBetween-3 interval, (dec optimalSplitPos), optimalSplitPos)))
                    optimalSplitPos
                        (when-not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos) => optimalSplitPos
                            ;; move position before actual instruction (odd opId)
                            (| (dec optimalSplitPos) 1)
                        )
                    #_"Interval" splitPart (Interval''split-3 interval, optimalSplitPos, (:allocator this))
                ]
                    (ยง ass! splitPart (Interval''setInsertMoveWhenActivated-2 splitPart, moveNecessary))
                    (ยง ass! (:unhandledLists this) (RegisterBindingLists''addToListSortedByStartAndUsePositions-3 (:unhandledLists this), RegisterBinding'Any, splitPart))
                )
            )
        )
        nil
    )

    (defn- #_"void" LinearScanWalker''changeSpillState-3 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" spillPos]
        (condp = (Interval''spillState-1 interval)
            SpillState'NoSpillStore
                (let [
                    #_"int" defLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), (Interval''spillDefinitionPos-1 interval)))
                    #_"int" spillLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), spillPos))
                ]
                    (if (< defLoopDepth spillLoopDepth)
                        ;; The loop depth of the spilling position is higher then the loop depth at
                        ;; the definition of the interval. Move write to memory out of loop.
                        (if GraalOptions'lirOptLSRAOptimizeSpillPosition
                            (Interval''setSpillState-2 interval, SpillState'SpillInDominator)  ;; find best spill position in the dominator tree
                            (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition) ;; store at definition of the interval
                        )
                        ;; The interval is currently spilled only once, so for now there is no reason
                        ;; to store the interval at the definition.
                        (Interval''setSpillState-2 interval, SpillState'OneSpillStore)
                    )
                )
            SpillState'OneSpillStore
                (let [
                    #_"int" defLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), (Interval''spillDefinitionPos-1 interval)))
                    #_"int" spillLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), spillPos))
                ]
                    (when (<= defLoopDepth spillLoopDepth)
                        (if GraalOptions'lirOptLSRAOptimizeSpillPosition
                            (Interval''setSpillState-2 interval, SpillState'SpillInDominator)  ;; the interval is spilled more then once
                            (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition) ;; it is better to store it to memory at the definition
                        )
                    )
                )
            nil
        )
        nil
    )

    ;; Split an interval at the optimal position between minSplitPos and maxSplitPos in two parts:
    ;;
    ;; (1) the left part has already a location assigned
    ;; (2) the right part is always on the stack and therefore ignored in further processing
    (defn #_"void" LinearScanWalker''splitForSpilling-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; calculate allowed range of splitting position
        (let [
            #_"int" maxSplitPos (:currentPosition this)
            #_"int" previousUsage (Interval''previousUsage-3 interval, RegisterPriority'ShouldHaveRegister, maxSplitPos)
            previousUsage
                (when (= previousUsage (:currentPosition this)) => previousUsage
                    ;; If there is a usage with ShouldHaveRegister priority at the current position
                    ;; fall back to MustHaveRegister priority. This only happens if register priority
                    ;; was downgraded to MustHaveRegister in #allocLockedRegister.
                    (Interval''previousUsage-3 interval, RegisterPriority'MustHaveRegister, maxSplitPos)
                )
            #_"int" minSplitPos (max (inc previousUsage) (Interval''from-1 interval))
        ]
            (if (= minSplitPos (Interval''from-1 interval))
                (do
                    ;; the whole interval is never used, so spill it entirely to memory
                    (LinearScan''assignSpillSlot-2 (:allocator this), interval)
                    (LinearScanWalker'''handleSpillSlot-2 this, interval)
                    (LinearScanWalker''changeSpillState-3 this, interval, minSplitPos)

                    ;; Also kick parent intervals out of register to memory when they have no use position.
                    ;; This avoids short interval in register surrounded by intervals in memory.
                    ;; Avoid useless moves from memory to register and back.
                    (loop-when [#_"Interval" parent interval] (and (some? parent) (Interval''isSplitChild-1 parent))
                        (let [
                            parent (Interval''getSplitChildBeforeOpId-2 parent, (Interval''from-1 parent))
                            parent
                                (when (instance? RegisterValue (:location parent)) => parent
                                    ;; => do not go further back, because the register is actually used by the interval
                                    (when (= (Interval''firstUsage-2 parent, RegisterPriority'ShouldHaveRegister) Integer/MAX_VALUE)
                                        ;; parent is never used, so kick it out of its assigned register
                                        (LinearScan''assignSpillSlot-2 (:allocator this), parent)
                                        (LinearScanWalker'''handleSpillSlot-2 this, parent)
                                        parent
                                    )
                                )
                        ]
                            (recur parent)
                        )
                    )
                )
                ;; search optimal split pos, split interval and spill only the right hand part
                (let [
                    #_"int" optimalSplitPos (LinearScanWalker''findOptimalSplitPos-5 this, interval, minSplitPos, maxSplitPos, false)
                    optimalSplitPos
                        (when-not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos) => optimalSplitPos
                            ;; move position before actual instruction (odd opId)
                            (| (dec optimalSplitPos) 1)
                        )
                    #_"Interval" spilledPart (Interval''split-3 interval, optimalSplitPos, (:allocator this))
                ]
                    (LinearScan''assignSpillSlot-2 (:allocator this), spilledPart)
                    (LinearScanWalker'''handleSpillSlot-2 this, spilledPart)
                    (LinearScanWalker''changeSpillState-3 this, spilledPart, optimalSplitPos)

                    (when-not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos)
                        (LinearScanWalker''insertMove-4 this, optimalSplitPos, interval, spilledPart)
                    )

                    ;; the currentSplitChild is needed later when moves are inserted for reloading
                    (Interval''makeCurrentSplitChild-1 spilledPart)
                )
            )
        )
        nil
    )

    (defm LinearScanWalker LinearScanWalker
        (#_"void" LinearScanWalker'''handleSpillSlot-2 [#_"LinearScanWalker" this, #_"Interval" interval]
            ;; Do nothing. Stack slots are not processed in this implementation.
            nil
        )
    )

    (defn #_"void" LinearScanWalker''splitStackInterval-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"int" minSplitPos (inc (:currentPosition this))
            #_"int" maxSplitPos (min (Interval''firstUsage-2 interval, RegisterPriority'ShouldHaveRegister) (Interval''to-1 interval))
        ]
            (LinearScanWalker''splitBeforeUsage-4 this, interval, minSplitPos, maxSplitPos)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''splitWhenPartialRegisterAvailable-3 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" registerAvailableUntil]
        (let [
            #_"int" minSplitPos (max (Interval''previousUsage-3 interval, RegisterPriority'ShouldHaveRegister, registerAvailableUntil) (inc (Interval''from-1 interval)))
        ]
            (LinearScanWalker''splitBeforeUsage-4 this, interval, minSplitPos, registerAvailableUntil)
        )
        nil
    )

    (defn #_"void" LinearScanWalker''splitAndSpillInterval-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"int" currentPos (:currentPosition this)
        ]
            (if (= (:state interval) IntervalState'Inactive)
                (do
                    ;; The interval is currently inactive, so no spill slot is needed for now.
                    ;; When the split part is activated, the interval has a new chance to get a register,
                    ;; so in the best case no stack slot is necessary.
                    (LinearScanWalker''splitBeforeUsage-4 this, interval, (inc currentPos), (inc currentPos))
                )
                ;; Search the position where the interval must have a register and split at the optimal position before.
                ;; The new created part is added to the unhandled list and will get a register when it is activated.
                (let [
                    #_"int" minSplitPos (inc currentPos)
                    #_"int" maxSplitPos (min (Interval''nextUsage-3 interval, RegisterPriority'MustHaveRegister, minSplitPos) (Interval''to-1 interval))
                ]
                    (LinearScanWalker''splitBeforeUsage-4 this, interval, minSplitPos, maxSplitPos)

                    (LinearScanWalker''splitForSpilling-2 this, interval)
                )
            )
        )
        nil
    )

    (defn #_"boolean" LinearScanWalker''allocFreeRegister-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (LinearScanWalker''initUseLists-2 this, true)
        (LinearScanWalker''freeExcludeActiveFixed-1 this)
        (LinearScanWalker''freeExcludeActiveAny-1 this)
        (LinearScanWalker''freeCollectInactiveFixed-2 this, interval)
        (LinearScanWalker''freeCollectInactiveAny-2 this, interval)
        ;; freeCollectUnhandled(fixedKind, cur);

        ;; usePos contains the start of the next interval that has this register assigned
        ;; (either as a fixed register or a normal allocated register in the past)
        ;; only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely

        (let [
            #_"Interval" locationHint (Interval''locationHint-2 interval, true)
            #_"Register" hint
                (when (and (some? locationHint) (some? (:location locationHint)) (instance? RegisterValue (:location locationHint)))
                    (#_"RegisterValue" .getRegister (:location locationHint))
                )
            ;; the register must be free at least until this position
            #_"int" regNeededUntil (inc (Interval''from-1 interval))
            #_"int" intervalTo (Interval''to-1 interval)
            [#_"Register" minFullReg #_"Register" maxPartialReg]
                (loop-when [minFullReg nil maxPartialReg nil #_"ISeq" s (seq (:availableRegs this))] (some? s) => [minFullReg maxPartialReg]
                    (let [
                        #_"Register" availableReg (first s)
                        #_"int" number (.number availableReg)
                        [minFullReg maxPartialReg]
                            (cond
                                (<= intervalTo (nth (:usePos this) number))
                                    ;; this register is free for the full interval
                                    (when (or (nil? minFullReg) (= availableReg hint) (and (< (nth (:usePos this) number) (nth (:usePos this) (.number minFullReg))) (not (= minFullReg hint)))) => [minFullReg maxPartialReg]
                                        [availableReg maxPartialReg]
                                    )
                                (< regNeededUntil (nth (:usePos this) number))
                                    ;; this register is at least free until regNeededUntil
                                    (when (or (nil? maxPartialReg) (= availableReg hint) (and (< (nth (:usePos this) (.number maxPartialReg)) (nth (:usePos this) number)) (not (= maxPartialReg hint)))) => [minFullReg maxPartialReg]
                                        [minFullReg availableReg]
                                    )
                                :else
                                    [minFullReg maxPartialReg]
                            )
                    ]
                        (recur minFullReg maxPartialReg (next s))
                    )
                )
            [#_"Register" reg #_"boolean" needSplit]
                (cond
                    (some? minFullReg)    [minFullReg false]
                    (some? maxPartialReg) [maxPartialReg true]
                    :else                 (ยง return false)
                )
            #_"int" splitPos (nth (:usePos this) (.number reg))
        ]
            (ยง ass! interval (Interval''assignLocation-2 interval, (#_"Register" .asValue reg, (:kind interval))))
            (when needSplit
                ;; register not available for full interval, so split it
                (LinearScanWalker''splitWhenPartialRegisterAvailable-3 this, interval, splitPos)
            )
            ;; only return true if interval is completely assigned
            true
        )
    )

    (defn #_"void" LinearScanWalker''splitAndSpillIntersectingIntervals-2 [#_"LinearScanWalker" this, #_"Register" reg]
        (dotimes [#_"int" i (count (nth (:spillIntervals this) (.number reg)))]
            (let [
                #_"Interval" interval (nth (nth (:spillIntervals this) (.number reg)) i)
            ]
                (IntervalWalker''removeFromList-2 this, interval)
                (LinearScanWalker''splitAndSpillInterval-2 this, interval)
            )
        )
        nil
    )

    ;; split an Interval and spill it to memory so that cur can be placed in a register
    (defn #_"void" LinearScanWalker''allocLockedRegister-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; the register must be free at least until this position
        (let [
            #_"int" firstUsage (Interval''firstUsage-2 interval, RegisterPriority'MustHaveRegister)
            #_"int" firstShouldHaveUsage (Interval''firstUsage-2 interval, RegisterPriority'ShouldHaveRegister)
            #_"int" regNeededUntil (min firstUsage (inc (Interval''from-1 interval)))
            #_"int" intervalTo (Interval''to-1 interval)
        ]
            ;; In the common case we don't spill registers that have _any_ use position that is
            ;; closer than the next use of the current interval, but if we can't spill the current
            ;; interval we weaken this strategy and also allow spilling of intervals that have a
            ;; non-mandatory requirements (no MustHaveRegister use position).
            (loop [#_"RegisterPriority" registerPriority RegisterPriority'LiveAtLoopEnd]
                ;; collect current usage of registers
                (LinearScanWalker''initUseLists-2 this, false)
                (LinearScanWalker''spillExcludeActiveFixed-1 this)
                (LinearScanWalker''spillBlockInactiveFixed-2 this, interval)
                (LinearScanWalker''spillCollectActiveAny-2 this, registerPriority)
                (LinearScanWalker''spillCollectInactiveAny-2 this, interval)

                (let [
                    #_"Register" ignore (when (and (some? (:location interval)) (instance? RegisterValue (:location interval))) (#_"RegisterValue" .getRegister (:location interval)))
                    #_"Register" reg
                        (loop-when [reg nil #_"ISeq" s (seq (:availableRegs this))] (some? s) => reg
                            (let [
                                #_"Register" available (first s)
                                reg (if (and (not= available ignore) (< regNeededUntil (nth (:usePos this) (.number available))) (or (nil? reg) (< (nth (:usePos this) (.number reg)) (nth (:usePos this) (.number available))))) available reg)
                            ]
                                (recur reg (next s))
                            )
                        )
                    #_"int" regUsePos (if (some? reg) (nth (:usePos this) (.number reg)) 0)
                ]
                    (if (<= regUsePos firstShouldHaveUsage)
                        (if (<= firstUsage (inc (Interval''from-1 interval)))
                            (if (= registerPriority RegisterPriority'LiveAtLoopEnd)
                                ;; Tool of last resort: we can not spill the current interval so we try
                                ;; to spill an active interval that has a usage but do not require a register.
                                (recur RegisterPriority'MustHaveRegister)
                                (do
                                    ;; assign a reasonable register and do a bailout in product mode to avoid errors
                                    (LinearScan''assignSpillSlot-2 (:allocator this), interval)
                                    (throw! "linear scan: no register found") ;; OutOfRegistersException
                                )
                            )
                            (LinearScanWalker''splitAndSpillInterval-2 this, interval)
                        )
                        (let [
                            #_"boolean" needSplit (<= (nth (:blockPos this) (.number reg)) intervalTo)
                            #_"int" splitPos (nth (:blockPos this) (.number reg))
                        ]
                            (ยง ass! interval (Interval''assignLocation-2 interval, (#_"Register" .asValue reg, (:kind interval))))
                            (when needSplit
                                ;; register not available for full interval : so split it
                                (LinearScanWalker''splitWhenPartialRegisterAvailable-3 this, interval, splitPos)
                            )
                            ;; perform splitting and spilling for all affected intervals
                            (LinearScanWalker''splitAndSpillIntersectingIntervals-2 this, reg)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"boolean" LinearScanWalker''noAllocationPossible-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (and (#_"RegisterConfig" .areAllAllocatableRegistersCallerSaved HotSpot'registerConfig)
            ;; fast calculation of intervals that can never get a register because
            ;; the next instruction is a call that blocks all registers
            ;; note: this only works if a call kills all registers

            ;; check if this interval is the result of a split operation (an interval got a register until this position)
            (let [
                #_"int" pos (Interval''from-1 interval)
            ]
                (and (CodeUtil/isOdd pos)
                    ;; the current instruction is a call that blocks all registers
                    (< pos (LinearScan''maxOpId-1 (:allocator this))) (LinearScan''hasCall-2 (:allocator this), (inc pos)) (< (inc pos) (Interval''to-1 interval))
                )
            )
        )
    )

    (defn #_"this" LinearScanWalker''initVarsForAlloc-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"AllocatableRegisters" r (RegisterAllocationConfig'getAllocatableRegisters-1 (#_"ValueKind" .getPlatformKind (:kind interval)))
            this (assoc this :availableRegs (:allocatableRegisters r))
            this (assoc this :minReg (:minRegisterNumber r))
            this (assoc this :maxReg (:maxRegisterNumber r))
        ]
            this
        )
    )

    (defn #_"boolean" LinearScanWalker'isMove-3 [#_"LIRInstruction" op, #_"Interval" from, #_"Interval" to]
        (and (satisfies? ValueMoveOp op)
            (satisfies? Variable (ValueMoveOp'''getInput-1 op)) (= (ValueMoveOp'''getInput-1 op) (:operand from))
            (satisfies? Variable (MoveOp'''getResult-1 op)) (= (MoveOp'''getResult-1 op) (:operand to))
        )
    )

    ;; optimization (especially for phi functions of nested loops)
    ;; assign same spill slot to non-intersecting intervals
    (defn #_"void" LinearScanWalker''combineSpilledIntervals-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; => optimization is only suitable for split parents
        (when-not (Interval''isSplitChild-1 interval)
            (let [
                #_"Interval" registerHint (Interval''locationHint-2 interval, false)
            ]
                ;; => 'interval' is not the target of a move, else registerHint would be set
                (when (some? registerHint)
                    ;; => combining the stack slots for intervals where spill move optimization is applied is not beneficial and would cause problems
                    (when (and (= (Interval''spillState-1 interval) SpillState'NoOptimization) (= (Interval''spillState-1 registerHint) SpillState'NoOptimization))
                        (let [
                            #_"int" beginPos (Interval''from-1 interval)
                            #_"int" endPos (Interval''to-1 interval)
                        ]
                            ;; => safety check that lirOpWithId is allowed
                            (when-not (or (< (LinearScan''maxOpId-1 (:allocator this)) endPos) (CodeUtil/isOdd beginPos) (CodeUtil/isOdd endPos))
                                ;; => 'interval' and registerHint are not connected with two moves
                                (when (and (LinearScanWalker'isMove-3 (LinearScan''instructionForId-2 (:allocator this), beginPos), registerHint, interval) (LinearScanWalker'isMove-3 (LinearScan''instructionForId-2 (:allocator this), endPos), interval, registerHint))
                                    (let [
                                        #_"Interval" beginHint (Interval''getSplitChildAtOpId-4 registerHint, beginPos, OperandMode'USE, (:allocator this))
                                        #_"Interval" endHint (Interval''getSplitChildAtOpId-4 registerHint, endPos, OperandMode'DEF, (:allocator this))
                                    ]
                                        ;; => registerHint must be split : otherwise the re-writing of use positions does not work
                                        (when (and (not (= beginHint endHint)) (= (Interval''to-1 beginHint) beginPos) (= (Interval''from-1 endHint) endPos))
                                            ;; => registerHint is not spilled at beginPos, so it would not be beneficial to immediately spill 'interval'
                                            (when-not (instance? RegisterValue (:location beginHint))
                                                ;; modify intervals such that 'interval' gets the same stack slot as registerHint
                                                ;; delete use positions to prevent the intervals to get a register at beginning
                                                (Interval''setSpillSlot-2 interval, (Interval''spillSlot-1 registerHint))
                                                (Interval''removeFirstUsePos-1 interval)
                                                (Interval''removeFirstUsePos-1 endHint)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;; allocate a physical register or memory location to an interval
    (defm LinearScanWalker IntervalWalker
        (#_"boolean" IntervalWalker'''activateCurrent-2 [#_"LinearScanWalker" this, #_"Interval" interval]
            (let [
                #_"Value" operand (:operand interval)
                #_"boolean" result
                    (if (and (some? (:location interval)) (LIRValueUtil'isStackSlotValue-1 (:location interval)))
                        (do
                            ;; activating an interval that has a stack slot assigned
                            ;; split it at first use position used for method parameters
                            (LinearScanWalker''splitStackInterval-2 this, interval)
                            false
                        )
                        (or (some? (:location interval))
                            (do
                                ;; interval has not assigned register
                                ;; normal allocation (the normal case for most intervals)

                                ;; assign same spill slot to non-intersecting intervals
                                (LinearScanWalker''combineSpilledIntervals-2 this, interval)

                                (ยง ass! this (LinearScanWalker''initVarsForAlloc-2 this, interval))
                                (when (or (LinearScanWalker''noAllocationPossible-2 this, interval) (not (LinearScanWalker''allocFreeRegister-2 this, interval)))
                                    ;; no empty register available
                                    ;; split and spill another interval so that this interval gets a register
                                    (LinearScanWalker''allocLockedRegister-2 this, interval)
                                )

                                ;; spilled intervals need not be move to active-list
                                (instance? RegisterValue (:location interval))
                            )
                        )
                    )
            ]
                ;; load spilled values that become active from stack slot to register
                (when (:insertMoveWhenActivated interval)
                    (LinearScanWalker''insertMove-4 this, (Interval''from-1 interval), (Interval''currentSplitChild-1 interval), interval)
                )
                (Interval''makeCurrentSplitChild-1 interval)

                result ;; true = interval is moved to active list
            )
        )
    )

    (defn #_"void" LinearScanWalker''finishAllocation-1 [#_"LinearScanWalker" this]
        ;; must be called when all intervals are allocated
        (ยง ass! (:moveResolver this) (MoveResolver''resolveAndAppendMoves-1 (:moveResolver this)))
        nil
    )
)

(class-ns OptimizingLinearScanWalker [LinearScanWalker, IntervalWalker]
    (defn #_"OptimizingLinearScanWalker" OptimizingLinearScanWalker'new-3 [#_"LinearScan" allocator, #_"Interval" unhandledFixedFirst, #_"Interval" unhandledAnyFirst]
        (merge (OptimizingLinearScanWalker'class.) (LinearScanWalker'new-3 allocator, unhandledFixedFirst, unhandledAnyFirst))
    )

    (defm OptimizingLinearScanWalker LinearScanWalker
        (#_"void" LinearScanWalker'''handleSpillSlot-2 [#_"OptimizingLinearScanWalker" this, #_"Interval" interval]
            (when-not (Interval''canMaterialize-1 interval)
                (ยง ass! (:unhandledLists this) (RegisterBindingLists''addToListSortedByStartAndUsePositions-3 (:unhandledLists this), RegisterBinding'Stack, interval))
            )
            nil
        )
    )

    (defn- #_"OptimizingLinearScanWalker" OptimizingLinearScanWalker''splitRegisterInterval-3 [#_"OptimizingLinearScanWalker" this, #_"Interval" interval, #_"Register" reg]
        (let [
            this (LinearScanWalker''initVarsForAlloc-2 this, interval)
        ]
            ;; collect current usage of registers
            (LinearScanWalker''initUseLists-2 this, false)
            (LinearScanWalker''spillExcludeActiveFixed-1 this)
            (LinearScanWalker''spillBlockInactiveFixed-2 this, interval)
            (LinearScanWalker''spillCollectActiveAny-2 this, RegisterPriority'LiveAtLoopEnd)
            (LinearScanWalker''spillCollectInactiveAny-2 this, interval)

            ;; the register must be free at least until this position
            (let [
                #_"boolean" split? (<= (nth (:blockPos this) (.number reg)) (Interval''to-1 interval))
                #_"int" pos (nth (:blockPos this) (.number reg))
            ]
                (ยง ass! interval (Interval''assignLocation-2 interval, (#_"Register" .asValue reg, (:kind interval))))
                (when split?
                    ;; register not available for full interval, so split it
                    (LinearScanWalker''splitWhenPartialRegisterAvailable-3 this, interval, pos)
                )
                ;; perform splitting and spilling for all affected intervals
                (LinearScanWalker''splitAndSpillIntersectingIntervals-2 this, reg)
                ;; activate interval
                (ยง ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), RegisterBinding'Any, interval))
                (ยง ass! interval (assoc interval :state IntervalState'Active))
                this
            )
        )
    )

    (defn- #_"boolean" OptimizingLinearScanWalker''optimize-5 [#_"OptimizingLinearScanWalker" this, #_"int" currentPos, #_"Block" currentBlock, #_"Interval" currentInterval, #_"RegisterBinding" binding]
        (cond
            (not (Interval''isSplitChild-1 currentInterval))  false ;; interval is not a split child -> no need for optimization
            (= (Interval''from-1 currentInterval) currentPos) false ;; the interval starts at the current position so no need for splitting
            :else
                (let [
                    #_"AllocatableValue" currentLocation (:location currentInterval)
                    #_"Block" predecessorBlock (nth (:predecessors currentBlock) 0)
                    #_"int" predEndId (LinearScan''getLastLirInstructionId-2 (:allocator this), predecessorBlock)
                    #_"Interval" predecessorInterval (Interval''getIntervalCoveringOpId-2 currentInterval, predEndId)
                    #_"AllocatableValue" predecessorLocation (:location predecessorInterval)
                ]
                    (cond
                        (= currentLocation predecessorLocation)
                            false ;; locations are already equal -> nothing to optimize
                        (and (not (LIRValueUtil'isStackSlotValue-1 predecessorLocation)) (not (instance? RegisterValue predecessorLocation)))
                            false ;; value is materialized -> no need for optimization
                        :else
                            ;; split current interval at current position
                            (let [
                                #_"Interval" splitPart (Interval''split-3 currentInterval, currentPos, (:allocator this))
                            ]
                                (ยง ass! (:activeLists this) (RegisterBindingLists''remove-3 (:activeLists this), binding, currentInterval))
                                ;; the currentSplitChild is needed later when moves are inserted for reloading
                                (Interval''makeCurrentSplitChild-1 splitPart)
                                (cond
                                    GraalOptions'lsraOptSplitOnly
                                        ;; just add the split interval to the unhandled list
                                        (ยง ass! (:unhandledLists this) (RegisterBindingLists''addToListSortedByStartAndUsePositions-3 (:unhandledLists this), RegisterBinding'Any, splitPart))
                                    (instance? RegisterValue predecessorLocation)
                                        (ยง ass! this (OptimizingLinearScanWalker''splitRegisterInterval-3 this, splitPart, (#_"RegisterValue" .getRegister predecessorLocation)))
                                    :else
                                    (do
                                        (ยง ass! splitPart (Interval''assignLocation-2 splitPart, predecessorLocation))
                                        ;; activate interval
                                        (ยง ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), RegisterBinding'Stack, splitPart))
                                        (ยง ass! splitPart (assoc splitPart :state IntervalState'Active))
                                        (LinearScanWalker''splitStackInterval-2 this, splitPart)
                                    )
                                )
                                true
                            )
                    )
                )
        )
    )

    (defn- #_"void" OptimizingLinearScanWalker''optimizeBlock-2 [#_"OptimizingLinearScanWalker" this, #_"Block" block]
        (when (= (count (:predecessors block)) 1)
            (let [
                #_"int" nextBlock (LinearScan''getFirstLirInstructionId-2 (:allocator this), block)
            ]
                (ยง ass! this (IntervalWalker''walkTo-2 this, nextBlock))
                ;; we need to do this because the active lists might change
                (loop []
                    (or
                        (loop-when [#_"Interval" active (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 active))
                            (or (OptimizingLinearScanWalker''optimize-5 this, nextBlock, block, active, RegisterBinding'Any)
                                (recur (:next active))
                            )
                        )
                        (loop-when [#_"Interval" active (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Stack)] (not (Interval''isEndMarker-1 active))
                            (or (OptimizingLinearScanWalker''optimize-5 this, nextBlock, block, active, RegisterBinding'Stack)
                                (recur (:next active))
                            )
                        )
                        (recur)
                    )
                )
            )
        )
        nil
    )

    (defm OptimizingLinearScanWalker IntervalWalker
        (#_"void" IntervalWalker'''walk-1 [#_"OptimizingLinearScanWalker" this]
            (doseq [#_"Block" block (LinearScan''sortedBlocks-1 (:allocator this))]
                (OptimizingLinearScanWalker''optimizeBlock-2 this, block)
            )
            (IntervalWalker'''walk-1 (ยง super LinearScanWalker'iface))
            nil
        )
    )
)

;;;
 ; An intrinsic is a substitute implementation of a Java method (or a bytecode in the case of
 ; snippets) that is itself implemented in Java. This interface provides information about the
 ; intrinsic currently being processed by the graph builder.
 ;
 ; When in the scope of an intrinsic, the graph builder does not check the value kinds flowing
 ; through the JVM state since intrinsics can employ non-Java kinds to represent values such as
 ; raw machine words and pointers.
 ;;
(class-ns IntrinsicContext []
    (defn #_"IntrinsicContext" IntrinsicContext'new-4 [#_"ResolvedJavaMethod" method, #_"ResolvedJavaMethod" intrinsic, #_"BytecodeProvider" bytecodeProvider, #_"CompilationContext" compilationContext]
        (merge (IntrinsicContext'class.)
            (hash-map
                ;;;
                 ; Method being intrinsified.
                 ;;
                #_"ResolvedJavaMethod" :originalMethod method
                ;;;
                 ; Method providing the intrinsic implementation.
                 ;;
                #_"ResolvedJavaMethod" :intrinsicMethod intrinsic
                ;;;
                 ; Provider of bytecode to be parsed for a method that is part of an intrinsic.
                 ;;
                #_"BytecodeProvider" :bytecodeProvider bytecodeProvider
                #_"CompilationContext" :compilationContext compilationContext
            )
        )
    )

    ;;;
     ; Determines if a call within the compilation scope of this intrinsic represents a call to the
     ; {@linkplain #getOriginalMethod() original} method. This denotes the path where a partial
     ; intrinsification falls back to the original method.
     ;;
    (defn #_"boolean" IntrinsicContext''isCallToOriginal-2 [#_"IntrinsicContext" this, #_"ResolvedJavaMethod" targetMethod]
        (or (= (:originalMethod this) targetMethod) (= (:intrinsicMethod this) targetMethod))
    )

    (defn #_"boolean" IntrinsicContext''isPostParseInlined-1 [#_"IntrinsicContext" this]
        (= (:compilationContext this) CompilationContext'INLINE_AFTER_PARSING)
    )

    (defn #_"boolean" IntrinsicContext''isCompilationRoot-1 [#_"IntrinsicContext" this]
        (= (:compilationContext this) CompilationContext'ROOT_COMPILATION)
    )

    (defn #_"FrameState" IntrinsicContext'createFrameState-3 [#_"Graph" graph, #_"SideEffectsState" sideEffects, #_"StateSplit" forStateSplit]
        (if (StateSplit'''hasSideEffect-1 forStateSplit)
            (do
                (when (SideEffectsState'''isAfterSideEffect-1 sideEffects)
                    ;; only the last side effect on any execution path in a replacement can inherit the stateAfter of the replaced node
                    (let [
                        #_"FrameState" invalid (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/INVALID_FRAMESTATE_BCI))
                    ]
                        (doseq [#_"StateSplit" lastSideEffect (SideEffectsState'''sideEffects-1 sideEffects)]
                            (StateSplit'''setStateAfter-2 lastSideEffect, invalid)
                        )
                    )
                )
                (SideEffectsState'''addSideEffect-2 sideEffects, forStateSplit)
                (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/AFTER_BCI))
            )
            (if (satisfies? AbstractMergeNode forStateSplit)
                ;; merge nodes always need a frame state
                (if (SideEffectsState'''isAfterSideEffect-1 sideEffects)
                    (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/AFTER_BCI))  ;; a merge after one or more side effects
                    (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/BEFORE_BCI)) ;; a merge before any side effects
                )
                ;; other non-side-effects do not need a state
                nil
            )
        )
    )
)

;;;
 ; A scoped object for tasks to be performed after parsing an intrinsic such as processing
 ; {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
 ;;
(class-ns IntrinsicScope [#_"AutoCloseable"]
    ;;;
     ; Creates a scope for root parsing an intrinsic.
     ;
     ; @param parser the parsing context of the intrinsic
     ;;
    (defn #_"IntrinsicScope" IntrinsicScope'new-1 [#_"BytecodeParser" parser]
        (merge (IntrinsicScope'class.)
            (hash-map
                #_"BytecodeParser" :parser parser
                #_"FrameState" :stateBefore nil
                #_"int" :mark 0
                #_"List<ReturnToCallerData>" :returnDataList nil
            )
        )
    )

    ;;;
     ; Creates a scope for parsing an intrinsic during graph builder inlining.
     ;
     ; @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
     ; @param args the arguments to the call
     ;;
    (defn #_"IntrinsicScope" IntrinsicScope'new-3 [#_"BytecodeParser" parser, #_"JavaKind[]" argSlotKinds, #_"ValueNode[]" args]
        (merge (IntrinsicScope'class.)
            (hash-map
                #_"BytecodeParser" :parser parser
                #_"FrameState" :stateBefore (FrameStateBuilder''create-6 (:frameState parser), (BytecodeParser''bci-1 parser), (BytecodeParser''getNonIntrinsicAncestor-1 parser), false, argSlotKinds, args)
                #_"int" :mark (Graph''getMark-1 (:graph parser))
                #_"List<ReturnToCallerData>" :returnDataList nil
            )
        )
    )

    ;;;
     ; Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
     ; added to the graph while parsing/inlining the intrinsic for which this object exists.
     ;;
    (defn- #_"this" IntrinsicScope''processPlaceholderFrameStates-2 [#_"IntrinsicScope" this, #_"IntrinsicContext" intrinsic]
        (let [
            #_"Graph" graph (:graph (:parser this))
            #_"boolean" invalid?
                (loop-when [invalid? false #_"ISeq" s (seq (Graph''getNodesSince-2 graph, (:mark this)))] (some? s) => invalid?
                    (let [
                        #_"Node" node (first s)
                        invalid?
                            (when (satisfies? FrameState node) => invalid?
                                (let [
                                    #_"FrameState" frameState node
                                ]
                                    (when (BytecodeFrame/isPlaceholderBci (:bci frameState)) => invalid?
                                        (condp = (:bci frameState)
                                            BytecodeFrame/AFTER_BCI
                                                (if (nil? (BytecodeParser''getInvokeReturnType-1 (:parser this)))
                                                    ;; A frame state in a root compiled intrinsic.
                                                    (do
                                                        (ยง ass! frameState (Node''replaceAndDelete-2 frameState, (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/INVALID_FRAMESTATE_BCI))))
                                                        invalid?
                                                    )
                                                    (let [
                                                        #_"JavaKind" returnKind (#_"JavaType" .getJavaKind (BytecodeParser''getInvokeReturnType-1 (:parser this)))
                                                        #_"FrameStateBuilder" frameStateBuilder (:frameState (:parser this))
                                                    ]
                                                        (cond
                                                            (not (zero? (:stackSize frameState)))
                                                                (let [
                                                                    #_"ValueNode" returnVal (FrameState''stackAt-2 frameState, 0)
                                                                ]
                                                                    (when-not (ReturnToCallerData'containsReturnValue-2 (:returnDataList this), returnVal)
                                                                        (throw! (str "AFTER_BCI frame state within an intrinsic has a non-return value on the stack: " returnVal))
                                                                    )
                                                                    ;; Swap the top-of-stack value with the return value.
                                                                    (let [
                                                                        #_"ValueNode" tos (FrameStateBuilder''pop-2 frameStateBuilder, returnKind)
                                                                    ]
                                                                        (ยง ass! frameState (Node''replaceAndDelete-2 frameState, (FrameStateBuilder''create-6 frameStateBuilder, (:nextBCI (:stream (:parser this))), (BytecodeParser''getNonIntrinsicAncestor-1 (:parser this)), false, (into-array JavaKind [ returnKind ]), (into-array ValueNode'iface [ returnVal ]))))
                                                                        (ยง ass! frameStateBuilder (FrameStateBuilder''push-3 frameStateBuilder, returnKind, tos))
                                                                    )
                                                                    invalid?
                                                                )
                                                            (= returnKind JavaKind/Void)
                                                                ;; An intrinsic for a void method.
                                                                (do
                                                                    (ยง ass! frameState (Node''replaceAndDelete-2 frameState, (FrameStateBuilder''create-3 frameStateBuilder, (:nextBCI (:stream (:parser this))), nil)))
                                                                    invalid?
                                                                )
                                                            :else
                                                                ;; If the intrinsic returns a non-void value, then any frame state with an empty stack
                                                                ;; is invalid as it cannot be used to deoptimize to just after the call returns.
                                                                ;; These invalid frame states are expected to be removed by later compilation stages.
                                                                (do
                                                                    (ยง ass! frameState (Node''replaceAndDelete-2 frameState, (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/INVALID_FRAMESTATE_BCI))))
                                                                    true
                                                                )
                                                        )
                                                    )
                                                )
                                            BytecodeFrame/BEFORE_BCI
                                                (do
                                                    (when (nil? (:stateBefore this))
                                                        (ยง ass! this (assoc this :stateBefore (:stateAfter (:start graph))))
                                                    )
                                                    (when-not (= (:stateBefore this) frameState)
                                                        (ยง ass! frameState (Node''replaceAndDelete-2 frameState, (:stateBefore this)))
                                                    )
                                                    invalid?
                                                )
                                            #_else
                                                invalid?
                                        )
                                    )
                                )
                            )
                    ]
                        (recur invalid? (next s))
                    )
                )
        ]
            (when invalid?
                (let [
                    #_"JavaKind" returnKind (#_"JavaType" .getJavaKind (BytecodeParser''getInvokeReturnType-1 (:parser this)))
                    #_"ValueNode" returnValue (FrameStateBuilder''pop-2 (:frameState (:parser this)), returnKind)
                    #_"StateSplitProxyNode" proxy (Graph''add-2 graph, (StateSplitProxyNode'new-1 returnValue))
                ]
                    (ยง ass! (:lastInstr (:parser this)) (FixedWithNextNode''setNext-2 (:lastInstr (:parser this)), proxy))
                    (ยง ass! (:frameState (:parser this)) (FrameStateBuilder''push-3 (:frameState (:parser this)), returnKind, proxy))
                    (StateSplit'''setStateAfter-2 proxy, (BytecodeParser''createFrameState-3 (:parser this), (:nextBCI (:stream (:parser this))), proxy))
                    (ยง ass! (:lastInstr (:parser this)) proxy)
                )
            )
            this
        )
    )

    (ยง override! #_"void" #_"AutoCloseable." close [#_"IntrinsicScope" this]
        (let [
            #_"IntrinsicContext" context (:intrinsicContext (:parser this))
        ]
            (when-not (and (some? context) (IntrinsicContext''isPostParseInlined-1 context))
                (ยง ass! this (IntrinsicScope''processPlaceholderFrameStates-2 this, context))
            )
        )
        nil
    )
)

(defp NodePredicate
    (#_"boolean" NodePredicate'''apply-2 [#_"NodePredicate" this, #_"Node" node])
)

(defp InvariantPredicate)

(class-ns InvariantPredicate [NodePredicate, #_"fn boolean [Node]"]
    (defn #_"InvariantPredicate" InvariantPredicate'new-1 [#_"LoopEx" loopEx]
        (merge (InvariantPredicate'class.)
            (hash-map
                #_"LoopEx" :loopEx loopEx
                #_"int" :mark (Graph''getMark-1 (:graph (LoopEx''loopBegin-1 loopEx)))
            )
        )
    )

    (defm InvariantPredicate NodePredicate
        (#_"boolean" NodePredicate'''apply-2 [#_"InvariantPredicate" this, #_"Node" node]
            (and (< (:nid node) (:mark this)) ;; newly created nodes are unknown
                (LoopEx''isOutsideLoop-2 (:loopEx this), node)
            )
        )
    )
)

(class-ns InvokeKind []
    (ยง enum InvokeKind'Interface (InvokeKind'new-1 false))
    (ยง enum InvokeKind'Special   (InvokeKind'new-1 true))
    (ยง enum InvokeKind'Static    (InvokeKind'new-1 true))
    (ยง enum InvokeKind'Virtual   (InvokeKind'new-1 false))

    (defn #_"InvokeKind" InvokeKind'new-1 [#_"boolean" direct]
        (merge (InvokeKind'class.)
            (hash-map
                #_"boolean" :direct direct
            )
        )
    )

    (defn #_"boolean" InvokeKind''hasReceiver-1 [#_"InvokeKind" this]
        (not= this InvokeKind'Static)
    )

    (defn #_"boolean" InvokeKind''isIndirect-1 [#_"InvokeKind" this]
        (not (:direct this))
    )

    #_unused
    (defn #_"boolean" InvokeKind''isInterface-1 [#_"InvokeKind" this]
        (= this InvokeKind'Interface)
    )
)

(class-ns IterativeConditionalEliminationPhase [Phase]
    (def- #_"int" IterativeConditionalEliminationPhase'MAX_ITERATIONS 256)

    (defn #_"IterativeConditionalEliminationPhase" IterativeConditionalEliminationPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"boolean" fullSchedule]
        (merge (IterativeConditionalEliminationPhase'class.)
            (hash-map
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
                #_"boolean" :fullSchedule fullSchedule
            )
        )
    )

    (defm IterativeConditionalEliminationPhase Phase
        (#_"Graph" Phase'''run-3 [#_"IterativeConditionalEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"HashSetNodeEventListener" listener (HashSetNodeEventListener''exclude-2 (HashSetNodeEventListener'new-0), NodeEvent'NODE_ADDED)
            ]
                (loop [graph graph #_"int" iteration 0]
                    (let [
                        graph
                            (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                                (Phase'''run-3 (ConditionalEliminationPhase'new-1 (:fullSchedule this)), graph, context)
                            )
                    ]
                        (when (seq (:nodes listener)) => graph
                            (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                                (when (satisfies? Simplifiable node)
                                    (#_"EconomicSet" .add (:nodes listener), node)
                                )
                            )
                            (CanonicalizerPhase''applyIncremental-3i (:canonicalizer this), graph, (:nodes listener))
                            (#_"EconomicSet" .clear (:nodes listener))
                            (let [
                                iteration (inc iteration)
                            ]
                                (when (< IterativeConditionalEliminationPhase'MAX_ITERATIONS iteration)
                                    (throw! (str "number of iterations in ConditionalEliminationPhase exceeds " IterativeConditionalEliminationPhase'MAX_ITERATIONS))
                                )
                                (recur graph iteration)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns JSRData []
    (defn #_"JSRData" JSRData'new-0 []
        (merge (JSRData'class.)
            (hash-map
                #_"EconomicMap<JsrScope, BciBlock>" :jsrAlternatives nil
                #_"JsrScope" :jsrScope JsrScope'EMPTY_SCOPE
                #_"BciBlock" :jsrSuccessor nil
                #_"int" :jsrReturnBci 0
                #_"BciBlock" :retSuccessor nil
                #_"boolean" :endsWithRet false
            )
        )
    )
)

(class-ns JsrScope []
    (ยง def #_"JsrScope" JsrScope'EMPTY_SCOPE (JsrScope'new-0))

    (defn- #_"JsrScope" JsrScope'new-1 [#_"long" scope]
        (merge (JsrScope'class.)
            (hash-map
                #_"long" :scope scope
            )
        )
    )

    (defn #_"JsrScope" JsrScope'new-0 []
        (JsrScope'new-1 0)
    )

    (defn #_"int" JsrScope''nextReturnAddress-1 [#_"JsrScope" this]
        (int (& (:scope this) 0xffff))
    )

    (defn #_"JsrScope" JsrScope''push-2 [#_"JsrScope" this, #_"int" jsrReturnBci]
        (when-not (zero? (& (:scope this) 0xffff000000000000))
            (throw! "only 4 jsr nesting levels are supported")
        )
        (JsrScope'new-1 (| (<< (:scope this) 16) jsrReturnBci))
    )

    (defn #_"boolean" JsrScope''isEmpty-1 [#_"JsrScope" this]
        (zero? (:scope this))
    )

    (defn #_"boolean" JsrScope''isPrefixOf-2 [#_"JsrScope" this, #_"JsrScope" other]
        (= (& (:scope this) (:scope other)) (:scope this))
    )

    (defn #_"JsrScope" JsrScope''pop-1 [#_"JsrScope" this]
        (JsrScope'new-1 (>>> (:scope this) 16))
    )
)

(class-ns KeyData []
    (defn #_"KeyData" KeyData'new-3 [#_"int" key, #_"double" keyProbability, #_"int" keySuccessor]
        (merge (KeyData'class.)
            (hash-map
                #_"int" :key key
                #_"double" :keyProbability keyProbability
                #_"int" :keySuccessor keySuccessor
            )
        )
    )
)

;;;
 ; This class implements the overall container for the LIR graph and directs its construction,
 ; optimization, and finalization.
 ;;
(class-ns LIR []
    ;;;
     ; Creates a new LIR instance for the specified compilation.
     ;;
    (defn #_"LIR" LIR'new-3 [#_"ControlFlowGraph" cfg, #_"Block[]" linearScanOrder, #_"Block[]" codeEmittingOrder]
        (merge (LIR'class.)
            (hash-map
                #_"ControlFlowGraph" :cfg cfg
                ;;;
                 ; The linear-scan ordered list of blocks.
                 ;;
                #_"Block[]" :linearScanOrder linearScanOrder
                ;;;
                 ; The order in which the code is emitted.
                 ;;
                #_"Block[]" :codeEmittingOrder codeEmittingOrder
                ;;;
                 ; Map from block to LIRInstructions.
                 ; Note that we are using ArrayList instead of List to avoid interface dispatch.
                 ;;
                #_"BlockMap<List<LIRInstruction>>" :lirInstructions (BlockMap'new-1 cfg)
                ;;;
                 ; Determines if any of the parameters to the method are passed via the stack where the parameters
                 ; are located in the caller's frame.
                 ;;
                #_"boolean" :hasArgInCallerFrame false
                #_"int" :numVariables 0
            )
        )
    )

    (defn #_"int" LIR''nextVariable-1 [#_"LIR" this]
        (ยง ass! this (update this :numVariables inc))
        (:numVariables this)
    )

    (defn #_"List<LIRInstruction>" LIR''getLIRforBlock-2 [#_"LIR" this, #_"Block" block]
        (BlockMap''get-2 (:lirInstructions this), block)
    )

    (defn #_"void" LIR''setLIRforBlock-3 [#_"LIR" this, #_"Block" block, #_"List<LIRInstruction>" list]
        (BlockMap''put-3 (:lirInstructions this), block, list)
        nil
    )

    (defn #_"LIR" LIR''setHasArgInCallerFrame-1 [#_"LIR" this]
        (assoc this :hasArgInCallerFrame true)
    )

    ;;;
     ; Gets the next non-nil block in a list.
     ;
     ; @param blocks list of blocks
     ; @param i index of the current block
     ; @return the next block in the list that is none nil or nil if there is no such block
     ;;
    (defn #_"Block" LIR'getNextBlock-2 [#_"Block[]" blocks, #_"int" i]
        (loop-when [i (inc i)] (and (pos? i) (< i (count blocks))) (or (nth blocks i) (recur (inc i))))
    )
)

(class-ns LIRBuilder []
    (defn #_"LIRBuilder" LIRBuilder'new-2 [#_"Graph" graph, #_"LIRGenerator" gen]
        (let [
            #_"LIRBuilder" this
                (merge (LIRBuilder'class.)
                    (hash-map
                        #_"LIRGenerator" :gen gen
                        #_"NodeMap<Value>" :nodeOperands (NodeMap'new-1g graph)
                        #_"LockStackHolder" :lockStackHolder (LockStackHolder'new-1 (LockStack'new-2 (:frameMapBuilder (:res gen)), (LIRKind'value-1 AMD64Kind/QWORD)))
                        #_"ValueNode" :currentInstruction nil
                    )
                )
        ]
            (ยง ass! gen (LIRGenerator''setLockStackHolder-2 gen, (:lockStackHolder this)))
            this
        )
    )

    ;;;
     ; Associates {@code operand} with the {@code node} in the current block.
     ;
     ; @return {@code operand}
     ;;
    (defn #_"Value" LIRBuilder''setResult-3 [#_"LIRBuilder" this, #_"ValueNode" node, #_"Value" operand]
        (NodeMap''set-3 (:nodeOperands this), node, operand)
        operand
    )

    (defn- #_"Value" LIRBuilder''getOperand-2 [#_"LIRBuilder" this, #_"Node" node]
        (when (some? (:nodeOperands this)) (get (:nodeOperands this) node))
    )

    ;;;
     ; Returns the operand that has been previously initialized by #setResult(ValueNode, Value) with the result of
     ; an instruction. It's a code generation error to ask for the operand of ValueNode that doesn't have one yet.
     ;
     ; @param node A node that produces a result value.
     ;;
    (defn #_"Value" LIRBuilder''operand-2 [#_"LIRBuilder" this, #_"Node" node]
        (LIRBuilder''getOperand-2 this, node)
    )

    ;;;
     ; Returns true if there is an {@link Value operand} associated with the {@code node} in the current block.
     ;;
    (defn #_"boolean" LIRBuilder''hasOperand-2 [#_"LIRBuilder" this, #_"Node" node]
        (some? (LIRBuilder''getOperand-2 this, node))
    )

    (defn #_"LabelRef" LIRBuilder''getLIRBlock-2 [#_"LIRBuilder" this, #_"FixedNode" node]
        (let [
            #_"Block" block (ControlFlowGraph''blockFor-2 (:cfg (:lir (:res (:gen this)))), node)
        ]
            (loop-when [#_"int" i 0 #_"ISeq" s (seq (:successors (:currentBlock (:gen this))))] (some? s) => (throw! "Block not in successor list of current block")
                (if (= (first s) block)
                    (LabelRef'new-3 (:lir (:res (:gen this))), (:currentBlock (:gen this)), i)
                    (recur (inc i) (next s))
                )
            )
        )
    )

    (defn #_"LIRKind" LIRBuilder''getExactPhiKind-2 [#_"LIRBuilder" this, #_"PhiNode" phi]
        ;; collect reference information
        (loop-when [#_"LIRKind" derivedKind (LIRGenerator'toRegisterKind-1 (Stamp'''getLIRKind-1 (:stamp phi))) #_"int" i 0] (and (< i (PhiNode''valueCount-1 phi)) (not (LIRKind''isUnknownReference-1 derivedKind))) => derivedKind
            (let [
                #_"ValueNode" node (PhiNode''valueAt-2i phi, i)
                #_"Value" value (LIRBuilder''getOperand-2 this, node)
                ;; get ValueKind for input
                #_"LIRKind" valueKind
                    (if (some? value)
                        (#_"Value" .getValueKind value, LIRKind'iface)
                        (LIRGenerator'toRegisterKind-1 (Stamp'''getLIRKind-1 (:stamp node)))
                    )
            ]
                ;; merge the reference information of the derived kind and the input
                (recur (LIRKind'mergeReferenceInformation-2 derivedKind, valueKind) (inc i))
            )
        )
    )

    (defn- #_"Value[]" LIRBuilder''createPhiIn-2 [#_"LIRBuilder" this, #_"AbstractMergeNode" merge]
        (let [
            #_"List<Value>" values (ArrayList.)
        ]
            (doseq [#_"ValuePhiNode" phi (AbstractMergeNode''valuePhis-1 merge)]
                (let [
                    #_"Variable" value (LIRGenerator''newVariable-2 (:gen this), (LIRBuilder''getExactPhiKind-2 this, phi))
                ]
                    (#_"List" .add values, value)
                    (LIRBuilder''setResult-3 this, phi, value)
                )
            )
            (into-array Value values)
        )
    )

    (defn- #_"Value[]" LIRBuilder''createPhiOut-3 [#_"LIRBuilder" this, #_"AbstractMergeNode" merge, #_"AbstractEndNode" pred]
        (let [
            #_"List<Value>" values (ArrayList.)
        ]
            (doseq [#_"PhiNode" phi (AbstractMergeNode''valuePhis-1 merge)]
                (let [
                    #_"ValueNode" node (PhiNode''valueAt-2n phi, pred)
                    #_"Value" value (LIRBuilder''operand-2 this, node)
                ]
                    (when (instance? RegisterValue value)
                        ;; Fixed register intervals are not allowed at block boundaries, so we introduce a new Variable.
                        (ยง ass value (LIRGenerator''emitMove-2 (:gen this), value))
                    )
                    (#_"List" .add values, value)
                )
            )
            (into-array Value values)
        )
    )

    (defn #_"boolean" LIRBuilder''peephole-2 [#_"LIRBuilder" this, #_"ValueNode" valueNode]
        (and (satisfies? IntegerDivRemNode valueNode)
            (let [
                #_"IntegerDivRemNode" divRem valueNode
            ]
                (loop [#_"FixedNode" node (:next divRem)]
                    (let [
                        node
                            (condp satisfies? node
                                IfNode
                                    (case (:trueSuccessorProbability node)
                                        1.0 (:trueSuccessor node)
                                        0.0 (:falseSuccessor node)
                                        nil
                                    )
                                FixedWithNextNode
                                    node
                                nil
                            )
                    ]
                        (and (some? node)
                            (let [
                                #_"boolean" found?
                                    (and (satisfies? IntegerDivRemNode node)
                                         (not= (:op divRem) (:op node))
                                         (= (IntegerDivRemNode''getType-1 divRem) (IntegerDivRemNode''getType-1 node))
                                         (= (:x node) (:x divRem)) (= (:y node) (:y divRem)) (not (LIRBuilder''hasOperand-2 this, node))
                                    )
                            ]
                                (when found? => (recur (:next node))
                                    (let [
                                        #_"Value[]" pair
                                            (condp = (IntegerDivRemNode''getType-1 divRem)
                                                Signedness'SIGNED
                                                    (LIRGenerator''emitSignedDivRem-3 (:gen this), (LIRBuilder''operand-2 this, (:x divRem)), (LIRBuilder''operand-2 this, (:y divRem)))
                                                Signedness'UNSIGNED
                                                    (LIRGenerator''emitUnsignedDivRem-3 (:gen this), (LIRBuilder''operand-2 this, (:x divRem)), (LIRBuilder''operand-2 this, (:y divRem)))
                                            )
                                    ]
                                        (condp = (:op divRem)
                                            DivRemOp'DIV
                                            (do
                                                (LIRBuilder''setResult-3 this, divRem, (nth pair 0))
                                                (LIRBuilder''setResult-3 this, node, (nth pair 1))
                                            )
                                            DivRemOp'REM
                                            (do
                                                (LIRBuilder''setResult-3 this, divRem, (nth pair 1))
                                                (LIRBuilder''setResult-3 this, node, (nth pair 0))
                                            )
                                        )
                                        true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" LIRBuilder''doBlockPrologue-2 [#_"LIRBuilder" this, #_"Block" block]
        (when GraalOptions'mitigateSpeculativeExecutionAttacks
            (let [
                #_"boolean" hasControlSplitPredecessor
                    (loop-when [#_"ISeq" s (seq (:predecessors block))] (some? s) => false
                        (or (< 1 (count (:successors (first s))))
                            (recur (next s))
                        )
                    )
            ]
                (when (or hasControlSplitPredecessor (empty? (:predecessors block)))
                    (LIRGenerator''emitLFence-1 (:gen this))
                )
            )
        )
        nil
    )

    ; @SuppressWarnings("try")
    (defn #_"LIRBuilder" LIRBuilder''doBlock-4 [#_"LIRBuilder" this, #_"Block" block, #_"Graph" graph, #_"BlockMap<List<Node>>" blockMap]
        (try (ยง with [#_"BlockScope" _ (LIRGenerator''getBlockScope-2 (:gen this), block)])
            (if (= block (ControlFlowGraph''getStartBlock-1 (:cfg (:lir (:res (:gen this))))))
                (LIRBuilder''emitPrologue-2 this, graph)
                ;; create phi-in value array
                (when (satisfies? AbstractMergeNode (:beginNode block))
                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:res (:gen this))), block)
                    ]
                        (ยง ass! (nth ops 0) (LabelOp''setPhiValues-2 (nth ops 0), (LIRBuilder''createPhiIn-2 this, (:beginNode block))))
                    )
                )
            )
            (LIRBuilder''doBlockPrologue-2 this, block)
            (let [
                #_"List<Node>" nodes (BlockMap''get-2 blockMap, block)
            ]
                (doseq [#_"Node" node nodes]
                    ;; => there can be cases in which the result of an instruction is already set before by other instructions
                    (when (and (satisfies? ValueNode node) (nil? (LIRBuilder''getOperand-2 this, node)) (not (LIRBuilder''peephole-2 this, node)))
                        (ยง ass! this (assoc this :currentInstruction node))
                        (LIRBuilder''emitNode-2 this, node)
                    )
                )
                (when-not (LIRGenerator''hasBlockEnd-2 (:gen this), block)
                    (let [
                        #_"Node*" successors (Node''successors-1 (:endNode block))
                    ]
                        ;; If we have more than one successor, we cannot just use the first one.
                        ;; Since successors are unordered, this would be a random choice.
                        (when (= (count (:successors block)) 1) => (throw! (str "Block without BlockEndOp: " (:endNode block)))
                            (LIRGenerator''emitJump-2 (:gen this), (LIRBuilder''getLIRBlock-2 this, (first successors)))
                        )
                    )
                )
                this
            )
        )
    )

    (defn #_"void" LIRBuilder''emitNode-2 [#_"LIRBuilder" this, #_"ValueNode" node]
        (when (satisfies? LIRLowerable node) => (throw! (str "node is not LIRLowerable: " node))
            (LIRLowerable'''generate-2 node, this)
        )
        nil
    )

    (defn #_"void" LIRBuilder''emitPrologue-2 [#_"LIRBuilder" this, #_"Graph" graph]
        (let [
            #_"CallingConvention" args (:callingConvention (:res (:gen this)))
            #_"Value[]" params (make-array Value (inc (#_"CallingConvention" .getArgumentCount args)))
        ]
            (dotimes [#_"int" i (dec (count params))]
                (let [
                    #_"AllocatableValue" arg (#_"CallingConvention" .getArgument args, i)
                ]
                    (aset params i arg)
                    (when (and (instance? StackSlot arg) (#_"StackSlot" .isInCallerFrame arg) (not (:hasArgInCallerFrame (:lir (:res (:gen this))))))
                        (ยง ass! (:lir (:res (:gen this))) (LIR''setHasArgInCallerFrame-1 (:lir (:res (:gen this)))))
                    )
                )
            )
            (aset params (dec (count params)) (#_"Register" .asValue AMD64/rbp, (LIRKind'value-1 AMD64Kind/QWORD)))

            (LIRGenerator''emitIncomingValues-2 (:gen this), params)
            (ยง ass! (:gen this) (LIRGenerator''emitSaveRbp-1 (:gen this)))
            (LIRGenerator''append-2 (:gen this), (:lockStack (:lockStackHolder this)))
            (doseq [#_"ParameterNode" param (Graph''getNodes-2 graph, ParameterNode)]
                (LIRBuilder''setResult-3 this, param, (LIRGenerator''emitMove-2 (:gen this), (nth params (AbstractLocalNode''index-1 param))))
            )
        )
        nil
    )

    (defn #_"void" LIRBuilder''visitMerge-2 [#_"LIRBuilder" this, #_"AbstractMergeNode" node]
        nil
    )

    (defn #_"void" LIRBuilder''visitEndNode-2 [#_"LIRBuilder" this, #_"AbstractEndNode" node]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 node)
            #_"JumpOp" jump (JumpOp'new-1 (LIRBuilder''getLIRBlock-2 this, merge))
            jump (JumpOp''setPhiValues-2 jump, (LIRBuilder''createPhiOut-3 this, merge, node))
        ]
            (LIRGenerator''append-2 (:gen this), jump)
        )
        nil
    )

    ;;;
     ; Runtime specific classes can override this to insert a safepoint at the end of a loop.
     ;;
    (defn #_"void" LIRBuilder''visitLoopEnd-2 [#_"LIRBuilder" this, #_"LoopEndNode" node]
        nil
    )

    (defn #_"void" LIRBuilder''visitSafepointNode-2 [#_"LIRBuilder" this, #_"SafepointNode" node]
        (LIRGenerator''append-2 (:gen this), (SafepointOp'new-2 this, HotSpot'threadRegister))
        nil
    )

    (defn- #_"void" LIRBuilder''emitNullCheckBranch-5 [#_"LIRBuilder" this, #_"IsNullNode" node, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (let [
            #_"LIRKind" kind (Stamp'''getLIRKind-1 (:stamp (Unary'''getValue-1 node)))
            #_"Value" nullValue (LIRGenerator''emitConstant-3 (:gen this), kind, JavaConstant/NULL_POINTER)
        ]
            (LIRGenerator''emitCompareBranch-8 (:gen this), (#_"ValueKind" .getPlatformKind kind), (LIRBuilder''operand-2 this, (Unary'''getValue-1 node)), nullValue, Condition'EQ, trueSuccessor, falseSuccessor, trueSuccessorProbability)
        )
        nil
    )

    (defn #_"void" LIRBuilder''emitBranch-5 [#_"LIRBuilder" this, #_"LogicNode" node, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (condp satisfies? node
            IsNullNode        (LIRBuilder''emitNullCheckBranch-5 this, node, trueSuccessor, falseSuccessor, trueSuccessorProbability)
            CompareNode       (LIRBuilder''emitCompareBranch-5 this, node, trueSuccessor, falseSuccessor, trueSuccessorProbability)
            LogicConstantNode (LIRBuilder''emitConstantBranch-4 this, (:value node), trueSuccessor, falseSuccessor)
            IntegerTestNode   (LIRBuilder''emitIntegerTestBranch-5 this, node, trueSuccessor, falseSuccessor, trueSuccessorProbability)
        )
        nil
    )

    (defn #_"void" LIRBuilder''emitIf-2 [#_"LIRBuilder" this, #_"IfNode" node]
        (LIRBuilder''emitBranch-5 this, (:logic node), (LIRBuilder''getLIRBlock-2 this, (:trueSuccessor node)), (LIRBuilder''getLIRBlock-2 this, (:falseSuccessor node)), (ControlSplitNode'''probability-2 node, (:trueSuccessor node)))
        nil
    )

    (defn #_"void" LIRBuilder''emitCompareBranch-5 [#_"LIRBuilder" this, #_"CompareNode" compare, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (let [
            #_"PlatformKind" kind (#_"ValueKind" .getPlatformKind (Stamp'''getLIRKind-1 (:stamp (:x compare))))
        ]
            (LIRGenerator''emitCompareBranch-8 (:gen this), kind, (LIRBuilder''operand-2 this, (:x compare)), (LIRBuilder''operand-2 this, (:y compare)), (:canonical (:condition compare)), trueSuccessor, falseSuccessor, trueSuccessorProbability)
        )
        nil
    )

    (defn #_"void" LIRBuilder''emitIntegerTestBranch-5 [#_"LIRBuilder" this, #_"IntegerTestNode" test, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (LIRGenerator''emitIntegerTestBranch-6 (:gen this), (LIRBuilder''operand-2 this, (:x test)), (LIRBuilder''operand-2 this, (:y test)), trueSuccessor, falseSuccessor, trueSuccessorProbability)
        nil
    )

    (defn #_"void" LIRBuilder''emitConstantBranch-4 [#_"LIRBuilder" this, #_"boolean" value?, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor]
        (LIRGenerator''emitJump-2 (:gen this), (if value? trueSuccessor falseSuccessor))
        nil
    )

    (defn #_"Variable" LIRBuilder''emitConditional-4 [#_"LIRBuilder" this, #_"LogicNode" node, #_"Value" trueValue, #_"Value" falseValue]
        (condp satisfies? node
            IsNullNode
                (let [
                    #_"LIRKind" kind (Stamp'''getLIRKind-1 (:stamp (Unary'''getValue-1 node)))
                    #_"Value" nullValue (LIRGenerator''emitConstant-3 (:gen this), kind, JavaConstant/NULL_POINTER)
                ]
                    (LIRGenerator''emitConditionalMove-7 (:gen this), (#_"ValueKind" .getPlatformKind kind), (LIRBuilder''operand-2 this, (Unary'''getValue-1 node)), nullValue, Condition'EQ, trueValue, falseValue)
                )
            CompareNode
                (let [
                    #_"PlatformKind" kind (#_"ValueKind" .getPlatformKind (Stamp'''getLIRKind-1 (:stamp (:x node))))
                ]
                    (LIRGenerator''emitConditionalMove-7 (:gen this), kind, (LIRBuilder''operand-2 this, (:x node)), (LIRBuilder''operand-2 this, (:y node)), (:canonical (:condition node)), trueValue, falseValue)
                )
            LogicConstantNode
                (LIRGenerator''emitMove-2 (:gen this), (if (:value node) trueValue falseValue))
            IntegerTestNode
                (LIRGenerator''emitIntegerTestMove-5 (:gen this), (LIRBuilder''operand-2 this, (:x node)), (LIRBuilder''operand-2 this, (:y node)), trueValue, falseValue)
        )
    )

    (defn #_"void" LIRBuilder''emitConditional-2 [#_"LIRBuilder" this, #_"ConditionalNode" conditional]
        (let [
            #_"Value" trueValue (LIRBuilder''operand-2 this, (:trueValue conditional))
            #_"Value" falseValue (LIRBuilder''operand-2 this, (:falseValue conditional))
        ]
            (LIRBuilder''setResult-3 this, conditional, (LIRBuilder''emitConditional-4 this, (:logic conditional), trueValue, falseValue))
        )
        nil
    )

    (defn #_"void" LIRBuilder''emitOverflowCheckBranch-5 [#_"LIRBuilder" this, #_"AbstractBeginNode" overflowSuccessor, #_"AbstractBeginNode" _next, #_"Stamp" stamp, #_"double" probability]
        (LIRGenerator''emitOverflowCheckBranch-5 (:gen this), (LIRBuilder''getLIRBlock-2 this, overflowSuccessor), (LIRBuilder''getLIRBlock-2 this, _next), (Stamp'''getLIRKind-1 stamp), probability)
        nil
    )

    ;;;
     ; This method tries to create a switch implementation that is optimal for the given switch. It
     ; will either generate a sequential if/then/else cascade, a set of range tests or a table switch.
     ;
     ; If the given switch does not contain int keys, it will always create a sequential implementation.
     ;;
    (defn #_"void" LIRBuilder''emitSwitch-2 [#_"LIRBuilder" this, #_"SwitchNode" node]
        (let [
            #_"LabelRef" defaultTarget (LIRBuilder''getLIRBlock-2 this, (SwitchNode''defaultSuccessor-1 node))
            #_"int" keyCount (count (:keys node))
        ]
            (if (zero? keyCount)
                (LIRGenerator''emitJump-2 (:gen this), defaultTarget)
                (let [
                    #_"Variable" value (LIRGenerator''load-2 (:gen this), (LIRBuilder''operand-2 this, (:value node)))
                ]
                    (cond
                        (= keyCount 1)
                            (let [
                                #_"double" probability (ControlSplitNode'''probability-2 node, (SwitchNode''keySuccessor-2 node, 0))
                                #_"LIRKind" kind (Stamp'''getLIRKind-1 (:stamp (:value node)))
                                #_"Value" key (LIRGenerator''emitConstant-3 (:gen this), kind, (SwitchNode'''keyAt-2 node, 0))
                            ]
                                (LIRGenerator''emitCompareBranch-8 (:gen this), (#_"ValueKind" .getPlatformKind kind), (LIRGenerator''load-2 (:gen this), (LIRBuilder''operand-2 this, (:value node))), key, Condition'EQ, (LIRBuilder''getLIRBlock-2 this, (SwitchNode''keySuccessor-2 node, 0)), defaultTarget, probability)
                            )
                        (and (satisfies? IntegerSwitchNode node) (SwitchNode'''isSorted-1 node))
                            (let [
                                #_"LabelRef[]" keyTargets (make-array LabelRef'iface keyCount)
                                #_"JavaConstant[]" keyConstants (make-array JavaConstant keyCount)
                                #_"double[]" keyProbabilities (double-array keyCount)
                                #_"JavaKind" keyKind (#_"JavaConstant" .getJavaKind (SwitchNode'''keyAt-2 node, 0))
                            ]
                                (dotimes [#_"int" i keyCount]
                                    (aset keyTargets i (LIRBuilder''getLIRBlock-2 this, (SwitchNode''keySuccessor-2 node, i)))
                                    (aset keyConstants i (SwitchNode'''keyAt-2 node, i))
                                    (aset keyProbabilities i (SwitchNode''keyProbability-2 node, i))
                                )
                                (LIRGenerator''emitStrategySwitch-6 (:gen this), keyConstants, keyProbabilities, keyTargets, defaultTarget, value)
                            )
                        :else
                            ;; keyKind != JavaKind.Int || !node.isSorted()
                            (let [
                                #_"LabelRef[]" keyTargets (make-array LabelRef'iface keyCount)
                                #_"Constant[]" keyConstants (make-array Constant keyCount)
                                #_"double[]" keyProbabilities (double-array keyCount)
                            ]
                                (dotimes [#_"int" i keyCount]
                                    (aset keyTargets i (LIRBuilder''getLIRBlock-2 this, (SwitchNode''keySuccessor-2 node, i)))
                                    (aset keyConstants i (SwitchNode'''keyAt-2 node, i))
                                    (aset keyProbabilities i (SwitchNode''keyProbability-2 node, i))
                                )

                                ;; hopefully only a few entries
                                (LIRGenerator''emitStrategySwitch-5 (:gen this), (SequentialStrategy'new-2 keyProbabilities, keyConstants), value, keyTargets, defaultTarget)
                            )
                    )
                )
            )
        )
        nil
    )

    (defn #_"Value[]" LIRBuilder''visitInvokeArguments-3 [#_"LIRBuilder" this, #_"CallingConvention" invokeCc, #_"Collection<ValueNode>" arguments]
        ;; for each argument, load it into the correct location
        (let [
            #_"Value[]" args (make-array Value (count arguments))
        ]
            (loop-when [#_"int" j 0 #_"ISeq" s (seq arguments)] (some? s)
                (let [
                    #_"ValueNode" arg (first s)
                ]
                    (when (some? arg) => (throw! "I thought we no longer have nil entries for two-slot types...")
                        (let [
                            #_"AllocatableValue" operand (#_"CallingConvention" .getArgument invokeCc, j)
                        ]
                            (LIRGenerator''emitMove-3 (:gen this), operand, (LIRBuilder''operand-2 this, arg))
                            (aset args j operand)
                            (recur (inc j) (next s))
                        )
                    )
                )
            )
            args
        )
    )

    (defn- #_"void" LIRBuilder''emitDirectCall-5 [#_"LIRBuilder" this, #_"DirectCallTargetNode" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (let [
            #_"InvokeKind" invokeKind (:invokeKind callTarget)
        ]
            (if (InvokeKind''isIndirect-1 invokeKind)
                (LIRGenerator''append-2 (:gen this), (DirectVirtualCallOp'new-5 (:targetMethod callTarget), result, parameters, temps, invokeKind))
                (LIRGenerator''append-2 (:gen this), (DirectStaticCallOp'new-5 (:targetMethod callTarget), result, parameters, temps, invokeKind))
            )
        )
        nil
    )

    (defn #_"void" LIRBuilder''emitInvoke-2 [#_"LIRBuilder" this, #_"InvokeNode" invoke]
        (let [
            #_"LoweredCallTargetNode" callTarget (:callTarget invoke)
            #_"FrameMapBuilder" frameMapBuilder (:frameMapBuilder (:res (:gen this)))
            #_"CallingConvention" invokeCc (#_"RegisterConfig" .getCallingConvention HotSpot'registerConfig, (LoweredCallTargetNode''callType-1 callTarget), (Stamp'''javaType-1 (:stamp invoke)), (LoweredCallTargetNode''signature-1 callTarget), HotSpot'valueKindFactory)
        ]
            (ยง ass! frameMapBuilder (FrameMapBuilder''callsMethod-2 frameMapBuilder, invokeCc))

            (let [
                #_"Value[]" parameters (LIRBuilder''visitInvokeArguments-3 this, invokeCc, (:arguments callTarget))
                #_"Value" result (#_"CallingConvention" .getReturn invokeCc)
            ]
                (condp satisfies? callTarget
                    DirectCallTargetNode (LIRBuilder''emitDirectCall-5 this, callTarget, result, parameters, AllocatableValue/NONE)
                )
                (when-not (= result Value/ILLEGAL)
                    (LIRBuilder''setResult-3 this, invoke, (LIRGenerator''emitMove-2 (:gen this), result))
                )
            )
        )
        nil
    )
)

(class-ns LIRGenerationContext []
    (defn #_"LIRGenerationContext" LIRGenerationContext'new-4 [#_"LIRGenerator" lirGen, #_"LIRBuilder" nodeLirBuilder, #_"Graph" graph, #_"ScheduleResult" schedule]
        (merge (LIRGenerationContext'class.)
            (hash-map
                #_"LIRBuilder" :nodeLirBuilder nodeLirBuilder
                #_"LIRGenerator" :lirGen lirGen
                #_"Graph" :graph graph
                #_"ScheduleResult" :schedule schedule
            )
        )
    )
)

(class-ns LIRGenerationPhase [LIRPhase #_"<LIRGenerationContext>"]
    (defn #_"LIRGenerationPhase" LIRGenerationPhase'new-0 []
        (LIRGenerationPhase'class.)
    )

    (defm LIRGenerationPhase LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"LIRGenerationPhase" this, #_"LIRGenerationResult" lirGenRes, #_"LIRGenerationContext" context]
            (doseq [#_"Block" block (:reversePostOrder (:cfg (:lir lirGenRes)))]
                (ยง ass! (:nodeLirBuilder context) (LIRBuilder''doBlock-4 (:nodeLirBuilder context), block, (:graph context), (:blockToNodesMap (:schedule context))))
            )
            (LIRGenerator''beforeRegisterAllocation-1 (:lirGen context))
            nil
        )
    )
)

(class-ns LIRGenerationResult []
    (defn #_"LIRGenerationResult" LIRGenerationResult'new-2 [#_"LIR" lir, #_"CallingConvention" callingConvention]
        (merge (LIRGenerationResult'class.)
            (hash-map
                #_"LIR" :lir lir
                ;;;
                 ; FrameMapBuilder for collecting the information to build a FrameMap.
                 ;
                 ; Valid only prior calling #buildFrameMap.
                 ;;
                #_"FrameMapBuilder" :frameMapBuilder (FrameMapBuilder'new-0)
                ;;;
                 ; FrameMap associated with this LIRGenerationResult.
                 ;
                 ; Valid only after calling #buildFrameMap.
                 ;;
                #_"FrameMap" :frameMap nil
                ;;;
                 ; Incoming calling convention for the parameters of the method that is compiled.
                 ;;
                #_"CallingConvention" :callingConvention callingConvention
                ;;;
                 ; Records whether the code being generated makes at least one foreign call.
                 ;;
                #_"boolean" :hasForeignCall false
            )
        )
    )

    ;;;
     ; Creates a FrameMap out of the FrameMapBuilder. This method should only be
     ; called once. After calling it, #getFrameMapBuilder() can no longer be used.
     ;;
    (defn #_"LIRGenerationResult" LIRGenerationResult''buildFrameMap-1 [#_"LIRGenerationResult" this]
        (assoc this :frameMap (FrameMapBuilder''buildFrameMap-2 (:frameMapBuilder this), this))
    )
)

;;;
 ; This namespace traverses the HIR instructions and generates LIR instructions from them.
 ;;
(class-ns LIRGenerator []
    (defn #_"LIRGenerator" LIRGenerator'new-1 [#_"LIRGenerationResult" res]
        (merge (LIRGenerator'class.)
            (hash-map
                #_"LIRGenerationResult" :res res
                ;;;
                 ; Intended to be a special MoveFactory for spill moves.
                 ;
                 ; The instructions returned by this factory must only depend on the input values. References
                 ; to values that require interaction with register allocation are strictly forbidden.
                 ;;
                #_"MoveFactory" :moveFactory (MoveFactory'new-1 (:frameMapBuilder res))
                #_"LockStackHolder" :lockStackHolder nil
                #_"SaveRbp" :saveRbp nil
                ;;;
                 ; List of epilogue operations that need to restore RBP.
                 ;;
                #_"List<AMD64HotSpotRestoreRbpOp>" :epilogueOps (ArrayList.)
                #_"Register" :pollOnReturnScratchRegister nil
                #_"Block" :currentBlock nil
            )
        )
    )

    (defn #_"LIRInstruction" LIRGenerator''append-2 [#_"LIRGenerator" this, #_"LIRInstruction" op]
        (#_"ArrayList" .add (LIR''getLIRforBlock-2 (:lir (:res this)), (:currentBlock this)), op)
        (when (satisfies? AMD64HotSpotRestoreRbpOp op)
            (#_"List" .add (:epilogueOps this), op)
        )
        op
    )

    ;;;
     ; Emit an atomic read-and-add instruction.
     ;
     ; @param address address of the value to be read and written
     ; @param delta the value to be added
     ;;
    (defn #_"Value" LIRGenerator''emitAtomicReadAndAdd-3 [#_"LIRGenerator" this, #_"Value" address, #_"Value" delta]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind delta)
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
        ]
            (LIRGenerator''append-2 this, (AtomicReadAndAddOp'new-4 (#_"ValueKind" .getPlatformKind kind), result, addressValue, (LIRGenerator''asAllocatable-2 this, delta)))
            result
        )
    )

    ;;;
     ; Emit an atomic read-and-write instruction.
     ;
     ; @param address address of the value to be read and written
     ; @param newValue the new value to be written
     ;;
    (defn #_"Value" LIRGenerator''emitAtomicReadAndWrite-3 [#_"LIRGenerator" this, #_"Value" address, #_"Value" newValue]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind newValue)
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
        ]
            (LIRGenerator''append-2 this, (AtomicReadAndWriteOp'new-4 (#_"ValueKind" .getPlatformKind kind), result, addressValue, (LIRGenerator''asAllocatable-2 this, newValue)))
            result
        )
    )

    ;;;
     ; Create a new Variable.
     ;
     ; @param kind The type of the value that will be stored in this Variable. See LIRKind for documentation
     ;            on what to pass here. Note that in most cases, simply passing Value#getValueKind() is wrong.
     ; @return a new Variable
     ;;
    (defn #_"Variable" LIRGenerator''newVariable-2 [#_"LIRGenerator" this, #_"ValueKind" valueKind]
        (Variable'new-2 valueKind, (LIR''nextVariable-1 (:lir (:res this))))
    )

    (defn #_"Variable" LIRGenerator''emitMove-2 [#_"LIRGenerator" this, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind input))
        ]
            (LIRGenerator''emitMove-3 this, result, input)
            result
        )
    )

    (defn #_"void" LIRGenerator''emitMove-3 [#_"LIRGenerator" this, #_"AllocatableValue" dst, #_"Value" src]
        (LIRGenerator''append-2 this, (MoveFactory'createMove-2 dst, src))
        nil
    )

    (defn #_"void" LIRGenerator''emitMoveConstant-3 [#_"LIRGenerator" this, #_"AllocatableValue" dst, #_"Constant" src]
        (LIRGenerator''append-2 this, (MoveFactory'createLoad-2 dst, src))
        nil
    )

    (defn #_"Value" LIRGenerator''emitConstant-3 [#_"LIRGenerator" this, #_"LIRKind" kind, #_"Constant" constant]
        (if (MoveFactory'canInlineConstant-1 constant)
            (ConstantValue'new-2 (LIRGenerator'toRegisterKind-1 kind), constant)
            (LIRGenerator''emitLoadConstant-3 this, (LIRGenerator'toRegisterKind-1 kind), constant)
        )
    )

    (defn #_"Value" LIRGenerator''emitJavaConstant-2 [#_"LIRGenerator" this, #_"JavaConstant" constant]
        (LIRGenerator''emitConstant-3 this, (#_"ValueKindFactory" .getValueKind HotSpot'valueKindFactory, (#_"JavaConstant" .getJavaKind constant)), constant)
    )

    (defn #_"Variable" LIRGenerator''emitAddress-2 [#_"LIRGenerator" this, #_"AllocatableValue" stackslot]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))))
        ]
            (LIRGenerator''append-2 this, (StackLeaOp'new-2 result, stackslot))
            result
        )
    )

    (defn #_"void" LIRGenerator''emitMembar-2 [#_"LIRGenerator" this, #_"int" barriers]
        (let [
            #_"int" necessaryBarriers (#_"Architecture" .requiredBarriers (.arch HotSpot'target), barriers)
        ]
            (when (and (.isMP HotSpot'target) (not (zero? necessaryBarriers)))
                (LIRGenerator''append-2 this, (MembarOp'new-1 necessaryBarriers))
            )
        )
        nil
    )

    ;;;
     ; Some backends need to convert sub-word kinds to a larger kind in LIRGenerator#emitLoad and #emitLoadConstant
     ; because sub-word registers can't be accessed. This method converts the LIRKind of a memory location or constant
     ; to the LIRKind that will be used when it is loaded into a register.
     ;
     ; The AMD64 backend only uses DWORD and QWORD values in registers because of a performance penalty when accessing
     ; WORD or BYTE registers. This function converts small integer kinds to DWORD.
     ;;
    (defn #_"ValueKind" LIRGenerator'toRegisterKind-1 [#_"ValueKind" kind]
        (when (any = (#_"ValueKind" .getPlatformKind kind) AMD64Kind/BYTE AMD64Kind/WORD) => kind
            (#_"ValueKind" .changeType kind, AMD64Kind/DWORD)
        )
    )

    (defn #_"AllocatableValue" LIRGenerator''emitLoadConstant-3 [#_"LIRGenerator" this, #_"ValueKind" kind, #_"Constant" constant]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''emitMoveConstant-3 this, result, constant)
            result
        )
    )

    (defn #_"void" LIRGenerator''emitNullCheck-2 [#_"LIRGenerator" this, #_"Value" address]
        (if (= (#_"ValueKind" .getPlatformKind (#_"Value" .getValueKind address)) (#_"ValueKind" .getPlatformKind (LIRKindTool'getNarrowOopKind-0)))
            (let [
                #_"CompressEncoding" encoding HotSpot'oopEncoding
                #_"Value" uncompressed
                    (if (<= (:shift encoding) 3)
                        (let [
                            #_"LIRKind" wordKind (LIRKind'unknownReference-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))
                        ]
                            (AMD64AddressValue'new-5 wordKind, (#_"Register" .asValue HotSpot'heapBaseRegister, wordKind), (LIRGenerator''asAllocatable-2 this, address), (Scale'fromInt-1 (<< 1 (:shift encoding))), 0)
                        )
                        (LIRGenerator''emitUncompress-4 this, address, encoding, false)
                    )
            ]
                (LIRGenerator''append-2 this, (NullCheckOp'new-1 (LIRGenerator''asAddressValue-2 this, uncompressed)))
            )
            (LIRGenerator''append-2 this, (NullCheckOp'new-1 (LIRGenerator''asAddressValue-2 this, address)))
        )
        nil
    )

    (defn #_"Variable" LIRGenerator''emitLogicCompareAndSwap-6 [#_"LIRGenerator" this, #_"Value" address, #_"Value" expectedValue, #_"Value" newValue, #_"Value" trueValue, #_"Value" falseValue]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind newValue)
            #_"AMD64Kind" memKind (#_"ValueKind" .getPlatformKind kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
            #_"RegisterValue" raxRes (#_"Register" .asValue AMD64/rax, kind)
        ]
            (LIRGenerator''emitMove-3 this, raxRes, expectedValue)
            (LIRGenerator''append-2 this, (CompareAndSwapOp'new-5 memKind, raxRes, addressValue, raxRes, (LIRGenerator''asAllocatable-2 this, newValue)))

            (let [
                #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind trueValue))
            ]
                (LIRGenerator''append-2 this, (CondMoveOp'new-4 result, Condition'EQ, (LIRGenerator''asAllocatable-2 this, trueValue), falseValue))
                result
            )
        )
    )

    (defn #_"Value" LIRGenerator''emitValueCompareAndSwap-4 [#_"LIRGenerator" this, #_"Value" address, #_"Value" expectedValue, #_"Value" newValue]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind newValue)
            #_"AMD64Kind" memKind (#_"ValueKind" .getPlatformKind kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
            #_"RegisterValue" raxRes (#_"Register" .asValue AMD64/rax, kind)
        ]
            (LIRGenerator''emitMove-3 this, raxRes, expectedValue)
            (LIRGenerator''append-2 this, (CompareAndSwapOp'new-5 memKind, raxRes, addressValue, raxRes, (LIRGenerator''asAllocatable-2 this, newValue)))
            (let [
                #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
            ]
                (LIRGenerator''emitMove-3 this, result, raxRes)
                result
            )
        )
    )

    #_unused
    (defn #_"void" LIRGenerator''emitCompareAndSwapBranch-9 [#_"LIRGenerator" this, #_"ValueKind" kind, #_"AMD64AddressValue" address, #_"Value" expectedValue, #_"Value" newValue, #_"Condition" condition, #_"LabelRef" trueLabel, #_"LabelRef" falseLabel, #_"double" trueLabelProbability]
        (let [
            #_"AMD64Kind" memKind (#_"ValueKind" .getPlatformKind kind)
            #_"RegisterValue" raxValue (#_"Register" .asValue AMD64/rax, kind)
        ]
            (LIRGenerator''emitMove-3 this, raxValue, expectedValue)
            (LIRGenerator''append-2 this, (CompareAndSwapOp'new-5 memKind, raxValue, address, raxValue, (LIRGenerator''asAllocatable-2 this, newValue)))
            (LIRGenerator''append-2 this, (BranchOp'new-4c condition, trueLabel, falseLabel, trueLabelProbability))
        )
        nil
    )

    (defn- #_"void" LIRGenerator''moveValueToThread-3 [#_"LIRGenerator" this, #_"Value" value, #_"int" offset]
        (let [
            #_"LIRKind" wordKind (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))
            #_"RegisterValue" thread (#_"Register" .asValue HotSpot'threadRegister, wordKind)
            #_"AMD64AddressValue" address (AMD64AddressValue'new-3 wordKind, thread, offset)
        ]
            (LIRGenerator''emitStore-4v this, (#_"Value" .getValueKind value), address, value)
        )
        nil
    )

    (defn- #_"void" LIRGenerator''moveDeoptValuesToThread-3 [#_"LIRGenerator" this, #_"Value" actionAndReason, #_"Value" speculation]
        (LIRGenerator''moveValueToThread-3 this, actionAndReason, HotSpot'pendingDeoptimizationOffset)
        (LIRGenerator''moveValueToThread-3 this, speculation, HotSpot'pendingFailedSpeculationOffset)
        nil
    )

    (defn #_"void" LIRGenerator''emitDeoptimize-3 [#_"LIRGenerator" this, #_"Value" actionAndReason, #_"Value" speculation]
        (LIRGenerator''moveDeoptValuesToThread-3 this, actionAndReason, speculation)
        (LIRGenerator''append-2 this, (AMD64DeoptimizeOp'new-0))
        nil
    )

    (defn #_"void" LIRGenerator''emitDeoptimizeCaller-3 [#_"LIRGenerator" this, #_"DeoptimizationAction" action, #_"DeoptimizationReason" reason]
        (let [
            #_"Value" actionAndReason (LIRGenerator''emitJavaConstant-2 this, (#_"MetaAccessProvider" .encodeDeoptActionAndReason HotSpot'metaAccess, action, reason, 0))
            #_"Value" nullValue (LIRGenerator''emitConstant-3 this, (LIRKind'reference-1 AMD64Kind/QWORD), JavaConstant/NULL_POINTER)
        ]
            (LIRGenerator''moveDeoptValuesToThread-3 this, actionAndReason, nullValue)
            (LIRGenerator''append-2 this, (DeoptimizeCallerOp'new-0))
        )
        nil
    )

    ;;;
     ; Gets the ABI specific operand used to return a value of a given kind from a method.
     ;
     ; @param javaKind the kind of value being returned
     ; @param valueKind the backend type of the value being returned
     ; @return the operand representing the ABI defined location used return a value of kind {@code kind}
     ;;
    (defn- #_"AllocatableValue" LIRGenerator'resultOperandFor-2 [#_"JavaKind" javaKind, #_"ValueKind" valueKind]
        (#_"Register" .asValue (#_"RegisterConfig" .getReturnRegister HotSpot'registerConfig, javaKind), valueKind)
    )

    (defn- #_"Register" LIRGenerator'findPollOnReturnScratchRegister-0 []
        (loop-when [#_"ISeq" s (seq (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))] (some? s) => (throw! "should not reach here")
            (let [
                #_"Register" r (first s)
            ]
                (when (and (not (= r (#_"RegisterConfig" .getReturnRegister HotSpot'registerConfig, JavaKind/Long))) (not (= r AMD64/rbp))) => (recur (next s))
                    r
                )
            )
        )
    )

    ;;;
     ; Emits a return instruction. Implementations need to insert a move if the input is not in the correct location.
     ;;
    (defn #_"this" LIRGenerator''emitReturn-3 [#_"LIRGenerator" this, #_"JavaKind" kind, #_"Value" input]
        (let [
            #_"AllocatableValue" operand
                (when (some? input) => Value/ILLEGAL
                    (let [
                        operand (LIRGenerator'resultOperandFor-2 kind, (#_"Value" .getValueKind input))
                    ]
                        (LIRGenerator''emitMove-3 this, operand, input)
                        operand
                    )
                )
            this
                (when (nil? (:pollOnReturnScratchRegister this)) => this
                    (assoc this :pollOnReturnScratchRegister (LIRGenerator'findPollOnReturnScratchRegister-0))
                )
        ]
            (LIRGenerator''append-2 this, (AMD64HotSpotReturnOp'new-3 operand, HotSpot'threadRegister, (:pollOnReturnScratchRegister this)))
            this
        )
    )

    (defn #_"AllocatableValue" LIRGenerator''asAllocatable-2 [#_"LIRGenerator" this, #_"Value" value]
        (condp instance? value
            AllocatableValue value
            ConstantValue'iface    (LIRGenerator''emitLoadConstant-3 this, (#_"Value" .getValueKind value), (:constant value))
                             (LIRGenerator''emitMove-2 this, value)
        )
    )

    (defn #_"Variable" LIRGenerator''load-2 [#_"LIRGenerator" this, #_"Value" value]
        (if (satisfies? Variable value) value (LIRGenerator''emitMove-2 this, value))
    )

    (defn #_"Value" LIRGenerator''loadNonConst-2 [#_"LIRGenerator" this, #_"Value" value]
        (if (and (satisfies? ConstantValue value) (not (MoveFactory'canInlineConstant-1 (:constant value))))
            (LIRGenerator''emitMove-2 this, value)
            value
        )
    )

    (defn #_"boolean" LIRGenerator''hasBlockEnd-2 [#_"LIRGenerator" this, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:res this)), block)
        ]
            (and (seq ops)
                (satisfies? BlockEndOp (nth ops (dec (count ops))))
            )
        )
    )

    (defn #_"BlockScope" LIRGenerator''getBlockScope-2 [#_"LIRGenerator" this, #_"Block" block]
        (let [
            #_"BlockScope" blockScope (BlockScope'new-2 this, block)
        ]
            (BlockScope''doBlockStart-1 blockScope)
            blockScope
        )
    )

    (defn #_"void" LIRGenerator''emitIncomingValues-2 [#_"LIRGenerator" this, #_"Value[]" params]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:res this)), (:currentBlock this))
        ]
            (ยง ass! (nth ops 0) (LabelOp''setIncomingValues-2 (nth ops 0), params))
        )
        nil
    )

    (defn #_"void" LIRGenerator''emitJump-2 [#_"LIRGenerator" this, #_"LabelRef" label]
        (LIRGenerator''append-2 this, (JumpOp'new-1 label))
        nil
    )

    (defn- #_"void" LIRGenerator''emitRawCompare-4 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" left, #_"Value" right]
        (LIRGenerator''emitCompareOp-4 this, cmpKind, (LIRGenerator''load-2 this, left), (LIRGenerator''loadNonConst-2 this, right))
        nil
    )

    ;;;
     ; This method emits the compare instruction, and may reorder the operands. It returns true if it did so.
     ;
     ; @param a the left operand of the comparison
     ; @param b the right operand of the comparison
     ; @param cond the condition of the comparison
     ; @return true if the left and right operands were switched, false otherwise
     ;;
    (defn- #_"Condition" LIRGenerator''emitCompare-5 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" a, #_"Value" b, #_"Condition" condition]
        (if (satisfies? Variable b)
            (do
                (LIRGenerator''emitRawCompare-4 this, cmpKind, b, a)
                (Condition''mirror-1 condition)
            )
            (do
                (LIRGenerator''emitRawCompare-4 this, cmpKind, a, b)
                condition
            )
        )
    )

    (defn #_"void" LIRGenerator''emitCompareBranch-8 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" left, #_"Value" right, #_"Condition" cond, #_"LabelRef" trueLabel, #_"LabelRef" falseLabel, #_"double" trueLabelProbability]
        (ยง ass cond (LIRGenerator''emitCompare-5 this, cmpKind, left, right, cond))
        (LIRGenerator''append-2 this, (BranchOp'new-4c cond, trueLabel, falseLabel, trueLabelProbability))
        nil
    )

    (defn #_"void" LIRGenerator''emitOverflowCheckBranch-5 [#_"LIRGenerator" this, #_"LabelRef" overflow, #_"LabelRef" noOverflow, #_"LIRKind" cmpLIRKind, #_"double" overflowProbability]
        (LIRGenerator''append-2 this, (BranchOp'new-4f ConditionFlag'Overflow, overflow, noOverflow, overflowProbability))
        nil
    )

    (defn- #_"void" LIRGenerator''emitIntegerTest-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"OperandSize" size (if (= (#_"Value" .getPlatformKind a) AMD64Kind/QWORD) OperandSize'QWORD OperandSize'DWORD)
        ]
            (cond
                (and (LIRValueUtil'isJavaConstant-1 b) (NumUtil'is32bit-1 (#_"JavaConstant" .asLong (:constant b))))
                    (LIRGenerator''append-2 this, (ConsumerConstOp'new-4a AMD64MIOp'TEST, size, (LIRGenerator''asAllocatable-2 this, a), (int (#_"JavaConstant" .asLong (:constant b)))))
                (and (LIRValueUtil'isJavaConstant-1 a) (NumUtil'is32bit-1 (#_"JavaConstant" .asLong (:constant a))))
                    (LIRGenerator''append-2 this, (ConsumerConstOp'new-4a AMD64MIOp'TEST, size, (LIRGenerator''asAllocatable-2 this, b), (int (#_"JavaConstant" .asLong (:constant a)))))
                (instance? AllocatableValue b)
                    (LIRGenerator''append-2 this, (ConsumerOp'new-4 AMD64RMOp'TEST, size, (LIRGenerator''asAllocatable-2 this, b), (LIRGenerator''asAllocatable-2 this, a)))
                :else
                    (LIRGenerator''append-2 this, (ConsumerOp'new-4 AMD64RMOp'TEST, size, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b)))
            )
        )
        nil
    )

    (defn #_"void" LIRGenerator''emitIntegerTestBranch-6 [#_"LIRGenerator" this, #_"Value" left, #_"Value" right, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (LIRGenerator''emitIntegerTest-3 this, left, right)
        (LIRGenerator''append-2 this, (BranchOp'new-4c Condition'EQ, trueDestination, falseDestination, trueDestinationProbability))
        nil
    )

    (defn #_"Variable" LIRGenerator''emitConditionalMove-7 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" left, #_"Value" right, #_"Condition" cond, #_"Value" trueValue, #_"Value" falseValue]
        (ยง ass cond (LIRGenerator''emitCompare-5 this, cmpKind, left, right, cond))

        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind trueValue))
        ]
            (cond
                (and (LIRValueUtil'isIntConstant-2 trueValue, 1) (LIRValueUtil'isIntConstant-2 falseValue, 0))
                    (LIRGenerator''append-2 this, (CondSetOp'new-2 result, cond))
                (and (LIRValueUtil'isIntConstant-2 trueValue, 0) (LIRValueUtil'isIntConstant-2 falseValue, 1))
                    (LIRGenerator''append-2 this, (CondSetOp'new-2 result, (Condition''negate-1 cond)))
                :else
                    (LIRGenerator''append-2 this, (CondMoveOp'new-4 result, cond, (LIRGenerator''load-2 this, trueValue), (LIRGenerator''loadNonConst-2 this, falseValue)))
            )
            result
        )
    )

    (defn #_"Variable" LIRGenerator''emitIntegerTestMove-5 [#_"LIRGenerator" this, #_"Value" left, #_"Value" right, #_"Value" trueValue, #_"Value" falseValue]
        (LIRGenerator''emitIntegerTest-3 this, left, right)
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind trueValue))
        ]
            (LIRGenerator''append-2 this, (CondMoveOp'new-4 result, Condition'EQ, (LIRGenerator''load-2 this, trueValue), (LIRGenerator''loadNonConst-2 this, falseValue)))
            result
        )
    )

    ;;;
     ; Emits the single call operation at the heart of generating LIR for a {@linkplain #emitForeignCall(ForeignCallLinkage, Value...) foreign call}.
     ;;
    (defn #_"void" LIRGenerator''emitForeignCallOp-5 [#_"LIRGenerator" this, #_"ForeignCallLinkage" linkage, #_"Value" result, #_"Value[]" arguments, #_"Value[]" temps]
        (let [
            #_"long" maxOffset (ForeignCallLinkage''getMaxCallTargetOffset-1 linkage)
        ]
            (if (= maxOffset (int maxOffset))
                (LIRGenerator''append-2 this, (DirectNearForeignCallOp'new-4 linkage, result, arguments, temps))
                (LIRGenerator''append-2 this, (DirectFarForeignCallOp'new-4 linkage, result, arguments, temps))
            )
        )
        nil
    )

    (defn- #_"Variable" LIRGenerator''_emitForeignCall-3* [#_"LIRGenerator" this, #_"ForeignCallLinkage" linkage & #_"Value..." args]
        (let [
            #_"CallingConvention" linkageCc (:outgoingCallingConvention linkage)
        ]
            (ยง ass! (:frameMapBuilder (:res this)) (FrameMapBuilder''callsMethod-2 (:frameMapBuilder (:res this)), linkageCc))

            (let [
                ;; move the arguments into the correct location
                #_"Value[]" argLocations (make-array Value (count args))
                _
                    (dotimes [#_"int" i (count args)]
                        (let [
                            #_"AllocatableValue" loc (#_"CallingConvention" .getArgument linkageCc, i)
                        ]
                            (LIRGenerator''emitMove-3 this, loc, (nth args i))
                            (aset argLocations i loc)
                        )
                    )
            ]
                (ยง ass! this (assoc-in this [:res :hasForeignCall] true))
                (LIRGenerator''emitForeignCallOp-5 this, linkage, (#_"CallingConvention" .getReturn linkageCc), argLocations, (#_"Object" .clone (:temporaries linkage)))

                (when-not (= (#_"CallingConvention" .getReturn linkageCc) Value/ILLEGAL)
                    (LIRGenerator''emitMove-2 this, (#_"CallingConvention" .getReturn linkageCc))
                )
            )
        )
    )

    (defn #_"Variable" LIRGenerator''emitForeignCall-3* [#_"LIRGenerator" this, #_"ForeignCallLinkage" linkage & #_"Value..." args]
        (when (ForeignCallLinkage''needsJavaFrameAnchor-1 linkage) => (apply LIRGenerator''_emitForeignCall-3* this, linkage, args)
            (LIRGenerator''append-2 this, (CRuntimeCallPrologueOp'new-2 HotSpot'threadLastJavaSpOffset, HotSpot'threadRegister))
            (let [
                #_"Variable" result (apply LIRGenerator''_emitForeignCall-3* this, linkage, args)
            ]
                (LIRGenerator''append-2 this, (CRuntimeCallEpilogueOp'new-4 HotSpot'threadLastJavaSpOffset, HotSpot'threadLastJavaFpOffset, HotSpot'threadLastJavaPcOffset, HotSpot'threadRegister))
                result
            )
        )
    )

    (defn #_"void" LIRGenerator''emitStrategySwitch-5 [#_"LIRGenerator" this, #_"SwitchStrategy" strategy, #_"Variable" key, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget]
        ;; a temp is needed for loading object constants
        (LIRGenerator''append-2 this, (AMD64HotSpotStrategySwitchOp'new-5 strategy, keyTargets, defaultTarget, key, (if-not (LIRKind'isValue-1v key) (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind key)) Value/ILLEGAL)))
        nil
    )

    (defn #_"void" LIRGenerator''emitTableSwitch-5 [#_"LIRGenerator" this, #_"int" lowKey, #_"LabelRef" defaultTarget, #_"LabelRef[]" targets, #_"Value" key]
        (LIRGenerator''append-2 this, (TableSwitchOp'new-6 lowKey, defaultTarget, targets, key, (LIRGenerator''newVariable-2 this, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))), (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind key))))
        nil
    )

    (defn #_"void" LIRGenerator''emitStrategySwitch-6 [#_"LIRGenerator" this, #_"JavaConstant[]" keyConstants, #_"double[]" keyProbabilities, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Variable" value]
        (let [
            #_"int" keyCount (count keyConstants)
            #_"SwitchStrategy" strategy (SwitchStrategy'getBestStrategy-3 keyProbabilities, keyConstants, keyTargets)
            #_"long" valueRange (inc (- (#_"JavaConstant" .asLong (nth keyConstants (dec keyCount))) (#_"JavaConstant" .asLong (nth keyConstants 0))))
            #_"double" tableSwitchDensity (/ keyCount (double valueRange))
        ]
            ;; This heuristic tries to find a compromise between the effort for the best switch strategy
            ;; and the density of a tableswitch. If the effort for the strategy is at least 4, then a
            ;; tableswitch is preferred if better than a certain value that starts at 0.5 and lowers
            ;; gradually with additional effort.
            (if (or (< (SwitchStrategy'''getAverageEffort-1 strategy) 4) (< tableSwitchDensity (/ 1.0 (Math/sqrt (SwitchStrategy'''getAverageEffort-1 strategy)))))
                (LIRGenerator''emitStrategySwitch-5 this, strategy, value, keyTargets, defaultTarget)
                (let [
                    #_"int" minValue (#_"JavaConstant" .asInt (nth keyConstants 0))
                    #_"LabelRef[]" targets (make-array LabelRef'iface (int valueRange))
                ]
                    (dotimes [#_"int" i valueRange]
                        (aset targets i defaultTarget)
                    )
                    (dotimes [#_"int" i keyCount]
                        (aset targets (- (#_"JavaConstant" .asInt (nth keyConstants i)) minValue) (nth keyTargets i))
                    )
                    (LIRGenerator''emitTableSwitch-5 this, minValue, defaultTarget, targets, value)
                )
            )
        )
        nil
    )

    ;;;
     ; Called just before register allocation is performed on the LIR owned by this generator.
     ; Overriding implementations of this method must call the overridden method.
     ;;
    (defn #_"void" LIRGenerator''beforeRegisterAllocation-1 [#_"LIRGenerator" this]
        (let [
            #_"AllocatableValue" savedRbp (SaveRbp''finalize-2 (:saveRbp this), false)
        ]
            (doseq [#_"AMD64HotSpotRestoreRbpOp" op (:epilogueOps this)]
                (AMD64HotSpotRestoreRbpOp'''setSavedRbp-2 op, savedRbp)
            )
        )
        nil
    )

    #_unused
    (defn #_"LIRKind" LIRGenerator'getAddressKind-3 [#_"Value" base, #_"long" displacement, #_"Value" index]
        (let [
            #_"PlatformKind" wordKind (#_"Architecture" .getWordKind (.arch HotSpot'target))
        ]
            (cond
                (and (LIRKind'isValue-1v base) (or (= index Value/ILLEGAL) (LIRKind'isValue-1v index)))
                    (LIRKind'value-1 wordKind)
                (and (satisfies? LIRKind (#_"Value" .getValueKind base)) (LIRKind''isReference-2 (#_"Value" .getValueKind base, LIRKind'iface), 0) (zero? displacement) (= index Value/ILLEGAL))
                    (LIRKind'reference-1 wordKind)
                :else
                    (LIRKind'unknownReference-1 wordKind)
            )
        )
    )

    #_unused
    (defn #_"Variable" LIRGenerator''emitByteSwap-2 [#_"LIRGenerator" this, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
        ]
            (LIRGenerator''append-2 this, (AMD64ByteSwapOp'new-2 result, input))
            result
        )
    )

    (defn #_"void" LIRGenerator''emitBlackhole-2 [#_"LIRGenerator" this, #_"Value" operand]
        (LIRGenerator''append-2 this, (BlackholeOp'new-1 operand))
        nil
    )

    (defn #_"void" LIRGenerator''emitPrefetchAllocate-2 [#_"LIRGenerator" this, #_"Value" address]
        (LIRGenerator''append-2 this, (AMD64PrefetchOp'new-2 (LIRGenerator''asAddressValue-2 this, address), HotSpot'allocatePrefetchInstr))
        nil
    )

    (defn #_"Value" LIRGenerator''emitCompress-4 [#_"LIRGenerator" this, #_"Value" pointer, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (let [
            #_"LIRKind" inputKind (#_"Value" .getValueKind pointer, LIRKind'iface)
        ]
            (if (LIRKind''isReference-2 inputKind, 0)
                ;; oop
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKindTool'getNarrowOopKind-0))
                ]
                    (LIRGenerator''append-2 this, (CompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), (#_"Register" .asValue HotSpot'heapBaseRegister), encoding, never-nil?))
                    result
                )
                ;; metaspace pointer
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKindTool'getNarrowPointerKind-0))
                    #_"AllocatableValue" base
                        (when (CompressEncoding''hasBase-1 encoding) => Value/ILLEGAL
                            (LIRGenerator''emitLoadConstant-3 this, (LIRKindTool'getWordKind-0), (JavaConstant/forLong (:base encoding)))
                        )
                ]
                    (LIRGenerator''append-2 this, (CompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), base, encoding, never-nil?))
                    result
                )
            )
        )
    )

    (defn #_"Value" LIRGenerator''emitUncompress-4 [#_"LIRGenerator" this, #_"Value" pointer, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (let [
            #_"LIRKind" inputKind (#_"Value" .getValueKind pointer, LIRKind'iface)
        ]
            (if (LIRKind''isReference-2 inputKind, 0)
                ;; oop
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKindTool'getObjectKind-0))
                ]
                    (LIRGenerator''append-2 this, (UncompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), (#_"Register" .asValue HotSpot'heapBaseRegister), encoding, never-nil?))
                    result
                )
                ;; metaspace pointer
                (let [
                    #_"LIRKind" uncompressedKind (LIRKindTool'getWordKind-0)
                    #_"Variable" result (LIRGenerator''newVariable-2 this, uncompressedKind)
                    #_"AllocatableValue" base
                        (when (CompressEncoding''hasBase-1 encoding) => Value/ILLEGAL
                            (LIRGenerator''emitLoadConstant-3 this, uncompressedKind, (JavaConstant/forLong (:base encoding)))
                        )
                ]
                    (LIRGenerator''append-2 this, (UncompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), base, encoding, never-nil?))
                    result
                )
            )
        )
    )

    (defn #_"void" LIRGenerator''emitLFence-1 [#_"LIRGenerator" this]
        (LIRGenerator''append-2 this, (AMD64LFenceOp'new-0))
        nil
    )

    (defn #_"LIRGenerator" LIRGenerator''setLockStackHolder-2 [#_"LIRGenerator" this, #_"LockStackHolder" lockStackHolder]
        (assoc this :lockStackHolder lockStackHolder)
    )

    ;;;
     ; Gets a stack slot for a lock at a given lock nesting depth.
     ;;
    (defn #_"VirtualStackSlot" LIRGenerator''getLockSlot-2 [#_"LIRGenerator" this, #_"int" lockDepth]
        (LockStack''makeLockSlot-2 (:lockStack (:lockStackHolder this)), lockDepth)
    )

    (defn #_"AMD64AddressValue" LIRGenerator''asAddressValue-2 [#_"LIRGenerator" this, #_"Value" address]
        (when-not (satisfies? AMD64AddressValue address) => address
            (when (instance? JavaConstant address)
                (let [
                    #_"long" displacement (#_"JavaConstant" .asLong address)
                ]
                    (when (NumUtil'isInt-1 displacement)
                        (ยง return (AMD64AddressValue'new-3 (#_"Value" .getValueKind address), Value/ILLEGAL, (int displacement)))
                    )
                )
            )
            (AMD64AddressValue'new-3 (#_"Value" .getValueKind address), (LIRGenerator''asAllocatable-2 this, address), 0)
        )
    )

    (defn #_"this" LIRGenerator''emitSaveRbp-1 [#_"LIRGenerator" this]
        (let [
            #_"NoOp" placeholder (NoOp'new-2 (:currentBlock this), (count (LIR''getLIRforBlock-2 (:lir (:res this)), (:currentBlock this))))
        ]
            (LIRGenerator''append-2 this, placeholder)
            (assoc this :saveRbp (SaveRbp'new-2 this, placeholder))
        )
    )

    ;;;
     ; Emits code for a VMConfigNode.
     ;
     ; @param markId id of the value to load
     ; @param kind type of the value to load
     ; @return value of loaded global in register
     ;;
    (defn #_"Value" LIRGenerator''emitLoadConfigValue-3 [#_"LIRGenerator" this, #_"int" markId, #_"LIRKind" kind]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''append-2 this, (LoadConfigValueOp'new-2 markId, result))
            result
        )
    )

    ;;;
     ; Emits code for a RandomSeedNode.
     ;
     ; @return value of the counter
     ;;
    (defn #_"Value" LIRGenerator''emitRandomSeed-1 [#_"LIRGenerator" this]
        (let [
            #_"ReadTimestampCounter" timestamp (ReadTimestampCounter'new-0)
        ]
            (LIRGenerator''append-2 this, timestamp)
            (LIRGenerator''emitMove-2 this, (:lowResult timestamp))
        )
    )

    ;;;
     ; Emits an operation to make a tail call.
     ;
     ; @param args the arguments of the call
     ; @param address the target address of the call
     ;;
    #_unused
    (defn #_"void" LIRGenerator''emitTailcall-3 [#_"LIRGenerator" this, #_"Value[]" args, #_"Value" address]
        (LIRGenerator''append-2 this, (AMD64TailcallOp'new-2 args, address))
        nil
    )

    #_unused
    (defn #_"void" LIRGenerator''emitCCall-4 [#_"LIRGenerator" this, #_"long" address, #_"CallingConvention" nativeCallingConvention, #_"Value[]" args]
        (ยง ass! (:frameMapBuilder (:res this)) (FrameMapBuilder''callsMethod-2 (:frameMapBuilder (:res this)), nativeCallingConvention))
        (LIRGenerator''emitMoveConstant-3 this, (#_"Register" .asValue AMD64/rax, (LIRKind'value-1 AMD64Kind/DWORD)), (JavaConstant/forInt 0))
        (let [
            #_"Value[]" argLocations (make-array Value (count args))
            _
                (dotimes [#_"int" i (count args)]
                    (let [
                        #_"AllocatableValue" loc (#_"CallingConvention" .getArgument nativeCallingConvention, i)
                    ]
                        (LIRGenerator''emitMove-3 this, loc, (nth args i))
                        (aset argLocations i loc)
                    )
                )
            #_"Value" ptr (LIRGenerator''emitLoadConstant-3 this, (LIRKind'value-1 AMD64Kind/QWORD), (JavaConstant/forLong address))
        ]
            (LIRGenerator''append-2 this, (AMD64CCall'new-3 (#_"CallingConvention" .getReturn nativeCallingConvention), ptr, argLocations))
        )
        nil
    )

    ;;;
     ; This namespace can be used to generate LIR for arithmetic and simple memory access operations.
     ;
     ; The setFlags flag in emitAdd, emitSub and emitMul indicates, that the instruction must set the
     ; flags register to be used for a later branch. (On AMD64, the condition codes are set in every
     ; arithmetic instruction, but other architectures optionally set the flags register.) If setFlags
     ; is set, the instruction must set the flags register; if false, the instruction may or may not
     ; set the flags register.
     ;;
    (def- #_"RegisterValue" LIRGenerator'RCX_I (ยง soon #_"Register" .asValue AMD64/rcx, (LIRKind'value-1 AMD64Kind/DWORD)))

    (defn #_"Variable" LIRGenerator''emitNegate-2 [#_"LIRGenerator" this, #_"Value" input]
        (let [
            input (LIRGenerator''asAllocatable-2 this, input)
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
        ]
            (condp = (#_"Value" .getPlatformKind input)
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NEG, OperandSize'DWORD, result, input))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NEG, OperandSize'QWORD, result, input))
            )
            result
        )
    )

    (defn #_"Variable" LIRGenerator''emitNot-2 [#_"LIRGenerator" this, #_"Value" input]
        (let [
            input (LIRGenerator''asAllocatable-2 this, input)
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
        ]
            (condp = (#_"Value" .getPlatformKind input)
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NOT, OperandSize'DWORD, result, input))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NOT, OperandSize'QWORD, result, input))
            )
            result
        )
    )

    (defn- #_"AMD64MOp" LIRGenerator'getMOp-2 [#_"BinaryArithmetic" op, #_"int" constant]
        (case constant
            1   (condp = op
                    BinaryArithmetic'ADD AMD64MOp'INC
                    BinaryArithmetic'SUB AMD64MOp'DEC
                    nil
                )
            -1  (condp = op
                    BinaryArithmetic'ADD AMD64MOp'DEC
                    BinaryArithmetic'SUB AMD64MOp'INC
                    nil
                )
            nil
        )
    )

    (defn- #_"Variable" LIRGenerator''emitBinaryVar-7 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"boolean" commutative?, #_"AllocatableValue" a, #_"AllocatableValue" b]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
        ]
            (if commutative?
                (LIRGenerator''append-2 this, (CommutativeTwoOp'new-5 op, size, result, a, b))
                (LIRGenerator''append-2 this, (TwoOp'new-5 op, size, result, a, b))
            )
            result
        )
    )

    (defn- #_"Variable" LIRGenerator''emitBinaryConst-8 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"BinaryArithmetic" op, #_"OperandSize" size, #_"boolean" commutative?, #_"AllocatableValue" a, #_"ConstantValue" b, #_"boolean" set-flags?]
        (let [
            #_"long" value (#_"JavaConstant" .asLong (:constant b))
        ]
            (if (NumUtil'isInt-1 value)
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
                    #_"int" constant (int value)
                ]
                    (when-not set-flags?
                        (let [
                            #_"AMD64MOp" mop (LIRGenerator'getMOp-2 op, constant)
                        ]
                            (when (some? mop)
                                (LIRGenerator''append-2 this, (MOp'new-4 mop, size, result, a))
                                (ยง return result)
                            )
                        )
                    )

                    (LIRGenerator''append-2 this, (ConstOp'new-5b op, size, result, a, constant))
                    result
                )
                (LIRGenerator''emitBinaryVar-7 this, resultKind, (BinaryArithmetic''getRMOpcode-2 op, size), size, commutative?, a, (LIRGenerator''asAllocatable-2 this, b))
            )
        )
    )

    (defn- #_"Variable" LIRGenerator''emitBinary-8 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"BinaryArithmetic" op, #_"OperandSize" size, #_"boolean" commutative?, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (cond
            (LIRValueUtil'isJavaConstant-1 b)                    (LIRGenerator''emitBinaryConst-8 this, resultKind, op, size, commutative?, (LIRGenerator''asAllocatable-2 this, a), b, set-flags?)
            (and commutative? (LIRValueUtil'isJavaConstant-1 a)) (LIRGenerator''emitBinaryConst-8 this, resultKind, op, size, commutative?, (LIRGenerator''asAllocatable-2 this, b), a, set-flags?)
            :else                                                (LIRGenerator''emitBinaryVar-7 this, resultKind, (BinaryArithmetic''getRMOpcode-2 op, size), size, commutative?, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b))
        )
    )

    (defn- #_"Variable" LIRGenerator''emitBinaryConst-6 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"AllocatableValue" a, #_"JavaConstant" b]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
        ]
            (LIRGenerator''append-2 this, (DataTwoOp'new-5 op, size, result, a, b))
            result
        )
    )

    #_unused
    (defn- #_"Variable" LIRGenerator''emitBinary-7 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"boolean" commutative?, #_"Value" a, #_"Value" b]
        (cond
            (LIRValueUtil'isJavaConstant-1 b)                    (LIRGenerator''emitBinaryConst-6 this, resultKind, op, size, (LIRGenerator''asAllocatable-2 this, a), (:constant b))
            (and commutative? (LIRValueUtil'isJavaConstant-1 a)) (LIRGenerator''emitBinaryConst-6 this, resultKind, op, size, (LIRGenerator''asAllocatable-2 this, b), (:constant a))
            :else                                                (LIRGenerator''emitBinaryVar-7 this, resultKind, op, size, commutative?, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b))
        )
    )

    (defn- #_"Variable" LIRGenerator''emitAddOrSub-5 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b, #_"boolean" set-flags?, #_"boolean" isAdd]
        (let [
            [a b #_"LIRKind" resultKind]
                (if (#_"AMD64Kind" .isInteger (#_"Value" .getPlatformKind a))
                    (let [
                        #_"LIRKind" aKind (#_"Value" .getValueKind a, LIRKind'iface)
                        #_"LIRKind" bKind (#_"Value" .getValueKind b, LIRKind'iface)
                    ]
                        (cond
                            (LIRKind''isUnknownReference-1 aKind)                       [a b aKind]
                            (LIRKind''isUnknownReference-1 bKind)                       [a b bKind]
                            (and (LIRKind''isValue-1 aKind) (LIRKind''isValue-1 bKind)) [a b aKind]
                            (LIRKind''isValue-1 aKind)
                                (if (LIRKind''isDerivedReference-1 bKind)
                                    [a b bKind]
                                    (let [
                                        #_"AllocatableValue" allocatable (LIRGenerator''asAllocatable-2 this, b)
                                    ]
                                        [a allocatable (LIRKind''makeDerivedReference-2 bKind, allocatable)]
                                    )
                                )
                            (LIRKind''isValue-1 bKind)
                                (if (LIRKind''isDerivedReference-1 aKind)
                                    [a b aKind]
                                    (let [
                                        #_"AllocatableValue" allocatable (LIRGenerator''asAllocatable-2 this, a)
                                    ]
                                        [allocatable b (LIRKind''makeDerivedReference-2 aKind, allocatable)]
                                    )
                                )
                            :else
                                [a b (LIRKind''makeUnknownReference-1 aKind)]
                        )
                    )
                    [a b (LIRKind'combine-1* a, b)]
                )
        ]
            (if isAdd
                (LIRGenerator''emitAdd-5 this, resultKind, a, b, set-flags?)
                (LIRGenerator''emitSub-5 this, resultKind, a, b, set-flags?)
            )
        )
    )

    (defn #_"Variable" LIRGenerator''emitAdd-4 [#_"LIRGenerator" this, #_"Value" aVal, #_"Value" bVal, #_"boolean" set-flags?]
        (LIRGenerator''emitAddOrSub-5 this, aVal, bVal, set-flags?, true)
    )

    (defn #_"Variable" LIRGenerator''emitSub-4 [#_"LIRGenerator" this, #_"Value" aVal, #_"Value" bVal, #_"boolean" set-flags?]
        (LIRGenerator''emitAddOrSub-5 this, aVal, bVal, set-flags?, false)
    )

    (defn- #_"Variable" LIRGenerator''emitBaseOffsetLea-5 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"Value" base, #_"int" offset, #_"OperandSize" size]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
            #_"AMD64AddressValue" address (AMD64AddressValue'new-3 resultKind, (LIRGenerator''asAllocatable-2 this, base), offset)
        ]
            (LIRGenerator''append-2 this, (LeaOp'new-3 result, address, size))
            result
        )
    )

    (defn #_"Variable" LIRGenerator''emitAdd-5 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD
            (do
                (when (and (LIRValueUtil'isJavaConstant-1 b) (not set-flags?))
                    (let [
                        #_"long" displacement (#_"JavaConstant" .asLong (:constant b))
                    ]
                        (when (and (NumUtil'isInt-1 displacement) (not= displacement 1) (not= displacement -1))
                            (ยง return (LIRGenerator''emitBaseOffsetLea-5 this, resultKind, a, (int displacement), OperandSize'DWORD))
                        )
                    )
                )
                (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'ADD, OperandSize'DWORD, true, a, b, set-flags?)
            )
            AMD64Kind/QWORD
            (do
                (when (and (LIRValueUtil'isJavaConstant-1 b) (not set-flags?))
                    (let [
                        #_"long" displacement (#_"JavaConstant" .asLong (:constant b))
                    ]
                        (when (and (NumUtil'isInt-1 displacement) (not= displacement 1) (not= displacement -1))
                            (ยง return (LIRGenerator''emitBaseOffsetLea-5 this, resultKind, a, (int displacement), OperandSize'QWORD))
                        )
                    )
                )
                (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'ADD, OperandSize'QWORD, true, a, b, set-flags?)
            )
        )
    )

    (defn #_"Variable" LIRGenerator''emitSub-5 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'SUB, OperandSize'DWORD, false, a, b, set-flags?)
            AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'SUB, OperandSize'QWORD, false, a, b, set-flags?)
        )
    )

    (defn- #_"Variable" LIRGenerator''emitIMULConst-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"AllocatableValue" a, #_"ConstantValue" b]
        (let [
            #_"long" value (#_"JavaConstant" .asLong (:constant b))
        ]
            (if (NumUtil'isInt-1 value)
                (let [
                    #_"int" imm (int value)
                    #_"AMD64RMIOp" op (if (NumUtil'isByte-1i imm) AMD64RMIOp'IMUL_SX AMD64RMIOp'IMUL)
                    #_"Variable" ret (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* a, b))
                ]
                    (LIRGenerator''append-2 this, (RMIOp'new-5 op, size, ret, a, imm))
                    ret
                )
                (LIRGenerator''emitBinaryVar-7 this, (LIRKind'combine-1* a, b), AMD64RMOp'IMUL, size, true, a, (LIRGenerator''asAllocatable-2 this, b))
            )
        )
    )

    (defn- #_"Variable" LIRGenerator''emitIMUL-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (cond
            (LIRValueUtil'isJavaConstant-1 b)
                (LIRGenerator''emitIMULConst-4 this, size, (LIRGenerator''asAllocatable-2 this, a), b)
            (LIRValueUtil'isJavaConstant-1 a)
                (LIRGenerator''emitIMULConst-4 this, size, (LIRGenerator''asAllocatable-2 this, b), a)
            :else
                (LIRGenerator''emitBinaryVar-7 this, (LIRKind'combine-1* a, b), AMD64RMOp'IMUL, size, true, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b))
        )
    )

    (defn #_"Variable" LIRGenerator''emitMul-4 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitIMUL-4 this, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitIMUL-4 this, OperandSize'QWORD, a, b)
        )
    )

    (defn- #_"RegisterValue" LIRGenerator''moveToReg-3 [#_"LIRGenerator" this, #_"Register" reg, #_"Value" value]
        (let [
            #_"RegisterValue" ret (#_"Register" .asValue reg, (#_"Value" .getValueKind value))
        ]
            (LIRGenerator''emitMove-3 this, ret, value)
            ret
        )
    )

    (defn- #_"Value" LIRGenerator''emitMulHigh-5 [#_"LIRGenerator" this, #_"AMD64MOp" opcode, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" mulHigh (LIRGenerator''append-2 this, (AMD64MulDivOp'new-5 opcode, size, (LIRKind'combine-1* a, b), (LIRGenerator''moveToReg-3 this, AMD64/rax, a), (LIRGenerator''asAllocatable-2 this, b)))
        ]
            (LIRGenerator''emitMove-2 this, (:highResult mulHigh))
        )
    )

    (defn #_"Value" LIRGenerator''emitMulHigh-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'IMUL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'IMUL, OperandSize'QWORD, a, b)
        )
    )

    (defn #_"Value" LIRGenerator''emitUMulHigh-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'MUL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'MUL, OperandSize'QWORD, a, b)
        )
    )

    #_unused
    (defn #_"Value" LIRGenerator''emitBinaryMemory-5 [#_"LIRGenerator" this, #_"AMD64RMOp" op, #_"OperandSize" size, #_"AllocatableValue" a, #_"AMD64AddressValue" location]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* a))
        ]
            (LIRGenerator''append-2 this, (MemoryTwoOp'new-5 op, size, result, a, location))
            result
        )
    )

    #_unused
    (defn #_"Value" LIRGenerator''emitConvertMemoryOp-5 [#_"LIRGenerator" this, #_"PlatformKind" kind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"AMD64AddressValue" address]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'value-1 kind))
        ]
            (LIRGenerator''append-2 this, (MemoryOp'new-4 op, size, result, address))
            result
        )
    )

    #_unused
    (defn #_"Value" LIRGenerator''emitZeroExtendMemory-4 [#_"LIRGenerator" this, #_"AMD64Kind" memoryKind, #_"int" resultBits, #_"AMD64AddressValue" address]
        ;; Issue a zero extending load of the proper bit size and set the result to the proper kind.
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'value-1 (if (<= resultBits 32) AMD64Kind/DWORD AMD64Kind/QWORD)))
        ]
            (condp = memoryKind
                AMD64Kind/BYTE  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVZXB, OperandSize'DWORD, result, address))
                AMD64Kind/WORD  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVZX, OperandSize'DWORD, result, address))
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'DWORD, result, address))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'QWORD, result, address))
            )
            result
        )
    )

    (defn- #_"AMD64MulDivOp" LIRGenerator''emitIDIV-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" kind (LIRKind'combine-1* a, b)
            #_"AMD64SignExtendOp" sx (LIRGenerator''append-2 this, (AMD64SignExtendOp'new-3 size, kind, (LIRGenerator''moveToReg-3 this, AMD64/rax, a)))
        ]
            (LIRGenerator''append-2 this, (AMD64MulDivOp'new-6 AMD64MOp'IDIV, size, kind, (:highResult sx), (:lowResult sx), (LIRGenerator''asAllocatable-2 this, b)))
        )
    )

    (defn- #_"AMD64MulDivOp" LIRGenerator''emitDIV-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" kind (LIRKind'combine-1* a, b)
            #_"RegisterValue" rax (LIRGenerator''moveToReg-3 this, AMD64/rax, a)
            #_"RegisterValue" rdx (#_"Register" .asValue AMD64/rdx, kind)
        ]
            (LIRGenerator''append-2 this, (AMD64ClearRegisterOp'new-2 size, rdx))
            (LIRGenerator''append-2 this, (AMD64MulDivOp'new-6 AMD64MOp'DIV, size, kind, rdx, rax, (LIRGenerator''asAllocatable-2 this, b)))
        )
    )

    (defn #_"Value[]" LIRGenerator''emitSignedDivRem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitIDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitIDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (into-array Value [ (LIRGenerator''emitMove-2 this, (:lowResult op)), (LIRGenerator''emitMove-2 this, (:highResult op)) ])
        )
    )

    (defn #_"Value[]" LIRGenerator''emitUnsignedDivRem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (into-array Value [ (LIRGenerator''emitMove-2 this, (:lowResult op)), (LIRGenerator''emitMove-2 this, (:highResult op)) ])
        )
    )

    (defn #_"Value" LIRGenerator''emitDiv-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMove-2 this, (:lowResult (LIRGenerator''emitIDIV-4 this, OperandSize'DWORD, a, b)))
            AMD64Kind/QWORD (LIRGenerator''emitMove-2 this, (:lowResult (LIRGenerator''emitIDIV-4 this, OperandSize'QWORD, a, b)))
        )
    )

    (defn #_"Value" LIRGenerator''emitRem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMove-2 this, (:highResult (LIRGenerator''emitIDIV-4 this, OperandSize'DWORD, a, b)))
            AMD64Kind/QWORD (LIRGenerator''emitMove-2 this, (:highResult (LIRGenerator''emitIDIV-4 this, OperandSize'QWORD, a, b)))
        )
    )

    (defn #_"Variable" LIRGenerator''emitUDiv-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (LIRGenerator''emitMove-2 this, (:lowResult op))
        )
    )

    (defn #_"Variable" LIRGenerator''emitURem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (LIRGenerator''emitMove-2 this, (:highResult op))
        )
    )

    (defn #_"Variable" LIRGenerator''emitAnd-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" resultKind (LIRKind'combine-1* a, b)
        ]
            (condp = (#_"Value" .getPlatformKind a)
                AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'AND, OperandSize'DWORD, true, a, b, false)
                AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'AND, OperandSize'QWORD, true, a, b, false)
            )
        )
    )

    (defn #_"Variable" LIRGenerator''emitOr-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" resultKind (LIRKind'combine-1* a, b)
        ]
            (condp = (#_"Value" .getPlatformKind a)
                AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'OR, OperandSize'DWORD, true, a, b, false)
                AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'OR, OperandSize'QWORD, true, a, b, false)
            )
        )
    )

    (defn #_"Variable" LIRGenerator''emitXor-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" resultKind (LIRKind'combine-1* a, b)
        ]
            (condp = (#_"Value" .getPlatformKind a)
                AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'XOR, OperandSize'DWORD, true, a, b, false)
                AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'XOR, OperandSize'QWORD, true, a, b, false)
            )
        )
    )

    (defn- #_"Variable" LIRGenerator''emitShift-5 [#_"LIRGenerator" this, #_"AMD64Shift" op, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"ValueKind" .changeType (LIRKind'combine-1* a, b), (#_"Value" .getPlatformKind a)))
            #_"AllocatableValue" input (LIRGenerator''asAllocatable-2 this, a)
        ]
            (if (LIRValueUtil'isJavaConstant-1 b)
                (let [
                    #_"JavaConstant" c (:constant b)
                ]
                    (if (= (#_"JavaConstant" .asLong c) 1)
                        (LIRGenerator''append-2 this, (MOp'new-4 (:m1Op op), size, result, input))
                        ;; c is implicitly masked to 5 or 6 bits by the CPU, so casting it to (int)
                        ;; is always correct, even without the NumUtil.is32bit() test.
                        (LIRGenerator''append-2 this, (ConstOp'new-5a (:miOp op), size, result, input, (int (#_"JavaConstant" .asLong c))))
                    )
                )
                (do
                    (LIRGenerator''emitMove-3 this, LIRGenerator'RCX_I, b)
                    (LIRGenerator''append-2 this, (AMD64ShiftOp'new-5 (:mcOp op), size, result, input, LIRGenerator'RCX_I))
                )
            )
            result
        )
    )

    (defn #_"Variable" LIRGenerator''emitShl-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHL, OperandSize'QWORD, a, b)
        )
    )

    (defn #_"Variable" LIRGenerator''emitShr-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SAR, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SAR, OperandSize'QWORD, a, b)
        )
    )

    (defn #_"Variable" LIRGenerator''emitUShr-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHR, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHR, OperandSize'QWORD, a, b)
        )
    )

    #_unused
    (defn #_"Variable" LIRGenerator''emitRol-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROL, OperandSize'QWORD, a, b)
        )
    )

    #_unused
    (defn #_"Variable" LIRGenerator''emitRor-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROR, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROR, OperandSize'QWORD, a, b)
        )
    )

    (defn- #_"AllocatableValue" LIRGenerator''emitConvertOp-5rm [#_"LIRGenerator" this, #_"LIRKind" kind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''append-2 this, (RMOp'new-4 op, size, result, (LIRGenerator''asAllocatable-2 this, input)))
            result
        )
    )

    #_unused
    (defn- #_"AllocatableValue" LIRGenerator''emitConvertOp-5mr [#_"LIRGenerator" this, #_"LIRKind" kind, #_"AMD64MROp" op, #_"OperandSize" size, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''append-2 this, (MROp'new-4 op, size, result, (LIRGenerator''asAllocatable-2 this, input)))
            result
        )
    )

    (defn #_"Value" LIRGenerator''emitNarrow-3 [#_"LIRGenerator" this, #_"Value" input, #_"int" bits]
        (when (and (= (#_"Value" .getPlatformKind input) AMD64Kind/QWORD) (<= bits 32)) => input
            ;; TODO make it possible to reinterpret Long as Int in LIR without move
            (LIRGenerator''emitConvertOp-5rm this, (#_"ValueKind" .changeType (LIRKind'combine-1* input), AMD64Kind/DWORD), AMD64RMOp'MOV, OperandSize'DWORD, input)
        )
    )

    (defn #_"Value" LIRGenerator''emitSignExtend-4 [#_"LIRGenerator" this, #_"Value" input, #_"int" fromBits, #_"int" toBits]
        (cond
            (= fromBits toBits)
                input
            (< 32 toBits)
                ;; sign extend to 64 bits
                (case fromBits
                     8 (LIRGenerator''emitConvertOp-5rm this, (#_"ValueKind" .changeType AMD64Kind/QWORD (LIRKind'combine-1* input)), AMD64RMOp'MOVSXB, OperandSize'QWORD, input)
                    16 (LIRGenerator''emitConvertOp-5rm this, (#_"ValueKind" .changeType AMD64Kind/QWORD (LIRKind'combine-1* input)), AMD64RMOp'MOVSX, OperandSize'QWORD, input)
                    32 (LIRGenerator''emitConvertOp-5rm this, (#_"ValueKind" .changeType AMD64Kind/QWORD (LIRKind'combine-1* input)), AMD64RMOp'MOVSXD, OperandSize'QWORD, input)
                )
            :else
                ;; sign extend to 32 bits (smaller values are internally represented as 32 bit values)
                (case fromBits
                     8 (LIRGenerator''emitConvertOp-5rm this, (#_"ValueKind" .changeType AMD64Kind/DWORD (LIRKind'combine-1* input)), AMD64RMOp'MOVSXB, OperandSize'DWORD, input)
                    16 (LIRGenerator''emitConvertOp-5rm this, (#_"ValueKind" .changeType AMD64Kind/DWORD (LIRKind'combine-1* input)), AMD64RMOp'MOVSX, OperandSize'DWORD, input)
                    32 input
                )
        )
    )

    (defn #_"Value" LIRGenerator''emitZeroExtend-4 [#_"LIRGenerator" this, #_"Value" input, #_"int" fromBits, #_"int" toBits]
        (cond
            (= fromBits toBits)
                input
            (< 32 fromBits)
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
                    #_"long" mask (CodeUtil/mask fromBits)
                ]
                    (LIRGenerator''append-2 this, (DataTwoOp'new-5 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'AND, OperandSize'QWORD), OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, input), (JavaConstant/forLong mask)))
                    result
                )
            :else
                (let [
                    #_"LIRKind" resultKind (#_"ValueKind" .changeType (LIRKind'combine-1* input), (if (< 32 toBits) AMD64Kind/QWORD AMD64Kind/DWORD))
                ]
                    ;; Always emit DWORD operations, even if the resultKind is Long. On AMD64, all DWORD operations
                    ;; implicitly set the upper half of the register to 0, which is what we want anyway. Compared to
                    ;; the QWORD operations, the encoding of the DWORD operations is sometimes one byte shorter.
                    (case fromBits
                         8 (LIRGenerator''emitConvertOp-5rm this, resultKind, AMD64RMOp'MOVZXB, OperandSize'DWORD, input)
                        16 (LIRGenerator''emitConvertOp-5rm this, resultKind, AMD64RMOp'MOVZX, OperandSize'DWORD, input)
                        32 (LIRGenerator''emitConvertOp-5rm this, resultKind, AMD64RMOp'MOV, OperandSize'DWORD, input)
                        ;; odd bit count, fall back on manual masking
                        (let [
                            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
                            #_"JavaConstant" mask (if (< 32 toBits) (JavaConstant/forLong (CodeUtil/mask fromBits)) (JavaConstant/forInt (int (CodeUtil/mask fromBits))))
                        ]
                            (LIRGenerator''append-2 this, (DataTwoOp'new-5 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'AND, OperandSize'DWORD), OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, input), mask))
                            result
                        )
                    )
                )
        )
    )

    (defn #_"Variable" LIRGenerator''emitBitCount-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"ValueKind" .changeType (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'POPCNT, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'POPCNT, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    #_unused
    (defn #_"Variable" LIRGenerator''emitBitScanForward-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"ValueKind" .changeType (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'BSF, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            result
        )
    )

    #_unused
    (defn #_"Variable" LIRGenerator''emitBitScanReverse-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"ValueKind" .changeType (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'BSR, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'BSR, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (defn #_"Value" LIRGenerator''emitCountLeadingZeros-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"ValueKind" .changeType (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'LZCNT, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'LZCNT, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (defn #_"Value" LIRGenerator''emitCountTrailingZeros-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"ValueKind" .changeType (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'TZCNT, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'TZCNT, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (defn #_"Variable" LIRGenerator''emitLoad-3 [#_"LIRGenerator" this, #_"LIRKind" kind, #_"Value" address]
        (let [
            #_"AMD64AddressValue" loadAddress (LIRGenerator''asAddressValue-2 this, address)
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRGenerator'toRegisterKind-1 kind))
        ]
            (condp = (#_"ValueKind" .getPlatformKind kind)
                AMD64Kind/BYTE  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVSXB, OperandSize'DWORD, result, loadAddress))
                AMD64Kind/WORD  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVSX, OperandSize'DWORD, result, loadAddress))
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'DWORD, result, loadAddress))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'QWORD, result, loadAddress))
            )
            result
        )
    )

    (defn #_"void" LIRGenerator''emitStoreConst-4 [#_"LIRGenerator" this, #_"AMD64Kind" kind, #_"AMD64AddressValue" address, #_"ConstantValue" value]
        (let [
            #_"Constant" c (:constant value)
        ]
            (cond
                (JavaConstant/isNull c)
                    (let [
                        #_"OperandSize" size (if (= kind AMD64Kind/DWORD) OperandSize'DWORD OperandSize'QWORD)
                    ]
                        (LIRGenerator''append-2 this, (MemoryConstOp'new-4a AMD64MIOp'MOV, size, address, 0))
                        (ยง return )
                    )
                (instance? VMConstant c)
                    ;; only 32-bit constants can be patched
                    (when (and (= kind AMD64Kind/DWORD) (or (.inlineObjects HotSpot'target) (not (instance? JavaConstant c))))
                        ;; if c is a JavaConstant, it's an oop, otherwise it's a metaspace constant
                        (LIRGenerator''append-2 this, (MemoryVMConstOp'new-3 AMD64MIOp'MOV, address, c))
                        (ยง return )
                    )
                :else
                    (let [
                        [#_"AMD64MIOp" op #_"OperandSize" size #_"long" imm]
                            (condp = kind
                                AMD64Kind/BYTE  [AMD64MIOp'MOVB OperandSize'BYTE  (#_"JavaConstant" .asInt  c)]
                                AMD64Kind/WORD  [AMD64MIOp'MOV  OperandSize'WORD  (#_"JavaConstant" .asInt  c)]
                                AMD64Kind/DWORD [AMD64MIOp'MOV  OperandSize'DWORD (#_"JavaConstant" .asInt  c)]
                                AMD64Kind/QWORD [AMD64MIOp'MOV  OperandSize'QWORD (#_"JavaConstant" .asLong c)]
                            )
                    ]
                        (when (NumUtil'isInt-1 imm)
                            (LIRGenerator''append-2 this, (MemoryConstOp'new-4a op, size, address, (int imm)))
                            (ยง return )
                        )
                    )
            )

            ;; fallback: load, then store
            (LIRGenerator''emitStore-4a this, kind, address, (LIRGenerator''asAllocatable-2 this, value))
        )
        nil
    )

    (defn #_"void" LIRGenerator''emitStore-4a [#_"LIRGenerator" this, #_"AMD64Kind" kind, #_"AMD64AddressValue" address, #_"AllocatableValue" value]
        (condp = kind
            AMD64Kind/BYTE  (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOVB, OperandSize'BYTE, address, value))
            AMD64Kind/WORD  (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOV, OperandSize'WORD, address, value))
            AMD64Kind/DWORD (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOV, OperandSize'DWORD, address, value))
            AMD64Kind/QWORD (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOV, OperandSize'QWORD, address, value))
        )
        nil
    )

    (defn #_"void" LIRGenerator''emitStore-4v [#_"LIRGenerator" this, #_"ValueKind" lirKind, #_"Value" address, #_"Value" input]
        (let [
            #_"AMD64AddressValue" storeAddress (LIRGenerator''asAddressValue-2 this, address)
            #_"AMD64Kind" kind (#_"ValueKind" .getPlatformKind lirKind)
        ]
            (if (satisfies? ConstantValue input)
                (LIRGenerator''emitStoreConst-4 this, kind, storeAddress, input)
                (LIRGenerator''emitStore-4a this, kind, storeAddress, (LIRGenerator''asAllocatable-2 this, input))
            )
        )
        nil
    )

    (defn #_"void" LIRGenerator''emitCompareOp-4 [#_"LIRGenerator" this, #_"AMD64Kind" cmpKind, #_"Variable" left, #_"Value" right]
        (let [
            #_"OperandSize" size
                (condp = cmpKind
                    AMD64Kind/BYTE  OperandSize'BYTE
                    AMD64Kind/WORD  OperandSize'WORD
                    AMD64Kind/DWORD OperandSize'DWORD
                    AMD64Kind/QWORD OperandSize'QWORD
                )
        ]
            (or
                (when (satisfies? ConstantValue right)
                    (let [
                        #_"Constant" c (:constant right)
                    ]
                        (cond
                            (JavaConstant/isNull c)
                                (do
                                    (LIRGenerator''append-2 this, (ConsumerOp'new-4 AMD64RMOp'TEST, size, left, left))
                                    :done
                                )
                            (instance? VMConstant c)
                                (do
                                    (if (= size OperandSize'DWORD)
                                        (LIRGenerator''append-2 this, (VMConstOp'new-3 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'DWORD, false), left, c))
                                        (LIRGenerator''append-2 this, (DataOp'new-4 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'CMP, size), size, left, c))
                                    )
                                    :done
                                )
                            (instance? JavaConstant c)
                                (cond
                                    (#_"JavaConstant" .isDefaultForKind c)
                                        (do
                                            (LIRGenerator''append-2 this, (ConsumerOp'new-4 (if (= size OperandSize'BYTE) AMD64RMOp'TESTB AMD64RMOp'TEST), size, left, left))
                                            :done
                                        )
                                    (NumUtil'is32bit-1 (#_"JavaConstant" .asLong c))
                                        (do
                                            (LIRGenerator''append-2 this, (ConsumerConstOp'new-4b BinaryArithmetic'CMP, size, left, (int (#_"JavaConstant" .asLong c))))
                                            :done
                                        )
                                )
                        )
                    )
                )
                ;; fallback: load, then compare
                (LIRGenerator''append-2 this, (ConsumerOp'new-4 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'CMP, size), size, left, (LIRGenerator''asAllocatable-2 this, right)))
            )
        )
        nil
    )
)

;;;
 ; A buffer to enqueue updates to a list. This avoids frequent re-sizing of the list and copying of
 ; list elements when insertions are done at multiple positions of the list. Additionally, it
 ; ensures that the list is not modified while it is, e.g. iterated, and instead only modified once
 ; after the iteration is done.
 ;
 ; The buffer uses internal data structures to store the enqueued updates. To avoid allocations, a
 ; buffer can be re-used. Call the methods in the following order: #init, #append,
 ; #append, ..., #finish(), #init, ...
 ;
 ; Note: This class does not depend on LIRInstruction, so we could make it a generic utility class.
 ;;
(class-ns LIRInsertionBuffer []
    (defn #_"LIRInsertionBuffer" LIRInsertionBuffer'new-0 []
        (merge (LIRInsertionBuffer'class.)
            (hash-map
                ;;;
                 ; The lir list where ops of this buffer should be inserted later (nil when uninitialized).
                 ;;
                #_"List<LIRInstruction>" :lir nil
                ;;;
                 ; List of insertion points. index and count are stored alternately: indexAndCount[i * 2]: the
                 ; index into lir list where "count" ops should be inserted indexAndCount[i * 2 + 1]: the number
                 ; of ops to be inserted at index
                 ;;
                #_"int[]" :indexAndCount (int-array 8)
                #_"int" :indexAndCountSize 0
                ;;;
                 ; The LIROps to be inserted.
                 ;;
                #_"List<LIRInstruction>" :ops (ArrayList.)
            )
        )
    )

    ;;;
     ; Initialize this buffer. This method must be called before using #append.
     ;;
    (defn #_"LIRInsertionBuffer" LIRInsertionBuffer''init-2 [#_"LIRInsertionBuffer" this, #_"List<LIRInstruction>" lir]
        (assoc this :lir lir)
    )

    (defn #_"boolean" LIRInsertionBuffer''initialized-1 [#_"LIRInsertionBuffer" this]
        (some? (:lir this))
    )

    (defn- #_"int" LIRInsertionBuffer''numberOfInsertionPoints-1 [#_"LIRInsertionBuffer" this]
        (>> (:indexAndCountSize this) 1)
    )

    (defn- #_"int" LIRInsertionBuffer''indexAt-2 [#_"LIRInsertionBuffer" this, #_"int" i]
        (nth (:indexAndCount this) (<< i 1))
    )

    (defn- #_"this" LIRInsertionBuffer''appendNew-3 [#_"LIRInsertionBuffer" this, #_"int" index, #_"int" count]
        (let [
            #_"int" oldSize (:indexAndCountSize this)
            #_"int" newSize (+ oldSize 2)
            this
                (when (< (count (:indexAndCount this)) newSize) => this
                    (assoc this :indexAndCount (Arrays/copyOf (:indexAndCount this), (* newSize 2)))
                )
        ]
            (aset (:indexAndCount this) oldSize index)
            (aset (:indexAndCount this) (inc oldSize) count)
            (assoc this :indexAndCountSize newSize)
        )
    )

    (defn- #_"void" LIRInsertionBuffer''setCountAt-3 [#_"LIRInsertionBuffer" this, #_"int" i, #_"int" value]
        (aset (:indexAndCount this) (inc (<< i 1)) value)
        nil
    )

    (defn- #_"int" LIRInsertionBuffer''countAt-2 [#_"LIRInsertionBuffer" this, #_"int" i]
        (nth (:indexAndCount this) (inc (<< i 1)))
    )

    ;;;
     ; Enqueue a new instruction that will be appended to the instruction list when #finish() is called.
     ; The new instruction is added <b>before</b> the existing instruction with the given index.
     ; This method can only be called with increasing values of index, e.g. once an instruction was
     ; appended with index 4, subsequent instructions can only be appended with index 4 or higher.
     ;;
    (defn #_"this" LIRInsertionBuffer''append-3 [#_"LIRInsertionBuffer" this, #_"int" index, #_"LIRInstruction" op]
        (let [
            #_"int" i (dec (LIRInsertionBuffer''numberOfInsertionPoints-1 this))
            this
                (if (or (neg? i) (< (LIRInsertionBuffer''indexAt-2 this, i) index))
                    (LIRInsertionBuffer''appendNew-3 this, index, 1)
                    (do
                        (LIRInsertionBuffer''setCountAt-3 this, i, (inc (LIRInsertionBuffer''countAt-2 this, i)))
                        this
                    )
                )
        ]
            (#_"List" .add (:ops this), op)
            this
        )
    )

    ;;;
     ; Append all enqueued instructions to the instruction list. After that, #init(List) can
     ; be called again to re-use this buffer.
     ;;
    (defn #_"LIRInsertionBuffer" LIRInsertionBuffer''finish-1 [#_"LIRInsertionBuffer" this]
        (when (seq (:ops this)) => (assoc this :lir nil)
            (let [
                #_"int" n (count (:lir this))
            ]
                ;; increase size of instructions list
                (dotimes [#_"int" i (count (:ops this))]
                    (#_"List" .add (:lir this), nil)
                )
                ;; insert ops from buffer into instructions list
                (loop-when [#_"int" op (dec (count (:ops this))) #_"int" from (dec n) #_"int" to (dec (count (:lir this))) #_"int" ip (dec (LIRInsertionBuffer''numberOfInsertionPoints-1 this))] (<= 0 ip)
                    (let [
                        #_"int" index (LIRInsertionBuffer''indexAt-2 this, ip)
                        ;; make room after insertion point
                        [to from]
                            (loop-when [to to from from] (<= index from) => [to from]
                                (#_"List" .set (:lir this), to, (nth (:lir this) from))
                                (recur (dec to) (dec from))
                            )
                        ;; insert ops from buffer
                        [to op]
                            (loop-when [to to op op #_"int" i (LIRInsertionBuffer''countAt-2 this, ip)] (pos? i) => [to op]
                                (#_"List" .set (:lir this), to, (nth (:ops this) op))
                                (recur (dec to) (dec op) (dec i))
                            )
                    ]
                        (recur op from to (dec ip))
                    )
                )
                (let [
                    this (assoc this :indexAndCountSize 0)
                ]
                    (#_"List" .clear (:ops this))
                    (assoc this :lir nil)
                )
            )
        )
    )
)

(class-ns LIRInstruction []
    ;;;
     ; Constructs a new LIR instruction.
     ;;
    (defn #_"LIRInstruction" LIRInstruction'new-0 []
        (merge (LIRInstruction'class.)
            (hash-map
                #_"LIRInstructionClass" :opClass nil
                ;;;
                 ; Instruction id for register allocation.
                 ;;
                #_"int" :id -1
            )
        )
    )

    (defn #_"LIRInstruction" LIRInstruction''setId-2 [#_"LIRInstruction" this, #_"int" id]
        (assoc this :id id)
    )

    (defn #_"boolean" LIRInstruction''hasOperands-1 [#_"LIRInstruction" this]
        (or (LIRInstructionClass''hasOperands-1 (:opClass this)) (LIRInstruction'''destroysCallerSavedRegisters-1 this))
    )

    (defm LIRInstruction LIRInstruction
        (#_"boolean" LIRInstruction'''destroysCallerSavedRegisters-1 [#_"LIRInstruction" this]
            false
        )
    )

    (defn #_"void" LIRInstruction''forEachInput-2  [#_"LIRInstruction" this, #_"ValueProcedure" proc] (LIRInstructionClass''forEachUse-3 (:opClass this), this, proc) nil)
    (defn #_"void" LIRInstruction''forEachAlive-2  [#_"LIRInstruction" this, #_"ValueProcedure" proc] (LIRInstructionClass''forEachAlive-3 (:opClass this), this, proc) nil)
    (defn #_"void" LIRInstruction''forEachTemp-2   [#_"LIRInstruction" this, #_"ValueProcedure" proc] (LIRInstructionClass''forEachTemp-3 (:opClass this), this, proc) nil)
    (defn #_"void" LIRInstruction''forEachOutput-2 [#_"LIRInstruction" this, #_"ValueProcedure" proc] (LIRInstructionClass''forEachDef-3 (:opClass this), this, proc) nil)

    (defn #_"void" LIRInstruction''visitEachInput-2  [#_"LIRInstruction" this, #_"ValueConsumer" proc] (LIRInstructionClass''visitEachUse-3 (:opClass this), this, proc) nil)
    (defn #_"void" LIRInstruction''visitEachAlive-2  [#_"LIRInstruction" this, #_"ValueConsumer" proc] (LIRInstructionClass''visitEachAlive-3 (:opClass this), this, proc) nil)
    (defn #_"void" LIRInstruction''visitEachTemp-2   [#_"LIRInstruction" this, #_"ValueConsumer" proc] (LIRInstructionClass''visitEachTemp-3 (:opClass this), this, proc) nil)
    (defn #_"void" LIRInstruction''visitEachOutput-2 [#_"LIRInstruction" this, #_"ValueConsumer" proc] (LIRInstructionClass''visitEachDef-3 (:opClass this), this, proc) nil)

    (defn #_"Value" LIRInstruction''forEachRegisterHint-4 [#_"LIRInstruction" this, #_"Value" value, #_"OperandMode" mode, #_"ValueProcedure" proc]
        (LIRInstructionClass''forEachRegisterHint-4 (:opClass this), this, mode, proc)
    )

    ;;;
     ; Utility method to add stack arguments to a list of temporaries. Useful for modeling calling
     ; conventions that kill outgoing argument space.
     ;
     ; @return additional temporaries
     ;;
    (defn #_"Value[]" LIRInstruction'addStackSlotsToTemporaries-2 [#_"Value*" parameters, #_"Value[]" temporaries]
        (let [
            #_"int" n (count (filter #(instance? StackSlot %) parameters))
        ]
            (when (pos? n) => temporaries
                (let [
                    #_"Value[]" t (Arrays/copyOf temporaries, (+ (count temporaries) n))
                ]
                    (loop-when [#_"int" i (count temporaries) #_"ISeq" s (seq parameters)] (some? s)
                        (let [
                            #_"Value" p (first s)
                            i
                                (when (instance? StackSlot p) => i
                                    (aset t i p)
                                    (inc i)
                                )
                        ]
                            (recur i (next s))
                        )
                    )
                    t
                )
            )
        )
    )
)

(class-ns AMD64ByteSwapOp [LIRInstruction]
    (defn #_"AMD64ByteSwapOp" AMD64ByteSwapOp'new-2 [#_"Value" result, #_"Value" input]
        (merge (AMD64ByteSwapOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"Value" :result result
                ; @OperandMode'USE
                #_"Value" :input input
            )
        )
    )

    (defm AMD64ByteSwapOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64ByteSwapOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:input this))
            (condp = (#_"Value" .getPlatformKind (:input this))
                AMD64Kind/DWORD (Assembler''bswapl-2 asm, (#_"RegisterValue" .getRegister (:result this)))
                AMD64Kind/QWORD (Assembler''bswapq-2 asm, (#_"RegisterValue" .getRegister (:result this)))
            )
            nil
        )
    )
)

(class-ns AMD64CCall [LIRInstruction]
    (defn #_"AMD64CCall" AMD64CCall'new-3 [#_"Value" result, #_"Value" functionPtr, #_"Value[]" parameters]
        (merge (AMD64CCall'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"Value" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"Value[]" :parameters parameters
                ; @OperandMode'USE({OperandFlag'REG})
                #_"Value" :functionPtr functionPtr
            )
        )
    )

    (defm AMD64CCall LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64CCall" this, #_"Assembler" asm]
            (let [
                #_"Register" reg (#_"RegisterValue" .getRegister (:functionPtr this))
            ]
                (Assembler''call-2 asm, reg)
                (Assembler''ensureUniquePC-1 asm)
            )
            nil
        )

        (#_"boolean" LIRInstruction'''destroysCallerSavedRegisters-1 [#_"AMD64CCall" this]
            true
        )
    )
)

(class-ns AMD64ClearRegisterOp [LIRInstruction]
    (defn #_"AMD64ClearRegisterOp" AMD64ClearRegisterOp'new-2 [#_"OperandSize" size, #_"AllocatableValue" result]
        (merge (AMD64ClearRegisterOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :op (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'XOR, size)
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
            )
        )
    )

    (defm AMD64ClearRegisterOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64ClearRegisterOp" this, #_"Assembler" asm]
            (AMD64RROp'''emit-5 (:op this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister (:result this)))
            nil
        )
    )
)

(class-ns AMD64DeoptimizeOp [LIRInstruction, BlockEndOp]
    (defn #_"AMD64DeoptimizeOp" AMD64DeoptimizeOp'new-0 []
        (merge (AMD64DeoptimizeOp'class.) (LIRInstruction'new-0))
    )

    (defm AMD64DeoptimizeOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64DeoptimizeOp" this, #_"Assembler" asm]
            (AMD64Call'directCall-4 asm, (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER), nil, false)
            nil
        )
    )
)

(class-ns AMD64LFenceOp [LIRInstruction]
    (defn #_"AMD64LFenceOp" AMD64LFenceOp'new-0 []
        (merge (AMD64LFenceOp'class.) (LIRInstruction'new-0))
    )

    (defm AMD64LFenceOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64LFenceOp" this, #_"Assembler" asm]
            (Assembler''lfence-1 asm)
            nil
        )
    )
)

;;;
 ; AMD64 mul/div operation. This operation has a single operand for the second input. The first
 ; input must be in RAX for mul and in RDX:RAX for div. The result is in RDX:RAX.
 ;;
(class-ns AMD64MulDivOp [LIRInstruction]
    (defn #_"AMD64MulDivOp" AMD64MulDivOp'new-5 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"LIRKind" resultKind, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (AMD64MulDivOp'new-6 opcode, size, resultKind, Value/ILLEGAL, x, y)
    )

    (defn #_"AMD64MulDivOp" AMD64MulDivOp'new-6 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"LIRKind" resultKind, #_"AllocatableValue" highX, #_"AllocatableValue" lowX, #_"AllocatableValue" y]
        (merge (AMD64MulDivOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :highResult (#_"Register" .asValue AMD64/rdx, resultKind)
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :lowResult (#_"Register" .asValue AMD64/rax, resultKind)
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"AllocatableValue" :highX highX
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :lowX lowX
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :y y
            )
        )
    )

    (defm AMD64MulDivOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64MulDivOp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:y this))
                (AMD64MOp''emit-4r (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:y this)))
                (AMD64MOp''emit-4a (:opcode this), asm, (:size this), (Assembler''asAddress-2 asm, (:y this)))
            )
            nil
        )
    )
)

(class-ns AMD64MultiStackMove [LIRInstruction]
    (defn #_"AMD64MultiStackMove" AMD64MultiStackMove'new-4 [#_"AllocatableValue*" results, #_"Value*" inputs, #_"Register" scratch, #_"AllocatableValue" backupSlot]
        (merge (AMD64MultiStackMove'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'STACK})
                #_"AllocatableValue*" :results results
                ; @OperandMode'USE({OperandFlag'STACK})
                #_"Value*" :inputs inputs
                ; @OperandMode'ALIVE({OperandFlag'STACK, OperandFlag'UNINITIALIZED})
                #_"AllocatableValue" :backupSlot backupSlot
                #_"Register" :scratch scratch
            )
        )
    )

    (defm AMD64MultiStackMove LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64MultiStackMove" this, #_"Assembler" asm]
            (let [
                #_"AMD64Kind" backupKind (#_"Value" .getPlatformKind (:backupSlot this))
            ]
                ;; backup scratch register
                (AMD64Move'move-4 backupKind, asm, (:backupSlot this), (#_"Register" .asValue (:scratch this), (#_"Value" .getValueKind (:backupSlot this))))
                (dotimes [#_"int" i (count (:results this))]
                    (let [
                        #_"Value" input (nth (:inputs this) i)
                        #_"AllocatableValue" result (nth (:results this) i)
                    ]
                        ;; move stack slot
                        (AMD64Move'move-4 (#_"Value" .getPlatformKind input), asm, (#_"Register" .asValue (:scratch this), (#_"Value" .getValueKind input)), input)
                        (AMD64Move'move-4 (#_"Value" .getPlatformKind result), asm, result, (#_"Register" .asValue (:scratch this), (#_"Value" .getValueKind result)))
                    )
                )
                ;; restore scratch register
                (AMD64Move'move-4 backupKind, asm, (#_"Register" .asValue (:scratch this), (#_"Value" .getValueKind (:backupSlot this))), (:backupSlot this))
            )
            nil
        )
    )
)

(class-ns AMD64PrefetchOp [LIRInstruction]
    (defn #_"AMD64PrefetchOp" AMD64PrefetchOp'new-2 [#_"AMD64AddressValue" address, #_"int" instr]
        (merge (AMD64PrefetchOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"int" :instr instr ;; AllocatePrefetchInstr
                ; @OperandMode'ALIVE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :address address
            )
        )
    )

    (defm AMD64PrefetchOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64PrefetchOp" this, #_"Assembler" asm]
            (case (:instr this)
                0 (Assembler''prefetchnta-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
                1 (Assembler''prefetcht0-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
                2 (Assembler''prefetcht2-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
                3 (Assembler''prefetchw-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
            )
            nil
        )
    )
)

(class-ns AMD64PushPopStackMove [LIRInstruction, ValueMoveOp, MoveOp]
    (defn #_"AMD64PushPopStackMove" AMD64PushPopStackMove'new-3 [#_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (merge (AMD64PushPopStackMove'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'STACK})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'STACK, OperandFlag'HINT})
                #_"AllocatableValue" :input input
                #_"OperandSize" :size size
            )
        )
    )

    (defm AMD64PushPopStackMove ValueMoveOp
        (#_"AllocatableValue" ValueMoveOp'''getInput-1 [#_"AMD64PushPopStackMove" this]
            (:input this)
        )
    )

    (defm AMD64PushPopStackMove MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"AMD64PushPopStackMove" this]
            (:result this)
        )
    )

    (defm AMD64PushPopStackMove LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64PushPopStackMove" this, #_"Assembler" asm]
            (AMD64MOp''emit-4a AMD64MOp'PUSH, asm, (:size this), (Assembler''asAddress-2 asm, (:input this)))
            (AMD64MOp''emit-4a AMD64MOp'POP, asm, (:size this), (Assembler''asAddress-2 asm, (:result this)))
            nil
        )
    )
)

;;;
 ; Restores registers from stack slots.
 ;;
(class-ns AMD64RestoreRegistersOp [LIRInstruction]
    #_unused
    (defn #_"AMD64RestoreRegistersOp" AMD64RestoreRegistersOp'new-2 [#_"AllocatableValue*" saveSlots, #_"AMD64SaveRegistersOp" saveOp]
        (merge (AMD64RestoreRegistersOp'class.) (LIRInstruction'new-0)
            (hash-map
                ;;;
                 ; The slots from which the registers are restored.
                 ;;
                ; @OperandMode'USE(OperandFlag'STACK)
                #_"AllocatableValue*" :saveSlots saveSlots
                ;;;
                 ; The operation that saved the registers restored by this operation.
                 ;;
                #_"AMD64SaveRegistersOp" :saveOp saveOp
            )
        )
    )

    (defn- #_"void" AMD64RestoreRegistersOp'restoreRegister-3 [#_"Assembler" asm, #_"Register" result, #_"StackSlot" input]
        (AMD64Move'stack2reg-4 (#_"StackSlot" .getPlatformKind input), asm, result, input)
        nil
    )

    (defm AMD64RestoreRegistersOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64RestoreRegistersOp" this, #_"Assembler" asm]
            (let [
                #_"Register*" savedRegisters (:savedRegisters (:saveOp this))
            ]
                (dotimes [#_"int" i (count savedRegisters)]
                    (when (some? (nth savedRegisters i))
                        (AMD64RestoreRegistersOp'restoreRegister-3 asm, (nth savedRegisters i), (nth (:saveSlots this) i))
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Saves registers to stack slots.
 ;;
(class-ns AMD64SaveRegistersOp [LIRInstruction]
    ;;;
     ; @param savedRegisters the registers saved by this operation which may be subject to {@linkplain #remove(EconomicSet) pruning}
     ; @param saveSlots the slots to which the registers are saved
     ;;
    #_unused
    (defn #_"AMD64SaveRegistersOp" AMD64SaveRegistersOp'new-2 [#_"Register*" savedRegisters, #_"AllocatableValue*" saveSlots]
        (merge (AMD64SaveRegistersOp'class.) (LIRInstruction'new-0)
            (hash-map
                ;;;
                 ; The registers (potentially) saved by this operation.
                 ;;
                #_"Register*" :savedRegisters savedRegisters
                ;;;
                 ; The slots to which the registers are saved.
                 ;;
                ; @OperandMode'DEF(OperandFlag'STACK)
                #_"AllocatableValue*" :saveSlots saveSlots
            )
        )
    )

    (defn- #_"void" AMD64SaveRegistersOp'saveRegister-3 [#_"Assembler" asm, #_"StackSlot" result, #_"Register" input]
        (AMD64Move'reg2stack-4 (#_"StackSlot" .getPlatformKind result), asm, result, input)
        nil
    )

    (defm AMD64SaveRegistersOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64SaveRegistersOp" this, #_"Assembler" asm]
            (dotimes [#_"int" i (count (:savedRegisters this))]
                (when (some? (nth (:savedRegisters this) i))
                    (AMD64SaveRegistersOp'saveRegister-3 asm, (nth (:saveSlots this) i), (nth (:savedRegisters this) i))
                )
            )
            nil
        )
    )
)

;;;
 ; AMD64 shift/rotate operation. This operation has a single operand for the first input and output.
 ; The second input must be in the RCX register.
 ;;
(class-ns AMD64ShiftOp [LIRInstruction]
    (defn #_"AMD64ShiftOp" AMD64ShiftOp'new-5 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (merge (AMD64ShiftOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :x x
                ; @OperandMode'ALIVE({OperandFlag'REG})
                #_"AllocatableValue" :y y
            )
        )
    )

    (defm AMD64ShiftOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64ShiftOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:x this))
            (AMD64MOp''emit-4r (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)))
            nil
        )
    )
)

(class-ns AMD64SignExtendOp [LIRInstruction]
    (defn #_"AMD64SignExtendOp" AMD64SignExtendOp'new-3 [#_"OperandSize" size, #_"LIRKind" resultKind, #_"AllocatableValue" input]
        (merge (AMD64SignExtendOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :highResult (#_"Register" .asValue AMD64/rdx, resultKind)
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :lowResult (#_"Register" .asValue AMD64/rax, resultKind)
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :input input
            )
        )
    )

    (defm AMD64SignExtendOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64SignExtendOp" this, #_"Assembler" asm]
            (if (= (:size this) OperandSize'DWORD)
                (Assembler''cdql-1 asm)
                (Assembler''cdqq-1 asm)
            )
            nil
        )
    )
)

(class-ns AMD64StackMove [LIRInstruction, ValueMoveOp, MoveOp]
    (defn #_"AMD64StackMove" AMD64StackMove'new-4 [#_"AllocatableValue" result, #_"AllocatableValue" input, #_"Register" scratch, #_"AllocatableValue" backupSlot]
        (merge (AMD64StackMove'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'STACK})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'STACK, OperandFlag'HINT})
                #_"AllocatableValue" :input input
                ; @OperandMode'ALIVE({OperandFlag'STACK, OperandFlag'UNINITIALIZED})
                #_"AllocatableValue" :backupSlot backupSlot
                #_"Register" :scratch scratch
            )
        )
    )

    (defm AMD64StackMove ValueMoveOp
        (#_"AllocatableValue" ValueMoveOp'''getInput-1 [#_"AMD64StackMove" this]
            (:input this)
        )
    )

    (defm AMD64StackMove MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"AMD64StackMove" this]
            (:result this)
        )
    )

    (defm AMD64StackMove LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64StackMove" this, #_"Assembler" asm]
            (let [
                #_"AMD64Kind" backupKind (#_"Value" .getPlatformKind (:backupSlot this))
            ]
                ;; backup scratch register
                (AMD64Move'reg2stack-4 backupKind, asm, (:backupSlot this), (:scratch this))
                ;; move stack slot
                (AMD64Move'stack2reg-4 (#_"Value" .getPlatformKind (ValueMoveOp'''getInput-1 this)), asm, (:scratch this), (ValueMoveOp'''getInput-1 this))
                (AMD64Move'reg2stack-4 (#_"Value" .getPlatformKind (MoveOp'''getResult-1 this)), asm, (MoveOp'''getResult-1 this), (:scratch this))
                ;; restore scratch register
                (AMD64Move'stack2reg-4 backupKind, asm, (:scratch this), (:backupSlot this))
            )
            nil
        )
    )
)

;;;
 ; Performs a hard-coded tail call to the specified target, which normally should be an InstalledCode instance.
 ;;
(class-ns AMD64TailcallOp [LIRInstruction]
    (defn #_"AMD64TailcallOp" AMD64TailcallOp'new-2 [#_"Value[]" parameters, #_"Value" target]
        (merge (AMD64TailcallOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'USE
                #_"Value" :target target
                ; @OperandMode'ALIVE
                #_"Value[]" :parameters parameters
            )
        )
    )

    (defm AMD64TailcallOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64TailcallOp" this, #_"Assembler" asm]
            ;; destroy the current frame (now the return address is the top of stack)
            (Assembler''leave-1 asm)

            ;; jump to the target method
            (Assembler''jmp-2r asm, (#_"RegisterValue" .getRegister (:target this)))
            (Assembler''ensureUniquePC-1 asm)
            nil
        )
    )
)

(class-ns AbstractMoveOp [LIRInstruction, ValueMoveOp, MoveOp]
    (defn #_"AbstractMoveOp" AbstractMoveOp'new-1 [#_"AMD64Kind" moveKind]
        (merge (AbstractMoveOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64Kind" :moveKind moveKind
            )
        )
    )

    (defm AbstractMoveOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AbstractMoveOp" this, #_"Assembler" asm]
            (AMD64Move'move-4 (:moveKind this), asm, (MoveOp'''getResult-1 this), (ValueMoveOp'''getInput-1 this))
            nil
        )
    )
)

(class-ns MoveFromRegOp [AbstractMoveOp, LIRInstruction, ValueMoveOp, MoveOp]
    (defn #_"MoveFromRegOp" MoveFromRegOp'new-3 [#_"AMD64Kind" moveKind, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (merge (MoveFromRegOp'class.) (AbstractMoveOp'new-1 moveKind)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :input input
            )
        )
    )

    (defm MoveFromRegOp ValueMoveOp
        (#_"AllocatableValue" ValueMoveOp'''getInput-1 [#_"MoveFromRegOp" this]
            (:input this)
        )
    )

    (defm MoveFromRegOp MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"MoveFromRegOp" this]
            (:result this)
        )
    )
)

(class-ns MoveToRegOp [AbstractMoveOp, LIRInstruction, ValueMoveOp, MoveOp]
    (defn #_"MoveToRegOp" MoveToRegOp'new-3 [#_"AMD64Kind" moveKind, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (merge (MoveToRegOp'class.) (AbstractMoveOp'new-1 moveKind)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :input input
            )
        )
    )

    (defm MoveToRegOp ValueMoveOp
        (#_"AllocatableValue" ValueMoveOp'''getInput-1 [#_"MoveToRegOp" this]
            (:input this)
        )
    )

    (defm MoveToRegOp MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"MoveToRegOp" this]
            (:result this)
        )
    )
)

(class-ns AtomicReadAndAddOp [LIRInstruction]
    (defn #_"AtomicReadAndAddOp" AtomicReadAndAddOp'new-4 [#_"AMD64Kind" accessKind, #_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"AllocatableValue" delta]
        (merge (AtomicReadAndAddOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64Kind" :accessKind accessKind
                ; @OperandMode'DEF
                #_"AllocatableValue" :result result
                ; @OperandMode'ALIVE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :address address
                ; @OperandMode'USE
                #_"AllocatableValue" :delta delta
            )
        )
    )

    (defm AtomicReadAndAddOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AtomicReadAndAddOp" this, #_"Assembler" asm]
            (AMD64Move'move-4 (:accessKind this), asm, (:result this), (:delta this))
            (when (.isMP HotSpot'target)
                (Assembler''lock-1 asm)
            )
            (condp = (:accessKind this)
                AMD64Kind/DWORD (Assembler''xaddl-3 asm, (AMD64AddressValue''toAddress-1 (:address this)), (#_"RegisterValue" .getRegister (:result this)))
                AMD64Kind/QWORD (Assembler''xaddq-3 asm, (AMD64AddressValue''toAddress-1 (:address this)), (#_"RegisterValue" .getRegister (:result this)))
            )
            nil
        )
    )
)

(class-ns AtomicReadAndWriteOp [LIRInstruction]
    (defn #_"AtomicReadAndWriteOp" AtomicReadAndWriteOp'new-4 [#_"AMD64Kind" accessKind, #_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"AllocatableValue" newValue]
        (merge (AtomicReadAndWriteOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64Kind" :accessKind accessKind
                ; @OperandMode'DEF
                #_"AllocatableValue" :result result
                ; @OperandMode'ALIVE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :address address
                ; @OperandMode'USE
                #_"AllocatableValue" :newValue newValue
            )
        )
    )

    (defm AtomicReadAndWriteOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AtomicReadAndWriteOp" this, #_"Assembler" asm]
            (AMD64Move'move-4 (:accessKind this), asm, (:result this), (:newValue this))
            (condp = (:accessKind this)
                AMD64Kind/DWORD (Assembler''xchgl-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
                AMD64Kind/QWORD (Assembler''xchgq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
            )
            nil
        )
    )
)

(class-ns BindToRegisterOp [LIRInstruction]
    (defn #_"BindToRegisterOp" BindToRegisterOp'new-1 [#_"Value" value]
        (merge (BindToRegisterOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'USE({OperandFlag'REG})
                #_"Value" :value value
            )
        )
    )

    (defm BindToRegisterOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"BindToRegisterOp" this, #_"Assembler" asm]
            ;; do nothing, just keep value alive until at least here
            nil
        )
    )
)

(class-ns BlackholeOp [LIRInstruction]
    (defn #_"BlackholeOp" BlackholeOp'new-1 [#_"Value" value]
        (merge (BlackholeOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST})
                #_"Value" :value value
            )
        )
    )

    (defm BlackholeOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"BlackholeOp" this, #_"Assembler" asm]
            ;; do nothing, just keep value alive until at least here
            nil
        )
    )
)

(class-ns BranchOp [LIRInstruction, StandardBranchOp, BlockEndOp]
    (defn #_"BranchOp" BranchOp'new-4c [#_"Condition" condition, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (BranchOp'new-4f (AMD64ControlFlow'intCond-1 condition), trueDestination, falseDestination, trueDestinationProbability)
    )

    (defn #_"BranchOp" BranchOp'new-4f [#_"ConditionFlag" condition, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (BranchOp'new-4 condition, trueDestination, falseDestination, trueDestinationProbability)
    )

    (defn #_"BranchOp" BranchOp'new-4 [#_"ConditionFlag" condition, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (merge (BranchOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"ConditionFlag" :condition condition
                #_"LabelRef" :trueDestination trueDestination
                #_"LabelRef" :falseDestination falseDestination
                #_"double" :trueDestinationProbability trueDestinationProbability
            )
        )
    )

    ;;;
     ; The strategy for emitting jumps is: If either trueDestination or falseDestination is the successor block,
     ; assume the block scheduler did the correct thing and jcc to the other. Otherwise, we need a jcc followed
     ; by a jmp. Use the branch probability to make sure it is more likely to branch on the jcc
     ; (= less likely to execute both the jcc and the jmp instead of just the jcc).
     ; In the case of loops, that means the jcc is the back-edge.
     ;;
    (defm BranchOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"BranchOp" this, #_"Assembler" asm]
            (cond
                (Assembler''isSuccessorEdge-2 asm, (:trueDestination this))  (BranchOp''jcc-4 this, asm, true, (:falseDestination this))
                (Assembler''isSuccessorEdge-2 asm, (:falseDestination this)) (BranchOp''jcc-4 this, asm, false, (:trueDestination this))
                :else
                    (if (< (:trueDestinationProbability this) 0.5)
                        (do
                            (BranchOp''jcc-4 this, asm, true, (:falseDestination this))
                            (Assembler''jmp-2l asm, (LabelRef''label-1 (:trueDestination this)))
                        )
                        (do
                            (BranchOp''jcc-4 this, asm, false, (:trueDestination this))
                            (Assembler''jmp-2l asm, (LabelRef''label-1 (:falseDestination this)))
                        )
                    )
            )
            nil
        )
    )

    (defn #_"void" BranchOp''jcc-4 [#_"BranchOp" this, #_"Assembler" asm, #_"boolean" negate?, #_"LabelRef" target]
        (Assembler''jcc-3 asm, (if negate? (ConditionFlag''negate-1 (:condition this)) (:condition this)), (LabelRef''label-1 target))
        nil
    )
)

(class-ns CRuntimeCallEpilogueOp [LIRInstruction]
    (defn #_"CRuntimeCallEpilogueOp" CRuntimeCallEpilogueOp'new-4 [#_"int" threadLastJavaSpOffset, #_"int" threadLastJavaFpOffset, #_"int" threadLastJavaPcOffset, #_"Register" thread]
        (merge (CRuntimeCallEpilogueOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"int" :threadLastJavaSpOffset threadLastJavaSpOffset
                #_"int" :threadLastJavaFpOffset threadLastJavaFpOffset
                #_"int" :threadLastJavaPcOffset threadLastJavaPcOffset
                #_"Register" :thread thread
            )
        )
    )

    (defm CRuntimeCallEpilogueOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CRuntimeCallEpilogueOp" this, #_"Assembler" asm]
            ;; reset last Java frame
            (Assembler''movslq-3ai asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaSpOffset this)), 0)
            (Assembler''movslq-3ai asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaFpOffset this)), 0)
            (Assembler''movslq-3ai asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaPcOffset this)), 0)
            nil
        )
    )
)

(class-ns CRuntimeCallPrologueOp [LIRInstruction]
    (defn #_"CRuntimeCallPrologueOp" CRuntimeCallPrologueOp'new-2 [#_"int" threadLastJavaSpOffset, #_"Register" thread]
        (merge (CRuntimeCallPrologueOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"int" :threadLastJavaSpOffset threadLastJavaSpOffset
                #_"Register" :thread thread
            )
        )
    )

    (defm CRuntimeCallPrologueOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CRuntimeCallPrologueOp" this, #_"Assembler" asm]
            ;; save last Java frame
            (Assembler''movq-3ar asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaSpOffset this)), AMD64/rsp)
            nil
        )
    )
)

(class-ns CallOp [LIRInstruction]
    (defn #_"CallOp" CallOp'new-3 [#_"Value" result, #_"Value[]" parameters, #_"Value[]" temporaries]
        (merge (CallOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"Value" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"Value[]" :parameters parameters
                ; @OperandMode'TEMP({OperandFlag'REG, OperandFlag'STACK})
                #_"Value[]" :temporaries (LIRInstruction'addStackSlotsToTemporaries-2 parameters, temporaries)
            )
        )
    )

    (defm CallOp LIRInstruction
        (#_"boolean" LIRInstruction'''destroysCallerSavedRegisters-1 [#_"CallOp" this]
            true
        )
    )
)

(class-ns ForeignCallOp [CallOp, LIRInstruction]
    (defn #_"ForeignCallOp" ForeignCallOp'new-4 [#_"ForeignCallLinkage" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (merge (ForeignCallOp'class.) (CallOp'new-3 result, parameters, temps)
            (hash-map
                #_"ForeignCallLinkage" :callTarget callTarget
            )
        )
    )

    (defm ForeignCallOp LIRInstruction
        (#_"boolean" LIRInstruction'''destroysCallerSavedRegisters-1 [#_"ForeignCallOp" this]
            (ForeignCallLinkage''destroysRegisters-1 (:callTarget this))
        )
    )
)

(class-ns DirectFarForeignCallOp [ForeignCallOp, CallOp, LIRInstruction]
    (defn #_"DirectFarForeignCallOp" DirectFarForeignCallOp'new-4 [#_"ForeignCallLinkage" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (merge (DirectFarForeignCallOp'class.) (ForeignCallOp'new-4 callTarget, result, parameters, temps)
            (hash-map
                ; @OperandMode'TEMP({OperandFlag'REG})
                ;; The register allocator does not support virtual registers that are used at the call site, so use a fixed register.
                #_"AllocatableValue" :callTemp (#_"Register" .asValue AMD64/rax, (LIRKind'value-1 AMD64Kind/QWORD))
            )
        )
    )

    (defm DirectFarForeignCallOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DirectFarForeignCallOp" this, #_"Assembler" asm]
            (AMD64Call'directCall-4 asm, (:callTarget this), (#_"RegisterValue" .getRegister (:callTemp this)), false)
            nil
        )
    )
)

(class-ns DirectNearForeignCallOp [ForeignCallOp, CallOp, LIRInstruction]
    (defn #_"DirectNearForeignCallOp" DirectNearForeignCallOp'new-4 [#_"ForeignCallLinkage" linkage, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (merge (DirectNearForeignCallOp'class.) (ForeignCallOp'new-4 linkage, result, parameters, temps))
    )

    (defm DirectNearForeignCallOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DirectNearForeignCallOp" this, #_"Assembler" asm]
            (AMD64Call'directCall-4 asm, (:callTarget this), nil, false)
            nil
        )
    )
)

(class-ns MethodCallOp [CallOp, LIRInstruction]
    (defn #_"MethodCallOp" MethodCallOp'new-4 [#_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (merge (MethodCallOp'class.) (CallOp'new-3 result, parameters, temps)
            (hash-map
                #_"ResolvedJavaMethod" :callTarget callTarget
            )
        )
    )
)

(class-ns DirectCallOp [MethodCallOp, CallOp, LIRInstruction]
    (defn #_"DirectCallOp" DirectCallOp'new-4 [#_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (merge (DirectCallOp'class.) (MethodCallOp'new-4 callTarget, result, parameters, temps))
    )

    (defm DirectCallOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DirectCallOp" this, #_"Assembler" asm]
            (AMD64Call'directCall-4 asm, (:callTarget this), nil, true)
            nil
        )
    )

    (defn #_"int" DirectCallOp''emitCall-2 [#_"DirectCallOp" this, #_"Assembler" asm]
        (AMD64Call'directCall-4 asm, (:callTarget this), nil, true)
    )
)

;;;
 ; A direct call that complies with the conventions for such calls in HotSpot. It doesn't use an
 ; inline cache so it's just a patchable call site.
 ;;
(class-ns DirectStaticCallOp [DirectCallOp, MethodCallOp, CallOp, LIRInstruction]
    (defn #_"DirectStaticCallOp" DirectStaticCallOp'new-5 [#_"ResolvedJavaMethod" target, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"InvokeKind" invokeKind]
        (merge (DirectStaticCallOp'class.) (DirectCallOp'new-4 target, result, parameters, temps)
            (hash-map
                #_"InvokeKind" :invokeKind invokeKind
            )
        )
    )

    (defm DirectStaticCallOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DirectStaticCallOp" this, #_"Assembler" asm]
            (Assembler''recordMark-2 asm, (if (= (:invokeKind this) InvokeKind'Static) HotSpot'invokestaticMark HotSpot'invokespecialMark))
            (LIRInstruction'''emitCode-2 (ยง super #_"DirectCallOp"), asm)
            nil
        )
    )
)

;;;
 ; A direct call that complies with the conventions for such calls in HotSpot. In particular, for
 ; calls using an inline cache, a MOVE instruction is emitted just prior to the aligned direct call.
 ;;
(class-ns DirectVirtualCallOp [DirectCallOp, MethodCallOp, CallOp, LIRInstruction]
    (defn #_"DirectVirtualCallOp" DirectVirtualCallOp'new-5 [#_"ResolvedJavaMethod" target, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"InvokeKind" invokeKind]
        (merge (DirectVirtualCallOp'class.) (DirectCallOp'new-4 target, result, parameters, temps)
            (hash-map
                #_"InvokeKind" :invokeKind invokeKind
            )
        )
    )

    (defm DirectVirtualCallOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DirectVirtualCallOp" this, #_"Assembler" asm]
            ;; The mark for an invocation that uses an inline cache must be placed
            ;; at the instruction that loads the Klass from the inline cache.
            (Assembler''recordMark-2 asm, (if (= (:invokeKind this) InvokeKind'Virtual) HotSpot'invokevirtualMark HotSpot'invokeinterfaceMark))
            ;; This must be emitted exactly like this to ensure, it's patchable.
            (Assembler''movq-3rl asm, AMD64/rax, HotSpot'nonOopBits)
            (DirectCallOp''emitCall-2 (ยง super #_"DirectCallOp"), asm)
            nil
        )
    )
)

;;;
 ; Commutative instruction that has two AllocatableValue operands.
 ;;
(class-ns CommutativeTwoOp [LIRInstruction]
    (defn #_"CommutativeTwoOp" CommutativeTwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (merge (CommutativeTwoOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :x x
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :y y
            )
        )
    )

    (defm CommutativeTwoOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CommutativeTwoOp" this, #_"Assembler" asm]
            (let [
                #_"AllocatableValue" input
                    (when-not (LIRValueUtil'sameRegister-2 (:result this), (:y this)) => (:x this)
                        (AMD64Move'move-3 asm, (:result this), (:x this))
                        (:y this)
                    )
            ]
                (if (instance? RegisterValue input)
                    (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister input))
                    (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (Assembler''asAddress-2 asm, input))
                )
            )
            nil
        )
    )
)

(class-ns CompareAndSwapOp [LIRInstruction]
    (defn #_"CompareAndSwapOp" CompareAndSwapOp'new-5 [#_"AMD64Kind" accessKind, #_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"AllocatableValue" cmpValue, #_"AllocatableValue" newValue]
        (merge (CompareAndSwapOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64Kind" :accessKind accessKind
                ; @OperandMode'DEF
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :address address
                ; @OperandMode'USE
                #_"AllocatableValue" :cmpValue cmpValue
                ; @OperandMode'USE
                #_"AllocatableValue" :newValue newValue
            )
        )
    )

    (defm CompareAndSwapOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CompareAndSwapOp" this, #_"Assembler" asm]
            (when (.isMP HotSpot'target)
                (Assembler''lock-1 asm)
            )
            (condp = (:accessKind this)
                AMD64Kind/DWORD (Assembler''cmpxchgl-3 asm, (#_"RegisterValue" .getRegister (:newValue this)), (AMD64AddressValue''toAddress-1 (:address this)))
                AMD64Kind/QWORD (Assembler''cmpxchgq-3 asm, (#_"RegisterValue" .getRegister (:newValue this)), (AMD64AddressValue''toAddress-1 (:address this)))
            )
            nil
        )
    )
)

(class-ns CondMoveOp [LIRInstruction]
    (defn #_"CondMoveOp" CondMoveOp'new-4 [#_"Variable" result, #_"Condition" condition, #_"AllocatableValue" trueValue, #_"Value" falseValue]
        (merge (CondMoveOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"Value" :result result
                ; @OperandMode'ALIVE({OperandFlag'REG})
                #_"Value" :trueValue trueValue
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST})
                #_"Value" :falseValue falseValue
                #_"ConditionFlag" :condition (AMD64ControlFlow'intCond-1 condition)
            )
        )
    )

    (defm CondMoveOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CondMoveOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:falseValue this))
            (AMD64ControlFlow'cmove-4 asm, (:result this), (:condition this), (:trueValue this))
            nil
        )
    )
)

(class-ns CondSetOp [LIRInstruction]
    (defn #_"CondSetOp" CondSetOp'new-2 [#_"Variable" result, #_"Condition" condition]
        (merge (CondSetOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"Value" :result result
                #_"ConditionFlag" :condition (AMD64ControlFlow'intCond-1 condition)
            )
        )
    )

    (defm CondSetOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CondSetOp" this, #_"Assembler" asm]
            (AMD64ControlFlow'setcc-3 asm, (:result this), (:condition this))
            nil
        )
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one 32-bit immediate operand.
 ;;
(class-ns ConstOp [LIRInstruction]
    (defn #_"ConstOp" ConstOp'new-5b [#_"BinaryArithmetic" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"int" y]
        (ConstOp'new-5a (BinaryArithmetic''getMIOpcode-3 opcode, size, (NumUtil'isByte-1i y)), size, result, x, y)
    )

    (defn #_"ConstOp" ConstOp'new-5a [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"int" y]
        (merge (ConstOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MIOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                #_"int" :y y
            )
        )
    )

    (defm ConstOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"ConstOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:x this))
            (AMD64MIOp''emit-5r (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (:y this))
            nil
        )
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one 32-bit immediate operand.
 ;;
(class-ns ConsumerConstOp [LIRInstruction]
    (defn #_"ConsumerConstOp" ConsumerConstOp'new-4b [#_"BinaryArithmetic" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"int" y]
        (ConsumerConstOp'new-4a (BinaryArithmetic''getMIOpcode-3 opcode, size, (NumUtil'isByte-1i y)), size, x, y)
    )

    (defn #_"ConsumerConstOp" ConsumerConstOp'new-4a [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"int" y]
        (ConsumerConstOp'new-4 opcode, size, x, y)
    )

    (defn #_"ConsumerConstOp" ConsumerConstOp'new-4 [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"int" y]
        (merge (ConsumerConstOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MIOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :x x
                #_"int" :y y
            )
        )
    )

    (defm ConsumerConstOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"ConsumerConstOp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:x this))
                (AMD64MIOp''emit-5r (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (:y this))
                (AMD64MIOp''emit-5a (:opcode this), asm, (:size this), (Assembler''asAddress-2 asm, (:x this)), (:y this))
            )
            nil
        )
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one 32-bit immediate operand
 ; that needs to be patched at runtime.
 ;;
(class-ns VMConstOp [ConsumerConstOp, LIRInstruction]
    (defn #_"VMConstOp" VMConstOp'new-3 [#_"AMD64MIOp" opcode, #_"AllocatableValue" x, #_"VMConstant" c]
        (merge (VMConstOp'class.) (ConsumerConstOp'new-4 opcode, OperandSize'DWORD, x, 0xdeaddead)
            (hash-map
                #_"VMConstant" :c c
            )
        )
    )

    (defm VMConstOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"VMConstOp" this, #_"Assembler" asm]
            (Assembler''recordInlineDataInCode-2 asm, (:c this))
            (LIRInstruction'''emitCode-2 (ยง super #_"ConsumerConstOp"), asm)
            nil
        )
    )
)

;;;
 ; Instruction that has two AllocatableValue operands.
 ;;
(class-ns ConsumerOp [LIRInstruction]
    (defn #_"ConsumerOp" ConsumerOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (merge (ConsumerOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :y y
            )
        )
    )

    (defm ConsumerOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"ConsumerOp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:y this))
                (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (#_"RegisterValue" .getRegister (:y this)))
                (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (Assembler''asAddress-2 asm, (:y this)))
            )
            nil
        )
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one DataSectionReference operand.
 ;;
(class-ns DataOp [LIRInstruction]
    (defn #_"DataOp" DataOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"Constant" y]
        (DataOp'new-5 opcode, size, x, y, (:bytes size))
    )

    (defn #_"DataOp" DataOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"Constant" y, #_"int" alignment]
        (merge (DataOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                #_"Constant" :y y
                #_"int" :alignment alignment
            )
        )
    )

    (defm DataOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DataOp" this, #_"Assembler" asm]
            (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (Assembler''recordDataReferenceInCode-3c asm, (:y this), (:alignment this)))
            nil
        )
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one
 ; DataSectionReference operand.
 ;;
(class-ns DataTwoOp [LIRInstruction]
    (defn #_"DataTwoOp" DataTwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"JavaConstant" y]
        (DataTwoOp'new-6 opcode, size, result, x, y, (#_"JavaKind" .getByteCount (#_"JavaConstant" .getJavaKind y)))
    )

    (defn #_"DataTwoOp" DataTwoOp'new-6 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"JavaConstant" y, #_"int" alignment]
        (merge (DataTwoOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                #_"JavaConstant" :y y
                #_"int" :alignment alignment
            )
        )
    )

    (defm DataTwoOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DataTwoOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:x this))
            (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (Assembler''recordDataReferenceInCode-3c asm, (:y this), (:alignment this)))
            nil
        )
    )
)

(class-ns EpilogueBlockEndOp [LIRInstruction, AMD64HotSpotRestoreRbpOp, BlockEndOp]
    (defn #_"EpilogueBlockEndOp" EpilogueBlockEndOp'new-0 []
        (merge (EpilogueBlockEndOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :savedRbp AMD64HotSpotRestoreRbpOp'PLACEHOLDER
            )
        )
    )

    (defn- #_"void" EpilogueBlockEndOp'leaveFrameAndRestoreRbp-2 [#_"AllocatableValue" savedRbp, #_"Assembler" asm]
        (if (instance? StackSlot savedRbp)
            (do
                ;; restoring RBP from the stack must be done before the frame is removed
                (Assembler''movq-3ra asm, AMD64/rbp, (Assembler''asAddress-2 asm, savedRbp))
            )
            (let [
                #_"Register" framePointer (#_"RegisterValue" .getRegister savedRbp)
            ]
                (when-not (= framePointer AMD64/rbp)
                    (Assembler''movq-3rr asm, AMD64/rbp, framePointer)
                )
            )
        )
        (FrameContext''leave-2 (:frameContext asm), asm)
        nil
    )

    (defn #_"void" EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2 [#_"EpilogueBlockEndOp" this, #_"Assembler" asm]
        (EpilogueBlockEndOp'leaveFrameAndRestoreRbp-2 (:savedRbp this), asm)
        nil
    )

    (defm EpilogueBlockEndOp AMD64HotSpotRestoreRbpOp
        (#_"void" AMD64HotSpotRestoreRbpOp'''setSavedRbp-2 [#_"EpilogueBlockEndOp" this, #_"AllocatableValue" value]
            (ยง ass! this (assoc this :savedRbp value))
            nil
        )
    )
)

;;;
 ; Returns from a function.
 ;;
(class-ns AMD64HotSpotReturnOp [EpilogueBlockEndOp, LIRInstruction, AMD64HotSpotRestoreRbpOp, BlockEndOp]
    (defn #_"AMD64HotSpotReturnOp" AMD64HotSpotReturnOp'new-3 [#_"Value" value, #_"Register" thread, #_"Register" scratchForSafepointOnReturn]
        (merge (AMD64HotSpotReturnOp'class.) (EpilogueBlockEndOp'new-0)
            (hash-map
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"Value" :value value
                #_"Register" :thread thread
                #_"Register" :scratchForSafepointOnReturn scratchForSafepointOnReturn
            )
        )
    )

    (defm AMD64HotSpotReturnOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64HotSpotReturnOp" this, #_"Assembler" asm]
            (EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2 this, asm)
            ;; Every compiled method must have a poll before the return.
            (SafepointOp'emitCode-4 asm, true, (:thread this), (:scratchForSafepointOnReturn this))
            (Assembler''ret-2 asm, 0)
            nil
        )
    )
)

;;;
 ; Removes the current frame and tail calls the uncommon trap routine.
 ;;
(class-ns DeoptimizeCallerOp [EpilogueBlockEndOp, LIRInstruction, AMD64HotSpotRestoreRbpOp, BlockEndOp]
    (defn #_"DeoptimizeCallerOp" DeoptimizeCallerOp'new-0 []
        (merge (DeoptimizeCallerOp'class.) (EpilogueBlockEndOp'new-0))
    )

    (defm DeoptimizeCallerOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"DeoptimizeCallerOp" this, #_"Assembler" asm]
            (EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2 this, asm)
            (AMD64Call'directJmp-2 asm, (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER))
            nil
        )
    )
)

;;;
 ; LIR operation that is an unconditional jump to a #destination().
 ;;
(class-ns JumpOp [LIRInstruction, BlockEndOp]
    (ยง def #_"EnumSet<OperandFlag>" JumpOp'outgoingFlags (EnumSet/of OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST, OperandFlag'OUTGOING))

    (defn #_"JumpOp" JumpOp'new-1 [#_"LabelRef" destination]
        (merge (JumpOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'ALIVE({OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST, OperandFlag'OUTGOING})
                #_"Value[]" :outgoingValues Value/NO_VALUES
                #_"LabelRef" :destination destination
            )
        )
    )

    (defm JumpOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"JumpOp" this, #_"Assembler" asm]
            (when-not (Assembler''isSuccessorEdge-2 asm, (:destination this))
                (Assembler''jmp-2l asm, (LabelRef''label-1 (:destination this)))
            )
            nil
        )
    )

    (defn #_"JumpOp" JumpOp''setPhiValues-2 [#_"JumpOp" this, #_"Value[]" values]
        (assoc this :outgoingValues values)
    )

    (defn #_"Value" JumpOp''getOutgoingValue-2 [#_"JumpOp" this, #_"int" idx]
        (nth (:outgoingValues this) idx)
    )

    (defn #_"JumpOp" JumpOp''clearOutgoingValues-1 [#_"JumpOp" this]
        (assoc this :outgoingValues Value/NO_VALUES)
    )
)

;;;
 ; LIR operation that defines the position of a label.
 ;;
(class-ns LabelOp [LIRInstruction]
    (defn #_"LabelOp" LabelOp'new-2 [#_"Label" label, #_"boolean" aligned?]
        (merge (LabelOp'class.) (LIRInstruction'new-0)
            (hash-map
                ;;;
                 ; In the LIR, every register and variable must be defined before it is used. For method
                 ; parameters that are passed in fixed registers, exception objects passed to the exception
                 ; handler in a fixed register, or any other use of a fixed register not defined in this
                 ; method, an artificial definition is necessary. To avoid spill moves to be inserted
                 ; between the label at the beginning of a block an an actual definition in the second
                 ; instruction of a block, the registers are defined here in the label.
                 ;;
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'STACK})
                #_"Value[]" :incomingValues Value/NO_VALUES
                #_"Label" :label label
                #_"boolean" :aligned? aligned?
                #_"int" :numPhis 0
            )
        )
    )

    (defn #_"LabelOp" LabelOp''setIncomingValues-2 [#_"LabelOp" this, #_"Value[]" values]
        (assoc this :incomingValues values)
    )

    (defn #_"int" LabelOp''getIncomingSize-1 [#_"LabelOp" this]
        (count (:incomingValues this))
    )

    (defn #_"Value" LabelOp''getIncomingValue-2 [#_"LabelOp" this, #_"int" idx]
        (nth (:incomingValues this) idx)
    )

    (defn #_"LabelOp" LabelOp''clearIncomingValues-1 [#_"LabelOp" this]
        (assoc this :incomingValues Value/NO_VALUES)
    )

    (defn #_"LabelOp" LabelOp''addIncomingValues-2 [#_"LabelOp" this, #_"Value[]" values]
        (when (seq (:incomingValues this)) => (LabelOp''setIncomingValues-2 this, values)
            (let [
                #_"Value[]" a (make-array Value (+ (count (:incomingValues this)) (count values)))
            ]
                (System/arraycopy (:incomingValues this), 0, a, 0, (count (:incomingValues this)))
                (System/arraycopy values, 0, a, (count (:incomingValues this)), (count values))
                (assoc this :incomingValues a)
            )
        )
    )

    (defn #_"this" LabelOp''setPhiValues-2 [#_"LabelOp" this, #_"Value[]" values]
        (let [
            this (LabelOp''setIncomingValues-2 this, values)
            this (assoc this :numPhis (count values))
        ]
            this
        )
    )

    ;;;
     ; @return true if this label acts as a PhiIn
     ;;
    (defn #_"boolean" LabelOp''isPhiIn-1 [#_"LabelOp" this]
        (pos? (:numPhis this))
    )

    (defm LabelOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"LabelOp" this, #_"Assembler" asm]
            (when (:aligned? this)
                (Assembler''align-2 asm, (* (.wordSize HotSpot'target) 2))
            )
            (Assembler''bind-2 asm, (:label this))
            nil
        )
    )
)

(class-ns LeaOp [LIRInstruction]
    (defn #_"LeaOp" LeaOp'new-3 [#_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"OperandSize" size]
        (merge (LeaOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'COMPOSITE, OperandFlag'UNINITIALIZED})
                #_"AMD64AddressValue" :address address
                #_"OperandSize" :size size
            )
        )
    )

    (defm LeaOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"LeaOp" this, #_"Assembler" asm]
            (if (= (:size this) OperandSize'QWORD)
                (Assembler''leaq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
                (Assembler''lead-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
            )
            nil
        )
    )
)

(class-ns LoadConfigValueOp [LIRInstruction]
    (defn #_"LoadConfigValueOp" LoadConfigValueOp'new-2 [#_"int" markId, #_"AllocatableValue" result]
        (merge (LoadConfigValueOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
                #_"int" :markId markId
            )
        )
    )

    (defm LoadConfigValueOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"LoadConfigValueOp" this, #_"Assembler" asm]
            (throw! "unimplemented")
        )
    )
)

(class-ns LoadMetaspaceConstantOp [LIRInstruction, LoadConstantOp, MoveOp]
    (defn #_"LoadMetaspaceConstantOp" LoadMetaspaceConstantOp'new-2 [#_"AllocatableValue" result, #_"HotSpotMetaspaceConstant" input]
        (merge (LoadMetaspaceConstantOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :result result
                #_"HotSpotMetaspaceConstant" :input input
            )
        )
    )

    (defm LoadMetaspaceConstantOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"LoadMetaspaceConstantOp" this, #_"Assembler" asm]
            (let [
                #_"boolean" compressed? (#_"HotSpotMetaspaceConstant" .isCompressed (:input this))
            ]
                (if (instance? RegisterValue (:result this))
                    (if compressed?
                        (do
                            (Assembler''recordInlineDataInCode-2 asm, (:input this))
                            (Assembler''movl-3ri asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddead)
                        )
                        (do
                            (Assembler''recordInlineDataInCode-2 asm, (:input this))
                            (Assembler''movq-3rl asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddeaddeaddead)
                        )
                    )
                    (when compressed? => (throw! "cannot store 64-bit constants to memory")
                        (do
                            (Assembler''recordInlineDataInCode-2 asm, (:input this))
                            (Assembler''movl-3ai asm, (Assembler''asAddress-2 asm, (:result this)), 0xdeaddead)
                        )
                    )
                )
            )
            nil
        )
    )

    (defm LoadMetaspaceConstantOp LoadConstantOp
        (#_"Constant" LoadConstantOp'''getConstant-1 [#_"LoadMetaspaceConstantOp" this]
            (:input this)
        )
    )

    (defm LoadMetaspaceConstantOp MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"LoadMetaspaceConstantOp" this]
            (:result this)
        )
    )
)

(class-ns LoadObjectConstantOp [LIRInstruction, LoadConstantOp, MoveOp]
    (defn #_"LoadObjectConstantOp" LoadObjectConstantOp'new-2 [#_"AllocatableValue" result, #_"HotSpotObjectConstant" input]
        (merge (LoadObjectConstantOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :result result
                #_"HotSpotObjectConstant" :input input
            )
        )
    )

    (defm LoadObjectConstantOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"LoadObjectConstantOp" this, #_"Assembler" asm]
            (let [
                #_"boolean" compressed? (#_"HotSpotObjectConstant" .isCompressed (:input this))
            ]
                (if (.inlineObjects HotSpot'target)
                    (do
                        (Assembler''recordInlineDataInCode-2 asm, (:input this))
                        (if (instance? RegisterValue (:result this))
                            (if compressed?
                                (Assembler''movl-3ri asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddead)
                                (Assembler''movq-3rl asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddeaddeaddead)
                            )
                            (if compressed?
                                (Assembler''movl-3ai asm, (Assembler''asAddress-2 asm, (:result this)), 0xdeaddead)
                                (throw! "cannot store 64-bit constants to memory")
                            )
                        )
                    )
                    (when (instance? RegisterValue (:result this)) => (throw! "cannot directly store data patch to memory")
                        (let [
                            #_"AMD64Address" address (Assembler''recordDataReferenceInCode-3c asm, (:input this), (if compressed? 4 8))
                        ]
                            (if compressed?
                                (Assembler''movl-3ra asm, (#_"RegisterValue" .getRegister (:result this)), address)
                                (Assembler''movq-3ra asm, (#_"RegisterValue" .getRegister (:result this)), address)
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defm LoadObjectConstantOp LoadConstantOp
        (#_"Constant" LoadConstantOp'''getConstant-1 [#_"LoadObjectConstantOp" this]
            (:input this)
        )
    )

    (defm LoadObjectConstantOp MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"LoadObjectConstantOp" this]
            (:result this)
        )
    )
)

;;;
 ; Manages allocation and re-use of lock slots in a scoped manner. The slots are used in HotSpot's
 ; lightweight locking mechanism to store the mark word of an object being locked.
 ;;
(class-ns LockStack [LIRInstruction]
    (def- #_"AllocatableValue[]" LockStack'EMPTY (make-array AllocatableValue 0))

    (defn #_"LockStack" LockStack'new-2 [#_"FrameMapBuilder" frameMapBuilder, #_"LIRKind" slotKind]
        (merge (LockStack'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'STACK})
                #_"AllocatableValue[]" :locks LockStack'EMPTY
                #_"FrameMapBuilder" :frameMapBuilder frameMapBuilder
                #_"LIRKind" :slotKind slotKind
            )
        )
    )

    ;;;
     ; Gets a stack slot for a lock at a given lock nesting depth, allocating it first if necessary.
     ;;
    (defn #_"VirtualStackSlot" LockStack''makeLockSlot-2 [#_"LockStack" this, #_"int" lockDepth]
        (cond
            (= (:locks this) LockStack'EMPTY)
                (ยง ass! this (assoc this :locks (make-array AllocatableValue (inc lockDepth))))
            (< (count (:locks this)) (inc lockDepth))
                (ยง ass! this (assoc this :locks (Arrays/copyOf (:locks this), (inc lockDepth))))
        )
        (when (nil? (nth (:locks this) lockDepth))
            (aset (:locks this) lockDepth (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder this), (:slotKind this)))
        )
        (nth (:locks this) lockDepth)
    )

    (defm LockStack LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"LockStack" this, #_"Assembler" asm]
            ;; do nothing
            nil
        )
    )
)

;;;
 ; Instruction with a single operand that is both input and output.
 ;;
(class-ns MOp [LIRInstruction]
    (defn #_"MOp" MOp'new-4 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" value]
        (merge (MOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :value value
            )
        )
    )

    (defm MOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:value this))
            (AMD64MOp''emit-4r (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)))
            nil
        )
    )
)

;;;
 ; Instruction with separate input and output operands, and an operand encoding of MR.
 ;;
(class-ns MROp [LIRInstruction]
    (defn #_"MROp" MROp'new-4 [#_"AMD64MROp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" value]
        (merge (MROp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MROp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :value value
            )
        )
    )

    (defm MROp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MROp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:result this))
                (AMD64MROp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister (:value this)))
                (AMD64MROp''emit-5 (:opcode this), asm, (:size this), (Assembler''asAddress-2 asm, (:result this)), (#_"RegisterValue" .getRegister (:value this)))
            )
            nil
        )
    )
)

(class-ns MembarOp [LIRInstruction]
    (defn #_"MembarOp" MembarOp'new-1 [#_"int" barriers]
        (merge (MembarOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"int" :barriers barriers
            )
        )
    )

    (defm MembarOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MembarOp" this, #_"Assembler" asm]
            (Assembler''membar-2 asm, (:barriers this))
            nil
        )
    )
)

;;;
 ; Instruction that has one {@link AMD64AddressValue memory} operand and one 32-bit immediate operand.
 ;;
(class-ns MemoryConstOp [LIRInstruction, ImplicitNullCheck]
    #_unused
    (defn #_"MemoryConstOp" MemoryConstOp'new-4b [#_"BinaryArithmetic" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"int" y]
        (MemoryConstOp'new-4a (BinaryArithmetic''getMIOpcode-3 opcode, size, (NumUtil'isByte-1i y)), size, x, y)
    )

    (defn #_"MemoryConstOp" MemoryConstOp'new-4a [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"int" y]
        (MemoryConstOp'new-4 opcode, size, x, y)
    )

    (defn #_"MemoryConstOp" MemoryConstOp'new-4 [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"int" y]
        (merge (MemoryConstOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MIOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'USE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :x x
                #_"int" :y y
            )
        )
    )

    (defm MemoryConstOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MemoryConstOp" this, #_"Assembler" asm]
            (AMD64MIOp''emit-5a (:opcode this), asm, (:size this), (AMD64AddressValue''toAddress-1 (:x this)), (:y this))
            nil
        )
    )

    (defm MemoryConstOp ImplicitNullCheck
        (#_"boolean" ImplicitNullCheck'''makeNullCheckFor-3 [#_"MemoryConstOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
            (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:x this), value, implicitNullCheckLimit)
        )
    )
)

;;;
 ; Instruction that has one {@link AMD64AddressValue memory} operand and one 32-bit immediate
 ; operand that needs to be patched at runtime.
 ;;
(class-ns MemoryVMConstOp [MemoryConstOp, LIRInstruction, ImplicitNullCheck]
    (defn #_"MemoryVMConstOp" MemoryVMConstOp'new-3 [#_"AMD64MIOp" opcode, #_"AMD64AddressValue" x, #_"VMConstant" c]
        (merge (MemoryVMConstOp'class.) (MemoryConstOp'new-4 opcode, OperandSize'DWORD, x, 0xdeaddead)
            (hash-map
                #_"VMConstant" :c c
            )
        )
    )

    (defm MemoryVMConstOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MemoryVMConstOp" this, #_"Assembler" asm]
            (Assembler''recordInlineDataInCode-2 asm, (:c this))
            (LIRInstruction'''emitCode-2 (ยง super #_"MemoryConstOp"), asm)
            nil
        )
    )
)

;;;
 ; Instruction that has a {@link AMD64AddressValue memory} operand as first input and an AllocatableValue as second input.
 ;;
(class-ns MemoryMROp [LIRInstruction, ImplicitNullCheck]
    (defn #_"MemoryMROp" MemoryMROp'new-4 [#_"AMD64MROp" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"AllocatableValue" y]
        (merge (MemoryMROp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64MROp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'USE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :x x
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :y y
            )
        )
    )

    (defm MemoryMROp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MemoryMROp" this, #_"Assembler" asm]
            (AMD64MROp''emit-5 (:opcode this), asm, (:size this), (AMD64AddressValue''toAddress-1 (:x this)), (#_"RegisterValue" .getRegister (:y this)))
            nil
        )
    )

    (defm MemoryMROp ImplicitNullCheck
        (#_"boolean" ImplicitNullCheck'''makeNullCheckFor-3 [#_"MemoryMROp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
            (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:x this), value, implicitNullCheckLimit)
        )
    )
)

;;;
 ; Instruction with a {@link AMD64AddressValue memory} operand.
 ;;
(class-ns MemoryOp [LIRInstruction, ImplicitNullCheck]
    (defn #_"MemoryOp" MemoryOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AMD64AddressValue" input]
        (merge (MemoryOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :input input
            )
        )
    )

    (defm MemoryOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MemoryOp" this, #_"Assembler" asm]
            (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:input this)))
            nil
        )
    )

    (defm MemoryOp ImplicitNullCheck
        (#_"boolean" ImplicitNullCheck'''makeNullCheckFor-3 [#_"MemoryOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
            (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:input this), value, implicitNullCheckLimit)
        )
    )
)

;;;
 ; Instruction that has an AllocatableValue as first input and a {@link AMD64AddressValue memory} operand as second input.
 ;;
(class-ns MemoryRMOp [LIRInstruction, ImplicitNullCheck]
    #_unused
    (defn #_"MemoryRMOp" MemoryRMOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"AMD64AddressValue" y]
        (merge (MemoryRMOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                ; @OperandMode'USE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :y y
            )
        )
    )

    (defm MemoryRMOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MemoryRMOp" this, #_"Assembler" asm]
            (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (AMD64AddressValue''toAddress-1 (:y this)))
            nil
        )
    )

    (defm MemoryRMOp ImplicitNullCheck
        (#_"boolean" ImplicitNullCheck'''makeNullCheckFor-3 [#_"MemoryRMOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
            (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:y this), value, implicitNullCheckLimit)
        )
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one {@link AMD64AddressValue
 ; memory} operand.
 ;;
(class-ns MemoryTwoOp [LIRInstruction, ImplicitNullCheck]
    (defn #_"MemoryTwoOp" MemoryTwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AMD64AddressValue" y]
        (merge (MemoryTwoOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                ; @OperandMode'ALIVE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :y y
            )
        )
    )

    (defm MemoryTwoOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MemoryTwoOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:x this))
            (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:y this)))
            nil
        )
    )

    (defm MemoryTwoOp ImplicitNullCheck
        (#_"boolean" ImplicitNullCheck'''makeNullCheckFor-3 [#_"MemoryTwoOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
            (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:y this), value, implicitNullCheckLimit)
        )
    )
)

(class-ns MoveFromConstOp [LIRInstruction, LoadConstantOp, MoveOp]
    (defn #_"MoveFromConstOp" MoveFromConstOp'new-2 [#_"AllocatableValue" result, #_"JavaConstant" input]
        (merge (MoveFromConstOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :result result
                #_"JavaConstant" :input input
            )
        )
    )

    (defm MoveFromConstOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"MoveFromConstOp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:result this))
                (AMD64Move'const2reg-3 asm, (#_"RegisterValue" .getRegister (:result this)), (:input this))
                (AMD64Move'const2stack-3 asm, (:result this), (:input this))
            )
            nil
        )
    )

    (defm MoveFromConstOp LoadConstantOp
        (#_"Constant" LoadConstantOp'''getConstant-1 [#_"MoveFromConstOp" this]
            (:input this)
        )
    )

    (defm MoveFromConstOp MoveOp
        (#_"AllocatableValue" MoveOp'''getResult-1 [#_"MoveFromConstOp" this]
            (:result this)
        )
    )
)

;;;
 ; A LIR operation that does nothing. If the operation records its position, it can be
 ; subsequently {@linkplain #replace(LIR, LIRInstruction) replaced}.
 ;;
(class-ns NoOp [LIRInstruction]
    (defn #_"NoOp" NoOp'new-2 [#_"Block" block, #_"int" index]
        (merge (NoOp'class.) (LIRInstruction'new-0)
            (hash-map
                ;;;
                 ; The block in which this instruction is located.
                 ;;
                #_"Block" :block block
                ;;;
                 ; The block index of this instruction.
                 ;;
                #_"int" :index index
            )
        )
    )

    (defn #_"void" NoOp''replace-3 [#_"NoOp" this, #_"LIR" lir, #_"LIRInstruction" replacement]
        (#_"ArrayList" .set (LIR''getLIRforBlock-2 lir, (:block this)), (:index this), replacement)
        nil
    )

    (defm NoOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"NoOp" this, #_"Assembler" asm]
            (when (some? (:block this))
                (throw! (str this " should have been replaced"))
            )
            nil
        )
    )
)

(class-ns NullCheckOp [LIRInstruction, NullCheck]
    (defn #_"NullCheckOp" NullCheckOp'new-1 [#_"AMD64AddressValue" address]
        (merge (NullCheckOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'USE({OperandFlag'COMPOSITE})
                #_"AMD64AddressValue" :address address
            )
        )
    )

    (defm NullCheckOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"NullCheckOp" this, #_"Assembler" asm]
            (Assembler''nullCheck-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
            nil
        )
    )

    (defm NullCheckOp NullCheck
        (#_"Value" NullCheck'''getCheckedValue-1 [#_"NullCheckOp" this]
            (:base (:address this))
        )
    )
)

(class-ns PointerCompressionOp [LIRInstruction]
    (defn #_"PointerCompressionOp" PointerCompressionOp'new-5 [#_"AllocatableValue" result, #_"Value" input, #_"AllocatableValue" baseRegister, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (merge (PointerCompressionOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"CompressEncoding" :encoding encoding
                #_"boolean" :never-nil? never-nil?
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'CONST})
                #_"Value" :input input
                ; @OperandMode'ALIVE({OperandFlag'REG, OperandFlag'ILLEGAL, OperandFlag'UNINITIALIZED})
                #_"AllocatableValue" :baseRegister baseRegister
            )
        )
    )

    (defn #_"boolean" PointerCompressionOp'hasBase-1 [#_"CompressEncoding" encoding]
        (CompressEncoding''hasBase-1 encoding)
    )

    (defn #_"Register" PointerCompressionOp''getBaseRegister-1 [#_"PointerCompressionOp" this]
        (#_"RegisterValue" .getRegister (:baseRegister this))
    )

    (defn #_"int" PointerCompressionOp''getShift-1 [#_"PointerCompressionOp" this]
        (:shift (:encoding this))
    )

    (defn #_"void" PointerCompressionOp''move-3 [#_"PointerCompressionOp" this, #_"LIRKind" kind, #_"Assembler" asm]
        (AMD64Move'move-4 (#_"ValueKind" .getPlatformKind kind), asm, (:result this), (:input this))
        nil
    )
)

(class-ns CompressPointerOp [PointerCompressionOp, LIRInstruction]
    (defn #_"CompressPointerOp" CompressPointerOp'new-5 [#_"AllocatableValue" result, #_"Value" input, #_"AllocatableValue" baseRegister, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (merge (CompressPointerOp'class.) (PointerCompressionOp'new-5 result, input, baseRegister, encoding, never-nil?))
    )

    (defm CompressPointerOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"CompressPointerOp" this, #_"Assembler" asm]
            (PointerCompressionOp''move-3 this, (LIRKindTool'getObjectKind-0), asm)

            (let [
                #_"Register" resReg (#_"RegisterValue" .getRegister (:result this))
            ]
                (when (PointerCompressionOp'hasBase-1 (:encoding this))
                    (let [
                        #_"Register" baseReg (PointerCompressionOp''getBaseRegister-1 this)
                    ]
                        (when-not (:never-nil? this)
                            (Assembler''testq-3 asm, resReg, resReg)
                            (Assembler''cmovq-4rr asm, ConditionFlag'Equal, resReg, baseReg)
                        )
                        (Assembler''subq-3rr asm, resReg, baseReg)
                    )
                )

                (let [
                    #_"int" shift (PointerCompressionOp''getShift-1 this)
                ]
                    (when-not (zero? shift)
                        (Assembler''shrq-3 asm, resReg, shift)
                    )
                )
            )
            nil
        )
    )
)

(class-ns UncompressPointerOp [PointerCompressionOp, LIRInstruction]
    (defn #_"UncompressPointerOp" UncompressPointerOp'new-5 [#_"AllocatableValue" result, #_"Value" input, #_"AllocatableValue" baseRegister, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (merge (UncompressPointerOp'class.) (PointerCompressionOp'new-5 result, input, baseRegister, encoding, never-nil?))
    )

    (defm UncompressPointerOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"UncompressPointerOp" this, #_"Assembler" asm]
            (PointerCompressionOp''move-3 this, (LIRKindTool'getNarrowOopKind-0), asm)

            (let [
                #_"Register" resReg (#_"RegisterValue" .getRegister (:result this))
                #_"int" shift (PointerCompressionOp''getShift-1 this)
            ]
                (when-not (zero? shift)
                    (Assembler''shlq-3 asm, resReg, shift)
                )

                (let [
                    #_"Register" baseReg (when (PointerCompressionOp'hasBase-1 (:encoding this)) (PointerCompressionOp''getBaseRegister-1 this))
                ]
                    (when (some? baseReg)
                        (when-not (:never-nil? this) => (Assembler''addq-3rr asm, resReg, baseReg)
                            (when (zero? shift)
                                ;; if encoding.shift != 0, the flags are already set by the shlq
                                (Assembler''testq-3 asm, resReg, resReg)
                            )
                            (let [
                                #_"Label" done (Label'new-0)
                            ]
                                (Assembler''jccb-3 asm, ConditionFlag'Equal, done)
                                (Assembler''addq-3rr asm, resReg, baseReg)
                                (Assembler''bind-2 asm, done)
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Instruction with a separate result operand, one AllocatableValue input and one 32-bit
 ; immediate input.
 ;;
(class-ns RMIOp [LIRInstruction]
    (defn #_"RMIOp" RMIOp'new-5 [#_"AMD64RMIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"int" y]
        (merge (RMIOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMIOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :x x
                #_"int" :y y
            )
        )
    )

    (defm RMIOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"RMIOp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:x this))
                (AMD64RMIOp''emit-6r (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister (:x this)), (:y this))
                (AMD64RMIOp''emit-6a (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (Assembler''asAddress-2 asm, (:x this)), (:y this))
            )
            nil
        )
    )
)

;;;
 ; Instruction with separate input and output operands, and an operand encoding of RM.
 ;;
(class-ns RMOp [LIRInstruction]
    (defn #_"RMOp" RMOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" value]
        (merge (RMOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :value value
            )
        )
    )

    (defm RMOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"RMOp" this, #_"Assembler" asm]
            (if (instance? RegisterValue (:value this))
                (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister (:value this)))
                (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (Assembler''asAddress-2 asm, (:value this)))
            )
            nil
        )
    )
)

;;;
 ; AMD64 rdtsc operation. The result is in EDX:EAX.
 ;;
(class-ns ReadTimestampCounter [LIRInstruction]
    (defn #_"ReadTimestampCounter" ReadTimestampCounter'new-0 []
        (merge (ReadTimestampCounter'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :highResult (#_"Register" .asValue AMD64/rdx, (LIRKind'value-1 AMD64Kind/DWORD))
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :lowResult (#_"Register" .asValue AMD64/rax, (LIRKind'value-1 AMD64Kind/DWORD))
            )
        )
    )

    (defm ReadTimestampCounter LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"ReadTimestampCounter" this, #_"Assembler" asm]
            (Assembler''rdtsc-1 asm)
            nil
        )
    )
)

(class-ns ReturnOp [LIRInstruction, BlockEndOp]
    #_unused
    (defn #_"ReturnOp" ReturnOp'new-1 [#_"Value" x]
        (merge (ReturnOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'USE({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"Value" :x x
            )
        )
    )

    (defm ReturnOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"ReturnOp" this, #_"Assembler" asm]
            (FrameContext''leave-2 (:frameContext asm), asm)
            (Assembler''ret-2 asm, 0)
            nil
        )
    )
)

;;;
 ; Emits a safepoint poll.
 ;;
(class-ns SafepointOp [LIRInstruction]
    ;;;
     ; Tests if the polling page address can be reached from the code cache with 32-bit displacements.
     ;;
    (defn- #_"boolean" SafepointOp'isPollingPageFar-0 []
        (let [
            #_"long" pollingPageAddress HotSpot'safepointPollingAddress
        ]
            (or (not (NumUtil'isInt-1 (- pollingPageAddress HotSpot'codeCacheLowBound))) (not (NumUtil'isInt-1 (- pollingPageAddress HotSpot'codeCacheHighBound))))
        )
    )

    (defn #_"SafepointOp" SafepointOp'new-2 [#_"LIRBuilder" builder, #_"Register" thread]
        (merge (SafepointOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'TEMP({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"AllocatableValue" :temp (if (or HotSpot'threadLocalHandshakes (SafepointOp'isPollingPageFar-0)) (LIRGenerator''newVariable-2 (:gen builder), (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))) Value/ILLEGAL) ;; => don't waste a register if it's unneeded
                #_"Register" :thread thread
            )
        )
    )

    (defm SafepointOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"SafepointOp" this, #_"Assembler" asm]
            (SafepointOp'emitCode-4 asm, false, (:thread this), (when (instance? RegisterValue (:temp this)) (#_"RegisterValue" .getRegister (:temp this))))
            nil
        )
    )

    (defn- #_"void" SafepointOp'emitThreadLocalPoll-4 [#_"Assembler" asm, #_"boolean" atReturn, #_"Register" thread, #_"Register" scratch]
        (Assembler''movptr-3ra asm, scratch, (AMD64Address'new-2 thread, HotSpot'threadPollingPageOffset))
        (Assembler''recordMark-2 asm, (if atReturn HotSpot'pollReturnFarMark HotSpot'pollFarMark))
        (Assembler''testl-3ra asm, AMD64/rax, (AMD64Address'new-1 scratch))
        nil
    )

    (defn- #_"void" SafepointOp'emitGlobalPoll-3 [#_"Assembler" asm, #_"boolean" atReturn, #_"Register" scratch]
        (if (SafepointOp'isPollingPageFar-0)
            (do
                (Assembler''movq-3rl asm, scratch, HotSpot'safepointPollingAddress)
                (Assembler''recordMark-2 asm, (if atReturn HotSpot'pollReturnFarMark HotSpot'pollFarMark))
                (Assembler''testl-3ra asm, AMD64/rax, (AMD64Address'new-1 scratch))
            )
            (do
                (Assembler''recordMark-2 asm, (if atReturn HotSpot'pollReturnNearMark HotSpot'pollNearMark))
                ;; The C++ code transforms the polling page offset into an RIP displacement
                ;; to the real address at that offset in the polling page.
                (Assembler''testl-3ra asm, AMD64/rax, (AMD64Address'new-2 AMD64/rip, 0))
            )
        )
        nil
    )

    (defn #_"void" SafepointOp'emitCode-4 [#_"Assembler" asm, #_"boolean" atReturn, #_"Register" thread, #_"Register" scratch]
        (if HotSpot'threadLocalHandshakes
            (SafepointOp'emitThreadLocalPoll-4 asm, atReturn, thread, scratch)
            (SafepointOp'emitGlobalPoll-3 asm, atReturn, scratch)
        )
        nil
    )
)

(class-ns SpillRegistersOp [LIRInstruction]
    (defn #_"SpillRegistersOp" SpillRegistersOp'new-0 []
        (merge (SpillRegistersOp'class.) (LIRInstruction'new-0))
    )

    (defm SpillRegistersOp LIRInstruction
        (#_"boolean" LIRInstruction'''destroysCallerSavedRegisters-1 [#_"SpillRegistersOp" this]
            true
        )

        (#_"void" LIRInstruction'''emitCode-2 [#_"SpillRegistersOp" this, #_"Assembler" asm]
            ;; do nothing, just keep value alive until at least here
            nil
        )
    )
)

(class-ns StackLeaOp [LIRInstruction]
    (defn #_"StackLeaOp" StackLeaOp'new-2 [#_"AllocatableValue" result, #_"AllocatableValue" slot]
        (merge (StackLeaOp'class.) (LIRInstruction'new-0)
            (hash-map
                ; @OperandMode'DEF({OperandFlag'REG})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'STACK, OperandFlag'UNINITIALIZED})
                #_"AllocatableValue" :slot slot
            )
        )
    )

    (defm StackLeaOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"StackLeaOp" this, #_"Assembler" asm]
            (Assembler''leaq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (Assembler''asAddress-2 asm, (:slot this)))
            nil
        )
    )
)

(class-ns StrategySwitchOp [LIRInstruction, BlockEndOp]
    (defn #_"StrategySwitchOp" StrategySwitchOp'new-5 [#_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Value" key, #_"Value" scratch]
        (merge (StrategySwitchOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"Constant[]" :keyConstants (:keyConstants strategy)
                #_"LabelRef[]" :keyTargets keyTargets
                #_"LabelRef" :defaultTarget defaultTarget
                ; @OperandMode'ALIVE({OperandFlag'REG})
                #_"Value" :key key
                ; @OperandMode'TEMP({OperandFlag'REG, OperandFlag'ILLEGAL})
                #_"Value" :scratch scratch
                #_"SwitchStrategy" :strategy strategy
            )
        )
    )

    (defm StrategySwitchOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"StrategySwitchOp" this, #_"Assembler" asm]
            (SwitchStrategy'''run-2 (:strategy this), (AMD64SwitchClosure'new-3 this, (#_"RegisterValue" .getRegister (:key this)), asm))
            nil
        )
    )
)

(class-ns AMD64HotSpotStrategySwitchOp [StrategySwitchOp, LIRInstruction, BlockEndOp]
    (defn #_"AMD64HotSpotStrategySwitchOp" AMD64HotSpotStrategySwitchOp'new-5 [#_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Value" key, #_"Value" scratch]
        (merge (AMD64HotSpotStrategySwitchOp'class.) (StrategySwitchOp'new-5 strategy, keyTargets, defaultTarget, key, scratch))
    )

    (defm AMD64HotSpotStrategySwitchOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"AMD64HotSpotStrategySwitchOp" this, #_"Assembler" asm]
            (SwitchStrategy'''run-2 (:strategy this), (HotSpotSwitchClosure'new-3 this, (#_"RegisterValue" .getRegister (:key this)), asm))
            nil
        )
    )
)

(class-ns TableSwitchOp [LIRInstruction, BlockEndOp]
    (defn #_"TableSwitchOp" TableSwitchOp'new-6 [#_"int" lowKey, #_"LabelRef" defaultTarget, #_"LabelRef[]" targets, #_"Value" index, #_"Variable" scratch, #_"Variable" idxScratch]
        (merge (TableSwitchOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"int" :lowKey lowKey
                #_"LabelRef" :defaultTarget defaultTarget
                #_"LabelRef[]" :targets targets
                ; @OperandMode'USE
                #_"Value" :index index
                ; @OperandMode'TEMP({OperandFlag'REG, OperandFlag'HINT})
                #_"Value" :idxScratch idxScratch
                ; @OperandMode'TEMP
                #_"Value" :scratch scratch
            )
        )
    )

    (defm TableSwitchOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"TableSwitchOp" this, #_"Assembler" asm]
            (let [
                #_"Register" indexReg (#_"RegisterValue" .getRegister (:index this))
                #_"Register" idxScratchReg (#_"RegisterValue" .getRegister (:idxScratch this))
                #_"Register" scratchReg (#_"RegisterValue" .getRegister (:scratch this))
            ]
                (when-not (= indexReg idxScratchReg)
                    (Assembler''movl-3rr asm, idxScratchReg, indexReg)
                )

                ;; compare index against jump table bounds
                (let [
                    #_"int" highKey (dec (+ (:lowKey this) (count (:targets this))))
                ]
                    (if (not= (:lowKey this) 0)
                        (do
                            ;; subtract the low value from the switch value
                            (Assembler''subl-3ri asm, idxScratchReg, (:lowKey this))
                            (Assembler''cmpl-3ri asm, idxScratchReg, (- highKey (:lowKey this)))
                        )
                        (Assembler''cmpl-3ri asm, idxScratchReg, highKey)
                    )

                    ;; jump to default target if index is not within the jump table
                    (when (some? (:defaultTarget this))
                        (Assembler''jcc-3 asm, ConditionFlag'Above, (LabelRef''label-1 (:defaultTarget this)))
                    )

                    ;; set scratch to address of jump table
                    (Assembler''leaq-3 asm, scratchReg, (AMD64Address'new-2 AMD64/rip, 0))
                    (let [
                        #_"int" afterLea (Assembler''position-1 asm)
                    ]
                        ;; load jump table entry into scratch and jump to it
                        (Assembler''movslq-3ra asm, idxScratchReg, (AMD64Address'new-4 scratchReg, idxScratchReg, Scale'Times4, 0))
                        (Assembler''addq-3rr asm, scratchReg, idxScratchReg)
                        (Assembler''jmp-2r asm, scratchReg)

                        ;; inserting padding, so that jump table address is 4-byte aligned
                        (when-not (zero? (& (Assembler''position-1 asm) 0x3))
                            (Assembler''nop-2 asm, (- 4 (& (Assembler''position-1 asm) 0x3)))
                        )

                        ;; patch LEA instruction above now that we know the position of the jump table
                        ;; TODO this is ugly and should be done differently
                        (let [
                            #_"int" jumpTablePos (Assembler''position-1 asm)
                            #_"int" leaDisplacementPosition (- afterLea 4)
                        ]
                            (Assembler''emitInt-3 asm, (- jumpTablePos afterLea), leaDisplacementPosition)

                            ;; emit jump table entries
                            (doseq [#_"LabelRef" target (:targets this)]
                                (let [
                                    #_"Label" label (LabelRef''label-1 target)
                                    #_"int" offsetToJumpTableBase (- (Assembler''position-1 asm) jumpTablePos)
                                ]
                                    (if (Label''isBound-1 label)
                                        (Assembler''emitInt-2 asm, (- (:position label) jumpTablePos))
                                        (do
                                            (ยง ass! label (Label''addPatchAt-2 label, (Assembler''position-1 asm)))

                                            (Assembler''emitByte-2 asm, 0) ;; pseudo-opcode for jump table entry
                                            (Assembler''emitShort-2 asm, offsetToJumpTableBase)
                                            (Assembler''emitByte-2 asm, 0) ;; padding to make jump table entry 4 bytes wide
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Instruction that has two AllocatableValue operands.
 ;;
(class-ns TwoOp [LIRInstruction]
    (defn #_"TwoOp" TwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (merge (TwoOp'class.) (LIRInstruction'new-0)
            (hash-map
                #_"AMD64RMOp" :opcode opcode
                #_"OperandSize" :size size
                ; @OperandMode'DEF({OperandFlag'REG, OperandFlag'HINT})
                #_"AllocatableValue" :result result
                ; @OperandMode'USE({OperandFlag'REG})
                #_"AllocatableValue" :x x
                ;;;
                 ; This argument must be Alive to ensure that result and y are not assigned to the same register,
                 ; which would break the code generation by destroying y too early.
                 ;;
                ; @OperandMode'ALIVE({OperandFlag'REG, OperandFlag'STACK})
                #_"AllocatableValue" :y y
            )
        )
    )

    (defm TwoOp LIRInstruction
        (#_"void" LIRInstruction'''emitCode-2 [#_"TwoOp" this, #_"Assembler" asm]
            (AMD64Move'move-3 asm, (:result this), (:x this))
            (if (instance? RegisterValue (:y this))
                (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister (:y this)))
                (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (Assembler''asAddress-2 asm, (:y this)))
            )
            nil
        )
    )
)

(class-ns LIRPhaseContext []
    (defn #_"LIRPhaseContext" LIRPhaseContext'new-1 [#_"LIRGenerator" lirGen]
        (merge (LIRPhaseContext'class.)
            (hash-map
                #_"LIRGenerator" :lirGen lirGen
            )
        )
    )
)

(class-ns LIRPhaseSuite [LIRPhase #_"<LIRPhaseContext>"]
    (defn #_"LIRPhaseSuite" LIRPhaseSuite'new-1* [& #_"LIRPhase<LIRPhaseContext>..." phases]
        (merge (LIRPhaseSuite'class.)
            (hash-map
                #_"LIRPhase<LIRPhaseContext>*" :phases phases
            )
        )
    )

    (defm LIRPhaseSuite LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"LIRPhaseSuite" this, #_"LIRGenerationResult" res, #_"LIRPhaseContext" context]
            (doseq [#_"LIRPhase<LIRPhaseContext>" phase (:phases this)]
                (LIRPhase'''run-3 phase, res, context)
            )
            nil
        )
    )
)

(class-ns LIRSuites []
    (defn #_"LIRSuites" LIRSuites'new-0 []
        (merge (LIRSuites'class.)
            (hash-map
                ;;;
                 ; PreAllocationPhases are executed between LIR generation and register allocation.
                 ; Implementers can create new variables, stack slots and virtual stack slots.
                 ;;
                #_"LIRPhaseSuite" :preAllocStage
                    (LIRPhaseSuite'new-1*
                        (ConstantLoadOptimization'new-0),
                        (SaveCalleeSaveRegisters'new-0)
                    )
                ;;;
                 ; AllocationPhases are responsible for register allocation and translating VirtualStackSlots into StackSlots.
                 ; After the AllocationStage there should be no more Variables and VirtualStackSlots.
                 ;;
                #_"LIRPhaseSuite" :allocStage
                    (LIRPhaseSuite'new-1*
                        (LinearScanPhase'new-0),
                        (StackSlotAllocator'new-0)
                    )
                ;;;
                 ; PostAllocationPhases are executed after register allocation and before machine code generation.
                 ; A PostAllocationPhase must not introduce new Variables, VirtualStackSlots or StackSlots.
                 ; Blocks might be removed from LIR#codeEmittingOrder() by overwriting them with nil.
                 ;;
                #_"LIRPhaseSuite" :postAllocStage
                    (LIRPhaseSuite'new-1*
                        (EdgeMoveOptimizer'new-0),
                        (ControlFlowOptimizer'new-0),
                        (RedundantMoveElimination'new-0),
                        (NullCheckOptimizer'new-0),
                        ;; note: this phase must be appended *after* RedundantMoveElimination
                        (StackMoveOptimizationPhase'new-0)
                    )
            )
        )
    )
)

;;;
 ; This class represents a label within assembly code.
 ;;
(class-ns Label []
    (defn #_"Label" Label'new-0 []
        (merge (Label'class.)
            (hash-map
                #_"int" :position -1
                ;;;
                 ; References to instructions that jump to this unresolved label. These instructions need to be
                 ; patched when the label is bound using the #patchInstructions(Assembler) method.
                 ;;
                #_"ArrayList<Integer>" :patchPositions nil
            )
        )
    )

    ;;;
     ; Binds the label to the specified position.
     ;;
    (defn #_"Label" Label''bind-2 [#_"Label" this, #_"int" pos]
        (assoc this :position pos)
    )

    (defn #_"boolean" Label''isBound-1 [#_"Label" this]
        (<= 0 (:position this))
    )

    (defn #_"this" Label''addPatchAt-2 [#_"Label" this, #_"int" pos]
        (let [
            this
                (when (nil? (:patchPositions this)) => this
                    (assoc this :patchPositions (ArrayList.))
                )
        ]
            (#_"ArrayList" .add (:patchPositions this), pos)
            this
        )
    )

    (defn #_"void" Label''patchInstructions-2 [#_"Label" this, #_"Assembler" asm]
        (when (some? (:patchPositions this))
            (let [
                #_"int" target (:position this)
            ]
                (dotimes [#_"int" i (count (:patchPositions this))]
                    (Assembler''patchJumpTarget-3 asm, (nth (:patchPositions this) i), target)
                )
            )
        )
        nil
    )
)

;;;
 ; LIR instructions such as JumpOp and BranchOp need to reference their target Block. However, direct
 ; references are not possible since the control flow graph (and therefore successors lists) can be
 ; changed by optimizations - and fixing the instructions is error prone. Therefore, we represent an edge
 ; to block B from block A via the tuple {@code (A, successor-index-of-B)}. That is, indirectly by storing
 ; the index into the successor list of A. Note therefore that the successor list cannot be re-ordered.
 ;;
(class-ns LabelRef []
    ;;;
     ; Returns a new reference to a successor of the given block.
     ;
     ; @param block The base block that contains the successor list.
     ; @param suxIndex The index of the successor.
     ;;
    (defn #_"LabelRef" LabelRef'new-3 [#_"LIR" lir, #_"Block" block, #_"int" suxIndex]
        (merge (LabelRef'class.)
            (hash-map
                #_"LIR" :lir lir
                #_"Block" :block block
                #_"int" :suxIndex suxIndex
            )
        )
    )

    (defn #_"Block" LabelRef''getTargetBlock-1 [#_"LabelRef" this]
        (nth (:successors (:block this)) (:suxIndex this))
    )

    (defn #_"Label" LabelRef''label-1 [#_"LabelRef" this]
        (:label (nth (LIR''getLIRforBlock-2 (:lir this), (LabelRef''getTargetBlock-1 this)) 0))
    )
)

(class-ns LSAllocationPhase []
    (defn #_"LSAllocationPhase" LSAllocationPhase'new-0 []
        (LSAllocationPhase'class.)
    )
)

;;;
 ; Phase 7: Assign register numbers back to LIR.
 ;;
(class-ns LSAssignLocationsPhase [LSAllocationPhase]
    (defn #_"LSAssignLocationsPhase" LSAssignLocationsPhase'new-1 [#_"LinearScan" allocator]
        (merge (LSAssignLocationsPhase'class.) (LSAllocationPhase'new-0)
            (hash-map
                #_"LinearScan" :allocator allocator
            )
        )
    )

    ;;;
     ; Assigns the allocated location for an LIR instruction operand back into the instruction.
     ;
     ; @param op current LIRInstruction
     ; @param operand an LIR instruction operand
     ; @param mode the usage mode for {@code operand} by the instruction
     ; @return the location assigned for the operand
     ;;
    (defn #_"Value" LSAssignLocationsPhase''colorLirOperand-4 [#_"LSAssignLocationsPhase" this, #_"LIRInstruction" op, #_"Variable" operand, #_"OperandMode" mode]
        (let [
            #_"int" opId (:id op)
            #_"Interval" interval (LinearScan''intervalFor-2v (:allocator this), operand)
            interval
                (when-not (= opId -1) => interval
                    ;; operands are not changed when an interval is split during allocation, so search the right interval here
                    (LinearScan''splitChildAtOpId-4 (:allocator this), interval, opId, mode)
                )
        ]
            (when (and (= (:location interval) Value/ILLEGAL) (Interval''canMaterialize-1 interval)) => (:location interval)
                (ConstantValue'new-2 (:kind interval), (Interval''getMaterializedValue-1 interval))
            )
        )
    )

    ;;;
     ; Assigns the operand of an LIRInstruction.
     ;
     ; @param op The LIRInstruction that should be colored.
     ; @return true if the instruction should be deleted
     ;;
    (defn #_"boolean" LSAssignLocationsPhase''assignLocations-2i [#_"LSAssignLocationsPhase" this, #_"LIRInstruction" op]
        (or
            ;; remove useless moves
            (when (satisfies? MoveOp op)
                (let [
                    #_"AllocatableValue" result (MoveOp'''getResult-1 op)
                ]
                    (when (and (satisfies? Variable result) (LinearScan''isMaterialized-4 (:allocator this), result, (:id op), OperandMode'DEF))
                        ;; It happens when a materializable interval is originally not spilled, but kicked out in LinearScanWalker.splitForSpilling().
                        ;; When kicking out such an interval, this move operation has already been generated.
                        true
                    )
                )
            )

            (let [
                #_"LSAssignLocationsPhase" owner this
                #_"ValueProcedure" assignProc
                    (reify ValueProcedure
                        (#_"Value" ValueProcedure'''doValue-5 [#_"ValueProcedure" _this, #_"LIRInstruction" __op, #_"Value" value, #_"OperandMode" mode, #_"{OperandFlag}" _flags]
                            (when (satisfies? Variable value) => value
                                (LSAssignLocationsPhase''colorLirOperand-4 owner, __op, value, mode)
                            )
                        )
                    )
            ]
                (LIRInstruction''forEachInput-2 op, assignProc)
                (LIRInstruction''forEachAlive-2 op, assignProc)
                (LIRInstruction''forEachTemp-2 op, assignProc)
                (LIRInstruction''forEachOutput-2 op, assignProc)

                ;; remove useless moves
                (and (satisfies? ValueMoveOp op) (= (ValueMoveOp'''getInput-1 op) (MoveOp'''getResult-1 op)))
            )
        )
    )

    (defn- #_"void" LSAssignLocationsPhase''assignLocations-2l [#_"LSAssignLocationsPhase" this, #_"List<LIRInstruction>" ops]
        (let [
            #_"boolean" hasDead
                (loop-when [hasDead false #_"int" i 0] (< i (count ops)) => hasDead
                    (let [
                        #_"LIRInstruction" op (nth ops i)
                        hasDead
                            (cond
                                (nil? op)
                                (do
                                    ;; this can happen when spill-moves are removed in eliminateSpillMoves
                                    true
                                )
                                (LSAssignLocationsPhase''assignLocations-2i this, op)
                                (do
                                    (#_"ArrayList" .set ops, i, nil)
                                    true
                                )
                                :else
                                    hasDead
                            )
                    ]
                        (recur hasDead (inc i))
                    )
                )
        ]
            (when hasDead
                ;; Remove nil values from the list.
                (#_"ArrayList" .removeAll ops, (Collections/singleton nil))
            )
        )
        nil
    )

    (defm LSAssignLocationsPhase LSAllocationPhase
        (#_"void" LSAllocationPhase'''run-2 [#_"LSAssignLocationsPhase" this, #_"LIRGenerationResult" lirGenRes]
            (doseq [#_"Block" block (LinearScan''sortedBlocks-1 (:allocator this))]
                (LSAssignLocationsPhase''assignLocations-2l this, (LIR''getLIRforBlock-2 (:lir (:allocator this)), block))
            )
            nil
        )
    )
)

(class-ns LSEliminateSpillMovePhase [LSAllocationPhase]
    (def- #_"IntervalPredicate" LSEliminateSpillMovePhase'mustStoreAtDefinition
        (reify IntervalPredicate
            (#_"boolean" IntervalPredicate'''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (and (Interval''isSplitParent-1 i) (= (Interval''spillState-1 i) SpillState'StoreAtDefinition))
            )
        )
    )

    (defn #_"LSEliminateSpillMovePhase" LSEliminateSpillMovePhase'new-1 [#_"LinearScan" allocator]
        (merge (LSEliminateSpillMovePhase'class.) (LSAllocationPhase'new-0)
            (hash-map
                #_"LinearScan" :allocator allocator
            )
        )
    )

    (defm LSEliminateSpillMovePhase LSEliminateSpillMovePhase
        (#_"int" LSEliminateSpillMovePhase'''firstInstructionOfInterest-1 [#_"LSEliminateSpillMovePhase" this]
            ;; skip the first because it is always a label
            1
        )

        (#_"boolean" LSEliminateSpillMovePhase'''canEliminateSpillMove-3 [#_"LSEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move]
            (let [
                #_"Interval" interval (LinearScan''intervalFor-2v (:allocator this), (MoveOp'''getResult-1 move))
            ]
                (and (not (instance? RegisterValue (:location interval))) (Interval''alwaysInMemory-1 interval))
            )
        )
    )

    ;; Called once before assignment of register numbers.
    (defn #_"void" LSEliminateSpillMovePhase''eliminateSpillMoves-2 [#_"LSEliminateSpillMovePhase" this, #_"LIRGenerationResult" res]
        ;; Collect all intervals that must be stored after their definition. The list is sorted by Interval.spillDefinitionPos.
        (let [
            #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer'new-0)
        ]
            (loop-when [#_"Interval" interval (#_"Pair" .getLeft (LinearScan''createUnhandledLists-3 (:allocator this), LSEliminateSpillMovePhase'mustStoreAtDefinition, nil)) #_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))] (some? s)
                (let [
                    #_"Block" block (first s)
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                    ;; Iterate all instructions of the block.
                    interval
                        (loop-when [interval interval #_"int" i (LSEliminateSpillMovePhase'''firstInstructionOfInterest-1 this)] (< i (count ops)) => interval
                            (let [
                                #_"LIRInstruction" op (nth ops i)
                                #_"int" opId (:id op)
                                interval
                                    (if (= opId -1)
                                        (do
                                            ;; Remove move from register to stack if the stack slot is guaranteed to be correct.
                                            ;; Only moves that have been inserted by LinearScan can be removed.
                                            (when (and GraalOptions'lirOptLSRAEliminateSpillMoves (LSEliminateSpillMovePhase'''canEliminateSpillMove-3 this, block, op))
                                                ;; Move target is a stack slot that is always correct, so eliminate instruction.
                                                ;; nil-instructions are deleted by assignRegNum
                                                (#_"ArrayList" .set ops, i, nil)
                                            )
                                            interval
                                        )
                                        ;; Insert move from register to stack just after the beginning of the interval.
                                        (loop-when interval (and (not (Interval''isEndMarker-1 interval)) (= (Interval''spillDefinitionPos-1 interval) opId)) => interval
                                            (when-not (Interval''canMaterialize-1 interval)
                                                (when-not (LIRInsertionBuffer''initialized-1 buffer)
                                                    ;; prepare insertion buffer (appended when all instructions in the block are processed)
                                                    (ยง ass! buffer (LIRInsertionBuffer''init-2 buffer, ops))
                                                )
                                                (let [
                                                    #_"AllocatableValue" fromLocation (:location interval)
                                                    #_"AllocatableValue" toLocation (LinearScan'canonicalSpillOpr-1 interval)
                                                ]
                                                    (when-not (= fromLocation toLocation)
                                                        (ยง ass! buffer (LIRInsertionBuffer''append-3 buffer, (inc i), (MoveFactory'createMove-2 toLocation, fromLocation)))
                                                    )
                                                )
                                            )
                                            (recur (:next interval))
                                        )
                                    )
                            ]
                                (recur interval (inc i))
                            )
                        )
                ]
                    (when (LIRInsertionBuffer''initialized-1 buffer)
                        (ยง ass! buffer (LIRInsertionBuffer''finish-1 buffer))
                    )
                    (recur interval (next s))
                )
            )
        )
        nil
    )

    (defm LSEliminateSpillMovePhase LSAllocationPhase
        (#_"void" LSAllocationPhase'''run-2 [#_"LSEliminateSpillMovePhase" this, #_"LIRGenerationResult" lirGenRes]
            (LSEliminateSpillMovePhase''eliminateSpillMoves-2 this, lirGenRes)
            nil
        )
    )
)

(class-ns SSALinearScanEliminateSpillMovePhase [LSEliminateSpillMovePhase, LSAllocationPhase]
    (defn #_"SSALinearScanEliminateSpillMovePhase" SSALinearScanEliminateSpillMovePhase'new-1 [#_"LinearScan" allocator]
        (merge (SSALinearScanEliminateSpillMovePhase'class.) (LSEliminateSpillMovePhase'new-1 allocator))
    )

    (defn- #_"boolean" SSALinearScanEliminateSpillMovePhase''isPhiResolutionMove-4 [#_"SSALinearScanEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move, #_"Interval" to]
        (and (Interval''isSplitParent-1 to)
             (zero? (& (Interval''from-1 to) 1))
             (= (count (:successors block)) 1)
             (satisfies? LabelOp (LinearScan''instructionForId-2 (:allocator this), (Interval''from-1 to)))
             (= (nth (:successors block) 0) (LinearScan''blockForId-2 (:allocator this), (Interval''from-1 to)))
        )
    )

    (defm SSALinearScanEliminateSpillMovePhase LSEliminateSpillMovePhase
        (#_"int" LSEliminateSpillMovePhase'''firstInstructionOfInterest-1 [#_"SSALinearScanEliminateSpillMovePhase" this]
            ;; also look at Labels as they define PHI values
            0
        )

        (#_"boolean" LSEliminateSpillMovePhase'''canEliminateSpillMove-3 [#_"SSALinearScanEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move]
            (and (LSEliminateSpillMovePhase'''canEliminateSpillMove-3 (ยง super LSEliminateSpillMovePhase'iface), block, move)
                ;; SSA Linear Scan might introduce moves to stack slots
                (not (SSALinearScanEliminateSpillMovePhase''isPhiResolutionMove-4 this, block, move, (LinearScan''intervalFor-2v (:allocator this), (MoveOp'''getResult-1 move))))
            )
        )
    )
)

(class-ns LSLifetimeAnalysisPhase [LSAllocationPhase]
    (defn #_"LSLifetimeAnalysisPhase" LSLifetimeAnalysisPhase'new-1 [#_"LinearScan" linearScan]
        (merge (LSLifetimeAnalysisPhase'class.) (LSAllocationPhase'new-0)
            (hash-map
                #_"LinearScan" :allocator linearScan
                ;;;
                 ; Bit set for each variable that is contained in each loop.
                 ;;
                #_"BitMap2D" :intervalInLoop nil
            )
        )
    )

    (defn #_"boolean" LSLifetimeAnalysisPhase''isIntervalInLoop-3 [#_"LSLifetimeAnalysisPhase" this, #_"int" interval, #_"int" _loop]
        (BitMap2D''at-3 (:intervalInLoop this), interval, _loop)
    )

    ;;;
     ; Numbers all instructions in all blocks. The numbering follows the linear scan order.
     ;;
    (defn #_"void" LSLifetimeAnalysisPhase''numberInstructions-1 [#_"LSLifetimeAnalysisPhase" this]
        (let [
            _ (ยง ass! (:allocator this) (LinearScan''initIntervals-1 (:allocator this)))
            #_"LSLifetimeAnalysisPhase" owner this
            #_"ValueConsumer" setVariableConsumer
                (reify ValueConsumer
                    (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" _op, #_"Value" value, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                        (when (satisfies? Variable value)
                            (LinearScan'''getOrCreateInterval-2 (:allocator owner), value)
                        )
                    )
                )
            ;; Assign IDs to LIR nodes and build a mapping, lirOps, from ID to LIRInstruction node.
            #_"int" n
                (loop-when-recur [n 0 #_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))]
                                 (some? s)
                                 [(+ n (count (LIR''getLIRforBlock-2 (:lir (:allocator this)), (first s)))) (next s)]
                              => n
                )
            ;; initialize with correct length
            _ (ยง ass! (:allocator this) (LinearScan''initOpIdMaps-2 (:allocator this), n))
        ]
            (loop-when [#_"int" opId 0 #_"int" index 0 #_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))] (some? s)
                (let [
                    #_"Block" block (first s)
                ]
                    (LinearScan'''initBlockData-2 (:allocator this), block)

                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                        [opId index]
                            (loop-when [opId opId index index #_"int" i 0] (< i (count ops)) => [opId index]
                                (let [
                                    #_"LIRInstruction" op (nth ops i)
                                ]
                                    (ยง ass! op (LIRInstruction''setId-2 op, opId))

                                    (LinearScan''putOpIdMaps-4 (:allocator this), index, op, block)

                                    (LIRInstruction''visitEachTemp-2 op, setVariableConsumer)
                                    (LIRInstruction''visitEachOutput-2 op, setVariableConsumer)

                                    ;; numbering of lirOps by two
                                    (recur (+ opId 2) (inc index) (inc i))
                                )
                            )
                    ]
                        (recur opId index (next s))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Creates a trimmed copy a bit set.
     ;
     ; BitSet#clone() cannot be used since it will not {@linkplain BitSet#trimToSize trim}
     ; the array if the bit set is {@linkplain BitSet#sizeIsSticky sticky}.
     ;;
    (defn- #_"BitSet" LSLifetimeAnalysisPhase'trimClone-1 [#_"BitSet" bits]
        (let [
            #_"BitSet" trimmed (BitSet. 0) ;; zero-length words array, sticky
        ]
            (#_"BitSet" .or trimmed, bits) ;; words size ensured to be words-in-use of set, also makes it non-sticky
            trimmed
        )
    )

    ;;;
     ; Computes local live sets (i.e. BlockData#liveGen and BlockData#liveKill) separately for each block.
     ;;
    (defn #_"this" LSLifetimeAnalysisPhase''computeLocalLiveSets-1 [#_"LSLifetimeAnalysisPhase" this]
        (let [
            this (assoc this :intervalInLoop (BitMap2D'new-2 (LinearScan''operandSize-1 (:allocator this)), (LinearScan''numLoops-1 (:allocator this))))
        ]
            ;; iterate all blocks
            (loop-when-recur [#_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))] (some? s) [(next s)]
                (let [
                    #_"Block" block (first s)
                    #_"BitSet" liveGenScratch (BitSet.)
                    #_"BitSet" liveKillScratch (BitSet.)
                    #_"LSLifetimeAnalysisPhase" owner this
                    #_"ValueConsumer" useConsumer
                        (reify ValueConsumer
                            (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" _op, #_"Value" operand, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                                (when (satisfies? Variable operand)
                                    (let [
                                        #_"int" operandNum (LinearScan''operandNumber-2 (:allocator owner), operand)
                                    ]
                                        (when-not (nth liveKillScratch operandNum)
                                            (#_"BitSet" .set liveGenScratch, operandNum)
                                        )
                                        (when (some? (:loop block))
                                            (BitMap2D''setBit-3 (:intervalInLoop owner), operandNum, (:index (:loop block)))
                                        )
                                    )
                                )
                            )
                        )
                    #_"ValueConsumer" defConsumer
                        (reify ValueConsumer
                            (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" _op, #_"Value" operand, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                                (when (satisfies? Variable operand)
                                    (let [
                                        #_"int" varNum (LinearScan''operandNumber-2 (:allocator owner), operand)
                                    ]
                                        (#_"BitSet" .set liveKillScratch, varNum)
                                        (when (some? (:loop block))
                                            (BitMap2D''setBit-3 (:intervalInLoop owner), varNum, (:index (:loop block)))
                                        )
                                    )
                                )
                            )
                        )
                ]
                    ;; iterate all instructions of the block
                    (doseq [#_"LIRInstruction" op (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)]
                        (LIRInstruction''visitEachInput-2 op, useConsumer)
                        (LIRInstruction''visitEachAlive-2 op, useConsumer)

                        (LIRInstruction''visitEachTemp-2 op, defConsumer)
                        (LIRInstruction''visitEachOutput-2 op, defConsumer)
                    )

                    (let [
                        #_"BlockData" blockSets (LinearScan''getBlockData-2 (:allocator this), block)
                    ]
                        (ยง ass! blockSets (assoc blockSets :liveGen (LSLifetimeAnalysisPhase'trimClone-1 liveGenScratch)))
                        (ยง ass! blockSets (assoc blockSets :liveKill (LSLifetimeAnalysisPhase'trimClone-1 liveKillScratch)))
                        ;; sticky size, will get non-sticky in computeGlobalLiveSets
                        (ยง ass! blockSets (assoc blockSets :liveIn (BitSet. 0)))
                        (ยง ass! blockSets (assoc blockSets :liveOut (BitSet. 0)))
                    )
                )
            )
            this
        )
    )

    ;;;
     ; Performs a backward dataflow analysis to compute global live sets (i.e. BlockData#liveIn and BlockData#liveOut) for each block.
     ;;
    (defn #_"void" LSLifetimeAnalysisPhase''computeGlobalLiveSets-1 [#_"LSLifetimeAnalysisPhase" this]
        (let [
            #_"int" numBlocks (LinearScan''blockCount-1 (:allocator this))
            #_"BitSet" scratch (BitSet.) ;; scratch set for calculations
        ]
            ;; Perform a backward dataflow analysis to compute liveOut and liveIn for each block.
            ;; The loop is executed until a fixpoint is reached (no changes in an iteration).
            (loop [#_"int" iteration 0]
                (let [
                    ;; iterate all blocks in reverse order
                    #_"boolean" changed?
                        (loop-when [changed? false #_"int" i (dec numBlocks)] (<= 0 i) => changed?
                            (let [
                                #_"Block" block (LinearScan''blockAt-2 (:allocator this), i)
                                #_"BlockData" blockSets (LinearScan''getBlockData-2 (:allocator this), block)
                                [#_"boolean" blockChanged changed?]
                                    (when (pos? (count (:successors block))) => [false changed?]
                                        (#_"BitSet" .clear scratch)
                                        (doseq [#_"Block" successor (:successors block)]
                                            (#_"BitSet" .or scratch, (:liveIn (LinearScan''getBlockData-2 (:allocator this), successor)))
                                        )
                                        ;; liveOut(block) is the union of liveIn(sux), for successors sux of block
                                        (when-not (= (:liveOut blockSets) scratch) => [false changed?]
                                            (ยง ass! blockSets (assoc blockSets :liveOut (LSLifetimeAnalysisPhase'trimClone-1 scratch)))
                                            [true true]
                                        )
                                    )
                            ]
                                (when (or (zero? iteration) blockChanged)
                                    ;; liveIn(block) is the union of liveGen(block) with (liveOut(block) & !liveKill(block))
                                    ;;
                                    ;; Note: liveIn has to be computed only in first iteration or if liveOut has changed!
                                    ;; Note: liveIn set can only grow, never shrink. No need to clear it.
                                    (let [
                                        #_"BitSet" liveIn (:liveIn blockSets)
                                    ]
                                        ;; BitSet#or will call BitSet#ensureSize (since the bit set is of length 0 initially)
                                        ;; and set sticky to false
                                        (#_"BitSet" .or liveIn, (:liveOut blockSets))
                                        (#_"BitSet" .andNot liveIn, (:liveKill blockSets))
                                        (#_"BitSet" .or liveIn, (:liveGen blockSets))

                                        (#_"Object" .clone liveIn) ;; trimToSize()
                                    )
                                )
                                (recur changed? (dec i))
                            )
                        )
                ]
                    (when (and changed? (<= 50 iteration))
                        ;; Very unlikely, should never happen, though when happens, we cannot guarantee it won't happen again.
                        (throw! "too many iterations in computeGlobalLiveSets")
                    )
                    (recur-if changed? [(inc iteration)])
                )
            )

            ;; check that the liveIn set of the first block is empty
            (let [
                #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg (:lir (:allocator this))))
            ]
                (when-not (zero? (#_"BitSet" .cardinality (:liveIn (LinearScan''getBlockData-2 (:allocator this), startBlock))))
                    ;; bailout if this occurs in product mode.
                    (throw! (str "liveIn set of first block must be empty: " (:liveIn (LinearScan''getBlockData-2 (:allocator this), startBlock))))
                )
            )
        )
        nil
    )

    (defn- #_"void" LSLifetimeAnalysisPhase''addUse-6 [#_"LSLifetimeAnalysisPhase" this, #_"AllocatableValue" operand, #_"int" from, #_"int" to, #_"RegisterPriority" registerPriority, #_"ValueKind" kind]
        (when (LinearScan''isProcessed-2 (:allocator this), operand)
            (let [
                #_"Interval" interval (LinearScan'''getOrCreateInterval-2 (:allocator this), operand)
            ]
                (when-not (= kind LIRKind'Illegal)
                    (ยง ass! interval (Interval''setKind-2 interval, kind))
                )
                (ยง ass! interval (Interval''addRange-3 interval, from, to))
                ;; Register use position at even instruction id.
                (Interval''addUsePos-3 interval, (& to (bit-not 1)), registerPriority)
            )
        )
        nil
    )

    (defn #_"void" LSLifetimeAnalysisPhase''addTemp-5 [#_"LSLifetimeAnalysisPhase" this, #_"AllocatableValue" operand, #_"int" tempPos, #_"RegisterPriority" registerPriority, #_"ValueKind" kind]
        (when (LinearScan''isProcessed-2 (:allocator this), operand)
            (let [
                #_"Interval" interval (LinearScan'''getOrCreateInterval-2 (:allocator this), operand)
            ]
                (when-not (= kind LIRKind'Illegal)
                    (ยง ass! interval (Interval''setKind-2 interval, kind))
                )
                (ยง ass! interval (Interval''addRange-3 interval, tempPos, (inc tempPos)))
                (Interval''addUsePos-3 interval, tempPos, registerPriority)
                (ยง ass! interval (Interval''addMaterializationValue-2 interval, nil))
            )
        )
        nil
    )

    ;;;
     ; Returns a value for a interval definition, which can be used for re-materialization.
     ;
     ; @param op An instruction which defines a value.
     ; @param operand The destination operand of the instruction.
     ; @param interval The interval for this defined value.
     ; @return the value which is moved to the instruction and which can be reused at all
     ;         reload-locations in case the interval of this instruction is spilled.
     ;         Currently this can only be a JavaConstant.
     ;;
    (defn- #_"Constant" LSLifetimeAnalysisPhase'getMaterializedValue-3 [#_"LIRInstruction" op, #_"Value" operand, #_"Interval" interval]
        (when (satisfies? LoadConstantOp op)
            ;; Check if the interval has any uses which would accept an stack location (priority == ShouldHaveRegister).
            ;; Rematerialization of such intervals can result in a degradation, because rematerialization always inserts
            ;; a constant load, even if the value is not needed in a register.
            (loop-when [#_"int" i 0] (< i (UsePosList''size-1 (:usePosList interval))) => (LoadConstantOp'''getConstant-1 op)
                (when-not (= (UsePosList''registerPriority-2 (:usePosList interval), i) RegisterPriority'ShouldHaveRegister)
                    (recur (inc i))
                )
            )
        )
    )

    ;;;
     ; Eliminates moves from register to stack if the stack slot is known to be correct.
     ;;
    (defn #_"void" LSLifetimeAnalysisPhase''changeSpillDefinitionPos-5 [#_"LSLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"AllocatableValue" operand, #_"Interval" interval, #_"int" defPos]
        (condp = (Interval''spillState-1 interval)
            SpillState'NoDefinitionFound
                (do
                    (Interval''setSpillDefinitionPos-2 interval, defPos)
                    (Interval''setSpillState-2 interval, SpillState'NoSpillStore)
                )
            SpillState'NoSpillStore
                (when (< defPos (- (Interval''spillDefinitionPos-1 interval) 2))
                    ;; second definition found, so no spill optimization possible for this interval
                    (Interval''setSpillState-2 interval, SpillState'NoOptimization)
                    ;; else: two consecutive definitions (because of two-operand LIR form)
                )
            nil
        )
        nil
    )

    (defn- #_"void" LSLifetimeAnalysisPhase''addDef-5 [#_"LSLifetimeAnalysisPhase" this, #_"AllocatableValue" operand, #_"LIRInstruction" op, #_"RegisterPriority" registerPriority, #_"ValueKind" kind]
        (when (LinearScan''isProcessed-2 (:allocator this), operand)
            (let [
                #_"int" defPos (:id op)
                #_"Interval" interval (LinearScan'''getOrCreateInterval-2 (:allocator this), operand)
            ]
                (when-not (= kind LIRKind'Illegal)
                    (ยง ass! interval (Interval''setKind-2 interval, kind))
                )
                (let [
                    #_"Range" r (:first interval)
                ]
                    (if (<= (:from r) defPos)
                        (do
                            ;; Update the starting point (when a range is first created for a use, its start is the
                            ;; beginning of the current block until a def is encountered).
                            (ยง ass r (assoc r :from defPos))
                            (Interval''addUsePos-3 interval, defPos, registerPriority)
                        )
                        (do
                            ;; dead value - make vacuous interval also add register priority for dead intervals
                            (ยง ass! interval (Interval''addRange-3 interval, defPos, (inc defPos)))
                            (Interval''addUsePos-3 interval, defPos, registerPriority)
                        )
                    )

                    (LSLifetimeAnalysisPhase''changeSpillDefinitionPos-5 this, op, operand, interval, defPos)
                    (when (and (= registerPriority RegisterPriority'None) (<= (SpillState''ordinal-1 (Interval''spillState-1 interval)) (SpillState''ordinal-1 SpillState'StartInMemory)) (instance? StackSlot operand))
                        ;; detection of method-parameters and roundfp-results
                        (Interval''setSpillState-2 interval, SpillState'StartInMemory)
                    )
                    (ยง ass! interval (Interval''addMaterializationValue-2 interval, (LSLifetimeAnalysisPhase'getMaterializedValue-3 op, operand, interval)))
                )
            )
        )
        nil
    )

    (defm LSLifetimeAnalysisPhase LSLifetimeAnalysisPhase
        (#_"void" LSLifetimeAnalysisPhase'''addRegisterHint-6 [#_"LSLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"Value" targetValue, #_"OperandMode" mode, #_"{OperandFlag}" flags, #_"boolean" hintAtDef]
            (when (and (contains? flags OperandFlag'HINT) (LinearScan'isVariableOrRegister-1 targetValue))
                (let [
                    #_"LSLifetimeAnalysisPhase" owner this
                ]
                    (LIRInstruction''forEachRegisterHint-4 op, targetValue, mode,
                        (reify ValueProcedure
                            (#_"Value" ValueProcedure'''doValue-5 [#_"ValueProcedure" _this, #_"LIRInstruction" _op, #_"Value" registerHint, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                                (when (LinearScan'isVariableOrRegister-1 registerHint)
                                    (let [
                                        #_"Interval" from (LinearScan'''getOrCreateInterval-2 (:allocator owner), registerHint)
                                        #_"Interval" to (LinearScan'''getOrCreateInterval-2 (:allocator owner), targetValue)
                                    ]
                                        ;; hints always point from def to use
                                        (if hintAtDef
                                            (ยง ass! to (Interval''setLocationHint-2 to, from))
                                            (ยง ass! from (Interval''setLocationHint-2 from, to))
                                        )
                                        registerHint
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"boolean" LSLifetimeAnalysisPhase'optimizeMethodArgument-1 [#_"Value" value]
        ;; Object method arguments that are passed on the stack are currently not optimized because
        ;; this requires that the runtime visits method arguments during stack walking.
        (and (instance? StackSlot value) (#_"StackSlot" .isInCallerFrame value) (LIRKind'isValue-1v value))
    )

    (defm LSLifetimeAnalysisPhase LSLifetimeAnalysisPhase
        (#_"RegisterPriority" LSLifetimeAnalysisPhase'''registerPriorityOfOutputOperand-2 [#_"LSLifetimeAnalysisPhase" this, #_"LIRInstruction" op]
            (if (and (satisfies? ValueMoveOp op) (LSLifetimeAnalysisPhase'optimizeMethodArgument-1 (ValueMoveOp'''getInput-1 op)))
                RegisterPriority'None
                ;; all other operands require a register
                RegisterPriority'MustHaveRegister
            )
        )
    )

    ;;;
     ; Determines the priority which with an instruction's input operand will be allocated a register.
     ;;
    (defn #_"RegisterPriority" LSLifetimeAnalysisPhase'registerPriorityOfInputOperand-1 [#_"EnumSet<OperandFlag>" flags]
        (if (contains? flags OperandFlag'STACK)
            RegisterPriority'ShouldHaveRegister
            ;; all other operands require a register
            RegisterPriority'MustHaveRegister
        )
    )

    ;;;
     ; Optimizes moves related to incoming stack based arguments. The interval for the destination
     ; of such moves is assigned the stack slot (which is in the caller's frame) as its spill slot.
     ;;
    (defn #_"void" LSLifetimeAnalysisPhase''handleMethodArguments-2 [#_"LSLifetimeAnalysisPhase" this, #_"LIRInstruction" op]
        (when (and (satisfies? ValueMoveOp op) (LSLifetimeAnalysisPhase'optimizeMethodArgument-1 (ValueMoveOp'''getInput-1 op)))
            (let [
                #_"StackSlot" slot (ValueMoveOp'''getInput-1 op)
                #_"Interval" interval (LinearScan''intervalFor-2v (:allocator this), (MoveOp'''getResult-1 op))
            ]
                (Interval''setSpillSlot-2 interval, slot)
                (ยง ass! interval (Interval''assignLocation-2 interval, slot))
            )
        )
        nil
    )

    (defm LSLifetimeAnalysisPhase LSLifetimeAnalysisPhase
        (#_"void" LSLifetimeAnalysisPhase'''buildIntervals-1 [#_"LSLifetimeAnalysisPhase" this]
            (let [
                #_"LSLifetimeAnalysisPhase" owner this
                #_"ValueConsumer" outputConsumer
                    (reify ValueConsumer
                        (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" op, #_"Value" operand, #_"OperandMode" mode, #_"{OperandFlag}" flags]
                            (when (LinearScan'isVariableOrRegister-1 operand)
                                (LSLifetimeAnalysisPhase''addDef-5 owner, operand, op, (LSLifetimeAnalysisPhase'''registerPriorityOfOutputOperand-2 owner, op), (#_"Value" .getValueKind operand))
                                (LSLifetimeAnalysisPhase'''addRegisterHint-6 owner, op, operand, mode, flags, true)
                            )
                        )
                    )
                #_"ValueConsumer" tempConsumer
                    (reify ValueConsumer
                        (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" op, #_"Value" operand, #_"OperandMode" mode, #_"{OperandFlag}" flags]
                            (when (LinearScan'isVariableOrRegister-1 operand)
                                (LSLifetimeAnalysisPhase''addTemp-5 owner, operand, (:id op), RegisterPriority'MustHaveRegister, (#_"Value" .getValueKind operand))
                                (LSLifetimeAnalysisPhase'''addRegisterHint-6 owner, op, operand, mode, flags, false)
                            )
                        )
                    )
                #_"ValueConsumer" aliveConsumer
                    (reify ValueConsumer
                        (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" op, #_"Value" operand, #_"OperandMode" mode, #_"{OperandFlag}" flags]
                            (when (LinearScan'isVariableOrRegister-1 operand)
                                (let [
                                    #_"RegisterPriority" p (LSLifetimeAnalysisPhase'registerPriorityOfInputOperand-1 flags)
                                    #_"int" opId (:id op)
                                    #_"int" blockFrom (LinearScan''getFirstLirInstructionId-2 (:allocator owner), (LinearScan''blockForId-2 (:allocator owner), opId))
                                ]
                                    (LSLifetimeAnalysisPhase''addUse-6 owner, operand, blockFrom, (inc opId), p, (#_"Value" .getValueKind operand))
                                    (LSLifetimeAnalysisPhase'''addRegisterHint-6 owner, op, operand, mode, flags, false)
                                )
                            )
                        )
                    )
                #_"ValueConsumer" inputConsumer
                    (reify ValueConsumer
                        (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" op, #_"Value" operand, #_"OperandMode" mode, #_"{OperandFlag}" flags]
                            (when (LinearScan'isVariableOrRegister-1 operand)
                                (let [
                                    #_"int" opId (:id op)
                                    #_"int" blockFrom (LinearScan''getFirstLirInstructionId-2 (:allocator owner), (LinearScan''blockForId-2 (:allocator owner), opId))
                                    #_"RegisterPriority" p (LSLifetimeAnalysisPhase'registerPriorityOfInputOperand-1 flags)
                                ]
                                    (LSLifetimeAnalysisPhase''addUse-6 owner, operand, blockFrom, opId, p, (#_"Value" .getValueKind operand))
                                    (LSLifetimeAnalysisPhase'''addRegisterHint-6 owner, op, operand, mode, flags, false)
                                )
                            )
                        )
                    )
                ;; create a list with all caller-save registers
                #_"RegisterArray" callerSaveRegs (#_"RegisterConfig" .getCallerSaveRegisters HotSpot'registerConfig)
            ]
                ;; iterate all blocks in reverse order
                (loop-when-recur [#_"int" i (dec (LinearScan''blockCount-1 (:allocator this)))] (<= 0 i) [(dec i)]
                    (let [
                        #_"Block" block (LinearScan''blockAt-2 (:allocator this), i)
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                        #_"int" blockFrom (LinearScan''getFirstLirInstructionId-2 (:allocator this), block)
                        #_"int" blockTo (LinearScan''getLastLirInstructionId-2 (:allocator this), block)
                        ;; update intervals for operands live at the end of this block
                        #_"BitSet" live (:liveOut (LinearScan''getBlockData-2 (:allocator this), block))
                    ]
                        (loop-when-recur [#_"int" operandNum (#_"BitSet" .nextSetBit live, 0)] (<= 0 operandNum) [(#_"BitSet" .nextSetBit live, (inc operandNum))]
                            (let [
                                #_"AllocatableValue" operand (:operand (LinearScan''intervalFor-2i (:allocator this), operandNum))
                            ]
                                (LSLifetimeAnalysisPhase''addUse-6 this, operand, blockFrom, (+ blockTo 2), RegisterPriority'None, LIRKind'Illegal)

                                ;; Add special use positions for loop-end blocks when the interval is used anywhere inside this loop.
                                ;; It's possible that the block was part of a non-natural loop, so it might have an invalid loop index.
                                (when (and (Block''isLoopEnd-1 block) (some? (:loop block)) (LSLifetimeAnalysisPhase''isIntervalInLoop-3 this, operandNum, (:index (:loop block))))
                                    (Interval''addUsePos-3 (LinearScan''intervalFor-2i (:allocator this), operandNum), (inc blockTo), RegisterPriority'LiveAtLoopEnd)
                                )
                            )
                        )

                        ;; Iterate all instructions of the block in reverse order. Definitions of intervals are processed before uses.
                        (loop-when-recur [#_"int" j (dec (count ops))] (<= 0 j) [(dec j)]
                            (let [
                                #_"LIRInstruction" op (nth ops j)
                                #_"int" opId (:id op)
                            ]
                                ;; Add a temp range for each register if operation destroys caller-save registers.
                                (when (LIRInstruction'''destroysCallerSavedRegisters-1 op)
                                    (doseq [#_"Register" r callerSaveRegs]
                                        (when (#_"RegisterAttributes" .isAllocatable (LinearScan''attributes-2 (:allocator this), r))
                                            (LSLifetimeAnalysisPhase''addTemp-5 this, (#_"Register" .asValue r), opId, RegisterPriority'None, LIRKind'Illegal)
                                        )
                                    )
                                )

                                (LIRInstruction''visitEachOutput-2 op, outputConsumer)
                                (LIRInstruction''visitEachTemp-2 op, tempConsumer)
                                (LIRInstruction''visitEachAlive-2 op, aliveConsumer)
                                (LIRInstruction''visitEachInput-2 op, inputConsumer)

                                ;; special steps for some instructions (especially moves)
                                (LSLifetimeAnalysisPhase''handleMethodArguments-2 this, op)
                            )
                        )
                    )
                )

                ;; Add the range [0, 1] to all fixed intervals. The register allocator need not handle unhandled fixed intervals.
                (doseq [#_"Interval" interval (:intervals (:allocator this))]
                    (when (and (some? interval) (instance? RegisterValue (:operand interval)))
                        (ยง ass! interval (Interval''addRange-3 interval, 0, 1))
                    )
                )
            )
            nil
        )
    )

    (defm LSLifetimeAnalysisPhase LSAllocationPhase
        (#_"void" LSAllocationPhase'''run-2 [#_"LSLifetimeAnalysisPhase" this, #_"LIRGenerationResult" lirGenRes]
            (LSLifetimeAnalysisPhase''numberInstructions-1 this)
            (ยง ass! this (LSLifetimeAnalysisPhase''computeLocalLiveSets-1 this))
            (LSLifetimeAnalysisPhase''computeGlobalLiveSets-1 this)
            (LSLifetimeAnalysisPhase'''buildIntervals-1 this)
            nil
        )
    )
)

(class-ns SSALinearScanLifetimeAnalysisPhase [LSLifetimeAnalysisPhase, LSAllocationPhase]
    (defn #_"SSALinearScanLifetimeAnalysisPhase" SSALinearScanLifetimeAnalysisPhase'new-1 [#_"LinearScan" linearScan]
        (merge (SSALinearScanLifetimeAnalysisPhase'class.) (LSLifetimeAnalysisPhase'new-1 linearScan))
    )

    (defm SSALinearScanLifetimeAnalysisPhase LSLifetimeAnalysisPhase
        (#_"void" LSLifetimeAnalysisPhase'''addRegisterHint-6 [#_"SSALinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"Value" targetValue, #_"OperandMode" mode, #_"{OperandFlag}" flags, #_"boolean" hintAtDef]
            (LSLifetimeAnalysisPhase'''addRegisterHint-6 (ยง super LSLifetimeAnalysisPhase'iface), op, targetValue, mode, flags, hintAtDef)

            (when (and hintAtDef (satisfies? LabelOp op))
                (let [
                    #_"Interval" to (LinearScan'''getOrCreateInterval-2 (:allocator this), targetValue)
                    #_"SSALinearScanLifetimeAnalysisPhase" owner this
                ]
                    (SSAUtil'forEachPhiRegisterHint-6 (:lir (:allocator this)), (LinearScan''blockForId-2 (:allocator this), (:id op)), op, targetValue, mode,
                        (reify ValueConsumer
                            (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" _op, #_"Value" registerHint, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                                (when (LinearScan'isVariableOrRegister-1 registerHint)
                                    (let [
                                        #_"Interval" from (LinearScan'''getOrCreateInterval-2 (:allocator owner), registerHint)
                                    ]
                                        (SSALinearScanLifetimeAnalysisPhase'setHint-3 op, to, from)
                                        (SSALinearScanLifetimeAnalysisPhase'setHint-3 op, from, to)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn #_"void" SSALinearScanLifetimeAnalysisPhase'setHint-3 [#_"LIRInstruction" op, #_"Interval" target, #_"Interval" source]
        (let [
            #_"Interval" hint (Interval''locationHint-2 target, false)
        ]
            (when (or (nil? hint) (< (Interval''from-1 target) (Interval''from-1 hint)))
                ;; Update hint if there was none or if the hint interval starts after the hinted interval.
                (ยง ass! target (Interval''setLocationHint-2 target, source))
            )
        )
        nil
    )

    (defm SSALinearScanLifetimeAnalysisPhase LSLifetimeAnalysisPhase
        (#_"RegisterPriority" LSLifetimeAnalysisPhase'''registerPriorityOfOutputOperand-2 [#_"SSALinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op]
            (when-not (and (satisfies? LabelOp op) (LabelOp''isPhiIn-1 op)) => RegisterPriority'None
                (LSLifetimeAnalysisPhase'''registerPriorityOfOutputOperand-2 (ยง super LSLifetimeAnalysisPhase'iface), op)
            )
        )
    )
)

(class-ns LSOptimizeSpillPositionPhase [LSAllocationPhase]
    (defn #_"LSOptimizeSpillPositionPhase" LSOptimizeSpillPositionPhase'new-1 [#_"LinearScan" allocator]
        (merge (LSOptimizeSpillPositionPhase'class.) (LSAllocationPhase'new-0)
            (hash-map
                #_"LinearScan" :allocator allocator
            )
        )
    )

    (defn- #_"Iterable<Block>" LSOptimizeSpillPositionPhase''blocksForInterval-2 [#_"LSOptimizeSpillPositionPhase" this, #_"Interval" interval]
        (let [
            #_"LSOptimizeSpillPositionPhase" owner this
        ]
            (reify Iterable #_"<Block>"
                (#_"Iterator<Block>" iterator [#_"Iterable<Block>" this]
                    (IntervalBlockIterator'new-2 (:allocator owner), interval)
                )
            )
        )
    )

    (defn- #_"Block" LSOptimizeSpillPositionPhase'moveSpillOutOfLoop-2 [#_"Block" defBlock, #_"Block" spillBlock]
        (let [
            #_"int" defLoopDepth (Block''getLoopDepth-1 defBlock)
        ]
            (loop-when-recur [#_"Block" block (:dominator spillBlock)]
                             (and (not (= block defBlock)) (not (<= (Block''getLoopDepth-1 block) defLoopDepth)))
                             [(:dominator block)]
                          => block
            )
        )
    )

    (defn- #_"void" LSOptimizeSpillPositionPhase''optimizeInterval-4 [#_"LSOptimizeSpillPositionPhase" this, #_"LIRInsertionBuffer[]" insertionBuffers, #_"Interval" interval, #_"LIRGenerationResult" res]
        (when (and (some? interval) (Interval''isSplitParent-1 interval) (= (Interval''spillState-1 interval) SpillState'SpillInDominator))
            (let [
                #_"Block" defBlock (LinearScan''blockForId-2 (:allocator this), (Interval''spillDefinitionPos-1 interval))
                [#_"Block" spillBlock #_"Interval" firstSpillChild]
                    (loop-when [spillBlock nil firstSpillChild nil #_"ISeq" s (seq (Interval''getSplitChildren-1 interval))] (some? s) => [spillBlock firstSpillChild]
                        (let [
                            #_"Interval" splitChild (first s)
                            [spillBlock firstSpillChild]
                                (when (LIRValueUtil'isStackSlotValue-1 (:location splitChild)) => [spillBlock firstSpillChild]
                                    (let [
                                        firstSpillChild
                                            (when (or (nil? firstSpillChild) (< (Interval''from-1 splitChild) (Interval''from-1 firstSpillChild))) => firstSpillChild
                                                splitChild
                                            )
                                        ;; iterate all blocks where the interval has use positions
                                        spillBlock
                                            (loop-when [spillBlock spillBlock #_"ISeq" s (seq (LSOptimizeSpillPositionPhase''blocksForInterval-2 this, splitChild))] (some? s) => spillBlock
                                                (let [
                                                    #_"Block" splitBlock (first s)
                                                    spillBlock
                                                        (when (ControlFlowGraph'dominates-2 defBlock, splitBlock) => spillBlock
                                                            (if (some? spillBlock) (ControlFlowGraph'commonDominator-2 spillBlock, splitBlock) splitBlock)
                                                        )
                                                ]
                                                    (recur spillBlock (next s))
                                                )
                                            )
                                    ]
                                        [spillBlock firstSpillChild]
                                    )
                                )
                        ]
                            (recur spillBlock firstSpillChild (next s))
                        )
                    )
            ]
                (when (some? spillBlock) => (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition) ;; no spill interval
                    ;; move out of loops
                    (let [
                        spillBlock
                            (when (< (Block''getLoopDepth-1 defBlock) (Block''getLoopDepth-1 spillBlock)) => spillBlock
                                (LSOptimizeSpillPositionPhase'moveSpillOutOfLoop-2 defBlock, spillBlock)
                            )
                        ;; The spill block is the begin of the first split child (aka the value is on the stack).
                        ;;
                        ;; The problem is that if spill block has more than one predecessor, the values at the
                        ;; end of the predecessors might differ. Therefore, we would need a spill move in all
                        ;; predecessors. To avoid this we spill in the dominator.
                        spillBlock
                            (when (and (not (= defBlock spillBlock)) (= spillBlock (LinearScan''blockForId-2 (:allocator this), (Interval''from-1 firstSpillChild)))) => spillBlock
                                (:dominator spillBlock)
                            )
                    ]
                        (cond
                            (= defBlock spillBlock)                                ;; definition is the best choice
                                (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition)
                            (<= (:probability defBlock) (:probability spillBlock)) ;; better spill block has the same probability -> do nothing
                                (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition)
                            :else
                                (let [
                                    #_"LIRInsertionBuffer" buffer
                                        (or (nth insertionBuffers (:id spillBlock))
                                            (let [
                                                buffer (LIRInsertionBuffer'new-0)
                                            ]
                                                (ยง aset! insertionBuffers (:id spillBlock) buffer)
                                                (LIRInsertionBuffer''init-2 buffer, (LIR''getLIRforBlock-2 (:lir (:allocator this)), spillBlock))
                                            )
                                        )
                                    #_"int" spillOpId (LinearScan''getFirstLirInstructionId-2 (:allocator this), spillBlock)
                                    #_"AllocatableValue" from (:location (Interval''getSplitChildAtOpId-4 interval, spillOpId, OperandMode'DEF, (:allocator this)))
                                    #_"AllocatableValue" to (LinearScan'canonicalSpillOpr-1 interval)
                                    #_"LIRInstruction" move (MoveFactory'createMove-2 to, from)
                                ]
                                    (ยง ass! move (LIRInstruction''setId-2 move, LinearScan'DOMINATOR_SPILL_MOVE_ID))
                                    ;; We can use the insertion buffer directly because we always insert at position 1.
                                    (ยง ass! buffer (LIRInsertionBuffer''append-3 buffer, 1, move))

                                    (Interval''setSpillDefinitionPos-2 interval, spillOpId)
                                )
                        )
                    )
                )
            )
        )
        nil
    )

    (defm LSOptimizeSpillPositionPhase LSAllocationPhase
        (#_"void" LSAllocationPhase'''run-2 [#_"LSOptimizeSpillPositionPhase" this, #_"LIRGenerationResult" res]
            (let [
                #_"LIRInsertionBuffer[]" buffers (make-array LIRInsertionBuffer'iface (count (:linearScanOrder (:lir (:allocator this)))))
            ]
                (doseq [#_"Interval" interval (:intervals (:allocator this))]
                    (LSOptimizeSpillPositionPhase''optimizeInterval-4 this, buffers, interval, res)
                )
                (doseq [#_"LIRInsertionBuffer" buffer buffers]
                    (when (some? buffer)
                        (ยง ass! buffer (LIRInsertionBuffer''finish-1 buffer))
                    )
                )
            )
            nil
        )
    )
)

(class-ns LSRegisterAllocationPhase [LSAllocationPhase]
    (defn #_"LSRegisterAllocationPhase" LSRegisterAllocationPhase'new-1 [#_"LinearScan" allocator]
        (merge (LSRegisterAllocationPhase'class.) (LSAllocationPhase'new-0)
            (hash-map
                #_"LinearScan" :allocator allocator
            )
        )
    )

    (defm LSRegisterAllocationPhase LSAllocationPhase
        (#_"void" LSAllocationPhase'''run-2 [#_"LSRegisterAllocationPhase" this, #_"LIRGenerationResult" result]
            (let [
                #_"Pair<Interval, Interval>" result (LinearScan''createUnhandledLists-3 (:allocator this), LinearScan'IS_PRECOLORED_INTERVAL, LinearScan'IS_VARIABLE_INTERVAL)
                #_"Interval" precoloredIntervals (#_"Pair" .getLeft result)
                #_"Interval" notPrecoloredIntervals (#_"Pair" .getRight result)
                ;; allocate cpu registers
                #_"LinearScanWalker" lsw
                    (if GraalOptions'lsraOptimization
                        (OptimizingLinearScanWalker'new-3 (:allocator this), precoloredIntervals, notPrecoloredIntervals)
                        (LinearScanWalker'new-3 (:allocator this), precoloredIntervals, notPrecoloredIntervals)
                    )
            ]
                (IntervalWalker'''walk-1 lsw)
                (LinearScanWalker''finishAllocation-1 lsw)
            )
            nil
        )
    )
)

(class-ns LSResolveDataFlowPhase [LSAllocationPhase]
    (defn #_"LSResolveDataFlowPhase" LSResolveDataFlowPhase'new-1 [#_"LinearScan" allocator]
        (merge (LSResolveDataFlowPhase'class.) (LSAllocationPhase'new-0)
            (hash-map
                #_"LinearScan" :allocator allocator
            )
        )
    )

    (defm LSResolveDataFlowPhase LSResolveDataFlowPhase
        (#_"void" LSResolveDataFlowPhase'''resolveCollectMappings-5 [#_"LSResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"Block" midBlock, #_"MoveResolver" moveResolver]
            (let [
                #_"int" toBlockFirstInstructionId (LinearScan''getFirstLirInstructionId-2 (:allocator this), toBlock)
                #_"int" fromBlockLastInstructionId (inc (LinearScan''getLastLirInstructionId-2 (:allocator this), fromBlock))
                #_"int" numOperands (LinearScan''operandSize-1 (:allocator this))
                #_"BitSet" liveAtEdge (:liveIn (LinearScan''getBlockData-2 (:allocator this), toBlock))
            ]
                ;; visit all variables for which the liveAtEdge bit is set
                (loop-when-recur [#_"int" operandNum (#_"BitSet" .nextSetBit liveAtEdge, 0)] (<= 0 operandNum) [(#_"BitSet" .nextSetBit liveAtEdge, (inc operandNum))]
                    (let [
                        #_"Interval" fromInterval (LinearScan''splitChildAtOpId-4 (:allocator this), (LinearScan''intervalFor-2i (:allocator this), operandNum), fromBlockLastInstructionId, OperandMode'DEF)
                        #_"Interval" toInterval (LinearScan''splitChildAtOpId-4 (:allocator this), (LinearScan''intervalFor-2i (:allocator this), operandNum), toBlockFirstInstructionId, OperandMode'DEF)
                    ]
                        (when (and (not= fromInterval toInterval) (not (= (:location fromInterval) (:location toInterval))))
                            ;; need to insert move instruction
                            (MoveResolver''addMapping-3i moveResolver, fromInterval, toInterval)
                        )
                    )
                )
            )
            nil
        )
    )

    (defn #_"void" LSResolveDataFlowPhase''resolveFindInsertPos-4 [#_"LSResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"MoveResolver" moveResolver]
        (if (<= (count (:successors fromBlock)) 1)
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), fromBlock)
            ]
                (if (satisfies? JumpOp (nth ops (dec (count ops))))
                    (ยง ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, ops, (dec (count ops)))) ;; insert moves before branch
                    (ยง ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, ops, (count ops)))
                )
            )
            (ยง ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, (LIR''getLIRforBlock-2 (:lir (:allocator this)), toBlock), 1))
        )
        nil
    )

    (defn #_"void" LSResolveDataFlowPhase''optimizeEmptyBlocks-3 [#_"LSResolveDataFlowPhase" this, #_"MoveResolver" moveResolver, #_"BitSet" blockCompleted]
        (doseq [#_"Block" block (LinearScan''sortedBlocks-1 (:allocator this))]
            ;; check if block has only one predecessor and only one successor
            (when (and (= (count (:predecessors block)) 1) (= (count (:successors block)) 1))
                (let [
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                ]
                    ;; check if block is empty (only label and branch)
                    (when (= (count ops) 2)
                        (let [
                            #_"Block" pred (nth (:predecessors block) 0)
                            #_"Block" sux (nth (:successors block) 0)
                        ]
                            ;; prevent optimization of two consecutive blocks
                            (when (and (not (#_"BitSet" .get blockCompleted, (:linearScanNumber pred))) (not (#_"BitSet" .get blockCompleted, (:linearScanNumber sux))))
                                (#_"BitSet" .set blockCompleted, (:linearScanNumber block))

                                ;; Directly resolve between pred and sux (without looking at the empty block between).
                                (LSResolveDataFlowPhase'''resolveCollectMappings-5 this, pred, sux, block, moveResolver)
                                (when (MoveResolver''hasMappings-1 moveResolver)
                                    (ยง ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, ops, 1))
                                    (ยง ass! moveResolver (MoveResolver''resolveAndAppendMoves-1 moveResolver))
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" LSResolveDataFlowPhase''resolveDataFlow0-3 [#_"LSResolveDataFlowPhase" this, #_"MoveResolver" moveResolver, #_"BitSet" blockCompleted]
        (let [
            #_"BitSet" alreadyResolved (BitSet.)
        ]
            (doseq [#_"Block" fromBlock (LinearScan''sortedBlocks-1 (:allocator this))]
                (when-not (#_"BitSet" .get blockCompleted, (:linearScanNumber fromBlock))
                    (#_"BitSet" .clear alreadyResolved)
                    (#_"BitSet" .or alreadyResolved, blockCompleted)

                    (doseq [#_"Block" toBlock (:successors fromBlock)]
                        ;; Check for duplicate edges between the same blocks (can happen with switch blocks).
                        (when-not (#_"BitSet" .get alreadyResolved, (:linearScanNumber toBlock))
                            (#_"BitSet" .set alreadyResolved, (:linearScanNumber toBlock))

                            ;; collect all intervals that have been split between fromBlock and toBlock
                            (LSResolveDataFlowPhase'''resolveCollectMappings-5 this, fromBlock, toBlock, nil, moveResolver)
                            (when (MoveResolver''hasMappings-1 moveResolver)
                                (LSResolveDataFlowPhase''resolveFindInsertPos-4 this, fromBlock, toBlock, moveResolver)
                                (ยง ass! moveResolver (MoveResolver''resolveAndAppendMoves-1 moveResolver))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Inserts necessary moves (spilling or reloading) at edges between blocks for intervals that have been split.
     ;;
    (defn #_"void" LSResolveDataFlowPhase''resolveDataFlow-1 [#_"LSResolveDataFlowPhase" this]
        (let [
            #_"MoveResolver" moveResolver (LinearScan'''createMoveResolver-1 (:allocator this))
            #_"BitSet" blockCompleted (BitSet.)
        ]
            (LSResolveDataFlowPhase''optimizeEmptyBlocks-3 this, moveResolver, blockCompleted)
            (LSResolveDataFlowPhase''resolveDataFlow0-3 this, moveResolver, blockCompleted)
        )
        nil
    )

    (defm LSResolveDataFlowPhase LSAllocationPhase
        (#_"void" LSAllocationPhase'''run-2 [#_"LSResolveDataFlowPhase" this, #_"LIRGenerationResult" lirGenRes]
            (LSResolveDataFlowPhase''resolveDataFlow-1 this)
            nil
        )
    )
)

(class-ns SSALinearScanResolveDataFlowPhase [LSResolveDataFlowPhase, LSAllocationPhase]
    (defn #_"SSALinearScanResolveDataFlowPhase" SSALinearScanResolveDataFlowPhase'new-1 [#_"LinearScan" allocator]
        (merge (SSALinearScanResolveDataFlowPhase'class.) (LSResolveDataFlowPhase'new-1 allocator))
    )

    (defm SSALinearScanResolveDataFlowPhase LSResolveDataFlowPhase
        (#_"void" LSResolveDataFlowPhase'''resolveCollectMappings-5 [#_"SSALinearScanResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"Block" midBlock, #_"MoveResolver" moveResolver]
            (LSResolveDataFlowPhase'''resolveCollectMappings-5 (ยง super LSResolveDataFlowPhase'iface), fromBlock, toBlock, midBlock, moveResolver)

            (when (< 1 (count (:predecessors toBlock)))
                (let [
                    #_"int" toBlockFirstInstructionId (LinearScan''getFirstLirInstructionId-2 (:allocator this), toBlock)
                    #_"int" fromBlockLastInstructionId (inc (LinearScan''getLastLirInstructionId-2 (:allocator this), fromBlock))
                    #_"Block" phiOutBlock (if (some? midBlock) midBlock fromBlock)
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), phiOutBlock)
                    #_"int" phiOutIdx (SSAUtil'phiOutIndex-2 (:lir (:allocator this)), phiOutBlock)
                    #_"int" phiOutId (if (some? midBlock) fromBlockLastInstructionId (:id (nth ops phiOutIdx)))
                    #_"SSALinearScanResolveDataFlowPhase" phase this
                    #_"PhiValueVisitor" visitor
                        (reify PhiValueVisitor
                            (#_"void" PhiValueVisitor'''visit-3 [#_"PhiValueVisitor" this, #_"Value" phiIn, #_"Value" phiOut]
                                (let [
                                    #_"Interval" toInterval (LinearScan''splitChildAtOpId-4 (:allocator phase), (LinearScan''intervalFor-2v (:allocator phase), phiIn), toBlockFirstInstructionId, OperandMode'DEF)
                                ]
                                    (if (satisfies? ConstantValue phiOut)
                                        (MoveResolver''addMapping-3c moveResolver, (:constant phiOut), toInterval)
                                        (let [
                                            #_"Interval" fromInterval (LinearScan''splitChildAtOpId-4 (:allocator phase), (LinearScan''intervalFor-2v (:allocator phase), phiOut), phiOutId, OperandMode'DEF)
                                        ]
                                            (when (and (not= fromInterval toInterval) (not (= (:location fromInterval) (:location toInterval))))
                                                (if (not (and (LIRValueUtil'isStackSlotValue-1 (:location toInterval)) (LIRValueUtil'isStackSlotValue-1 (:location fromInterval))))
                                                    (MoveResolver''addMapping-3i moveResolver, fromInterval, toInterval)
                                                    (MoveResolver''addMapping-3i moveResolver, fromInterval, toInterval)
                                                )
                                            )
                                        )
                                    )
                                )
                                nil
                            )
                        )
                ]
                    (SSAUtil'forEachPhiValuePair-4 (:lir (:allocator this)), toBlock, phiOutBlock, visitor)
                    (SSAUtil'removePhiOut-2 (:lir (:allocator this)), phiOutBlock)
                )
            )
            nil
        )
    )
)

(class-ns LinearScan []
    (def #_"int" LinearScan'DOMINATOR_SPILL_MOVE_ID -2)
    (def- #_"int" LinearScan'SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT 1)

    (defn #_"LinearScan" LinearScan'new-3 [#_"LIRGenerationResult" res, #_"MoveFactory" moveFactory, #_"Block[]" sortedBlocks]
        (let [
            #_"LinearScan" this
                (merge (LinearScan'class.)
                    (hash-map
                        #_"LIR" :lir (:lir res)
                        #_"FrameMapBuilder" :frameMapBuilder (:frameMapBuilder res)
                        #_"RegisterAttributes[]" :registerAttributes (#_"RegisterConfig" .getAttributesMap HotSpot'registerConfig)
                        #_"RegisterArray" :registers (#_"Architecture" .getRegisters (.arch HotSpot'target))
                        #_"MoveFactory" :moveFactory moveFactory
                        #_"BlockMap<BlockData>" :blockData (BlockMap'new-1 (:cfg (:lir res)))
                        ;;;
                         ; List of blocks in linear-scan order. This is only correct as long as the CFG does not change.
                         ;;
                        #_"Block[]" :sortedBlocks sortedBlocks
                        ;;;
                         ; Map from {@linkplain #operandNumber(Value) operand numbers} to intervals.
                         ;;
                        #_"Interval[]" :intervals nil
                        ;;;
                         ; The number of valid entries in #intervals.
                         ;;
                        #_"int" :intervalsSize 0
                        ;;;
                         ; The index of the first entry in #intervals for a
                         ; {@linkplain #createDerivedInterval(Interval) derived interval}.
                         ;;
                        #_"int" :firstDerivedIntervalIndex -1
                        ;;;
                         ; Intervals sorted by Interval#from().
                         ;;
                        #_"Interval[]" :sortedIntervals nil
                        ;;;
                         ; Map from an instruction {@linkplain LIRInstruction#id id} to the instruction. Entries should
                         ; be retrieved with #instructionForId(int) as the id is not simply an index into this array.
                         ;;
                        #_"LIRInstruction[]" :opIdToInstructionMap nil
                        ;;;
                         ; Map from an instruction {@linkplain LIRInstruction#id id} to the block containing the instruction.
                         ; Entries should be retrieved with #blockForId(int) as the id is not simply an index into this array.
                         ;;
                        #_"Block[]" :opIdToBlockMap nil
                        ;;;
                         ; The {@linkplain #operandNumber(Value) number} of the first variable operand allocated.
                         ;;
                        #_"int" :firstVariableNumber 0
                        #_"int" :numVariables (:numVariables (:lir res))
                        ;;;
                         ; Sentinel interval to denote the end of an interval list.
                         ;;
                        #_"Interval" :intervalEndMarker nil
                        #_"Range" :rangeEndMarker (Range'new-3 Integer/MAX_VALUE, Integer/MAX_VALUE, nil)
                    )
                )
            this (assoc this :firstVariableNumber (#_"RegisterArray" .size (LinearScan''getRegisters-1 this)))
            this (assoc this :intervalEndMarker (Interval'new-4 Value/ILLEGAL, Interval'END_MARKER_OPERAND_NUMBER, nil, (:rangeEndMarker this)))
        ]
            (ยง ass! (:next (:intervalEndMarker this)) (:intervalEndMarker this))
            this
        )
    )

    (defn #_"int" LinearScan''getFirstLirInstructionId-2 [#_"LinearScan" this, #_"Block" block]
        (:id (nth (LIR''getLIRforBlock-2 (:lir this), block) 0))
    )

    (defn #_"int" LinearScan''getLastLirInstructionId-2 [#_"LinearScan" this, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
        ]
            (:id (nth ops (dec (count ops))))
        )
    )

    (defm LinearScan LinearScan
        (#_"MoveResolver" LinearScan'''createMoveResolver-1 [#_"LinearScan" this]
            (MoveResolver'new-1 this)
        )
    )

    (defn #_"boolean" LinearScan'isVariableOrRegister-1 [#_"Value" value]
        (or (satisfies? Variable value) (instance? RegisterValue value))
    )

    ;;;
     ; Converts an operand (variable or register) to an index in a flat address space covering all
     ; the variables and registers being processed by this allocator.
     ;;
    (defn #_"int" LinearScan''operandNumber-2 [#_"LinearScan" this, #_"Value" operand]
        (if (instance? RegisterValue operand)
            (.number (#_"RegisterValue" .getRegister operand))
            (+ (:firstVariableNumber this) (:index operand))
        )
    )

    ;;;
     ; Gets the number of operands. This value will increase by 1 for new variable.
     ;;
    (defn #_"int" LinearScan''operandSize-1 [#_"LinearScan" this]
        (+ (:firstVariableNumber this) (:numVariables this))
    )

    (defn #_"BlockData" LinearScan''getBlockData-2 [#_"LinearScan" this, #_"Block" block]
        (BlockMap''get-2 (:blockData this), block)
    )

    (defm LinearScan LinearScan
        (#_"void" LinearScan'''initBlockData-2 [#_"LinearScan" this, #_"Block" block]
            (BlockMap''put-3 (:blockData this), block, (BlockData'new-0))
            nil
        )
    )

    (def #_"IntervalPredicate" LinearScan'IS_PRECOLORED_INTERVAL
        (reify IntervalPredicate
            (#_"boolean" IntervalPredicate'''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (instance? RegisterValue (:operand i))
            )
        )
    )

    (def #_"IntervalPredicate" LinearScan'IS_VARIABLE_INTERVAL
        (reify IntervalPredicate
            (#_"boolean" IntervalPredicate'''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (satisfies? Variable (:operand i))
            )
        )
    )

    (def #_"IntervalPredicate" LinearScan'IS_STACK_INTERVAL
        (reify IntervalPredicate
            (#_"boolean" IntervalPredicate'''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (not (instance? RegisterValue (:operand i)))
            )
        )
    )

    ;;;
     ; Gets an object describing the attributes of a given register according to this register configuration.
     ;;
    (defn #_"RegisterAttributes" LinearScan''attributes-2 [#_"LinearScan" this, #_"Register" reg]
        (nth (:registerAttributes this) (.number reg))
    )

    (defn #_"void" LinearScan''assignSpillSlot-2 [#_"LinearScan" this, #_"Interval" interval]
        ;; Assign the canonical spill slot of the parent (if a part of the interval is already spilled)
        ;; or allocate a new spill slot.
        (cond
            (Interval''canMaterialize-1 interval)
                (ยง ass! interval (Interval''assignLocation-2 interval, Value/ILLEGAL))
            (some? (Interval''spillSlot-1 interval))
                (ยง ass! interval (Interval''assignLocation-2 interval, (Interval''spillSlot-1 interval)))
            :else
                (let [
                    #_"VirtualStackSlot" slot (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder this), (:kind interval))
                ]
                    (Interval''setSpillSlot-2 interval, slot)
                    (ยง ass! interval (Interval''assignLocation-2 interval, slot))
                )
        )
        nil
    )

    (defn #_"this" LinearScan''initIntervals-1 [#_"LinearScan" this]
        (let [
            this (assoc this :intervalsSize (LinearScan''operandSize-1 this))
            this (assoc this :intervals (make-array Interval'iface (+ (:intervalsSize this) (>> (:intervalsSize this) LinearScan'SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT))))
        ]
            this
        )
    )

    ;;;
     ; Creates a new interval.
     ;
     ; @param operand the operand for the interval
     ; @return the created interval
     ;;
    (defn #_"Interval" LinearScan''createInterval-2 [#_"LinearScan" this, #_"AllocatableValue" operand]
        (let [
            #_"int" operandNumber (LinearScan''operandNumber-2 this, operand)
            #_"Interval" interval (Interval'new-4 operand, operandNumber, (:intervalEndMarker this), (:rangeEndMarker this))
        ]
            (aset (:intervals this) operandNumber interval)
            interval
        )
    )

    ;;;
     ; Creates an interval as a result of splitting or spilling another interval.
     ;
     ; @param source an interval being split of spilled
     ; @return a new interval derived from {@code source}
     ;;
    (defn #_"Interval" LinearScan''createDerivedInterval-2 [#_"LinearScan" this, #_"Interval" source]
        (when (= (:firstDerivedIntervalIndex this) -1)
            (ยง ass! this (assoc this :firstDerivedIntervalIndex (:intervalsSize this)))
        )
        (when (= (:intervalsSize this) (count (:intervals this)))
            (ยง ass! this (assoc this :intervals (Arrays/copyOf (:intervals this), (+ (count (:intervals this)) (>> (count (:intervals this)) LinearScan'SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT) 1))))
        )
        (ยง ass! this (update this :intervalsSize inc))
        ;; note: these variables are not managed and must therefore never be inserted into the LIR
        (let [
            #_"Variable" variable (Variable'new-2 (:kind source), (:numVariables this))
        ]
            (ยง ass! this (update this :numVariables inc))
            (LinearScan''createInterval-2 this, variable)
        )
    )

    ;; access to block list (sorted in linear scan order)
    (defn #_"int" LinearScan''blockCount-1 [#_"LinearScan" this]
        (count (:sortedBlocks this))
    )

    (defn #_"Block" LinearScan''blockAt-2 [#_"LinearScan" this, #_"int" index]
        (nth (:sortedBlocks this) index)
    )

    ;;;
     ; Gets the size of the BlockData#liveIn and BlockData#liveOut sets for a basic block.
     ; These sets do not include any operands allocated as a result of creating
     ; {@linkplain #createDerivedInterval(Interval) derived intervals}.
     ;;
    #_unused
    (defn #_"int" LinearScan''liveSetSize-1 [#_"LinearScan" this]
        (if (= (:firstDerivedIntervalIndex this) -1) (LinearScan''operandSize-1 this) (:firstDerivedIntervalIndex this))
    )

    (defn #_"int" LinearScan''numLoops-1 [#_"LinearScan" this]
        (count (:loops (:cfg (:lir this))))
    )

    (defn #_"Interval" LinearScan''intervalFor-2i [#_"LinearScan" this, #_"int" operandNumber]
        (nth (:intervals this) operandNumber)
    )

    (defn #_"Interval" LinearScan''intervalFor-2v [#_"LinearScan" this, #_"Value" operand]
        (nth (:intervals this) (LinearScan''operandNumber-2 this, operand))
    )

    (defm LinearScan LinearScan
        (#_"Interval" LinearScan'''getOrCreateInterval-2 [#_"LinearScan" this, #_"AllocatableValue" operand]
            (or (LinearScan''intervalFor-2v this, operand) (LinearScan''createInterval-2 this, operand))
        )
    )

    (defn #_"this" LinearScan''initOpIdMaps-2 [#_"LinearScan" this, #_"int" n]
        (let [
            this (assoc this :opIdToInstructionMap (make-array LIRInstruction'iface n))
            this (assoc this :opIdToBlockMap (make-array Block'iface n))
        ]
            this
        )
    )

    (defn #_"void" LinearScan''putOpIdMaps-4 [#_"LinearScan" this, #_"int" index, #_"LIRInstruction" op, #_"Block" block]
        (aset (:opIdToInstructionMap this) index op)
        (aset (:opIdToBlockMap this) index block)
        nil
    )

    ;;;
     ; Gets the highest instruction id allocated by this object.
     ;;
    (defn #_"int" LinearScan''maxOpId-1 [#_"LinearScan" this]
        (<< (dec (count (:opIdToInstructionMap this))) 1)
    )

    ;;;
     ; Converts an {@linkplain LIRInstruction#id instruction id} to an instruction index. All LIR
     ; instructions in a method have an index one greater than their linear-scan order predecessor
     ; with the first instruction having an index of 0.
     ;;
    (defn- #_"int" LinearScan'opIdToIndex-1 [#_"int" opId]
        (>> opId 1)
    )

    ;;;
     ; Retrieves the LIRInstruction based on its {@linkplain LIRInstruction#id id}.
     ;
     ; @param opId an instruction {@linkplain LIRInstruction#id id}
     ; @return the instruction whose {@linkplain LIRInstruction#id} {@code == id}
     ;;
    (defn #_"LIRInstruction" LinearScan''instructionForId-2 [#_"LinearScan" this, #_"int" opId]
        (nth (:opIdToInstructionMap this) (LinearScan'opIdToIndex-1 opId))
    )

    ;;;
     ; Gets the block containing a given instruction.
     ;
     ; @param opId an instruction {@linkplain LIRInstruction#id id}
     ; @return the block containing the instruction denoted by {@code opId}
     ;;
    (defn #_"Block" LinearScan''blockForId-2 [#_"LinearScan" this, #_"int" opId]
        (nth (:opIdToBlockMap this) (LinearScan'opIdToIndex-1 opId))
    )

    (defn #_"boolean" LinearScan''isBlockBegin-2 [#_"LinearScan" this, #_"int" opId]
        (or (zero? opId) (not= (LinearScan''blockForId-2 this, opId) (LinearScan''blockForId-2 this, (dec opId))))
    )

    #_unused
    (defn #_"boolean" LinearScan''coversBlockBegin-3 [#_"LinearScan" this, #_"int" opId1, #_"int" opId2]
        (not= (LinearScan''blockForId-2 this, opId1) (LinearScan''blockForId-2 this, opId2))
    )

    ;;;
     ; Determines if an LIRInstruction destroys all caller saved registers.
     ;
     ; @param opId an instruction {@linkplain LIRInstruction#id id}
     ; @return true if the instruction denoted by {@code id} destroys all caller saved registers
     ;;
    (defn #_"boolean" LinearScan''hasCall-2 [#_"LinearScan" this, #_"int" opId]
        (LIRInstruction'''destroysCallerSavedRegisters-1 (LinearScan''instructionForId-2 this, opId))
    )

    (defn #_"boolean" LinearScan''isProcessed-2 [#_"LinearScan" this, #_"Value" operand]
        (or (not (instance? RegisterValue operand)) (#_"RegisterAttributes" .isAllocatable (LinearScan''attributes-2 this, (#_"RegisterValue" .getRegister operand))))
    )

    ;; * Phase 5: actual register allocation

    (defn #_"Interval" LinearScan'addToList-3 [#_"Interval" _first, #_"Interval" prev, #_"Interval" interval]
        (let [
            #_"Interval" newFirst _first
        ]
            (if (some? prev)
                (ยง ass! prev (assoc prev :next interval))
                (ยง ass newFirst interval)
            )
            newFirst
        )
    )

    (defn #_"Pair<Interval, Interval>" LinearScan''createUnhandledLists-3 [#_"LinearScan" this, #_"IntervalPredicate" isList1, #_"IntervalPredicate" isList2]
        (let [
            [#_"Interval" list1 #_"Interval" list2 #_"Interval" prev1 #_"Interval" prev2]
                (loop-when [list1 (:intervalEndMarker this) list2 (:intervalEndMarker this) prev1 nil prev2 nil #_"int" i 0] (< i (count (:sortedIntervals this))) => [list1 list2 prev1 prev2]
                    (let [
                        #_"Interval" interval (nth (:sortedIntervals this) i)
                        [list1 list2 prev1 prev2]
                            (when (some? interval) => [list1 list2 prev1 prev2]
                                (cond
                                    (IntervalPredicate'''apply-2 isList1, interval)
                                        [(LinearScan'addToList-3 list1, prev1, interval) list2 interval prev2]
                                    (or (nil? isList2) (IntervalPredicate'''apply-2 isList2, interval))
                                        [list1 (LinearScan'addToList-3 list2, prev2, interval) prev1 interval]
                                    :else
                                        [list1 list2 prev1 prev2]
                                )
                            )
                    ]
                        (recur list1 list2 prev1 prev2 (inc i))
                    )
                )
        ]
            (when (some? prev1)
                (ยง ass! prev1 (assoc prev1 :next (:intervalEndMarker this)))
            )
            (when (some? prev2)
                (ยง ass! prev2 (assoc prev2 :next (:intervalEndMarker this)))
            )
            (Pair/create list1, list2)
        )
    )

    (defn #_"this" LinearScan''sortIntervalsBeforeAllocation-1 [#_"LinearScan" this]
        (let [
            #_"Interval[]" a (make-array Interval'iface (count (filter some? (:intervals this))))
        ]
            ;; special sorting algorithm: the original interval list is almost sorted, only
            ;; some intervals are swapped, so this is much faster than a complete QuickSort
            (loop-when [#_"int" i 0 #_"int" fromMax -1 #_"ISeq" s (seq (filter some? (:intervals this)))] (some? s)
                (let [
                    #_"Interval" interval (first s)
                    #_"int" from (Interval''from-1 interval)
                    [i fromMax]
                        (if (<= fromMax from)
                            (do
                                (aset a i interval)
                                [(inc i) from]
                            )
                            ;; the assumption that the intervals are already sorted failed,
                            ;; so this interval must be sorted in manually
                            (do
                                (loop-when-recur [#_"int" j (dec i)] (and (<= 0 j) (< from (Interval''from-1 (nth a j)))) [(dec j)] => (aset a (inc j) interval)
                                    (aset a (inc j) (nth a j))
                                )
                                [(inc i) fromMax]
                            )
                        )
                ]
                    (recur i fromMax (next s))
                )
            )
            (assoc this :sortedIntervals a)
        )
    )

    (defn #_"LinearScan" LinearScan''sortIntervalsAfterAllocation-1 [#_"LinearScan" this]
        (when-not (= (:firstDerivedIntervalIndex this) -1) => this ;; no intervals have been added during allocation, so sorted list is already up to date
            (let [
                #_"Interval[]" oldList (:sortedIntervals this)
                #_"Interval[]" newList (Arrays/copyOfRange (:intervals this), (:firstDerivedIntervalIndex this), (:intervalsSize this))
                #_"int" oldLen (count oldList)
                #_"int" newLen (count newList)
            ]
                ;; conventional sort-algorithm for new intervals
                (Arrays/sort newList, (ร (#_"Interval" a, #_"Interval" b)  (ยง fun (- (Interval''from-1 a) (Interval''from-1 b)))))

                ;; merge old and new list (both already sorted) into one combined list
                (let [
                    #_"Interval[]" a (make-array Interval'iface (+ oldLen newLen))
                ]
                    (loop-when [#_"int" oldIdx 0 #_"int" newIdx 0] (< (+ oldIdx newIdx) (count a))
                        (if (or (<= newLen newIdx) (and (< oldIdx oldLen) (<= (Interval''from-1 (nth oldList oldIdx)) (Interval''from-1 (nth newList newIdx)))))
                            (do
                                (aset a (+ oldIdx newIdx) (nth oldList oldIdx))
                                (recur (inc oldIdx) newIdx)
                            )
                            (do
                                (aset a (+ oldIdx newIdx) (nth newList newIdx))
                                (recur oldIdx (inc newIdx))
                            )
                        )
                    )
                    (assoc this :sortedIntervals a)
                )
            )
        )
    )

    ;; wrapper for Interval.splitChildAtOpId that performs a bailout in product mode instead of returning nil
    (defn #_"Interval" LinearScan''splitChildAtOpId-4 [#_"LinearScan" this, #_"Interval" interval, #_"int" opId, #_"OperandMode" mode]
        (or (Interval''getSplitChildAtOpId-4 interval, opId, mode, this)
            (throw! "linear scan: interval is nil")
        )
    )

    (defn #_"AllocatableValue" LinearScan'canonicalSpillOpr-1 [#_"Interval" interval]
        (Interval''spillSlot-1 interval)
    )

    (defn #_"boolean" LinearScan''isMaterialized-4 [#_"LinearScan" this, #_"AllocatableValue" operand, #_"int" opId, #_"OperandMode" mode]
        (let [
            #_"Interval" interval (LinearScan''intervalFor-2v this, operand)
            interval
                (when-not (= opId -1) => interval
                    ;; operands are not changed when an interval is split during allocation, so search the right interval here
                    (LinearScan''splitChildAtOpId-4 this, interval, opId, mode)
                )
        ]
            (and (= (:location interval) Value/ILLEGAL) (Interval''canMaterialize-1 interval))
        )
    )

    #_unused
    (defn #_"boolean" LinearScan''isCallerSave-2 [#_"LinearScan" this, #_"Value" operand]
        (#_"RegisterAttributes" .isCallerSave (LinearScan''attributes-2 this, (#_"RegisterValue" .getRegister operand)))
    )

    (defn #_"void" LinearScan''allocate-2 [#_"LinearScan" this, #_"LIRGenerationResult" lirGenRes]
        (LSAllocationPhase'''run-2 (LinearScan'''createLifetimeAnalysisPhase-1 this), lirGenRes)

        (ยง ass! this (LinearScan''sortIntervalsBeforeAllocation-1 this))

        (LSAllocationPhase'''run-2 (LinearScan''createRegisterAllocationPhase-1 this), lirGenRes)

        (when GraalOptions'lirOptLSRAOptimizeSpillPosition
            (LSAllocationPhase'''run-2 (LinearScan''createOptimizeSpillPositionPhase-1 this), lirGenRes)
        )
        (LSAllocationPhase'''run-2 (LinearScan'''createResolveDataFlowPhase-1 this), lirGenRes)

        (ยง ass! this (LinearScan''sortIntervalsAfterAllocation-1 this))

        (LinearScan'''beforeSpillMoveElimination-1 this)
        (LSAllocationPhase'''run-2 (LinearScan'''createSpillMoveEliminationPhase-1 this), lirGenRes)
        (LSAllocationPhase'''run-2 (LinearScan''createAssignLocationsPhase-1 this), lirGenRes)
        nil
    )

    (defm LinearScan LinearScan
        (#_"void" LinearScan'''beforeSpillMoveElimination-1 [#_"LinearScan" this]
            nil
        )

        (#_"LSLifetimeAnalysisPhase" LinearScan'''createLifetimeAnalysisPhase-1 [#_"LinearScan" this]
            (LSLifetimeAnalysisPhase'new-1 this)
        )
    )

    (defn #_"LSRegisterAllocationPhase" LinearScan''createRegisterAllocationPhase-1 [#_"LinearScan" this]
        (LSRegisterAllocationPhase'new-1 this)
    )

    (defn #_"LSOptimizeSpillPositionPhase" LinearScan''createOptimizeSpillPositionPhase-1 [#_"LinearScan" this]
        (LSOptimizeSpillPositionPhase'new-1 this)
    )

    (defm LinearScan LinearScan
        (#_"LSResolveDataFlowPhase" LinearScan'''createResolveDataFlowPhase-1 [#_"LinearScan" this]
            (LSResolveDataFlowPhase'new-1 this)
        )

        (#_"LSEliminateSpillMovePhase" LinearScan'''createSpillMoveEliminationPhase-1 [#_"LinearScan" this]
            (LSEliminateSpillMovePhase'new-1 this)
        )
    )

    (defn #_"LSAssignLocationsPhase" LinearScan''createAssignLocationsPhase-1 [#_"LinearScan" this]
        (LSAssignLocationsPhase'new-1 this)
    )

    (defn #_"FrameMapBuilder" LinearScan''getFrameMapBuilder-1 [#_"LinearScan" this]
        (:frameMapBuilder this)
    )

    (defn #_"Block[]" LinearScan''sortedBlocks-1 [#_"LinearScan" this]
        (:sortedBlocks this)
    )

    (defn #_"RegisterArray" LinearScan''getRegisters-1 [#_"LinearScan" this]
        (:registers this)
    )
)

(class-ns SSALinearScan [LinearScan]
    (defn #_"SSALinearScan" SSALinearScan'new-3 [#_"LIRGenerationResult" res, #_"MoveFactory" moveFactory, #_"Block[]" sortedBlocks]
        (merge (SSALinearScan'class.) (LinearScan'new-3 res, moveFactory, sortedBlocks))
    )

    (defm SSALinearScan LinearScan
        (#_"MoveResolver" LinearScan'''createMoveResolver-1 [#_"SSALinearScan" this]
            (SSAMoveResolver'new-1 this)
        )

        (#_"LSLifetimeAnalysisPhase" LinearScan'''createLifetimeAnalysisPhase-1 [#_"SSALinearScan" this]
            (SSALinearScanLifetimeAnalysisPhase'new-1 this)
        )

        (#_"LSResolveDataFlowPhase" LinearScan'''createResolveDataFlowPhase-1 [#_"SSALinearScan" this]
            (SSALinearScanResolveDataFlowPhase'new-1 this)
        )

        (#_"LSEliminateSpillMovePhase" LinearScan'''createSpillMoveEliminationPhase-1 [#_"SSALinearScan" this]
            (SSALinearScanEliminateSpillMovePhase'new-1 this)
        )

        (#_"void" LinearScan'''beforeSpillMoveElimination-1 [#_"SSALinearScan" this]
            ;; PHIs where the Out and In value matches (i.e. there is no resolution move) are falsely detected as errors.
            (doseq [#_"Block" toBlock (LinearScan''sortedBlocks-1 this)]
                (when (< 1 (count (:predecessors toBlock)))
                    (SSAUtil'removePhiIn-2 (:lir this), toBlock)
                )
            )
            nil
        )
    )
)

(class-ns LinearScanPhase [LIRPhase #_"<LIRPhaseContext>"] ;; AllocationPhase
    (defn #_"LinearScanPhase" LinearScanPhase'new-0 []
        (LinearScanPhase'class.)
    )

    (defm LinearScanPhase LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"LinearScanPhase" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (let [
                #_"LinearScan" allocator (SSALinearScan'new-3 lirGenRes, (:moveFactory (:lirGen context)), (:linearScanOrder (:lir lirGenRes)))
            ]
                (LinearScan''allocate-2 allocator, lirGenRes)
            )
            nil
        )
    )
)

(class-ns LocalLiveness []
    (defn #_"LocalLiveness" LocalLiveness'new-1 [#_"BciBlock[]" blocks]
        (merge (LocalLiveness'class.)
            (hash-map
                #_"BciBlock[]" :blocks blocks
            )
        )
    )

    (defn- #_"void" LocalLiveness''loadTwo-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local]
        (LocalLiveness'''loadOne-3 this, blockID, local)
        (LocalLiveness'''loadOne-3 this, blockID, (inc local))
        nil
    )

    (defn- #_"void" LocalLiveness''storeTwo-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local]
        (LocalLiveness'''storeOne-3 this, blockID, local)
        (LocalLiveness'''storeOne-3 this, blockID, (inc local))
        nil
    )

    (defn- #_"void" LocalLiveness''computeLocalLiveness-3 [#_"LocalLiveness" this, #_"BytecodeStream" stream, #_"BciBlock" block]
        (let [
            #_"int" blockID (:id block)
        ]
            (loop-when-recur [_ (ยง ass! stream (BytecodeStream''setBCI-2 stream, (:startBci block)))] (<= (:curBCI stream) (:endBci block)) [(ยง ass! stream (BytecodeStream''next-1 stream))]
                (condp =? (BytecodeStream''currentBC-1 stream)
                    Bytecodes'LLOAD                                (LocalLiveness''loadTwo-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    Bytecodes'LLOAD_0                              (LocalLiveness''loadTwo-3 this, blockID, 0)
                    Bytecodes'LLOAD_1                              (LocalLiveness''loadTwo-3 this, blockID, 1)
                    Bytecodes'LLOAD_2                              (LocalLiveness''loadTwo-3 this, blockID, 2)
                    Bytecodes'LLOAD_3                              (LocalLiveness''loadTwo-3 this, blockID, 3)
                    Bytecodes'IINC
                        (let [
                            #_"int" i (BytecodeStream''readLocalIndex-1 stream)
                        ]
                            (LocalLiveness'''loadOne-3 this, blockID, i)
                            (LocalLiveness'''storeOne-3 this, blockID, i)
                        )
                    [Bytecodes'ILOAD Bytecodes'ALOAD Bytecodes'RET] (LocalLiveness'''loadOne-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    [Bytecodes'ILOAD_0 Bytecodes'ALOAD_0]           (LocalLiveness'''loadOne-3 this, blockID, 0)
                    [Bytecodes'ILOAD_1 Bytecodes'ALOAD_1]           (LocalLiveness'''loadOne-3 this, blockID, 1)
                    [Bytecodes'ILOAD_2 Bytecodes'ALOAD_2]           (LocalLiveness'''loadOne-3 this, blockID, 2)
                    [Bytecodes'ILOAD_3 Bytecodes'ALOAD_3]           (LocalLiveness'''loadOne-3 this, blockID, 3)
                    Bytecodes'LSTORE                               (LocalLiveness''storeTwo-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    Bytecodes'LSTORE_0                             (LocalLiveness''storeTwo-3 this, blockID, 0)
                    Bytecodes'LSTORE_1                             (LocalLiveness''storeTwo-3 this, blockID, 1)
                    Bytecodes'LSTORE_2                             (LocalLiveness''storeTwo-3 this, blockID, 2)
                    Bytecodes'LSTORE_3                             (LocalLiveness''storeTwo-3 this, blockID, 3)
                    [Bytecodes'ISTORE Bytecodes'ASTORE]             (LocalLiveness'''storeOne-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    [Bytecodes'ISTORE_0 Bytecodes'ASTORE_0]         (LocalLiveness'''storeOne-3 this, blockID, 0)
                    [Bytecodes'ISTORE_1 Bytecodes'ASTORE_1]         (LocalLiveness'''storeOne-3 this, blockID, 1)
                    [Bytecodes'ISTORE_2 Bytecodes'ASTORE_2]         (LocalLiveness'''storeOne-3 this, blockID, 2)
                    [Bytecodes'ISTORE_3 Bytecodes'ASTORE_3]         (LocalLiveness'''storeOne-3 this, blockID, 3)
                    nil
                )
            )
        )
        nil
    )

    (defn- #_"void" LocalLiveness''computeLiveness-2 [#_"LocalLiveness" this, #_"BytecodeStream" stream]
        (doseq [#_"BciBlock" block (:blocks this)]
            (LocalLiveness''computeLocalLiveness-3 this, stream, block)
        )
        (loop [#_"int" iteration 0]
            (let [
                #_"boolean" changed?
                    (loop-when [changed? false #_"int" i (dec (count (:blocks this)))] (<= 0 i) => changed?
                        (let [
                            #_"BciBlock" block (nth (:blocks this) i)
                            #_"boolean" blockChanged (zero? iteration)
                            blockChanged
                                (when (seq (:successors block)) => blockChanged
                                    (let [
                                        #_"int" o'cardinality (LocalLiveness'''liveOutCardinality-2 this, (:id block))
                                    ]
                                        (doseq [#_"BciBlock" sux (:successors block)]
                                            (LocalLiveness'''propagateLiveness-3 this, (:id block), (:id sux))
                                        )
                                        (or blockChanged (not= o'cardinality (LocalLiveness'''liveOutCardinality-2 this, (:id block))))
                                    )
                                )
                        ]
                            (when blockChanged
                                (LocalLiveness'''updateLiveness-2 this, (:id block))
                            )
                            (recur (or changed? blockChanged) (dec i))
                        )
                    )
            ]
                (recur-if changed? [(inc iteration)])
            )
        )
        nil
    )

    (defn #_"LocalLiveness" LocalLiveness'compute-4 [#_"BytecodeStream" stream, #_"BciBlock[]" blocks, #_"int" maxLocals, #_"int" loopCount]
        (let [
            #_"LocalLiveness" liveness (if (<= maxLocals 64) (SmallLocalLiveness'new-3 blocks, maxLocals, loopCount) (LargeLocalLiveness'new-3 blocks, maxLocals, loopCount))
        ]
            (LocalLiveness''computeLiveness-2 liveness, stream)
            liveness
        )
    )
)

(class-ns LargeLocalLiveness [LocalLiveness]
    (defn #_"LargeLocalLiveness" LargeLocalLiveness'new-3 [#_"BciBlock[]" blocks, #_"int" maxLocals, #_"int" loopCount]
        (let [
            #_"int" n (count blocks)
            #_"LargeLocalLiveness" this
                (merge (LargeLocalLiveness'class.) (LocalLiveness'new-1 blocks)
                    (hash-map
                        #_"BitSet[]" :localsLiveIn (make-array BitSet n)
                        #_"BitSet[]" :localsLiveOut (make-array BitSet n)
                        #_"BitSet[]" :localsLiveGen (make-array BitSet n)
                        #_"BitSet[]" :localsLiveKill (make-array BitSet n)
                        #_"BitSet[]" :localsChangedInLoop (make-array BitSet loopCount)
                    )
                )
            _
                (dotimes [#_"int" i n]
                    (aset (:localsLiveIn this) i (BitSet. maxLocals))
                    (aset (:localsLiveOut this) i (BitSet. maxLocals))
                    (aset (:localsLiveGen this) i (BitSet. maxLocals))
                    (aset (:localsLiveKill this) i (BitSet. maxLocals))
                )
            _
                (dotimes [#_"int" i loopCount]
                    (aset (:localsChangedInLoop this) i (BitSet. maxLocals))
                )
        ]
            this
        )
    )

    (defm LargeLocalLiveness LocalLiveness
        (#_"int" LocalLiveness'''liveOutCardinality-2 [#_"LargeLocalLiveness" this, #_"int" blockID]
            (#_"BitSet" .cardinality (nth (:localsLiveOut this) blockID))
        )

        (#_"void" LocalLiveness'''propagateLiveness-3 [#_"LargeLocalLiveness" this, #_"int" blockID, #_"int" successorID]
            (#_"BitSet" .or (nth (:localsLiveOut this) blockID), (nth (:localsLiveIn this) successorID))
            nil
        )

        (#_"void" LocalLiveness'''updateLiveness-2 [#_"LargeLocalLiveness" this, #_"int" blockID]
            (let [
                #_"BitSet" liveIn (nth (:localsLiveIn this) blockID)
            ]
                (#_"BitSet" .clear liveIn)
                (#_"BitSet" .or liveIn, (nth (:localsLiveOut this) blockID))
                (#_"BitSet" .andNot liveIn, (nth (:localsLiveKill this) blockID))
                (#_"BitSet" .or liveIn, (nth (:localsLiveGen this) blockID))
            )
            nil
        )

        (#_"void" LocalLiveness'''loadOne-3 [#_"LargeLocalLiveness" this, #_"int" blockID, #_"int" local]
            (when-not (#_"BitSet" .get (nth (:localsLiveKill this) blockID), local)
                (#_"BitSet" .set (nth (:localsLiveGen this) blockID), local)
            )
            nil
        )

        (#_"void" LocalLiveness'''storeOne-3 [#_"LargeLocalLiveness" this, #_"int" blockID, #_"int" local]
            (when-not (#_"BitSet" .get (nth (:localsLiveGen this) blockID), local)
                (#_"BitSet" .set (nth (:localsLiveKill this) blockID), local)
            )
            (loop-when-recur [#_"long" loops (:loops (nth (:blocks this) blockID)) #_"int" i 0] (not (zero? loops)) [(>>> loops 1) (inc i)]
                (when (= (& loops 1) 1)
                    (#_"BitSet" .set (nth (:localsChangedInLoop this) i), local)
                )
            )
            nil
        )

        (#_"boolean" LocalLiveness'''localIsLiveIn-3 [#_"LargeLocalLiveness" this, #_"BciBlock" block, #_"int" local]
            (or (<= Integer/MAX_VALUE (:id block)) (#_"BitSet" .get (nth (:localsLiveIn this) (:id block)), local))
        )

        (#_"boolean" LocalLiveness'''localIsLiveOut-3 [#_"LargeLocalLiveness" this, #_"BciBlock" block, #_"int" local]
            (or (<= Integer/MAX_VALUE (:id block)) (#_"BitSet" .get (nth (:localsLiveOut this) (:id block)), local))
        )

        (#_"boolean" LocalLiveness'''localIsChangedInLoop-3 [#_"LargeLocalLiveness" this, #_"int" loopId, #_"int" local]
            (#_"BitSet" .get (nth (:localsChangedInLoop this) loopId), local)
        )
    )
)

(class-ns SmallLocalLiveness [LocalLiveness]
    ;; local n is represented by the bit accessible as (1 << n)

    (defn #_"SmallLocalLiveness" SmallLocalLiveness'new-3 [#_"BciBlock[]" blocks, #_"int" maxLocals, #_"int" loopCount]
        (let [
            #_"int" n (count blocks)
        ]
            (merge (SmallLocalLiveness'class.) (LocalLiveness'new-1 blocks)
                (hash-map
                    #_"long[]" :localsLiveIn (long-array n)
                    #_"long[]" :localsLiveOut (long-array n)
                    #_"long[]" :localsLiveGen (long-array n)
                    #_"long[]" :localsLiveKill (long-array n)
                    #_"long[]" :localsChangedInLoop (long-array loopCount)
                    #_"int" :maxLocals maxLocals
                )
            )
        )
    )

    (defm SmallLocalLiveness LocalLiveness
        (#_"int" LocalLiveness'''liveOutCardinality-2 [#_"SmallLocalLiveness" this, #_"int" blockID]
            (Long/bitCount (nth (:localsLiveOut this) blockID))
        )

        (#_"void" LocalLiveness'''propagateLiveness-3 [#_"SmallLocalLiveness" this, #_"int" blockID, #_"int" successorID]
            (aswap (:localsLiveOut this) blockID | (nth (:localsLiveIn this) successorID))
            nil
        )

        (#_"void" LocalLiveness'''updateLiveness-2 [#_"SmallLocalLiveness" this, #_"int" blockID]
            (aset (:localsLiveIn this) blockID (| (& (nth (:localsLiveOut this) blockID) (bit-not (nth (:localsLiveKill this) blockID))) (nth (:localsLiveGen this) blockID)))
            nil
        )

        (#_"void" LocalLiveness'''loadOne-3 [#_"SmallLocalLiveness" this, #_"int" blockID, #_"int" local]
            (let [
                #_"long" bit (<< 1 local)
            ]
                (when (zero? (& (nth (:localsLiveKill this) blockID) bit))
                    (aswap (:localsLiveGen this) blockID | bit)
                )
            )
            nil
        )

        (#_"void" LocalLiveness'''storeOne-3 [#_"SmallLocalLiveness" this, #_"int" blockID, #_"int" local]
            (let [
                #_"long" bit (<< 1 local)
            ]
                (when (zero? (& (nth (:localsLiveGen this) blockID) bit))
                    (aswap (:localsLiveKill this) blockID | bit)
                )
                (loop-when-recur [#_"long" loops (:loops (nth (:blocks this) blockID)) #_"int" i 0] (not (zero? loops)) [(>>> loops 1) (inc i)]
                    (when (= (& loops 1) 1)
                        (aswap (:localsChangedInLoop this) i | bit)
                    )
                )
            )
            nil
        )

        (#_"boolean" LocalLiveness'''localIsLiveIn-3 [#_"SmallLocalLiveness" this, #_"BciBlock" block, #_"int" local]
            (and (< (:id block) Integer/MAX_VALUE) (not (zero? (& (nth (:localsLiveIn this) (:id block)) (<< 1 local)))))
        )

        (#_"boolean" LocalLiveness'''localIsLiveOut-3 [#_"SmallLocalLiveness" this, #_"BciBlock" block, #_"int" local]
            (and (< (:id block) Integer/MAX_VALUE) (not (zero? (& (nth (:localsLiveOut this) (:id block)) (<< 1 local)))))
        )

        (#_"boolean" LocalLiveness'''localIsChangedInLoop-3 [#_"SmallLocalLiveness" this, #_"int" loopId, #_"int" local]
            (not (zero? (& (nth (:localsChangedInLoop this) loopId) (<< 1 local))))
        )
    )
)

(class-ns LocationIdentity []
    ;;;
     ; Creates a new location identity. Subclasses are responsible to provide proper implementations
     ; of {@link #equals} and {@link #hashCode}.
     ;
     ; @param immutable true if the location is immutable
     ;;
    (defn #_"LocationIdentity" LocationIdentity'new-1 [#_"boolean" immutable]
        (merge (LocationIdentity'class.)
            (hash-map
                ;;;
                 ; Denotes a location is unchanging in all cases. Not that this is different than
                 ; the Java notion of final which only requires definite assignment.
                 ;;
                #_"boolean" :immutable immutable
            )
        )
    )

    ;;;
     ; Indicates that the given location is the union of all possible mutable locations. A write to
     ; such a location kill all reads from mutable locations and a read from this location is killed
     ; by any write (except for initialization writes).
     ;;
    (def #_"LocationIdentity" LocationIdentity'ANY (LocationIdentity'new-1 false))

    ;;;
     ; Location only allowed to be used for writes. Indicates that a completely new memory location
     ; is written. Kills no read. The previous value at the given location must be either
     ; uninitialized or null. Writes to this location do not need a GC pre-barrier.
     ;;
    (def #_"LocationIdentity" LocationIdentity'INIT (LocationIdentity'new-1 true))

    ;;;
     ; Returns true if this location identity is {@link #any}.
     ;;
    (defn #_"boolean" LocationIdentity''isAny-1 [#_"LocationIdentity" this]
        (= this LocationIdentity'ANY)
    )

    ;;;
     ; Returns true if this location identity is {@link #init}.
     ;;
    (defn #_"boolean" LocationIdentity''isInit-1 [#_"LocationIdentity" this]
        (= this LocationIdentity'INIT)
    )

    ;;;
     ; Returns true if this location identity is not {@link #any}.
     ;;
    (defn #_"boolean" LocationIdentity''isSingle-1 [#_"LocationIdentity" this]
        (not= this LocationIdentity'ANY)
    )

    ;;;
     ; Returns true if the memory slice denoted by this location identity may overlap with the other.
     ;;
    (defn #_"boolean" LocationIdentity''overlaps-2 [#_"LocationIdentity" this, #_"LocationIdentity" other]
        (or (LocationIdentity''isAny-1 this) (LocationIdentity''isAny-1 other) (= this other))
    )
)

(class-ns FieldLocationIdentity [LocationIdentity]
    (defn #_"FieldLocationIdentity" FieldLocationIdentity'new-1 [#_"ResolvedJavaField" inner]
        (merge (FieldLocationIdentity'class.) (LocationIdentity'new-1 false)
            (hash-map
                #_"ResolvedJavaField" :inner inner
            )
        )
    )
)

;;;
 ; A LocationIdentity with a name.
 ;;
(class-ns NamedLocationIdentity [LocationIdentity]
    ;;;
     ; Creates a named unique location identity for read and write operations.
     ;
     ; @param name the name of the new location identity
     ; @param immutable true if the location is immutable
     ;;
    (defn- #_"NamedLocationIdentity" NamedLocationIdentity'new-2 [#_"String" name, #_"boolean" immutable]
        (merge (NamedLocationIdentity'class.) (LocationIdentity'new-1 immutable)
            (hash-map
                #_"String" :name name
            )
        )
    )

    ;;;
     ; Creates a named unique location identity for read and write operations against mutable memory.
     ;
     ; @param name the name of the new location identity
     ;;
    (defn #_"NamedLocationIdentity" NamedLocationIdentity'mutable-1 [#_"String" name]
        (NamedLocationIdentity'new-2 name, false)
    )

    ;;;
     ; Creates a named unique location identity for read operations against immutable memory.
     ; Immutable memory will never have a visible write in the graph, which is more restrictive than Java final.
     ;
     ; @param name the name of the new location identity
     ;;
    (defn #_"NamedLocationIdentity" NamedLocationIdentity'immutable-1 [#_"String" name]
        (NamedLocationIdentity'new-2 name, true)
    )

    ;;;
     ; Denotes the location of the length field of a Java array.
     ;;
    (def #_"LocationIdentity" NamedLocationIdentity'ARRAY_LENGTH (NamedLocationIdentity'immutable-1 "[].length"))

    (def- #_"EnumMap<JavaKind, LocationIdentity>" NamedLocationIdentity'ARRAY
        (let [
            #_"EnumMap<JavaKind, LocationIdentity>" m (EnumMap. JavaKind)
        ]
            (doseq [#_"JavaKind" kind (JavaKind/values)]
                (#_"EnumMap" .put m, kind, (NamedLocationIdentity'mutable-1 (str "Array: " (#_"JavaKind" .getJavaName kind))))
            )
            m
        )
    )

    ;;;
     ; Returns the named location identity for an array of the given element kind. Array accesses of
     ; the same kind must have the same location identity unless an alias analysis guarantees that
     ; two distinct arrays are accessed.
     ;;
    (defn #_"LocationIdentity" NamedLocationIdentity'getArrayLocation-1 [#_"JavaKind" elementKind]
        (get NamedLocationIdentity'ARRAY elementKind)
    )

    (def- #_"EnumMap<JavaKind, LocationIdentity>" NamedLocationIdentity'UNBOX
        (let [
            #_"EnumMap<JavaKind, LocationIdentity>" m (EnumMap. JavaKind)
        ]
            (doseq [#_"JavaKind" kind (JavaKind/values)]
                (#_"EnumMap" .put m, kind, (NamedLocationIdentity'immutable-1 (str "Unbox: " (#_"JavaKind" .getJavaName kind))))
            )
            m
        )
    )

    (defn #_"LocationIdentity" NamedLocationIdentity'getUnboxLocation-1 [#_"JavaKind" elementKind]
        (get NamedLocationIdentity'UNBOX elementKind)
    )

    (def #_"LocationIdentity" NamedLocationIdentity'TLAB_TOP (NamedLocationIdentity'mutable-1 "TlabTop"))
    (def #_"LocationIdentity" NamedLocationIdentity'TLAB_END (NamedLocationIdentity'mutable-1 "TlabEnd"))

    (def #_"LocationIdentity" NamedLocationIdentity'PENDING_EXCEPTION      (NamedLocationIdentity'mutable-1 "PendingException"))
    (def #_"LocationIdentity" NamedLocationIdentity'PENDING_DEOPTIMIZATION (NamedLocationIdentity'mutable-1 "PendingDeoptimization"))
    (def #_"LocationIdentity" NamedLocationIdentity'OBJECT_RESULT          (NamedLocationIdentity'mutable-1 "ObjectResult"))

    (def #_"LocationIdentity" NamedLocationIdentity'PROTOTYPE_MARK_WORD (NamedLocationIdentity'mutable-1 "PrototypeMarkWord"))

    (def #_"LocationIdentity" NamedLocationIdentity'MARK_WORD (NamedLocationIdentity'mutable-1 "MarkWord"))
    (def #_"LocationIdentity" NamedLocationIdentity'HUB_WRITE (NamedLocationIdentity'mutable-1 "Hub:write"))

    (def #_"LocationIdentity" NamedLocationIdentity'HUB
        (ยง proxy #_"CanonicalizableLocation" (CanonicalizableLocation'new-1 "Hub")
            (#_"ValueNode" CanonicalizableLocation'''canonicalizeRead-4 [#_"CanonicalizableLocation" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object]
                (let [
                    #_"TypeReference" constantType (StampTool'typeReferenceOrNull-1 (:stamp object))
                ]
                    (when (and (some? constantType) (:exactReference constantType)) => read
                        (ConstantNode'forConstant-2s (:stamp read), (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type constantType)))
                    )
                )
            )
        )
    )

    (def #_"LocationIdentity" NamedLocationIdentity'COMPRESSED_HUB
        (ยง proxy #_"CanonicalizableLocation" (CanonicalizableLocation'new-1 "CompressedHub")
            (#_"ValueNode" CanonicalizableLocation'''canonicalizeRead-4 [#_"CanonicalizableLocation" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object]
                (let [
                    #_"TypeReference" constantType (StampTool'typeReferenceOrNull-1 (:stamp object))
                ]
                    (when (and (some? constantType) (:exactReference constantType)) => read
                        (ConstantNode'forConstant-2s (:stamp read), (#_"HotSpotMetaspaceConstant" .compress (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type constantType))))
                    )
                )
            )
        )
    )

    (def #_"LocationIdentity" NamedLocationIdentity'KLASS_SUPER_CHECK_OFFSET (NamedLocationIdentity'immutable-1 "Klass::_super_check_offset"))
    (def #_"LocationIdentity" NamedLocationIdentity'SECONDARY_SUPER_CACHE    (NamedLocationIdentity'mutable-1   "SecondarySuperCache"))
    (def #_"LocationIdentity" NamedLocationIdentity'SECONDARY_SUPERS         (NamedLocationIdentity'immutable-1 "SecondarySupers"))

    (def #_"LocationIdentity" NamedLocationIdentity'DISPLACED_MARK_WORD       (NamedLocationIdentity'mutable-1 "DisplacedMarkWord"))
    (def #_"LocationIdentity" NamedLocationIdentity'OBJECT_MONITOR_OWNER      (NamedLocationIdentity'mutable-1 "ObjectMonitor::_owner"))
    (def #_"LocationIdentity" NamedLocationIdentity'OBJECT_MONITOR_RECURSION  (NamedLocationIdentity'mutable-1 "ObjectMonitor::_recursions"))
    (def #_"LocationIdentity" NamedLocationIdentity'OBJECT_MONITOR_CXQ        (NamedLocationIdentity'mutable-1 "ObjectMonitor::_cxq"))
    (def #_"LocationIdentity" NamedLocationIdentity'OBJECT_MONITOR_ENTRY_LIST (NamedLocationIdentity'mutable-1 "ObjectMonitor::_EntryList"))

    (def #_"LocationIdentity" NamedLocationIdentity'CLASS_KLASS
        (ยง proxy #_"CanonicalizableLocation" (CanonicalizableLocation'new-1 "Class._klass")
            (#_"ValueNode" CanonicalizableLocation'''canonicalizeRead-4 [#_"CanonicalizableLocation" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object]
                (CanonicalizableLocation'foldIndirection-3 read, object, NamedLocationIdentity'CLASS_MIRROR)
            )
        )
    )

    (def #_"LocationIdentity" NamedLocationIdentity'CLASS_MIRROR        (NamedLocationIdentity'immutable-1 "Klass::_java_mirror"))
    (def #_"LocationIdentity" NamedLocationIdentity'CLASS_MIRROR_HANDLE (NamedLocationIdentity'immutable-1 "Klass::_java_mirror handle"))

    (def #_"LocationIdentity" NamedLocationIdentity'OBJ_ARRAY_KLASS_ELEMENT_KLASS
        (ยง proxy #_"CanonicalizableLocation" (CanonicalizableLocation'new-1 "ObjArrayKlass::_element_klass")
            (#_"ValueNode" CanonicalizableLocation'''canonicalizeRead-4 [#_"CanonicalizableLocation" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object]
                read
            )
        )
    )

    (def #_"LocationIdentity" NamedLocationIdentity'PRIMARY_SUPERS           (NamedLocationIdentity'immutable-1 "PrimarySupers"))
    (def #_"LocationIdentity" NamedLocationIdentity'METASPACE_ARRAY_LENGTH   (NamedLocationIdentity'immutable-1 "MetaspaceArrayLength"))
    (def #_"LocationIdentity" NamedLocationIdentity'SECONDARY_SUPERS_ELEMENT (NamedLocationIdentity'immutable-1 "SecondarySupersElement"))

    (def #_"LocationIdentity" NamedLocationIdentity'GC_CARD (NamedLocationIdentity'mutable-1 "GC-Card"))
    (def #_"LocationIdentity" NamedLocationIdentity'GC_LOG (NamedLocationIdentity'mutable-1 "GC-Log"))
    (def #_"LocationIdentity" NamedLocationIdentity'GC_INDEX (NamedLocationIdentity'mutable-1 "GC-Index"))
)

(class-ns CanonicalizableLocation [NamedLocationIdentity, LocationIdentity]
    (defn #_"CanonicalizableLocation" CanonicalizableLocation'new-1 [#_"String" name]
        (merge (CanonicalizableLocation'class.) (NamedLocationIdentity'new-2 name, true))
    )

    ;;;
     ; Fold reads that convert from Class -> Hub -> Class or vice versa.
     ;
     ; @return an earlier read or the original {@code read}
     ;;
    (defn #_"ValueNode" CanonicalizableLocation'foldIndirection-3 [#_"ValueNode" read, #_"ValueNode" object, #_"LocationIdentity" otherLocation]
        (when (and (satisfies? Access object) (= (Access'''getLocationIdentity-1 object) otherLocation)) => read
            (let [
                #_"AddressNode" address (Access'''getAddress-1 object)
            ]
                (when (satisfies? OffsetAddressNode address) => read
                    (AddressNode'''getBase-1 address)
                )
            )
        )
    )
)

(class-ns LocationSet []
    (defn #_"LocationSet" LocationSet'new-0 []
        (merge (LocationSet'class.)
            (hash-map
                #_"LocationIdentity" :firstLocation nil
                #_"List<LocationIdentity>" :list nil
            )
        )
    )

    (defn #_"boolean" LocationSet''isAny-1 [#_"LocationSet" this]
        (and (some? (:firstLocation this)) (LocationIdentity''isAny-1 (:firstLocation this)))
    )

    (defn #_"LocationSet" LocationSet''add-2 [#_"LocationSet" this, #_"LocationIdentity" location]
        (cond
            (LocationSet''isAny-1 this)        this
            (LocationSet''isAny-1 location)    (assoc this :firstLocation location :list nil)
            (:immutable location)              this
            (nil? (:firstLocation this))       (assoc this :firstLocation location)
            (= location (:firstLocation this)) this
            :else
                (let [
                    this
                        (when (nil? (:list this)) => this
                            (assoc this :list (ArrayList.))
                        )
                ]
                    (loop-when [#_"int" i 0] (< i (count (:list this))) => (#_"List" .add (:list this), location)
                        (when-not (= (nth (:list this) i) location)
                            (recur (inc i))
                        )
                    )
                    this
                )
        )
    )

    (defn #_"this" LocationSet''addAll-2 [#_"LocationSet" this, #_"LocationSet" other]
        (let [
            this
                (when (some? (:firstLocation other)) => this
                    (LocationSet''add-2 this, (:firstLocation other))
                )
        ]
            (doseq [#_"LocationIdentity" l (:list other)]
                (ยง ass! this (LocationSet''add-2 this, l))
            )
            this
        )
    )

    (defn #_"boolean" LocationSet''contains-2 [#_"LocationSet" this, #_"LocationIdentity" location]
        (or (any = (:firstLocation this) LocationIdentity'ANY location)
            (and (some? (:list this))
                (loop-when [#_"int" i 0] (< i (count (:list this))) => false
                    (or (= location (nth (:list this) i))
                        (recur (inc i))
                    )
                )
            )
        )
    )
)

(class-ns LockEliminationPhase [Phase]
    (defn #_"LockEliminationPhase" LockEliminationPhase'new-0 []
        (LockEliminationPhase'class.)
    )

    (defm LockEliminationPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LockEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (doseq [#_"MonitorExitNode" monitorExitNode (Graph''getNodes-2 graph, MonitorExitNode)]
                (let [
                    #_"FixedNode" _next (:next monitorExitNode)
                ]
                    (when (or (satisfies? MonitorEnterNode _next) (satisfies? RawMonitorEnterNode _next))
                        ;; should never happen, osr monitor enters are always direct successors of the graph start
                        (let [
                            #_"AccessMonitorNode" monitorEnterNode _next
                        ]
                            (when (= (GraphUtil'unproxify-1n (:object monitorEnterNode)) (GraphUtil'unproxify-1n (:object monitorExitNode)))
                                ;; We've coarsened the lock so use the same monitor id for the whole region,
                                ;; otherwise the monitor operations appear to be unrelated.
                                (let [
                                    #_"MonitorIdNode" enterId (:monitorId monitorEnterNode)
                                    #_"MonitorIdNode" exitId (:monitorId monitorExitNode)
                                ]
                                    (when-not (= enterId exitId)
                                        (ยง ass! enterId (Node''replaceAndDelete-2 enterId, exitId))
                                    )
                                    (GraphUtil'removeFixedWithUnusedInputs-1 monitorEnterNode)
                                    (GraphUtil'removeFixedWithUnusedInputs-1 monitorExitNode)
                                )
                            )
                        )
                    )
                )
            )
            graph
        )
    )
)

(class-ns LockStackHolder []
    (defn #_"LockStackHolder" LockStackHolder'new-1 [#_"LockStack" lockStack]
        (merge (LockStackHolder'class.)
            (hash-map
                #_"LockStack" :lockStack lockStack
            )
        )
    )
)

;;;
 ; The class implements a simple linked list of MonitorIdNodes, which can be used to describe the
 ; current lock state of an object.
 ;;
(class-ns LockState []
    (defn #_"LockState" LockState'new-2 [#_"MonitorIdNode" monitorId, #_"LockState" _next]
        (merge (LockState'class.)
            (hash-map
                #_"MonitorIdNode" :monitorId monitorId
                #_"LockState" :next _next
            )
        )
    )

    (defn #_"List<MonitorIdNode>" LockState'asList-1 [#_"LockState" state]
        (when (some? state) => (Collections/emptyList)
            (let [
                #_"ArrayList<MonitorIdNode>" list (ArrayList.)
            ]
                (loop [state state]
                    (#_"ArrayList" .add list, (:monitorId state))
                    (let [
                        state (:next state)
                    ]
                        (recur-if (some? state) [state] => list)
                    )
                )
            )
        )
    )
)

(class-ns Loop []
    (defn #_"Loop" Loop'new-3 [#_"Loop" parent, #_"int" index, #_"Block" header]
        (merge (Loop'class.)
            (hash-map
                #_"Loop" :parent parent
                #_"List<Loop>" :children (ArrayList.)
                #_"int" :depth (if (some? parent) (inc (:depth parent)) 1)
                #_"int" :index index
                #_"Block" :header header
                #_"List<Block>" :blocks (ArrayList.)
                #_"List<Block>" :exits (ArrayList.)
                #_"LocationSet" :killLocations nil
            )
        )
    )

    (defn #_"long" Loop''numBackedges-1 [#_"Loop" this]
        (count (LoopBeginNode''loopEnds-1 (:beginNode (:header this))))
    )

    (defn #_"void" Loop''addExit-2 [#_"Loop" this, #_"Block" block]
        (#_"List" .add (:exits this), block)
        nil
    )

    (defn #_"LocationSet" Loop''getKillLocations-1 [#_"Loop" this]
        (when (nil? (:killLocations this))
            (ยง ass! this (assoc this :killLocations (LocationSet'new-0)))
            (loop-when [#_"ISeq" s (seq (:blocks this))] (some? s)
                (let [
                    #_"Block" block (first s)
                ]
                    (when (= (:loop block) this) => (recur (next s))
                        (ยง ass! (:killLocations this) (LocationSet''addAll-2 (:killLocations this), (Block''getKillLocations-1 block)))
                        (when-not (LocationSet''isAny-1 (:killLocations this))
                            (recur (next s))
                        )
                    )
                )
            )
        )
        (loop-when [#_"ISeq" s (seq (:children this))] (some? s)
            (let [
                #_"Loop" child (first s)
            ]
                (when-not (LocationSet''isAny-1 (:killLocations this))
                    (ยง ass! (:killLocations this) (LocationSet''addAll-2 (:killLocations this), (Loop''getKillLocations-1 child)))
                    (recur (next s))
                )
            )
        )
        (:killLocations this)
    )

    (defn #_"boolean" Loop''canKill-2 [#_"Loop" this, #_"LocationIdentity" location]
        (LocationSet''contains-2 (Loop''getKillLocations-1 this), location)
    )
)

(class-ns LoopEx []
    (defn #_"LoopEx" LoopEx'new-2 [#_"Loop" _loop, #_"LoopsData" data]
        (merge (LoopEx'class.)
            (hash-map
                #_"Loop" :loop _loop
                #_"LoopFragmentInside" :inside nil
                #_"LoopFragmentWhole" :whole nil
                #_"CountedLoopInfo" :counted nil
                #_"LoopsData" :data data
                #_"EconomicMap<Node, InductionVariable>" :ivs nil
            )
        )
    )

    (defn #_"LoopFragmentInside" LoopEx''inside-1 [#_"LoopEx" this]
        (when (nil? (:inside this))
            (ยง ass! this (assoc this :inside (LoopFragmentInside'new-1e this)))
        )
        (:inside this)
    )

    (defn #_"LoopFragmentWhole" LoopEx''whole-1 [#_"LoopEx" this]
        (when (nil? (:whole this))
            (ยง ass! this (assoc this :whole (LoopFragmentWhole'new-1e this)))
        )
        (:whole this)
    )

    (defn #_"this" LoopEx''invalidateFragments-1 [#_"LoopEx" this]
        (let [
            this (assoc this :inside nil)
            this (assoc this :whole nil)
        ]
            this
        )
    )

    (defn #_"boolean" LoopEx''isOutsideLoop-2 [#_"LoopEx" this, #_"Node" node]
        (not (LoopFragment''contains-2 (LoopEx''whole-1 this), node))
    )

    (defn #_"LoopBeginNode" LoopEx''loopBegin-1 [#_"LoopEx" this]
        (:beginNode (:header (:loop this)))
    )

    (defn #_"FixedNode" LoopEx''entryPoint-1 [#_"LoopEx" this]
        (LoopBeginNode''forwardEnd-1 (LoopEx''loopBegin-1 this))
    )

    (defn #_"boolean" LoopEx''isCounted-1 [#_"LoopEx" this]
        (some? (:counted this))
    )

    (defn #_"int" LoopEx''size-1 [#_"LoopEx" this]
        (count (LoopFragment'''nodes-1 (LoopEx''whole-1 this)))
    )

    (defn #_"boolean" LoopEx''reassociateInvariants-1 [#_"LoopEx" this]
        (let [
            #_"Graph" graph (:graph (LoopEx''loopBegin-1 this))
            #_"InvariantPredicate" invariant (InvariantPredicate'new-1 this)
        ]
            (loop-when [#_"int" n 0 #_"ISeq" s (seq (filter #(satisfies? BinaryArithmeticNode %) (LoopFragment'''nodes-1 (LoopEx''whole-1 this))))] (some? s) => (pos? n)
                (let [
                    #_"BinaryArithmeticNode" binary (first s)
                    n
                        (when (BinaryArithmeticNode'''isAssociative-1 binary) => n
                            (let [
                                #_"ValueNode" result (BinaryArithmeticNode'reassociate-4 binary, invariant, (:x binary), (:y binary))
                            ]
                                (when-not (= result binary) => n
                                    (let [
                                        result
                                            (when-not (Node''isAlive-1 result) => result
                                                (Graph''addOrUniqueWithInputs-2 graph, result)
                                            )
                                    ]
                                        (ยง ass! binary (Node''replaceAtUsages-2 binary, result))
                                        (GraphUtil'killWithUnusedFloatingInputs-1 binary)
                                        (inc n)
                                    )
                                )
                            )
                        )
                ]
                    (recur n (next s))
                )
            )
        )
    )

    (defn #_"boolean" LoopEx''detectCounted-1 [#_"LoopEx" this]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 this)
            #_"FixedNode" _next
                (loop-when-recur [_next (:next loopBegin)]
                                 (or (satisfies? FixedGuardNode _next) (satisfies? ValueAnchorNode _next))
                                 [(:next _next)]
                              => _next
                )
        ]
            (and (satisfies? IfNode _next)
                (let [
                    #_"IfNode" ifNode _next
                    #_"boolean" negated? false
                ]
                    (when-not (LoopBeginNode''isLoopExit-2 loopBegin, (:falseSuccessor ifNode))
                        (when-not (LoopBeginNode''isLoopExit-2 loopBegin, (:trueSuccessor ifNode))
                            (ยง return false)
                        )
                        (ยง ass negated? true)
                    )
                    (let [
                        #_"LogicNode" logic (:logic ifNode)
                    ]
                        (and (or (satisfies? IntegerLessThanNode logic) (satisfies? IntegerEqualsNode logic))
                            (let [
                                [#_"InductionVariable" iv #_"Condition" condition #_"ValueNode" limit]
                                    (cond
                                        (LoopEx''isOutsideLoop-2 this, (:x logic))
                                            (let [
                                                iv (get (LoopEx''getInductionVariables-1 this) (:y logic))
                                            ]
                                                (when (some? iv)
                                                    [iv (Condition''mirror-1 (:canonical (:condition logic))) (:x logic)]
                                                )
                                            )
                                        (LoopEx''isOutsideLoop-2 this, (:y logic))
                                            (let [
                                                iv (get (LoopEx''getInductionVariables-1 this) (:x logic))
                                            ]
                                                (when (some? iv)
                                                    [iv (:canonical (:condition logic)) (:y logic)]
                                                )
                                            )
                                    )
                            ]
                                (and (some? condition)
                                    (let [
                                        condition (if negated? (Condition''negate-1 condition) condition)
                                        #_"boolean" oneOff (ยง tbd )
                                    ]
                                        (condp = condition
                                            Condition'EQ
                                                (ยง return false)
                                            Condition'NE
                                            (do
                                                (when-not (and (InductionVariable'''isConstantStride-1 iv) (= (abs (InductionVariable'''constantStride-1 iv)) 1))
                                                    (ยง return false)
                                                )
                                                (let [
                                                    #_"IntegerStamp" initStamp (:stamp (InductionVariable'''initNode-1 iv))
                                                    #_"IntegerStamp" limitStamp (:stamp limit)
                                                ]
                                                    (case (InductionVariable'''direction-1 iv)
                                                        :Direction'Up
                                                        (do
                                                            (when (< (:lowerBound limitStamp) (:upperBound initStamp))
                                                                (ยง return false)
                                                            )
                                                            (ยง ass oneOff false)
                                                        )
                                                        :Direction'Down
                                                        (do
                                                            (when (< (:lowerBound initStamp) (:upperBound limitStamp))
                                                                (ยง return false)
                                                            )
                                                            (ยง ass oneOff false)
                                                        )
                                                        (ยง return false)
                                                    )
                                                )
                                            )
                                            Condition'LE
                                            (do
                                                (when-not (= (InductionVariable'''direction-1 iv) :Direction'Up)
                                                    (ยง return false)
                                                )
                                                (ยง ass oneOff true)
                                            )
                                            Condition'LT
                                            (do
                                                (when-not (= (InductionVariable'''direction-1 iv) :Direction'Up)
                                                    (ยง return false)
                                                )
                                                (ยง ass oneOff false)
                                            )
                                            Condition'GE
                                            (do
                                                (when-not (= (InductionVariable'''direction-1 iv) :Direction'Down)
                                                    (ยง return false)
                                                )
                                                (ยง ass oneOff true)
                                            )
                                            Condition'GT
                                            (do
                                                (when-not (= (InductionVariable'''direction-1 iv) :Direction'Down)
                                                    (ยง return false)
                                                )
                                                (ยง ass oneOff false)
                                            )
                                        )
                                        (ยง ass! this (assoc this :counted (CountedLoopInfo'new-6 this, iv, ifNode, limit, oneOff, (if negated? (:falseSuccessor ifNode) (:trueSuccessor ifNode)))))
                                        true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" LoopEx''nodesInLoopBranch-3 [#_"LoopEx" this, #_"NodeBitMap" branchNodes, #_"AbstractBeginNode" branch]
        (let [
            #_"EconomicSet<AbstractBeginNode>" blocks (EconomicSet/create)
            #_"Collection<AbstractBeginNode>" exits (LinkedList.)
            #_"Queue<Block>" work (LinkedList.)
        ]
            (#_"Queue" .add work, (ControlFlowGraph''blockFor-2 (:cfg (:data this)), branch))
            (while (not (#_"Queue" .isEmpty work))
                (let [
                    #_"Block" b (#_"Queue" .remove work)
                ]
                    (cond
                        (#_"List" .contains (:exits (:loop this)), b)
                            (#_"Collection" .add exits, (:beginNode b))
                        (#_"EconomicSet" .add blocks, (:beginNode b))
                            (loop-when-recur [#_"Block" d (:dominatedSibling b)] (some? d) [(:dominatedSibling d)]
                                (when (#_"List" .contains (:blocks (:loop this)), d)
                                    (#_"Queue" .add work, d)
                                )
                            )
                    )
                )
            )
            (ยง ass! branchNodes (LoopFragment'computeNodes-4 branchNodes, (:graph branch), blocks, exits))
        )
        nil
    )

    (defn- #_"ValueNode" LoopEx'addSub-3 [#_"LoopEx" _loop, #_"ValueNode" op, #_"ValueNode" base]
        (when (and (satisfies? IntegerStamp (:stamp op)) (or (satisfies? AddNode op) (satisfies? SubNode op)))
            (cond
                (and (= (:x op) base) (LoopEx''isOutsideLoop-2 _loop, (:y op))) (:y op)
                (and (= (:y op) base) (LoopEx''isOutsideLoop-2 _loop, (:x op))) (:x op)
            )
        )
    )

    (defn- #_"ValueNode" LoopEx'mul-3 [#_"LoopEx" _loop, #_"ValueNode" op, #_"ValueNode" base]
        (condp satisfies? op
            MulNode
                (cond
                    (and (= (:x op) base) (LoopEx''isOutsideLoop-2 _loop, (:y op))) (:y op)
                    (and (= (:y op) base) (LoopEx''isOutsideLoop-2 _loop, (:x op))) (:x op)
                )
            LeftShiftNode
                (when (and (= (:x op) base) (satisfies? ConstantNode (:y op)))
                    (ConstantNode'forIntegerStamp-3 (:stamp base), (<< 1 (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y op)))), (:graph base))
                )
            nil
        )
    )

    ;;;
     ; Collect all the basic induction variables for the loop and the find any induction variables
     ; which are derived from the basic ones.
     ;
     ; @return a map from node to induction variable
     ;;
    (defn- #_"EconomicMap<Node, InductionVariable>" LoopEx'findInductionVariables-1 [#_"LoopEx" _loop]
        (let [
            #_"EconomicMap<Node, InductionVariable>" ivs (EconomicMap/create)
            #_"Queue<InductionVariable>" scanQueue (LinkedList.)
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 _loop)
            #_"AbstractEndNode" forwardEnd (LoopBeginNode''forwardEnd-1 loopBegin)
        ]
            (doseq [#_"PhiNode" phi (AbstractMergeNode''valuePhis-1 loopBegin)]
                (let [
                    #_"ValueNode" backValue (PhiNode''singleBackValueOrThis-1 phi)
                ]
                    (when-not (= backValue phi)
                        (let [
                            #_"ValueNode" stride (LoopEx'addSub-3 _loop, backValue, phi)
                        ]
                            (when (some? stride)
                                (let [
                                    #_"BasicInductionVariable" biv (BasicInductionVariable'new-5 _loop, phi, (PhiNode''valueAt-2n phi, forwardEnd), stride, backValue)
                                ]
                                    (#_"EconomicMap" .put ivs, phi, biv)
                                    (#_"Queue" .add scanQueue, biv)
                                )
                            )
                        )
                    )
                )
            )
            (while (not (#_"Queue" .isEmpty scanQueue))
                (let [
                    #_"InductionVariable" baseIv (#_"Queue" .remove scanQueue)
                    #_"ValueNode" baseIvNode (InductionVariable'''valueNode-1 baseIv)
                ]
                    (doseq [#_"ValueNode" op (filter #(satisfies? ValueNode %) (:nodeUsages baseIvNode))]
                        (cond
                            (LoopEx''isOutsideLoop-2 _loop, op)
                                nil
                            (and (Node''hasExactlyOneUsage-1 op) (= (first (:nodeUsages op)) baseIvNode))
                                nil ;; This is just the base induction variable increment with no other uses, so don't bother reporting it.
                            :else
                                (let [
                                    #_"ValueNode" offset (LoopEx'addSub-3 _loop, op, baseIvNode)
                                    #_"InductionVariable" iv
                                        (cond
                                            (some? offset)             (DerivedOffsetInductionVariable'new-4 _loop, baseIv, offset, op)
                                            (satisfies? NegateNode op) (DerivedScaledInductionVariable'new-3 _loop, baseIv,         op)
                                            :else
                                                (let [
                                                    #_"ValueNode" scale (LoopEx'mul-3 _loop, op, baseIvNode)
                                                ]
                                                    (cond
                                                        (some? scale) (DerivedScaledInductionVariable'new-4 _loop, baseIv, scale, op)
                                                        :else
                                                            (let [
                                                                #_"boolean" valid? (or (satisfies? PiNode op) (satisfies? SignExtendNode op))
                                                                valid?
                                                                    (when (and (not valid?) (satisfies? ZeroExtendNode op)) => valid?
                                                                        (or (:inputAlwaysPositive op) (IntegerStamp''isPositive-1 (:stamp op)))
                                                                    )
                                                            ]
                                                                (when valid?
                                                                    (DerivedConvertedInductionVariable'new-4 _loop, baseIv, (:stamp op), op)
                                                                )
                                                            )
                                                    )
                                                )
                                        )
                                ]
                                    (when (some? iv)
                                        (#_"EconomicMap" .put ivs, op, iv)
                                        (#_"Queue" .offer scanQueue, iv)
                                    )
                                )
                        )
                    )
                )
            )
            ivs
        )
    )

    (defn #_"EconomicMap<Node, InductionVariable>" LoopEx''getInductionVariables-1 [#_"LoopEx" this]
        (when (nil? (:ivs this))
            (ยง ass! this (assoc this :ivs (LoopEx'findInductionVariables-1 this)))
        )
        (:ivs this)
    )

    ;;;
     ; Deletes any nodes created within the scope of this object that have no usages.
     ;;
    (defn #_"void" LoopEx''deleteUnusedNodes-1 [#_"LoopEx" this]
        (when (some? (:ivs this))
            (doseq [#_"InductionVariable" iv (vals (:ivs this))]
                (InductionVariable'''deleteUnusedNodes-1 iv)
            )
        )
        nil
    )

    ;;;
     ; Returns true if all nodes in the loop can be duplicated.
     ;;
    (defn #_"boolean" LoopEx''canDuplicateLoop-1 [#_"LoopEx" this]
        (loop-when [#_"ISeq" s (seq (LoopFragment'''nodes-1 (LoopEx''inside-1 this)))] (some? s) => true
            (and (not (satisfies? ControlFlowAnchored (first s)))
                (recur (next s))
            )
        )
    )
)

(class-ns LoopFragment []
    (defn #_"LoopFragment" LoopFragment'new-2 [#_"LoopEx" _loop, #_"LoopFragment" original]
        (merge (LoopFragment'class.)
            (hash-map
                ;;;
                 ; The original LoopEx for this fragment. For duplicated fragments this is nil.
                 ;;
                #_"LoopEx" :loop _loop
                #_"LoopFragment" :original original
                #_"NodeBitMap" :nodes nil
                #_"boolean" :nodesReady false
                #_"EconomicMap<Node, Node>" :duplicationMap nil
            )
        )
    )

    (defn #_"LoopFragment" LoopFragment'new-1 [#_"LoopEx" _loop]
        (let [
            #_"LoopFragment" this (merge (LoopFragment'class.) (LoopFragment'new-2 _loop, nil))
            this (assoc this :nodesReady true)
        ]
            this
        )
    )

    (defn #_"boolean" LoopFragment''contains-2 [#_"LoopFragment" this, #_"Node" node]
        (NodeBitMap''isMarkedAndGrow-2 (LoopFragment'''nodes-1 this), node)
    )

    (defn #_"Node" LoopFragment''getDuplicatedNode-2 [#_"LoopFragment" this, #_"Node" node]
        (get (:duplicationMap this) node)
    )

    (defn #_"void" LoopFragment''putDuplicatedNode-3 [#_"LoopFragment" this, #_"Node" oldNode, #_"Node" newNode]
        (#_"EconomicMap" .put (:duplicationMap this), oldNode, newNode)
        nil
    )

    (defn #_"boolean" LoopFragment''isDuplicate-1 [#_"LoopFragment" this]
        (some? (:original this))
    )

    (defn #_"Graph" LoopFragment''graph-1 [#_"LoopFragment" this]
        (:graph (LoopEx''loopBegin-1 (:loop (if (LoopFragment''isDuplicate-1 this) (:original this) this))))
    )

    (defn #_"LoopFragment" LoopFragment''patchNodes-2 [#_"LoopFragment" this, #_"DuplicationReplacement" dataFix]
        (when (and (LoopFragment''isDuplicate-1 this) (not (:nodesReady this))) => this
            (let [
                #_"DuplicationReplacement" cfgFix (LoopFragment'''getDuplicationReplacement-1 (:original this))
                #_"DuplicationReplacement" dr
                    (cond
                        (and (nil? cfgFix) (some? dataFix)) dataFix
                        (and (some? cfgFix) (nil? dataFix)) cfgFix
                        (and (some? cfgFix) (some? dataFix))
                            (reify DuplicationReplacement
                                (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" this, #_"Node" o]
                                    (let [
                                        #_"Node" r1 (DuplicationReplacement'''replacement-2 dataFix, o)
                                    ]
                                        (if-not (= r1 o)
                                            r1
                                            (let [
                                                #_"Node" r2 (DuplicationReplacement'''replacement-2 cfgFix, o)
                                            ]
                                                (if-not (= r2 o)
                                                    r2
                                                    o
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                    )
                _ (LoopFragment'''beforeDuplication-1 this)
                #_"Node*" nodeSeq (LoopFragment'''nodes-1 (:original this))
                this (assoc this :duplicationMap (Graph''addDuplicates-5r (LoopFragment''graph-1 this), nodeSeq, (LoopFragment''graph-1 this), (count nodeSeq), dr))
                _ (LoopFragment'''finishDuplication-1 this)
                this (assoc this :nodes (NodeBitMap'new-1 (LoopFragment''graph-1 this)))
            ]
                (NodeBitMap''markAll-2 (:nodes this), (vals (:duplicationMap this)))
                (assoc this :nodesReady true)
            )
        )
    )

    (defn- #_"void" LoopFragment'markFloating-4 [#_"Deque<WorkListEntry>" workList, #_"Node" start, #_"NodeBitMap" loopNodes, #_"NodeBitMap" nonLoopNodes]
        (when-not (#_"TriState" .isKnown (LoopFragment'isLoopNode-3 start, loopNodes, nonLoopNodes))
            (#_"Deque" .push workList, (WorkListEntry'new-2 start, loopNodes))
            (while (seq workList)
                (let [
                    #_"WorkListEntry" currentEntry (#_"Deque" .peek workList)
                ]
                    (if (seq (:usages currentEntry))
                        (let [
                            #_"Node" current (#_"Iterator" .next (:usages currentEntry))
                            #_"TriState" result (LoopFragment'isLoopNode-3 current, loopNodes, nonLoopNodes)
                        ]
                            (if (#_"TriState" .isKnown result)
                                (when (#_"TriState" .toBoolean result)
                                    (ยง ass currentEntry (assoc currentEntry :isLoopNode true))
                                )
                                (#_"Deque" .push workList, (WorkListEntry'new-2 current, loopNodes))
                            )
                        )
                        (do
                            (#_"Deque" .pop workList)
                            (let [
                                #_"boolean" isLoopNode (:isLoopNode currentEntry)
                                #_"Node" current (:n currentEntry)
                            ]
                                (when (and (not isLoopNode) (satisfies? GuardNode current))
                                    ;; this is only OK if we are not going to make loop transforms based on this
                                    (ยง ass isLoopNode true)
                                )
                                (if isLoopNode
                                    (do
                                        (NodeBitMap''mark-2 loopNodes, current)
                                        (loop-when-recur [#_"ISeq" s (seq workList)] (some? s) [(next s)]
                                            (let [
                                                #_"WorkListEntry" e (first s)
                                            ]
                                                (ยง ass! e (assoc e :isLoopNode true))
                                            )
                                        )
                                    )
                                    (NodeBitMap''mark-2 nonLoopNodes, current)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"NodeBitMap" LoopFragment'computeNodes-4 [#_"NodeBitMap" nodes, #_"Graph" graph, #_"AbstractBeginNode*" blocks, #_"AbstractBeginNode*" earlyExits]
        (doseq [#_"AbstractBeginNode" block blocks]
            (when-not (Node''isDeleted-1 block)
                (doseq [#_"Node" node (AbstractBeginNode''getBlockNodes-1 block)]
                    (when (satisfies? InvokeNode node)
                        (NodeBitMap''mark-2 nodes, (:callTarget node))
                    )
                    (when (satisfies? NodeWithState node)
                        (doseq [#_"FrameState" state (NodeWithState''states-1 node)]
                            (VirtualState'''applyToVirtual-2 state,
                                (reify VirtualClosure
                                    (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs]
                                        (NodeBitMap''mark-2 nodes, vs)
                                        nil
                                    )
                                )
                            )
                        )
                    )
                    (when (satisfies? AbstractMergeNode node)
                        ;; if a merge is in the loop, all of its phis are also in the loop
                        (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 node)]
                            (NodeBitMap''mark-2 nodes, phi)
                        )
                    )
                    (NodeBitMap''mark-2 nodes, node)
                )
            )
        )
        (doseq [#_"AbstractBeginNode" earlyExit earlyExits]
            (when-not (Node''isDeleted-1 earlyExit)
                (NodeBitMap''mark-2 nodes, earlyExit)
                (when (satisfies? LoopExitNode earlyExit)
                    (let [
                        #_"FrameState" stateAfter (:stateAfter earlyExit)
                    ]
                        (when (some? stateAfter)
                            (VirtualState'''applyToVirtual-2 stateAfter,
                                (reify VirtualClosure
                                    (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs]
                                        (NodeBitMap''mark-2 nodes, vs)
                                        nil
                                    )
                                )
                            )
                        )
                        (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 earlyExit)]
                            (NodeBitMap''mark-2 nodes, proxy)
                        )
                    )
                )
            )
        )

        (let [
            #_"NodeBitMap" nonLoopNodes (NodeBitMap'new-1 graph)
            #_"Deque<WorkListEntry>" worklist (ArrayDeque.)
        ]
            (doseq [#_"AbstractBeginNode" block blocks]
                (when-not (Node''isDeleted-1 block)
                    (doseq [#_"Node" node (AbstractBeginNode''getBlockNodes-1 block)]
                        (when (satisfies? CommitAllocationNode node)
                            (doseq [#_"VirtualObjectNode" obj (:virtualObjects node)]
                                (LoopFragment'markFloating-4 worklist, obj, nodes, nonLoopNodes)
                            )
                        )
                        (when (satisfies? MonitorEnterNode node)
                            (LoopFragment'markFloating-4 worklist, (:monitorId node), nodes, nonLoopNodes)
                        )
                        (when (satisfies? AbstractMergeNode node)
                            ;; Since we already marked all phi nodes as being in the loop to break cycles,
                            ;; we also have to iterate over their usages here.
                            (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 node)]
                                (doseq [#_"Node" usage (:nodeUsages phi)]
                                    (LoopFragment'markFloating-4 worklist, usage, nodes, nonLoopNodes)
                                )
                            )
                        )
                        (doseq [#_"Node" usage (:nodeUsages node)]
                            (LoopFragment'markFloating-4 worklist, usage, nodes, nonLoopNodes)
                        )
                    )
                )
            )
            nodes
        )
    )

    (defn #_"NodeBitMap" LoopFragment'computeNodes-3 [#_"Graph" graph, #_"AbstractBeginNode*" blocks, #_"AbstractBeginNode*" earlyExits]
        (LoopFragment'computeNodes-4 (NodeBitMap'new-1 graph), graph, blocks, earlyExits)
    )

    (defn #_"TriState" LoopFragment'isLoopNode-3 [#_"Node" node, #_"NodeBitMap" loopNodes, #_"NodeBitMap" nonLoopNodes]
        (cond
            (NodeBitMap''isMarked-2n loopNodes, node)                  TriState/TRUE
            (NodeBitMap''isMarked-2n nonLoopNodes, node)               TriState/FALSE
            ;; phi nodes are treated the same as fixed nodes in this algorithm to break cycles
            (or (satisfies? FixedNode node) (satisfies? PhiNode node)) TriState/FALSE
            :else                                                      TriState/UNKNOWN
        )
    )

    (defn #_"AbstractBeginNode*" LoopFragment'toHirBlocks-1 [#_"Iterable<Block>" blocks]
        (map :beginNode blocks)
    )

    ;;;
     ; Return the true LoopExitNode for this loop or the BeginNode for the block.
     ;;
    (defn #_"AbstractBeginNode*" LoopFragment'toHirExits-1 [#_"Iterable<Block>" blocks]
        (map #(or (Block''getLoopExit-1 %) (:beginNode %)) blocks)
    )

    ;;;
     ; Merges the early exits (i.e. loop exits) that were duplicated as part of this fragment
     ; with the original fragment's exits.
     ;;
    (defn #_"void" LoopFragment''mergeEarlyExits-1 [#_"LoopFragment" this]
        (let [
            #_"Graph" graph (LoopFragment''graph-1 this)
        ]
            (doseq [#_"AbstractBeginNode" earlyExit (LoopFragment'toHirBlocks-1 (:exits (:loop (:loop (:original this)))))]
                (let [
                    #_"FixedNode" _next (:next earlyExit)
                ]
                    (when (and (not (Node''isDeleted-1 earlyExit)) (LoopFragment''contains-2 (:original this), earlyExit))
                        (let [
                            #_"AbstractBeginNode" newEarlyExit (LoopFragment''getDuplicatedNode-2 this, earlyExit)
                        ]
                            (when (some? newEarlyExit)
                                (let [
                                    #_"MergeNode" merge (Graph''add-2 graph, (MergeNode'new-0))
                                    #_"EndNode" originalEnd (Graph''add-2 graph, (EndNode'new-0))
                                    #_"EndNode" newEnd (Graph''add-2 graph, (EndNode'new-0))
                                ]
                                    (AbstractMergeNode''addForwardEnd-2 merge, originalEnd)
                                    (AbstractMergeNode''addForwardEnd-2 merge, newEnd)
                                    (ยง ass! earlyExit (FixedWithNextNode''setNext-2 earlyExit, originalEnd))
                                    (ยง ass! newEarlyExit (FixedWithNextNode''setNext-2 newEarlyExit, newEnd))
                                    (ยง ass! merge (FixedWithNextNode''setNext-2 merge, _next))

                                    (let [
                                        #_"FrameState" finalExitState
                                            (when-some [#_"FrameState" exitState (:stateAfter earlyExit)]
                                                (let [
                                                    #_"FrameState" o'exitState exitState
                                                    exitState (VirtualState'''duplicateWithVirtualState-1 exitState)
                                                ]
                                                    (StateSplit'''setStateAfter-2 earlyExit, exitState)
                                                    (StateSplit'''setStateAfter-2 merge, o'exitState)
                                                    ;; Using the old exit's state as the merge's state is necessary because some of the VirtualState
                                                    ;; nodes contained in the old exit's state may be shared by other dominated VirtualStates.
                                                    ;; Those dominated virtual states need to see the proxy->phi update that are applied below.
                                                    ;;
                                                    ;; We now update the original fragment's nodes accordingly:
                                                    (let [
                                                        #_"LoopFragment" owner this
                                                    ]
                                                        (VirtualState'''applyToVirtual-2 o'exitState,
                                                            (reify VirtualClosure
                                                                (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs]
                                                                    (ยง ass! (:nodes (:original owner)) (NodeBitMap''clearAndGrow-2 (:nodes (:original owner)), vs))
                                                                    nil
                                                                )
                                                            )
                                                        )
                                                        (VirtualState'''applyToVirtual-2 exitState,
                                                            (reify VirtualClosure
                                                                (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs]
                                                                    (ยง ass! (:nodes (:original owner)) (NodeBitMap''markAndGrow-2 (:nodes (:original owner)), vs))
                                                                    nil
                                                                )
                                                            )
                                                        )
                                                        exitState
                                                    )
                                                )
                                            )
                                    ]
                                        (doseq [#_"Node" anchored (ยง snap (AbstractBeginNode'''anchored-1 earlyExit))]
                                            (Node''replaceFirstInput-3 anchored, earlyExit, merge)
                                        )

                                        (let [
                                            #_"boolean" newEarlyExitIsLoopExit (satisfies? LoopExitNode newEarlyExit)
                                        ]
                                            (doseq [#_"ProxyNode" vpn (ยง snap (LoopExitNode''proxies-1 earlyExit))]
                                                (cond
                                                    (Node''hasNoUsages-1 vpn)  nil
                                                    (nil? (:value vpn)) (ยง ass! vpn (Node''replaceAtUsages-2 vpn, nil))
                                                    :else
                                                        (let [
                                                            #_"ValueNode" newVpn (LoopFragment'''prim-2 this, (if newEarlyExitIsLoopExit vpn (:value vpn)))
                                                            #_"ValueNode" replaceWith
                                                                (when (some? newVpn) => (:value vpn)
                                                                    (let [
                                                                        #_"PhiNode" phi
                                                                            (condp satisfies? vpn
                                                                                ValueProxyNode (ValuePhiNode'new-2 (:stamp vpn), merge)
                                                                                GuardProxyNode (GuardPhiNode'new-1 merge)
                                                                            )
                                                                    ]
                                                                        (Graph''add-2 graph, phi)
                                                                        (PhiNode''addInput-2 phi, vpn)
                                                                        (PhiNode''addInput-2 phi, newVpn)
                                                                        phi
                                                                    )
                                                                )
                                                        ]
                                                            (ยง ass! vpn (Node''replaceAtMatchingUsages-3 vpn, replaceWith,
                                                                (ร (usage) 
                                                                    (ยง fun
                                                                        (not (or (AbstractMergeNode''isPhiAtMerge-2 merge, usage) (and (satisfies? VirtualState usage) (some? finalExitState) (VirtualState'''isPartOfThisState-2 finalExitState, usage))))
                                                                    )
                                                                )
                                                            ))
                                                        )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

(class-ns LoopFragmentInside [LoopFragment]
    (defn- #_"LoopFragmentInside" LoopFragmentInside'init-0 []
        (hash-map
            ;;;
             ; When an inside fragment's (loop)ends are merged to create a unique exit point, some phis
             ; must be created: they phis together all the back-values of the loop-phis. These can then
             ; be used to update the loop-phis' forward edge value ('initializer') in the peeling case.
             ; In the unrolling case they will be used as the value that replace the loop-phis of the
             ; duplicated inside fragment.
             ;;
            #_"EconomicMap<PhiNode, ValueNode>" :mergedInitializers nil
        )
    )

    (defn #_"LoopFragmentInside" LoopFragmentInside'new-1e [#_"LoopEx" _loop]
        (merge (LoopFragmentInside'class.) (LoopFragment'new-1 _loop)
            (LoopFragmentInside'init-0)
        )
    )

    (defn #_"LoopFragmentInside" LoopFragmentInside'new-1f [#_"LoopFragmentInside" original]
        (merge (LoopFragmentInside'class.) (LoopFragment'new-2 nil, original)
            (LoopFragmentInside'init-0)
        )
    )

    (defm LoopFragmentInside LoopFragment
        (#_"LoopFragmentInside" LoopFragment'''duplicate-1 [#_"LoopFragmentInside" this]
            (LoopFragmentInside'new-1f this)
        )
    )

    (defn- #_"PhiNode" LoopFragmentInside'patchPhi-3 [#_"Graph" graph, #_"PhiNode" phi, #_"AbstractMergeNode" merge]
        (let [
            #_"PhiNode" ret
                (condp satisfies? phi
                    ValuePhiNode  (ValuePhiNode'new-2 (:stamp phi), merge)
                    GuardPhiNode  (GuardPhiNode'new-1 merge)
                    MemoryPhiNode (MemoryPhiNode'new-2 merge, (:locationIdentity phi))
                )
        ]
            (Graph''add-2 graph, ret)
        )
    )

    (defn- #_"AbstractBeginNode" LoopFragmentInside''mergeEnds-1 [#_"LoopFragmentInside" this]
        (let [
            #_"List<EndNode>" endsToMerge (LinkedList.)
            ;; map peel exits to the corresponding loop exits
            #_"EconomicMap<AbstractEndNode, LoopEndNode>" reverseEnds (EconomicMap/create)
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
        ]
            (doseq [#_"LoopEndNode" le (LoopBeginNode''loopEnds-1 loopBegin)]
                (let [
                    #_"AbstractEndNode" duplicate (LoopFragment''getDuplicatedNode-2 this, le)
                ]
                    (when (some? duplicate)
                        (#_"List" .add endsToMerge, (ยง cast #_"EndNode" duplicate))
                        (#_"EconomicMap" .put reverseEnds, duplicate, le)
                    )
                )
            )
            (ยง ass! this (assoc this :mergedInitializers (EconomicMap/create)))
            (let [
                #_"Graph" graph (LoopFragment''graph-1 this)
            ]
                (if (= (count endsToMerge) 1)
                    (let [
                        #_"AbstractEndNode" end (nth endsToMerge 0)
                        #_"AbstractBeginNode" newExit (Graph''add-2 graph, (BeginNode'new-0))
                    ]
                        (Node''replaceAtPredecessor-2 end, newExit)
                        (Node''safeDelete-1 end)
                        newExit
                    )
                    (let [
                        #_"AbstractMergeNode" newExitMerge (Graph''add-2 graph, (MergeNode'new-0))
                        #_"AbstractBeginNode" newExit newExitMerge
                        #_"FrameState" state (:stateAfter loopBegin)
                        #_"FrameState" duplicateState
                            (when (some? state)
                                (let [
                                    duplicateState (VirtualState'''duplicateWithVirtualState-1 state)
                                ]
                                    (StateSplit'''setStateAfter-2 newExitMerge, duplicateState)
                                    duplicateState
                                )
                            )
                    ]
                        (doseq [#_"EndNode" end endsToMerge]
                            (AbstractMergeNode''addForwardEnd-2 newExitMerge, end)
                        )

                        (doseq [#_"PhiNode" phi (ยง snap (AbstractMergeNode''phis-1 loopBegin))]
                            (when-not (Node''hasNoUsages-1 phi)
                                (let [
                                    #_"PhiNode" firstPhi (LoopFragmentInside'patchPhi-3 graph, phi, newExitMerge)
                                ]
                                    (doseq [#_"AbstractEndNode" end (:ends newExitMerge)]
                                        (let [
                                            #_"LoopEndNode" loopEnd (get reverseEnds end)
                                            #_"ValueNode" prim (LoopFragment'''prim-2 this, (PhiNode''valueAt-2n phi, loopEnd))
                                        ]
                                            (PhiNode''addInput-2 firstPhi, prim)
                                        )
                                    )
                                    (let [
                                        #_"ValueNode" initializer firstPhi
                                    ]
                                        (when (some? duplicateState)
                                            ;; fix the merge's state after
                                            (VirtualState'''applyToNonVirtual-2 duplicateState,
                                                (ยง proxy #_"NodeClosure" #_"<ValueNode>" (NodeClosure'new-0)
                                                    (defm NodeClosure #_"<ValueNode>" NodeClosure
                                                        (#_"void" NodeClosure'''apply-3 [#_"NodeClosure<ValueNode>" this, #_"Node" from, #_"ValueNode" node]
                                                            (when (= node phi)
                                                                (Node''replaceFirstInput-3 from, phi, firstPhi)
                                                            )
                                                            nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (#_"EconomicMap" .put (:mergedInitializers this), phi, initializer)
                                    )
                                )
                            )
                        )
                        newExit
                    )
                )
            )
        )
    )

    (defn- #_"void" LoopFragmentInside'markStateNodes-2 [#_"StateSplit" stateSplit, #_"NodeBitMap" marks]
        (let [
            #_"FrameState" exitState (:stateAfter stateSplit)
        ]
            (when (some? exitState)
                (VirtualState'''applyToVirtual-2 exitState,
                    (reify VirtualClosure
                        (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs]
                            (ยง ass! marks (NodeBitMap''markAndGrow-2 marks, vs))
                            nil
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" LoopFragmentInside''patchPeeling-2 [#_"LoopFragmentInside" this, #_"LoopFragmentInside" peel]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop this))
            #_"Graph" graph (:graph loopBegin)
            #_"List<PhiNode>" newPhis (LinkedList.)
            #_"NodeBitMap" usagesToPatch (NodeBitMap'copy-1 (:nodes this))
        ]
            (doseq [#_"LoopExitNode" exit (LoopFragmentInside''exits-1 this)]
                (LoopFragmentInside'markStateNodes-2 exit, usagesToPatch)
                (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 exit)]
                    (ยง ass! usagesToPatch (NodeBitMap''markAndGrow-2 usagesToPatch, proxy))
                )
            )
            (LoopFragmentInside'markStateNodes-2 loopBegin, usagesToPatch)

            (let [
                #_"PhiNode*" oldPhis (ยง snap (AbstractMergeNode''phis-1 loopBegin))
            ]
                (doseq [#_"PhiNode" phi oldPhis]
                    (when-not (Node''hasNoUsages-1 phi)
                        (let [
                            #_"ValueNode" _first
                                (if (= (count (LoopBeginNode''loopEnds-1 loopBegin)) 1)
                                    (let [
                                        ;; back edge value
                                        #_"ValueNode" b (PhiNode''valueAt-2n phi, (first (LoopBeginNode''loopEnds-1 loopBegin)))
                                    ]
                                        (LoopFragment'''prim-2 peel, b) ;; corresponding value in the peel
                                    )
                                    (get (:mergedInitializers peel) phi)
                                )
                            ;; create a new phi (we don't patch the old one since some usages of the old one may still be valid)
                            #_"PhiNode" newPhi (LoopFragmentInside'patchPhi-3 graph, phi, loopBegin)
                        ]
                            (PhiNode''addInput-2 newPhi, _first)
                            (doseq [#_"LoopEndNode" end (LoopBeginNode''orderedLoopEnds-1 loopBegin)]
                                (PhiNode''addInput-2 newPhi, (PhiNode''valueAt-2n phi, end))
                            )
                            (LoopFragment''putDuplicatedNode-3 peel, phi, newPhi)
                            (#_"List" .add newPhis, newPhi)
                            (doseq [#_"Node" usage (:nodeUsages phi)]
                                ;; patch only usages that should use the new phi, i.e. usages that were peeled
                                (when (NodeBitMap''isMarkedAndGrow-2 usagesToPatch, usage)
                                    (Node''replaceFirstInput-3 usage, phi, newPhi)
                                )
                            )
                        )
                    )
                )
                ;; check new phis to see if they have as input some old phis, replace those inputs with the new corresponding phis
                (doseq [#_"PhiNode" phi newPhis]
                    (dotimes [#_"int" i (PhiNode''valueCount-1 phi)]
                        (let-when [#_"ValueNode" v (PhiNode''valueAt-2i phi, i)] (AbstractMergeNode''isPhiAtMerge-2 loopBegin, v)
                            (when-some [#_"PhiNode" newV (LoopFragment''getDuplicatedNode-2 peel, v)]
                                (PhiNode''setValueAt-3i phi, i, newV)
                            )
                        )
                    )
                )
                (loop []
                    (let [
                        #_"boolean" progress?
                            (loop-when [progress? false #_"int" i 0] (< i (count oldPhis)) => progress?
                                (let [
                                    [progress? i]
                                        (loop-when [#_"ISeq" s (seq (:nodeUsages (nth oldPhis i)))] (some? s) => [progress? i]
                                            (let [
                                                #_"Node" usage (first s)
                                            ]
                                                (if (and (satisfies? PhiNode usage) (#_"List" .contains oldPhis, usage))
                                                    (recur (next s)) ;; Do not mark.
                                                    (do
                                                        ;; Mark alive by removing from delete set.
                                                        (#_"List" .remove oldPhis, i)
                                                        [true (dec i)]
                                                    )
                                                )
                                            )
                                        )
                                ]
                                    (recur progress? (inc i))
                                )
                            )
                    ]
                        (recur-if progress? [])
                    )
                )
                (doseq [#_"PhiNode" deadPhi oldPhis]
                    (Node''clearInputs-1 deadPhi)
                )
                (doseq [#_"PhiNode" deadPhi oldPhis]
                    (when (Node''isAlive-1 deadPhi)
                        (GraphUtil'killWithUnusedFloatingInputs-1 deadPhi)
                    )
                )
            )
        )
        nil
    )

    (defm LoopFragmentInside LoopFragment
        (#_"void" LoopFragment'''insertBefore-2 [#_"LoopFragmentInside" this, #_"LoopEx" _loop]
            (let [
                #_"LoopFragmentInside" fragments this
                #_"DuplicationReplacement" dataFixBefore
                    (reify DuplicationReplacement
                        (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original]
                            (if (satisfies? ValueNode original) (LoopFragment'''prim-2 fragments, original) original)
                        )
                    )
            ]
                (ยง ass! this (LoopFragment''patchNodes-2 this, dataFixBefore))

                (let [
                    #_"AbstractBeginNode" end (LoopFragmentInside''mergeEnds-1 this)
                ]
                    (LoopFragment''mergeEarlyExits-1 this)

                    (LoopFragmentInside''patchPeeling-2 (:original this), this)

                    (let [
                        #_"AbstractBeginNode" entry (LoopFragment''getDuplicatedNode-2 this, (LoopEx''loopBegin-1 _loop))
                    ]
                        (Node''replaceAtPredecessor-2 (LoopEx''entryPoint-1 _loop), entry)
                        (ยง ass! end (FixedWithNextNode''setNext-2 end, (LoopEx''entryPoint-1 _loop)))
                    )
                )
            )
            nil
        )
    )

    (defn- #_"EndNode" LoopFragmentInside'getBlockEnd-1 [#_"FixedNode" node]
        (loop-when-recur node (satisfies? FixedWithNextNode node) (:next node) => node)
    )

    (defn- #_"void" LoopFragmentInside''placeNewSegmentAndCleanup-2 [#_"LoopFragmentInside" this, #_"LoopEx" _loop]
        (let [
            #_"CountedLoopInfo" mainCounted (:counted _loop)
            #_"LoopBeginNode" mainLoopBegin (LoopEx''loopBegin-1 _loop)
            ;; discard the segment entry and its flow after if merging it into the loop
            #_"Graph" graph (:graph mainLoopBegin)
            #_"IfNode" loopTest (:ifNode mainCounted)
            #_"IfNode" newSegmentTest (LoopFragment''getDuplicatedNode-2 this, loopTest)
            #_"AbstractBeginNode" trueSuccessor (:trueSuccessor loopTest)
            #_"AbstractBeginNode" falseSuccessor (:falseSuccessor loopTest)
            #_"boolean" codeInTrueSide (= trueSuccessor (:body mainCounted))
            #_"FixedNode" firstNode (:next (if codeInTrueSide trueSuccessor falseSuccessor))
            trueSuccessor (:trueSuccessor newSegmentTest)
            falseSuccessor (:falseSuccessor newSegmentTest)
        ]
            (doseq [#_"Node" usage (ยง snap (AbstractBeginNode'''anchored-1 falseSuccessor))]
                (Node''replaceFirstInput-3 usage, falseSuccessor, (:falseSuccessor loopTest))
            )
            (doseq [#_"Node" usage (ยง snap (AbstractBeginNode'''anchored-1 trueSuccessor))]
                (Node''replaceFirstInput-3 usage, trueSuccessor, (:trueSuccessor loopTest))
            )
            (let [
                #_"AbstractBeginNode" startBlockNode (if codeInTrueSide trueSuccessor falseSuccessor)
                #_"FixedNode" lastNode (LoopFragmentInside'getBlockEnd-1 startBlockNode)
                #_"LoopEndNode" loopEndNode (LoopBeginNode''getSingleLoopEnd-1 mainLoopBegin)
                #_"FixedWithNextNode" lastCodeNode (:predecessor loopEndNode)
                #_"FixedNode" newSegmentFirstNode (LoopFragment''getDuplicatedNode-2 this, firstNode)
                #_"FixedWithNextNode" newSegmentLastNode (LoopFragment''getDuplicatedNode-2 this, lastCodeNode)
            ]
                (if (satisfies? LoopEndNode firstNode)
                    (GraphUtil'killCFG-1 (LoopFragment''getDuplicatedNode-2 this, mainLoopBegin))
                    (do
                        (Node''clearSuccessors-1 newSegmentLastNode)
                        (ยง ass! startBlockNode (FixedWithNextNode''setNext-2 startBlockNode, lastNode))
                        (Node''replaceFirstSuccessor-3 lastCodeNode, loopEndNode, newSegmentFirstNode)
                        (Node''replaceFirstSuccessor-3 newSegmentLastNode, lastNode, loopEndNode)
                        (ยง ass! lastCodeNode (FixedWithNextNode''setNext-2 lastCodeNode, newSegmentFirstNode))
                        (ยง ass! newSegmentLastNode (FixedWithNextNode''setNext-2 newSegmentLastNode, loopEndNode))
                        (Node''clearSuccessors-1 startBlockNode)
                        (Node''safeDelete-1 lastNode)
                        (let [
                            #_"Node" newSegmentTestStart (:predecessor newSegmentTest)
                            #_"LogicNode" newSegmentIfTest (:logic newSegmentTest)
                        ]
                            (Node''clearSuccessors-1 newSegmentTestStart)
                            (Node''safeDelete-1 newSegmentTest)
                            (Node''safeDelete-1 newSegmentIfTest)
                            (Node''safeDelete-1 trueSuccessor)
                            (Node''safeDelete-1 falseSuccessor)
                            (Node''safeDelete-1 newSegmentTestStart)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Duplicate the body within the loop after the current copy copy of the body.
     ;
     ; @param updateLimit true if the iteration limit should be adjusted.
     ;;
    (defn #_"void" LoopFragmentInside''insertWithinAfter-3 [#_"LoopFragmentInside" this, #_"LoopEx" _loop, #_"boolean" updateLimit]
        (let [
            #_"LoopFragmentInside" fragments this
            #_"DuplicationReplacement" dataFixWithinAfter
                (reify DuplicationReplacement
                    (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original]
                        (if (satisfies? ValueNode original) (LoopFragmentInside''primAfter-2 fragments, original) original)
                    )
                )
        ]
            (ยง ass! this (LoopFragment''patchNodes-2 this, dataFixWithinAfter))

            ;; collect any new back edges values before updating them since they might reference each other
            (let [
                #_"LoopBeginNode" mainLoopBegin (LoopEx''loopBegin-1 _loop)
                #_"ArrayList<ValueNode>" backedgeValues (ArrayList.)
            ]
                (doseq [#_"PhiNode" mainPhiNode (AbstractMergeNode''phis-1 mainLoopBegin)]
                    (let [
                        #_"ValueNode" duplicatedNode (LoopFragment''getDuplicatedNode-2 this, (PhiNode''valueAt-2i mainPhiNode, 1))
                        duplicatedNode
                            (if (and (nil? duplicatedNode) (AbstractMergeNode''isPhiAtMerge-2 mainLoopBegin, (PhiNode''valueAt-2i mainPhiNode, 1)))
                                (PhiNode''valueAt-2i (PhiNode''valueAt-2i mainPhiNode, 1), 1)
                                duplicatedNode
                            )
                    ]
                        (#_"ArrayList" .add backedgeValues, duplicatedNode)
                    )
                )
                (let [
                    #_"int" index
                        (loop-when [index 0 #_"ISeq" s (seq (AbstractMergeNode''phis-1 mainLoopBegin))] (some? s) => index
                            (let [
                                #_"ValueNode" duplicatedNode (nth backedgeValues index)
                                index (inc index)
                            ]
                                (when (some? duplicatedNode)
                                    (PhiNode''setValueAt-3i (first s), 1, duplicatedNode)
                                )
                                (recur index (next s))
                            )
                        )
                ]
                    (LoopFragmentInside''placeNewSegmentAndCleanup-2 this, _loop)

                    ;; remove any safepoints from the original copy leaving only the duplicated one
                    (doseq [#_"SafepointNode" safepoint (filter #(satisfies? SafepointNode %) (LoopFragment'''nodes-1 (LoopEx''whole-1 _loop)))]
                        (Graph''removeFixed-2 (LoopFragment''graph-1 this), safepoint)
                    )

                    (let [
                        #_"int" unrollFactor (:unrollFactor mainLoopBegin)
                        #_"Graph" graph (:graph mainLoopBegin)
                    ]
                        (when updateLimit
                            ;; use the previous unrollFactor to update the exit condition to power of two
                            (let [
                                #_"InductionVariable" iv (:iv (:counted _loop))
                                #_"CompareNode" compareNode (:logic (:ifNode (:counted _loop)))
                                #_"ValueNode" compareBound
                                    (condp = (InductionVariable'''valueNode-1 iv)
                                        (:x compareNode) (:y compareNode)
                                        (:y compareNode) (:x compareNode)
                                    )
                                #_"long" originalStride (if (= unrollFactor 1) (InductionVariable'''constantStride-1 iv) (quot (InductionVariable'''constantStride-1 iv) unrollFactor))
                            ]
                                (case (InductionVariable'''direction-1 iv)
                                    :Direction'Up
                                    (let [
                                        #_"ConstantNode" aboveVal (Graph''add-2 graph, (ConstantNode'forIntegerStamp-2 (:stamp (InductionVariable'''initNode-1 iv)), (* unrollFactor originalStride)))
                                        #_"ValueNode" newLimit (Graph''add-2 graph, (SubNode'new-2 compareBound, aboveVal))
                                    ]
                                        (Node''replaceFirstInput-3 compareNode, compareBound, newLimit)
                                    )
                                    :Direction'Down
                                    (let [
                                        #_"ConstantNode" aboveVal (Graph''add-2 graph, (ConstantNode'forIntegerStamp-2 (:stamp (InductionVariable'''initNode-1 iv)), (* unrollFactor (- originalStride))))
                                        #_"ValueNode" newLimit (Graph''add-2 graph, (AddNode'new-2 compareBound, aboveVal))
                                    ]
                                        (Node''replaceFirstInput-3 compareNode, compareBound, newLimit)
                                    )
                                    nil
                                )
                            )
                        )
                        (ยง ass! mainLoopBegin (LoopBeginNode''setUnrollFactor-2 mainLoopBegin, (* unrollFactor 2)))
                        (ยง ass! mainLoopBegin (LoopBeginNode''setLoopFrequency-2 mainLoopBegin, (/ (:loopFrequency mainLoopBegin) 2)))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Duplicate the body within the loop after the current copy copy of the body, updating the
     ; iteration limit to account for the duplication.
     ;;
    (defn #_"void" LoopFragmentInside''insertWithinAfter-2 [#_"LoopFragmentInside" this, #_"LoopEx" _loop]
        (LoopFragmentInside''insertWithinAfter-3 this, _loop, true)
        nil
    )

    (defn- #_"void" LoopFragmentInside''clearStateNodes-2 [#_"LoopFragmentInside" this, #_"StateSplit" stateSplit]
        (let [
            #_"LoopFragmentInside" owner this
            #_"FrameState" loopState (:stateAfter stateSplit)
        ]
            (when (some? loopState)
                (VirtualState'''applyToVirtual-2 loopState,
                    (reify VirtualClosure
                        (#_"void" VirtualClosure'''apply-2 [#_"VirtualClosure" this, #_"VirtualState" vs]
                            (when (empty? (filter #(and (NodeBitMap''isMarked-2n (:nodes owner), %) (not= % stateSplit)) (:nodeUsages vs)))
                                (NodeBitMap''clear-2 (:nodes owner), vs)
                            )
                            nil
                        )
                    )
                )
            )
        )
        nil
    )

    (defm LoopFragmentInside LoopFragment
        (#_"NodeBitMap" LoopFragment'''nodes-1 [#_"LoopFragmentInside" this]
            (when (nil? (:nodes this))
                (let [
                    #_"LoopFragmentWhole" whole (LoopEx''whole-1 (:loop this))
                ]
                    (LoopFragment'''nodes-1 whole) ;; init nodes bitmap in whole
                    (ยง ass! this (assoc this :nodes (NodeBitMap'copy-1 (:nodes whole))))
                    ;; remove the phis
                    (let [
                        #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop this))
                    ]
                        (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 loopBegin)]
                            (NodeBitMap''clear-2 (:nodes this), phi)
                        )
                        (LoopFragmentInside''clearStateNodes-2 this, loopBegin)
                        (doseq [#_"LoopExitNode" exit (LoopFragmentInside''exits-1 this)]
                            (LoopFragmentInside''clearStateNodes-2 this, exit)
                            (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 exit)]
                                (NodeBitMap''clear-2 (:nodes this), proxy)
                            )
                        )
                    )
                )
            )
            (:nodes this)
        )
    )

    (defn #_"LoopExitNode*" LoopFragmentInside''exits-1 [#_"LoopFragmentInside" this]
        (LoopBeginNode''loopExits-1 (LoopEx''loopBegin-1 (:loop this)))
    )

    (defm LoopFragmentInside LoopFragment
        (#_"DuplicationReplacement" LoopFragment'''getDuplicationReplacement-1 [#_"LoopFragmentInside" this]
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop this))
                #_"Graph" graph (LoopFragment''graph-1 this)
                #_"EconomicMap<Node, Node>" seenNode (EconomicMap/create)
            ]
                (reify DuplicationReplacement
                    (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original]
                        (when (= original loopBegin)
                            (let [
                                #_"Node" value (get seenNode original)
                            ]
                                (when (some? value)
                                    (ยง return value)
                                )
                                (let [
                                    #_"AbstractBeginNode" newValue (Graph''add-2 graph, (BeginNode'new-0))
                                ]
                                    (#_"EconomicMap" .put seenNode, original, newValue)
                                    (ยง return newValue)
                                )
                            )
                        )
                        (when (and (satisfies? LoopExitNode original) (= (LoopEx''loopBegin-1 original) loopBegin))
                            (let [
                                #_"Node" value (get seenNode original)
                            ]
                                (when (some? value)
                                    (ยง return value)
                                )
                                (let [
                                    #_"AbstractBeginNode" newValue (Graph''add-2 graph, (BeginNode'new-0))
                                ]
                                    (#_"EconomicMap" .put seenNode, original, newValue)
                                    (ยง return newValue)
                                )
                            )
                        )
                        (when (and (satisfies? LoopEndNode original) (= (LoopEx''loopBegin-1 original) loopBegin))
                            (let [
                                #_"Node" value (get seenNode original)
                            ]
                                (when (some? value)
                                    (ยง return value)
                                )
                                (let [
                                    #_"EndNode" newValue (Graph''add-2 graph, (EndNode'new-0))
                                ]
                                    (#_"EconomicMap" .put seenNode, original, newValue)
                                    (ยง return newValue)
                                )
                            )
                        )
                        original
                    )
                )
            )
        )

        (#_"void" LoopFragment'''finishDuplication-1 [#_"LoopFragmentInside" this]
            ;; TODO
            nil
        )

        (#_"void" LoopFragment'''beforeDuplication-1 [#_"LoopFragmentInside" this]
            ;; Nothing to do
            nil
        )
    )

    ;;;
     ; Gets the corresponding value in this fragment.
     ;
     ; @param b original value
     ; @return corresponding value in the peel
     ;;
    (defm LoopFragmentInside LoopFragment
        (#_"ValueNode" LoopFragment'''prim-2 [#_"LoopFragmentInside" this, #_"ValueNode" b]
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
            ]
                (cond
                    (AbstractMergeNode''isPhiAtMerge-2 loopBegin, b) (PhiNode''valueAt-2n b, (LoopBeginNode''forwardEnd-1 loopBegin))
                    (:nodesReady this)                               (or (LoopFragment''getDuplicatedNode-2 this, b) b)
                    :else                                            b
                )
            )
        )
    )

    (defn #_"ValueNode" LoopFragmentInside''primAfter-2 [#_"LoopFragmentInside" this, #_"ValueNode" b]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
        ]
            (cond
                (AbstractMergeNode''isPhiAtMerge-2 loopBegin, b) (PhiNode''valueAt-2i b, 1)
                (:nodesReady this)                               (or (LoopFragment''getDuplicatedNode-2 this, b) b)
                :else                                            b
            )
        )
    )
)

(class-ns LoopFragmentWhole [LoopFragment]
    (defn #_"LoopFragmentWhole" LoopFragmentWhole'new-1e [#_"LoopEx" _loop]
        (merge (LoopFragmentWhole'class.) (LoopFragment'new-1 _loop))
    )

    (defn #_"LoopFragmentWhole" LoopFragmentWhole'new-1f [#_"LoopFragmentWhole" original]
        (merge (LoopFragmentWhole'class.) (LoopFragment'new-2 nil, original))
    )

    (defm LoopFragmentWhole LoopFragment
        (#_"LoopFragmentWhole" LoopFragment'''duplicate-1 [#_"LoopFragmentWhole" this]
            (let [
                #_"LoopFragmentWhole" copy (LoopFragmentWhole'new-1f this)
                copy (LoopFragment''patchNodes-2 copy, nil)
            ]
                (LoopFragment''mergeEarlyExits-1 copy)
                copy
            )
        )

        (#_"NodeBitMap" LoopFragment'''nodes-1 [#_"LoopFragmentWhole" this]
            (when (nil? (:nodes this))
                (let [
                    #_"Loop" _loop (:loop (:loop this))
                ]
                    (ยง ass! this (assoc this :nodes (LoopFragment'computeNodes-3 (LoopFragment''graph-1 this), (LoopFragment'toHirBlocks-1 (:blocks _loop)), (LoopFragment'toHirExits-1 (:exits _loop)))))
                )
            )
            (:nodes this)
        )

        (#_"ValueNode" LoopFragment'''prim-2 [#_"LoopFragmentWhole" this, #_"ValueNode" b]
            (LoopFragment''getDuplicatedNode-2 this, b)
        )

        (#_"DuplicationReplacement" LoopFragment'''getDuplicationReplacement-1 [#_"LoopFragmentWhole" this]
            (let [
                #_"FixedNode" entry (LoopEx''entryPoint-1 (:loop this))
                #_"Graph" graph (LoopFragment''graph-1 this)
                #_"EndNode" endNode nil
            ]
                (reify DuplicationReplacement
                    (#_"Node" DuplicationReplacement'''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original]
                        (when (= original entry) => original
                            (when (nil? endNode)
                                (ยง ass! endNode (Graph''add-2 graph, (EndNode'new-0)))
                            )
                            endNode
                        )
                    )
                )
            )
        )
    )

    (defn #_"FixedNode" LoopFragmentWhole''entryPoint-1 [#_"LoopFragmentWhole" this]
        (when (LoopFragment''isDuplicate-1 this) => (LoopEx''entryPoint-1 (:loop this))
            (LoopBeginNode''forwardEnd-1 (LoopFragment''getDuplicatedNode-2 this, (LoopEx''loopBegin-1 (:loop (:original this)))))
        )
    )

    (defm LoopFragmentWhole LoopFragment
        (#_"void" LoopFragment'''finishDuplication-1 [#_"LoopFragmentWhole" this]
            ;; TODO
            nil
        )
    )

    (defn #_"void" LoopFragmentWhole''cleanupLoopExits-1 [#_"LoopFragmentWhole" this]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
            #_"Graph" graph (:graph loopBegin)
        ]
            (when (= (:guardsStage graph) GuardsStage'AFTER_FSA)
                ;; After FrameStateAssignment ControlFlowGraph treats loop exits differently which means
                ;; that the LoopExitNodes can be in a block which post dominates the true loop exit. For
                ;; cloning to work right they must agree.
                (let [
                    #_"EconomicSet<LoopExitNode>" exits (EconomicSet/create)
                ]
                    (doseq [#_"Block" exitBlock (:exits (:loop (:loop (:original this))))]
                        (let [
                            #_"LoopExitNode" exitNode (Block''getLoopExit-1 exitBlock)
                        ]
                            (when (nil? exitNode)
                                (ยง ass exitNode (Graph''add-2 graph, (LoopExitNode'new-1 loopBegin)))
                                (Graph''addAfterFixed-3 graph, (:beginNode exitBlock), exitNode)
                                (when (some? (:nodes this))
                                    (NodeBitMap''mark-2 (:nodes this), exitNode)
                                )
                            )
                            (#_"EconomicSet" .add exits, exitNode)
                        )
                    )
                    (doseq [#_"LoopExitNode" exitNode (LoopBeginNode''loopExits-1 loopBegin)]
                        (when-not (contains? exits exitNode)
                            (when (some? (:nodes this))
                                (NodeBitMap''clear-2 (:nodes this), exitNode)
                            )
                            (Graph''removeFixed-2 graph, exitNode)
                        )
                    )
                )
            )
        )
        nil
    )

    (defm LoopFragmentWhole LoopFragment
        (#_"void" LoopFragment'''beforeDuplication-1 [#_"LoopFragmentWhole" this]
            (LoopFragmentWhole''cleanupLoopExits-1 this)
            nil
        )

        (#_"void" LoopFragment'''insertBefore-2 [#_"LoopFragmentWhole" this, #_"LoopEx" _loop]
            ;; TODO auto-generated method stub
            nil
        )
    )
)

(class-ns LoopKillCache []
    (defn #_"LoopKillCache" LoopKillCache'new-1 [#_"int" visits]
        (merge (LoopKillCache'class.)
            (hash-map
                #_"int" :visits visits
                #_"LocationIdentity" :firstLocation nil
                #_"EconomicSet<LocationIdentity>" :killedLocations nil
                #_"boolean" :killsAll false
            )
        )
    )

    (defn #_"LoopKillCache" LoopKillCache''visited-1 [#_"LoopKillCache" this]
        (update this :visits inc)
    )

    (defn #_"this" LoopKillCache''setKillsAll-1 [#_"LoopKillCache" this]
        (let [
            this (assoc this :killsAll true)
            this (assoc this :firstLocation nil)
            this (assoc this :killedLocations nil)
        ]
            this
        )
    )

    (defn #_"boolean" LoopKillCache''containsLocation-2 [#_"LoopKillCache" this, #_"LocationIdentity" location]
        (or (:killsAll this)
            (and (some? (:firstLocation this))
                (or (= (:firstLocation this) location)
                    (and (some? (:killedLocations this)) (contains? (:killedLocations this) location))
                )
            )
        )
    )

    (defn #_"LoopKillCache" LoopKillCache''rememberLoopKilledLocation-2 [#_"LoopKillCache" this, #_"LocationIdentity" location]
        (when-not (:killsAll this) => this
            (if (or (nil? (:firstLocation this)) (= (:firstLocation this) location))
                (assoc this :firstLocation location)
                (let [
                    this
                        (when (nil? (:killedLocations this)) => this
                            (assoc this :killedLocations (EconomicSet/create))
                        )
                ]
                    (#_"EconomicSet" .add (:killedLocations this), location)
                    this
                )
            )
        )
    )

    (defn #_"boolean" LoopKillCache''loopKillsLocations-1 [#_"LoopKillCache" this]
        (or (:killsAll this) (some? (:firstLocation this)))
    )
)

(class-ns LoopPhase [Phase]
    (defn #_"LoopPhase" LoopPhase'new-1 [#_"LoopPolicies" policies]
        (merge (LoopPhase'class.)
            (hash-map
                #_"LoopPolicies" :policies policies
            )
        )
    )
)

(class-ns LoopFullUnrollPhase [LoopPhase, Phase]
    (defn #_"LoopFullUnrollPhase" LoopFullUnrollPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"LoopPolicies" policies]
        (merge (LoopFullUnrollPhase'class.) (LoopPhase'new-1 policies)
            (hash-map
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
            )
        )
    )

    (defm LoopFullUnrollPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoopFullUnrollPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (Graph''hasLoops-1 graph)
                (loop []
                    (let [
                        #_"LoopsData" dataCounted (LoopsData'new-1 graph)
                    ]
                        (LoopsData''detectedCountedLoops-1 dataCounted)
                        (let [
                            #_"boolean" peeled?
                                (loop-when [#_"ISeq" s (seq (LoopsData''countedLoops-1 dataCounted))] (some? s) => false
                                    (let [
                                        #_"LoopEx" _loop (first s)
                                    ]
                                        (when (LoopPolicies'''shouldFullUnroll-2 (:policies this), _loop) => (recur (next s))
                                            (LoopTransformations'fullUnroll-2 _loop, (:canonicalizer this))
                                            true
                                        )
                                    )
                                )
                        ]
                            (LoopsData''deleteUnusedNodes-1 dataCounted)
                            (recur-if peeled? [])
                        )
                    )
                )
            )
            graph
        )
    )
)

(class-ns LoopPartialUnrollPhase [LoopPhase, Phase]
    (defn #_"LoopPartialUnrollPhase" LoopPartialUnrollPhase'new-2 [#_"LoopPolicies" policies, #_"CanonicalizerPhase" canonicalizer]
        (merge (LoopPartialUnrollPhase'class.) (LoopPhase'new-1 policies)
            (hash-map
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
            )
        )
    )

    ; @SuppressWarnings("try")
    (defm LoopPartialUnrollPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoopPartialUnrollPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (Graph''hasLoops-1 graph)
                (let [
                    #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
                ]
                    (loop []
                        (let [
                            #_"boolean" changed?
                                (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                                    (let [
                                        #_"LoopsData" dataCounted (LoopsData'new-1 graph)
                                    ]
                                        (LoopsData''detectedCountedLoops-1 dataCounted)
                                        (let [
                                            changed?
                                                (loop-when [changed? false #_"ISeq" s (seq (LoopsData''countedLoops-1 dataCounted))] (some? s) => changed?
                                                    (let [
                                                        #_"LoopEx" _loop (first s)
                                                        changed?
                                                            (when (and (LoopTransformations'isUnrollableLoop-1 _loop) (LoopPolicies'''shouldPartiallyUnroll-2 (:policies this), _loop)) => changed?
                                                                (if (LoopBeginNode''isSimpleLoop-1 (LoopEx''loopBegin-1 _loop))
                                                                    ;; First perform the pre/post transformation and do the partial unroll when we come around again.
                                                                    (LoopTransformations'insertPrePostLoops-1 _loop)
                                                                    (LoopTransformations'partialUnroll-1 _loop)
                                                                )
                                                                true
                                                            )
                                                    ]
                                                        (recur changed? (next s))
                                                    )
                                                )
                                        ]
                                            (LoopsData''deleteUnusedNodes-1 dataCounted)

                                            (when (seq (:nodes listener))
                                                (CanonicalizerPhase''applyIncremental-3i (:canonicalizer this), graph, (:nodes listener))
                                                (#_"EconomicSet" .clear (:nodes listener))
                                            )
                                            changed?
                                        )
                                    )
                                )
                        ]
                            (recur-if changed? [])
                        )
                    )
                )
            )
            graph
        )
    )
)

(class-ns LoopPeelingPhase [LoopPhase, Phase]
    (defn #_"LoopPeelingPhase" LoopPeelingPhase'new-1 [#_"LoopPolicies" policies]
        (merge (LoopPeelingPhase'class.) (LoopPhase'new-1 policies))
    )

    (defm LoopPeelingPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoopPeelingPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (Graph''hasLoops-1 graph)
                (let [
                    #_"LoopsData" data (LoopsData'new-1 graph)
                ]
                    (doseq [#_"LoopEx" _loop (:loops data)]
                        (when (LoopPolicies'''shouldPeel-3 (:policies this), _loop, (:cfg data))
                            (LoopTransformations'peel-1 _loop)
                        )
                    )
                    (LoopsData''deleteUnusedNodes-1 data)
                )
            )
            graph
        )
    )
)

(class-ns LoopUnswitchingPhase [LoopPhase, Phase]
    (defn #_"LoopUnswitchingPhase" LoopUnswitchingPhase'new-1 [#_"LoopPolicies" policies]
        (merge (LoopUnswitchingPhase'class.) (LoopPhase'new-1 policies))
    )

    (defm LoopUnswitchingPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoopUnswitchingPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when (Graph''hasLoops-1 graph)
                (loop []
                    (let [
                        #_"LoopsData" dataUnswitch (LoopsData'new-1 graph)
                        #_"boolean" unswitched?
                            (loop-when [#_"ISeq" s (seq (:loops dataUnswitch))] (some? s) => false
                                (let [
                                    #_"LoopEx" _loop (first s)
                                ]
                                    (when (LoopPolicies'''shouldTryUnswitch-2 (:policies this), _loop) => (recur (next s))
                                        (let [
                                            #_"List<ControlSplitNode>" controlSplits (LoopTransformations'findUnswitchable-1 _loop)
                                        ]
                                            (when (and (some? controlSplits) (LoopPolicies'''shouldUnswitch-3 (:policies this), _loop, controlSplits)) => (recur (next s))
                                                (LoopTransformations'unswitch-2 _loop, controlSplits)
                                                true
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        (recur-if unswitched? [])
                    )
                )
            )
            graph
        )
    )
)

(class-ns LoopSafepointEliminationPhase [Phase]
    (defn #_"LoopSafepointEliminationPhase" LoopSafepointEliminationPhase'new-0 []
        (LoopSafepointEliminationPhase'class.)
    )

    (defm LoopSafepointEliminationPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoopSafepointEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"LoopsData" loops (LoopsData'new-1 graph)
            ]
                (when (and (OptimisticOptimizations''useLoopLimitChecks-1 (:optimisticOpts context)) (GuardsStage'allowsFloatingGuards-1 (:guardsStage graph)))
                    (LoopsData''detectedCountedLoops-1 loops)
                    (doseq [#_"LoopEx" _loop (LoopsData''countedLoops-1 loops)]
                        (when (and (empty? (:children (:loop _loop))) (<= (:bits (CountedLoopInfo''getStamp-1 (:counted _loop))) 32))
                            (let [
                                #_"boolean" hasSafepoint
                                    (loop-when-recur [hasSafepoint false #_"ISeq" s (seq (LoopBeginNode''loopEnds-1 (LoopEx''loopBegin-1 _loop)))]
                                                    (some? s)
                                                    [(or hasSafepoint (:canSafepoint (first s))) (next s)]
                                                => hasSafepoint
                                    )
                            ]
                                (when hasSafepoint
                                    (CountedLoopInfo''createOverFlowGuard-1 (:counted _loop))
                                    (ยง ass! (LoopEx''loopBegin-1 _loop) (LoopBeginNode''disableSafepoint-1 (LoopEx''loopBegin-1 _loop)))
                                )
                            )
                        )
                    )
                )
                (doseq [#_"LoopEx" _loop (:loops loops) #_"LoopEndNode" loopEnd (LoopBeginNode''loopEnds-1 (LoopEx''loopBegin-1 _loop))]
                    (loop-when [#_"Block" b (ControlFlowGraph''blockFor-2 (:cfg loops), loopEnd)] (not= b (:header (:loop _loop)))
                        (or
                            (loop-when [#_"ISeq" s (seq (Block''getNodes-1 b))] (some? s)
                                (let [
                                    #_"FixedNode" node (first s)
                                ]
                                    (when (satisfies? InvokeNode node) => (recur (next s))
                                        (ยง ass! loopEnd (LoopEndNode''disableSafepoint-1 loopEnd))
                                        :done
                                    )
                                )
                            )
                            (recur (:dominator b))
                        )
                    )
                )
                (LoopsData''deleteUnusedNodes-1 loops)
                graph
            )
        )
    )
)

;;;
 ; Adds safepoints to loops.
 ;;
(class-ns LoopSafepointInsertionPhase [Phase]
    (defn #_"LoopSafepointInsertionPhase" LoopSafepointInsertionPhase'new-0 []
        (LoopSafepointInsertionPhase'class.)
    )

    (defm LoopSafepointInsertionPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoopSafepointInsertionPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when GraalOptions'genLoopSafepoints
                (doseq [#_"LoopBeginNode" loopBeginNode (Graph''getNodes-2 graph, LoopBeginNode) #_"LoopEndNode" loopEndNode (LoopBeginNode''loopEnds-1 loopBeginNode)]
                    (when (:canSafepoint loopEndNode)
                        (Graph''addBeforeFixed-3 graph, loopEndNode, (Graph''add-2 graph, (SafepointNode'new-0)))
                    )
                )
            )
            graph
        )
    )
)

(class-ns LoopsData []
    (defn #_"LoopsData" LoopsData'new-1 [#_"Graph" graph]
        (let [
            #_"LoopsData" this
                (merge (LoopsData'class.)
                    (hash-map
                        #_"EconomicMap<LoopBeginNode, LoopEx>" :loopBeginToEx (EconomicMap/create)
                        #_"ControlFlowGraph" :cfg (ControlFlowGraph'compute-5 graph, true, true, true, true)
                        #_"List<LoopEx>" :loops (ArrayList.)
                    )
                )
            _
                (doseq [#_"Loop" _loop (:loops (:cfg this))]
                    (let [
                        #_"LoopEx" ex (LoopEx'new-2 _loop, this)
                    ]
                        (#_"List" .add (:loops this), ex)
                        (#_"EconomicMap" .put (:loopBeginToEx this), (LoopEx''loopBegin-1 ex), ex)
                    )
                )
        ]
            this
        )
    )

    (defn #_"LoopEx" LoopsData''loop-2 [#_"LoopsData" this, #_"LoopBeginNode" loopBegin]
        (get (:loopBeginToEx this) loopBegin)
    )

    (defn #_"Collection<LoopEx>" LoopsData''countedLoops-1 [#_"LoopsData" this]
        (let [
            #_"List<LoopEx>" counted (LinkedList.)
        ]
            (doseq [#_"LoopEx" _loop (:loops this)]
                (when (LoopEx''isCounted-1 _loop)
                    (#_"List" .add counted, _loop)
                )
            )
            counted
        )
    )

    (defn #_"void" LoopsData''detectedCountedLoops-1 [#_"LoopsData" this]
        (doseq [#_"LoopEx" _loop (:loops this)]
            (LoopEx''detectCounted-1 _loop)
        )
        nil
    )

    ;;;
     ; Deletes any nodes created within the scope of this object that have no usages.
     ;;
    (defn #_"void" LoopsData''deleteUnusedNodes-1 [#_"LoopsData" this]
        (doseq [#_"LoopEx" _loop (:loops this)]
            (LoopEx''deleteUnusedNodes-1 _loop)
        )
        nil
    )
)

;;;
 ; Processes all Lowerable nodes to do their lowering.
 ;;
(class-ns LoweringPhase [Phase]
    (defn #_"LoweringPhase" LoweringPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"LoweringStage" loweringStage]
        (merge (LoweringPhase'class.)
            (hash-map
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
                #_"LoweringStage" :loweringStage loweringStage
            )
        )
    )

    (defm LoweringPhase Phase
        (#_"Graph" Phase'''run-3 [#_"LoweringPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"IncrementalCanonicalizerPhase" suite (IncrementalCanonicalizerPhase'new-2 (:canonicalizer this), (LoweringRound'new-1 this))
            ]
                (Phase'''run-3 suite, graph, context)
            )
        )
    )

    ;;;
     ; This state-machine resembles the following recursion:
     ;
     ; void processBlock(Block block) {
     ;     preprocess();
     ;     // Process always reached block first.
     ;     Block alwaysReachedBlock = block.getPostdominator();
     ;     if (alwaysReachedBlock != null && alwaysReachedBlock.getDominator() == block) {
     ;         processBlock(alwaysReachedBlock);
     ;     }
     ;
     ;     // Now go for the other dominators.
     ;     for (Block dominated : block.getDominated()) {
     ;         if (dominated != alwaysReachedBlock) {
     ;             assert dominated.getDominator() == block;
     ;             processBlock(dominated);
     ;         }
     ;     }
     ;     postprocess();
     ; }
     ;
     ; This is necessary, as the recursive implementation quickly exceed the stack depth on SPARC.
     ;
     ; @param rootFrame contains the starting block.
     ;;
    (defn #_"void" LoweringPhase'processBlock-1 [#_"ProcessFrame" rootFrame]
        (loop-when [#_"ProcessBlockState" state ProcessBlockState'ST_PROCESS #_"ProcessFrame" frame rootFrame] (some? frame)
            (let [
                [state frame]
                    (condp = state
                        ProcessBlockState'ST_PROCESS
                            (do
                                (ยง ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER_ALWAYS_REACHED frame]
                            )
                        ProcessBlockState'ST_PROCESS_ALWAYS_REACHED
                            (do
                                (ยง ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER frame]
                            )
                        ProcessBlockState'ST_ENTER_ALWAYS_REACHED
                            (if (and (some? (:alwaysReachedBlock frame)) (= (:dominator (:alwaysReachedBlock frame)) (:block frame)))
                                [ProcessBlockState'ST_PROCESS (ProcessFrame''enterAlwaysReached-2 frame, (:alwaysReachedBlock frame))]
                                [ProcessBlockState'ST_ENTER frame]
                            )
                        ProcessBlockState'ST_ENTER
                            (let [
                                #_"Block" block (:dominated frame)
                            ]
                                (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                    (ยง ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                    (let [
                                        block
                                            (when (= block (:alwaysReachedBlock frame)) => block
                                                (let [
                                                    block (:dominated frame)
                                                ]
                                                    (when (some? block)
                                                        (ยง ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                                        block
                                                    )
                                                )
                                            )
                                    ]
                                        (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                            [ProcessBlockState'ST_PROCESS (ProcessFrame''enter-2 frame, block)]
                                        )
                                    )
                                )
                            )
                        ProcessBlockState'ST_LEAVE
                            (do
                                (ProcessFrame''postprocess-1 frame)
                                [ProcessBlockState'ST_ENTER (:parent frame)]
                            )
                    )
            ]
                (recur state frame)
            )
        )
        nil
    )

    #_unused
    (defn #_"void" LoweringPhase'processBlockBounded-1 [#_"ProcessFrame" rootFrame]
        (loop-when [#_"ProcessBlockState" state ProcessBlockState'ST_PROCESS #_"ProcessFrame" frame rootFrame] (some? frame)
            (let [
                [state frame]
                    (condp = state
                        ProcessBlockState'ST_PROCESS
                            (do
                                (ยง ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER_ALWAYS_REACHED frame]
                            )
                        ProcessBlockState'ST_PROCESS_ALWAYS_REACHED
                            (do
                                (ยง ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER frame]
                            )
                        ProcessBlockState'ST_ENTER_ALWAYS_REACHED
                            (when (and (some? (:alwaysReachedBlock frame)) (= (:dominator (:alwaysReachedBlock frame)) (:block frame))) => [ProcessBlockState'ST_ENTER frame]
                                (let [
                                    #_"ProcessFrame" continueRecur (ProcessFrame''enterAlwaysReached-2 frame, (:alwaysReachedBlock frame))
                                ]
                                    (when (nil? continueRecur) => [ProcessBlockState'ST_PROCESS continueRecur]
                                        ;; stop recursion here
                                        (ProcessFrame''postprocess-1 frame)
                                        [ProcessBlockState'ST_ENTER (:parent frame)]
                                    )
                                )
                            )
                        ProcessBlockState'ST_ENTER
                            (let [
                                #_"Block" block (:dominated frame)
                            ]
                                (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                    (ยง ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                    (let [
                                        block
                                            (when (= block (:alwaysReachedBlock frame)) => block
                                                (let [
                                                    block (:dominated frame)
                                                ]
                                                    (when (some? block)
                                                        (ยง ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                                        block
                                                    )
                                                )
                                            )
                                    ]
                                        (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                            (let [
                                                #_"ProcessFrame" continueRecur (ProcessFrame''enter-2 frame, block)
                                            ]
                                                (when (nil? continueRecur) => [ProcessBlockState'ST_PROCESS continueRecur]
                                                    ;; stop recursion here
                                                    (ProcessFrame''postprocess-1 frame)
                                                    [ProcessBlockState'ST_ENTER (:parent frame)]
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        ProcessBlockState'ST_LEAVE
                            (do
                                (ProcessFrame''postprocess-1 frame)
                                [ProcessBlockState'ST_ENTER (:parent frame)]
                            )
                    )
            ]
                (recur state frame)
            )
        )
        nil
    )
)

(class-ns LoweringRound [Phase]
    (defn #_"LoweringRound" LoweringRound'new-1 [#_"LoweringPhase" phase]
        (merge (LoweringRound'class.)
            (hash-map
                #_"LoweringPhase" :phase phase
                #_"SchedulePhase" :schedulePhase (SchedulePhase'new-0)
                #_"ScheduleResult" :schedule nil
            )
        )
    )

    (defm LoweringRound Phase
        (#_"Graph" Phase'''run-3 [#_"LoweringRound" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                graph (Phase'''run-3 (:schedulePhase this), graph, nil)
            ]
                (ยง ass! this (assoc this :schedule (:lastSchedule graph)))
                (ControlFlowGraph''computePostdominators-1 (:cfg (:schedule this)))
                (let [
                    #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg (:schedule this)))
                ]
                    (LoweringPhase'processBlock-1 (ProcessFrame'new-5 nil, this, startBlock, (NodeBitMap'new-1 graph), (:beginNode startBlock)))
                    graph
                )
            )
        )
    )

    (defn- #_"AnchoringNode" LoweringRound''process-4 [#_"LoweringRound" this, #_"Block" block, #_"NodeBitMap" activeGuards, #_"AnchoringNode" startAnchor]
        ;; Lower the instructions of this block.
        (let [
            #_"LoweringTool" lowerer
                (loop-when [lowerer (LoweringTool'new-4 (:phase this), startAnchor, activeGuards, (:beginNode block)) #_"ISeq" s (seq (ScheduleResult''nodesFor-2 (:schedule this), block))] (some? s) => lowerer
                    (let [
                        #_"Node" node (first s)
                    ]
                        ;; => can happen when previous lowerings have deleted nodes
                        (when-not (Node''isDeleted-1 node) => (recur lowerer (next s))
                            ;; Cache the next node to be able to reconstruct the previous of the next node after lowering.
                            (let [
                                #_"FixedNode" nextNode (:next (if (satisfies? FixedWithNextNode node) node (:lastFixedNode lowerer)))
                            ]
                                (when (satisfies? Lowerable node)
                                    (Lowerable'''lower-2 node, lowerer)
                                    (when (Node''isDeleted-1 (:guardAnchor lowerer))
                                        ;; TODO nextNode could be deleted but this is not currently supported
                                        (ยง ass! lowerer (assoc lowerer :guardAnchor (AbstractBeginNode'prevBegin-1 nextNode)))
                                    )
                                )

                                ;; => can happen when the rest of the block is killed by lowering (e.g. by an unconditional deopt)
                                (when (Node''isAlive-1 nextNode) => lowerer
                                    (let [
                                        #_"Node" predecessor (:predecessor nextNode)
                                        predecessor
                                            (when-not (satisfies? FixedWithNextNode predecessor) => predecessor
                                                ;; Insert begin node, to have a valid last fixed for next lowerable node.
                                                ;; This is about lowering a FixedWithNextNode to a control split while this
                                                ;; FixedWithNextNode is followed by some kind of BeginNode.
                                                ;; For example the when a FixedGuard followed by a loop exit is lowered to
                                                ;; a control-split + deopt.
                                                (let [
                                                    #_"AbstractBeginNode" begin (Graph''add-2 (:graph node), (BeginNode'new-0))
                                                ]
                                                    (Node''replaceFirstSuccessor-3 predecessor, nextNode, begin)
                                                    (FixedWithNextNode''setNext-2 begin, nextNode)
                                                )
                                            )
                                    ]
                                        (LoweringTool''setLastFixedNode-2 lowerer, predecessor)
                                        (recur lowerer (next s))
                                    )
                                )
                            )
                        )
                    )
                )
        ]
            (:guardAnchor lowerer)
        )
    )
)

(class-ns LoweringTool []
    (defn #_"LoweringTool" LoweringTool'new-4 [#_"LoweringPhase" phase, #_"AnchoringNode" guardAnchor, #_"NodeBitMap" activeGuards, #_"FixedWithNextNode" lastFixedNode]
        (merge (LoweringTool'class.)
            (hash-map
                #_"LoweringPhase" :phase phase
                #_"NodeBitMap" :activeGuards activeGuards
                #_"AnchoringNode" :guardAnchor guardAnchor
                #_"FixedWithNextNode" :lastFixedNode lastFixedNode
            )
        )
    )

    (defn #_"GuardingNode" LoweringTool''createGuard-5 [#_"LoweringTool" this, #_"FixedNode" before, #_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action]
        (LoweringTool''createGuard-7 this, before, logic, reason, action, JavaConstant/NULL_POINTER, false)
    )

    (defn #_"GuardingNode" LoweringTool''createGuard-7 [#_"LoweringTool" this, #_"FixedNode" before, #_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"JavaConstant" speculation, #_"boolean" negated?]
        (let [
            #_"Graph" graph (:graph before)
        ]
            (when GraalOptions'optEliminateGuards
                (loop-when [#_"ISeq" s (seq (:nodeUsages logic))] (some? s)
                    (let [
                        #_"Node" usage (first s)
                    ]
                        (if (and (not (NodeBitMap''isNew-2 (:activeGuards this), usage)) (NodeBitMap''isMarked-2n (:activeGuards this), usage) (= (:negated? usage) negated?))
                            (ยง return usage)
                            (recur (next s))
                        )
                    )
                )
            )
            (if (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph logic)))
                (let [
                    #_"GuardNode" newGuard (Graph''add-2 graph, (GuardNode'new-6 logic, (:guardAnchor this), reason, action, negated?, speculation))
                ]
                    (when GraalOptions'optEliminateGuards
                        (ยง ass! (:activeGuards this) (NodeBitMap''markAndGrow-2 (:activeGuards this), newGuard))
                    )
                    newGuard
                )
                (let [
                    #_"FixedGuardNode" fixedGuard (Graph''add-2 graph, (FixedGuardNode'new-5 logic, reason, action, speculation, negated?))
                ]
                    (Graph''addBeforeFixed-3 graph, before, fixedGuard)
                    (let [
                        #_"DummyGuardHandle" handle (Graph''add-2 graph, (DummyGuardHandle'new-1 fixedGuard))
                    ]
                        (Lowerable'''lower-2 fixedGuard, this)
                        (let [
                            #_"GuardingNode" result (GuardedNode'''getGuard-1 handle)
                        ]
                            (Node''safeDelete-1 handle)
                            result
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Sets the closest fixed node preceding the node currently being lowered.
     ;;
    (defn #_"void" LoweringTool''setLastFixedNode-2 [#_"LoweringTool" this, #_"FixedWithNextNode" n]
        (ยง ass! this (assoc this :lastFixedNode n))
        nil
    )
)

(class-ns MapReplacement [DuplicationReplacement]
    (defn #_"MapReplacement" MapReplacement'new-1 [#_"EconomicMap<Node, Node>" map]
        (merge (MapReplacement'class.)
            (hash-map
                #_"EconomicMap<Node, Node>" :map map
            )
        )
    )

    (defm MapReplacement DuplicationReplacement
        (#_"Node" DuplicationReplacement'''replacement-2 [#_"MapReplacement" this, #_"Node" original]
            (or (get (:map this) original) original)
        )
    )
)

;;;
 ; This iterator only returns nodes that are marked in the NodeBitMap and are alive
 ; in the corresponding Graph.
 ;;
(class-ns MarkedNodeIterator [#_"Iterator" #_"<Node>"]
    (defn- #_"this" MarkedNodeIterator''forward-1 [#_"MarkedNodeIterator" this]
        (let [
            this (assoc this :currentNode (NodeBitMap''nextMarkedNode-2 (:bitMap this), (inc (:currentNodeId this))))
        ]
            (assoc this :currentNodeId (if (some? (:currentNode this)) (:nid (:currentNode this)) -1))
        )
    )

    (defn #_"MarkedNodeIterator" MarkedNodeIterator'new-1 [#_"NodeBitMap" bitMap]
        (let [
            #_"MarkedNodeIterator" this
                (merge (MarkedNodeIterator'class.)
                    (hash-map
                        #_"NodeBitMap" :bitMap bitMap
                        #_"int" :currentNodeId -1
                        #_"Node" :currentNode nil
                    )
                )
        ]
            (MarkedNodeIterator''forward-1 this)
        )
    )

    (ยง override! #_"boolean" #_"Iterator." hasNext [#_"MarkedNodeIterator" this]
        (when (and (nil? (:currentNode this)) (<= 0 (:currentNodeId this)))
            (ยง ass! this (MarkedNodeIterator''forward-1 this))
        )
        (<= 0 (:currentNodeId this))
    )

    (ยง override! #_"Node" #_"Iterator." next [#_"MarkedNodeIterator" this]
        (when-not (#_"Iterator" .hasNext this)
            (throw (NoSuchElementException.))
        )
        (when-not (Node''isAlive-1 (:currentNode this))
            (throw (ConcurrentModificationException. "NodeBitMap was modified between the calls to hasNext() and next()"))
        )

        (let [
            #_"Node" result (:currentNode this)
        ]
            (ยง ass! this (assoc this :currentNode nil))
            result
        )
    )
)

(class-ns MemoryInputMap [MemoryMap]
    (defn #_"MemoryInputMap" MemoryInputMap'new-1 [#_"ValueNode" replacee]
        (let [
            ? (satisfies? MemoryAccess replacee)
        ]
            (merge (MemoryInputMap'class.)
                (hash-map
                    #_"LocationIdentity" :locationIdentity (when ? (MemoryAccess'''getLocationIdentity-1 replacee))
                    #_"MemoryNode" :lastLocationAccess (when ? (:lastLocationAccess replacee))
                )
            )
        )
    )

    (defm MemoryInputMap MemoryMap
        (#_"MemoryNode" MemoryMap'''getLastLocationAccess-2 [#_"MemoryInputMap" this, #_"LocationIdentity" location]
            (when (and (some? (:locationIdentity this)) (= (:locationIdentity this) location))
                (:lastLocationAccess this)
            )
        )

        (#_"LocationIdentity*" MemoryMap'''getLocations-1 [#_"MemoryInputMap" this]
            (when (some? (:locationIdentity this)) (list (:locationIdentity this)))
        )
    )
)

(class-ns MemoryOutputMap [MemoryInputMap, MemoryMap]
    (defn #_"MemoryOutputMap" MemoryOutputMap'new-3 [#_"SnippetTemplate" template, #_"ValueNode" replacee, #_"{Node Node}" duplicates]
        (merge (MemoryOutputMap'class.) (MemoryInputMap'new-1 replacee)
            (hash-map
                #_"SnippetTemplate" :template template
                #_"{Node Node}" :duplicates duplicates
            )
        )
    )

    (defm MemoryOutputMap MemoryMap
        (#_"MemoryNode" MemoryMap'''getLastLocationAccess-2 [#_"MemoryOutputMap" this, #_"LocationIdentity" location]
            (let [
                #_"MemoryNode" lastLocationAccess (MemoryMap'''getLastLocationAccess-2 (:memoryMap (:returnNode (:template this))), location)
            ]
                (if (= lastLocationAccess (:memoryAnchor (:template this)))
                    (MemoryMap'''getLastLocationAccess-2 (ยง super #_"MemoryInputMap"), location)
                    (get (:duplicates this) lastLocationAccess)
                )
            )
        )

        (#_"LocationIdentity*" MemoryMap'''getLocations-1 [#_"MemoryOutputMap" this]
            (MemoryMap'''getLocations-1 (:memoryMap (:returnNode (:template this))))
        )
    )
)

(class-ns MemoryMap0 [MemoryMap]
    (defn #_"MemoryMap0" MemoryMap0'new-0 []
        (merge (MemoryMap0'class.)
            (hash-map
                #_"EconomicMap<LocationIdentity, MemoryNode>" :lastMemorySnapshot (EconomicMap/create)
            )
        )
    )

    (defn #_"MemoryMap0" MemoryMap0'new-1 [#_"StartNode" start]
        (let [
            #_"MemoryMap0" this (MemoryMap0'new-0)
        ]
            (#_"EconomicMap" .put (:lastMemorySnapshot this), LocationIdentity'ANY, start)
            this
        )
    )

    (defn #_"MemoryMap0" MemoryMap0'copy-1 [#_"MemoryMap0" other]
        (merge (MemoryMap0'class.)
            (hash-map
                #_"EconomicMap<LocationIdentity, MemoryNode>" :lastMemorySnapshot (EconomicMap/create (:lastMemorySnapshot other))
            )
        )
    )

    (defm MemoryMap0 MemoryMap
        (#_"MemoryNode" MemoryMap'''getLastLocationAccess-2 [#_"MemoryMap0" this, #_"LocationIdentity" location]
            (when-not (:immutable location)
                (or (get (:lastMemorySnapshot this) location)
                    (get (:lastMemorySnapshot this) LocationIdentity'ANY)
                )
            )
        )

        (#_"LocationIdentity*" MemoryMap'''getLocations-1 [#_"MemoryMap0" this]
            (keys (:lastMemorySnapshot this))
        )
    )
)

(class-ns MergeProcessor #_"<T implements EffectsBlockState<T>>" []
    (defn #_"MergeProcessor" MergeProcessor'new-1 [#_"Block" mergeBlock]
        (merge (MergeProcessor'class.)
            (hash-map
                #_"Block" :mergeBlock mergeBlock
                #_"AbstractMergeNode" :merge (ยง cast #_"AbstractMergeNode" (:beginNode mergeBlock))
                #_"GraphEffectList" :mergeEffects (GraphEffectList'new-0)
                #_"GraphEffectList" :afterMergeEffects (GraphEffectList'new-0)
                ;;;
                 ; The indexes are used to map from an index in the list of active (non-dead) predecessors
                 ; to an index in the list of all predecessors (the latter may be larger).
                 ;;
                #_"int[]" :stateIndexes nil
                #_"T" :newState nil
            )
        )
    )

    (defn #_"this" MergeProcessor''setNewState-2 [#_"MergeProcessor<T>" this, #_"T" state]
        (let [
            this (assoc this :newState state)
        ]
            (EffectList'''clear-1 (:mergeEffects this))
            (EffectList'''clear-1 (:afterMergeEffects this))
            this
        )
    )

    (defn #_"MergeProcessor<T>" MergeProcessor''setStateIndexes-2 [#_"MergeProcessor<T>" this, #_"int[]" stateIndexes]
        (assoc this :stateIndexes stateIndexes)
    )

    (defn #_"Block" MergeProcessor''getPredecessor-2 [#_"MergeProcessor<T>" this, #_"int" index]
        (nth (:predecessors (:mergeBlock this)) (nth (:stateIndexes this) index))
    )

    (defn #_"PhiNode*" MergeProcessor''getPhis-1 [#_"MergeProcessor<T>" this]
        (AbstractMergeNode''phis-1 (:merge this))
    )

    (defn #_"ValueNode" MergeProcessor''getPhiValueAt-3 [#_"MergeProcessor<T>" this, #_"PhiNode" phi, #_"int" index]
        (PhiNode''valueAt-2i phi, (nth (:stateIndexes this) index))
    )

    (defn #_"ValuePhiNode" MergeProcessor''createValuePhi-2 [#_"MergeProcessor<T>" this, #_"Stamp" stamp]
        (ValuePhiNode'new-3 stamp, (:merge this), (make-array ValueNode'iface (count (:predecessors (:mergeBlock this)))))
    )

    (defn #_"void" MergeProcessor''setPhiInput-4 [#_"MergeProcessor<T>" this, #_"PhiNode" phi, #_"int" index, #_"ValueNode" value]
        (GraphEffectList''initializePhiInput-4 (:afterMergeEffects this), phi, (nth (:stateIndexes this) index), value)
        nil
    )

    (defn #_"Graph" MergeProcessor''graph-1 [#_"MergeProcessor<T>" this]
        (:graph (:merge this))
    )
)

(class-ns PEMergeProcessor #_"<T implements PartialEscapeBlockState<T>>" [MergeProcessor #_"<T>"]
    (defn #_"PEMergeProcessor" PEMergeProcessor'new-2 [#_"PartialEscapeClosure<T>" peClosure, #_"Block" mergeBlock]
        (merge (PEMergeProcessor'class.) (MergeProcessor'new-1 mergeBlock)
            (hash-map
                #_"PartialEscapeClosure<T>" :peClosure peClosure
                #_"EconomicMap<Object, ValuePhiNode>" :materializedPhis nil
                #_"EconomicMap<ValueNode, ValuePhiNode[]>" :valuePhis nil
                #_"EconomicMap<ValuePhiNode, VirtualObjectNode>" :valueObjectVirtuals nil
                ;; merge will only be called multiple times for loop headers
                #_"boolean" :needsCaching (Block''isLoopHeader-1 mergeBlock)
            )
        )
    )

    (defn- #_"<T> PhiNode" PEMergeProcessor''getPhiCached-3 [#_"PEMergeProcessor<T>" this, #_"T" virtual, #_"Stamp" stamp]
        (when (nil? (:materializedPhis this))
            (ยง ass! this (assoc this :materializedPhis (EconomicMap/create)))
        )
        (let [
            #_"ValuePhiNode" result (get (:materializedPhis this) virtual)
        ]
            (when (nil? result)
                (ยง ass result (MergeProcessor''createValuePhi-2 this, stamp))
                (#_"EconomicMap" .put (:materializedPhis this), virtual, result)
            )
            result
        )
    )

    (defn #_"<T> PhiNode" PEMergeProcessor''getPhi-3 [#_"PEMergeProcessor<T>" this, #_"T" virtual, #_"Stamp" stamp]
        (if (:needsCaching this)
            (PEMergeProcessor''getPhiCached-3 this, virtual, stamp)
            (MergeProcessor''createValuePhi-2 this, stamp)
        )
    )

    (defn- #_"PhiNode[]" PEMergeProcessor''getValuePhisCached-3 [#_"PEMergeProcessor<T>" this, #_"ValueNode" key, #_"int" entryCount]
        (when (nil? (:valuePhis this))
            (ยง ass! this (assoc this :valuePhis (EconomicMap/create)))
        )
        (let [
            #_"ValuePhiNode[]" result (get (:valuePhis this) key)
        ]
            (when (nil? result)
                (ยง ass result (make-array ValuePhiNode'iface entryCount))
                (#_"EconomicMap" .put (:valuePhis this), key, result)
            )
            result
        )
    )

    (defn- #_"PhiNode[]" PEMergeProcessor''getValuePhis-3 [#_"PEMergeProcessor<T>" this, #_"ValueNode" key, #_"int" entryCount]
        (if (:needsCaching this)
            (PEMergeProcessor''getValuePhisCached-3 this, key, entryCount)
            (make-array ValuePhiNode'iface entryCount)
        )
    )

    (defn- #_"VirtualObjectNode" PEMergeProcessor''getValueObjectVirtualCached-3 [#_"PEMergeProcessor<T>" this, #_"ValuePhiNode" phi, #_"VirtualObjectNode" virtual]
        (when (nil? (:valueObjectVirtuals this))
            (ยง ass! this (assoc this :valueObjectVirtuals (EconomicMap/create)))
        )
        (let [
            #_"VirtualObjectNode" result (get (:valueObjectVirtuals this) phi)
        ]
            (when (nil? result)
                (ยง ass result (VirtualObjectNode'''duplicate-1 virtual))
                (#_"EconomicMap" .put (:valueObjectVirtuals this), phi, result)
            )
            result
        )
    )

    (defn- #_"VirtualObjectNode" PEMergeProcessor''getValueObjectVirtual-3 [#_"PEMergeProcessor<T>" this, #_"ValuePhiNode" phi, #_"VirtualObjectNode" virtual]
        (if (:needsCaching this)
            (PEMergeProcessor''getValueObjectVirtualCached-3 this, phi, virtual)
            (VirtualObjectNode'''duplicate-1 virtual)
        )
    )

    (defn- #_"boolean" PEMergeProcessor'intersectObjectState-2 [#_"PartialEscapeBlockState*" states, #_"int" index]
        (loop-when [#_"int" i 0] (< i (count states)) => true
            (and (some? (when (< index (count (:objectStates (nth states i)))) (nth (:objectStates (nth states i)) index)))
                (recur (inc i))
            )
        )
    )

    (defn- #_"int[]" PEMergeProcessor'intersectVirtualObjects-1 [#_"PartialEscapeBlockState*" states]
        (let [
            #_"int" m
                (loop-when-recur [m (count (:objectStates (nth states 0))) #_"int" i 1]
                                 (< i (count states))
                                 [(min m (count (:objectStates (nth states i)))) (inc i)]
                              => m
                )
            #_"int" n
                (loop-when-recur [n 0 #_"int" j 0] (< j m) [(if (PEMergeProcessor'intersectObjectState-2 states, j) (inc n) n) (inc j)] => n)
            #_"int[]" a (int-array n)
        ]
            (loop-when [#_"int" i 0 #_"int" j 0] (< j m)
                (when (PEMergeProcessor'intersectObjectState-2 states, j) => (recur i (inc j))
                    (aset a i j)
                    (recur (inc i) (inc j))
                )
            )
            a
        )
    )

    (defn- #_"boolean" PEMergeProcessor''isSingleUsageAllocation-4 [#_"PEMergeProcessor<T>" this, #_"ValueNode" value, #_"VirtualObjectNode*" objects, #_"PartialEscapeBlockState" state]
        ;; If the phi input is an allocation, we know that it is a "fresh" value, i.e. that
        ;; this is a value that will only appear through this source, and cannot appear anywhere
        ;; else. If the phi is also the only usage of this input, we know that no other place
        ;; can check object identity against it, so it is safe to lose the object identity here.
        (and (satisfies? AllocatedObjectNode value) (Node''hasExactlyOneUsage-1 value)
            ;; Check that the state only references the one virtual object from the Phi.
            (loop-when [#_"VirtualObjectNode" singleVirtual nil #_"int" i 0] (< i (count objects)) => true
                (let [
                    singleVirtual
                        (when (PartialEscapeBlockState''contains-2 state, (nth objects i)) => singleVirtual
                            (cond
                                (nil? singleVirtual)              (nth objects i)
                                (= singleVirtual (nth objects i)) singleVirtual
                                :else
                                    ;; More than one virtual object is visible in the object state.
                                    (ยง return false)
                            )
                        )
                ]
                    (recur singleVirtual (inc i))
                )
            )
        )
    )

    ;;;
     ; Fill the inputs of the PhiNode corresponding to one JavaKind#Object entry in the virtual object.
     ;
     ; @return true if materialization happened during the merge, false otherwise
     ;;
    (defn- #_"boolean" PEMergeProcessor''mergeObjectEntry-5 [#_"PEMergeProcessor<T>" this, #_"fn int [int]" f'objectId-1, #_"PartialEscapeBlockState*" states, #_"PhiNode" phi, #_"int" index]
        (loop-when [#_"boolean" materialized? false #_"int" i 0] (< i (count states)) => materialized?
            (let [
                #_"int" object (f'objectId-1 i)
                #_"ObjectState" state (nth (:objectStates (nth states i)) object)
            ]
                (when (ObjectState''isVirtual-1 state) => materialized?
                    (let [
                        #_"ValueNode" entry (ObjectState''getEntry-2 state, index)
                        [materialized? entry]
                            (when (satisfies? VirtualObjectNode entry) => [materialized? entry]
                                (let [
                                    #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                                    materialized? (or materialized? (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), (:oid entry), (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor)))
                                    entry
                                        (when (ObjectState''isVirtual-1 (nth (:objectStates (nth states i)) object)) => entry
                                            (let [
                                                entry (:materializedValue (nth (:objectStates (nth states i)) (:oid entry)))
                                            ]
                                                (PartialEscapeBlockState''setEntry-4 (nth states i), object, index, entry)
                                                entry
                                            )
                                        )
                                ]
                                    [materialized? entry]
                                )
                            )
                    ]
                        (MergeProcessor''setPhiInput-4 this, phi, i, entry)
                        (recur materialized? (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; Try to merge multiple virtual object states into a single object state. If the incoming
     ; object states are compatible, then this method will create PhiNodes for the object's
     ; entries where needed. If they are incompatible, then all incoming virtual objects will be
     ; materialized, and a PhiNode for the materialized values will be created. Object states
     ; can be incompatible if they contain {@code long} or {@code double} values occupying two
     ; {@code int} slots in such a way that that their values cannot be merged using PhiNodes.
     ;
     ; @param states the predecessor block states of the merge
     ; @return true if materialization happened during the merge, false otherwise
     ;;
    (defn- #_"boolean" PEMergeProcessor''mergeObjectStates-4 [#_"PEMergeProcessor<T>" this, #_"int" resultObject, #_"int*" sourceObjects, #_"PartialEscapeBlockState*" states]
        (let [
            #_"fn int [int]" f'getObject-1 #(if (some? sourceObjects) (nth sourceObjects %) resultObject)
            #_"VirtualObjectNode" virtual (nth (:virtualObjects (:peClosure this)) resultObject)
            #_"int" entryCount (VirtualObjectNode'''entryCount-1 virtual)
            ;; determine all entries that have a two-slot value
            [#_"boolean" ensure? #_"boolean" compatible? #_"JavaKind[]" twoSlotKinds]
                (loop-when [ensure? true #_"int" j 0 twoSlotKinds nil] (< j (count states)) => [ensure? true twoSlotKinds]
                    (let [
                        #_"ObjectState" objectState (nth (:objectStates (nth states j)) (f'getObject-1 j))
                        #_"ValueNode[]" entries (:entries objectState)
                        ensure? (and ensure? (:ensureVirtualized objectState))
                        [compatible? twoSlotKinds]
                            (loop-when [twoSlotKinds twoSlotKinds #_"int" i 0] (< i entryCount) => [true twoSlotKinds]
                                (let [
                                    #_"JavaKind" otherKind (ValueNode''getStackKind-1 (nth entries i))
                                    #_"JavaKind" entryKind (VirtualObjectNode'''entryKind-2 virtual, i)
                                ]
                                    (when (and (= entryKind JavaKind/Int) (#_"JavaKind" .needsTwoSlots otherKind)) => (recur twoSlotKinds (inc i))
                                        (let [
                                            twoSlotKinds (or twoSlotKinds (make-array JavaKind entryCount))
                                        ]
                                            (when (or (nil? (nth twoSlotKinds i)) (= (nth twoSlotKinds i) otherKind)) => [false twoSlotKinds]
                                                (aset twoSlotKinds i otherKind)
                                                ;; skip the next entry
                                                (recur twoSlotKinds (+ i 2))
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        (recur-if compatible? [ensure? (inc j) twoSlotKinds] => [ensure? false twoSlotKinds])
                    )
                )
            compatible?
                (when (and compatible? (some? twoSlotKinds)) => compatible?
                    ;; if there are two-slot values then make sure the incoming states can be merged
                    (loop-when [#_"int" i 0] (< i entryCount) => true
                        (let [
                            compatible?
                                (when (some? (nth twoSlotKinds i)) => true
                                    (loop-when [#_"int" j 0] (< j (count states)) => true
                                        (let [
                                            #_"int" object (f'getObject-1 j)
                                            #_"ObjectState" objectState (nth (:objectStates (nth states j)) object)
                                            #_"ValueNode" value (ObjectState''getEntry-2 objectState, i)
                                            #_"JavaKind" valueKind (ValueNode''getStackKind-1 value)
                                            compatible?
                                                (when-not (= valueKind (nth twoSlotKinds i)) => true
                                                    (let [
                                                        #_"ValueNode" nextValue (ObjectState''getEntry-2 objectState, (inc i))
                                                    ]
                                                        (and (satisfies? ConstantNode value) (= (:value value) JavaConstant/INT_0) (satisfies? ConstantNode nextValue) (= (:value nextValue) JavaConstant/INT_0)
                                                            (do
                                                                ;; rewrite to a zero constant of the larger kind
                                                                (PartialEscapeBlockState''setEntry-4 (nth states j), object, i, (ConstantNode'defaultForKind-2 (nth twoSlotKinds i), (MergeProcessor''graph-1 this)))
                                                                (PartialEscapeBlockState''setEntry-4 (nth states j), object, (inc i), (ConstantNode'forConstant-2c (JavaConstant/forIllegal), (MergeProcessor''graph-1 this)))
                                                                true
                                                            )
                                                        )
                                                    )
                                                )
                                        ]
                                            (recur-if compatible? [(inc j)] => false)
                                        )
                                    )
                                )
                        ]
                            (recur-if compatible? [(inc i)] => false)
                        )
                    )
                )
        ]
            (if compatible?
                ;; virtual objects are compatible: create phis for all entries that need them
                (let [
                    #_"ValueNode[]" values (#_"Object" .clone (:entries (nth (:objectStates (nth states 0)) (f'getObject-1 0))))
                    #_"PhiNode[]" phis (PEMergeProcessor''getValuePhis-3 this, virtual, (VirtualObjectNode'''entryCount-1 virtual))
                ]
                    (loop-when [#_"int" i 0] (< i (count values))
                        (loop-when-recur [#_"int" j 1] (< j (count states)) [(inc j)]
                            (when-not (or (some? (nth phis i)) (= (nth values i) (ObjectState''getEntry-2 (nth (:objectStates (nth states j)) (f'getObject-1 j)), i)))
                                (aset phis i (MergeProcessor''createValuePhi-2 this, (Stamp'''unrestricted-1 (:stamp (nth values i)))))
                            )
                        )
                        (when (and (some? (nth phis i)) (not (Stamp'''isCompatible-2s (:stamp (nth phis i)), (:stamp (nth values i)))))
                            (aset phis i (MergeProcessor''createValuePhi-2 this, (Stamp'''unrestricted-1 (:stamp (nth values i)))))
                        )
                        (let [
                            i
                                (when (and (some? twoSlotKinds) (some? (nth twoSlotKinds i))) => i
                                    ;; skip an entry after a long/double value that occupies two int slots
                                    (let [
                                        i (inc i)
                                    ]
                                        (aset phis i nil)
                                        (aset values i (ConstantNode'forConstant-2c (JavaConstant/forIllegal), (MergeProcessor''graph-1 this)))
                                        i
                                    )
                                )
                        ]
                            (recur (inc i))
                        )
                    )

                    (let [
                        #_"boolean" materialized?
                            (loop-when [materialized? false #_"int" i 0] (< i (count values)) => materialized?
                                (let [
                                    #_"PhiNode" phi (nth phis i)
                                    materialized?
                                        (when (some? phi) => materialized?
                                            (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phi, "virtualMergePhi")
                                            (let [
                                                materialized?
                                                    (if (= (VirtualObjectNode'''entryKind-2 virtual, i) JavaKind/Object)
                                                        (or materialized? (PEMergeProcessor''mergeObjectEntry-5 this, f'getObject-1, states, phi, i))
                                                        (loop-when [#_"int" j 0] (< j (count states)) => materialized?
                                                            (let [
                                                                #_"ObjectState" state (nth (:objectStates (nth states j)) (f'getObject-1 j))
                                                            ]
                                                                (when (ObjectState''isVirtual-1 state) => materialized?
                                                                    (MergeProcessor''setPhiInput-4 this, phi, j, (ObjectState''getEntry-2 state, i))
                                                                    (recur (inc j))
                                                                )
                                                            )
                                                        )
                                                    )
                                            ]
                                                (aset values i phi)
                                                materialized?
                                            )
                                        )
                                ]
                                    (recur materialized? (inc i))
                                )
                            )
                    ]
                        (PartialEscapeBlockState''addObject-3 (:newState this), resultObject, (ObjectState'new-3s values, (:locks (nth (:objectStates (nth states 0)) (f'getObject-1 0))), ensure?))
                        materialized?
                    )
                )
                ;; not compatible: materialize in all predecessors
                (let [
                    #_"PhiNode" materializedValuePhi (PEMergeProcessor''getPhi-3 this, resultObject, (StampFactory'forKind-1 JavaKind/Object))
                ]
                    (dotimes [#_"int" i (count states)]
                        (let [
                            #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                        ]
                            (when (and (not ensure?) (ObjectState''isVirtual-1 (nth (:objectStates (nth states i)) (f'getObject-1 i))))
                                ;; we can materialize if not all inputs are "ensureVirtualized"
                                (ยง ass! (nth (:objectStates (nth states i)) (f'getObject-1 i)) (ObjectState''setEnsureVirtualized-2 (nth (:objectStates (nth states i)) (f'getObject-1 i)), false))
                            )
                            (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), (f'getObject-1 i), (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor))
                            (MergeProcessor''setPhiInput-4 this, materializedValuePhi, i, (:materializedValue (nth (:objectStates (nth states i)) (f'getObject-1 i))))
                        )
                    )
                    (PartialEscapeBlockState''addObject-3 (:newState this), resultObject, (ObjectState'new-3v materializedValuePhi, nil, ensure?))
                    true
                )
            )
        )
    )

    ;;;
     ; Examine a PhiNode and try to replace it with merging of virtual objects if all its inputs refer to
     ; virtual object states. In order for the merging to happen, all incoming object states need to be
     ; compatible and without object identity (meaning that their object identity if not used later on).
     ;
     ; @param phi the PhiNode that should be processed
     ; @param states the predecessor block states of the merge
     ; @return true if materialization happened during the merge, false otherwise
     ;;
    (defn- #_"boolean" PEMergeProcessor''processPhi-3 [#_"PEMergeProcessor<T>" this, #_"ValuePhiNode" phi, #_"PartialEscapeBlockState*" states]
        ;; determine how many inputs are virtual and if they're all the same virtual object
        (let [
            #_"VirtualObjectNode[]" objects (make-array VirtualObjectNode'iface (count states))
            [#_"boolean" unique? #_"boolean" ensure? #_"int" virtualInputs]
                (loop-when [unique? true ensure? true virtualInputs 0 #_"int" i 0] (< i (count states)) => [unique? ensure? virtualInputs]
                    (let [
                        #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 (:peClosure this), (MergeProcessor''getPhiValueAt-3 this, phi, i))
                        [unique? ensure? virtualInputs]
                            (when (satisfies? VirtualObjectNode alias) => [unique? ensure? virtualInputs]
                                (aset objects i alias)
                                (let [
                                    #_"ObjectState" objectState (let [#_"int" id (:oid alias)] (when (< id (count (:objectStates (nth states i)))) (nth (:objectStates (nth states i)) id)))
                                ]
                                    (when (some? objectState) => (ยง return false)
                                        (when (ObjectState''isVirtual-1 objectState) => [unique? ensure? virtualInputs]
                                            [(and (= (nth objects 0) alias) unique?) (and ensure? (:ensureVirtualized objectState)) (inc virtualInputs)]
                                        )
                                    )
                                )
                            )
                    ]
                        (recur unique? ensure? virtualInputs (inc i))
                    )
                )
        ]
            (when (= virtualInputs (count states))
                (if unique?
                    (do
                        ;; all inputs refer to the same object: just make the phi node an alias
                        (PartialEscapeClosure''addVirtualAlias-3 (:peClosure this), (nth objects 0), phi)
                        (GraphEffectList''deleteNode-2 (:mergeEffects this), phi)
                        (ยง return false)
                    )
                    ;; all inputs are virtual: check if they're compatible and without identity
                    (let [
                        #_"boolean" compatible?
                            (loop-when [#_"int" i 0] (< i (count states)) => true
                                (and
                                    (= (VirtualObjectNode'''type-1 (nth objects 0)) (VirtualObjectNode'''type-1 (nth objects i)))
                                    (= (VirtualObjectNode'''entryCount-1 (nth objects 0)) (VirtualObjectNode'''entryCount-1 (nth objects i)))
                                    (ObjectState''locksEqual-2 (nth (:objectStates (nth states 0)) (:oid (nth objects 0))), (nth (:objectStates (nth states i)) (:oid (nth objects i))))
                                    (recur (inc i))
                                )
                            )
                        compatible?
                            (and compatible?
                                (loop-when [compatible? true #_"int" i 0] (< i (count states)) => compatible?
                                    ;; check whether we trivially see that this is the only reference to this allocation
                                    (let [
                                        compatible?
                                            (and compatible?
                                                (or (not (:hasIdentity (nth objects i))) (PEMergeProcessor''isSingleUsageAllocation-4 this, (MergeProcessor''getPhiValueAt-3 this, phi, i), objects, (nth states i)))
                                            )
                                    ]
                                        (recur compatible? (inc i))
                                    )
                                )
                            )
                    ]
                        (when compatible?
                            (let [
                                #_"VirtualObjectNode" virtual (PEMergeProcessor''getValueObjectVirtual-3 this, phi, (nth objects 0))
                            ]
                                (GraphEffectList''addFloatingNode-3 (:mergeEffects this), virtual, "valueObjectNode")
                                (GraphEffectList''deleteNode-2 (:mergeEffects this), phi)
                                (when (= (:oid virtual) -1)
                                    (let [
                                        #_"int" id (count (:virtualObjects (:peClosure this)))
                                    ]
                                        (#_"ArrayList" .add (:virtualObjects (:peClosure this)), virtual)
                                        (ยง ass! virtual (VirtualObjectNode''setObjectId-2 virtual, id))
                                    )
                                )

                                (let [
                                    #_"int[]" virtualObjectIds (int-array (count states))
                                    _
                                        (dotimes [#_"int" i (count states)]
                                            (aset virtualObjectIds i (:oid (nth objects i)))
                                        )
                                    #_"boolean" materialized? (PEMergeProcessor''mergeObjectStates-4 this, (:oid virtual), virtualObjectIds, states)
                                ]
                                    (PartialEscapeClosure''addVirtualAlias-3 (:peClosure this), virtual, virtual)
                                    (PartialEscapeClosure''addVirtualAlias-3 (:peClosure this), virtual, phi)
                                    (ยง return materialized?)
                                )
                            )
                        )
                    )
                )
            )

            ;; otherwise: materialize all phi inputs
            (let [
                #_"boolean" materialized?
                    (and (pos? virtualInputs)
                        (loop-when [materialized? false #_"int" i 0] (< i (count states)) => materialized?
                            (let [
                                materialized?
                                    (when (some? (nth objects i)) => materialized?
                                        (let [
                                            #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                                            #_"ObjectState" objectState (nth (:objectStates (nth states i)) (:oid (nth objects i)))
                                        ]
                                            (when (and (not ensure?) (ObjectState''isVirtual-1 objectState))
                                                ;; we can materialize if not all inputs are "ensureVirtualized"
                                                (ยง ass! objectState (ObjectState''setEnsureVirtualized-2 objectState, false))
                                            )
                                            (or materialized?
                                                (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), (:oid (nth objects i)), (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor))
                                            )
                                        )
                                    )
                            ]
                                (recur materialized? (inc i))
                            )
                        )
                    )
            ]
                (dotimes [#_"int" i (count states)]
                    (when (some? (nth objects i))
                        (MergeProcessor''setPhiInput-4 this, phi, i, (PartialEscapeClosure''getAliasAndResolve-3 (:peClosure this), (nth states i), (nth objects i)))
                    )
                )
                materialized?
            )
        )
    )

    ;;;
     ; Merge all predecessor block states into one block state. This is an iterative process,
     ; because merging states can lead to materializations which make previous parts of the
     ; merging operation invalid. The merging process is executed until a stable state has been
     ; reached. This method needs to be careful to place the effects of the merging operation
     ; into the correct blocks.
     ;
     ; @param statesList the predecessor block states of the merge
     ;;
    (defm PEMergeProcessor #_"<T>" MergeProcessor
        (#_"void" MergeProcessor'''merge-2 [#_"PEMergeProcessor<T>" this, #_"List<T>" statesList]
            (let [
                #_"PartialEscapeBlockState[]" states (make-array PartialEscapeBlockState'iface (count statesList))
                _
                    (dotimes [#_"int" i (count statesList)]
                        (aset states i (nth statesList i))
                    )
                ;; calculate the set of virtual objects that exist in all predecessors
                #_"int[]" virtualObjTemp (PEMergeProcessor'intersectVirtualObjects-1 states)
            ]
                (loop []
                    (let [
                        #_"boolean" materialized?
                            (if (PartialEscapeBlockState'identicalObjectStates-1 states)
                                (do
                                    (ยง ass! (:newState this) (PartialEscapeBlockState''adoptAddObjectStates-2 (:newState this), (nth states 0)))
                                    false
                                )
                                (loop-when [materialized? false #_"ISeq" s (seq virtualObjTemp)] (some? s) => materialized?
                                    (let [
                                        #_"int" object (first s)
                                        materialized?
                                            (when (PartialEscapeBlockState'identicalObjectStates-2 states, object) => materialized?
                                                (PartialEscapeBlockState''addObject-3 (:newState this), object, (ObjectState''share-1 (nth (:objectStates (nth states 0)) object)))
                                                ;; determine if all inputs are virtual or the same materialized value
                                                (let [
                                                    #_"ObjectState" startObj (nth (:objectStates (nth states 0)) object)
                                                    [#_"boolean" ensureVirtual #_"int" virtualCount #_"ValueNode" uniqueMaterializedValue #_"boolean" locksMatch]
                                                        (loop-when [ensureVirtual true virtualCount 0 uniqueMaterializedValue (when-not (ObjectState''isVirtual-1 startObj) (:materializedValue startObj)) locksMatch true #_"int" i 0] (< i (count states)) => [ensureVirtual virtualCount uniqueMaterializedValue locksMatch]
                                                            (let [
                                                                #_"ObjectState" obj (nth (:objectStates (nth states i)) object)
                                                                ensureVirtual (and ensureVirtual (:ensureVirtualized obj))
                                                                [virtualCount uniqueMaterializedValue locksMatch]
                                                                    (if (ObjectState''isVirtual-1 obj)
                                                                        [(inc virtualCount) nil (and locksMatch (ObjectState''locksEqual-2 obj, startObj))]
                                                                        [virtualCount (when (= (:materializedValue obj) uniqueMaterializedValue) uniqueMaterializedValue) locksMatch]
                                                                    )
                                                            ]
                                                                (recur ensureVirtual virtualCount uniqueMaterializedValue locksMatch (inc i))
                                                            )
                                                        )
                                                ]
                                                    (cond
                                                        (and (= virtualCount (count states)) locksMatch)
                                                            (or materialized? (PEMergeProcessor''mergeObjectStates-4 this, object, nil, states))
                                                        (some? uniqueMaterializedValue)
                                                            (do
                                                                (PartialEscapeBlockState''addObject-3 (:newState this), object, (ObjectState'new-3v uniqueMaterializedValue, nil, ensureVirtual))
                                                                materialized?
                                                            )
                                                        :else
                                                            (let [
                                                                #_"PhiNode" materializedValuePhi (PEMergeProcessor''getPhi-3 this, object, (StampFactory'forKind-1 JavaKind/Object))
                                                                _ (GraphEffectList''addFloatingNode-3 (:mergeEffects this), materializedValuePhi, "materializedPhi")
                                                                materialized?
                                                                    (loop-when [materialized? materialized? #_"int" i 0] (< i (count states)) => materialized?
                                                                        (let [
                                                                            #_"ObjectState" obj (nth (:objectStates (nth states i)) object)
                                                                            [materialized? obj]
                                                                                (when (ObjectState''isVirtual-1 obj) => [materialized? obj]
                                                                                    (let [
                                                                                        #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                                                                                    ]
                                                                                        (when (and (not ensureVirtual) (ObjectState''isVirtual-1 obj))
                                                                                            ;; we can materialize if not all inputs are "ensureVirtualized"
                                                                                            (ยง ass! obj (ObjectState''setEnsureVirtualized-2 obj, false))
                                                                                        )
                                                                                        [(or materialized? (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), object, (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor))) (nth (:objectStates (nth states i)) object)]
                                                                                    )
                                                                                )
                                                                        ]
                                                                            (MergeProcessor''setPhiInput-4 this, materializedValuePhi, i, (:materializedValue obj))
                                                                            (recur materialized? (inc i))
                                                                        )
                                                                    )
                                                            ]
                                                                (PartialEscapeBlockState''addObject-3 (:newState this), object, (ObjectState'new-3v materializedValuePhi, nil, false))
                                                                materialized?
                                                            )
                                                    )
                                                )
                                            )
                                    ]
                                        (recur materialized? (next s))
                                    )
                                )
                            )
                        materialized?
                            (loop-when [materialized? materialized? #_"ISeq" s (seq (MergeProcessor''getPhis-1 this))] (some? s) => materialized?
                                (let [
                                    #_"PhiNode" phi (first s)
                                ]
                                    (NodeMap''set-3 (:aliases (:peClosure this)), phi, nil)
                                    (recur (or materialized? (and (NodeBitMap''isMarked-2n (:hasVirtualInputs (:peClosure this)), phi) (satisfies? ValuePhiNode phi) (PEMergeProcessor''processPhi-3 this, phi, states))) (next s))
                                )
                            )
                    ]
                        (when materialized?
                            (ยง ass! (:newState this) (PartialEscapeBlockState''resetObjectStates-2 (:newState this), (count (:virtualObjects (:peClosure this)))))
                            (EffectList'''clear-1 (:mergeEffects this))
                            (EffectList'''clear-1 (:afterMergeEffects this))
                        )
                        (recur-if materialized? [])
                    )
                )
            )
            nil
        )
    )
)

(class-ns PEReadEliminationMergeProcessor [PEMergeProcessor #_"<PEReadEliminationBlockState>", MergeProcessor #_"<PEReadEliminationBlockState>"]
    (defn #_"PEReadEliminationMergeProcessor" PEReadEliminationMergeProcessor'new-2 [#_"PEReadEliminationClosure" reClosure, #_"Block" mergeBlock]
        (merge (PEReadEliminationMergeProcessor'class.) (PEMergeProcessor'new-2 reClosure, mergeBlock))
    )

    (defn- #_"void" PEReadEliminationMergeProcessor''mergeReadCachePhi-7 [#_"PEReadEliminationMergeProcessor" this, #_"PhiNode" phi, #_"LocationIdentity" location, #_"int" index, #_"JavaKind" kind, #_"boolean" overflowAccess, #_"List<PEReadEliminationBlockState>" states]
        (let [
            #_"ValueNode[]" values (make-array ValueNode'iface (count states))
        ]
            (aset values 0 (PEReadEliminationBlockState''getReadCache-6 (nth states 0), (MergeProcessor''getPhiValueAt-3 this, phi, 0), location, index, kind, (:peClosure this)))
            (when (some? (nth values 0))
                (loop [#_"int" i 1]
                    (if (< i (count states))
                        (let [
                            #_"ValueNode" value (PEReadEliminationBlockState''getReadCache-6 (nth states i), (MergeProcessor''getPhiValueAt-3 this, phi, i), location, index, kind, (:peClosure this))
                        ]
                            ;; e.g. unsafe loads/stores with same identity, but different access kinds, see mergeReadCache(states)
                            (when (and (some? value) (Stamp'''isCompatible-2s (:stamp (nth values (dec i))), (:stamp value)))
                                (aset values i value)
                                (recur (inc i))
                            )
                        )
                        (let [
                            #_"PhiNode" phiNode (PEMergeProcessor''getPhi-3 this, (ReadCacheEntry'new-5 location, phi, index, kind, overflowAccess), (Stamp'''unrestricted-1 (:stamp (nth values 0))))
                        ]
                            (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCachePhi")
                            (dotimes [#_"int" i (count values)]
                                (MergeProcessor''setPhiInput-4 this, phiNode, i, (nth values i))
                            )
                            (#_"EconomicMap" .put (:readCache (:newState this)), (ReadCacheEntry'new-5 location, phi, index, kind, overflowAccess), phiNode)
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" PEReadEliminationMergeProcessor''mergeReadCache-2 [#_"PEReadEliminationMergeProcessor" this, #_"List<PEReadEliminationBlockState>" states]
        (let [
            #_"MapCursor<ReadCacheEntry, ValueNode>" cursor (#_"EconomicMap" .getEntries (:readCache (nth states 0)))
        ]
            (while (#_"MapCursor" .advance cursor)
                (let [
                    #_"ReadCacheEntry" key (#_"MapCursor" .getKey cursor)
                    [#_"ValueNode" value #_"boolean" phi]
                        (loop-when [value (#_"MapCursor" .getValue cursor) phi false #_"int" i 1] (< i (count states)) => [value phi]
                            (let [
                                #_"ValueNode" other (get (:readCache (nth states i)) key)
                            ]
                                ;; e.g. unsafe loads/stores with different access kinds have different stamps although location,
                                ;; object and offset are the same, in this case we cannot create a phi nor can we set a common value
                                (when (and (some? other) (Stamp'''isCompatible-2s (:stamp value), (:stamp other))) => [nil false]
                                    (recur value (or phi (not (= other value))) (inc i))
                                )
                            )
                        )
                ]
                    (cond
                        phi
                            (let [
                                #_"PhiNode" phiNode (PEMergeProcessor''getPhi-3 this, key, (Stamp'''unrestricted-1 (:stamp value)))
                            ]
                                (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCache")
                                (dotimes [#_"int" i (count states)]
                                    (MergeProcessor''setPhiInput-4 this, phiNode, i, (PEReadEliminationBlockState''getReadCache-6 (nth states i), (:object key), (:identity key), (:index key), (:kind key), (:peClosure this)))
                                )
                                (#_"EconomicMap" .put (:readCache (:newState this)), key, phiNode)
                            )
                        (some? value)
                            (#_"EconomicMap" .put (:readCache (:newState this)), key, value)
                    )
                )
            )
            ;; For object phis, see if there are known reads on all predecessors, for which we could create new phis.
            (doseq [#_"PhiNode" phi (MergeProcessor''getPhis-1 this)]
                (when (= (ValueNode''getStackKind-1 phi) JavaKind/Object)
                    (doseq [#_"ReadCacheEntry" entry (keys (:readCache (nth states 0)))]
                        (when (= (:object entry) (MergeProcessor''getPhiValueAt-3 this, phi, 0))
                            (PEReadEliminationMergeProcessor''mergeReadCachePhi-7 this, phi, (:identity entry), (:index entry), (:kind entry), (:overflowAccess entry), states)
                        )
                    )
                )
            )
        )
        nil
    )

    (defm PEReadEliminationMergeProcessor MergeProcessor
        (#_"void" MergeProcessor'''merge-2 [#_"PEReadEliminationMergeProcessor" this, #_"List<PEReadEliminationBlockState>" states]
            (MergeProcessor'''merge-2 (ยง super #_"PEMergeProcessor"), states)

            (PEReadEliminationMergeProcessor''mergeReadCache-2 this, states)
            nil
        )
    )
)

(class-ns ReadEliminationMergeProcessor [MergeProcessor #_"<ReadEliminationBlockState>"]
    (defn #_"ReadEliminationMergeProcessor" ReadEliminationMergeProcessor'new-1 [#_"Block" mergeBlock]
        (merge (ReadEliminationMergeProcessor'class.) (MergeProcessor'new-1 mergeBlock)
            (hash-map
                #_"EconomicMap<Object, ValuePhiNode>" :materializedPhis (EconomicMap/create)
            )
        )
    )

    (defn #_"ValuePhiNode" ReadEliminationMergeProcessor''getCachedPhi-3 [#_"ReadEliminationMergeProcessor" this, #_"CacheEntry" virtual, #_"Stamp" stamp]
        (or (get (:materializedPhis this) virtual)
            (let [
                #_"ValuePhiNode" result (MergeProcessor''createValuePhi-2 this, stamp)
            ]
                (#_"EconomicMap" .put (:materializedPhis this), virtual, result)
                result
            )
        )
    )

    (defn- #_"void" ReadEliminationMergeProcessor''mergeReadCachePhi-4 [#_"ReadEliminationMergeProcessor" this, #_"PhiNode" phi, #_"CacheEntry" identifier, #_"List<ReadEliminationBlockState>" states]
        (let [
            #_"ValueNode[]" values (make-array ValueNode'iface (count states))
        ]
            (aset values 0 (ReadEliminationBlockState''getCacheEntry-2 (nth states 0), (CacheEntry'''duplicateWithObject-2 identifier, (MergeProcessor''getPhiValueAt-3 this, phi, 0))))
            (when (some? (nth values 0))
                (loop [#_"int" i 1]
                    (if (< i (count states))
                        (let [
                            #_"ValueNode" value (ReadEliminationBlockState''getCacheEntry-2 (nth states i), (CacheEntry'''duplicateWithObject-2 identifier, (MergeProcessor''getPhiValueAt-3 this, phi, i)))
                        ]
                            ;; e.g. unsafe loads/stores with same identity, but different access kinds, see mergeReadCache(states)
                            (when (and (some? value) (Stamp'''isCompatible-2s (:stamp (nth values (dec i))), (:stamp value)))
                                (aset values i value)
                                (recur (inc i))
                            )
                        )
                        (let [
                            #_"CacheEntry" newIdentifier (CacheEntry'''duplicateWithObject-2 identifier, phi)
                            #_"PhiNode" phiNode (ReadEliminationMergeProcessor''getCachedPhi-3 this, newIdentifier, (Stamp'''unrestricted-1 (:stamp (nth values 0))))
                        ]
                            (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCachePhi")
                            (dotimes [#_"int" i (count values)]
                                (MergeProcessor''setPhiInput-4 this, phiNode, i, (nth values i))
                            )
                            (ReadEliminationBlockState''addCacheEntry-3 (:newState this), newIdentifier, phiNode)
                        )
                    )
                )
            )
        )
        nil
    )

    (defm ReadEliminationMergeProcessor MergeProcessor
        (#_"void" MergeProcessor'''merge-2 [#_"ReadEliminationMergeProcessor" this, #_"List<ReadEliminationBlockState>" states]
            (let [
                #_"MapCursor<CacheEntry, ValueNode>" cursor (#_"EconomicMap" .getEntries (:readCache (nth states 0)))
            ]
                (while (#_"MapCursor" .advance cursor)
                    (let [
                        #_"CacheEntry" key (#_"MapCursor" .getKey cursor)
                        [#_"ValueNode" value #_"boolean" phi]
                            (loop-when [value (#_"MapCursor" .getValue cursor) phi false #_"int" i 1] (< i (count states)) => [value phi]
                                (let [
                                    #_"ValueNode" other (get (:readCache (nth states i)) key)
                                ]
                                    ;; e.g. unsafe loads/stores with different access kinds have different stamps although location,
                                    ;; object and offset are the same, in this case we cannot create a phi nor can we set a common value
                                    (when (and (some? other) (Stamp'''isCompatible-2s (:stamp value), (:stamp other))) => [nil false]
                                        (recur value (or phi (not (= other value))) (inc i))
                                    )
                                )
                            )
                    ]
                        (cond
                            phi
                                (let [
                                    #_"PhiNode" phiNode (ReadEliminationMergeProcessor''getCachedPhi-3 this, key, (Stamp'''unrestricted-1 (:stamp value)))
                                ]
                                    (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCache")
                                    (dotimes [#_"int" i (count states)]
                                        (MergeProcessor''setPhiInput-4 this, phiNode, i, (ReadEliminationBlockState''getCacheEntry-2 (nth states i), key))
                                    )
                                    (ReadEliminationBlockState''addCacheEntry-3 (:newState this), key, phiNode)
                                )
                            (some? value)
                                ;; there is the same value on all branches
                                (ReadEliminationBlockState''addCacheEntry-3 (:newState this), key, value)
                        )
                    )
                )
                ;; For object phis, see if there are known reads on all predecessors, for which we could create new phis.
                (doseq [#_"PhiNode" phi (MergeProcessor''getPhis-1 this)]
                    (when (= (ValueNode''getStackKind-1 phi) JavaKind/Object)
                        (doseq [#_"CacheEntry" entry (keys (:readCache (nth states 0)))]
                            (when (= (:object entry) (MergeProcessor''getPhiValueAt-3 this, phi, 0))
                                (ReadEliminationMergeProcessor''mergeReadCachePhi-4 this, phi, entry, states)
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; An instance of this class denotes a callsite being analyzed for inlining.
 ;
 ; Each element of the InliningData stack contains one such instance, the accompanying
 ; CallsiteHolders in that element represent feasible targets for the callsite in question.
 ;;
(class-ns MethodInvocation []
    (defn #_"MethodInvocation" MethodInvocation'new-4 [#_"InlineInfo" info, #_"double" probability, #_"double" relevance, #_"BitSet" freshArgs]
        (merge (MethodInvocation'class.)
            (hash-map
                #_"InlineInfo" :callee info
                #_"double" :probability probability
                #_"double" :relevance relevance
                #_"int" :processedGraphs 0
                ;;;
                 ; The immutable positions of freshly instantiated arguments (i.e. positions in {@code callee.invoke.callTarget.arguments}).
                 ;
                 ; A freshly instantiated argument is either:
                 ;
                 ; (1) an InliningData#isFreshInstantiation(ValueNode)
                 ; (2) a fixed-param of the graph containing the callsite (i.e. of {@code callee.graph()} that contains {@code callee.invoke})
                 ;
                 ; Given those positions, the CallsiteHolderExplorable instantiated in #buildCallsiteHolderForElement(int) can determine
                 ; which of <i>its</i> parameters are fixed.
                 ;;
                #_"BitSet" :freshArgs freshArgs
                #_"int" :sizeFreshArgs (if (some? freshArgs) (#_"BitSet" .cardinality freshArgs) 0)
            )
        )
    )

    (defn #_"MethodInvocation" MethodInvocation''incrementProcessedGraphs-1 [#_"MethodInvocation" this]
        (update this :processedGraphs inc)
    )

    (defn #_"int" MethodInvocation''totalGraphs-1 [#_"MethodInvocation" this]
        (InlineInfo'''numberOfMethods-1 (:callee this))
    )

    (defn #_"boolean" MethodInvocation''isRoot-1 [#_"MethodInvocation" this]
        (nil? (:callee this))
    )

    (defn #_"CallsiteHolder" MethodInvocation''buildCallsiteHolderForElement-2 [#_"MethodInvocation" this, #_"int" index]
        (let [
            #_"Inlineable" elem (InlineInfo'''inlineableElementAt-2 (:callee this), index)
            #_"double" invokeProbability (* (:probability this) (InlineInfo'''probabilityAt-2 (:callee this), index))
            #_"double" invokeRelevance (* (:relevance this) (InlineInfo'''relevanceAt-2 (:callee this), index))
        ]
            (CallsiteHolder'new-4 (:graph elem), invokeProbability, invokeRelevance, (:freshArgs this))
        )
    )
)

;;;
 ; Name and descriptor of a method.
 ;;
(class-ns MethodKey []
    (defn #_"MethodKey" MethodKey'new-2 [#_"String" name, #_"String" descriptor]
        (merge (MethodKey'class.)
            (hash-map
                #_"String" :name name
                #_"String" :descriptor descriptor
            )
        )
    )
)

;;;
 ; Method cache for a ResolvedJavaType.
 ;;
(class-ns MethodsCache []
    (defn #_"MethodsCache" MethodsCache'new-0 []
        (MethodsCache'class.)
    )

    (ยง volatile #_"EconomicMap<MethodKey, ResolvedJavaMethod>" :constructors nil)
    (ยง volatile #_"EconomicMap<MethodKey, ResolvedJavaMethod>" :methods nil)

    (defn- #_"EconomicMap<MethodKey, ResolvedJavaMethod>" MethodsCache'createMethodMap-1 [#_"ResolvedJavaMethod*" methods]
        (let [
            #_"EconomicMap<MethodKey, ResolvedJavaMethod>" map (EconomicMap/create)
        ]
            (doseq [#_"ResolvedJavaMethod" m methods]
                (#_"EconomicMap" .put map, (MethodKey'new-2 (#_"ResolvedJavaMethod" .getName m), (#_"Signature" .toMethodDescriptor (#_"ResolvedJavaMethod" .getSignature m))), m)
            )
            map
        )
    )

    (defn #_"ResolvedJavaMethod" MethodsCache''lookup-4 [#_"MethodsCache" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" descriptor]
        (let [
            #_"MethodKey" key (MethodKey'new-2 name, descriptor)
        ]
            (case name
                "<clinit>"
                    ;; no need to cache <clinit> as it will be looked up at most once
                    (#_"ResolvedJavaType" .getClassInitializer type)
                "<init>"
                    (do
                        (when (nil? (:constructors this))
                            ;; racy initialization is safe since instanceFields is volatile
                            (ยง ass! this (assoc this :constructors (MethodsCache'createMethodMap-1 (#_"ResolvedJavaType" .getDeclaredConstructors type))))
                        )
                        (get (:constructors this) key)
                    )
                (do
                    (when (nil? (:methods this))
                        ;; racy initialization is safe since 'methods' is volatile
                        (ยง ass! this (assoc this :methods (MethodsCache'createMethodMap-1 (#_"ResolvedJavaType" .getDeclaredMethods type))))
                    )
                    (get (:methods this) key)
                )
            )
        )
    )
)

;;;
 ; Micro block that is allocated for each fixed node and captures all floating nodes that
 ; need to be scheduled immediately after the corresponding fixed node.
 ;;
(class-ns MicroBlock []
    (defn #_"MicroBlock" MicroBlock'new-1 [#_"int" id]
        (merge (MicroBlock'class.)
            (hash-map
                ;;;
                 ; The id of the micro block, with a block always associated with a lower id than its successors.
                 ;;
                #_"int" :id id
                ;;;
                 ; Number of nodes in this micro block.
                 ;;
                #_"int" :nodeCount 0
                ;;;
                 ; First node of the linked list of nodes of this micro block.
                 ;;
                #_"NodeEntry" :head nil
                #_"NodeEntry" :tail nil
            )
        )
    )

    ;;;
     ; Adds a new floating node into the micro block.
     ;;
    (defn #_"this" MicroBlock''add-2 [#_"MicroBlock" this, #_"Node" node]
        (let [
            #_"NodeEntry" tail (NodeEntry'new-1 node)
            this
                (if (nil? (:tail this))
                    (let [
                        this (assoc this :head tail)
                        this (assoc this :tail tail)
                    ]
                        this
                    )
                    (let [
                        _ (ยง ass! (:next (:tail this)) tail)
                        this (assoc this :tail tail)
                    ]
                        this
                    )
                )
            this (update this :nodeCount inc)
        ]
            this
        )
    )

    ;;;
     ; Takes all nodes in this micro blocks and prepends them to the nodes of the given parameter.
     ;
     ; @param block the new block for the nodes
     ;;
    (defn #_"MicroBlock" MicroBlock''prependChildrenTo-2 [#_"MicroBlock" this, #_"MicroBlock" block]
        (when (some? (:tail this)) => this
            (let [
                _ (ยง ass! (:next (:tail this)) (:head block))
                _ (ยง ass! block (assoc block :head (:head this)))
                this (assoc this :tail nil)
                this (assoc this :head nil)
                _ (ยง ass! block (assoc block :nodeCount (+ (:nodeCount block) (:nodeCount this))))
                this (assoc this :nodeCount 0)
            ]
                this
            )
        )
    )
)

;;;
 ; Factory for creating moves.
 ;;
(class-ns MoveFactory []
    (defn #_"MoveFactory" MoveFactory'new-1 [#_"FrameMapBuilder" frameMapBuilder]
        (merge (MoveFactory'class.)
            (hash-map
                #_"FrameMapBuilder" :frameMapBuilder frameMapBuilder
            )
        )
    )

    #_memoize
    (defn #_"RegisterBackupPair" MoveFactory''getScratchRegister-2 [#_"MoveFactory" this, #_"PlatformKind" kind]
        (let [
            #_"RegisterArray" available (#_"RegisterConfig" .filterAllocatableRegisters HotSpot'registerConfig, kind, (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))
            #_"Register" scratch (#_"RegisterArray" .get available, 0)
            #_"LIRKind" largest (LIRKind'value-1 (#_"Architecture" .getLargestStorableKind (.arch HotSpot'target), (#_"Register" .getRegisterCategory scratch)))
        ]
            (RegisterBackupPair'new-2 scratch, (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder this), largest))
        )
    )

    ;;;
     ; Checks whether the supplied constant can be used without loading it into a register for
     ; most operations, i.e. for commonly used arithmetic, logical, and comparison operations.
     ;
     ; @return true if the constant can be used directly, false if the constant needs to be in a register
     ;;
    (defn #_"boolean" MoveFactory'canInlineConstant-1 [#_"Constant" constant]
        (or (= constant HotSpotCompressedNullConstant/COMPRESSED_NULL)
            (condp instance? constant
                HotSpotObjectConstant    (KlassPointerStamp''isCompressed-1 constant)
                HotSpotMetaspaceConstant (KlassPointerStamp''isCompressed-1 constant)
                JavaConstant
                    (condp = (#_"JavaConstant" .getJavaKind constant)
                        JavaKind/Long   (NumUtil'isInt-1 (#_"JavaConstant" .asLong constant))
                        JavaKind/Object (#_"JavaConstant" .isNull constant)
                        true
                    )
                false
            )
        )
    )

    ;;;
     ; @param constant The constant that might be moved to a stack slot.
     ; @return true if constant to stack moves are supported for this constant
     ;;
    #_unused
    (defn #_"boolean" MoveFactory'allowConstantToStackMove-1 [#_"Constant" constant]
        (condp instance? constant
            HotSpotConstant (#_"HotSpotConstant" .isCompressed constant)
            JavaConstant    (AMD64Move'canMoveConst2Stack-1 constant)
                            true
        )
    )

    (defn #_"LIRInstruction" MoveFactory'createMove-2 [#_"AllocatableValue" dst, #_"Value" src]
        (cond
            (satisfies? AMD64AddressValue src)                                       (LeaOp'new-3 dst, src, OperandSize'QWORD)
            (satisfies? ConstantValue src)                                           (MoveFactory'createLoad-2 dst, (:constant src))
            (or (instance? RegisterValue src) (LIRValueUtil'isStackSlotValue-1 dst)) (MoveFromRegOp'new-3 (#_"Value" .getPlatformKind dst), dst, src)
            :else                                                                    (MoveToRegOp'new-3 (#_"Value" .getPlatformKind dst), dst, src)
        )
    )

    (defn #_"LIRInstruction" MoveFactory''createStackMove-3 [#_"MoveFactory" this, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (case (#_"AMD64Kind" .getSizeInBytes (#_"Value" .getPlatformKind result))
            2 (AMD64PushPopStackMove'new-3 OperandSize'WORD, result, input)
            8 (AMD64PushPopStackMove'new-3 OperandSize'QWORD, result, input)
            (let [
                #_"RegisterBackupPair" backup (MoveFactory''getScratchRegister-2 this, (#_"Value" .getPlatformKind input))
            ]
                (AMD64StackMove'new-4 result, input, (:register backup), (:backupSlot backup))
            )
        )
    )

    (defn- #_"LIRInstruction" MoveFactory'createLoad-2 [#_"AllocatableValue" dst, #_"Constant" src]
        (condp instance? src
            JavaConstant (MoveFromConstOp'new-2 dst, src)
        )
    )

    (defn #_"LIRInstruction" MoveFactory'createLoad-2 [#_"AllocatableValue" dst, #_"Constant" src]
        (when-not (= src HotSpotCompressedNullConstant/COMPRESSED_NULL) => (MoveFactory'createLoad-2 dst, JavaConstant/INT_0)
            (condp instance? src
                HotSpotObjectConstant    (LoadObjectConstantOp'new-2 dst, src)
                HotSpotMetaspaceConstant (LoadMetaspaceConstantOp'new-2 dst, src)
                                         (MoveFactory'createLoad-2 dst, src)
            )
        )
    )

    (defn- #_"LIRInstruction" MoveFactory'createStackLoad-2 [#_"AllocatableValue" dst, #_"Constant" src]
        (condp instance? src
            JavaConstant (MoveFromConstOp'new-2 dst, src)
        )
    )

    (defn #_"LIRInstruction" MoveFactory'createStackLoad-2 [#_"AllocatableValue" dst, #_"Constant" src]
        (when-not (= src HotSpotCompressedNullConstant/COMPRESSED_NULL) => (MoveFactory'createStackLoad-2 dst, JavaConstant/INT_0)
            (condp instance? src
                HotSpotObjectConstant    (LoadObjectConstantOp'new-2 dst, src)
                HotSpotMetaspaceConstant (LoadMetaspaceConstantOp'new-2 dst, src)
                                         (MoveFactory'createStackLoad-2 dst, src)
            )
        )
    )
)

(class-ns MoveGuardsUpwards [RecursiveVisitor #_"<Block>"]
    (defn #_"MoveGuardsUpwards" MoveGuardsUpwards'new-0 []
        (merge (MoveGuardsUpwards'class.)
            (hash-map
                #_"Block" :anchorBlock nil
            )
        )
    )

    (defm MoveGuardsUpwards RecursiveVisitor
        (#_"Block" RecursiveVisitor'''enter-2 [#_"MoveGuardsUpwards" this, #_"Block" block]
            (let [
                #_"Block" o'anchorBlock (:anchorBlock this)
            ]
                (when-not (and (some? (:dominator block)) (= (:postdominator (:dominator block)) block))
                    ;; New anchor.
                    (ยง ass! this (assoc this :anchorBlock block))
                )

                (let [
                    #_"AbstractBeginNode" begin (:beginNode block)
                ]
                    (when (and (satisfies? AbstractMergeNode begin) (not= (:anchorBlock this) block))
                        (doseq [#_"GuardNode" guard (ยง snap (AbstractBeginNode''guards-1 begin))]
                            (ยง ass! guard (Node''replaceAndDelete-2 guard, (Graph''add-2 (:graph begin), (GuardNode'new-6 (DeoptimizingGuard'''getCondition-1 guard), (:beginNode (:anchorBlock this)), (:reason guard), (:action guard), (:negated? guard), (:speculation guard)))))
                        )
                    )

                    (let [
                        #_"FixedNode" end (:endNode block)
                    ]
                        (when (satisfies? IfNode end)
                            (let [
                                ;; Check if we can move guards upwards.
                                #_"EconomicMap<LogicNode, GuardNode>" trueGuards (EconomicMap/create)
                                _
                                    (doseq [#_"GuardNode" guard (AbstractBeginNode''guards-1 (:trueSuccessor end))]
                                        (let [
                                            #_"LogicNode" logic (DeoptimizingGuard'''getCondition-1 guard)
                                        ]
                                            (when (Node''hasMoreThanOneUsage-1 logic)
                                                (#_"EconomicMap" .put trueGuards, logic, guard)
                                            )
                                        )
                                    )
                            ]
                                (when (seq trueGuards)
                                    (loop-when-recur [#_"ISeq" s (seq (ยง snap (AbstractBeginNode''guards-1 (:falseSuccessor end))))] (some? s) [(next s)]
                                        (let [
                                            #_"GuardNode" guard (first s)
                                            #_"GuardNode" other (get trueGuards (DeoptimizingGuard'''getCondition-1 guard))
                                        ]
                                            (when (and (some? other) (= (:negated? guard) (:negated? other)))
                                                (let [
                                                    #_"JavaConstant" speculation
                                                        (cond
                                                            (nil? (:speculation other))                                                    (:speculation guard)
                                                            (or (nil? (:speculation guard)) (= (:speculation guard) (:speculation other))) (:speculation other)
                                                            :else
                                                                ;; Cannot optimize due to different speculations.
                                                                (ยง continue )
                                                        )
                                                ]
                                                    (let [
                                                        #_"GuardNode" newGuard (Graph''add-2 (:graph end), (GuardNode'new-6 (DeoptimizingGuard'''getCondition-1 guard), (:beginNode (:anchorBlock this)), (:reason guard), (:action guard), (:negated? guard), speculation))
                                                    ]
                                                        (when (Node''isAlive-1 other)
                                                            (ยง ass! other (Node''replaceAndDelete-2 other, newGuard))
                                                        )
                                                        (ยง ass! guard (Node''replaceAndDelete-2 guard, newGuard))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        o'anchorBlock
                    )
                )
            )
        )

        (#_"this" RecursiveVisitor'''exit-3 [#_"MoveGuardsUpwards" this, #_"Block" block, #_"Block" value]
            (assoc this :anchorBlock value)
        )
    )
)

(class-ns MoveResolver []
    (defm MoveResolver MoveResolver
        (#_"void" MoveResolver'''setValueBlocked-3 [#_"MoveResolver" this, #_"Value" location, #_"int" direction]
            (when (instance? RegisterValue location) => (throw! (str "unhandled value " location))
                (aswap (:registerBlocked this) (.number (#_"RegisterValue" .getRegister location)) + direction)
            )
            nil
        )
    )

    (defn #_"Interval" MoveResolver''getMappingFrom-2 [#_"MoveResolver" this, #_"int" i]
        (nth (:mappingFrom this) i)
    )

    (defm MoveResolver MoveResolver
        (#_"int" MoveResolver'''valueBlocked-2 [#_"MoveResolver" this, #_"Value" location]
            (when (instance? RegisterValue location) => (throw! (str "unhandled value " location))
                (nth (:registerBlocked this) (.number (#_"RegisterValue" .getRegister location)))
            )
        )
    )

    (defn #_"boolean" MoveResolver''hasMappings-1 [#_"MoveResolver" this]
        (seq (:mappingFrom this))
    )

    (defn #_"MoveResolver" MoveResolver'new-1 [#_"LinearScan" allocator]
        (merge (MoveResolver'class.)
            (hash-map
                #_"LinearScan" :allocator allocator
                #_"int" :insertIdx -1
                #_"LIRInsertionBuffer" :insertionBuffer (LIRInsertionBuffer'new-0) ;; buffer where moves are inserted
                #_"ArrayList<Interval>" :mappingFrom (ArrayList.)
                #_"ArrayList<Constant>" :mappingFromOpr (ArrayList.)
                #_"ArrayList<Interval>" :mappingTo (ArrayList.)
                #_"int[]" :registerBlocked (int-array (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator)))
            )
        )
    )

    ;; mark assignedReg and assignedRegHi of the interval as blocked
    (defn- #_"void" MoveResolver''blockRegisters-2 [#_"MoveResolver" this, #_"Interval" interval]
        (let [
            #_"Value" location (:location interval)
        ]
            (when (MoveResolver'''mightBeBlocked-2 this, location)
                (let [
                    #_"int" direction 1
                ]
                    (MoveResolver'''setValueBlocked-3 this, location, direction)
                )
            )
        )
        nil
    )

    ;; mark assignedReg and assignedRegHi of the interval as unblocked
    (defn- #_"void" MoveResolver''unblockRegisters-2 [#_"MoveResolver" this, #_"Interval" interval]
        (let [
            #_"Value" location (:location interval)
        ]
            (when (MoveResolver'''mightBeBlocked-2 this, location)
                (MoveResolver'''setValueBlocked-3 this, location, -1)
            )
        )
        nil
    )

    (defn- #_"boolean" MoveResolver'isMoveToSelf-2 [#_"Value" from, #_"Value" to]
        (or (= to from)
            (and (some? from)
                (instance? RegisterValue from) (instance? RegisterValue to)
                (= (#_"RegisterValue" .getRegister from) (#_"RegisterValue" .getRegister to))
            )
        )
    )

    ;;;
     ; Checks if the {@linkplain Interval#location() location} of {@code to} is not blocked or is only blocked by {@code from}.
     ;;
    (defn- #_"boolean" MoveResolver''safeToProcessMove-3 [#_"MoveResolver" this, #_"Interval" from, #_"Interval" to]
        (let [
            #_"Value" fromReg (when (some? from) (:location from))
            #_"Value" location (:location to)
        ]
            (not (and (MoveResolver'''mightBeBlocked-2 this, location)
                      (or (< 1 (MoveResolver'''valueBlocked-2 this, location))
                          (and (= (MoveResolver'''valueBlocked-2 this, location) 1)
                               (not (MoveResolver'isMoveToSelf-2 fromReg, location))
                          )
                      )
                 )
            )
        )
    )

    (defm MoveResolver MoveResolver
        (#_"boolean" MoveResolver'''mightBeBlocked-2 [#_"MoveResolver" this, #_"Value" location]
            (instance? RegisterValue location)
        )
    )

    (defn- #_"void" MoveResolver''createInsertionBuffer-2 [#_"MoveResolver" this, #_"List<LIRInstruction>" list]
        (ยง ass! (:insertionBuffer this) (LIRInsertionBuffer''init-2 (:insertionBuffer this), list))
        nil
    )

    (defn- #_"this" MoveResolver''appendInsertionBuffer-1 [#_"MoveResolver" this]
        (let [
            _
                (when (LIRInsertionBuffer''initialized-1 (:insertionBuffer this))
                    (ยง ass! (:insertionBuffer this) (LIRInsertionBuffer''finish-1 (:insertionBuffer this)))
                )
        ]
            (assoc this :insertIdx -1)
        )
    )

    (defn- #_"LIRInstruction" MoveResolver''insertMove-3i [#_"MoveResolver" this, #_"Interval" fromInterval, #_"Interval" toInterval]
        (let [
            #_"LIRInstruction" move (MoveResolver'''createMove-5 this, (:operand fromInterval), (:operand toInterval), (:location fromInterval), (:location toInterval))
        ]
            (ยง ass! (:insertionBuffer this) (LIRInsertionBuffer''append-3 (:insertionBuffer this), (:insertIdx this), move))

            move
        )
    )

    (defm MoveResolver MoveResolver
        (#_"LIRInstruction" MoveResolver'''createMove-5 [#_"MoveResolver" this, #_"AllocatableValue" fromOpr, #_"AllocatableValue" toOpr, #_"AllocatableValue" fromLocation, #_"AllocatableValue" toLocation]
            (MoveFactory'createMove-2 toOpr, fromOpr)
        )
    )

    (defn- #_"LIRInstruction" MoveResolver''insertMove-3c [#_"MoveResolver" this, #_"Constant" fromOpr, #_"Interval" toInterval]
        (let [
            #_"AllocatableValue" toOpr (:operand toInterval)
            #_"LIRInstruction" move
                (if (LIRValueUtil'isStackSlotValue-1 (:location toInterval))
                    (MoveFactory'createStackLoad-2 toOpr, fromOpr)
                    (MoveFactory'createLoad-2 toOpr, fromOpr)
                )
        ]
            (ยง ass! (:insertionBuffer this) (LIRInsertionBuffer''append-3 (:insertionBuffer this), (:insertIdx this), move))
            move
        )
    )

    (defn- #_"this" MoveResolver''resolveMappings-1 [#_"MoveResolver" this]
        ;; Block all registers that are used as input operands of a move.
        ;; When a register is blocked, no move to this register is emitted.
        ;; This is necessary for detecting cycles in moves.
        (loop-when-recur [#_"int" i (dec (count (:mappingFrom this)))] (<= 0 i) [(dec i)]
            (let [
                #_"Interval" fromInterval (nth (:mappingFrom this) i)
            ]
                (when (some? fromInterval)
                    (MoveResolver''blockRegisters-2 this, fromInterval)
                )
            )
        )

        (loop-when [#_"ArrayList<AllocatableValue>" busySpillSlots nil] (seq (:mappingFrom this))
            (let [
                [busySpillSlots #_"boolean" processed? #_"int" spillCandidate]
                    (loop-when [busySpillSlots busySpillSlots processed? false spillCandidate -1 #_"int" i (dec (count (:mappingFrom this)))] (<= 0 i) => [busySpillSlots processed? spillCandidate]
                        (let [
                            #_"Interval" fromInterval (nth (:mappingFrom this) i)
                            #_"Interval" toInterval (nth (:mappingTo this) i)
                            [busySpillSlots processed? spillCandidate]
                                (when (MoveResolver''safeToProcessMove-3 this, fromInterval, toInterval) => [busySpillSlots processed? (if (and (some? fromInterval) (instance? RegisterValue (:location fromInterval)) (not (and (some? busySpillSlots) (#_"ArrayList" .contains busySpillSlots, (Interval''spillSlot-1 fromInterval))))) i spillCandidate)]
                                    (let [
                                        #_"LIRInstruction" move
                                            (when (some? fromInterval) => (MoveResolver''insertMove-3c this, (nth (:mappingFromOpr this) i), toInterval)
                                                (let [
                                                    move (MoveResolver''insertMove-3i this, fromInterval, toInterval)
                                                ]
                                                    (MoveResolver''unblockRegisters-2 this, fromInterval)
                                                    move
                                                )
                                            )
                                        busySpillSlots
                                            (when (LIRValueUtil'isStackSlotValue-1 (:location toInterval)) => busySpillSlots
                                                (let [
                                                    busySpillSlots (or busySpillSlots (ArrayList.))
                                                ]
                                                    (#_"ArrayList" .add busySpillSlots, (:location toInterval))
                                                    busySpillSlots
                                                )
                                            )
                                    ]
                                        (#_"ArrayList" .remove (:mappingFrom this), i)
                                        (#_"ArrayList" .remove (:mappingFromOpr this), i)
                                        (#_"ArrayList" .remove (:mappingTo this), i)

                                        [busySpillSlots true spillCandidate]
                                    )
                                )
                        ]
                            (recur busySpillSlots processed? spillCandidate (dec i))
                        )
                    )
            ]
                (when-not processed?
                    (MoveResolver'''breakCycle-2 this, spillCandidate)
                )
                (recur busySpillSlots)
            )
        )

        this
    )

    (defm MoveResolver MoveResolver
        (#_"void" MoveResolver'''breakCycle-2 [#_"MoveResolver" this, #_"int" spillCandidate]
            ;; no move could be processed because there is a cycle in the move list
            ;; (e.g. r1 . r2, r2 . r1), so one interval must be spilled to memory

            ;; create a new spill interval and assign a stack slot to it
            (let [
                #_"Interval" fromInterval (nth (:mappingFrom this) spillCandidate)
                ;; do not allocate a new spill slot for temporary interval, but
                ;; use spill slot assigned to fromInterval. Otherwise moves from
                ;; one stack slot to another can happen (not allowed by LIRAssembler)
                #_"AllocatableValue" spillSlot (Interval''spillSlot-1 fromInterval)
            ]
                (when (nil? spillSlot)
                    (ยง ass spillSlot (FrameMapBuilder''allocateSpillSlot-2 (LinearScan''getFrameMapBuilder-1 (:allocator this)), (:kind fromInterval)))
                    (Interval''setSpillSlot-2 fromInterval, spillSlot)
                )
                (MoveResolver''spillInterval-4 this, spillCandidate, fromInterval, spillSlot)
            )
            nil
        )
    )

    (defn #_"void" MoveResolver''spillInterval-4 [#_"MoveResolver" this, #_"int" spillCandidate, #_"Interval" fromInterval, #_"AllocatableValue" spillSlot]
        (let [
            #_"Interval" spillInterval (LinearScan''createDerivedInterval-2 (:allocator this), fromInterval)
        ]
            (ยง ass! spillInterval (Interval''setKind-2 spillInterval, (:kind fromInterval)))

            ;; add a dummy range because real position is difficult to calculate
            ;; note: this range is a special case when the integrity of the allocation is checked
            (ยง ass! spillInterval (Interval''addRange-3 spillInterval, 1, 2))

            (ยง ass! spillInterval (Interval''assignLocation-2 spillInterval, spillSlot))

            (MoveResolver''blockRegisters-2 this, spillInterval)

            ;; insert a move from register to stack and update the mapping
            (let [
                #_"LIRInstruction" move (MoveResolver''insertMove-3i this, fromInterval, spillInterval)
            ]
                (#_"ArrayList" .set (:mappingFrom this), spillCandidate, spillInterval)
                (MoveResolver''unblockRegisters-2 this, fromInterval)
            )
        )
        nil
    )

    (defn #_"MoveResolver" MoveResolver''setInsertPosition-3 [#_"MoveResolver" this, #_"List<LIRInstruction>" insertList, #_"int" insertIdx]
        (MoveResolver''createInsertionBuffer-2 this, insertList)
        (assoc this :insertIdx insertIdx)
    )

    (defn #_"this" MoveResolver''moveInsertPosition-3 [#_"MoveResolver" this, #_"List<LIRInstruction>" newInsertList, #_"int" newInsertIdx]
        (let [
            this
                (when (and (some? (:lir (:insertionBuffer this))) (or (not= (:lir (:insertionBuffer this)) newInsertList) (not= (:insertIdx this) newInsertIdx))) => this
                    ;; insert position changed . resolve current mappings
                    (MoveResolver''resolveMappings-1 this)
                )
            this
                (when-not (= (:lir (:insertionBuffer this)) newInsertList) => this
                    ;; block changed . append insertionBuffer because it is
                    ;; bound to a specific block and create a new insertionBuffer
                    (let [
                        this (MoveResolver''appendInsertionBuffer-1 this)
                    ]
                        (MoveResolver''createInsertionBuffer-2 this, newInsertList)
                        this
                    )
                )
        ]
            (assoc this :insertIdx newInsertIdx)
        )
    )

    (defn #_"void" MoveResolver''addMapping-3i [#_"MoveResolver" this, #_"Interval" fromInterval, #_"Interval" toInterval]
        (when-not (and (= (:location toInterval) Value/ILLEGAL) (Interval''canMaterialize-1 toInterval))
            (if (and (= (:location fromInterval) Value/ILLEGAL) (Interval''canMaterialize-1 fromInterval))
                ;; instead of a reload, re-materialize the value
                (MoveResolver''addMapping-3c this, (Interval''getMaterializedValue-1 fromInterval), toInterval)
                (do
                    (#_"ArrayList" .add (:mappingFrom this), fromInterval)
                    (#_"ArrayList" .add (:mappingFromOpr this), nil)
                    (#_"ArrayList" .add (:mappingTo this), toInterval)
                )
            )
        )
        nil
    )

    (defn #_"void" MoveResolver''addMapping-3c [#_"MoveResolver" this, #_"Constant" fromOpr, #_"Interval" toInterval]
        (#_"ArrayList" .add (:mappingFrom this), nil)
        (#_"ArrayList" .add (:mappingFromOpr this), fromOpr)
        (#_"ArrayList" .add (:mappingTo this), toInterval)
        nil
    )

    (defn #_"MoveResolver" MoveResolver''resolveAndAppendMoves-1 [#_"MoveResolver" this]
        (let [
            this
                (when (MoveResolver''hasMappings-1 this) => this
                    (MoveResolver''resolveMappings-1 this)
                )
        ]
            (MoveResolver''appendInsertionBuffer-1 this)
        )
    )
)

(class-ns SSAMoveResolver [MoveResolver]
    (def- #_"int" SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX -1)

    (defn #_"SSAMoveResolver" SSAMoveResolver'new-1 [#_"LinearScan" allocator]
        (let [
            #_"FrameMapBuilder" frameMapBuilder (LinearScan''getFrameMapBuilder-1 allocator)
            #_"FrameMap" frameMap (:frameMap frameMapBuilder)
        ]
            (merge (SSAMoveResolver'class.) (MoveResolver'new-1 allocator)
                (hash-map
                    #_"int[]" :stackBlocked (int-array (:numStackSlots frameMapBuilder))
                    #_"int" :firstVirtualStackIndex (if (not (FrameMap''frameNeedsAllocating-1 frameMap)) 0 (inc (FrameMap''currentFrameSize-1 frameMap)))
                )
            )
        )
    )

    (defn- #_"int" SSAMoveResolver''getStackArrayIndex-2s [#_"SSAMoveResolver" this, #_"StackSlot" stackSlot]
        ;; incoming stack arguments can be ignored
        (if (#_"StackSlot" .isInCallerFrame stackSlot) SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX (- (#_"StackSlot" .getRawOffset stackSlot)))
    )

    (defn- #_"int" SSAMoveResolver''getStackArrayIndex-2i [#_"SSAMoveResolver" this, #_"VirtualStackSlot" virtualStackSlot]
        (+ (:firstVirtualStackIndex this) (:id virtualStackSlot))
    )

    (defn- #_"int" SSAMoveResolver''getStackArrayIndex-2v [#_"SSAMoveResolver" this, #_"Value" stackSlotValue]
        (condp instance? stackSlotValue
            StackSlot        (SSAMoveResolver''getStackArrayIndex-2s this, stackSlotValue)
            VirtualStackSlot'iface (SSAMoveResolver''getStackArrayIndex-2i this, stackSlotValue)
        )
    )

    (defm SSAMoveResolver MoveResolver
        (#_"boolean" MoveResolver'''mightBeBlocked-2 [#_"SSAMoveResolver" this, #_"Value" location]
            (or (MoveResolver'''mightBeBlocked-2 (ยง super MoveResolver'iface), location) (LIRValueUtil'isStackSlotValue-1 location))
        )

        (#_"void" MoveResolver'''setValueBlocked-3 [#_"SSAMoveResolver" this, #_"Value" location, #_"int" direction]
            (when (LIRValueUtil'isStackSlotValue-1 location) => (MoveResolver'''setValueBlocked-3 (ยง super MoveResolver'iface), location, direction)
                (let [
                    #_"int" i (SSAMoveResolver''getStackArrayIndex-2v this, location)
                ]
                    (when-not (= i SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX) ;; => incoming stack arguments can be ignored
                        (when (<= (count (:stackBlocked this)) i)
                            (ยง ass! this (assoc this :stackBlocked (Arrays/copyOf (:stackBlocked this), (inc i))))
                        )
                        (aswap (:stackBlocked this) i + direction)
                    )
                )
            )
            nil
        )

        (#_"int" MoveResolver'''valueBlocked-2 [#_"SSAMoveResolver" this, #_"Value" location]
            (when (LIRValueUtil'isStackSlotValue-1 location) => (MoveResolver'''valueBlocked-2 (ยง super MoveResolver'iface), location)
                (let [
                    #_"int" i (SSAMoveResolver''getStackArrayIndex-2v this, location)
                ]
                    (cond
                        ;; incoming stack arguments are always blocked (aka they can not be written)
                        (= i SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX) 1
                        (<= (count (:stackBlocked this)) i)                  0
                        :else                                                (nth (:stackBlocked this) i)
                    )
                )
            )
        )

        (#_"LIRInstruction" MoveResolver'''createMove-5 [#_"SSAMoveResolver" this, #_"AllocatableValue" fromOpr, #_"AllocatableValue" toOpr, #_"AllocatableValue" fromLocation, #_"AllocatableValue" toLocation]
            (if (and (LIRValueUtil'isStackSlotValue-1 toLocation) (LIRValueUtil'isStackSlotValue-1 fromLocation))
                (MoveFactory''createStackMove-3 (:moveFactory (:allocator this)), toOpr, fromOpr)
                (MoveResolver'''createMove-5 (ยง super MoveResolver'iface), fromOpr, toOpr, fromLocation, toLocation)
            )
        )

        (#_"void" MoveResolver'''breakCycle-2 [#_"SSAMoveResolver" this, #_"int" spillCandidate]
            (when (= spillCandidate -1) => (MoveResolver'''breakCycle-2 (ยง super MoveResolver'iface), spillCandidate)
                ;; Arbitrarily select the first entry for spilling.
                (let [
                    #_"int" stackSpillCandidate 0
                    #_"Interval" fromInterval (MoveResolver''getMappingFrom-2 this, stackSpillCandidate)
                    ;; allocate new stack slot
                    #_"VirtualStackSlot" spillSlot (FrameMapBuilder''allocateSpillSlot-2 (LinearScan''getFrameMapBuilder-1 (:allocator this)), (:kind fromInterval))
                ]
                    (MoveResolver''spillInterval-4 this, stackSpillCandidate, fromInterval, spillSlot)
                )
            )
            nil
        )
    )
)

(class-ns NodeBitMap [#_"Iterable" #_"<Node>"]
    (def- #_"int" NodeBitMap'SHIFT 6)

    (defn- #_"int" NodeBitMap'sizeForNodeCount-1 [#_"int" nodeCount]
        (>> (dec (+ nodeCount Long/SIZE)) NodeBitMap'SHIFT)
    )

    (defn #_"NodeBitMap" NodeBitMap'new-1 [#_"Graph" graph]
        (merge (NodeBitMap'class.)
            (hash-map
                #_"Graph" :graph graph
                #_"long[]" :bits (long-array (NodeBitMap'sizeForNodeCount-1 (count (:gNodes graph))))
                #_"int" :nodeCount (count (:gNodes graph))
                #_"int" :counter 0
            )
        )
    )

    (defn #_"NodeBitMap" NodeBitMap'copy-1 [#_"NodeBitMap" other]
        (merge (NodeBitMap'class.)
            (hash-map
                #_"Graph" :graph (:graph other)
                #_"long[]" :bits (#_"Object" .clone (:bits other))
                #_"int" :nodeCount (:nodeCount other)
                #_"int" :counter 0
            )
        )
    )

    (defn #_"boolean" NodeBitMap''isNew-2 [#_"NodeBitMap" this, #_"Node" node]
        (<= (:nodeCount this) (:nid node))
    )

    (defn #_"boolean" NodeBitMap''checkAndMarkInc-2 [#_"NodeBitMap" this, #_"Node" node]
        (and (not (NodeBitMap''isMarked-2n this, node))
            (do
                (ยง ass! this (update this :counter inc))
                (NodeBitMap''mark-2 this, node)
                true
            )
        )
    )

    (defn- #_"NodeBitMap" NodeBitMap''grow-1 [#_"NodeBitMap" this]
        (let [
            this (assoc this :nodeCount (max (:nodeCount this) (count (:gNodes (:graph this)))))
            #_"int" n (NodeBitMap'sizeForNodeCount-1 (:nodeCount this))
        ]
            (when (< (count (:bits this)) n) => this
                (assoc this :bits (Arrays/copyOf (:bits this), (max n (inc (quot (* (count (:bits this)) 3) 2)))))
            )
        )
    )

    (defn- #_"NodeBitMap" NodeBitMap''checkGrow-2 [#_"NodeBitMap" this, #_"int" id]
        (when (<= (:nodeCount this) id) => this
            (if (<= (count (:bits this)) (>> id NodeBitMap'SHIFT))
                (NodeBitMap''grow-1 this)
                (assoc this :nodeCount (inc id))
            )
        )
    )

    (defn #_"boolean" NodeBitMap''isMarked-2i [#_"NodeBitMap" this, #_"int" id]
        (not (zero? (& (nth (:bits this) (>> id NodeBitMap'SHIFT)) (<< 1 id))))
    )

    (defn #_"boolean" NodeBitMap''isMarked-2n [#_"NodeBitMap" this, #_"Node" node]
        (NodeBitMap''isMarked-2i this, (:nid node))
    )

    (defn #_"boolean" NodeBitMap''isMarkedAndGrow-2 [#_"NodeBitMap" this, #_"Node" node]
        (ยง ass! this (NodeBitMap''checkGrow-2 this, (:nid node)))
        (NodeBitMap''isMarked-2i this, (:nid node))
    )

    (defn #_"void" NodeBitMap''mark-2 [#_"NodeBitMap" this, #_"Node" node]
        (aswap (:bits this) (>> (:nid node) NodeBitMap'SHIFT) | (<< 1 (:nid node)))
        nil
    )

    (defn #_"this" NodeBitMap''markAndGrow-2 [#_"NodeBitMap" this, #_"Node" node]
        (let [
            this (NodeBitMap''checkGrow-2 this, (:nid node))
        ]
            (NodeBitMap''mark-2 this, node)
            this
        )
    )

    (defn #_"void" NodeBitMap''clear-2 [#_"NodeBitMap" this, #_"Node" node]
        (aswap (:bits this) (>> (:nid node) NodeBitMap'SHIFT) & (bit-not (<< 1 (:nid node))))
        nil
    )

    (defn #_"this" NodeBitMap''clearAndGrow-2 [#_"NodeBitMap" this, #_"Node" node]
        (let [
            this (NodeBitMap''checkGrow-2 this, (:nid node))
        ]
            (NodeBitMap''clear-2 this, node)
            this
        )
    )

    (defn #_"void" NodeBitMap''clearAll-1 [#_"NodeBitMap" this]
        (Arrays/fill (:bits this), 0)
        nil
    )

    (defn #_"void" NodeBitMap''invert-1 [#_"NodeBitMap" this]
        (dotimes [#_"int" i (count (:bits this))]
            (aswap (:bits this) i bit-not)
        )
        nil
    )

    (defn #_"<T implements Node> void" NodeBitMap''markAll-2 [#_"NodeBitMap" this, #_"Iterable<T>" nodes]
        (doseq [#_"Node" node nodes]
            (NodeBitMap''mark-2 this, node)
        )
        nil
    )

    (defn- #_"long" NodeBitMap'getPartOfWord-2 [#_"long" word, #_"int" firstNodeIdToInclude]
        (& word (<< 0xffffffffffffffff firstNodeIdToInclude))
    )

    (defn #_"Node" NodeBitMap''nextMarkedNode-2 [#_"NodeBitMap" this, #_"int" fromNodeId]
        (let [
            #_"int" i (>> fromNodeId NodeBitMap'SHIFT)
            #_"int" n (count (:bits this))
        ]
            (when (< i n)
                (loop [i i #_"long" word (NodeBitMap'getPartOfWord-2 (nth (:bits this) i), fromNodeId)]
                    (or
                        (loop-when word (not (zero? word))
                            (let [
                                #_"int" bitIndex (Long/numberOfTrailingZeros word)
                                #_"int" nodeId (+ (* i Long/SIZE) bitIndex)
                            ]
                                (or (nth (:gNodes (:graph this)) nodeId)
                                    (do
                                        ;; node was deleted -> clear the bit and continue searching
                                        (aswap (:bits this) i & (bit-not (<< 1 bitIndex)))
                                        (let [
                                            nodeId (inc nodeId)
                                        ]
                                            (when-not (zero? (& nodeId (dec Long/SIZE))) ;; => we reached the end of this word
                                                (recur (NodeBitMap'getPartOfWord-2 word, nodeId))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (let [
                            i (inc i)
                        ]
                            (when (< i n)
                                (recur i (nth (:bits this) i))
                            )
                        )
                    )
                )
            )
        )
    )

    (ยง override! #_"Iterator<Node>" #_"Iterable." iterator [#_"NodeBitMap" this]
        (MarkedNodeIterator'new-1 this)
    )
)

(class-ns NodeClosure #_"<T implements Node>" []
    (defn #_"NodeClosure" NodeClosure'new-0 []
        (NodeClosure'class.)
    )
)

(class-ns CollectVirtualObjectsClosure #_"<T implements PartialEscapeBlockState<T>>" [NodeClosure #_"<ValueNode>"]
    (defn #_"CollectVirtualObjectsClosure" CollectVirtualObjectsClosure'new-4 [#_"PartialEscapeClosure<T>" peClosure, #_"EconomicSet<VirtualObjectNode>" virtual, #_"GraphEffectList" effects, #_"T" state]
        (merge (CollectVirtualObjectsClosure'class.) (NodeClosure'new-0)
            (hash-map
                #_"PartialEscapeClosure<T>" :peClosure peClosure
                #_"EconomicSet<VirtualObjectNode>" :virtual virtual
                #_"GraphEffectList" :effects effects
                #_"T" :state state
            )
        )
    )

    (defm CollectVirtualObjectsClosure #_"<T>" NodeClosure
        (#_"void" NodeClosure'''apply-3 [#_"CollectVirtualObjectsClosure<T>" this, #_"Node" usage, #_"ValueNode" value]
            (if (satisfies? VirtualObjectNode value)
                (let [
                    #_"int" id (:oid value)
                ]
                    (when (and (not= id -1) (some? (when (< id (count (:objectStates (:state this)))) (nth (:objectStates (:state this)) id))))
                        (#_"EconomicSet" .add (:virtual this), value)
                    )
                )
                (let [
                    #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 (:peClosure this), value)
                ]
                    (when (satisfies? VirtualObjectNode alias)
                        (#_"EconomicSet" .add (:virtual this), alias)
                        (GraphEffectList''replaceFirstInput-4 (:effects this), usage, value, alias)
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Costs associated with a block.
 ;;
(class-ns NodeCost []
    (defn #_"NodeCost" NodeCost'new-3 [#_"double" bestCost, #_"UseEntry*" usages, #_"int" numMat]
        (merge (NodeCost'class.)
            (hash-map
                #_"UseEntry*" :usages usages
                #_"double" :bestCost bestCost
                #_"int" :numMat numMat
            )
        )
    )
)

;;;
 ; Entry in the linked list of nodes.
 ;;
(class-ns NodeEntry []
    (defn #_"NodeEntry" NodeEntry'new-1 [#_"Node" node]
        (merge (NodeEntry'class.)
            (hash-map
                #_"Node" :node node
                #_"NodeEntry" :next nil
            )
        )
    )
)

(class-ns NodeEventListener []
    (defn #_"NodeEventListener" NodeEventListener'new-0 []
        (NodeEventListener'class.)
    )

    ;;;
     ; A method called when a change event occurs.
     ;
     ; This method dispatches the event to user-defined triggers. The methods that change the
     ; graph (typically in Graph and Node) must call this method to dispatch the event.
     ;
     ; @param e an event
     ; @param node the node related to {@code e}
     ;;
    (defn #_"void" NodeEventListener''event-3 [#_"NodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
        (condp = e
            NodeEvent'INPUT_CHANGED (NodeEventListener'''inputChanged-2 this, node)
            NodeEvent'ZERO_USAGES   (NodeEventListener'''usagesDroppedToZero-2 this, node)
            NodeEvent'NODE_ADDED    (NodeEventListener'''nodeAdded-2 this, node)
            NodeEvent'NODE_REMOVED  (NodeEventListener'''nodeRemoved-2 this, node)
            nil
        )
        (NodeEventListener'''changed-3 this, e, node)
        nil
    )

    (defm NodeEventListener NodeEventListener
        (#_"void" NodeEventListener'''changed-3 [#_"NodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
            nil
        )

        (#_"void" NodeEventListener'''inputChanged-2 [#_"NodeEventListener" this, #_"Node" node]
            nil
        )

        (#_"void" NodeEventListener'''usagesDroppedToZero-2 [#_"NodeEventListener" this, #_"Node" node]
            nil
        )

        (#_"void" NodeEventListener'''nodeAdded-2 [#_"NodeEventListener" this, #_"Node" node]
            nil
        )

        (#_"void" NodeEventListener'''nodeRemoved-2 [#_"NodeEventListener" this, #_"Node" node]
            nil
        )
    )
)

(class-ns ChainedNodeEventListener [NodeEventListener]
    (defn #_"ChainedNodeEventListener" ChainedNodeEventListener'new-2 [#_"NodeEventListener" head, #_"NodeEventListener" _next]
        (merge (ChainedNodeEventListener'class.) (NodeEventListener'new-0)
            (hash-map
                #_"NodeEventListener" :head head
                #_"NodeEventListener" :next _next
            )
        )
    )

    (defm ChainedNodeEventListener NodeEventListener
        (#_"void" NodeEventListener'''nodeAdded-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
            (NodeEventListener''event-3 (:head this), NodeEvent'NODE_ADDED, node)
            (NodeEventListener''event-3 (:next this), NodeEvent'NODE_ADDED, node)
            nil
        )

        (#_"void" NodeEventListener'''inputChanged-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
            (NodeEventListener''event-3 (:head this), NodeEvent'INPUT_CHANGED, node)
            (NodeEventListener''event-3 (:next this), NodeEvent'INPUT_CHANGED, node)
            nil
        )

        (#_"void" NodeEventListener'''usagesDroppedToZero-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
            (NodeEventListener''event-3 (:head this), NodeEvent'ZERO_USAGES, node)
            (NodeEventListener''event-3 (:next this), NodeEvent'ZERO_USAGES, node)
            nil
        )

        (#_"void" NodeEventListener'''nodeRemoved-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
            (NodeEventListener''event-3 (:head this), NodeEvent'NODE_REMOVED, node)
            (NodeEventListener''event-3 (:next this), NodeEvent'NODE_REMOVED, node)
            nil
        )

        (#_"void" NodeEventListener'''changed-3 [#_"ChainedNodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
            (NodeEventListener''event-3 (:head this), e, node)
            (NodeEventListener''event-3 (:next this), e, node)
            nil
        )
    )
)

;;;
 ; A simple NodeEventListener implementation that accumulates event nodes in a HashSet.
 ;;
(class-ns HashSetNodeEventListener [NodeEventListener]
    ;;;
     ; Creates a NodeEventListener that collects nodes from all events that match a given filter.
     ;;
    (defn #_"HashSetNodeEventListener" HashSetNodeEventListener'new-1 [#_"Set<NodeEvent>" filter]
        (merge (HashSetNodeEventListener'class.) (NodeEventListener'new-0)
            (hash-map
                ;;;
                 ; The set being used to accumulate the nodes communicated to this listener.
                 ;;
                #_"EconomicSet<Node>" :nodes (EconomicSet/create)
                #_"Set<NodeEvent>" :filter filter
            )
        )
    )

    ;;;
     ; Creates a NodeEventListener that collects nodes from all events.
     ;;
    (defn #_"HashSetNodeEventListener" HashSetNodeEventListener'new-0 []
        (HashSetNodeEventListener'new-1 (EnumSet/allOf NodeEvent))
    )

    ;;;
     ; Excludes a given event from those for which nodes are collected.
     ;;
    (defn #_"this" HashSetNodeEventListener''exclude-2 [#_"HashSetNodeEventListener" this, #_"NodeEvent" e]
        (#_"Set" .remove (:filter this), e)
        this
    )

    (defm HashSetNodeEventListener NodeEventListener
        (#_"void" NodeEventListener'''changed-3 [#_"HashSetNodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
            (when (contains? (:filter this) e)
                (#_"EconomicSet" .add (:nodes this), node)
                (when (satisfies? IndirectCanonicalization node)
                    (doseq [#_"Node" usage (:nodeUsages node)]
                        (#_"EconomicSet" .add (:nodes this), usage)
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Registers a given NodeEventListener with the enclosing graph until this object is {@linkplain #close() closed}.
 ;;
(class-ns NodeEventScope [#_"AutoCloseable"]
    (defn #_"NodeEventScope" NodeEventScope'new-2 [#_"Graph" graph, #_"NodeEventListener" listener]
        (let [
            #_"NodeEventScope" this
                (merge (NodeEventScope'class.)
                    (hash-map
                        #_"Graph" :graph graph
                    )
                )
        ]
            (if (nil? (:nodeEventListener (:graph this)))
                (ยง ass! (:nodeEventListener (:graph this)) listener)
                (ยง ass! (:nodeEventListener (:graph this)) (ChainedNodeEventListener'new-2 listener, (:nodeEventListener (:graph this))))
            )
            this
        )
    )

    (ยง override! #_"void" #_"AutoCloseable." close [#_"NodeEventScope" this]
        (if (satisfies? ChainedNodeEventListener (:nodeEventListener (:graph this)))
            (ยง ass! (:nodeEventListener (:graph this)) (:next (:nodeEventListener (:graph this))))
            (ยง ass! (:nodeEventListener (:graph this)) nil)
        )
        nil
    )
)

(class-ns NodeFlood [#_"Iterable" #_"<Node>"]
    (defn #_"NodeFlood" NodeFlood'new-1 [#_"Graph" graph]
        (merge (NodeFlood'class.)
            (hash-map
                #_"NodeBitMap" :visited (NodeBitMap'new-1 graph)
                #_"Queue<Node>" :worklist (ArrayDeque.)
                #_"int" :totalMarkedCount 0
            )
        )
    )

    (defn #_"this" NodeFlood''add-2 [#_"NodeFlood" this, #_"Node" node]
        (when (and (some? node) (not (NodeBitMap''isMarked-2n (:visited this), node))) => this
            (NodeBitMap''mark-2 (:visited this), node)
            (#_"Queue" .add (:worklist this), node)
            (update this :totalMarkedCount inc)
        )
    )

    (defn #_"boolean" NodeFlood''isMarked-2 [#_"NodeFlood" this, #_"Node" node]
        (NodeBitMap''isMarked-2n (:visited this), node)
    )

    (ยง override! #_"Iterator<Node>" #_"Iterable." iterator [#_"NodeFlood" this]
        (let [
            #_"NodeFlood" flood this
        ]
            (reify Iterator #_"<Node>"
                (#_"boolean" hasNext [#_"Iterator<Node>" this]
                    (not (#_"Queue" .isEmpty (:worklist flood)))
                )

                (#_"Node" next [#_"Iterator<Node>" this]
                    (#_"Queue" .remove (:worklist flood))
                )
            )
        )
    )
)

(class-ns Node []
    (def #_"int" Node'DELETED_ID_START -1000000000)
    (def #_"int" Node'INITIAL_ID -1)
    (def #_"int" Node'ALIVE_ID_START 0)

    (def #_"int" Node'NODE_LIST -2)

    (defn #_"Node" Node'new-0 []
        (merge (Node'class.)
            (hash-map
                #_"NodeClass<? implements Node>" :nodeClass nil
                #_"int" :nid Node'INITIAL_ID
                #_"Graph" :graph nil
                #_"[Node]" :nodeUsages []
                #_"Node" :predecessor nil
            )
        )
    )

    ;;;
     ; Returns an iterable which can be used to traverse all non-nil input edges of this node.
     ;;
    (defn #_"Node*" Node''inputs-1 [#_"Node" this]
        (iterator-seq (RawEdgesIterator'new-2 this, (:inputsIteration (:nodeClass this))))
    )

    ;;;
     ; Returns an iterable which can be used to traverse all non-nil input edges of this node.
     ;;
    (defn #_"Position*" Node''inputPositions-1 [#_"Node" this]
        (Edges''getPositions-2 (:inputs (:nodeClass this)), this)
    )

    ;;;
     ; Applies the given visitor to all inputs of this node.
     ;;
    (defn #_"void" Node''applyInputs-2 [#_"Node" this, #_"EdgeVisitor" visitor]
        (NodeClass''applyInputs-3 (:nodeClass this), this, visitor)
        nil
    )

    ;;;
     ; Returns an iterable which can be used to traverse all non-nil successor edges of this node.
     ;;
    (defn #_"Node*" Node''successors-1 [#_"Node" this]
        (iterator-seq (RawEdgesIterator'new-2 this, (:successorIteration (:nodeClass this))))
    )

    ;;;
     ; Returns an iterable which can be used to traverse all successor edge positions of this node.
     ;;
    (defn #_"Position*" Node''successorPositions-1 [#_"Node" this]
        (Edges''getPositions-2 (:successors (:nodeClass this)), this)
    )

    ;;;
     ; Applies the given visitor to all successors of this node.
     ;;
    (defn #_"void" Node''applySuccessors-2 [#_"Node" this, #_"EdgeVisitor" visitor]
        (NodeClass''applySuccessors-3 (:nodeClass this), this, visitor)
        nil
    )

    ;;;
     ; Checks whether this node has no usages.
     ;;
    (defn #_"boolean" Node''hasNoUsages-1 [#_"Node" this]
        (empty? (:nodeUsages this))
    )

    ;;;
     ; Checks whether this node has usages.
     ;;
    (defn #_"boolean" Node''hasUsages-1 [#_"Node" this]
        (boolean (seq (:nodeUsages this)))
    )

    ;;;
     ; Checks whether this node has more than one usages.
     ;;
    (defn #_"boolean" Node''hasMoreThanOneUsage-1 [#_"Node" this]
        (boolean (seq (next (:nodeUsages this))))
    )

    ;;;
     ; Checks whether this node has exactly one usgae.
     ;;
    (defn #_"boolean" Node''hasExactlyOneUsage-1 [#_"Node" this]
        (and (Node''hasUsages-1 this) (not (Node''hasMoreThanOneUsage-1 this)))
    )

    ;;;
     ; Adds a given node to this node's {@linkplain #usages() usages}.
     ;;
    (defn #_"Node" Node''addUsage-2 [#_"Node" this, #_"Node" node]
        (update this :nodeUsages #(conj (vec %) node))
    )

    ;;;
     ; Removes a given node from this node's {@linkplain #usages() usages}.
     ;;
    (defn #_"Node" Node''removeUsage-2 [#_"Node" this, #_"Node" node]
        ;; For large graphs, usage removal is critical for performance.
        ;; Furthermore, it is critical that this method maintains the invariant,
        ;; that the usage list has no nil element preceding a non-nil element.
        (loop-when [#_"int" i (dec (count (:nodeUsages this)))] (<= 0 i) => this
            (when (= (nth (:nodeUsages this) i) node) => (recur (dec i))
                (update this :nodeUsages #(assoc (pop %) i (peek %)))
            )
        )
    )

    (defn #_"boolean" Node''isDeleted-1 [#_"Node" this]
        (<= (:nid this) Node'DELETED_ID_START)
    )

    (defn #_"boolean" Node''isAlive-1 [#_"Node" this]
        (<= Node'ALIVE_ID_START (:nid this))
    )

    (defn- #_"void" Node''maybeNotifyInputChanged-2 [#_"Node" this, #_"Node" node]
        (when (some? (:graph this))
            (let [
                #_"NodeEventListener" listener (:nodeEventListener (:graph this))
            ]
                (when (some? listener)
                    (NodeEventListener''event-3 listener, NodeEvent'INPUT_CHANGED, node)
                )
            )
        )
        nil
    )

    ;;;
     ; Updates the usages sets of the given nodes after an input slot is changed from
     ; {@code oldInput} to {@code newInput} by removing this node from {@code oldInput}'s usages and
     ; adds this node to {@code newInput}'s usages.
     ;;
    (defn #_"void" Node''updateUsages-3 [#_"Node" this, #_"Node" oldInput, #_"Node" newInput]
        (when-not (= oldInput newInput)
            (when (some? oldInput)
                (ยง ass! oldInput (Node''removeUsage-2 oldInput, this))
            )
            (Node''maybeNotifyInputChanged-2 this, this)
            (when (some? newInput)
                (ยง ass! newInput (Node''addUsage-2 newInput, this))
            )
            (when (and (some? oldInput) (Node''hasNoUsages-1 oldInput))
                (Node''maybeNotifyZeroUsages-2 this, oldInput)
            )
        )
        nil
    )

    ;;;
     ; Updates the predecessor of the given nodes after a successor slot is changed from
     ; oldSuccessor to newSuccessor: removes this node from oldSuccessor's predecessors and adds
     ; this node to newSuccessor's predecessors.
     ;;
    (defn #_"void" Node''updatePredecessor-3 [#_"Node" this, #_"Node" oldSuccessor, #_"Node" newSuccessor]
        (when-not (= oldSuccessor newSuccessor)
            (when (some? oldSuccessor)
                (ยง ass! oldSuccessor (assoc oldSuccessor :predecessor nil))
            )
            (when (some? newSuccessor)
                (ยง ass! newSuccessor (assoc newSuccessor :predecessor this))
            )
        )
        nil
    )

    (defn- #_"boolean" Node''checkReplaceWith-2 [#_"Node" this, #_"Node" other]
        (cond
            (and (some? (:graph this)) (Graph''isFrozen-1 (:graph this))) (throw! "cannot modify frozen graph")
            (= other this)                                                (throw! "cannot replace a node with itself")
            (Node''isDeleted-1 this)                                      (throw! "cannot replace deleted node")
            (and (some? other) (Node''isDeleted-1 other))                 (throw! (str "cannot replace with deleted node " other))
            :else                                                         true
        )
    )

    (defn #_"Node" Node''replaceAtUsages-2 [#_"Node" this, #_"Node" other]
        (Node''replaceAtAllUsages-3 this, other, nil)
    )

    (defn #_"this" Node''replaceAtUsagesAndDelete-2 [#_"Node" this, #_"Node" other]
        (let [
            this (Node''replaceAtAllUsages-3 this, other, this)
        ]
            (Node''safeDelete-1 this)
            this
        )
    )

    (defn- #_"void" Node''replaceAtUsage-4 [#_"Node" this, #_"Node" other, #_"Node" toBeDeleted, #_"Node" usage]
        (NodeClass''replaceFirstInput-4 (:nodeClass usage), usage, this, other)
        ;; Don't notify for nodes which are about to be deleted.
        (when (or (nil? toBeDeleted) (not= usage toBeDeleted))
            (Node''maybeNotifyInputChanged-2 this, usage)
        )
        (when (some? other)
            (ยง ass! other (Node''addUsage-2 other, usage))
        )
        nil
    )

    (defn #_"this" Node''replaceAtAllUsages-3 [#_"Node" this, #_"Node" other, #_"Node" toBeDeleted]
        (Node''checkReplaceWith-2 this, other)
        (when (seq (:nodeUsages this)) => this
            (doseq [#_"Node" node (:nodeUsages this)]
                (Node''replaceAtUsage-4 this, other, toBeDeleted, node)
            )
            (assoc this :nodeUsages [])
        )
    )

    (defn #_"Node" Node''replaceAtMatchingUsages-3 [#_"Node" this, #_"Node" other, #_"NodePredicate" f'filter-1]
        (Node''checkReplaceWith-2 this, other)
        (when (some? f'filter-1) => (throw! "filter cannot be nil")
            (Node''checkReplaceWith-2 this, other)
            (loop-when [this this #_"int" i 0] (< i (count (:nodeUsages this))) => this
                (let [
                    #_"Node" usage (nth (:nodeUsages this) i)
                ]
                    (when (f'filter-1 usage) => (recur this (inc i))
                        (Node''replaceAtUsage-4 this, other, nil, usage)
                        (recur (update this :nodeUsages #(assoc (pop %) i (peek %))) i)
                    )
                )
            )
        )
    )

    (defn #_"void" Node''replaceAtUsages-3 [#_"Node" this, #_"InputType" type, #_"Node" other]
        (Node''checkReplaceWith-2 this, other)
        (doseq [#_"Node" usage (:nodeUsages this) #_"Position" pos (Node''inputPositions-1 usage)]
            (when (and (= (Position''getInputType-1 pos) type) (= (Position''get-2 pos, usage) this))
                (Position''set-3 pos, usage, other)
            )
        )
        nil
    )

    (defn #_"void" Node''maybeNotifyZeroUsages-2 [#_"Node" this, #_"Node" node]
        (when (some? (:graph this))
            (let [
                #_"NodeEventListener" listener (:nodeEventListener (:graph this))
            ]
                (when (and (some? listener) (Node''isAlive-1 node))
                    (NodeEventListener''event-3 listener, NodeEvent'ZERO_USAGES, node)
                )
            )
        )
        nil
    )

    (defn #_"void" Node''replaceAtPredecessor-2 [#_"Node" this, #_"Node" other]
        (Node''checkReplaceWith-2 this, other)
        (when (some? (:predecessor this))
            (when-not (NodeClass''replaceFirstSuccessor-4 (:nodeClass (:predecessor this)), (:predecessor this), this, other)
                (throw! (str "not found in successors, predecessor: " (:predecessor this)))
            )
            (Node''updatePredecessor-3 (:predecessor this), this, other)
        )
        nil
    )

    (defn #_"Node" Node''replaceAndDelete-2 [#_"Node" this, #_"Node" other]
        (Node''checkReplaceWith-2 this, other)
        (when (some? other) => (throw! "cannot replace with nil")
            (let [
                this
                    (when (Node''hasUsages-1 this) => this
                        (Node''replaceAtUsages-2 this, other)
                    )
            ]
                (Node''replaceAtPredecessor-2 this, other)
                (Node''safeDelete-1 this)
                this
            )
        )
    )

    (defn #_"void" Node''replaceFirstSuccessor-3 [#_"Node" this, #_"Node" oldSuccessor, #_"Node" newSuccessor]
        (when (NodeClass''replaceFirstSuccessor-4 (:nodeClass this), this, oldSuccessor, newSuccessor)
            (Node''updatePredecessor-3 this, oldSuccessor, newSuccessor)
        )
        nil
    )

    (defn #_"void" Node''replaceFirstInput-3 [#_"Node" this, #_"Node" oldInput, #_"Node" newInput]
        (when (NodeClass''replaceFirstInput-4 (:nodeClass this), this, oldInput, newInput)
            (Node''updateUsages-3 this, oldInput, newInput)
        )
        nil
    )

    (defn #_"void" Node''clearInputs-1 [#_"Node" this]
        (NodeClass''unregisterAtInputsAsUsage-2 (:nodeClass this), this)
        nil
    )

    (defn #_"void" Node''clearSuccessors-1 [#_"Node" this]
        (NodeClass''unregisterAtSuccessorsAsPredecessor-2 (:nodeClass this), this)
        nil
    )

    ;;;
     ; Removes this node from its graph. This node must have no usages and no predecessor.
     ;;
    (defn #_"void" Node''safeDelete-1 [#_"Node" this]
        (Node''clearInputs-1 this)
        (Node''clearSuccessors-1 this)
        (Node''markDeleted-1 this)
        nil
    )

    (defn #_"void" Node''markDeleted-1 [#_"Node" this]
        (ยง ass! (:graph this) (Graph''unregister-2 (:graph this), this))
        (ยง ass! this (assoc this :nid (- Node'DELETED_ID_START (:nid this))))
        nil
    )

    (defn #_"Node" Node''copyWithInputs-1 [#_"Node" this]
        (let [
            #_"Node" newNode (Node''clone-3 this, (:graph this), Node'WithOnlyInputEdges)
        ]
            (doseq [#_"Node" input (Node''inputs-1 this)]
                (ยง ass! input (Node''addUsage-2 input, newNode))
            )
            newNode
        )
    )

    ;;;
     ; @param newNode the result of cloning this node or {@link Unsafe#allocateInstance(Class) raw allocating} a copy of this node
     ; @param type the type of edges to process
     ; @param edgesToCopy if {@code type} is in this set, the edges are copied otherwise they are cleared
     ;;
    (defn- #_"void" Node''copyOrClearEdgesForClone-4 [#_"Node" this, #_"Node" newNode, #_"EdgesType" type, #_"EnumSet<EdgesType>" edgesToCopy]
        (if (contains? edgesToCopy type)
            (Edges''copy-3 (NodeClass''getEdges-2 (:nodeClass this), type), this, newNode)
            ;; the direct edges are already nil
            (Edges''initializeLists-3 (NodeClass''getEdges-2 (:nodeClass this), type), newNode, this)
        )
        nil
    )

    (ยง def #_"EnumSet<EdgesType>" Node'WithNoEdges (EnumSet/noneOf EdgesType))
    (ยง def #_"EnumSet<EdgesType>" Node'WithAllEdges (EnumSet/allOf EdgesType))
    (ยง def #_"EnumSet<EdgesType>" Node'WithOnlyInputEdges (EnumSet/of EdgesType'Inputs))
    (ยง def #_"EnumSet<EdgesType>" Node'WithOnlySucessorEdges (EnumSet/of EdgesType'Successors))

    ;;;
     ; Makes a copy of this node in(to) a given graph.
     ;
     ; @param into the graph in which the copy will be registered (which may be this node's graph)
     ;            or nil if the copy should not be registered in a graph
     ; @param edgesToCopy specifies the edges to be copied. The edges not specified in this set are initialized
     ;            to their default value (i.e. nil for a direct edge, an empty list for an edge list)
     ; @return the copy of this node
     ;;
    (defn #_"Node" Node''clone-3 [#_"Node" this, #_"Graph" into, #_"EnumSet<EdgesType>" edgesToCopy]
        (let [
            #_"Node" node (.allocateInstance HotSpot'unsafe, (#_"Object" .getClass this))
            node (assoc node :nodeClass (:nodeClass this))
            _ (Fields''copy-3 (:data (:nodeClass this)), this, node)
            _ (Node''copyOrClearEdgesForClone-4 this, node, EdgesType'Inputs, edgesToCopy)
            _ (Node''copyOrClearEdgesForClone-4 this, node, EdgesType'Successors, edgesToCopy)
            node (assoc node :graph into)
            node (assoc node :nid Node'INITIAL_ID)
            _
                (when (some? into)
                    (ยง ass! into (Graph''register-2 into, node))
                )
            node (assoc node :nodeUsages [])
        ]
            (Node'''afterClone-2 node, this)
            node
        )
    )

    (defm Node Node
        (#_"void" Node'''afterClone-2 [#_"Node" this, #_"Node" other]
            nil
        )

        (#_"Node*" Node'''cfgPredecessors-1 [#_"Node" this]
            (when (some? (:predecessor this)) (list (:predecessor this)))
        )

        (#_"Node*" Node'''cfgSuccessors-1 [#_"Node" this]
            (Node''successors-1 this)
        )
    )

    ;;;
     ; Nodes using their #id as the hash code. This works very well when nodes of the same graph are
     ; stored in sets. It can give bad behavior when storing nodes of different graphs in the same set.
     ;;
    (ยง override! #_"int" #_"Object." hashCode [#_"Node" this]
        (if (Node''isDeleted-1 this) (- Node'DELETED_ID_START (:nid this)) (:nid this))
    )

    ;;;
     ; Do not overwrite the equality test of a node in subclasses.
     ; Equality tests must rely solely on identity.
     ;;

    ;;;
     ; Determines if this node's {@link NodeClass#getData() data} fields are equal to the
     ; data fields of another node of the same type. Primitive fields are compared by value
     ; and non-primitive fields are compared by Objects#equals(Object, Object).
     ;
     ; The result of this method undefined if {@code other.getClass() != this.getClass()}.
     ;
     ; @param other a node of exactly the same type as this node
     ; @return true if the data fields of this object and {@code other} are equal
     ;;
    (defn #_"boolean" Node''valueEquals-2 [#_"Node" this, #_"Node" other]
        (NodeClass''dataEquals-3 (:nodeClass this), this, other)
    )

    ;;;
     ; Determines if this node is equal to the other node while ignoring differences in
     ; {@linkplain Successor control-flow} edges.
     ;;
    (defn #_"boolean" Node''dataFlowEquals-2 [#_"Node" this, #_"Node" other]
        (or (= this other)
            (and (= (:nodeClass this) (:nodeClass other))
                 (Node''valueEquals-2 this, other)
                 (NodeClass''equalInputs-3 (:nodeClass this), this, other)
            )
        )
    )
)

(class-ns ValueNode [Node]
    (defn #_"ValueNode" ValueNode'new-1 [#_"Stamp" stamp]
        (merge (ValueNode'class.) (Node'new-0)
            (hash-map
                ;;;
                 ; The kind of this value. This is JavaKind#Void for instructions that produce no value.
                 ; This kind is guaranteed to be a {@linkplain JavaKind#getStackKind() stack kind}.
                 ;;
                #_"Stamp" :stamp stamp
            )
        )
    )

    (defn #_"ValueNode" ValueNode''setStamp-2 [#_"ValueNode" this, #_"Stamp" stamp]
        (assoc this :stamp stamp)
    )

    ;;;
     ; Checks if the given stamp is different than the current one ({@code newStamp.equals(oldStamp) == false}).
     ; If it is different then the new stamp will become the current stamp for this node.
     ;
     ; @return true if the stamp has changed, false otherwise
     ;;
    (defn #_"boolean" ValueNode''updateStamp-2 [#_"ValueNode" this, #_"Stamp" stamp]
        (and (some? stamp) (not= stamp (:stamp this))
            (do
                (ยง ass! this (assoc this :stamp stamp))
                true
            )
        )
    )

    (defm ValueNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"ValueNode" this]
            false
        )
    )

    (defn #_"JavaKind" ValueNode''getStackKind-1 [#_"ValueNode" this]
        (Stamp'''getStackKind-1 (:stamp this))
    )

    (def #_"NodePredicate" ValueNode'IS_CONSTANT
        (reify NodePredicate
            (#_"boolean" NodePredicate'''apply-2 [#_"NodePredicate" this, #_"Node" node]
                (satisfies? ConstantNode node)
            )
        )
    )

    ;;;
     ; Checks whether this value represents the nil constant.
     ;
     ; @return true if this value represents the nil constant
     ;;
    (defn #_"boolean" ValueNode''isNullConstant-1 [#_"ValueNode" this]
        (let [
            #_"JavaConstant" value (ValueNode''asJavaConstant-1 this)
        ]
            (and (some? value) (#_"JavaConstant" .isNull value))
        )
    )

    ;;;
     ; Convert this value to a constant if it is a constant, otherwise return nil.
     ;
     ; @return the JavaConstant represented by this value if it is a constant; nil otherwise
     ;;
    (defn #_"Constant" ValueNode''asConstant-1 [#_"ValueNode" this]
        (when (satisfies? ConstantNode this) (:value this))
    )

    (defn #_"boolean" ValueNode''isJavaConstant-1 [#_"ValueNode" this]
        (and (satisfies? ConstantNode this) (instance? JavaConstant (:value this)))
    )

    (defn #_"JavaConstant" ValueNode''asJavaConstant-1 [#_"ValueNode" this]
        (let [
            #_"Constant" value (ValueNode''asConstant-1 this)
        ]
            (when (instance? JavaConstant value)
                value
            )
        )
    )

    ;;;
     ; Checks if this node has usages other than the given node {@code node}.
     ;
     ; @param node node which is ignored when searching for usages
     ; @return true if this node has other usages, false otherwise
     ;;
    (defn #_"boolean" ValueNode''hasUsagesOtherThan-3 [#_"ValueNode" this, #_"ValueNode" node, #_"LIRBuilder" builder]
        (loop-when [#_"ISeq" s (seq (:nodeUsages this))] (some? s) => false
            (let [
                #_"Node" usage (first s)
            ]
                (or (and (not= usage node) (satisfies? ValueNode usage) (LIRBuilder''hasOperand-2 builder, usage))
                    (recur (next s))
                )
            )
        )
    )
)

(class-ns CallTargetNode [ValueNode, Node, LIRLowerable]
    (defn #_"CallTargetNode" CallTargetNode'new-4 [#_"ValueNode*" arguments, #_"ResolvedJavaMethod" targetMethod, #_"InvokeKind" invokeKind, #_"Stamp" returnStamp]
        (merge (CallTargetNode'class.) (ValueNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"NodeInputList<ValueNode>" :arguments (NodeInputList'new-2s (ร this), arguments)
                ;;;
                 ; The target method for this invocation instruction.
                 ;;
                #_"ResolvedJavaMethod" :targetMethod targetMethod
                #_"InvokeKind" :invokeKind invokeKind
                #_"Stamp" :returnStamp returnStamp
            )
        )
    )

    (defm CallTargetNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"CallTargetNode" this, #_"LIRBuilder" builder]
            ;; nop
            nil
        )
    )

    (defn #_"CallTargetNode" CallTargetNode''setTargetMethod-2 [#_"CallTargetNode" this, #_"ResolvedJavaMethod" method]
        (assoc this :targetMethod method)
    )

    (defn #_"CallTargetNode" CallTargetNode''setInvokeKind-2 [#_"CallTargetNode" this, #_"InvokeKind" kind]
        (assoc this :invokeKind kind)
    )
)

(class-ns LoweredCallTargetNode [CallTargetNode, ValueNode, Node, LIRLowerable]
    (defn #_"LoweredCallTargetNode" LoweredCallTargetNode'new-6 [#_"ValueNode*" arguments, #_"Stamp" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (merge (LoweredCallTargetNode'class.) (CallTargetNode'new-4 arguments, target, invokeKind, returnStamp)
            (hash-map
                #_"JavaType[]" :signature signature
                #_"CallingConvention$Type" :callType callType
            )
        )
    )

    (defn #_"JavaType[]" LoweredCallTargetNode''signature-1 [#_"LoweredCallTargetNode" this]
        (:signature this)
    )

    (defn #_"CallingConvention$Type" LoweredCallTargetNode''callType-1 [#_"LoweredCallTargetNode" this]
        (:callType this)
    )
)

(class-ns DirectCallTargetNode [LoweredCallTargetNode, CallTargetNode, ValueNode, Node, LIRLowerable]
    (defn #_"DirectCallTargetNode" DirectCallTargetNode'new-6 [#_"ValueNode*" arguments, #_"Stamp" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (merge (DirectCallTargetNode'class.) (LoweredCallTargetNode'new-6 arguments, returnStamp, signature, target, callType, invokeKind))
    )
)

(class-ns HotSpotDirectCallTargetNode [DirectCallTargetNode, LoweredCallTargetNode, CallTargetNode, ValueNode, Node, LIRLowerable]
    (defn #_"HotSpotDirectCallTargetNode" HotSpotDirectCallTargetNode'new-6 [#_"ValueNode*" arguments, #_"Stamp" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (merge (HotSpotDirectCallTargetNode'class.) (DirectCallTargetNode'new-6 arguments, returnStamp, signature, target, callType, invokeKind))
    )
)

(class-ns MethodCallTargetNode [CallTargetNode, ValueNode, Node, LIRLowerable, Simplifiable]
    (defn #_"MethodCallTargetNode" MethodCallTargetNode'new-4 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode*" arguments, #_"Stamp" returnStamp]
        (merge (MethodCallTargetNode'class.) (CallTargetNode'new-4 arguments, targetMethod, invokeKind, returnStamp))
    )

    ;;;
     ; Gets the instruction that produces the receiver object for this invocation, if any.
     ;
     ; @return the instruction that produces the receiver object for this invocation if any,
     ;         nil if this invocation does not take a receiver object
     ;;
    (defn #_"ValueNode" MethodCallTargetNode''receiver-1 [#_"MethodCallTargetNode" this]
        (when-not (MethodCallTargetNode''isStatic-1 this)
            (nth (:arguments this) 0)
        )
    )

    ;;;
     ; Checks whether this is an invocation of a static method.
     ;
     ; @return true if the invocation is a static invocation
     ;;
    (defn #_"boolean" MethodCallTargetNode''isStatic-1 [#_"MethodCallTargetNode" this]
        (= (:invokeKind this) InvokeKind'Static)
    )

    #_unused
    (defn #_"JavaKind" MethodCallTargetNode''returnKind-1 [#_"MethodCallTargetNode" this]
        (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature (:targetMethod this)))
    )

    (defn #_"InvokeNode" MethodCallTargetNode''invoke-1 [#_"MethodCallTargetNode" this]
        (first (:nodeUsages this))
    )

    (defn #_"ResolvedJavaMethod" MethodCallTargetNode'findSpecialCallTarget-4 [#_"InvokeKind" invokeKind, #_"ValueNode" receiver, #_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaType" contextType]
        (cond
            (:direct invokeKind) nil
            ;; check for trivial cases (e.g. final methods, nonvirtual methods)
            (#_"ResolvedJavaMethod" .canBeStaticallyBound targetMethod) targetMethod
            :else (MethodCallTargetNode'devirtualizeCall-4 invokeKind, targetMethod, contextType, (:stamp receiver))
        )
    )

    (defn #_"ResolvedJavaMethod" MethodCallTargetNode'devirtualizeCall-4 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaType" contextType, #_"Stamp" receiverStamp]
        (let [
            #_"TypeReference" type
                (or (StampTool'typeReferenceOrNull-1 receiverStamp)
                    (when (= invokeKind InvokeKind'Virtual)
                        ;; For virtual calls, we are guaranteed to receive a correct receiver type.
                        (TypeReference'createTrusted-1 (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod))
                    )
                )
        ]
            (when (some? type)
                ;; either the holder class is exact, or the receiver object has an exact type, or it's an array type
                (let [
                    #_"ResolvedJavaMethod" resolvedMethod (#_"ResolvedJavaType" .resolveConcreteMethod (:type type), targetMethod, contextType)
                ]
                    (when (and (some? resolvedMethod) (or (#_"ResolvedJavaMethod" .canBeStaticallyBound resolvedMethod) (:exactReference type) (#_"ResolvedJavaType" .isArray (:type type))))
                        resolvedMethod
                    )
                )
            )
        )
    )

    (defm MethodCallTargetNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"MethodCallTargetNode" this, #_"SimplifierTool" tool]
            ;; attempt to devirtualize the call
            (when (some? (InvokeNode''getContextMethod-1 (MethodCallTargetNode''invoke-1 this))) ;; => avoid invokes that have placeholder bcis: they do not have a valid contextType
                (let [
                    #_"ResolvedJavaType" contextType (when-not (and (nil? (:stateAfter (MethodCallTargetNode''invoke-1 this))) (nil? (:stateDuring (MethodCallTargetNode''invoke-1 this)))) (InvokeNode''getContextType-1 (MethodCallTargetNode''invoke-1 this)))
                    #_"ResolvedJavaMethod" specialCallTarget (MethodCallTargetNode'findSpecialCallTarget-4 (:invokeKind this), (MethodCallTargetNode''receiver-1 this), (:targetMethod this), contextType)
                ]
                    (when (some? specialCallTarget)
                        (ยง ass! this (CallTargetNode''setTargetMethod-2 this, specialCallTarget))
                        (ยง ass! this (CallTargetNode''setInvokeKind-2 this, InvokeKind'Special))
                    )
                )
            )
            nil
        )
    )
)

(class-ns DummyGuardHandle [ValueNode, Node, GuardedNode]
    (defn #_"DummyGuardHandle" DummyGuardHandle'new-1 [#_"GuardingNode" guard]
        (merge (DummyGuardHandle'class.) (ValueNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input(InputType'Guard)
                #_"GuardingNode" :guard guard
            )
        )
    )

    (defm DummyGuardHandle GuardedNode
        (#_"GuardingNode" GuardedNode'''getGuard-1 [#_"DummyGuardHandle" this]
            (:guard this)
        )

        (#_"void" GuardedNode'''setGuard-2 [#_"DummyGuardHandle" this, #_"GuardingNode" guard]
            (Node''updateUsages-3 this, (:guard this), guard)
            (ยง ass! this (assoc this :guard guard))
            nil
        )
    )
)

(class-ns FixedNode [ValueNode, Node]
    (defn #_"FixedNode" FixedNode'new-1 [#_"Stamp" stamp]
        (merge (FixedNode'class.) (ValueNode'new-1 stamp))
    )
)

(class-ns AbstractEndNode [FixedNode, ValueNode, Node, LIRLowerable]
    (defn #_"AbstractEndNode" AbstractEndNode'new-0 []
        (merge (AbstractEndNode'class.) (FixedNode'new-1 VoidStamp'instance))
    )

    (defm AbstractEndNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AbstractEndNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''visitEndNode-2 builder, this)
            nil
        )
    )

    (defm AbstractEndNode AbstractEndNode
        (#_"AbstractMergeNode" AbstractEndNode'''merge-1 [#_"AbstractEndNode" this]
            (first (:nodeUsages this))
        )
    )

    (defm AbstractEndNode Node
        (#_"Node*" Node'''cfgSuccessors-1 [#_"AbstractEndNode" this]
            (let [
                #_"AbstractMergeNode" _merge (AbstractEndNode'''merge-1 this)
            ]
                (when (some? _merge) (list _merge))
            )
        )
    )
)

(class-ns EndNode [AbstractEndNode, FixedNode, ValueNode, Node, LIRLowerable]
    (defn #_"EndNode" EndNode'new-0 []
        (merge (EndNode'class.) (AbstractEndNode'new-0))
    )
)

;;;
 ; LoopEnd nodes represent a loop back-edge. When a LoopEnd is reached, execution continues at the
 ; {@linkplain #loopBegin() loop header}.
 ;;
(class-ns LoopEndNode [AbstractEndNode, FixedNode, ValueNode, Node, LIRLowerable]
    (defn #_"LoopEndNode" LoopEndNode'new-1 [#_"LoopBeginNode" begin]
        (merge (LoopEndNode'class.) (AbstractEndNode'new-0)
            (hash-map
                ;;;
                 ; The declared type of the field cannot be LoopBeginNode, because loop explosion during partial
                 ; evaluation can temporarily assign a non-loop begin. This node will then be deleted shortly
                 ; after - but we still must not have type system violations for that short amount of time.
                 ;;
                ; @Input
                #_"AbstractBeginNode" :loopBegin begin
                ;;;
                 ; The index of this loop end amongst its LoopBeginNode's loop ends.
                 ;
                 ; Since a LoopBeginNode also has {@linkplain LoopBeginNode#forwardEnds() forward ends},
                 ; this is *not* the index into PhiNode values at the loop begin.
                 ; Use LoopBeginNode#phiPredecessorIndex(AbstractEndNode) for this purpose.
                 ;;
                #_"int" :endIndex (LoopBeginNode''nextEndIndex-1 begin)
                ;;;
                 ; Most loop ends need a safepoint (flag set to true) so that garbage collection can interrupt
                 ; a long-running (possibly endless) loop. Safepoints may be disabled for two reasons: (1) Some
                 ; code must be safepoint free, i.e. uninterruptible by garbage collection. (2) An optimization
                 ; phase determined that the loop already has another safepoint or cannot be endless, so there
                 ; is no need for a loop-end safepoint.
                 ;
                 ; Note that (1) is a hard correctness issue: emitting a safepoint in uninterruptible code is a bug,
                 ; i.e. it is not allowed to set the flag back to true once it is false. To ensure that loop ends
                 ; that are created late, e.g. during control flow simplifications, have no safepoints in such cases,
                 ; the safepoints are actually disabled for the {@link LoopBeginNode#canEndsSafepoint loop begin}.
                 ; New loop ends inherit the flag value from the loop begin.
                 ;;
                #_"boolean" :canSafepoint (:canEndsSafepoint begin)
            )
        )
    )

    (defm LoopEndNode AbstractEndNode
        (#_"AbstractMergeNode" AbstractEndNode'''merge-1 [#_"LoopEndNode" this]
            (:loopBegin this)
        )
    )

    (defn #_"LoopEndNode" LoopEndNode''setLoopBegin-2 [#_"LoopEndNode" this, #_"LoopBeginNode" loopBegin]
        (Node''updateUsages-3 this, (:loopBegin this), loopBegin)
        (assoc this :loopBegin loopBegin)
    )

    ;;;
     ; Disables safepoints for only this loop end (in contrast to disabling it for
     ; {@link LoopBeginNode#disableSafepoint() the whole loop}).
     ;;
    (defn #_"LoopEndNode" LoopEndNode''disableSafepoint-1 [#_"LoopEndNode" this]
        (assoc this :canSafepoint false)
    )

    (defm LoopEndNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"LoopEndNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''visitLoopEnd-2 builder, this)
            (LIRLowerable'''generate-2 (ยง super AbstractEndNode'iface), builder)
            nil
        )
    )

    (defn #_"LoopEndNode" LoopEndNode''setEndIndex-2 [#_"LoopEndNode" this, #_"int" idx]
        (assoc this :endIndex idx)
    )

    (defm LoopEndNode Node
        (#_"Node*" Node'''cfgSuccessors-1 [#_"LoopEndNode" this]
            nil
        )
    )
)

(class-ns ControlSinkNode [FixedNode, ValueNode, Node]
    (defn #_"ControlSinkNode" ControlSinkNode'new-1 [#_"Stamp" stamp]
        (merge (ControlSinkNode'class.) (FixedNode'new-1 stamp))
    )
)

(class-ns AbstractDeoptimizeNode [ControlSinkNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState]
    (defn #_"AbstractDeoptimizeNode" AbstractDeoptimizeNode'new-1 [#_"FrameState" stateBefore]
        (merge (AbstractDeoptimizeNode'class.) (ControlSinkNode'new-1 VoidStamp'instance)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateBefore stateBefore
            )
        )
    )

    (defm AbstractDeoptimizeNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"AbstractDeoptimizeNode" this]
            true
        )
    )

    (defm AbstractDeoptimizeNode DeoptBefore
        (#_"void" DeoptBefore'''setStateBefore-2 [#_"AbstractDeoptimizeNode" this, #_"FrameState" f]
            (Node''updateUsages-3 this, (:stateBefore this), f)
            (ยง ass! this (assoc this :stateBefore f))
            nil
        )
    )
)

(class-ns DeoptimizeNode [AbstractDeoptimizeNode, ControlSinkNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Lowerable, LIRLowerable, StaticDeoptimizingNode]
    (def #_"int" DeoptimizeNode'DEFAULT_DEBUG_ID 0)

    (ยง intrinsic! #_"void" DeoptimizeNode'deopt-2 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason])

    #_intrinsifier
    (defn #_"DeoptimizeNode" DeoptimizeNode'new-2 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason]
        (DeoptimizeNode'new-5 action, reason, DeoptimizeNode'DEFAULT_DEBUG_ID, JavaConstant/NULL_POINTER, nil)
    )

    (defn #_"DeoptimizeNode" DeoptimizeNode'new-3 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason, #_"JavaConstant" speculation]
        (DeoptimizeNode'new-5 action, reason, DeoptimizeNode'DEFAULT_DEBUG_ID, speculation, nil)
    )

    (defn #_"DeoptimizeNode" DeoptimizeNode'new-5 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason, #_"int" debugId, #_"JavaConstant" speculation, #_"FrameState" stateBefore]
        (merge (DeoptimizeNode'class.) (AbstractDeoptimizeNode'new-1 stateBefore)
            (hash-map
                #_"DeoptimizationAction" :action action
                #_"DeoptimizationReason" :reason reason
                #_"int" :debugId debugId
                #_"JavaConstant" :speculation speculation
            )
        )
    )

    (defm DeoptimizeNode StaticDeoptimizingNode
        (#_"void" StaticDeoptimizingNode'''setAction-2 [#_"DeoptimizeNode" this, #_"DeoptimizationAction" action]
            (ยง ass! this (assoc this :action action))
            nil
        )

        (#_"void" StaticDeoptimizingNode'''setReason-2 [#_"DeoptimizeNode" this, #_"DeoptimizationReason" reason]
            (ยง ass! this (assoc this :reason reason))
            nil
        )
    )

    (defm DeoptimizeNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"DeoptimizeNode" this, #_"LoweringTool" lowerer]
            nil ;; No lowering, we generate LIR directly for this node.
        )
    )

    (defm DeoptimizeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"DeoptimizeNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" actionAndReason (LIRGenerator''emitJavaConstant-2 (:gen builder), (#_"MetaAccessProvider" .encodeDeoptActionAndReason HotSpot'metaAccess, (:action this), (:reason this), (:debugId this)))
                #_"Value" speculationValue (LIRGenerator''emitJavaConstant-2 (:gen builder), (:speculation this))
            ]
                (LIRGenerator''emitDeoptimize-3 (:gen builder), actionAndReason, speculationValue)
            )
            nil
        )
    )

    (defm DeoptimizeNode AbstractDeoptimizeNode
        (#_"ValueNode" AbstractDeoptimizeNode'''getActionAndReason-1 [#_"DeoptimizeNode" this]
            (ConstantNode'forConstant-2c (#_"MetaAccessProvider" .encodeDeoptActionAndReason HotSpot'metaAccess, (:action this), (:reason this), (:debugId this)), (:graph this))
        )

        (#_"ValueNode" AbstractDeoptimizeNode'''getSpeculation-1 [#_"DeoptimizeNode" this]
            (ConstantNode'forConstant-2c (:speculation this), (:graph this))
        )
    )

    (defm DeoptimizeNode StaticDeoptimizingNode
        (#_"GuardPriority" StaticDeoptimizingNode'''computePriority-1 [#_"DeoptimizeNode" this]
            (if (and (some? (:speculation this)) (#_"JavaConstant" .isNonNull (:speculation this)))
                GuardPriority'Speculation
                (condp =? (:action this)
                    [DeoptimizationAction/InvalidateReprofile DeoptimizationAction/InvalidateRecompile]                                    GuardPriority'Profile
                    [DeoptimizationAction/RecompileIfTooManyDeopts DeoptimizationAction/InvalidateStopCompiling DeoptimizationAction/None] GuardPriority'None
                )
            )
        )
    )
)

(class-ns DynamicDeoptimizeNode [AbstractDeoptimizeNode, ControlSinkNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, LIRLowerable, Lowerable, Canonicalizable]
    (defn #_"DynamicDeoptimizeNode" DynamicDeoptimizeNode'new-2 [#_"ValueNode" actionAndReason, #_"ValueNode" speculation]
        (merge (DynamicDeoptimizeNode'class.) (AbstractDeoptimizeNode'new-1 nil)
            (hash-map
                ; @Input
                #_"ValueNode" :actionAndReason actionAndReason
                ; @Input
                #_"ValueNode" :speculation speculation
            )
        )
    )

    (defm DynamicDeoptimizeNode AbstractDeoptimizeNode
        (#_"ValueNode" AbstractDeoptimizeNode'''getActionAndReason-1 [#_"DynamicDeoptimizeNode" this]
            (:actionAndReason this)
        )

        (#_"ValueNode" AbstractDeoptimizeNode'''getSpeculation-1 [#_"DynamicDeoptimizeNode" this]
            (:speculation this)
        )
    )

    (defm DynamicDeoptimizeNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"DynamicDeoptimizeNode" this, #_"LoweringTool" lowerer]
            nil ;; No lowering, we generate LIR directly for this node.
        )
    )

    (defm DynamicDeoptimizeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"DynamicDeoptimizeNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitDeoptimize-3 (:gen builder), (LIRBuilder''operand-2 builder, (:actionAndReason this)), (LIRBuilder''operand-2 builder, (:speculation this)))
            nil
        )
    )

    (defm DynamicDeoptimizeNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"DynamicDeoptimizeNode" this, #_"CanonicalizerTool" tool]
            (when (and (satisfies? ConstantNode (:actionAndReason this)) (satisfies? ConstantNode (:speculation this))) => this
                (let [
                    #_"JavaConstant" constant (ValueNode''asJavaConstant-1 (:actionAndReason this))
                ]
                    (DeoptimizeNode'new-5 (#_"MetaAccessProvider" .decodeDeoptAction HotSpot'metaAccess, constant), (#_"MetaAccessProvider" .decodeDeoptReason HotSpot'metaAccess, constant), (#_"MetaAccessProvider" .decodeDebugId HotSpot'metaAccess, constant), (ValueNode''asJavaConstant-1 (:speculation this)), (:stateBefore this))
                )
            )
        )
    )
)

;;;
 ; Removes the current frame and tail calls the uncommon trap routine.
 ;;
(class-ns DeoptimizeCallerNode [ControlSinkNode, FixedNode, ValueNode, Node, LIRLowerable]
    (ยง intrinsic! #_"void" DeoptimizeCallerNode'deopt-2 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason])

    #_intrinsifier
    (defn #_"DeoptimizeCallerNode" DeoptimizeCallerNode'new-2 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason]
        (merge (DeoptimizeCallerNode'class.) (ControlSinkNode'new-1 VoidStamp'instance)
            (hash-map
                #_"DeoptimizationAction" :action action
                #_"DeoptimizationReason" :reason reason
            )
        )
    )

    (defm DeoptimizeCallerNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"DeoptimizeCallerNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitDeoptimizeCaller-3 (:gen builder), (:action this), (:reason this))
            nil
        )
    )
)

(class-ns ReturnNode [ControlSinkNode, FixedNode, ValueNode, Node, LIRLowerable]
    (defn #_"ReturnNode" ReturnNode'new-1 [#_"ValueNode" result]
        (ReturnNode'new-2 result, nil)
    )

    (defn #_"ReturnNode" ReturnNode'new-2 [#_"ValueNode" result, #_"MemoryMapNode" memoryMap]
        (merge (ReturnNode'class.) (ControlSinkNode'new-1 VoidStamp'instance)
            (hash-map
                ; @OptionalInput
                #_"ValueNode" :result result
                ; @OptionalInput
                #_"MemoryMapNode" :memoryMap memoryMap
            )
        )
    )

    (defm ReturnNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ReturnNode" this, #_"LIRBuilder" builder]
            (if (nil? (:result this))
                (ยง ass! (:gen builder) (LIRGenerator''emitReturn-3 (:gen builder), JavaKind/Void, nil))
                (ยง ass! (:gen builder) (LIRGenerator''emitReturn-3 (:gen builder), (ValueNode''getStackKind-1 (:result this)), (LIRBuilder''operand-2 builder, (:result this))))
            )
            nil
        )
    )

    (defn #_"ReturnNode" ReturnNode''setMemoryMap-2 [#_"ReturnNode" this, #_"MemoryMapNode" memoryMap]
        (Node''updateUsages-3 this, (:memoryMap this), memoryMap)
        (assoc this :memoryMap memoryMap)
    )
)

(class-ns ControlSplitNode [FixedNode, ValueNode, Node]
    (defn #_"ControlSplitNode" ControlSplitNode'new-1 [#_"Stamp" stamp]
        (merge (ControlSplitNode'class.) (FixedNode'new-1 stamp))
    )
)

;;;
 ; The IfNode represents a branch that can go one of two directions depending on the outcome
 ; of a comparison.
 ;;
(class-ns IfNode [ControlSplitNode, FixedNode, ValueNode, Node, Simplifiable, LIRLowerable]
    (defn #_"IfNode" IfNode''setCondition-2 [#_"IfNode" this, #_"LogicNode" logic]
        (Node''updateUsages-3 this, (:logic this), logic)
        (assoc this :logic logic)
    )

    (defn #_"IfNode" IfNode'new-4f [#_"LogicNode" logic, #_"FixedNode" trueSuccessor, #_"FixedNode" falseSuccessor, #_"double" trueSuccessorProbability]
        (IfNode'new-4b logic, (BeginNode'begin-1 trueSuccessor), (BeginNode'begin-1 falseSuccessor), trueSuccessorProbability)
    )

    (defn #_"IfNode" IfNode'new-4b [#_"LogicNode" logic, #_"AbstractBeginNode" trueSuccessor, #_"AbstractBeginNode" falseSuccessor, #_"double" trueSuccessorProbability]
        (let [
            #_"IfNode" this
                (merge (IfNode'class.) (ControlSplitNode'new-1 VoidStamp'instance)
                    (hash-map
                        ; @Successor
                        #_"AbstractBeginNode" :trueSuccessor trueSuccessor
                        ; @Successor
                        #_"AbstractBeginNode" :falseSuccessor falseSuccessor
                        ; @Input
                        #_"LogicNode" :logic logic
                        #_"double" :trueSuccessorProbability 0.0
                    )
                )
            this (IfNode''setTrueSuccessorProbability-2 this, trueSuccessorProbability)
        ]
            this
        )
    )

    (defn #_"IfNode" IfNode''setTrueSuccessor-2 [#_"IfNode" this, #_"AbstractBeginNode" node]
        (Node''updatePredecessor-3 this, (:trueSuccessor this), node)
        (assoc this :trueSuccessor node)
    )

    (defn #_"IfNode" IfNode''setFalseSuccessor-2 [#_"IfNode" this, #_"AbstractBeginNode" node]
        (Node''updatePredecessor-3 this, (:falseSuccessor this), node)
        (assoc this :falseSuccessor node)
    )

    ;;;
     ; Gets the node corresponding to the specified outcome of the branch.
     ;
     ; @param istrue true if the true successor is requested, false otherwise
     ; @return the corresponding successor
     ;;
    (defn #_"AbstractBeginNode" IfNode''getSuccessor-2 [#_"IfNode" this, #_"boolean" istrue]
        (if istrue (:trueSuccessor this) (:falseSuccessor this))
    )

    (defn #_"IfNode" IfNode''setTrueSuccessorProbability-2 [#_"IfNode" this, #_"double" prob]
        (assoc this :trueSuccessorProbability (min 1.0 (max 0.0 prob)))
    )

    (defm IfNode ControlSplitNode
        (#_"double" ControlSplitNode'''probability-2 [#_"IfNode" this, #_"AbstractBeginNode" successor]
            (if (= successor (:trueSuccessor this)) (:trueSuccessorProbability this) (- 1.0 (:trueSuccessorProbability this)))
        )
    )

    (defm IfNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"IfNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''emitIf-2 builder, this)
            nil
        )
    )

    (defn #_"this" IfNode''eliminateNegation-1 [#_"IfNode" this]
        (let [
            this (assoc this :trueSuccessor (:falseSuccessor this) :falseSuccessor (:trueSuccessor this))
            this (assoc this :trueSuccessorProbability (- 1.0 (:trueSuccessorProbability this)))
            this (IfNode''setCondition-2 this, (Unary'''getValue-1 (ยง cast #_"LogicNegationNode" (:logic this))))
        ]
            this
        )
    )

    (defn- #_"void" IfNode''pushNodesThroughIf-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        ;; push similar nodes upwards through the if, thereby deduplicating them
        (loop []
            (let [
                #_"AbstractBeginNode" trueSucc (:trueSuccessor this)
                #_"AbstractBeginNode" falseSucc (:falseSuccessor this)
            ]
                (when (and (satisfies? BeginNode trueSucc) (satisfies? BeginNode falseSucc) (satisfies? FixedWithNextNode (:next trueSucc)) (satisfies? FixedWithNextNode (:next falseSucc)))
                    (let [
                        #_"FixedWithNextNode" trueNext (:next trueSucc)
                        #_"FixedWithNextNode" falseNext (:next falseSucc)
                        #_"NodeClass" nodeClass (:nodeClass trueNext)
                    ]
                        (when (= (#_"Object" .getClass trueNext) (#_"Object" .getClass falseNext))
                            (cond
                                (satisfies? AbstractBeginNode trueNext)
                                (do
                                    ;; Cannot do this optimization for begin nodes, because it could
                                    ;; move guards above the if that need to stay below a branch.
                                )
                                (and (NodeClass''equalInputs-3 nodeClass, trueNext, falseNext) (Node''valueEquals-2 trueNext, falseNext))
                                (do
                                    (ยง ass! falseNext (Node''replaceAtUsages-2 falseNext, trueNext))
                                    (Graph''removeFixed-2 (:graph this), falseNext)
                                    (GraphUtil'unlinkFixedNode-1 trueNext)
                                    (Graph''addBeforeFixed-3 (:graph this), this, trueNext)
                                    (doseq [#_"Node" usage (:nodeUsages trueNext)]
                                        (when (Node''isAlive-1 usage)
                                            (SimplifierTool'''addToWorkList-2n tool, usage)
                                        )
                                    )
                                    (recur)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Check it these two blocks end up at the same place. Meeting at the same merge, or deoptimizing in the same way.
     ;;
    (defn- #_"boolean" IfNode'sameDestination-2 [#_"AbstractBeginNode" succ1, #_"AbstractBeginNode" succ2]
        (let [
            #_"Node" next1 (:next succ1)
            #_"Node" next2 (:next succ2)
        ]
            (cond
                ;; go to the same MergeNode and merge the same values
                (and (satisfies? EndNode next1) (satisfies? EndNode next2))
                    (and (= (AbstractEndNode'''merge-1 next1) (AbstractEndNode'''merge-1 next2))
                        (loop-when [#_"ISeq" s (seq (AbstractMergeNode''phis-1 (AbstractEndNode'''merge-1 next1)))] (some? s) => true
                            (let [
                                #_"PhiNode" phi (first s)
                            ]
                                (and (= (PhiNode''valueAt-2n phi, next1) (PhiNode''valueAt-2n phi, next2))
                                    (recur (next s))
                                )
                            )
                        )
                    )
                ;; same deoptimization reason and action
                (and (satisfies? DeoptimizeNode next1) (satisfies? DeoptimizeNode next2))
                    (and (= (:reason next1) (:reason next2)) (= (:action next1) (:action next2)))
                ;; exit the same loop and end up at the same place
                (and (satisfies? LoopExitNode next1) (satisfies? LoopExitNode next2))
                    (and (= (:loopBegin next1) (:loopBegin next2))
                         (= (:stateAfter next1) (:stateAfter next2))
                         (nil? (:stateAfter next1))
                         (IfNode'sameDestination-2 next1, next2)
                    )
                ;; exit the same loop and end up at the same place
                (and (satisfies? ReturnNode next1) (satisfies? ReturnNode next2))
                    (= (:result next1) (:result next2))
                :else
                    false
            )
        )
    )

    ;;;
     ; Recognize a couple patterns that can be merged into an unsigned compare.
     ;
     ; @return true if a replacement was done
     ;;
    (defn- #_"boolean" IfNode''checkForUnsignedCompare-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (satisfies? IntegerLessThanNode (:logic this))
            (let [
                #_"IntegerLessThanNode" lessThan (:logic this)
                #_"Constant" y (Stamp'''asConstant-1 (:stamp (:y lessThan)))
            ]
                (and (instance? PrimitiveConstant y) (zero? (UnsignedLong''asLong-1 y)) (satisfies? IfNode (:next (:falseSuccessor this)))
                    (let [
                        #_"IfNode" ifNode2 (:next (:falseSuccessor this))
                    ]
                        (and (satisfies? IntegerLessThanNode (:logic ifNode2))
                            (let [
                                #_"IntegerLessThanNode" lessThan2 (:logic ifNode2)
                                #_"AbstractBeginNode" trueSucc (:trueSuccessor ifNode2)
                                #_"AbstractBeginNode" falseSucc (:falseSuccessor ifNode2)
                                [trueSucc falseSucc #_"IntegerBelowNode" below]
                                    ;; Convert x >= 0 && x < positive, which is represented as !(x < 0) && x < <positive>, into an unsigned compare.
                                    (cond
                                        (and (= (:x lessThan2) (:x lessThan)) (satisfies? IntegerStamp (:stamp (:y lessThan2))) (IntegerStamp''isPositive-1 (:stamp (:y lessThan2))) (IfNode'sameDestination-2 (:trueSuccessor this), (:falseSuccessor ifNode2)))
                                            ;; swap direction
                                            [falseSucc trueSucc (Graph''add-2 (:graph this), (IntegerBelowNode'new-2 (:x lessThan2), (:y lessThan2)))]
                                        (and (= (:y lessThan2) (:x lessThan)) (IfNode'sameDestination-2 (:trueSuccessor this), (:trueSuccessor ifNode2)))
                                            ;; Convert x >= 0 && x <= positive, which is represented as !(x < 0) && !(<positive> > x), into x <| positive + 1.
                                            ;; Only for constants, since there isn't an IntegerBelowEqualThanNode, but that doesn't appear to be interesting.
                                            (let [
                                                #_"JavaConstant" positive (ValueNode''asJavaConstant-1 (:x lessThan2))
                                                below
                                                    (when (and (some? positive) (pos? (UnsignedLong''asLong-1 positive)) (< (UnsignedLong''asLong-1 positive) (#_"JavaKind" .getMaxValue (#_"JavaConstant" .getJavaKind positive))))
                                                        (Graph''add-2 (:graph this), (IntegerBelowNode'new-2 (:x lessThan), (ConstantNode'forIntegerStamp-3 (:stamp (:x lessThan2)), (inc (UnsignedLong''asLong-1 positive)), (:graph this))))
                                                    )
                                            ]
                                                [trueSucc falseSucc below]
                                            )
                                        :else
                                            [trueSucc falseSucc nil]
                                    )
                            ]
                                (and (some? below)
                                    (do
                                        (ยง ass! ifNode2 (IfNode''setTrueSuccessor-2 ifNode2, nil))
                                        (ยง ass! ifNode2 (IfNode''setFalseSuccessor-2 ifNode2, nil))

                                        (let [
                                            #_"IfNode" newIfNode (Graph''add-2 (:graph this), (IfNode'new-4b below, falseSucc, trueSucc, (- 1.0 (:trueSuccessorProbability this))))
                                        ]
                                            ;; Remove the < 0 test.
                                            (SimplifierTool'''deleteBranch-2 tool, (:trueSuccessor this))
                                            (Graph''removeSplit-3 (:graph this), this, (:falseSuccessor this))

                                            ;; Replace the second test with the new one.
                                            (Node''replaceFirstSuccessor-3 (:predecessor ifNode2), ifNode2, newIfNode)
                                            (Node''safeDelete-1 ifNode2)
                                            true
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" IfNode''removeThroughFalseBranch-3 [#_"IfNode" this, #_"SimplifierTool" tool, #_"AbstractMergeNode" merge]
        (let [
            #_"AbstractBeginNode" trueBegin (:trueSuccessor this)
            #_"LogicNode" logic (:logic this)
        ]
            (Graph''removeSplitPropagate-3 (:graph this), this, trueBegin)
            (SimplifierTool'''addToWorkList-2n tool, trueBegin)
            (when (some? logic)
                (GraphUtil'tryKillUnused-1 logic)
            )
            (when (and (Node''isAlive-1 merge) (< 1 (AbstractMergeNode''forwardEndCount-1 merge)))
                (doseq [#_"FixedNode" end (:ends merge)]
                    (let [
                        #_"Node" n (loop-when-recur [n end] (and (some? n) (satisfies? BeginNode (:predecessor n))) [(:predecessor n)] => n)
                    ]
                        (when (and (some? n) (satisfies? IfNode (:predecessor n)))
                            (SimplifierTool'''addToWorkList-2n tool, (:predecessor n))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"ValueNode" IfNode''canonicalizeConditionalCascade-4 [#_"IfNode" this, #_"SimplifierTool" tool, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (cond
            (not (= (ValueNode''getStackKind-1 trueValue) (ValueNode''getStackKind-1 falseValue)))
                nil
            (not (any = (ValueNode''getStackKind-1 trueValue) JavaKind/Int JavaKind/Long))
                nil
            (and (satisfies? ConstantNode trueValue) (satisfies? ConstantNode falseValue))
                (Graph''add-2 (:graph this), (ConditionalNode'new-3 (:logic this), trueValue, falseValue))
            (not (:isAfterExpandLogic (:graph this)))
                (let [
                    [#_"ConditionalNode" conditional #_"ValueNode" constant #_"boolean" negateCondition]
                        (cond
                            (and (satisfies? ConditionalNode trueValue)  (satisfies? ConstantNode falseValue)) [trueValue falseValue true ]
                            (and (satisfies? ConditionalNode falseValue) (satisfies? ConstantNode trueValue) ) [falseValue trueValue false]
                            :else
                                (ยง return nil)
                        )
                ]
                    (let [
                        [#_"ValueNode" otherValue #_"boolean" negateConditionalCondition]
                            (condp = constant
                                (:trueValue conditional)  [(:falseValue conditional) false]
                                (:falseValue conditional) [(:trueValue conditional)  true ]
                                                          [nil                       false]
                            )
                    ]
                        (cond
                            (and (some? otherValue) (satisfies? ConstantNode otherValue))
                                (let [
                                    #_"double" shortCutProbability (ControlSplitNode'''probability-2 this, (:trueSuccessor this))
                                    #_"LogicNode" newCondition (LogicNode'or-5 (:logic this), negateCondition, (:logic conditional), negateConditionalCondition, shortCutProbability)
                                ]
                                    (Graph''add-2 (:graph this), (ConditionalNode'new-3 newCondition, constant, otherValue))
                                )
                            (and (not negateCondition) (ValueNode''isJavaConstant-1 constant) (ValueNode''isJavaConstant-1 (:trueValue conditional)) (ValueNode''isJavaConstant-1 (:falseValue conditional)))
                                (let [
                                    [#_"IntegerLessThanNode" lessThan #_"IntegerEqualsNode" equals]
                                        (cond
                                            (and (satisfies? IntegerLessThanNode (:logic this)) (satisfies? IntegerEqualsNode (:logic conditional)) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 constant)) -1) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:trueValue conditional)))) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:falseValue conditional))) 1))
                                                [
                                                    (:logic this)
                                                    (:logic conditional)
                                                ]
                                            (and (satisfies? IntegerEqualsNode (:logic this)) (satisfies? IntegerLessThanNode (:logic conditional)) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 constant))) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:trueValue conditional))) -1) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:falseValue conditional))) 1))
                                                [
                                                    (:logic conditional)
                                                    (:logic this)
                                                ]
                                        )
                                ]
                                    (when (some? lessThan)
                                        (when (or (and (= (:x lessThan) (:x equals)) (= (:y lessThan) (:y equals))) (and (= (:x lessThan) (:y equals)) (= (:y lessThan) (:x equals))))
                                            (Graph''add-2 (:graph this), (NormalizeCompareNode'new-3 (:x lessThan), (:y lessThan), (Stamp'''getStackKind-1 (:stamp (:trueValue conditional)))))
                                        )
                                    )
                                )
                        )
                    )
                )
        )
    )

    (defn- #_"ValueNode" IfNode''proxyReplacement-2 [#_"IfNode" this, #_"ValueNode" replacement]
        ;; Special case: Every empty diamond we collapse to a conditional node can potentially
        ;; contain loop exit nodes on both branches. See the graph below: The two loop exits
        ;; (instanceof begin node) exit the same loop. The resulting phi is defined outside the
        ;; loop, but the resulting conditional node will be inside the loop, so we need to proxy the
        ;; resulting conditional node. Callers of this method ensure that true and false successor
        ;; have no usages, therefore a and b in the graph below can never be proxies themselves.
        ;;
        ;;              +--+
        ;;              |If|
        ;;              +--+      +-----+ +-----+
        ;;         +----+  +----+ |  a  | |  b  |
        ;;         |Lex |  |Lex | +----^+ +^----+
        ;;         +----+  +----+      |   |
        ;;           +-------+         +---+
        ;;           | Merge +---------+Phi|
        ;;           +-------+         +---+
        (if (and (:hasValueProxies (:graph this)) (satisfies? LoopExitNode (:trueSuccessor this)) (satisfies? LoopExitNode (:falseSuccessor this)))
            (Graph''add-2 (:graph this), (ValueProxyNode'new-2 replacement, (:trueSuccessor this)))
            replacement
        )
    )

    ;;;
     ; Tries to remove an empty if construct or replace an if construct with a materialization.
     ;
     ; @return true if a transformation was made, false otherwise
     ;;
    (defn- #_"boolean" IfNode''removeOrMaterializeIf-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (let [
            #_"FixedNode" trueEnd (:next (:trueSuccessor this))
            #_"FixedNode" falseEnd (:next (:falseSuccessor this))
        ]
            (when (and (satisfies? AbstractEndNode trueEnd) (satisfies? AbstractEndNode falseEnd))
                (let [
                    #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 trueEnd)
                ]
                    (when (and (= merge (AbstractEndNode'''merge-1 falseEnd)) (empty? (AbstractBeginNode'''anchored-1 (:trueSuccessor this))) (empty? (AbstractBeginNode'''anchored-1 (:falseSuccessor this))))
                        (let [
                            [#_"PhiNode" singlePhi #_"int" distinct]
                                (loop-when [singlePhi nil distinct 0 #_"ISeq" s (seq (AbstractMergeNode''phis-1 merge))] (some? s) => [singlePhi distinct]
                                    (let [
                                        #_"PhiNode" phi (first s)
                                    ]
                                        (if (= (PhiNode''valueAt-2n phi, trueEnd) (PhiNode''valueAt-2n phi, falseEnd))
                                            (recur singlePhi distinct (next s))
                                            (recur phi (inc distinct) (next s))
                                        )
                                    )
                                )
                        ]
                            (case distinct
                                0
                                    (do
                                        ;; multiple phis, but merging same values for true and false, so simply delete the path
                                        (IfNode''removeThroughFalseBranch-3 this, tool, merge)
                                        (ยง return true)
                                    )
                                1
                                    (let [
                                        #_"ValueNode" trueValue (PhiNode''valueAt-2n singlePhi, trueEnd)
                                        #_"ValueNode" falseValue (PhiNode''valueAt-2n singlePhi, falseEnd)
                                        #_"ValueNode" conditional (IfNode''canonicalizeConditionalCascade-4 this, tool, trueValue, falseValue)
                                    ]
                                        (when (some? conditional)
                                            (PhiNode''setValueAt-3n singlePhi, trueEnd, (IfNode''proxyReplacement-2 this, conditional))
                                            (IfNode''removeThroughFalseBranch-3 this, tool, merge)
                                            (ยง return true)
                                        )
                                    )
                                nil
                            )
                        )
                    )
                )
            )
            (and (satisfies? ReturnNode trueEnd) (satisfies? ReturnNode falseEnd)
                (let [
                    #_"ValueNode" trueValue (:result trueEnd)
                    #_"ValueNode" falseValue (:result falseEnd)
                    #_"ValueNode" value nil
                ]
                    (when (some? trueValue)
                        (if (= trueValue falseValue)
                            (ยง ass value trueValue)
                            (do
                                (ยง ass value (IfNode''canonicalizeConditionalCascade-4 this, tool, trueValue, falseValue))
                                (when (nil? value)
                                    (ยง return false)
                                )
                            )
                        )
                    )
                    (Node''replaceAtPredecessor-2 this, (Graph''add-2 (:graph this), (ReturnNode'new-1 value)))
                    (GraphUtil'killCFG-1 this)
                    true
                )
            )
        )
    )

    ;;;
     ; Gets an array of constants derived from a node that is either a ConstantNode or a
     ; PhiNode whose input values are all constants. The length of the returned array is
     ; equal to the number of ends terminating in a given merge node.
     ;
     ; @return nil if {@code node} is neither a ConstantNode nor a PhiNode whose
     ;         input values are all constants
     ;;
    (defn- #_"Constant[]" IfNode'constantValues-3 [#_"ValueNode" node, #_"AbstractMergeNode" merge, #_"boolean" allow-nil?]
        (cond
            (satisfies? ConstantNode node)
                (let [
                    #_"Constant[]" constants (make-array Constant (AbstractMergeNode''forwardEndCount-1 merge))
                ]
                    (Arrays/fill constants, (:value node))
                    constants
                )
            (and (satisfies? PhiNode node) (= (:merge node) merge) (satisfies? ValuePhiNode node) (= (PhiNode''valueCount-1 node) (AbstractMergeNode''forwardEndCount-1 merge)))
                (let [
                    #_"Constant[]" constants (make-array Constant (AbstractMergeNode''forwardEndCount-1 merge))
                ]
                    (loop-when [#_"int" i 0 #_"ISeq" s (seq (:values node))] (some? s) => constants
                        (let [
                            #_"ValueNode" n (first s)
                        ]
                            (when (or allow-nil? (satisfies? ConstantNode n))
                                (aset constants i (ValueNode''asConstant-1 n))
                                (recur (inc i) (next s))
                            )
                        )
                    )
                )
        )
    )

    (defn- #_"boolean" IfNode'checkFrameState-1 [#_"FixedNode" node]
        (loop [node node]
            (condp satisfies? node
                AbstractMergeNode
                    (ยง return (some? (:stateAfter node)))
                StateSplit
                    (when (some? (:stateAfter node))
                        (ยง return true)
                    )
                nil
            )

            (condp satisfies? node
                ControlSplitNode
                    (loop-when [#_"ISeq" s (seq (Node'''cfgSuccessors-1 node))] (some? s) => false
                        (or (IfNode'checkFrameState-1 (first s))
                            (recur (next s))
                        )
                    )
                FixedWithNextNode (recur (:next node))
                AbstractEndNode   (recur (AbstractEndNode'''merge-1 node))
                ControlSinkNode   true
                                  false
            )
        )
    )

    ;;;
     ; Connects a set of ends to a given successor, inserting a merge node if there is more than
     ; one end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}'s
     ; {@linkplain SimplifierTool#addToWorkList(Node) work list}.
     ;
     ; @param oldMerge the merge being removed
     ; @param phiValues the values of the phi at the merge, keyed by the merge ends
     ;;
    (defn- #_"void" IfNode''connectEnds-6 [#_"IfNode" this, #_"List<EndNode>" ends, #_"EconomicMap<AbstractEndNode, ValueNode>" phiValues, #_"AbstractBeginNode" successor, #_"AbstractMergeNode" oldMerge, #_"SimplifierTool" tool]
        (when (seq ends)
            (if (= (count ends) 1)
                (let [
                    #_"AbstractEndNode" end (nth ends 0)
                ]
                    (ยง ass! (:predecessor end) (FixedWithNextNode''setNext-2 (:predecessor end), successor))
                    (AbstractMergeNode''removeEnd-2 oldMerge, end)
                    (GraphUtil'killCFG-1 end)
                )
                ;; need a new phi in case the frame state is used by more than the merge being removed
                (let [
                    #_"AbstractMergeNode" newMerge (Graph''add-2 (:graph this), (MergeNode'new-0))
                    #_"PhiNode" oldPhi (first (:nodeUsages oldMerge))
                    #_"PhiNode" newPhi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 (:stamp oldPhi), newMerge))
                ]
                    (doseq [#_"EndNode" end ends]
                        (PhiNode''addInput-2 newPhi, (get phiValues end))
                        (AbstractMergeNode''addForwardEnd-2 newMerge, end)
                    )

                    (let [
                        #_"FrameState" stateAfter (:stateAfter oldMerge)
                    ]
                        (when (some? stateAfter)
                            (ยง ass stateAfter (FrameState''duplicate-1 stateAfter))
                            (Node''replaceFirstInput-3 stateAfter, oldPhi, newPhi)
                            (StateSplit'''setStateAfter-2 newMerge, stateAfter)
                        )

                        (ยง ass! newMerge (FixedWithNextNode''setNext-2 newMerge, successor))
                    )
                )
            )
            (SimplifierTool'''addToWorkList-2n tool, successor)
        )
        nil
    )

    (defn- #_"void" IfNode'propagateZeroProbability-1 [#_"FixedNode" start]
        (loop-when [#_"FixedNode" prev nil #_"FixedNode" node start] (some? node)
            (and
                (cond
                    (satisfies? IfNode node)
                        (condp = prev
                            (:trueSuccessor node)
                                (case (:trueSuccessorProbability node)
                                    0.0 nil
                                    1.0 :continue
                                    (do
                                        (ยง ass! node (IfNode''setTrueSuccessorProbability-2 node, 0.0))
                                        nil
                                    )
                                )
                            (:falseSuccessor node)
                                (case (:trueSuccessorProbability node)
                                    1.0 nil
                                    0.0 :continue
                                    (do
                                        (ยง ass! node (IfNode''setTrueSuccessorProbability-2 node, 1.0))
                                        nil
                                    )
                                )
                        )
                    (and (satisfies? AbstractMergeNode node) (not (satisfies? LoopBeginNode node)))
                        (do
                            (doseq [#_"AbstractEndNode" endNode (Node'''cfgPredecessors-1 node)]
                                (IfNode'propagateZeroProbability-1 endNode)
                            )
                            nil
                        )
                    :else
                        :continue
                )
                (recur node (:predecessor node))
            )
        )
        nil
    )

    ;;;
     ; Tries to connect code that initializes a variable directly with the successors of an if
     ; construct that switches on the variable. For example, the pseudo code below:
     ;
     ; contains(list, e, yes, no) {
     ;     if (list == null || e == null) {
     ;         condition = false;
     ;     } else {
     ;         condition = false;
     ;         for (i in list) {
     ;             if (i.equals(e)) {
     ;                 condition = true;
     ;                 break;
     ;             }
     ;         }
     ;     }
     ;     if (condition) {
     ;         return yes;
     ;     } else {
     ;         return no;
     ;     }
     ; }
     ;
     ; will be transformed into:
     ;
     ; contains(list, e, yes, no) {
     ;     if (list == null || e == null) {
     ;         return no;
     ;     } else {
     ;         condition = false;
     ;         for (i in list) {
     ;             if (i.equals(e)) {
     ;                 return yes;
     ;             }
     ;         }
     ;         return no;
     ;     }
     ; }
     ;
     ; @return true if a transformation was made, false otherwise
     ;;
    (defn- #_"boolean" IfNode''removeIntermediateMaterialization-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (satisfies? AbstractMergeNode (:predecessor this)) (not (satisfies? LoopBeginNode (:predecessor this))) (satisfies? CompareNode (:logic this))
            (let [
                #_"CompareNode" compare (:logic this)
            ]
                ;; consider merges only with a single usage that is both a phi and an operand of the comparison
                (and (Node''hasExactlyOneUsage-1 compare)
                    (let [
                        #_"AbstractMergeNode" merge (:predecessor this)
                        #_"Node*" mergeUsages (:nodeUsages merge)
                    ]
                        (and (= (count mergeUsages) 1)
                            (let [
                                #_"Node" singleUsage (first mergeUsages)
                            ]
                                ;; ensure phi is used by at most the comparison and the merge's frame state (if any)
                                (and (satisfies? ValuePhiNode singleUsage) (any = singleUsage (:x compare) (:y compare))
                                    (let [
                                        #_"ValuePhiNode" phi singleUsage
                                        #_"Node*" phiUsages (:nodeUsages phi)
                                    ]
                                        (and
                                            (<= (count phiUsages) 2)
                                            (loop-when [#_"ISeq" s (seq phiUsages)] (some? s) => true
                                                (and (any = (first s) compare (:stateAfter merge))
                                                    (recur (next s))
                                                )
                                            )
                                            (let [
                                                #_"EndNode*" mergePredecessors (ยง snap (Node'''cfgPredecessors-1 merge))
                                                #_"Constant[]" xs (IfNode'constantValues-3 (:x compare), merge, false)
                                                #_"Constant[]" ys (IfNode'constantValues-3 (:y compare), merge, false)
                                            ]
                                                (and (some? xs) (some? ys)
                                                    ;; Sanity check that both ends are not followed by a merge without frame state.
                                                    (or (IfNode'checkFrameState-1 (:trueSuccessor this)) (IfNode'checkFrameState-1 (:falseSuccessor this)))
                                                    (let [
                                                        #_"List<EndNode>" falseEnds (ArrayList.)
                                                        #_"List<EndNode>" trueEnds (ArrayList.)
                                                        #_"EconomicMap<AbstractEndNode, ValueNode>" phiValues (EconomicMap/create)
                                                        #_"AbstractBeginNode" oldFalseSuccessor (:falseSuccessor this)
                                                        #_"AbstractBeginNode" oldTrueSuccessor (:trueSuccessor this)
                                                        _ (ยง ass! this (IfNode''setFalseSuccessor-2 this, nil))
                                                        _ (ยง ass! this (IfNode''setTrueSuccessor-2 this, nil))
                                                        #_"Iterator<EndNode>" ends (#_"List" .iterator mergePredecessors)
                                                    ]
                                                        (dotimes [#_"int" i (count xs)]
                                                            (let [
                                                                #_"EndNode" end (#_"Iterator" .next ends)
                                                            ]
                                                                (#_"EconomicMap" .put phiValues, end, (PhiNode''valueAt-2n phi, end))
                                                                (if (Condition''foldCondition-3c (:condition compare), (nth xs i), (nth ys i))
                                                                    (#_"List" .add trueEnds, end)
                                                                    (#_"List" .add falseEnds, end)
                                                                )
                                                            )
                                                        )

                                                        (IfNode''connectEnds-6 this, falseEnds, phiValues, oldFalseSuccessor, merge, tool)
                                                        (IfNode''connectEnds-6 this, trueEnds, phiValues, oldTrueSuccessor, merge, tool)

                                                        (when (= (:trueSuccessorProbability this) 0.0)
                                                            (doseq [#_"AbstractEndNode" endNode trueEnds]
                                                                (IfNode'propagateZeroProbability-1 endNode)
                                                            )
                                                        )

                                                        (when (= (:trueSuccessorProbability this) 1.0)
                                                            (doseq [#_"AbstractEndNode" endNode falseEnds]
                                                                (IfNode'propagateZeroProbability-1 endNode)
                                                            )
                                                        )

                                                        ;; Remove obsolete ends only after processing all ends, otherwise oldTrueSuccessor or
                                                        ;; oldFalseSuccessor might have been removed if it is a LoopExitNode.
                                                        (when (empty? falseEnds)
                                                            (GraphUtil'killCFG-1 oldFalseSuccessor)
                                                        )
                                                        (when (empty? trueEnds)
                                                            (GraphUtil'killCFG-1 oldTrueSuccessor)
                                                        )
                                                        (GraphUtil'killCFG-1 merge)

                                                        true
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Return true if the passed in {@code logic} uses {@code phi} and the condition is only used once.
     ; Since the phi will go dead, the logic using it will also have to be dead after the optimization.
     ;;
    (defn- #_"boolean" IfNode'conditionUses-2 [#_"LogicNode" logic, #_"PhiNode" phi]
        (and (Node''hasExactlyOneUsage-1 logic)
            (condp satisfies? logic
                ShortCircuitOrNode
                    (and (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph logic)))
                        ;; It can be unsafe to simplify a ShortCircuitOr before deopts are fixed because
                        ;; conversion to guards assumes that all the required conditions are being tested.
                        ;; Simplifying the condition based on context before this happens may lose a condition.
                        (or (IfNode'conditionUses-2 (:x logic), phi) (IfNode'conditionUses-2 (:y logic), phi))
                    )
                Unary  (= (Unary'''getValue-1 logic) phi)
                Binary (or (= (:x logic) phi) (= (:y logic) phi))
                       false
            )
        )
    )

    ;;;
     ; Canonicalize {@code logic} using {@code value} in place of {@code phi}.
     ;;
    (defn- #_"LogicNode" IfNode'computeCondition-4 [#_"SimplifierTool" tool, #_"LogicNode" logic, #_"PhiNode" phi, #_"Node" value]
        (condp satisfies? logic
            ShortCircuitOrNode
                (when (and (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph logic))) (not (:isAfterExpandLogic (:graph logic))))
                    (let [
                        #_"LogicNode" resultX (IfNode'computeCondition-4 tool, (:x logic), phi, value)
                        #_"LogicNode" resultY (IfNode'computeCondition-4 tool, (:y logic), phi, value)
                    ]
                        (when-not (and (= resultX (:x logic)) (= resultY (:y logic)))
                            (let [
                                #_"LogicNode" canon (Binary'''canonical-4 logic, tool, resultX, resultY)
                            ]
                                (if-not (= canon logic)
                                    (ยง return canon)
                                    ;; Create a new node to carry the optimized inputs.
                                    (ยง return (Canonicalizable'''canonical-2 (ShortCircuitOrNode'new-5 resultX, (:xNegated logic), resultY, (:yNegated logic), (:shortCircuitProbability logic)), tool))
                                )
                            )
                        )
                        (ยง return logic)
                    )
                )
            Binary
                (cond
                    (= (:x logic) phi)
                        (ยง return (Binary'''canonical-4 logic, tool, value, (:y logic)))
                    (= (:y logic) phi)
                        (ยง return (Binary'''canonical-4 logic, tool, (:x logic), value))
                )
            Unary
                (when (= (Unary'''getValue-1 logic) phi)
                    (ยง return (Unary'''canonical-3 logic, tool, value))
                )
            nil
        )
        (if (satisfies? Canonicalizable logic) (Canonicalizable'''canonical-2 logic, tool) logic)
    )

    (defn- #_"MergeNode" IfNode''insertMerge-2 [#_"IfNode" this, #_"AbstractBeginNode" begin]
        (let [
            #_"MergeNode" merge (Graph''add-2 (:graph this), (MergeNode'new-0))
            _
                (when (seq (AbstractBeginNode'''anchored-1 begin))
                    (Node''replaceAtUsages-3 begin, InputType'Guard, merge)
                    (Node''replaceAtUsages-3 begin, InputType'Anchor, merge)
                )
            #_"AbstractBeginNode" theBegin
                (when (satisfies? LoopExitNode begin) => begin
                    ;; Insert an extra begin to make it easier.
                    (let [
                        theBegin (Graph''add-2 (:graph this), (BeginNode'new-0))
                    ]
                        (Node''replaceAtPredecessor-2 begin, theBegin)
                        (FixedWithNextNode''setNext-2 theBegin, begin)
                    )
                )
            #_"FixedNode" _next (:next theBegin)
        ]
            (Node''replaceAtPredecessor-2 _next, merge)
            (ยง ass! theBegin (FixedWithNextNode''setNext-2 theBegin, (Graph''add-2 (:graph this), (EndNode'new-0))))
            (AbstractMergeNode''addForwardEnd-2 merge, (:next theBegin))
            (FixedWithNextNode''setNext-2 merge, _next)
        )
    )

    (defn- #_"void" IfNode'transferProxies-2 [#_"AbstractBeginNode" successor, #_"MergeNode" falseMerge]
        (when (and (satisfies? LoopExitNode successor) (some? falseMerge))
            (doseq [#_"ProxyNode" proxy (ยง snap (LoopExitNode''proxies-1 successor))]
                (Node''replaceFirstInput-3 proxy, successor, falseMerge)
            )
        )
        nil
    )

    (defn- #_"void" IfNode''cleanupMerge-2 [#_"IfNode" this, #_"MergeNode" merge]
        (when (and (some? merge) (Node''isAlive-1 merge))
            (case (AbstractMergeNode''forwardEndCount-1 merge)
                0 (GraphUtil'killCFG-1 merge)
                1 (Graph''reduceTrivialMerge-2 (:graph this), merge)
                nil
            )
        )
        nil
    )

    ;;;
     ; Take an if that is immediately dominated by a merge with a single phi and split off any paths
     ; where the test would be statically decidable creating a new merge below the approriate side
     ; of the IfNode. Any undecidable tests will continue to use the original IfNode.
     ;;
    (defn- #_"boolean" IfNode''splitIfAtPhi-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        ;; disabled until we make sure we have no FrameState-less merges at this stage
        (and (not (GuardsStage'areFrameStatesAtSideEffects-1 (:guardsStage (:graph this))))
            (satisfies? MergeNode (:predecessor this))
            (let [
                #_"MergeNode" merge (:predecessor this)
            ]
                (and (not (= (AbstractMergeNode''forwardEndCount-1 merge) 1)) ;; don't bother
                    (Node''hasExactlyOneUsage-1 merge) (= (count (AbstractMergeNode''phis-1 merge)) 1)
                    (nil? (:stateAfter merge)) ;; we'll get the chance to simplify this after frame state assignment
                    (let [
                        #_"PhiNode" phi (first (AbstractMergeNode''phis-1 merge))
                    ]
                        (and
                            ;; for simplicity, the code below assumes that phi goes dead at the end, so skip this case
                            (Node''hasExactlyOneUsage-1 phi)
                            ;; check that the condition uses the phi and that there is only one user of the condition expression
                            (IfNode'conditionUses-2 (:logic this), phi)
                            ;; We could additionally filter for the case that at least some of the Phi inputs or one of
                            ;; the condition inputs are constants but there are cases where a non-constant is simplifiable,
                            ;; usually where the stamp allows the question to be answered.

                            ;; each successor of the if gets a new merge if needed
                            (let [
                                [#_"MergeNode" trueMerge #_"MergeNode" falseMerge]
                                    (loop-when [trueMerge nil falseMerge nil #_"ISeq" s (seq (ยง snap (:ends merge)))] (some? s) => [trueMerge falseMerge]
                                        (let [
                                            #_"EndNode" end (first s)
                                            #_"Node" value (PhiNode''valueAt-2n phi, end)
                                            #_"LogicNode" result (IfNode'computeCondition-4 tool, (:logic this), phi, value)
                                            [trueMerge falseMerge]
                                                (cond
                                                    (satisfies? LogicConstantNode result)
                                                        (do
                                                            (AbstractMergeNode''removeEnd-2 merge, end)
                                                            (if (:value result)
                                                                (let [
                                                                    trueMerge (or trueMerge (IfNode''insertMerge-2 this, (:trueSuccessor this)))
                                                                ]
                                                                    (AbstractMergeNode''addForwardEnd-2 trueMerge, end)
                                                                    [trueMerge falseMerge]
                                                                )
                                                                (let [
                                                                    falseMerge (or falseMerge (IfNode''insertMerge-2 this, (:falseSuccessor this)))
                                                                ]
                                                                    (AbstractMergeNode''addForwardEnd-2 falseMerge, end)
                                                                    [trueMerge falseMerge]
                                                                )
                                                            )
                                                        )
                                                    (= result (:logic this))
                                                        [trueMerge falseMerge]
                                                    :else
                                                        ;; build a new IfNode using the new condition
                                                        (let [
                                                            #_"BeginNode" trueBegin (Graph''add-2 (:graph this), (BeginNode'new-0))
                                                            #_"BeginNode" falseBegin (Graph''add-2 (:graph this), (BeginNode'new-0))
                                                            result (if (some? (:graph result)) result (Graph''addOrUniqueWithInputs-2 (:graph this), result))
                                                            #_"IfNode" newIfNode (Graph''add-2 (:graph this), (IfNode'new-4b result, trueBegin, falseBegin, (:trueSuccessorProbability this)))
                                                            _ (AbstractMergeNode''removeEnd-2 merge, end)
                                                            _ (ยง ass! (:predecessor end) (FixedWithNextNode''setNext-2 (:predecessor end), newIfNode))
                                                            trueMerge (or trueMerge (IfNode''insertMerge-2 this, (:trueSuccessor this)))
                                                            _ (ยง ass! trueBegin (FixedWithNextNode''setNext-2 trueBegin, (Graph''add-2 (:graph this), (EndNode'new-0))))
                                                            _ (AbstractMergeNode''addForwardEnd-2 trueMerge, (:next trueBegin))
                                                            falseMerge (or falseMerge (IfNode''insertMerge-2 this, (:falseSuccessor this)))
                                                            _ (ยง ass! falseBegin (FixedWithNextNode''setNext-2 falseBegin, (Graph''add-2 (:graph this), (EndNode'new-0))))
                                                            _ (AbstractMergeNode''addForwardEnd-2 falseMerge, (:next falseBegin))
                                                            _ (Node''safeDelete-1 end)
                                                        ]
                                                            [trueMerge falseMerge]
                                                        )
                                                )
                                        ]
                                            (recur trueMerge falseMerge (next s))
                                        )
                                    )
                            ]
                                (IfNode'transferProxies-2 (:trueSuccessor this), trueMerge)
                                (IfNode'transferProxies-2 (:falseSuccessor this), falseMerge)

                                (IfNode''cleanupMerge-2 this, merge)
                                (IfNode''cleanupMerge-2 this, trueMerge)
                                (IfNode''cleanupMerge-2 this, falseMerge)

                                true
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Try to optimize this as if it were a ConditionalNode.
     ;;
    (defn- #_"boolean" IfNode''conditionalNodeOptimization-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (satisfies? AbstractEndNode (:next (:trueSuccessor this)))
             (satisfies? AbstractEndNode (:next (:falseSuccessor this)))
            (let [
                #_"AbstractEndNode" trueEnd (:next (:trueSuccessor this))
                #_"AbstractEndNode" falseEnd (:next (:falseSuccessor this))
            ]
                (and (= (AbstractEndNode'''merge-1 trueEnd) (AbstractEndNode'''merge-1 falseEnd)) (satisfies? MergeNode (AbstractEndNode'''merge-1 trueEnd))
                    (let [
                        #_"MergeNode" merge (AbstractEndNode'''merge-1 trueEnd)
                    ]
                        (and (Node''hasExactlyOneUsage-1 merge)
                             (= (count (AbstractMergeNode''phis-1 merge)) 1)
                             (empty? (AbstractBeginNode'''anchored-1 (:trueSuccessor this)))
                             (empty? (AbstractBeginNode'''anchored-1 (:falseSuccessor this)))
                            (let [
                                #_"PhiNode" phi (first (AbstractMergeNode''phis-1 merge))
                                #_"ValueNode" result (ConditionalNode'canonicalizeConditional-4 (:logic this), (PhiNode''valueAt-2n phi, trueEnd), (PhiNode''valueAt-2n phi, falseEnd), (:stamp phi))
                            ]
                                (and (some? result)
                                    ;; canonicalizeConditional returns possibly new nodes so add them to the graph
                                    (let [
                                        result
                                            (when (nil? (:graph result)) => result
                                                (Graph''addOrUniqueWithInputs-2 (:graph this), result)
                                            )
                                        result (IfNode''proxyReplacement-2 this, result)
                                    ]
                                        ;; This optimization can be performed even if multiple values merge at this phi
                                        ;; since the two inputs get simplified into one.
                                        (PhiNode''setValueAt-3n phi, trueEnd, result)
                                        (IfNode''removeThroughFalseBranch-3 this, tool, merge)
                                        true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"boolean" IfNode'valuesDistinct-3 [#_"SimplifierTool" tool, #_"ValueNode" a, #_"ValueNode" b]
        (when (and (satisfies? ConstantNode a) (satisfies? ConstantNode b))
            (let [
                #_"Boolean" equal (#_"ConstantReflectionProvider" .constantEquals HotSpot'constantReflection, (:value a), (:value b))
            ]
                (when (some? equal)
                    (ยง return (not (#_"Boolean" .booleanValue equal)))
                )
            )
        )

        (Stamp'''alwaysDistinct-2 (:stamp a), (:stamp b))
    )

    (defn- #_"boolean" IfNode'prepareForSwap-3 [#_"SimplifierTool" tool, #_"LogicNode" a, #_"LogicNode" b]
        (condp satisfies? a
            InstanceOfNode
                (condp satisfies? b
                    IsNullNode
                        (= (Unary'''getValue-1 b) (Unary'''getValue-1 a))
                    InstanceOfNode
                        ;; Two instanceof on the same value with mutually exclusive types.
                        (and (= (Unary'''getValue-1 a) (Unary'''getValue-1 b))
                             (not (#_"ResolvedJavaType" .isInterface (:type (InstanceOfNode''type-1 a))))
                             (not (#_"ResolvedJavaType" .isInterface (:type (InstanceOfNode''type-1 b))))
                             (not (#_"ResolvedJavaType" .isAssignableFrom (:type (InstanceOfNode''type-1 a)), (:type (InstanceOfNode''type-1 b))))
                             (not (#_"ResolvedJavaType" .isAssignableFrom (:type (InstanceOfNode''type-1 b)), (:type (InstanceOfNode''type-1 a))))
                        )
                    false
                )
            CompareNode
                (let [
                    #_"Condition" conditionA (:canonical (:condition a))
                ]
                    (and (satisfies? CompareNode b) (not= a b)
                        (let [
                            #_"Condition" conditionB (:canonical (:condition b))
                            #_"Condition" comparableCondition
                                (cond
                                    (and (= (:x b) (:x a)) (= (:y b) (:y a)))                      conditionB
                                    (and (= (:x b) (:y a)) (= (:y b) (:x a))) (Condition''mirror-1 conditionB)
                                )
                        ]
                            (if (nil? comparableCondition)
                                (and (= conditionA conditionB Condition'EQ)
                                    (or (and (= (:x a) (:x b)) (IfNode'valuesDistinct-3 tool, (:y a), (:y b)))
                                        (and (= (:x a) (:y b)) (IfNode'valuesDistinct-3 tool, (:y a), (:x b)))
                                        (and (= (:y a) (:x b)) (IfNode'valuesDistinct-3 tool, (:x a), (:y b)))
                                        (and (= (:y a) (:y b)) (IfNode'valuesDistinct-3 tool, (:x a), (:x b)))
                                    )
                                )
                                ;; The two conditions are disjoint => can reorder.
                                (nil? (Condition''join-2 conditionA, comparableCondition))
                            )
                        )
                    )
                )
            false
        )
    )

    (defn- #_"boolean" IfNode''isUnboxedFrom-3 [#_"IfNode" this, #_"ValueNode" x, #_"ValueNode" src]
        (or (= x src)
            (condp satisfies? x
                UnboxNode (IfNode''isUnboxedFrom-3 this, (Unary'''getValue-1 x), src)
                PiNode    (IfNode''isUnboxedFrom-3 this, (Proxy'''getOriginalNode-1 x), src)
                LoadFieldNode
                    (let [
                        #_"ValueNode" value (Unary'''getValue-1 x)
                    ]
                        (and (= (Stamp'''javaType-1 (:stamp value)) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Integer))
                            (IfNode''isUnboxedFrom-3 this, value, src)
                        )
                    )
                false
            )
        )
    )

    ;;;
     ; Attempts to replace the following pattern:
     ;
     ; Integer x = ...;
     ; Integer y = ...;
     ; if ((x == y) || x.equals(y)) { ... }
     ;
     ; with:
     ;
     ; Integer x = ...;
     ; Integer y = ...;
     ; if (x.equals(y)) { ... }
     ;
     ; whenever the probability that the reference check will pass is relatively small.
     ;
     ; See GR-1315 for more information.
     ;;
    (defn- #_"boolean" IfNode''tryEliminateBoxedReferenceEquals-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (satisfies? ObjectEqualsNode (:logic this))
            (let [
                #_"ValueNode" x (:x (:logic this))
                #_"ValueNode" y (:y (:logic this))
                #_"ResolvedJavaType" integerType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Integer)
            ]
                (and
                    ;; At least one argument for reference equal must be a boxed primitive.
                    (or (= (Stamp'''javaType-1 (:stamp x)) integerType) (= (Stamp'''javaType-1 (:stamp y)) integerType))
                    ;; The reference equality check is usually more efficient compared to a boxing check.
                    ;; The success of the reference equals must therefore be relatively rare, otherwise
                    ;; it makes no sense to eliminate it.
                    (<= (:trueSuccessorProbability this) 0.4)
                    ;; True branch must be empty.
                    (and (or (satisfies? BeginNode (:trueSuccessor this)) (satisfies? LoopExitNode (:trueSuccessor this)))
                        (satisfies? EndNode (:next (:trueSuccessor this))) ;; Empty true branch.
                    )
                    ;; False branch must only check the unboxed values.
                    (let [
                        [#_"UnboxNode" unbox #_"FixedGuardNode" unboxCheck]
                            (loop-when [unbox nil unboxCheck nil #_"ISeq" s (seq (AbstractBeginNode''getBlockNodes-1 (:falseSuccessor this)))] (some? s) => [unbox unboxCheck]
                                (let [
                                    #_"FixedNode" node (first s)
                                ]
                                    (when (or (satisfies? BeginNode node) (satisfies? UnboxNode node) (satisfies? FixedGuardNode node) (satisfies? EndNode node) (satisfies? LoadFieldNode node) (satisfies? LoopExitNode node))
                                        (let [
                                            unbox
                                                (when (satisfies? UnboxNode node) => unbox
                                                    (when (nil? unbox) => (ยง return nil)
                                                        node
                                                    )
                                                )
                                        ]
                                            (let [
                                                unboxCheck
                                                    (when (and (satisfies? FixedGuardNode node) (satisfies? IntegerEqualsNode (DeoptimizingGuard'''getCondition-1 node))) => unboxCheck
                                                        (let [
                                                            #_"IntegerEqualsNode" equals (DeoptimizingGuard'''getCondition-1 node)
                                                        ]
                                                            (when (or (and (IfNode''isUnboxedFrom-3 this, (:x equals), x) (IfNode''isUnboxedFrom-3 this, (:y equals), y)) (and (IfNode''isUnboxedFrom-3 this, (:x equals), y) (IfNode''isUnboxedFrom-3 this, (:y equals), x))) => unboxCheck
                                                                node
                                                            )
                                                        )
                                                    )
                                            ]
                                                (recur unbox unboxCheck (next s))
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        (and (some? unbox) (some? unboxCheck)
                            (do
                                ;; Falsify the reference check.
                                (ยง ass! this (IfNode''setCondition-2 this, (Graph''addOrUniqueWithInputs-2 (:graph this), (LogicConstantNode'contradiction-0))))
                                true
                            )
                        )
                    )
                )
            )
        )
    )

    (defm IfNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"IfNode" this, #_"SimplifierTool" tool]
            (cond
                (satisfies? DeoptimizeNode (:next (:trueSuccessor this)))
                    (when-not (= (:trueSuccessorProbability this) 0)
                        (ยง ass! this (assoc this :trueSuccessorProbability 0))
                    )
                (satisfies? DeoptimizeNode (:next (:falseSuccessor this)))
                    (when-not (= (:trueSuccessorProbability this) 1)
                        (ยง ass! this (assoc this :trueSuccessorProbability 1))
                    )
            )
            (when (satisfies? LogicNegationNode (:logic this))
                (ยง ass! this (IfNode''eliminateNegation-1 this))
            )
            (or
                (when (satisfies? LogicConstantNode (:logic this))
                    (if (:value (:logic this))
                        (do
                            (SimplifierTool'''deleteBranch-2 tool, (:falseSuccessor this))
                            (SimplifierTool'''addToWorkList-2n tool, (:trueSuccessor this))
                            (Graph''removeSplit-3 (:graph this), this, (:trueSuccessor this))
                        )
                        (do
                            (SimplifierTool'''deleteBranch-2 tool, (:trueSuccessor this))
                            (SimplifierTool'''addToWorkList-2n tool, (:falseSuccessor this))
                            (Graph''removeSplit-3 (:graph this), this, (:falseSuccessor this))
                        )
                    )
                    :done
                )
                (when (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 (:trueSuccessor this)) (Node''hasNoUsages-1 (:falseSuccessor this)))
                    (IfNode''pushNodesThroughIf-2 this, tool)
                    (when (or (IfNode''checkForUnsignedCompare-2 this, tool) (IfNode''removeOrMaterializeIf-2 this, tool))
                        :done
                    )
                )
                (when (IfNode''removeIntermediateMaterialization-2 this, tool)
                    :done
                )
                (when (IfNode''splitIfAtPhi-2 this, tool)
                    :done
                )
                (when (IfNode''conditionalNodeOptimization-2 this, tool)
                    :done
                )
                (when (and (Node''hasNoUsages-1 (:falseSuccessor this)) (not (satisfies? LoopExitNode (:falseSuccessor this))) (satisfies? IfNode (:next (:falseSuccessor this))))
                    (let [
                        #_"AbstractBeginNode" intermediateBegin (:falseSuccessor this)
                        #_"IfNode" nextIf (:next intermediateBegin)
                        #_"double" probabilityB (* (- 1.0 (:trueSuccessorProbability this)) (:trueSuccessorProbability nextIf))
                    ]
                        ;; Reordering of those two if statements is beneficial from the point of view of their probabilities.
                        ;; Reordering is allowed from (if1 => begin => if2) to (if2 => begin => if1).
                        (when (and (< (:trueSuccessorProbability this) probabilityB) (IfNode'prepareForSwap-3 tool, (:logic this), (:logic nextIf)))
                            (let [
                                #_"AbstractBeginNode" bothFalseBegin (:falseSuccessor nextIf)
                            ]
                                (ยง ass! nextIf (IfNode''setFalseSuccessor-2 nextIf, nil))
                                (ยง ass! intermediateBegin (FixedWithNextNode''setNext-2 intermediateBegin, nil))
                                (ยง ass! this (IfNode''setFalseSuccessor-2 this, nil))

                                (Node''replaceAtPredecessor-2 this, nextIf)
                                (ยง ass! nextIf (IfNode''setFalseSuccessor-2 nextIf, intermediateBegin))
                                (ยง ass! intermediateBegin (FixedWithNextNode''setNext-2 intermediateBegin, this))
                                (ยง ass! this (IfNode''setFalseSuccessor-2 this, bothFalseBegin))

                                (ยง ass! nextIf (IfNode''setTrueSuccessorProbability-2 nextIf, probabilityB))
                                (ยง ass! this (IfNode''setTrueSuccessorProbability-2 this, (if (= probabilityB 1.0) 0.0 (min 1.0 (/ (:trueSuccessorProbability this) (- 1.0 probabilityB))))))
                                :done
                            )
                        )
                    )
                )
                (when (IfNode''tryEliminateBoxedReferenceEquals-2 this, tool)
                    :done
                )
            )
            nil
        )
    )

    (defm IfNode ControlSplitNode
        (#_"AbstractBeginNode" ControlSplitNode'''getPrimarySuccessor-1 [#_"IfNode" this]
            nil
        )
    )

    (defm IfNode ControlSplitNode
        (#_"boolean" ControlSplitNode'''setProbability-3 [#_"IfNode" this, #_"AbstractBeginNode" successor, #_"double" value]
            (condp = successor
                (:trueSuccessor this)
                (do
                    (ยง ass! this (IfNode''setTrueSuccessorProbability-2 this, value))
                    true
                )
                (:falseSuccessor this)
                (do
                    (ยง ass! this (IfNode''setTrueSuccessorProbability-2 this, (- 1.0 value)))
                    true
                )
                false
            )
        )

        (#_"int" ControlSplitNode'''getSuccessorCount-1 [#_"IfNode" this]
            2
        )
    )
)

(class-ns IntegerExactArithmeticSplitNode [ControlSplitNode, FixedNode, ValueNode, Node, Simplifiable, LIRLowerable]
    (defn #_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" overflowSuccessor]
        (merge (IntegerExactArithmeticSplitNode'class.) (ControlSplitNode'new-1 stamp)
            (hash-map
                ; @Successor
                #_"AbstractBeginNode" :next _next
                ; @Successor
                #_"AbstractBeginNode" :overflowSuccessor overflowSuccessor
                ; @Input
                #_"ValueNode" :x x
                ; @Input
                #_"ValueNode" :y y
            )
        )
    )

    (defm IntegerExactArithmeticSplitNode ControlSplitNode
        (#_"AbstractBeginNode" ControlSplitNode'''getPrimarySuccessor-1 [#_"IntegerExactArithmeticSplitNode" this]
            (:next this)
        )

        (#_"double" ControlSplitNode'''probability-2 [#_"IntegerExactArithmeticSplitNode" this, #_"AbstractBeginNode" successor]
            (if (= successor (:next this)) 1 0)
        )

        (#_"boolean" ControlSplitNode'''setProbability-3 [#_"IntegerExactArithmeticSplitNode" this, #_"AbstractBeginNode" successor, #_"double" value]
            ;; Successor probabilities for arithmetic split nodes are fixed.
            false
        )
    )

    (defn #_"AbstractBeginNode" IntegerExactArithmeticSplitNode''getNext-1 [#_"IntegerExactArithmeticSplitNode" this]
        (:next this)
    )

    (defm IntegerExactArithmeticSplitNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"IntegerExactArithmeticSplitNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (IntegerExactArithmeticSplitNode'''generateArithmetic-2 this, builder))
            (LIRBuilder''emitOverflowCheckBranch-5 builder, (:overflowSuccessor this), (IntegerExactArithmeticSplitNode''getNext-1 this), (:stamp this), (ControlSplitNode'''probability-2 this, (:overflowSuccessor this)))
            nil
        )
    )

    (defn #_"void" IntegerExactArithmeticSplitNode'lower-2 [#_"LoweringTool" lowerer, #_"IntegerExactArithmeticNode" node]
        (when (= (:guardsStage (:graph node)) GuardsStage'FIXED_DEOPTS)
            (let [
                #_"FixedWithNextNode" previous (:lastFixedNode lowerer)
                #_"FixedNode" _next (:next previous)
            ]
                (ยง ass! previous (FixedWithNextNode''setNext-2 previous, nil))
                (let [
                    #_"DeoptimizeNode" deopt (Graph''add-2 (:graph node), (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/ArithmeticException))
                    #_"AbstractBeginNode" normalBegin (Graph''add-2 (:graph node), (BeginNode'new-0))
                ]
                    (ยง ass! normalBegin (FixedWithNextNode''setNext-2 normalBegin, _next))
                    (let [
                        #_"IntegerExactArithmeticSplitNode" split (IntegerExactArithmeticNode'''createSplit-3 node, normalBegin, (BeginNode'begin-1 deopt))
                    ]
                        (ยง ass! previous (FixedWithNextNode''setNext-2 previous, split))
                        (ยง ass! node (Node''replaceAndDelete-2 node, split))
                    )
                )
            )
        )
        nil
    )

    (defm IntegerExactArithmeticSplitNode ControlSplitNode
        (#_"int" ControlSplitNode'''getSuccessorCount-1 [#_"IntegerExactArithmeticSplitNode" this]
            2
        )
    )
)

(class-ns IntegerAddExactSplitNode [IntegerExactArithmeticSplitNode, ControlSplitNode, FixedNode, ValueNode, Node, Simplifiable, LIRLowerable]
    (defn #_"IntegerAddExactSplitNode" IntegerAddExactSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" overflowSuccessor]
        (merge (IntegerAddExactSplitNode'class.) (IntegerExactArithmeticSplitNode'new-5 stamp, x, y, _next, overflowSuccessor))
    )

    (defm IntegerAddExactSplitNode IntegerExactArithmeticSplitNode
        (#_"Value" IntegerExactArithmeticSplitNode'''generateArithmetic-2 [#_"IntegerAddExactSplitNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitAdd-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), true)
        )
    )

    (defm IntegerAddExactSplitNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"IntegerAddExactSplitNode" this, #_"SimplifierTool" tool]
            (when-not (IntegerStamp'addCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))
                (SimplifierTool'''deleteBranch-2 tool, (:overflowSuccessor this))
                (SimplifierTool'''addToWorkList-2n tool, (:next this))
                (let [
                    #_"AddNode" replacement (Graph''add-2 (:graph this), (AddNode'new-2 (:x this), (:y this)))
                ]
                    (Graph''replaceSplitWithFloating-4 (:graph this), this, replacement, (:next this))
                    (SimplifierTool'''addToWorkList-2n tool, replacement)
                )
            )
            nil
        )
    )
)

(class-ns IntegerMulExactSplitNode [IntegerExactArithmeticSplitNode, ControlSplitNode, FixedNode, ValueNode, Node, Simplifiable, LIRLowerable]
    (defn #_"IntegerMulExactSplitNode" IntegerMulExactSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" overflowSuccessor]
        (merge (IntegerMulExactSplitNode'class.) (IntegerExactArithmeticSplitNode'new-5 stamp, x, y, _next, overflowSuccessor))
    )

    (defm IntegerMulExactSplitNode IntegerExactArithmeticSplitNode
        (#_"Value" IntegerExactArithmeticSplitNode'''generateArithmetic-2 [#_"IntegerMulExactSplitNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitMul-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), true)
        )
    )

    (defm IntegerMulExactSplitNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"IntegerMulExactSplitNode" this, #_"SimplifierTool" tool]
            (when-not (IntegerStamp'multiplicationCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))
                (SimplifierTool'''deleteBranch-2 tool, (:overflowSuccessor this))
                (SimplifierTool'''addToWorkList-2n tool, (:next this))
                (let [
                    #_"MulNode" replacement (Graph''add-2 (:graph this), (MulNode'new-2 (:x this), (:y this)))
                ]
                    (Graph''replaceSplitWithFloating-4 (:graph this), this, replacement, (:next this))
                    (SimplifierTool'''addToWorkList-2n tool, replacement)
                )
            )
            nil
        )
    )
)

(class-ns IntegerSubExactSplitNode [IntegerExactArithmeticSplitNode, ControlSplitNode, FixedNode, ValueNode, Node, Simplifiable, LIRLowerable]
    (defn #_"IntegerSubExactSplitNode" IntegerSubExactSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" overflowSuccessor]
        (merge (IntegerSubExactSplitNode'class.) (IntegerExactArithmeticSplitNode'new-5 stamp, x, y, _next, overflowSuccessor))
    )

    (defm IntegerSubExactSplitNode IntegerExactArithmeticSplitNode
        (#_"Value" IntegerExactArithmeticSplitNode'''generateArithmetic-2 [#_"IntegerSubExactSplitNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitSub-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), true)
        )
    )

    (defm IntegerSubExactSplitNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"IntegerSubExactSplitNode" this, #_"SimplifierTool" tool]
            (when-not (IntegerStamp'subtractionCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))
                (SimplifierTool'''deleteBranch-2 tool, (:overflowSuccessor this))
                (SimplifierTool'''addToWorkList-2n tool, (:next this))
                (let [
                    #_"SubNode" replacement (Graph''add-2 (:graph this), (SubNode'new-2 (:x this), (:y this)))
                ]
                    (Graph''replaceSplitWithFloating-4 (:graph this), this, replacement, (:next this))
                    (SimplifierTool'''addToWorkList-2n tool, replacement)
                )
            )
            nil
        )
    )
)

(class-ns SwitchNode [ControlSplitNode, FixedNode, ValueNode, Node]
    ;;;
     ; Constructs a new Switch.
     ;
     ; @param value the instruction that provides the value to be switched over
     ; @param successors the list of successors of this switch
     ;;
    (defn #_"SwitchNode" SwitchNode'new-4 [#_"ValueNode" value, #_"AbstractBeginNode*" successors, #_"int[]" keySuccessors, #_"double[]" keyProbabilities]
        (merge (SwitchNode'class.) (ControlSplitNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Successor
                #_"NodeSuccessorList<AbstractBeginNode>" :successors (NodeSuccessorList'new-2s (ร this), successors)
                ; @Input
                #_"ValueNode" :value value
                ;; do not change the contents of these arrays:
                #_"double[]" :keyProbabilities keyProbabilities
                #_"int[]" :keySuccessors keySuccessors
            )
        )
    )

    (defm SwitchNode ControlSplitNode
        (#_"int" ControlSplitNode'''getSuccessorCount-1 [#_"SwitchNode" this]
            (count (:successors this))
        )

        (#_"double" ControlSplitNode'''probability-2 [#_"SwitchNode" this, #_"AbstractBeginNode" successor]
            (loop-when [#_"double" sum 0.0 #_"int" i 0] (< i (count (:keySuccessors this))) => sum
                (let [
                    sum
                        (when (= (nth (:successors this) (nth (:keySuccessors this) i)) successor) => sum
                            (+ sum (nth (:keyProbabilities this) i))
                        )
                ]
                    (recur sum (inc i))
                )
            )
        )

        (#_"boolean" ControlSplitNode'''setProbability-3 [#_"SwitchNode" this, #_"AbstractBeginNode" successor, #_"double" value]
            (let [
                [#_"double" sum #_"double" otherSum]
                    (loop-when [sum 0.0 otherSum 0.0 #_"int" i 0] (< i (count (:keySuccessors this))) => [sum otherSum]
                        (if (= (nth (:successors this) (nth (:keySuccessors this) i)) successor)
                            (recur (+ sum (nth (:keyProbabilities this) i)) otherSum (inc i))
                            (recur sum (+ otherSum (nth (:keyProbabilities this) i)) (inc i))
                        )
                    )
            ]
                (if (or (zero? sum) (zero? otherSum))
                    false ;; cannot correctly adjust probabilities
                    (let [
                        #_"double" delta (- value sum)
                    ]
                        (dotimes [#_"int" i (count (:keySuccessors this))]
                            (if (= (nth (:successors this) (nth (:keySuccessors this) i)) successor)
                                (aswap (:keyProbabilities this) i #(max 0.0 (+ % (/ (* delta %) sum))))
                                (aswap (:keyProbabilities this) i #(max 0.0 (- % (/ (* delta %) otherSum))))
                            )
                        )
                        true
                    )
                )
            )
        )
    )

    (defn #_"boolean" SwitchNode''structureEquals-2 [#_"SwitchNode" this, #_"SwitchNode" switchNode]
        (and (Arrays/equals (:keySuccessors this), (:keySuccessors switchNode)) (SwitchNode'''equalKeys-2 this, switchNode))
    )

    ;;;
     ; Returns the index of the successor belonging to the key at the specified index.
     ;;
    (defn #_"int" SwitchNode''keySuccessorIndex-2 [#_"SwitchNode" this, #_"int" i]
        (nth (:keySuccessors this) i)
    )

    ;;;
     ; Returns the successor for the key at the given index.
     ;;
    (defn #_"AbstractBeginNode" SwitchNode''keySuccessor-2 [#_"SwitchNode" this, #_"int" i]
        (nth (:successors this) (nth (:keySuccessors this) i))
    )

    ;;;
     ; Returns the probability of the key at the given index.
     ;;
    (defn #_"double" SwitchNode''keyProbability-2 [#_"SwitchNode" this, #_"int" i]
        (nth (:keyProbabilities this) i)
    )

    ;;;
     ; Returns the index of the default (fall through) successor of this switch.
     ;;
    (defn #_"int" SwitchNode''defaultSuccessorIndex-1 [#_"SwitchNode" this]
        (nth (:keySuccessors this) (dec (count (:keySuccessors this))))
    )

    (defn #_"void" SwitchNode''setBlockSuccessor-3 [#_"SwitchNode" this, #_"int" i, #_"AbstractBeginNode" s]
        (#_"List" .set (:successors this), i, s)
        nil
    )

    ;;;
     ; Gets the successor corresponding to the default (fall through) case.
     ;
     ; @return the default successor
     ;;
    (defn #_"AbstractBeginNode" SwitchNode''defaultSuccessor-1 [#_"SwitchNode" this]
        (when (= (SwitchNode''defaultSuccessorIndex-1 this) -1)
            (throw! "unexpected")
        )
        (nth (:successors this) (SwitchNode''defaultSuccessorIndex-1 this))
    )

    (defm SwitchNode ControlSplitNode
        (#_"AbstractBeginNode" ControlSplitNode'''getPrimarySuccessor-1 [#_"SwitchNode" this]
            nil
        )
    )

    ;;;
     ; Delete all other successors except for the one reached by {@code survivingEdge}.
     ;
     ; @param survivingEdge index of the edge in the SwitchNode#successors list
     ;;
    (defn #_"void" SwitchNode''killOtherSuccessors-3 [#_"SwitchNode" this, #_"SimplifierTool" tool, #_"int" survivingEdge]
        (doseq [#_"Node" successor (Node''successors-1 this)]
            ;; Deleting a branch change the successors, so reload the surviving successor each time.
            (when-not (= successor (nth (:successors this) survivingEdge))
                (SimplifierTool'''deleteBranch-2 tool, successor)
            )
        )
        (SimplifierTool'''addToWorkList-2n tool, (nth (:successors this) survivingEdge))
        (Graph''removeSplit-3 (:graph this), this, (nth (:successors this) survivingEdge))
        nil
    )
)

;;;
 ; The IntegerSwitchNode represents a switch on integer keys, with a sorted array of key values.
 ; The actual implementation of the switch will be decided by the backend.
 ;;
(class-ns IntegerSwitchNode [SwitchNode, ControlSplitNode, FixedNode, ValueNode, Node, LIRLowerable, Simplifiable]
    (defn #_"IntegerSwitchNode" IntegerSwitchNode'new-5a [#_"ValueNode" value, #_"AbstractBeginNode[]" successors, #_"int[]" keys, #_"double[]" keyProbabilities, #_"int[]" keySuccessors]
        (merge (IntegerSwitchNode'class.) (SwitchNode'new-4 value, successors, keySuccessors, keyProbabilities)
            (hash-map
                #_"int[]" :keys keys
            )
        )
    )

    (defn #_"IntegerSwitchNode" IntegerSwitchNode'new-5i [#_"ValueNode" value, #_"int" successorCount, #_"int[]" keys, #_"double[]" keyProbabilities, #_"int[]" keySuccessors]
        (IntegerSwitchNode'new-5a value, (make-array AbstractBeginNode'iface successorCount), keys, keyProbabilities, keySuccessors)
    )

    (defm IntegerSwitchNode SwitchNode
        (#_"boolean" SwitchNode'''isSorted-1 [#_"IntegerSwitchNode" this]
            true
        )
    )

    ;;;
     ; Gets the key at the specified index.
     ;;
    (defm IntegerSwitchNode SwitchNode
        (#_"JavaConstant" SwitchNode'''keyAt-2 [#_"IntegerSwitchNode" this, #_"int" i]
            (JavaConstant/forInt (nth (:keys this) i))
        )

        (#_"boolean" SwitchNode'''equalKeys-2 [#_"IntegerSwitchNode" this, #_"SwitchNode" switchNode]
            (and (satisfies? IntegerSwitchNode switchNode) (Arrays/equals (:keys this), (:keys switchNode)))
        )
    )

    (defm IntegerSwitchNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"IntegerSwitchNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''emitSwitch-2 builder, this)
            nil
        )
    )

    (defn- #_"int" IntegerSwitchNode''successorIndexAtKey-2 [#_"IntegerSwitchNode" this, #_"int" key]
        (let [
            #_"int" n (count (:keys this))
        ]
            (loop-when [#_"int" i 0] (< i n) => (SwitchNode''keySuccessorIndex-2 this, n)
                (if (= (nth (:keys this) i) key)
                    (SwitchNode''keySuccessorIndex-2 this, i)
                    (recur (inc i))
                )
            )
        )
    )

    (defn- #_"int" IntegerSwitchNode'addNewSuccessor-2 [#_"AbstractBeginNode" newSuccessor, #_"ArrayList<AbstractBeginNode>" newSuccessors]
        (let [
            #_"int" index (#_"ArrayList" .indexOf newSuccessors, newSuccessor)
        ]
            (when (= index -1) => index
                (let [
                    index (count newSuccessors)
                ]
                    (#_"ArrayList" .add newSuccessors, newSuccessor)
                    index
                )
            )
        )
    )

    (defn- #_"void" IntegerSwitchNode''doReplace-6 [#_"IntegerSwitchNode" this, #_"ValueNode" newValue, #_"List<KeyData>" newKeyDatas, #_"ArrayList<AbstractBeginNode>" newSuccessors, #_"int" newDefaultSuccessor, #_"double" newDefaultProbability]
        ;; Sort the new keys (invariant of the IntegerSwitchNode).
        (ยง ass! newKeyDatas (sort-by :key newKeyDatas))

        ;; Create the final data arrays.
        (let [
            #_"int" newKeyCount (count newKeyDatas)
            #_"int[]" newKeys (int-array newKeyCount)
            #_"double[]" newKeyProbabilities (double-array (inc newKeyCount))
            #_"int[]" newKeySuccessors (int-array (inc newKeyCount))
        ]
            (dotimes [#_"int" i newKeyCount]
                (let [
                    #_"KeyData" keyData (nth newKeyDatas i)
                ]
                    (aset newKeys i (:key keyData))
                    (aset newKeyProbabilities i (:keyProbability keyData))
                    (aset newKeySuccessors i (:keySuccessor keyData))
                )
            )

            (aset newKeySuccessors newKeyCount newDefaultSuccessor)
            (aset newKeyProbabilities newKeyCount newDefaultProbability)

            ;; Normalize new probabilities so that they sum up to 1.
            (let [
                #_"double" totalProbability
                    (loop-when-recur [totalProbability 0.0 #_"ISeq" s (seq newKeyProbabilities)]
                                     (some? s)
                                     [(+ totalProbability (first s)) (next s)]
                                  => totalProbability
                    )
            ]
                (if (pos? totalProbability)
                    (dotimes [#_"int" i (count newKeyProbabilities)]
                        (aswap newKeyProbabilities i / totalProbability)
                    )
                    (dotimes [#_"int" i (count newKeyProbabilities)]
                        (aset newKeyProbabilities i (/ 1.0 (count newKeyProbabilities)))
                    )
                )

                ;; Collect dead successors. Successors have to be cleaned before adding the new node to the graph.
                (let [
                    #_"AbstractBeginNode*" deadSuccessors (ยง snap (remove #(#_"ArrayList" .contains newSuccessors, %) (:successors this)))
                ]
                    (#_"List" .clear (:successors this))

                    ;; Create the new switch node. This is done before removing dead successors as 'killCFG' could edit
                    ;; some of the inputs (e.g. if 'newValue' is a loop-phi of the loop that dies while removing successors).
                    (let [
                        #_"AbstractBeginNode[]" successorsArray (into-array AbstractBeginNode'iface newSuccessors)
                        #_"SwitchNode" newSwitch (Graph''add-2 (:graph this), (IntegerSwitchNode'new-5a newValue, successorsArray, newKeys, newKeyProbabilities, newKeySuccessors))
                    ]
                        ;; remove dead successors
                        (doseq [#_"AbstractBeginNode" successor deadSuccessors]
                            (GraphUtil'killCFG-1 successor)
                        )

                        ;; replace ourselves with the new switch
                        (ยง ass! (:predecessor this) (FixedWithNextNode''setNext-2 (:predecessor this), newSwitch))
                        (GraphUtil'killWithUnusedFloatingInputs-1 this)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; For switch statements on enum values, the Java compiler has to generate complicated code:
     ; because Enum#ordinal() can change when recompiling an enum, it cannot be used directly
     ; as the value that is switched on. An intermediate int[] array, which is initialized once
     ; at run time based on the actual Enum#ordinal() values, is used.
     ;
     ; The ConstantFields of Graal already detects the int[] arrays and marks them as
     ; {@link ConstantNode#isDefaultStable() stable}, i.e. the array elements are constant.
     ; The code in this method detects array loads from such a stable array and re-wires the
     ; switch to use the keys from the array elements, so that the array load is unnecessary.
     ;;
    (defn- #_"boolean" IntegerSwitchNode''tryOptimizeEnumSwitch-2 [#_"IntegerSwitchNode" this, #_"SimplifierTool" tool]
        (and (satisfies? LoadIndexedNode (:value this))
            ;; Not the switch pattern we are looking for.
            (let [
                #_"LoadIndexedNode" loadIndexed (:value this)
            ]
                ;; The array load is necessary for other reasons too, so there is no benefit optimizing the switch.
                (and (not (< 1 (count (:nodeUsages loadIndexed))))
                    (let [
                        #_"ValueNode" newValue (AccessIndexedNode''index-1 loadIndexed)
                        #_"JavaConstant" arrayConstant (ValueNode''asJavaConstant-1 (:array loadIndexed))
                    ]
                        ;; The array is a constant that we can optimize. We require the array elements to be
                        ;; constant too, since we put them as literal constants into the switch keys.
                        (and (some? arrayConstant)
                            (= (:stableDimension (:array loadIndexed)) 1)
                            (:isDefaultStable (:array loadIndexed))
                            (let [
                                #_"Integer" optionalArrayLength (#_"ConstantReflectionProvider" .readArrayLength HotSpot'constantReflection, arrayConstant)
                            ]
                                ;; => Loading a constant value can be denied by the VM.
                                (and (some? optionalArrayLength)
                                    (let [
                                        #_"int" arrayLength optionalArrayLength
                                        #_"Map<Integer, List<Integer>>" reverseArrayMapping (HashMap.)
                                    ]
                                        (and
                                            (loop-when [#_"int" i 0] (< i arrayLength) => true
                                                (let [
                                                    #_"JavaConstant" elementConstant (#_"ConstantReflectionProvider" .readArrayElement HotSpot'constantReflection, arrayConstant, i)
                                                ]
                                                    ;; => Loading a constant value can be denied by the VM.
                                                    (and (some? elementConstant) (= (#_"JavaConstant" .getJavaKind elementConstant) JavaKind/Int)
                                                        ;; The value loaded from the array is the old switch key, the index into the array is
                                                        ;; the new switch key. We build a mapping from the old switch key to new keys.
                                                        (#_"List" .add (#_"Map" .computeIfAbsent reverseArrayMapping, (#_"JavaConstant" .asInt elementConstant), (ร (e)  (ยง fun (ArrayList.)))), i)
                                                        (recur (inc i))
                                                    )
                                                )
                                            )
                                            ;; Build high-level representation of new switch keys.
                                            (let [
                                                #_"List<KeyData>" newKeyDatas (ArrayList.)
                                                #_"ArrayList<AbstractBeginNode>" newSuccessors (ArrayList.)
                                            ]
                                                (dotimes [#_"int" i (count (:keys this))]
                                                    (let [
                                                        #_"List<Integer>" newKeys (#_"Map" .get reverseArrayMapping, (nth (:keys this) i))
                                                    ]
                                                        ;; => The switch case is unreachable, we can ignore it.
                                                        (when (seq newKeys)
                                                            ;; We do not have detailed profiling information about the individual new keys, so we
                                                            ;; have to assume they split the probability of the old key.
                                                            (let [
                                                                #_"double" newKeyProbability (/ (nth (:keyProbabilities this) i) (count newKeys))
                                                                #_"int" newKeySuccessor (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''keySuccessor-2 this, i), newSuccessors)
                                                            ]
                                                                (doseq [#_"int" newKey newKeys]
                                                                    (#_"List" .add newKeyDatas, (KeyData'new-3 newKey, newKeyProbability, newKeySuccessor))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )

                                                (let [
                                                    #_"int" newDefaultSuccessor (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''defaultSuccessor-1 this), newSuccessors)
                                                    #_"double" newDefaultProbability (nth (:keyProbabilities this) (dec (count (:keyProbabilities this))))
                                                    ;; We remove the array load, but we still need to preserve exception semantics by keeping
                                                    ;; the bounds check. Fortunately the array length is a constant.
                                                    #_"LogicNode" boundsCheck (Graph''add-2 (:graph this), (IntegerBelowNode'new-2 newValue, (ConstantNode'forInt-2 arrayLength, (:graph this))))
                                                ]
                                                    (Graph''addBeforeFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (FixedGuardNode'new-3 boundsCheck, DeoptimizationReason/BoundsCheckException, DeoptimizationAction/InvalidateReprofile)))

                                                    ;; Build the low-level representation of the new switch keys and replace ourself with a new node.
                                                    (IntegerSwitchNode''doReplace-6 this, newValue, newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability)

                                                    ;; The array load is now unnecessary.
                                                    (GraphUtil'removeFixedWithUnusedInputs-1 loadIndexed)

                                                    true
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defm IntegerSwitchNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"IntegerSwitchNode" this, #_"SimplifierTool" tool]
            (cond
                (= (count (:successors this)) 1)
                (do
                    (SimplifierTool'''addToWorkList-2n tool, (SwitchNode''defaultSuccessor-1 this))
                    (Graph''removeSplitPropagate-3 (:graph this), this, (SwitchNode''defaultSuccessor-1 this))
                )
                (satisfies? ConstantNode (:value this))
                    (SwitchNode''killOtherSuccessors-3 this, tool, (IntegerSwitchNode''successorIndexAtKey-2 this, (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:value this)))))
                (IntegerSwitchNode''tryOptimizeEnumSwitch-2 this, tool)
                    nil
                (IntegerSwitchNode''tryRemoveUnreachableKeys-3 this, tool, (:stamp (:value this)))
                    nil
            )
            nil
        )
    )

    ;;;
     ; Remove unreachable keys from the switch based on the stamp of the value,
     ; i.e. based on the known range of the switch value.
     ;;
    (defn #_"boolean" IntegerSwitchNode''tryRemoveUnreachableKeys-3 [#_"IntegerSwitchNode" this, #_"SimplifierTool" tool, #_"Stamp" stamp]
        (and (satisfies? IntegerStamp stamp) (not (Stamp'''isUnrestricted-1 stamp))
            (let [
                #_"List<KeyData>" newKeys (ArrayList.)
                #_"ArrayList<AbstractBeginNode>" newSuccessors (ArrayList.)
                _
                    (dotimes [#_"int" i (count (:keys this))]
                        (when (and (IntegerStamp''contains-2 stamp, (nth (:keys this) i)) (not= (SwitchNode''keySuccessor-2 this, i) (SwitchNode''defaultSuccessor-1 this)))
                            (#_"List" .add newKeys, (KeyData'new-3 (nth (:keys this) i), (nth (:keyProbabilities this) i), (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''keySuccessor-2 this, i), newSuccessors)))
                        )
                    )
            ]
                (cond
                    (= (count newKeys) (count (:keys this)))
                        false ;; all keys are reachable
                    (empty? newKeys)
                        (do
                            (when (some? tool)
                                (SimplifierTool'''addToWorkList-2n tool, (SwitchNode''defaultSuccessor-1 this))
                            )
                            (Graph''removeSplitPropagate-3 (:graph this), this, (SwitchNode''defaultSuccessor-1 this))
                            true
                        )
                    :else
                        (do
                            (IntegerSwitchNode''doReplace-6 this, (:value this), newKeys, newSuccessors, (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''defaultSuccessor-1 this), newSuccessors), (nth (:keyProbabilities this) (dec (count (:keyProbabilities this)))))
                            true
                        )
                )
            )
        )
    )

    (defm IntegerSwitchNode SwitchNode
        (#_"Stamp" SwitchNode'''getValueStampForSuccessor-2 [#_"IntegerSwitchNode" this, #_"AbstractBeginNode" beginNode]
            (when-not (= beginNode (SwitchNode''defaultSuccessor-1 this))
                (loop-when [#_"Stamp" stamp nil #_"int" i 0] (< i (count (:keys this))) => stamp
                    (let [
                        stamp
                            (when (= (SwitchNode''keySuccessor-2 this, i) beginNode) => stamp
                                (if (nil? stamp)
                                    (StampFactory'forPrimitiveConstant-1 (SwitchNode'''keyAt-2 this, i))
                                    (Stamp'''meet-2 stamp, (StampFactory'forPrimitiveConstant-1 (SwitchNode'''keyAt-2 this, i)))
                                )
                            )
                    ]
                        (recur stamp (inc i))
                    )
                )
            )
        )
    )
)

;;;
 ; Base class of all nodes that are fixed within the control flow graph and have an immediate successor.
 ;;
(class-ns FixedWithNextNode [FixedNode, ValueNode, Node]
    (defn #_"FixedWithNextNode" FixedWithNextNode''setNext-2 [#_"FixedWithNextNode" this, #_"FixedNode" node]
        (Node''updatePredecessor-3 this, (:next this), node)
        (assoc this :next node)
    )

    (defn #_"FixedWithNextNode" FixedWithNextNode'new-1 [#_"Stamp" stamp]
        (merge (FixedWithNextNode'class.) (FixedNode'new-1 stamp)
            (hash-map
                ; @Successor
                #_"FixedNode" :next nil
            )
        )
    )
)

(class-ns AbstractBeginNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode]
    (defn #_"AbstractBeginNode" AbstractBeginNode'new-1 [#_"Stamp" stamp]
        (merge (AbstractBeginNode'class.) (FixedWithNextNode'new-1 stamp))
    )

    #_unused
    (defn #_"AbstractBeginNode" AbstractBeginNode'new-0 []
        (AbstractBeginNode'new-1 VoidStamp'instance)
    )

    (defn #_"AbstractBeginNode" AbstractBeginNode'prevBegin-1 [#_"FixedNode" node]
        (loop-when [node node] (some? node)
            (if (satisfies? AbstractBeginNode node)
                node
                (recur (:predecessor node))
            )
        )
    )

    (defn- #_"void" AbstractBeginNode''evacuateGuards-2 [#_"AbstractBeginNode" this, #_"FixedNode" evacuateFrom]
        (when-not (Node''hasNoUsages-1 this)
            (let [
                #_"AbstractBeginNode" prevBegin (AbstractBeginNode'prevBegin-1 evacuateFrom)
            ]
                (doseq [#_"Node" anchored (ยง snap (AbstractBeginNode'''anchored-1 this))]
                    (Node''replaceFirstInput-3 anchored, this, prevBegin)
                )
            )
        )
        nil
    )

    (defn #_"void" AbstractBeginNode''prepareDelete-1 [#_"AbstractBeginNode" this]
        (AbstractBeginNode'''prepareDelete-2 this, (:predecessor this))
        nil
    )

    (defm AbstractBeginNode AbstractBeginNode
        (#_"void" AbstractBeginNode'''prepareDelete-2 [#_"AbstractBeginNode" this, #_"FixedNode" evacuateFrom]
            (AbstractBeginNode''evacuateGuards-2 this, evacuateFrom)
            nil
        )
    )

    (defm AbstractBeginNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AbstractBeginNode" this, #_"LIRBuilder" builder]
            ;; nop
            nil
        )
    )

    (defn #_"GuardNode*" AbstractBeginNode''guards-1 [#_"AbstractBeginNode" this]
        (filter #(satisfies? GuardNode %) (:nodeUsages this))
    )

    (defm AbstractBeginNode AbstractBeginNode
        (#_"Node*" AbstractBeginNode'''anchored-1 [#_"AbstractBeginNode" this]
            (:nodeUsages this)
        )
    )

    (defn #_"FixedNode*" AbstractBeginNode''getBlockNodes-1 [#_"AbstractBeginNode" this]
        (->> this (iterate #(when (and (satisfies? FixedWithNextNode %) (not (satisfies? AbstractBeginNode (:next %)))) (:next %))) (take-while some?))
    )
)

(class-ns BeginNode [AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, Simplifiable]
    (defn #_"BeginNode" BeginNode'new-1 [#_"Stamp" stamp]
        (merge (BeginNode'class.) (AbstractBeginNode'new-1 stamp))
    )

    (defn #_"BeginNode" BeginNode'new-0 []
        (BeginNode'new-1 VoidStamp'instance)
    )

    (defm BeginNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"BeginNode" this, #_"SimplifierTool" tool]
            (let [
                #_"FixedNode" prev (:predecessor this)
            ]
                (cond
                    (nil? prev)
                        nil ;; This is the start node.
                    (satisfies? ControlSplitNode prev)
                        nil ;; This begin node is necessary.
                    :else
                        (do
                            ;; This begin node can be removed and all guards moved up to the preceding begin node.
                            (AbstractBeginNode''prepareDelete-1 this)
                            (SimplifierTool'''addToWorkList-2n tool, (:next this))
                            (Graph''removeFixed-2 (:graph this), this)
                        )
                )
            )
            nil
        )
    )

    (defn #_"AbstractBeginNode" BeginNode'begin-1 [#_"FixedNode" with]
        (when-not (satisfies? AbstractBeginNode with) => with
            (let [
                #_"BeginNode" begin (Graph''add-2 (:graph with), (BeginNode'new-0))
            ]
                (FixedWithNextNode''setNext-2 begin, with)
            )
        )
    )
)

;;;
 ; Base class for AbstractBeginNodes that are associated with a frame state.
 ;
 ; TODO this not needed until AbstractBeginNode no longer implements StateSplit
 ; which is not possible until loop peeling works without requiring begin nodes to have frames states.
 ;;
(class-ns BeginStateSplitNode [AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, StateSplit, NodeWithState]
    (defn #_"BeginStateSplitNode" BeginStateSplitNode'new-1 [#_"Stamp" stamp]
        (merge (BeginStateSplitNode'class.) (AbstractBeginNode'new-1 stamp)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
            )
        )
    )

    (defn #_"BeginStateSplitNode" BeginStateSplitNode'new-0 []
        (BeginStateSplitNode'new-1 VoidStamp'instance)
    )

    (defm BeginStateSplitNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"BeginStateSplitNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )
    )

    ;;;
     ; A begin node has no side effect.
     ;;
    (defm BeginStateSplitNode StateSplit
        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"BeginStateSplitNode" this]
            false
        )
    )
)

(class-ns AbstractMergeNode [BeginStateSplitNode, AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, StateSplit, NodeWithState, Simplifiable]
    (defn #_"AbstractMergeNode" AbstractMergeNode'new-0 []
        (merge (AbstractMergeNode'class.) (BeginStateSplitNode'new-0)
            (hash-map
                ; @Input
                #_"NodeInputList<EndNode>" :ends (NodeInputList'new-1 (ร this))
            )
        )
    )

    (defm AbstractMergeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AbstractMergeNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''visitMerge-2 builder, this)
            nil
        )
    )

    (defn #_"int" AbstractMergeNode''forwardEndIndex-2 [#_"AbstractMergeNode" this, #_"EndNode" end]
        (#_"List" .indexOf (:ends this), end)
    )

    (defn #_"void" AbstractMergeNode''addForwardEnd-2 [#_"AbstractMergeNode" this, #_"EndNode" end]
        (#_"List" .add (:ends this), end)
        nil
    )

    (defn #_"int" AbstractMergeNode''forwardEndCount-1 [#_"AbstractMergeNode" this]
        (count (:ends this))
    )

    (defn #_"EndNode" AbstractMergeNode''forwardEndAt-2 [#_"AbstractMergeNode" this, #_"int" index]
        (nth (:ends this) index)
    )

    (defm AbstractMergeNode Node
        (#_"EndNode*" Node'''cfgPredecessors-1 [#_"AbstractMergeNode" this]
            (:ends this)
        )
    )

    ;;;
     ; Determines if a given node is a phi whose {@linkplain PhiNode#merge() merge} is this node.
     ;
     ; @param value the instruction to test
     ; @return true if {@code value} is a phi and its merge is {@code this}
     ;;
    (defn #_"boolean" AbstractMergeNode''isPhiAtMerge-2 [#_"AbstractMergeNode" this, #_"Node" value]
        (and (satisfies? PhiNode value) (= (:merge value) this))
    )

    ;;;
     ; Removes the given end from the merge, along with the entries corresponding to this end in the
     ; phis connected to the merge.
     ;
     ; @param pred the end to remove
     ;;
    (defn #_"void" AbstractMergeNode''removeEnd-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" pred]
        (let [
            #_"int" predIndex (AbstractMergeNode'''phiPredecessorIndex-2 this, pred)
        ]
            (AbstractMergeNode'''deleteEnd-2 this, pred)
            (doseq [#_"PhiNode" phi (ยง snap (AbstractMergeNode''phis-1 this))]
                (when-not (Node''isDeleted-1 phi)
                    (let [
                        #_"ValueNode" removedValue (PhiNode''valueAt-2i phi, predIndex)
                    ]
                        (PhiNode''removeInput-2 phi, predIndex)
                        (when (some? removedValue)
                            (GraphUtil'tryKillUnused-1 removedValue)
                        )
                    )
                )
            )
        )
        nil
    )

    (defm AbstractMergeNode AbstractMergeNode
        (#_"void" AbstractMergeNode'''deleteEnd-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" end]
            (#_"List" .remove (:ends this), end)
            nil
        )

        (#_"int" AbstractMergeNode'''phiPredecessorCount-1 [#_"AbstractMergeNode" this]
            (AbstractMergeNode''forwardEndCount-1 this)
        )

        (#_"int" AbstractMergeNode'''phiPredecessorIndex-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" pred]
            (AbstractMergeNode''forwardEndIndex-2 this, pred)
        )

        (#_"AbstractEndNode" AbstractMergeNode'''phiPredecessorAt-2 [#_"AbstractMergeNode" this, #_"int" index]
            (AbstractMergeNode''forwardEndAt-2 this, index)
        )
    )

    (defn #_"PhiNode*" AbstractMergeNode''phis-1 [#_"AbstractMergeNode" this]
        (filter #(AbstractMergeNode''isPhiAtMerge-2 this, %) (filter #(satisfies? PhiNode %) (:nodeUsages this)))
    )

    (defn #_"ValuePhiNode*" AbstractMergeNode''valuePhis-1 [#_"AbstractMergeNode" this]
        (filter #(satisfies? ValuePhiNode %) (:nodeUsages this))
    )

    (defn #_"MemoryPhiNode*" AbstractMergeNode''memoryPhis-1 [#_"AbstractMergeNode" this]
        (filter #(satisfies? MemoryPhiNode %) (:nodeUsages this))
    )

    (defm AbstractMergeNode AbstractBeginNode
        (#_"Node*" AbstractBeginNode'''anchored-1 [#_"AbstractMergeNode" this]
            (remove #(AbstractMergeNode''isPhiAtMerge-2 this, %) (AbstractBeginNode'''anchored-1 (ยง super #_"BeginStateSplitNode")))
        )
    )

    ;;;
     ; This simplify method can deal with a nil value for tool, so that it can be used outside of canonicalization.
     ;;
    (defm AbstractMergeNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"AbstractMergeNode" this, #_"SimplifierTool" tool]
            (let [
                #_"FixedNode" node (:next this)
            ]
                (condp satisfies? node
                    AbstractEndNode
                        (let [
                            #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 node)
                        ]
                            (or
                                (when (and (satisfies? LoopBeginNode merge) (not (satisfies? LoopEndNode node)))
                                    :done
                                )
                                ;; In order to move anchored values to the other merge we would need to check
                                ;; if the anchors are used by phis of the other merge.
                                (when (seq (AbstractBeginNode'''anchored-1 this))
                                    :done
                                )
                                ;; We hold a state, but the succeeding merge does not => do not combine.
                                (when (and (nil? (:stateAfter merge)) (some? (:stateAfter this)))
                                    :done
                                )
                                (loop-when [#_"ISeq" s (seq (AbstractMergeNode''phis-1 this))] (some? s)
                                    (let [
                                        #_"PhiNode" phi (first s)
                                    ]
                                        (or
                                            (loop-when [#_"ISeq" s (seq (:nodeUsages phi))] (some? s)
                                                (let [
                                                    #_"Node" usage (first s)
                                                ]
                                                    (if (and (not (satisfies? VirtualState usage)) (not (AbstractMergeNode''isPhiAtMerge-2 merge, usage)))
                                                        :done
                                                        (recur (next s))
                                                    )
                                                )
                                            )
                                            (recur (next s))
                                        )
                                    )
                                )
                                (let [
                                    #_"int" n (dec (AbstractMergeNode''forwardEndCount-1 this))
                                ]
                                    (dotimes [#_"int" i n]
                                        (let [
                                            #_"AbstractEndNode" end (AbstractMergeNode''forwardEndAt-2 this, (- n i))
                                        ]
                                            (when (some? tool)
                                                (SimplifierTool'''addToWorkList-2n tool, end)
                                            )
                                            (let [
                                                #_"AbstractEndNode" newEnd
                                                    (if (satisfies? LoopBeginNode merge)
                                                        (Graph''add-2 (:graph this), (LoopEndNode'new-1 merge))
                                                        (let [
                                                            newEnd (Graph''add-2 (:graph this), (EndNode'new-0))
                                                        ]
                                                            (AbstractMergeNode''addForwardEnd-2 merge, newEnd)
                                                            newEnd
                                                        )
                                                    )
                                            ]
                                                (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 merge)]
                                                    (let [
                                                        #_"ValueNode" v (PhiNode''valueAt-2n phi, node)
                                                    ]
                                                        (PhiNode''addInput-2 phi, (if (AbstractMergeNode''isPhiAtMerge-2 this, v) (PhiNode''valueAt-2n v, end) v))
                                                    )
                                                )
                                                (AbstractMergeNode''removeEnd-2 this, end)
                                                (Node''replaceAtPredecessor-2 end, newEnd)
                                                (Node''safeDelete-1 end)
                                                (when (some? tool)
                                                    (SimplifierTool'''addToWorkList-2n tool, (:predecessor newEnd))
                                                )
                                            )
                                        )
                                    )
                                    (Graph''reduceTrivialMerge-2 (:graph this), this)
                                )
                            )
                        )
                    ReturnNode
                        (when (and (empty? (AbstractBeginNode'''anchored-1 this)) (nil? (:memoryMap node)))
                            (let [
                                #_"PhiNode*" phis (ยง snap (AbstractMergeNode''phis-1 this))
                            ]
                                (or
                                    (loop-when [#_"ISeq" s (seq phis)] (some? s)
                                        (let [
                                            #_"PhiNode" phi (first s)
                                        ]
                                            (or
                                                (loop-when [#_"ISeq" s (seq (:nodeUsages phi))] (some? s)
                                                    (let [
                                                        #_"Node" usage (first s)
                                                    ]
                                                        (if (and (not (= usage node)) (not (satisfies? FrameState usage)))
                                                            :done
                                                            (recur (next s))
                                                        )
                                                    )
                                                )
                                                (recur (next s))
                                            )
                                        )
                                    )
                                    (let [
                                        #_"ValuePhiNode" returnValuePhi (when-not (or (nil? (:result node)) (not (AbstractMergeNode''isPhiAtMerge-2 this, (:result node)))) (:result node))
                                        #_"List<EndNode>" endNodes (ยง snap (:ends this))
                                    ]
                                        (doseq [#_"EndNode" end endNodes]
                                            (let [
                                                #_"ReturnNode" newReturn (Graph''add-2 (:graph this), (ReturnNode'new-1 (if (nil? returnValuePhi) (:result node) (PhiNode''valueAt-2n returnValuePhi, end))))
                                            ]
                                                (when (some? tool)
                                                    (SimplifierTool'''addToWorkList-2n tool, (:predecessor end))
                                                )
                                                (Node''replaceAtPredecessor-2 end, newReturn)
                                            )
                                        )
                                        (GraphUtil'killCFG-1 this)
                                        (doseq [#_"EndNode" end endNodes]
                                            (Node''safeDelete-1 end)
                                        )
                                        (doseq [#_"PhiNode" phi phis]
                                            (when (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''isAlive-1 phi) (Node''hasNoUsages-1 phi))
                                                (GraphUtil'killWithUnusedFloatingInputs-1 phi)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    nil
                )
            )
            nil
        )
    )
)

(class-ns LoopBeginNode [AbstractMergeNode, BeginStateSplitNode, AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, StateSplit, NodeWithState, Simplifiable]
    (defn #_"LoopBeginNode" LoopBeginNode'new-0 []
        (merge (LoopBeginNode'class.) (AbstractMergeNode'new-0)
            (hash-map
                #_"double" :loopFrequency 1.0
                #_"double" :loopOrigFrequency 1.0
                #_"int" :nextEndIndex 0
                #_"int" :unswitches 0
                #_"int" :splits 0
                #_"LoopType" :loopType LoopType'SIMPLE_LOOP
                #_"int" :unrollFactor 1
                ;;;
                 ; See LoopEndNode#canSafepoint for more information.
                 ;;
                #_"boolean" :canEndsSafepoint true
                ; @OptionalInput(InputType'Guard)
                #_"GuardingNode" :overflowGuard nil
            )
        )
    )

    (defn #_"boolean" LoopBeginNode''isSimpleLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'SIMPLE_LOOP)
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setPreLoop-1 [#_"LoopBeginNode" this]
        (assoc this :loopType LoopType'PRE_LOOP)
    )

    #_unused
    (defn #_"boolean" LoopBeginNode''isPreLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'PRE_LOOP)
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setMainLoop-1 [#_"LoopBeginNode" this]
        (assoc this :loopType LoopType'MAIN_LOOP)
    )

    (defn #_"boolean" LoopBeginNode''isMainLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'MAIN_LOOP)
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setPostLoop-1 [#_"LoopBeginNode" this]
        (assoc this :loopType LoopType'POST_LOOP)
    )

    #_unused
    (defn #_"boolean" LoopBeginNode''isPostLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'POST_LOOP)
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setUnrollFactor-2 [#_"LoopBeginNode" this, #_"int" currentUnrollFactor]
        (assoc this :unrollFactor currentUnrollFactor)
    )

    ;;;
     ; Disables safepoint for the whole loop, i.e. for all {@link LoopEndNode loop ends}.
     ;;
    (defn #_"this" LoopBeginNode''disableSafepoint-1 [#_"LoopBeginNode" this]
        ;; Store flag locally in case new loop ends are created later on.
        (let [
            this (assoc this :canEndsSafepoint false)
        ]
            ;; Propagate flag to all existing loop ends.
            (doseq [#_"LoopEndNode" loopEnd (LoopBeginNode''loopEnds-1 this)]
                (ยง ass! loopEnd (LoopEndNode''disableSafepoint-1 loopEnd))
            )
            this
        )
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setLoopOrigFrequency-2 [#_"LoopBeginNode" this, #_"double" loopOrigFrequency]
        (assoc this :loopOrigFrequency loopOrigFrequency)
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setLoopFrequency-2 [#_"LoopBeginNode" this, #_"double" loopFrequency]
        (assoc this :loopFrequency loopFrequency)
    )

    ;;;
     ; Returns the <b>unordered</b> set of LoopEndNode that correspond to back-edges for
     ; this loop. The order of the back-edges is unspecified, if you need to get an ordering
     ; compatible for PhiNode creation, use #orderedLoopEnds().
     ;
     ; @return the set of LoopEndNode that correspond to back-edges for this loop
     ;;
    (defn #_"LoopEndNode*" LoopBeginNode''loopEnds-1 [#_"LoopBeginNode" this]
        (filter #(satisfies? LoopEndNode %) (:nodeUsages this))
    )

    (defn #_"LoopExitNode*" LoopBeginNode''loopExits-1 [#_"LoopBeginNode" this]
        (filter #(satisfies? LoopExitNode %) (:nodeUsages this))
    )

    (defm LoopBeginNode AbstractBeginNode
        (#_"Node*" AbstractBeginNode'''anchored-1 [#_"LoopBeginNode" this]
            (filter #(and (not (satisfies? LoopEndNode %)) (not (satisfies? LoopExitNode %))) (AbstractBeginNode'''anchored-1 (ยง super AbstractMergeNode'iface)))
        )
    )

    ;;;
     ; Returns the set of LoopEndNode that correspond to back-edges for this loop, in increasing
     ; #phiPredecessorIndex order. This method is suited to create new loop PhiNode.
     ;
     ; For example a new PhiNode may be added as follow:
     ;
     ; PhiNode phi = ValuePhiNode'new(stamp, loop);
     ; phi.addInput(forwardEdgeValue);
     ; for (LoopEndNode loopEnd : loop.orderedLoopEnds()) {
     ;     phi.addInput(backEdgeValue(loopEnd));
     ; }
     ;
     ; @return the set of LoopEndNode that correspond to back-edges for this loop
     ;;
    (defn #_"LoopEndNode[]" LoopBeginNode''orderedLoopEnds-1 [#_"LoopBeginNode" this]
        (let [
            #_"LoopEndNode[]" result (make-array LoopEndNode'iface (:nextEndIndex this))
        ]
            (doseq [#_"LoopEndNode" end (LoopBeginNode''loopEnds-1 this)]
                (aset result (:endIndex end) end)
            )
            result
        )
    )

    (defn #_"AbstractEndNode" LoopBeginNode''forwardEnd-1 [#_"LoopBeginNode" this]
        (AbstractMergeNode''forwardEndAt-2 this, 0)
    )

    (defn #_"LoopBeginNode" LoopBeginNode''incrementSplits-1 [#_"LoopBeginNode" this]
        (update this :splits inc)
    )

    (defm LoopBeginNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"LoopBeginNode" this, #_"LIRBuilder" builder]
            ;; Nothing to emit, since this is node is used for structural purposes only.
            nil
        )
    )

    (defm LoopBeginNode AbstractMergeNode
        (#_"void" AbstractMergeNode'''deleteEnd-2 [#_"LoopBeginNode" this, #_"AbstractEndNode" end]
            (when (satisfies? LoopEndNode end) => (AbstractMergeNode'''deleteEnd-2 (ยง super AbstractMergeNode'iface), end)
                (ยง ass! end (LoopEndNode''setLoopBegin-2 end, nil))
                (let [
                    #_"int" i (:endIndex end)
                ]
                    (doseq [#_"LoopEndNode" e (LoopBeginNode''loopEnds-1 this)]
                        (let [
                            #_"int" j (:endIndex e)
                        ]
                            (when (< i j)
                                (ยง ass! e (LoopEndNode''setEndIndex-2 e, (dec j)))
                            )
                        )
                    )
                    (ยง ass! this (update this :nextEndIndex dec))
                )
            )
            nil
        )

        (#_"int" AbstractMergeNode'''phiPredecessorCount-1 [#_"LoopBeginNode" this]
            (+ (AbstractMergeNode''forwardEndCount-1 this) (count (LoopBeginNode''loopEnds-1 this)))
        )

        (#_"int" AbstractMergeNode'''phiPredecessorIndex-2 [#_"LoopBeginNode" this, #_"AbstractEndNode" pred]
            (when (satisfies? LoopEndNode pred) => (AbstractMergeNode''forwardEndIndex-2 (ยง super AbstractMergeNode'iface), pred)
                (when (= (:loopBegin pred) this) => (throw! "should not reach here")
                    (+ (:endIndex pred) (AbstractMergeNode''forwardEndCount-1 this))
                )
            )
        )
    )

    (defm LoopBeginNode AbstractMergeNode
        #_unused
        (#_"AbstractEndNode" AbstractMergeNode'''phiPredecessorAt-2 [#_"LoopBeginNode" this, #_"int" index]
            (if (< index (AbstractMergeNode''forwardEndCount-1 this))
                (AbstractMergeNode''forwardEndAt-2 this, index)
                (loop-when [#_"ISeq" s (seq (LoopBeginNode''loopEnds-1 this))] (some? s) => (throw! "should not reach here")
                    (let [
                        #_"LoopEndNode" end (first s)
                    ]
                        (if (= (:endIndex end) (- index (AbstractMergeNode''forwardEndCount-1 this)))
                            end
                            (recur (next s))
                        )
                    )
                )
            )
        )
    )

    (defn #_"int" LoopBeginNode''nextEndIndex-1 [#_"LoopBeginNode" this]
        (let [
            _ (:nextEndIndex this)
        ]
            (ยง ass! this (update this :nextEndIndex inc))
            _
        )
    )

    (defn #_"LoopBeginNode" LoopBeginNode''incrementUnswitches-1 [#_"LoopBeginNode" this]
        (update this :unswitches inc)
    )

    (defm LoopBeginNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"LoopBeginNode" this, #_"SimplifierTool" tool]
            (LoopBeginNode''canonicalizePhis-2 this, tool)
            nil
        )
    )

    (defn #_"boolean" LoopBeginNode''isLoopExit-2 [#_"LoopBeginNode" this, #_"AbstractBeginNode" begin]
        (and (satisfies? LoopExitNode begin) (= (:loopBegin begin) this))
    )

    (defn #_"LoopExitNode" LoopBeginNode''getSingleLoopExit-1 [#_"LoopBeginNode" this]
        (first (LoopBeginNode''loopExits-1 this))
    )

    (defn #_"LoopEndNode" LoopBeginNode''getSingleLoopEnd-1 [#_"LoopBeginNode" this]
        (first (LoopBeginNode''loopEnds-1 this))
    )

    (defn #_"void" LoopBeginNode''removeExits-1 [#_"LoopBeginNode" this]
        (doseq [#_"LoopExitNode" loopexit (ยง snap (LoopBeginNode''loopExits-1 this))]
            (LoopExitNode''removeProxies-1 loopexit)
            (let [
                #_"FrameState" loopStateAfter (:stateAfter loopexit)
            ]
                (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), loopexit, (Graph''add-2 (:graph this), (BeginNode'new-0))))
                (when (some? loopStateAfter)
                    (GraphUtil'tryKillUnused-1 loopStateAfter)
                )
            )
        )
        nil
    )

    (defn #_"LoopBeginNode" LoopBeginNode''setOverflowGuard-2 [#_"LoopBeginNode" this, #_"GuardingNode" overflowGuard]
        (Node''updateUsages-3 this, (:overflowGuard this), overflowGuard)
        (assoc this :overflowGuard overflowGuard)
    )

    (def- #_"int" LoopBeginNode'NO_INCREMENT Integer/MIN_VALUE)

    ;;;
     ; Returns an array with one entry for each input of the phi, which is either #NO_INCREMENT
     ; or the increment, i.e. the value by which the phi is incremented in the corresponding branch.
     ;;
    (defn- #_"int[]" LoopBeginNode'getSelfIncrements-1 [#_"PhiNode" phi]
        (let [
            #_"int[]" selfIncrement (int-array (PhiNode''valueCount-1 phi))
        ]
            (loop-when-recur [#_"int" i 0] (< i (PhiNode''valueCount-1 phi)) [(inc i)]
                (let [
                    #_"ValueNode" input (PhiNode''valueAt-2i phi, i)
                    #_"long" increment
                        (cond
                            (and (some? input) (satisfies? AddNode input) (satisfies? IntegerStamp (:stamp input)))
                                (cond
                                    (and (= (:x input) phi) (satisfies? ConstantNode (:y input)))
                                        (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y input)))
                                    (and (= (:y input) phi) (satisfies? ConstantNode (:x input)))
                                        (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:x input)))
                                    :else
                                        LoopBeginNode'NO_INCREMENT
                                )
                            (= input phi)
                                0
                            :else
                                LoopBeginNode'NO_INCREMENT
                        )
                    increment
                        (when-not (<= Integer/MIN_VALUE increment Integer/MAX_VALUE) => increment
                            LoopBeginNode'NO_INCREMENT
                        )
                ]
                    (aset selfIncrement i (int increment))
                )
            )
            selfIncrement
        )
    )

    ;;;
     ; Coalesces loop phis that represent the same value (which is not handled by normal Global Value Numbering).
     ;;
    (defn #_"void" LoopBeginNode''canonicalizePhis-2 [#_"LoopBeginNode" this, #_"SimplifierTool" tool]
        (let [
            #_"int" phiCount (count (AbstractMergeNode''phis-1 this))
        ]
            (when (< 1 phiCount)
                (let [
                    #_"int" phiInputCount (AbstractMergeNode'''phiPredecessorCount-1 this)
                    #_"int[][]" selfIncrement (ร new int[phiCount][])
                    #_"PhiNode[]" phis (into-array PhiNode'iface (ยง snap (AbstractMergeNode''phis-1 this)))
                ]
                    (loop-when-recur [#_"int" phiIndex 0] (< phiIndex phiCount) [(inc phiIndex)]
                        (let [
                            #_"PhiNode" phi (nth phis phiIndex)
                        ]
                            (when (some? phi)
                                (ยง label nextPhi)
                                (loop-when-recur [#_"int" otherPhiIndex (inc phiIndex)] (< otherPhiIndex phiCount) [(inc otherPhiIndex)]
                                    (let [
                                        #_"PhiNode" otherPhi (nth phis otherPhiIndex)
                                    ]
                                        (when (and (some? otherPhi) (= (:nodeClass phi) (:nodeClass otherPhi)) (Node''valueEquals-2 phi, otherPhi))
                                            (when (nil? (nth selfIncrement phiIndex))
                                                (aset selfIncrement phiIndex (LoopBeginNode'getSelfIncrements-1 phi))
                                            )
                                            (when (nil? (nth selfIncrement otherPhiIndex))
                                                (aset selfIncrement otherPhiIndex (LoopBeginNode'getSelfIncrements-1 otherPhi))
                                            )
                                            (let [
                                                #_"int[]" phiIncrement (nth selfIncrement phiIndex)
                                                #_"int[]" otherPhiIncrement (nth selfIncrement otherPhiIndex)
                                            ]
                                                (loop-when-recur [#_"int" inputIndex 0] (< inputIndex phiInputCount) [(inc inputIndex)]
                                                    (when (= (nth phiIncrement inputIndex) LoopBeginNode'NO_INCREMENT)
                                                        (when-not (= (PhiNode''valueAt-2i phi, inputIndex) (PhiNode''valueAt-2i otherPhi, inputIndex))
                                                            (ยง continue nextPhi)
                                                        )
                                                    )
                                                    (when-not (= (nth phiIncrement inputIndex) (nth otherPhiIncrement inputIndex))
                                                        (ยง continue nextPhi)
                                                    )
                                                )
                                                (when (some? tool)
                                                    (SimplifierTool'''addToWorkList-2s tool, (:nodeUsages otherPhi))
                                                )
                                                (ยง ass! otherPhi (Node''replaceAtUsages-2 otherPhi, phi))
                                                (GraphUtil'killWithUnusedFloatingInputs-1 otherPhi)
                                                (aset phis otherPhiIndex nil)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Denotes the merging of multiple control-flow paths.
 ;;
(class-ns MergeNode [AbstractMergeNode, BeginStateSplitNode, AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, StateSplit, NodeWithState, Simplifiable]
    (defn #_"MergeNode" MergeNode'new-0 []
        (merge (MergeNode'class.) (AbstractMergeNode'new-0))
    )
)

(class-ns LoopExitNode [BeginStateSplitNode, AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, StateSplit, NodeWithState, Simplifiable]
    (defn #_"LoopExitNode" LoopExitNode'new-1 [#_"LoopBeginNode" _loop]
        (merge (LoopExitNode'class.) (BeginStateSplitNode'new-0)
            (hash-map
                ;; The declared type of the field cannot be LoopBeginNode, because loop explosion during partial
                ;; evaluation can temporarily assign a non-loop begin. This node will then be deleted shortly
                ;; after - but we still must not have type system violations for that short amount of time.
                ; @Input
                #_"AbstractBeginNode" :loopBegin _loop
            )
        )
    )

    (defm LoopExitNode AbstractBeginNode
        (#_"Node*" AbstractBeginNode'''anchored-1 [#_"LoopExitNode" this]
            (remove #(and (satisfies? ProxyNode %) (= (:loopExit %) this)) (AbstractBeginNode'''anchored-1 (ยง super #_"BeginStateSplitNode")))
        )

        (#_"void" AbstractBeginNode'''prepareDelete-2 [#_"LoopExitNode" this, #_"FixedNode" evacuateFrom]
            (LoopExitNode''removeProxies-1 this)
            (AbstractBeginNode'''prepareDelete-2 (ยง super #_"BeginStateSplitNode"), evacuateFrom)
            nil
        )
    )

    (defn #_"void" LoopExitNode''removeProxies-1 [#_"LoopExitNode" this]
        (when (Node''hasUsages-1 this)
            (while
                (loop-when [#_"ISeq" s (seq (ยง snap (LoopExitNode''proxies-1 this)))] (some? s)
                    (let [
                        #_"ProxyNode" vpn (first s)
                        #_"ValueNode" value (:value vpn)
                    ]
                        (ยง ass! vpn (Node''replaceAtUsagesAndDelete-2 vpn, value))
                        ;; Guard proxy could have this input as value.
                        (or (= value this) (recur (next s)))
                    )
                )
            )
        )
        nil
    )

    (defn #_"ProxyNode*" LoopExitNode''proxies-1 [#_"LoopExitNode" this]
        (filter #(and (satisfies? ProxyNode %) (= (:loopExit %) this)) (:nodeUsages this))
    )

    (defm LoopExitNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"LoopExitNode" this, #_"SimplifierTool" tool]
            (loop-when [#_"Node" pred (:predecessor this)] (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (satisfies? BeginNode pred) (Node''hasNoUsages-1 pred))
                (let [
                    #_"AbstractBeginNode" begin pred
                    pred (:predecessor pred)
                ]
                    (Graph''removeFixed-2 (:graph this), begin)
                    (recur pred)
                )
            )
            nil
        )
    )
)

;;;
 ; The start node of a graph.
 ;;
(class-ns StartNode [BeginStateSplitNode, AbstractBeginNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, GuardingNode, AnchoringNode, StateSplit, NodeWithState, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"StartNode" StartNode'new-0 []
        (merge (StartNode'class.) (BeginStateSplitNode'new-0))
    )

    (defm StartNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"StartNode" this]
            LocationIdentity'ANY
        )
    )
)

;;;
 ; Provides an implementation of StateSplit.
 ;;
(class-ns AbstractStateSplit [FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState]
    (defn #_"AbstractStateSplit" AbstractStateSplit'new-2 [#_"Stamp" stamp, #_"FrameState" stateAfter]
        (merge (AbstractStateSplit'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateAfter stateAfter
            )
        )
    )

    (defm AbstractStateSplit StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"AbstractStateSplit" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"AbstractStateSplit" this]
            true
        )
    )
)

;;;
 ; Provides an implementation of StateSplit.
 ;;
(class-ns AbstractMemoryCheckpoint [AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode]
    (defn #_"AbstractMemoryCheckpoint" AbstractMemoryCheckpoint'new-1 [#_"Stamp" stamp]
        (AbstractMemoryCheckpoint'new-2 stamp, nil)
    )

    (defn #_"AbstractMemoryCheckpoint" AbstractMemoryCheckpoint'new-2 [#_"Stamp" stamp, #_"FrameState" stateAfter]
        (merge (AbstractMemoryCheckpoint'class.) (AbstractStateSplit'new-2 stamp, stateAfter))
    )
)

;;;
 ; The AccessMonitorNode is the base class of both monitor acquisition and release.
 ;
 ; The Java bytecode specification allows non-balanced locking. Graal does not handle such cases.
 ;;
(class-ns AccessMonitorNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, DeoptBefore, DeoptimizingNode, DeoptAfter]
    (defm AccessMonitorNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"AccessMonitorNode" this]
            true
        )
    )

    (defm AccessMonitorNode DeoptBefore
        (#_"void" DeoptBefore'''setStateBefore-2 [#_"AccessMonitorNode" this, #_"FrameState" f]
            (Node''updateUsages-3 this, (:stateBefore this), f)
            (ยง ass! this (assoc this :stateBefore f))
            nil
        )
    )

    ;;;
     ; Creates a new AccessMonitor instruction.
     ;
     ; @param object the instruction producing the object
     ;;
    (defn #_"AccessMonitorNode" AccessMonitorNode'new-2 [#_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (merge (AccessMonitorNode'class.) (AbstractMemoryCheckpoint'new-1 VoidStamp'instance)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateBefore nil
                ; @Input
                #_"ValueNode" :object object
                ; @Input
                #_"MonitorIdNode" :monitorId monitorId
            )
        )
    )
)

;;;
 ; The MonitorEnterNode represents the acquisition of a monitor.
 ;;
(class-ns MonitorEnterNode [AccessMonitorNode, AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, DeoptBefore, DeoptimizingNode, DeoptAfter, Virtualizable, Lowerable, MonitorEnter, Single]
    (defn #_"MonitorEnterNode" MonitorEnterNode'new-2 [#_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (merge (MonitorEnterNode'class.) (AccessMonitorNode'new-2 object, monitorId))
    )

    (defm MonitorEnterNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"MonitorEnterNode" this]
            LocationIdentity'ANY
        )
    )

    (defm MonitorEnterNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"MonitorEnterNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"ValueNode" object (Lowerer'createNullCheckedValue-3 (:object this), this, lowerer)
                #_"ValueNode" hub (Graph''add-2 (:graph this), (LoadHubNode'create-1 object))
                #_"RawMonitorEnterNode" rawMonitorEnter (Graph''add-2 (:graph this), (RawMonitorEnterNode'new-3 object, hub, (:monitorId this)))
            ]
                (DeoptBefore'''setStateBefore-2 rawMonitorEnter, (:stateBefore this))
                (StateSplit'''setStateAfter-2 rawMonitorEnter, (:stateAfter this))
                (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, rawMonitorEnter))
            )
            nil
        )
    )

    (defm MonitorEnterNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"MonitorEnterNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (and (satisfies? VirtualObjectNode object) (:hasIdentity object))
                    (VirtualizerTool'''addLock-3 tool, object, (:monitorId this))
                    (VirtualizerTool'''delete-1 tool)
                )
            )
            nil
        )
    )
)

;;;
 ; The MonitorExitNode represents a monitor release. If it is the release of the monitor
 ; of a synchronized method, then the return value of the method will be referenced via the edge
 ; #escapedReturnValue, so that it will be materialized before releasing the monitor.
 ;;
(class-ns MonitorExitNode [AccessMonitorNode, AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, DeoptBefore, DeoptimizingNode, DeoptAfter, Virtualizable, Lowerable, MonitorExit, Single]
    (defn #_"MonitorExitNode" MonitorExitNode'new-3 [#_"ValueNode" object, #_"MonitorIdNode" monitorId, #_"ValueNode" escapedReturnValue]
        (merge (MonitorExitNode'class.) (AccessMonitorNode'new-2 object, monitorId)
            (hash-map
                ;;;
                 ; Non-null for the monitor exit introduced due to a synchronized root method and nil in all other cases.
                 ;;
                ; @OptionalInput
                #_"ValueNode" :escapedReturnValue escapedReturnValue
            )
        )
    )

    ;;;
     ; Return value is cleared when a synchronized method graph is inlined.
     ;;
    (defn #_"MonitorExitNode" MonitorExitNode''clearEscapedReturnValue-1 [#_"MonitorExitNode" this]
        (Node''updateUsages-3 this, (:escapedReturnValue this), nil)
        (assoc this :escapedReturnValue nil)
    )

    (defm MonitorExitNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"MonitorExitNode" this]
            LocationIdentity'ANY
        )
    )

    (defm MonitorExitNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"MonitorExitNode" this, #_"LoweringTool" lowerer]
            (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                (MonitorTemplates''lower-3o Lowerer'monitorSnippets, this, lowerer)
            )
            nil
        )
    )

    (defm MonitorExitNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"MonitorExitNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (and (satisfies? VirtualObjectNode object) (:hasIdentity object))
                    (VirtualizerTool'''removeLock-2 tool, object)
                    (VirtualizerTool'''delete-1 tool)
                )
            )
            nil
        )
    )
)

;;;
 ; The RawMonitorEnterNode represents the acquisition of a monitor. The object needs to
 ; already be non-nil and the hub is an additional parameter to the node.
 ;;
(class-ns RawMonitorEnterNode [AccessMonitorNode, AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, DeoptBefore, DeoptimizingNode, DeoptAfter, Virtualizable, Lowerable, MonitorEnter, Single]
    (defn #_"RawMonitorEnterNode" RawMonitorEnterNode'new-3 [#_"ValueNode" object, #_"ValueNode" hub, #_"MonitorIdNode" monitorId]
        (merge (RawMonitorEnterNode'class.) (AccessMonitorNode'new-2 object, monitorId)
            (hash-map
                ; @Input
                #_"ValueNode" :hub hub
            )
        )
    )

    (defm RawMonitorEnterNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"RawMonitorEnterNode" this]
            LocationIdentity'ANY
        )
    )

    (defm RawMonitorEnterNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"RawMonitorEnterNode" this, #_"LoweringTool" lowerer]
            (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                (MonitorTemplates''lower-3i Lowerer'monitorSnippets, this, lowerer)
            )
            nil
        )
    )

    (defm RawMonitorEnterNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"RawMonitorEnterNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (and (satisfies? VirtualObjectNode object) (:hasIdentity object))
                    (VirtualizerTool'''addLock-3 tool, object, (:monitorId this))
                    (VirtualizerTool'''delete-1 tool)
                )
            )
            nil
        )
    )
)

;;;
 ; Represents an atomic read-and-add operation like {@link sun.misc.Unsafe#getAndAddInt(Object, long, int)}.
 ;;
(class-ns AtomicReadAndAddNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, LIRLowerable, Single]
    #_unused
    (defn #_"AtomicReadAndAddNode" AtomicReadAndAddNode'new-3 [#_"AddressNode" address, #_"ValueNode" delta, #_"LocationIdentity" locationIdentity]
        (merge (AtomicReadAndAddNode'class.) (AbstractMemoryCheckpoint'new-1 (StampFactory'forKind-1 (ValueNode''getStackKind-1 delta)))
            (hash-map
                ; @Input
                #_"AddressNode" :address address
                ; @Input
                #_"ValueNode" :delta delta
                #_"LocationIdentity" :locationIdentity locationIdentity
            )
        )
    )

    (defm AtomicReadAndAddNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"AtomicReadAndAddNode" this]
            (:locationIdentity this)
        )
    )

    (defm AtomicReadAndAddNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AtomicReadAndAddNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAtomicReadAndAdd-3 (:gen builder), (LIRBuilder''operand-2 builder, (:address this)), (LIRBuilder''operand-2 builder, (:delta this))))
            nil
        )
    )
)

;;;
 ; Represents an atomic read-and-write operation like {@link sun.misc.Unsafe#getAndSetInt(Object, long, int)}.
 ;;
(class-ns AtomicReadAndWriteNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, Lowerable, Single]
    #_unused
    (defn #_"AtomicReadAndWriteNode" AtomicReadAndWriteNode'new-5 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" newValue, #_"JavaKind" valueKind, #_"LocationIdentity" locationIdentity]
        (merge (AtomicReadAndWriteNode'class.) (AbstractMemoryCheckpoint'new-1 (StampFactory'forKind-1 (ValueNode''getStackKind-1 newValue)))
            (hash-map
                ; @Input
                #_"ValueNode" :object object
                ; @Input
                #_"ValueNode" :offset offset
                ; @Input
                #_"ValueNode" :newValue newValue
                #_"JavaKind" :valueKind valueKind
                #_"LocationIdentity" :locationIdentity locationIdentity
            )
        )
    )

    (defm AtomicReadAndWriteNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"AtomicReadAndWriteNode" this]
            (:locationIdentity this)
        )
    )

    (defm AtomicReadAndWriteNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"AtomicReadAndWriteNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"Graph" graph (:graph this)
                #_"JavaKind" valueKind (:valueKind this)
                #_"ValueNode" newValue (Lowerer'implicitStoreConvert-3 graph, valueKind, (:newValue this))
                #_"AddressNode" address (Graph''add-2 graph, (OffsetAddressNode'new-2 (:object this), (:offset this)))
                #_"BarrierType" barrierType (Lowerer'storeBarrierType-2 (:object this), (:newValue this))
                #_"LoweredAtomicReadAndWriteNode" memoryRead (Graph''add-2 graph, (LoweredAtomicReadAndWriteNode'new-4 address, (ร AtomicReadAndWriteNode''getLocationIdentity-1 this), newValue, barrierType))
            ]
                (StateSplit'''setStateAfter-2 memoryRead, (:stateAfter this))

                (let [
                    #_"ValueNode" readValue (Lowerer'implicitLoadConvert-3 graph, valueKind, memoryRead)
                ]
                    (Node''replaceFirstInput-3 (:stateAfter this), this, memoryRead)
                    (ยง ass! this (Node''replaceAtUsages-2 this, readValue))
                    (ยง ass! graph (Graph''replaceFixedWithFixed-3 graph, this, memoryRead))
                )
            )
            nil
        )
    )
)

;;;
 ; Intrinsic for opening a scope binding a stack-based lock with an object. A lock scope must be closed
 ; with an EndLockScopeNode. The frame state after this node denotes that the object is locked (ensuring
 ; the GC sees and updates the object) so it must come after any nil pointer check on the object.
 ;;
(class-ns BeginLockScopeNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, LIRLowerable, MonitorEnter, Single]
    (defn #_"BeginLockScopeNode" BeginLockScopeNode'new-2 [#_"JavaKind" kind, #_"int" lockDepth]
        (merge (BeginLockScopeNode'class.) (AbstractMemoryCheckpoint'new-1 (StampFactory'forKind-1 kind))
            (hash-map
                #_"int" :lockDepth lockDepth
            )
        )
    )

    (ยง intrinsic! #_"Word" BeginLockScopeNode'beginLockScope-1 [#_"int" lockDepth])

    #_intrinsifier
    (defn #_"BeginLockScopeNode" BeginLockScopeNode'new-1 [#_"int" lockDepth]
        (BeginLockScopeNode'new-2 WordTypes'wordKind, lockDepth)
    )

    (defm BeginLockScopeNode StateSplit
        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"BeginLockScopeNode" this]
            false
        )
    )

    (defm BeginLockScopeNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"BeginLockScopeNode" this]
            LocationIdentity'ANY
        )
    )

    (defm BeginLockScopeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"BeginLockScopeNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAddress-2 (:gen builder), (LIRGenerator''getLockSlot-2 (:gen builder), (:lockDepth this))))
            nil
        )
    )
)

;;;
 ; Intrinsic for closing a scope binding a stack-based lock with an object.
 ;;
(class-ns EndLockScopeNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, LIRLowerable, MonitorExit, Single]
    (ยง intrinsic! #_"void" EndLockScopeNode'endLockScope-0 [])

    #_intrinsifier
    (defn #_"EndLockScopeNode" EndLockScopeNode'new-0 []
        (merge (EndLockScopeNode'class.) (AbstractMemoryCheckpoint'new-1 VoidStamp'instance))
    )

    (defm EndLockScopeNode StateSplit
        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"EndLockScopeNode" this]
            false
        )
    )

    (defm EndLockScopeNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"EndLockScopeNode" this]
            LocationIdentity'ANY
        )
    )

    (defm EndLockScopeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"EndLockScopeNode" this, #_"LIRBuilder" builder]
            nil
        )
    )
)

;;;
 ; The InvokeNode represents all kinds of method calls.
 ;;
(class-ns InvokeNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, Lowerable, DeoptDuring, DeoptimizingNode, LIRLowerable, Single]
    (defn #_"InvokeNode" InvokeNode'new-3 [#_"CallTargetNode" callTarget, #_"int" bci, #_"Stamp" stamp]
        (merge (InvokeNode'class.) (AbstractMemoryCheckpoint'new-1 stamp)
            (hash-map
                ; @Input
                #_"CallTargetNode" :callTarget callTarget
                #_"int" :bci bci
                ; @OptionalInput
                #_"ValueNode" :classInit nil
                ; @OptionalInput
                #_"FrameState" :stateDuring nil
                #_"boolean" :useForInlining true
            )
        )
    )

    (defn #_"InvokeNode" InvokeNode'new-2 [#_"CallTargetNode" callTarget, #_"int" bci]
        (InvokeNode'new-3 callTarget, bci, (:returnStamp callTarget))
    )

    ;;;
     ; Returns the method from which this invoke is executed. This is the caller method and in
     ; the case of inlining it may be different from the method of the graph this node is in.
     ;;
    (defn #_"ResolvedJavaMethod" InvokeNode''getContextMethod-1 [#_"InvokeNode" this]
        (FrameState''getMethod-1 (or (:stateAfter this) (:stateDuring this)))
    )

    ;;;
     ; Returns the type from which this invoke is executed.
     ; This is the declaring type of the caller method.
     ;;
    (defn #_"ResolvedJavaType" InvokeNode''getContextType-1 [#_"InvokeNode" this]
        (let [
            #_"ResolvedJavaMethod" contextMethod (InvokeNode''getContextMethod-1 this)
        ]
            (when (some? contextMethod)
                (#_"ResolvedJavaMethod" .getDeclaringClass contextMethod)
            )
        )
    )

    (defm InvokeNode DeoptDuring
        (#_"void" DeoptDuring'''computeStateDuring-2 [#_"InvokeNode" this, #_"FrameState" stateAfter]
            (DeoptDuring'''setStateDuring-2 this, (FrameState''duplicateModifiedDuringCall-3 stateAfter, (:bci this), (ValueNode''getStackKind-1 this)))
            nil
        )
    )

    (defn #_"ValueNode" InvokeNode''getReceiver-1 [#_"InvokeNode" this]
        (nth (:arguments (:callTarget this)) 0)
    )

    (defn #_"ResolvedJavaType" InvokeNode''getReceiverType-1 [#_"InvokeNode" this]
        (or (StampTool'typeOrNull-1 (:stamp (InvokeNode''getReceiver-1 this)))
            (#_"ResolvedJavaMethod" .getDeclaringClass (:targetMethod (:callTarget this)))
        )
    )

    (defn #_"InvokeKind" InvokeNode''getInvokeKind-1 [#_"InvokeNode" this]
        (:invokeKind (:callTarget this))
    )

    (defm InvokeNode Node
        (#_"void" Node'''afterClone-2 [#_"InvokeNode" this, #_"Node" other]
            nil
        )
    )

    (defn #_"InvokeNode" InvokeNode''setUseForInlining-2 [#_"InvokeNode" this, #_"boolean" value]
        (assoc this :useForInlining value)
    )

    (defm InvokeNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"InvokeNode" this]
            LocationIdentity'ANY
        )
    )

    (defm InvokeNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"InvokeNode" this, #_"LoweringTool" lowerer]
            (when (satisfies? MethodCallTargetNode (:callTarget this))
                (let [
                    #_"MethodCallTargetNode" callTarget (:callTarget this)
                    #_"NodeInputList<ValueNode>" parameters (:arguments callTarget)
                    #_"ValueNode" receiver (first parameters)
                    receiver
                        (when (and (not (MethodCallTargetNode''isStatic-1 callTarget)) (satisfies? ObjectStamp (:stamp receiver)) (not (StampTool'isPointerNeverNull-1 (:stamp receiver)))) => receiver
                            (let [
                                receiver (Lowerer'createNullCheckedValue-3 receiver, this, lowerer)
                            ]
                                (#_"List" .set parameters, 0, receiver)
                                receiver
                            )
                        )
                    #_"JavaType[]" signature (#_"Signature" .toParameterTypes (#_"ResolvedJavaMethod" .getSignature (:targetMethod callTarget)), (when-not (MethodCallTargetNode''isStatic-1 callTarget) (#_"ResolvedJavaMethod" .getDeclaringClass (:targetMethod callTarget))))
                    #_"LoweredCallTargetNode" loweredCallTarget (Graph''add-2 (:graph this), (HotSpotDirectCallTargetNode'new-6 (into-array ValueNode'iface parameters), (:returnStamp callTarget), signature, (:targetMethod callTarget), HotSpotCallingConventionType/JavaCall, (:invokeKind callTarget)))
                ]
                    (ยง ass! callTarget (Node''replaceAndDelete-2 callTarget, loweredCallTarget))
                )
            )
            nil
        )
    )

    (defm InvokeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"InvokeNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''emitInvoke-2 builder, this)
            nil
        )
    )

    (defn #_"void" InvokeNode''intrinsify-2 [#_"InvokeNode" this, #_"Node" node]
        (let [
            #_"CallTargetNode" call (:callTarget this)
            #_"FrameState" currentStateAfter (:stateAfter this)
        ]
            (when (satisfies? StateSplit node)
                (StateSplit'''setStateAfter-2 node, currentStateAfter)
            )
            (condp satisfies? node
                FixedWithNextNode
                    (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, node))
                ControlSinkNode
                    (do
                        (Node''replaceAtPredecessor-2 this, node)
                        (ยง ass! this (Node''replaceAtUsages-2 this, nil))
                        (GraphUtil'killCFG-1 this)
                        (ยง return )
                    )
                #_else
                    (ยง ass! (:graph this) (Graph''replaceFixed-3 (:graph this), this, node))
            )
            (GraphUtil'killWithUnusedFloatingInputs-1 call)
            (when (Node''hasNoUsages-1 currentStateAfter)
                (GraphUtil'killWithUnusedFloatingInputs-1 currentStateAfter)
            )
        )
        nil
    )

    (defm InvokeNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"InvokeNode" this]
            true
        )
    )

    (defm InvokeNode DeoptDuring
        (#_"void" DeoptDuring'''setStateDuring-2 [#_"InvokeNode" this, #_"FrameState" stateDuring]
            (Node''updateUsages-3 this, (:stateDuring this), stateDuring)
            (ยง ass! this (assoc this :stateDuring stateDuring))
            nil
        )
    )

    (defn #_"this" InvokeNode''setClassInit-2 [#_"InvokeNode" this, #_"ValueNode" classInit]
        (let [
            this (assoc this :classInit classInit)
        ]
            (Node''updateUsages-3 this, nil, classInit)
            this
        )
    )
)

;;;
 ; Represents an atomic compare-and-swap operation The result is a boolean that contains whether the
 ; value matched the expected value.
 ;;
(class-ns UnsafeCompareAndSwapNode [AbstractMemoryCheckpoint, AbstractStateSplit, FixedWithNextNode, FixedNode, ValueNode, Node, StateSplit, NodeWithState, MemoryCheckpoint, MemoryNode, Lowerable, Single]
    #_unused
    (defn #_"UnsafeCompareAndSwapNode" UnsafeCompareAndSwapNode'new-6 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" expected, #_"ValueNode" newValue, #_"JavaKind" valueKind, #_"LocationIdentity" locationIdentity]
        (merge (UnsafeCompareAndSwapNode'class.) (AbstractMemoryCheckpoint'new-1 (StampFactory'forKind-1 (#_"JavaKind" .getStackKind JavaKind/Boolean)))
            (hash-map
                ; @Input
                #_"ValueNode" :object object
                ; @Input
                #_"ValueNode" :offset offset
                ; @Input
                #_"ValueNode" :expected expected
                ; @Input
                #_"ValueNode" :newValue newValue
                #_"JavaKind" :valueKind valueKind
                #_"LocationIdentity" :locationIdentity locationIdentity
            )
        )
    )

    (defm UnsafeCompareAndSwapNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"UnsafeCompareAndSwapNode" this]
            (:locationIdentity this)
        )
    )

    (defm UnsafeCompareAndSwapNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"UnsafeCompareAndSwapNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"Graph" graph (:graph this)
                #_"JavaKind" valueKind (:valueKind this)
                #_"ValueNode" expectedValue (Lowerer'implicitStoreConvert-3 graph, valueKind, (:expected this))
                #_"ValueNode" newValue (Lowerer'implicitStoreConvert-3 graph, valueKind, (:newValue this))
                #_"AddressNode" address (Graph''add-2 graph, (OffsetAddressNode'new-2 (:object this), (:offset this)))
                #_"BarrierType" barrierType (Lowerer'storeBarrierType-2 (:object this), expectedValue)
                #_"LogicCompareAndSwapNode" atomicNode (Graph''add-2 graph, (LogicCompareAndSwapNode'new-5 address, (ร UnsafeCompareAndSwapNode''getLocationIdentity-1 this), expectedValue, newValue, barrierType))
            ]
                (StateSplit'''setStateAfter-2 atomicNode, (:stateAfter this))
                (ยง ass! graph (Graph''replaceFixedWithFixed-3 graph, this, atomicNode))
            )
            nil
        )
    )
)

;;;
 ; This the base class of all array operations.
 ;;
(class-ns AccessArrayNode [FixedWithNextNode, FixedNode, ValueNode, Node]
    ;;;
     ; Creates a new AccessArrayNode.
     ;
     ; @param array the instruction that produces the array object value
     ;;
    (defn #_"AccessArrayNode" AccessArrayNode'new-2 [#_"Stamp" stamp, #_"ValueNode" array]
        (merge (AccessArrayNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :array array
            )
        )
    )
)

;;;
 ; The AccessIndexedNode class is the base class of instructions that read or write elements
 ; of an array.
 ;;
(class-ns AccessIndexedNode [AccessArrayNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"ValueNode" AccessIndexedNode''index-1 [#_"AccessIndexedNode" this]
        (:index this)
    )

    ;;;
     ; Create an new AccessIndexedNode.
     ;
     ; @param stamp the result kind of the access
     ; @param array the instruction producing the array
     ; @param index the instruction producing the index
     ; @param elementKind the kind of the elements of the array
     ;;
    (defn #_"AccessIndexedNode" AccessIndexedNode'new-4 [#_"Stamp" stamp, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (merge (AccessIndexedNode'class.) (AccessArrayNode'new-2 stamp, array)
            (hash-map
                ; @Input
                #_"ValueNode" :index index
                ;;;
                 ; The element type of the array.
                 ;;
                #_"JavaKind" :elementKind elementKind
            )
        )
    )

    ;;;
     ; Create a PiNode on the index proving that the index is positive. On some platforms this is
     ; important to allow the index to be used as an int in the address mode.
     ;;
    (defn- #_"AddressNode" AccessIndexedNode'createArrayIndexAddress-5 [#_"Graph" graph, #_"ValueNode" array, #_"JavaKind" elementKind, #_"ValueNode" index, #_"GuardingNode" boundsCheck]
        (let [
            #_"IntegerStamp" indexStamp (StampFactory'forInteger-3i 32, 0, (dec Integer/MAX_VALUE))
            #_"ValueNode" positiveIndex (Graph''maybeAddOrUnique-2 graph, (PiNode'create-3 index, indexStamp, (when (some? boundsCheck) boundsCheck)))
        ]
            (Lowerer'createArrayAddress-4 graph, array, elementKind, positiveIndex)
        )
    )

    (defn- #_"void" AccessIndexedNode''lowerLoadIndexedNode-2 [#_"LoadIndexedNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" array (Lowerer'createNullCheckedValue-3 (:array this), this, lowerer)
            #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp this), (:elementKind this), true)
            #_"GuardingNode" boundsCheck (Lowerer'getBoundsCheck-3 this, array, lowerer)
            #_"AddressNode" address (AccessIndexedNode'createArrayIndexAddress-5 (:graph this), array, (:elementKind this), (AccessIndexedNode''index-1 this), boundsCheck)
            #_"ReadNode" memoryRead (Graph''add-2 (:graph this), (ReadNode'new-4 address, (NamedLocationIdentity'getArrayLocation-1 (:elementKind this)), loadStamp, BarrierType'NONE))
        ]
            (GuardedNode'''setGuard-2 memoryRead, boundsCheck)
            (ยง ass! this (Node''replaceAtUsages-2 this, (Lowerer'implicitLoadConvert-3 (:graph this), (:elementKind this), memoryRead)))
            (ยง ass! (:graph this) (Graph''replaceFixed-3 (:graph this), this, memoryRead))
        )
        nil
    )

    (defn- #_"void" AccessIndexedNode''lowerStoreIndexedNode-2 [#_"StoreIndexedNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" array (Lowerer'createNullCheckedValue-3 (:array this), this, lowerer)
            #_"GuardingNode" boundsCheck (Lowerer'getBoundsCheck-3 this, array, lowerer)
            #_"LogicNode" logic
                (when (and (= (:elementKind this) JavaKind/Object) (not (StampTool'isPointerAlwaysNull-1 (:stamp (:value this)))))
                    ;; Array store check.
                    (let [
                        #_"TypeReference" arrayType (StampTool'typeReferenceOrNull-1 (:stamp array))
                    ]
                        (if (and (some? arrayType) (:exactReference arrayType))
                            (let [
                                #_"ResolvedJavaType" elementType (#_"ResolvedJavaType" .getComponentType (:type arrayType))
                            ]
                                (when-not (#_"ResolvedJavaType" .isJavaLangObject elementType)
                                    (let [
                                        #_"LogicNode" typeTest (Graph''addOrUniqueWithInputs-2 (:graph this), (InstanceOfNode'create-2 (TypeReference'createTrusted-1 elementType), (:value this)))
                                    ]
                                        (LogicNode'or-3 (Graph''add-2 (:graph this), (IsNullNode'create-1 (:value this))), typeTest, GraalDirectives'UNLIKELY_PROBABILITY)
                                    )
                                )
                            )
                            ;; The guard on the read hub should be the nil-check of the array that was introduced earlier.
                            (let [
                                #_"LogicNode" typeTest (Graph''add-2 (:graph this), (InstanceOfDynamicNode'create-3 (Lowerer'createReadArrayComponentHub-3 (:graph this), (Lowerer'createReadHub-3 (:graph this), array, lowerer), this), (:value this), false))
                            ]
                                (LogicNode'or-3 (Graph''add-2 (:graph this), (IsNullNode'create-1 (:value this))), typeTest, GraalDirectives'UNLIKELY_PROBABILITY)
                            )
                        )
                    )
                )
            #_"AddressNode" address (AccessIndexedNode'createArrayIndexAddress-5 (:graph this), array, (:elementKind this), (AccessIndexedNode''index-1 this), boundsCheck)
            #_"WriteNode" memoryWrite (Graph''add-2 (:graph this), (WriteNode'new-4 address, (NamedLocationIdentity'getArrayLocation-1 (:elementKind this)), (Lowerer'implicitStoreConvert-3 (:graph this), (:elementKind this), (:value this)), (Lowerer'arrayStoreBarrierType-1 (:elementKind this))))
        ]
            (GuardedNode'''setGuard-2 memoryWrite, boundsCheck)
            (when (some? logic)
                (LoweringTool''createGuard-5 lowerer, this, logic, DeoptimizationReason/ArrayStoreException, DeoptimizationAction/InvalidateReprofile)
            )
            (StateSplit'''setStateAfter-2 memoryWrite, (:stateAfter this))
            (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, memoryWrite))
        )
        nil
    )

    (defm AccessIndexedNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"AccessIndexedNode" this, #_"LoweringTool" lowerer]
            (condp satisfies? this
                LoadIndexedNode  (AccessIndexedNode''lowerLoadIndexedNode-2 this, lowerer)
                StoreIndexedNode (AccessIndexedNode''lowerStoreIndexedNode-2 this, lowerer)
            )
            nil
        )
    )
)

;;;
 ; The LoadIndexedNode represents a read from an element of an array.
 ;;
(class-ns LoadIndexedNode [AccessIndexedNode, AccessArrayNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, Virtualizable, Canonicalizable]
    (defn #_"LoadIndexedNode" LoadIndexedNode'new-4 [#_"Stamp" stamp, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (merge (LoadIndexedNode'class.) (AccessIndexedNode'new-4 stamp, array, index, elementKind))
    )

    (defn- #_"JavaKind" LoadIndexedNode'determinePreciseArrayElementType-2 [#_"ValueNode" array, #_"JavaKind" kind]
        (when (= kind JavaKind/Byte) => kind
            (let [
                #_"ResolvedJavaType" type (:type (:stamp array))
            ]
                (when (and (some? type) (#_"ResolvedJavaType" .isArray type) (some? (#_"ResolvedJavaType" .getComponentType type)) (= (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type)) JavaKind/Boolean)) => kind
                    JavaKind/Boolean
                )
            )
        )
    )

    (defn- #_"Stamp" LoadIndexedNode'createStamp-2 [#_"ValueNode" array, #_"JavaKind" kind]
        (let [
            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp array))
        ]
            (if (and (= kind JavaKind/Object) (some? type) (#_"ResolvedJavaType" .isArray type))
                (StampFactory'object-1 (TypeReference'createTrusted-1 (#_"ResolvedJavaType" .getComponentType type)))
                (StampFactory'forKind-1 (LoadIndexedNode'determinePreciseArrayElementType-2 array, kind))
            )
        )
    )

    ;;;
     ; Creates a new LoadIndexedNode.
     ;
     ; @param array the instruction producing the array
     ; @param index the instruction producing the index
     ; @param elementKind the element type
     ;;
    (defn #_"LoadIndexedNode" LoadIndexedNode'new-3 [#_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (LoadIndexedNode'new-4 (LoadIndexedNode'createStamp-2 array, elementKind), array, index, elementKind)
    )

    (defn- #_"ValueNode" LoadIndexedNode'tryConstantFold-2 [#_"ValueNode" array, #_"ValueNode" index]
        (when (and (satisfies? ConstantNode array) (not (ValueNode''isNullConstant-1 array)) (satisfies? ConstantNode index))
            (let [
                #_"JavaConstant" arrayConstant (ValueNode''asJavaConstant-1 array)
            ]
                (when (and (some? arrayConstant) (pos? (:stableDimension array)))
                    (let [
                        #_"JavaConstant" constant (#_"ConstantReflectionProvider" .readArrayElement HotSpot'constantReflection, arrayConstant, (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 index)))
                    ]
                        (when (and (some? constant) (or (:isDefaultStable array) (not (#_"JavaConstant" .isDefaultForKind constant))))
                            (ConstantNode'forConstant-3c constant, (dec (:stableDimension array)), (:isDefaultStable array))
                        )
                    )
                )
            )
        )
    )

    (defn #_"ValueNode" LoadIndexedNode'create-3 [#_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (or (LoadIndexedNode'tryConstantFold-2 array, index)
            (LoadIndexedNode'new-3 array, index, elementKind)
        )
    )

    (defm LoadIndexedNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"LoadIndexedNode" this]
            (ValueNode''updateStamp-2 this, (Stamp'''improveWith-2 (:stamp this), (LoadIndexedNode'createStamp-2 (:array this), (:elementKind this))))
        )
    )

    (defm LoadIndexedNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"LoadIndexedNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" array (VirtualizerTool'''getAlias-2 tool, (:array this))
            ]
                (when (satisfies? VirtualObjectNode array)
                    (let [
                        #_"ValueNode" index (VirtualizerTool'''getAlias-2 tool, (AccessIndexedNode''index-1 this))
                        #_"int" i (if (satisfies? ConstantNode index) (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 index)) -1)
                    ]
                        (when (< -1 i (VirtualObjectNode'''entryCount-1 array))
                            (let [
                                #_"ValueNode" entry (VirtualizerTool'''getEntry-3 tool, array, i)
                            ]
                                (when (Stamp'''isCompatible-2s (:stamp this), (:stamp entry))
                                    (VirtualizerTool'''replaceWith-2 tool, entry)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defm LoadIndexedNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"LoadIndexedNode" this, #_"CanonicalizerTool" tool]
            (or (LoadIndexedNode'tryConstantFold-2 (:array this), (AccessIndexedNode''index-1 this))
                this
            )
        )
    )
)

(class-ns LoadIndexedPointerNode [LoadIndexedNode, AccessIndexedNode, AccessArrayNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, Virtualizable, Canonicalizable]
    (defn #_"LoadIndexedPointerNode" LoadIndexedPointerNode'new-3 [#_"Stamp" stamp, #_"ValueNode" array, #_"ValueNode" index]
        (merge (LoadIndexedPointerNode'class.) (LoadIndexedNode'new-4 stamp, array, index, JavaKind/Illegal))
    )

    (defm LoadIndexedPointerNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"LoadIndexedPointerNode" this]
            false
        )
    )
)

;;;
 ; The StoreIndexedNode represents a write to an array element.
 ;;
(class-ns StoreIndexedNode [AccessIndexedNode, AccessArrayNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, StateSplit, NodeWithState, Virtualizable]
    (defm StoreIndexedNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"StoreIndexedNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"StoreIndexedNode" this]
            true
        )
    )

    (defn #_"StoreIndexedNode" StoreIndexedNode'new-4 [#_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
        (merge (StoreIndexedNode'class.) (AccessIndexedNode'new-4 VoidStamp'instance, array, index, elementKind)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
            )
        )
    )

    (defm StoreIndexedNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"StoreIndexedNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" array (VirtualizerTool'''getAlias-2 tool, (:array this))
            ]
                (when (satisfies? VirtualObjectNode array)
                    (let [
                        #_"ValueNode" index (VirtualizerTool'''getAlias-2 tool, (AccessIndexedNode''index-1 this))
                        #_"int" i (if (satisfies? ConstantNode index) (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 index)) -1)
                    ]
                        (when (< -1 i (VirtualObjectNode'''entryCount-1 array))
                            (let [
                                #_"ResolvedJavaType" componentType (#_"ResolvedJavaType" .getComponentType (VirtualObjectNode'''type-1 array))
                            ]
                                (when (or (#_"ResolvedJavaType" .isPrimitive componentType) (StampTool'isPointerAlwaysNull-1 (:stamp (:value this))) (nil? (#_"ResolvedJavaType" .getSuperclass componentType)) (and (some? (StampTool'typeReferenceOrNull-1 (:stamp (:value this)))) (#_"ResolvedJavaType" .isAssignableFrom componentType, (StampTool'typeOrNull-1 (:stamp (:value this))))))
                                    (VirtualizerTool'''setVirtualEntry-4 tool, array, i, (:value this))
                                    (VirtualizerTool'''delete-1 tool)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; The base class of all instructions that access fields.
 ;;
(class-ns AccessFieldNode [FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    ;;;
     ; Constructs a new access field object.
     ;
     ; @param object the instruction producing the receiver object
     ; @param field the compiler interface representation of the field
     ;;
    (defn #_"AccessFieldNode" AccessFieldNode'new-3 [#_"Stamp" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (merge (AccessFieldNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @OptionalInput
                #_"ValueNode" :object object
                ;;;
                 ; The compiler interface field for this field access.
                 ;;
                #_"ResolvedJavaField" :field field
            )
        )
    )

    (defn #_"boolean" AccessFieldNode''isStatic-1   [#_"AccessFieldNode" this] (#_"ResolvedJavaField" .isStatic   (:field this)))
    (defn #_"boolean" AccessFieldNode''isVolatile-1 [#_"AccessFieldNode" this] (#_"ResolvedJavaField" .isVolatile (:field this)))

    (defn- #_"ValueNode" AccessFieldNode'staticFieldBase-2 [#_"Graph" graph, #_"ResolvedJavaField" field]
        (ConstantNode'forConstant-2c (#_"HotSpotConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"HotSpotResolvedJavaField" .getDeclaringClass field)), graph)
    )

    (defn- #_"void" AccessFieldNode''lowerLoadFieldNode-2 [#_"LoadFieldNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" object (if (AccessFieldNode''isStatic-1 this) (AccessFieldNode'staticFieldBase-2 (:graph this), (:field this)) (:object this))
            object (Lowerer'createNullCheckedValue-3 object, this, lowerer)
            #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp this), (#_"ResolvedJavaField" .getJavaKind (:field this)), true)
            #_"AddressNode" address (Lowerer'createFieldAddress-3 (:graph this), object, (:field this))
            #_"ReadNode" memoryRead (Graph''add-2 (:graph this), (ReadNode'new-4 address, (FieldLocationIdentity'new-1 (:field this)), loadStamp, (Lowerer'fieldLoadBarrierType-1 (:field this))))
            #_"ValueNode" readValue (Lowerer'implicitLoadConvert-3 (:graph this), (#_"ResolvedJavaField" .getJavaKind (:field this)), memoryRead)
        ]
            (ยง ass! this (Node''replaceAtUsages-2 this, readValue))
            (ยง ass! (:graph this) (Graph''replaceFixed-3 (:graph this), this, memoryRead))

            (when (AccessFieldNode''isVolatile-1 this)
                (Graph''addBeforeFixed-3 (:graph this), memoryRead, (Graph''add-2 (:graph this), (MembarNode'new-1 MemoryBarriers/JMM_PRE_VOLATILE_READ)))
                (Graph''addAfterFixed-3 (:graph this), memoryRead, (Graph''add-2 (:graph this), (MembarNode'new-1 MemoryBarriers/JMM_POST_VOLATILE_READ)))
            )
        )
        nil
    )

    (defn- #_"void" AccessFieldNode''lowerStoreFieldNode-2 [#_"StoreFieldNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" object (if (AccessFieldNode''isStatic-1 this) (AccessFieldNode'staticFieldBase-2 (:graph this), (:field this)) (:object this))
            object (Lowerer'createNullCheckedValue-3 object, this, lowerer)
            #_"ValueNode" value (Lowerer'implicitStoreConvert-3 (:graph this), (#_"ResolvedJavaField" .getJavaKind (:field this)), (:value this))
            #_"AddressNode" address (Lowerer'createFieldAddress-3 (:graph this), object, (:field this))
            #_"WriteNode" memoryWrite (Graph''add-2 (:graph this), (WriteNode'new-4 address, (FieldLocationIdentity'new-1 (:field this)), value, (Lowerer'fieldStoreBarrierType-1 (:field this))))
        ]
            (StateSplit'''setStateAfter-2 memoryWrite, (:stateAfter this))
            (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, memoryWrite))

            (when (AccessFieldNode''isVolatile-1 this)
                (Graph''addBeforeFixed-3 (:graph this), memoryWrite, (Graph''add-2 (:graph this), (MembarNode'new-1 MemoryBarriers/JMM_PRE_VOLATILE_WRITE)))
                (Graph''addAfterFixed-3 (:graph this), memoryWrite, (Graph''add-2 (:graph this), (MembarNode'new-1 MemoryBarriers/JMM_POST_VOLATILE_WRITE)))
            )
        )
        nil
    )

    (defm AccessFieldNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"AccessFieldNode" this, #_"LoweringTool" lowerer]
            (condp satisfies? this
                LoadFieldNode  (AccessFieldNode''lowerLoadFieldNode-2 this, lowerer)
                StoreFieldNode (AccessFieldNode''lowerStoreFieldNode-2 this, lowerer)
            )
            nil
        )
    )
)

;;;
 ; The LoadFieldNode represents a read of a static or instance field.
 ;;
(class-ns LoadFieldNode [AccessFieldNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, Unary #_"<ValueNode>", Canonicalizable, Virtualizable]
    (defn #_"LoadFieldNode" LoadFieldNode'new-3 [#_"Stamp" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (merge (LoadFieldNode'class.) (AccessFieldNode'new-3 stamp, object, field))
    )

    (defn #_"LoadFieldNode" LoadFieldNode'create-2 [#_"ValueNode" object, #_"ResolvedJavaField" field]
        (LoadFieldNode'new-3 (StampFactory'forDeclaredType-2 (#_"ResolvedJavaField" .getType field), false), object, field)
    )

    (defn #_"LoadFieldNode" LoadFieldNode'createOverrideStamp-3 [#_"Stamp" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (LoadFieldNode'new-3 stamp, object, field)
    )

    (defn- #_"ConstantNode" LoadFieldNode'asConstant-2 [#_"ValueNode" forObject, #_"ResolvedJavaField" field]
        (cond
            (#_"ResolvedJavaField" .isStatic field)
                (ConstantFields'tryConstantFold-2 field, nil)
            (and (satisfies? ConstantNode forObject) (not (ValueNode''isNullConstant-1 forObject)))
                (ConstantFields'tryConstantFold-2 field, (ValueNode''asJavaConstant-1 forObject))
        )
    )

    (defn- #_"PhiNode" LoadFieldNode'asPhi-3 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"Stamp" stamp]
        (when (and (not (#_"ResolvedJavaField" .isStatic field)) (#_"ResolvedJavaField" .isFinal field) (satisfies? ValuePhiNode object) (empty? (remove #(satisfies? ConstantNode %) (:values object))))
            (let [
                #_"ConstantNode[]" constantNodes (make-array ConstantNode'iface (PhiNode''valueCount-1 object))
            ]
                (loop-when [#_"int" i 0] (< i (PhiNode''valueCount-1 object)) => (ValuePhiNode'new-3 stamp, (:merge object), constantNodes)
                    (let [
                        #_"ConstantNode" constant (ConstantFields'tryConstantFold-2 field, (ValueNode''asJavaConstant-1 (PhiNode''valueAt-2i object, i)))
                    ]
                        (when (some? constant)
                            (aset constantNodes i constant)
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )

    (defn- #_"ValueNode" LoadFieldNode'canonical-6 [#_"LoadFieldNode" self, #_"Stamp" stamp, #_"ValueNode" forObject, #_"ResolvedJavaField" field, #_"boolean" canonicalizeReads, #_"boolean" allUsagesAvailable]
        (or
            (when canonicalizeReads
                (or
                    (LoadFieldNode'asConstant-2 forObject, field)
                    (when allUsagesAvailable
                        (LoadFieldNode'asPhi-3 forObject, field, stamp)
                    )
                )
            )
            (if (and (some? self) (not (#_"ResolvedJavaField" .isStatic field)) (ValueNode''isNullConstant-1 forObject))
                (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/NullCheckException)
                (or self (LoadFieldNode'new-3 stamp, forObject, field))
            )
        )
    )

    (defn #_"ValueNode" LoadFieldNode'create-4 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"boolean" canonicalizeReads, #_"boolean" allUsagesAvailable]
        (LoadFieldNode'canonical-6 nil, (StampFactory'forDeclaredType-2 (#_"ResolvedJavaField" .getType field), false), object, field, canonicalizeReads, allUsagesAvailable)
    )

    (defn #_"ValueNode" LoadFieldNode'createOverrideStamp-5 [#_"Stamp" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"boolean" canonicalizeReads, #_"boolean" allUsagesAvailable]
        (LoadFieldNode'canonical-6 nil, stamp, object, field, canonicalizeReads, allUsagesAvailable)
    )

    (defm LoadFieldNode Unary
        (#_"ValueNode" Unary'''getValue-1 [#_"LoadFieldNode" this]
            (:object this)
        )

        (#_"ValueNode" Unary'''canonical-3 [#_"LoadFieldNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forObject]
            (when-not (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this) (not (AccessFieldNode''isVolatile-1 this)) (or (AccessFieldNode''isStatic-1 this) (StampTool'isPointerNeverNull-1 (:stamp forObject))))
                (LoadFieldNode'canonical-6 this, (:stamp this), forObject, (:field this), (CanonicalizerTool'''canonicalizeReads-1 tool), (CanonicalizerTool'''allUsagesAvailable-1 tool))
            )
        )
    )

    (defm LoadFieldNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"LoadFieldNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )

    (defm LoadFieldNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"LoadFieldNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (satisfies? VirtualObjectNode object)
                    (let [
                        #_"int" i (VirtualInstanceNode''fieldIndex-2 object, (:field this))
                    ]
                        (when-not (= i -1)
                            (let [
                                #_"ValueNode" entry (VirtualizerTool'''getEntry-3 tool, object, i)
                            ]
                                (when (Stamp'''isCompatible-2s (:stamp this), (:stamp entry))
                                    (VirtualizerTool'''replaceWith-2 tool, entry)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; The StoreFieldNode represents a write to a static or instance field.
 ;;
(class-ns StoreFieldNode [AccessFieldNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, StateSplit, NodeWithState, Virtualizable]
    (defn #_"StoreFieldNode" StoreFieldNode'new-4 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value, #_"FrameState" state]
        (merge (StoreFieldNode'class.) (AccessFieldNode'new-3 VoidStamp'instance, object, field)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                ; @OptionalInput
                #_"FrameState" :stateAfter state
            )
        )
    )

    (defn #_"StoreFieldNode" StoreFieldNode'new-3 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (StoreFieldNode'new-4 object, field, value, nil)
    )

    (defm StoreFieldNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"StoreFieldNode" this, #_"FrameState" state]
            (Node''updateUsages-3 this, (:stateAfter this), state)
            (ยง ass! this (assoc this :stateAfter state))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"StoreFieldNode" this]
            true
        )
    )

    (defm StoreFieldNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"StoreFieldNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (satisfies? VirtualObjectNode object)
                    (let [
                        #_"int" i (VirtualInstanceNode''fieldIndex-2 object, (:field this))
                    ]
                        (when-not (= i -1)
                            (VirtualizerTool'''setVirtualEntry-4 tool, object, i, (:value this))
                            (VirtualizerTool'''delete-1 tool)
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Marks the control flow path where an object acquired a lightweight lock based on an atomic
 ; compare-and-swap (CAS) of the mark word in the object's header.
 ;;
(class-ns AcquiredCASLockNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    (ยง intrinsic! #_"void" AcquiredCASLockNode'mark-1 [#_"Object" object])

    #_intrinsifier
    (defn #_"AcquiredCASLockNode" AcquiredCASLockNode'new-1 [#_"ValueNode" object]
        (merge (AcquiredCASLockNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defm AcquiredCASLockNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AcquiredCASLockNode" this, #_"LIRBuilder" builder]
            ;; this is just a marker node, so it generates nothing
            nil
        )
    )
)

;;;
 ; The ArrayLength instruction gets the length of an array.
 ;;
(class-ns ArrayLengthNode [FixedWithNextNode, FixedNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, Lowerable, Virtualizable]
    (defn #_"ArrayLengthNode" ArrayLengthNode'new-1 [#_"ValueNode" array]
        (merge (ArrayLengthNode'class.) (FixedWithNextNode'new-1 StampFactory'nonNegativeInt)
            (hash-map
                ; @Input
                #_"ValueNode" :array array
            )
        )
    )

    (defn- #_"ValueNode" ArrayLengthNode'readArrayLengthConstant-1 [#_"ValueNode" originalArray]
        (let [
            #_"ValueNode" array (GraphUtil'unproxify-1n originalArray)
        ]
            (when (and (some? HotSpot'constantReflection) (satisfies? ConstantNode array) (not (ValueNode''isNullConstant-1 array)))
                (let [
                    #_"JavaConstant" constantValue (ValueNode''asJavaConstant-1 array)
                ]
                    (when (and (some? constantValue) (#_"JavaConstant" .isNonNull constantValue))
                        (let [
                            #_"Integer" constantLength (#_"ConstantReflectionProvider" .readArrayLength HotSpot'constantReflection, constantValue)
                        ]
                            (when (some? constantLength)
                                (ConstantNode'forInt-1 constantLength)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"ValueNode" ArrayLengthNode'create-1 [#_"ValueNode" value]
        (when-not (satisfies? NewArrayNode value) => (ArrayLengthProvider'''length-1 value)
            (or (ArrayLengthNode'readArrayLengthConstant-1 value)
                (ArrayLengthNode'new-1 value)
            )
        )
    )

    (defm ArrayLengthNode Unary
        (#_"ValueNode" Unary'''getValue-1 [#_"ArrayLengthNode" this]
            (:array this)
        )

        (#_"ValueNode" Unary'''canonical-3 [#_"ArrayLengthNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (ArrayLengthNode'readArrayLength-1 value)
                this
            )
        )
    )

    (defm ArrayLengthNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"ArrayLengthNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )

    ;;;
     ; Replicate the ValueProxyNodes from {@code originalValue} onto {@code value}.
     ;
     ; @param originalValue a possibly proxied value
     ; @param value a value needing proxies
     ; @return proxies wrapping {@code value}
     ;;
    (defn- #_"ValueNode" ArrayLengthNode'reproxyValue-2 [#_"ValueNode" originalValue, #_"ValueNode" value]
        (if (satisfies? ConstantNode value)
            value ;; no proxy needed
            (condp satisfies? originalValue
                ValueProxyNode
                    (ValueProxyNode'new-2 (ArrayLengthNode'reproxyValue-2 (Proxy'''getOriginalNode-1 originalValue), value), (:loopExit originalValue))
                ValueProxy
                    (ArrayLengthNode'reproxyValue-2 (Proxy'''getOriginalNode-1 originalValue), value)
                value
            )
        )
    )

    ;;;
     ; Gets the length of an array if possible.
     ;
     ; @return a node representing the length of {@code array} or nil if it is not available
     ;;
    (defn #_"ValueNode" ArrayLengthNode'readArrayLength-1 [#_"ValueNode" originalArray]
        (let [
            #_"ValueNode" length (GraphUtil'arrayLength-1 originalArray)
        ]
            (if (some? length)
                ;; ensure that any proxies on the original value end up on the length value
                (ArrayLengthNode'reproxyValue-2 originalArray, length)
                (ArrayLengthNode'readArrayLengthConstant-1 originalArray)
            )
        )
    )

    (defm ArrayLengthNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"ArrayLengthNode" this, #_"LoweringTool" lowerer]
            (ยง ass! this (Node''replaceAtUsages-2 this, (Lowerer'createReadArrayLength-3 (:array this), this, lowerer)))
            (Graph''removeFixed-2 (:graph this), this)
            nil
        )
    )

    (defm ArrayLengthNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"ArrayLengthNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" array (VirtualizerTool'''getAlias-2 tool, (:array this))
            ]
                (when (satisfies? VirtualArrayNode array)
                    (VirtualizerTool'''replaceWithValue-2 tool, (ConstantNode'forInt-2 (VirtualObjectNode'''entryCount-1 array), (:graph this)))
                )
            )
            nil
        )
    )
)

(class-ns BindToRegisterNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    #_unused
    (defn #_"BindToRegisterNode" BindToRegisterNode'new-1 [#_"ValueNode" value]
        (merge (BindToRegisterNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
            )
        )
    )

    (defm BindToRegisterNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"BindToRegisterNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''append-2 (:gen builder), (BindToRegisterOp'new-1 (LIRGenerator''asAllocatable-2 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)))))
            nil
        )
    )
)

(class-ns BlackholeNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    #_unused
    (defn #_"BlackholeNode" BlackholeNode'new-1 [#_"ValueNode" value]
        (merge (BlackholeNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
            )
        )
    )

    (defm BlackholeNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"BlackholeNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitBlackhole-2 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)))
            nil
        )
    )
)

;;;
 ; This node represents the boxing of a primitive value. This corresponds to a call to the valueOf
 ; methods in Integer, Long, etc.
 ;;
(class-ns BoxNode [FixedWithNextNode, FixedNode, ValueNode, Node, VirtualizableAllocation, Virtualizable, Lowerable, Unary #_"<ValueNode>", Canonicalizable]
    (defn #_"BoxNode" BoxNode'new-3 [#_"ValueNode" value, #_"ResolvedJavaType" resultType, #_"JavaKind" boxingKind]
        (merge (BoxNode'class.) (FixedWithNextNode'new-1 (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 resultType)))
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                #_"JavaKind" :boxingKind boxingKind
            )
        )
    )

    (defm BoxNode Unary
        (#_"ValueNode" Unary'''getValue-1 [#_"BoxNode" this]
            (:value this)
        )
    )

    (defm BoxNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"BoxNode" this, #_"LoweringTool" lowerer]
            (BoxingTemplates''lower-3b Lowerer'boxingSnippets, this, lowerer)
            nil
        )
    )

    (defm BoxNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"BoxNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (when-not (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                this
            )
        )
    )

    (defm BoxNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"BoxNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )

    (defn #_"VirtualBoxingNode" BoxNode''createVirtualBoxingNode-1 [#_"BoxNode" this]
        (VirtualBoxingNode'new-2 (StampTool'typeOrNull-1 (:stamp this)), (:boxingKind this))
    )

    (defm BoxNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"BoxNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" alias (VirtualizerTool'''getAlias-2 tool, (Unary'''getValue-1 this))
                #_"VirtualBoxingNode" newVirtual (BoxNode''createVirtualBoxingNode-1 this)
            ]
                (VirtualizerTool'''createVirtualObject-5 tool, newVirtual, (into-array ValueNode'iface [ alias ]), #_"<MonitorIdNode>" (Collections/emptyList), false)
                (VirtualizerTool'''replaceWithVirtual-2 tool, newVirtual)
            )
            nil
        )
    )
)

(class-ns CommitAllocationNode [FixedWithNextNode, FixedNode, ValueNode, Node, VirtualizableAllocation, Virtualizable, Lowerable, Simplifiable, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"CommitAllocationNode" CommitAllocationNode'new-0 []
        (merge (CommitAllocationNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"NodeInputList<VirtualObjectNode>" :virtualObjects (NodeInputList'new-1 (ร this))
                ; @Input
                #_"NodeInputList<ValueNode>" :values (NodeInputList'new-1 (ร this))
                ; @Input
                #_"NodeInputList<MonitorIdNode>" :locks (NodeInputList'new-1 (ร this))
                #_"ArrayList<Integer>" :lockIndexes (ArrayList. (Arrays/asList 0))
                #_"ArrayList<Boolean>" :ensureVirtual (ArrayList.)
            )
        )
    )

    (defn #_"void" CommitAllocationNode''addLocks-2 [#_"CommitAllocationNode" this, #_"List<MonitorIdNode>" monitorIds]
        (#_"List" .addAll (:locks this), monitorIds)
        (#_"ArrayList" .add (:lockIndexes this), (count (:locks this)))
        nil
    )

    (defn #_"List<MonitorIdNode>" CommitAllocationNode''getLocks-2 [#_"CommitAllocationNode" this, #_"int" i]
        (#_"List" .subList (:locks this), (nth (:lockIndexes this) i), (nth (:lockIndexes this) (inc i)))
    )

    ;;;
     ; Insert the required MemoryBarriers#STORE_STORE barrier for an allocation and also include
     ; the MemoryBarriers#LOAD_STORE required for final fields if any final fields are being written,
     ; as if FinalFieldBarrierNode were emitted.
     ;;
    (defn- #_"void" CommitAllocationNode''insertAllocationBarrier-1 [#_"CommitAllocationNode" this]
        (let [
            #_"boolean" final?
                (loop-when [#_"ISeq" s (seq (:virtualObjects this))] (some? s) => false
                    (or
                        (loop-when [#_"ISeq" s (seq (#_"ResolvedJavaType" .getInstanceFields (VirtualObjectNode'''type-1 (first s)), true))] (some? s) => false
                            (or
                                (#_"ResolvedJavaField" .isFinal (first s))
                                (recur (next s))
                            )
                        )
                        (recur (next s))
                    )
                )
            #_"int" barrier (| MemoryBarriers/STORE_STORE (if final? MemoryBarriers/LOAD_STORE 0))
        ]
            (Graph''addAfterFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (MembarNode'new-2 barrier, LocationIdentity'INIT)))
        )
        nil
    )

    (defn- #_"void" CommitAllocationNode''finishAllocatedObjects-3 [#_"CommitAllocationNode" this, #_"LoweringTool" lowerer, #_"ValueNode[]" allocations]
        (dotimes [#_"int" i (count (:virtualObjects this))]
            (let [
                #_"FixedValueAnchorNode" anchor (Graph''add-2 (:graph this), (FixedValueAnchorNode'new-1 (nth allocations i)))
            ]
                (ยง aset! allocations i anchor)
                (Graph''addBeforeFixed-3 (:graph this), this, anchor)
            )
        )
        ;; Note that the FrameState that is assigned to these MonitorEnterNodes isn't the correct state.
        ;; It will be the state from before the allocation occurred instead of a valid state after the
        ;; locking is performed. In practice this should be fine since these are newly allocated objects.
        ;; The bytecodes themselves permit allocating an object, doing a monitorenter and then dropping
        ;; all references to the object which would produce the same state, though that would normally
        ;; produce an IllegalMonitorStateException. In HotSpot some form of fast path locking should
        ;; always occur so the FrameState should never actually be used.
        (let [
            #_"[MonitorEnterNode]" enters
                (loop-when [enters nil #_"int" i 0] (< i (count (:virtualObjects this))) => enters
                    (let [
                        #_"MonitorIdNode*" locks (CommitAllocationNode''getLocks-2 this, i)
                        ;; ensure that the lock operations are performed in lock depth order
                        locks
                            (when (< 1 (count locks)) => locks
                                (sort-by :lockDepth locks)
                            )
                        enters
                            (loop-when [enters enters #_"ISeq" s (seq locks)] (some? s) => enters
                                (let [
                                    #_"MonitorEnterNode" enter (Graph''add-2 (:graph this), (MonitorEnterNode'new-2 (nth allocations i), (first s)))
                                ]
                                    (Graph''addBeforeFixed-3 (:graph this), this, enter)
                                    (recur (conj (vec enters) enter) (next s))
                                )
                            )
                    ]
                        (recur enters (inc i))
                    )
                )
        ]
            (doseq [#_"Node" usage (:nodeUsages this)]
                (if (satisfies? AllocatedObjectNode usage)
                    (ยง ass! usage (Node''replaceAtUsagesAndDelete-2 usage, (nth allocations (#_"List" .indexOf (:virtualObjects this), (:virtualObject usage)))))
                    (Node''replaceAtUsages-3 this, InputType'Memory, (peek enters))
                )
            )
            (doseq [#_"MonitorEnterNode" enter enters]
                (Lowerable'''lower-2 enter, lowerer)
            )
            (CommitAllocationNode''insertAllocationBarrier-1 this)
        )
        nil
    )

    (defn- #_"void" CommitAllocationNode'ensureVirtualFailure-2 [#_"Node" location, #_"Stamp" stamp]
        (let [
            #_"String" additionalReason
                (when (satisfies? FixedWithNextNode location) => ""
                    (let [
                        #_"FixedNode" _next (:next location)
                    ]
                        (condp satisfies? _next
                            StoreFieldNode " (must not store virtual object into a field)"
                            InvokeNode     " (must not pass virtual object into an invoke that cannot be inlined)"
                                      (str " (must not let virtual object escape at node " _next ")")
                        )
                    )
                )
        ]
            (throw! (str "instance of type " (#_"ResolvedJavaType" .getName (StampTool'typeOrNull-1 stamp)) " should not be materialized" additionalReason))
        )
        nil
    )

    (defm CommitAllocationNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"CommitAllocationNode" this, #_"LoweringTool" lowerer]
            (dotimes [#_"int" i (count (:virtualObjects this))]
                (when (nth (:ensureVirtual this) i)
                    (CommitAllocationNode'ensureVirtualFailure-2 this, (:stamp (nth (:virtualObjects this) i)))
                )
            )
            (when (= (:guardsStage (:graph this)) GuardsStage'FIXED_DEOPTS)
                (let [
                    #_"List<AbstractNewObjectNode>" recursiveLowerings (ArrayList.)
                    #_"ValueNode[]" allocations (make-array ValueNode'iface (count (:virtualObjects this)))
                    #_"BitSet" omittedValues (BitSet.)
                ]
                    (loop-when [#_"int" valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects this)))
                        (let [
                            #_"VirtualObjectNode" virtual (nth (:virtualObjects this) objIndex)
                            #_"int" entryCount (VirtualObjectNode'''entryCount-1 virtual)
                            #_"AbstractNewObjectNode" newObject
                                (if (satisfies? VirtualInstanceNode virtual)
                                    (Graph''add-2 (:graph this), (NewInstanceNode'new-1 (VirtualObjectNode'''type-1 virtual)))
                                    (Graph''add-2 (:graph this), (NewArrayNode'new-2 (:componentType virtual), (ConstantNode'forInt-2 entryCount, (:graph this))))
                                )
                        ]
                            (#_"List" .add recursiveLowerings, newObject)
                            (Graph''addBeforeFixed-3 (:graph this), this, newObject)
                            (aset allocations objIndex newObject)
                            (let [
                                valuePos
                                    (loop-when [valuePos valuePos #_"int" i 0] (< i entryCount) => valuePos
                                        (let [
                                            #_"ValueNode" value (nth (:values this) valuePos)
                                            value
                                                (when (satisfies? VirtualObjectNode value) => value
                                                    (nth allocations (#_"List" .indexOf (:virtualObjects this), value))
                                                )
                                        ]
                                            (cond
                                                (nil? value)
                                                    (#_"BitSet" .set omittedValues, valuePos)
                                                (not (and (satisfies? ConstantNode value) (#_"Constant" .isDefaultForKind (:value value))))
                                                    ;; Constant.illegal is always the defaultForKind, so it is skipped
                                                    (let [
                                                        #_"JavaKind" valueKind (ValueNode''getStackKind-1 value)
                                                        #_"JavaKind" entryKind (VirtualObjectNode'''entryKind-2 virtual, i)
                                                        [#_"AddressNode" address #_"BarrierType" barrierType]
                                                            (if (satisfies? VirtualInstanceNode virtual)
                                                                (let [
                                                                    #_"long" offset (#_"HotSpotResolvedJavaField" .offset (VirtualInstanceNode''field-2 virtual, i))
                                                                ]
                                                                    (when (<= 0 offset)
                                                                        [(Lowerer'createOffsetAddress-3 (:graph this), newObject, offset) (Lowerer'fieldInitializationBarrier-1 entryKind)]
                                                                    )
                                                                )
                                                                [(Lowerer'createOffsetAddress-3 (:graph this), newObject, (+ (HotSpot'arrayBaseOffset-1 entryKind) (* i (HotSpot'arrayIndexScale-1 entryKind)))) (Lowerer'arrayInitializationBarrier-1 entryKind)]
                                                            )
                                                    ]
                                                        (when (some? address)
                                                            (Graph''addAfterFixed-3 (:graph this), newObject, (Graph''add-2 (:graph this), (WriteNode'new-4 address, LocationIdentity'INIT, (Lowerer'implicitStoreConvert-3 (:graph this), entryKind, value), barrierType)))
                                                        )
                                                    )
                                            )
                                            (recur (inc valuePos) (inc i))
                                        )
                                    )
                            ]
                                (recur valuePos (inc objIndex))
                            )
                        )
                    )

                    (loop-when [#_"int" valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects this)))
                        (let [
                            #_"VirtualObjectNode" virtual (nth (:virtualObjects this) objIndex)
                            #_"int" entryCount (VirtualObjectNode'''entryCount-1 virtual)
                            #_"ValueNode" newObject (nth allocations objIndex)
                            valuePos
                                (loop-when [valuePos valuePos #_"int" i 0] (< i entryCount) => valuePos
                                    (when (#_"BitSet" .get omittedValues, valuePos)
                                        (let [
                                            #_"ValueNode" value (nth (:values this) valuePos)
                                            #_"ValueNode" allocValue (nth allocations (#_"List" .indexOf (:virtualObjects this), value))
                                        ]
                                            (when-not (and (satisfies? ConstantNode allocValue) (#_"Constant" .isDefaultForKind (:value allocValue)))
                                                (let [
                                                    [#_"AddressNode" address #_"BarrierType" barrierType]
                                                        (if (satisfies? VirtualInstanceNode virtual)
                                                            [(Lowerer'createFieldAddress-3 (:graph this), newObject, (VirtualInstanceNode''field-2 virtual, i)) BarrierType'IMPRECISE]
                                                            [(Lowerer'createArrayAddress-4 (:graph this), newObject, (VirtualObjectNode'''entryKind-2 virtual, i), (ConstantNode'forInt-2 i, (:graph this))) BarrierType'PRECISE]
                                                        )
                                                ]
                                                    (when (some? address)
                                                        (Graph''addBeforeFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (WriteNode'new-4 address, LocationIdentity'INIT, (Lowerer'implicitStoreConvert-3 (:graph this), JavaKind/Object, allocValue), barrierType)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (recur (inc valuePos) (inc i))
                                )
                        ]
                            (recur valuePos (inc objIndex))
                        )
                    )

                    (CommitAllocationNode''finishAllocatedObjects-3 this, lowerer, allocations)
                    (Graph''removeFixed-2 (:graph this), this)

                    (doseq [#_"AbstractNewObjectNode" recursiveLowering recursiveLowerings]
                        (Lowerable'''lower-2 recursiveLowering, lowerer)
                    )
                )
            )
            nil
        )
    )

    (defm CommitAllocationNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"CommitAllocationNode" this]
            (if (empty? (:locks this)) LocationIdentity'INIT LocationIdentity'ANY)
        )
    )

    (defm CommitAllocationNode Node
        (#_"void" Node'''afterClone-2 [#_"CommitAllocationNode" this, #_"Node" other]
            (ยง ass! this (assoc this :lockIndexes (ArrayList. (:lockIndexes this))))
            nil
        )
    )

    (defm CommitAllocationNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"CommitAllocationNode" this, #_"VirtualizerTool" tool]
            (loop-when [#_"int" j 0 #_"int" i 0] (< i (count (:virtualObjects this)))
                (let [
                    #_"VirtualObjectNode" virtualObject (nth (:virtualObjects this) i)
                    #_"int" n (VirtualObjectNode'''entryCount-1 virtualObject)
                ]
                    (VirtualizerTool'''createVirtualObject-5 tool, virtualObject, (into-array ValueNode'iface (#_"List" .subList (:values this), j, (+ j n))), (CommitAllocationNode''getLocks-2 this, i), (nth (:ensureVirtual this) i))
                    (recur (+ j n) (inc i))
                )
            )
            (VirtualizerTool'''delete-1 tool)
            nil
        )
    )

    (defm CommitAllocationNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"CommitAllocationNode" this, #_"SimplifierTool" tool]
            (let [
                #_"boolean[]" used (boolean-array (count (:virtualObjects this)))
                #_"int" usedCount
                    (loop-when [usedCount 0 #_"ISeq" s (seq (filter #(satisfies? AllocatedObjectNode %) (:nodeUsages this)))] (some? s) => usedCount
                        (aset used (#_"List" .indexOf (:virtualObjects this), (:virtualObject (first s))) true)
                        (recur (inc usedCount) (next s))
                    )
            ]
                (if (zero? usedCount)
                    (let [
                        #_"Node*" inputSnapshot (ยง snap (Node''inputs-1 this))
                    ]
                        (Graph''removeFixed-2 (:graph this), this)
                        (doseq [#_"Node" input inputSnapshot]
                            (SimplifierTool'''removeIfUnused-2 tool, input)
                        )
                    )
                    (let [
                        usedCount
                            (loop [usedCount usedCount]
                                (let [
                                    [usedCount #_"boolean" progress?]
                                        (loop-when [usedCount usedCount progress? false #_"int" valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects this))) => [usedCount progress?]
                                            (let [
                                                #_"VirtualObjectNode" virtualObject (nth (:virtualObjects this) objIndex)
                                                [usedCount progress?]
                                                    (when (nth used objIndex) => [usedCount progress?]
                                                        (loop-when [usedCount usedCount progress? progress? #_"int" i 0] (< i (VirtualObjectNode'''entryCount-1 virtualObject)) => [usedCount progress?]
                                                            (let [
                                                                #_"int" index (#_"List" .indexOf (:virtualObjects this), (nth (:values this) (+ valuePos i)))
                                                                [usedCount progress?]
                                                                    (when (and (not= index -1) (not (nth used index))) => [usedCount progress?]
                                                                        (aset used index true)
                                                                        [(inc usedCount) true]
                                                                    )
                                                            ]
                                                                (recur usedCount progress? (inc i))
                                                            )
                                                        )
                                                    )
                                            ]
                                                (recur usedCount progress? (+ valuePos (VirtualObjectNode'''entryCount-1 virtualObject)) (inc objIndex))
                                            )
                                        )
                                ]
                                    (recur-if progress? [usedCount] => usedCount)
                                )
                            )
                    ]
                        (when (< usedCount (count (:virtualObjects this)))
                            (let [
                                #_"List<VirtualObjectNode>" newVirtualObjects (ArrayList.)
                                #_"List<MonitorIdNode>" newLocks (ArrayList.)
                                #_"ArrayList<Integer>" newLockIndexes (ArrayList.)
                                #_"ArrayList<Boolean>" newEnsureVirtual (ArrayList.)
                            ]
                                (#_"ArrayList" .add newLockIndexes, 0)
                                (let [
                                    #_"List<ValueNode>" newValues (ArrayList.)
                                    #_"int" valuePos
                                        (loop-when [valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects this))) => valuePos
                                            (let [
                                                #_"VirtualObjectNode" virtualObject (nth (:virtualObjects this) objIndex)
                                            ]
                                                (when (nth used objIndex)
                                                    (#_"List" .add newVirtualObjects, virtualObject)
                                                    (#_"List" .addAll newLocks, (CommitAllocationNode''getLocks-2 this, objIndex))
                                                    (#_"ArrayList" .add newLockIndexes, (count newLocks))
                                                    (#_"List" .addAll newValues, (#_"List" .subList (:values this), valuePos, (+ valuePos (VirtualObjectNode'''entryCount-1 virtualObject))))
                                                    (#_"ArrayList" .add newEnsureVirtual, (nth (:ensureVirtual this) objIndex))
                                                )
                                                (recur (+ valuePos (VirtualObjectNode'''entryCount-1 virtualObject)) (inc objIndex))
                                            )
                                        )
                                ]
                                    (#_"List" .clear (:virtualObjects this))
                                    (#_"List" .addAll (:virtualObjects this), newVirtualObjects)
                                    (#_"List" .clear (:locks this))
                                    (#_"List" .addAll (:locks this), newLocks)
                                    (#_"List" .clear (:values this))
                                    (#_"List" .addAll (:values this), newValues)
                                    (ยง ass! this (assoc this :lockIndexes newLockIndexes))
                                    (ยง ass! this (assoc this :ensureVirtual newEnsureVirtual))
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; A high-level intrinsic for getting an address inside of an object. During lowering it will be
 ; moved next to any uses to avoid creating a derived pointer that is live across a safepoint.
 ;;
(class-ns ComputeObjectAddressNode [FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, ControlFlowAnchored]
    (ยง intrinsic! #_"long" ComputeObjectAddressNode'get-2 [#_"Object" array, #_"long" offset])

    #_intrinsifier
    (defn #_"ComputeObjectAddressNode" ComputeObjectAddressNode'new-2 [#_"ValueNode" obj, #_"ValueNode" offset]
        (merge (ComputeObjectAddressNode'class.) (FixedWithNextNode'new-1 (StampFactory'forKind-1 JavaKind/Long))
            (hash-map
                ; @Input
                #_"ValueNode" :object obj
                ; @Input
                #_"ValueNode" :offset offset
            )
        )
    )

    (defm ComputeObjectAddressNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"ComputeObjectAddressNode" this, #_"LoweringTool" lowerer]
            (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                ;; Lower this node into a ComputeObjectAddress and an Add, but ensure
                ;; that it's below any potential safepoints and above it's uses.
                (doseq [#_"Node" use (:nodeUsages this)]
                    (when (satisfies? FixedNode use) => (throw! (str "unexpected floating use of ComputeObjectAddressNode " this))
                        (let [
                            #_"Graph" graph (:graph this)
                            #_"GetObjectAddressNode" address (Graph''add-2 graph, (GetObjectAddressNode'new-1 (:object this)))
                        ]
                            (Graph''addBeforeFixed-3 graph, use, address)
                            (Node''replaceFirstInput-3 use, this, (Graph''add-2 graph, (AddNode'new-2 address, (:offset this))))
                        )
                    )
                )
                (GraphUtil'unlinkFixedNode-1 this)
                (Node''safeDelete-1 this)
            )
            nil
        )
    )
)

(class-ns ConditionAnchorNode [FixedWithNextNode, FixedNode, ValueNode, Node, Unary #_"<Node>", Canonicalizable, Lowerable, GuardingNode]
    #_unused
    (defn #_"ConditionAnchorNode" ConditionAnchorNode'new-1 [#_"LogicNode" logic]
        (ConditionAnchorNode'new-2 logic, false)
    )

    (defn #_"ConditionAnchorNode" ConditionAnchorNode'new-2 [#_"LogicNode" logic, #_"boolean" negated?]
        (merge (ConditionAnchorNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"LogicNode" :logic logic
                #_"boolean" :negated? negated?
            )
        )
    )

    (defm ConditionAnchorNode Unary
        (#_"Node" Unary'''canonical-3 [#_"ConditionAnchorNode" this, #_"CanonicalizerTool" tool, #_"Node" value]
            (condp satisfies? value
                LogicNegationNode
                    (ConditionAnchorNode'new-2 (Unary'''getValue-1 value), (not (:negated? this)))
                LogicConstantNode
                    (when (= (:value value) (:negated? this))
                        (ValueAnchorNode'new-1 nil)
                    )
                (when-not (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                    this
                )
            )
        )
    )

    (defm ConditionAnchorNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"ConditionAnchorNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )

    (defm ConditionAnchorNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"ConditionAnchorNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"Graph" graph (:graph this)
            ]
                (when (= (:guardsStage graph) GuardsStage'FIXED_DEOPTS)
                    (ยง ass! graph (Graph''replaceFixedWithFixed-3 graph, this, (Graph''add-2 graph, (ValueAnchorNode'new-1 nil))))
                )
            )
            nil
        )
    )

    (defm ConditionAnchorNode Unary
        (#_"Node" Unary'''getValue-1 [#_"ConditionAnchorNode" this]
            (:logic this)
        )
    )
)

(class-ns ControlFlowAnchorNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, ControlFlowAnchored]
    #_unused
    (defn #_"ControlFlowAnchorNode" ControlFlowAnchorNode'new-0 []
        (merge (ControlFlowAnchorNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance))
    )

    (defm ControlFlowAnchorNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ControlFlowAnchorNode" this, #_"LIRBuilder" builder]
            ;; do nothing
            nil
        )
    )

    (defm ControlFlowAnchorNode Node
        (#_"void" Node'''afterClone-2 [#_"ControlFlowAnchorNode" this, #_"Node" other]
            nil
        )
    )
)

;;;
 ; Intrinsic for getting the lock in the current lock scope.
 ;;
(class-ns CurrentLockNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    (ยง intrinsic! #_"Word" CurrentLockNode'currentLock-1 [#_"int" lockDepth])

    #_intrinsifier
    (defn #_"CurrentLockNode" CurrentLockNode'new-1 [#_"int" lockDepth]
        (merge (CurrentLockNode'class.) (FixedWithNextNode'new-1 (StampFactory'forKind-1 WordTypes'wordKind))
            (hash-map
                #_"int" :lockDepth lockDepth
            )
        )
    )

    (defm CurrentLockNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"CurrentLockNode" this, #_"LIRBuilder" builder]
            ;; the register allocator cannot handle stack -> register moves, so we use an LEA here
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAddress-2 (:gen builder), (LIRGenerator''getLockSlot-2 (:gen builder), (:lockDepth this))))
            nil
        )
    )
)

(class-ns DeoptimizingFixedWithNextNode [FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState]
    (defn #_"DeoptimizingFixedWithNextNode" DeoptimizingFixedWithNextNode'new-1 [#_"Stamp" stamp]
        (merge (DeoptimizingFixedWithNextNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateBefore nil
            )
        )
    )

    (defm DeoptimizingFixedWithNextNode DeoptBefore
        (#_"void" DeoptBefore'''setStateBefore-2 [#_"DeoptimizingFixedWithNextNode" this, #_"FrameState" state]
            (Node''updateUsages-3 this, (:stateBefore this), state)
            (ยง ass! this (assoc this :stateBefore state))
            nil
        )
    )
)

(class-ns AbstractFixedGuardNode [DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Simplifiable, GuardingNode, DeoptimizingGuard, StaticDeoptimizingNode]
    (defn #_"AbstractFixedGuardNode" AbstractFixedGuardNode'new-5 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"JavaConstant" speculation, #_"boolean" negated?]
        (merge (AbstractFixedGuardNode'class.) (DeoptimizingFixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"LogicNode" :logic logic
                #_"DeoptimizationReason" :reason reason
                #_"DeoptimizationAction" :action action
                #_"JavaConstant" :speculation speculation
                #_"boolean" :negated? negated?
            )
        )
    )

    (defm AbstractFixedGuardNode DeoptimizingGuard
        (#_"LogicNode" DeoptimizingGuard'''getCondition-1 [#_"AbstractFixedGuardNode" this]
            (:logic this)
        )

        (#_"void" DeoptimizingGuard'''setCondition-3 [#_"AbstractFixedGuardNode" this, #_"LogicNode" logic, #_"boolean" negated?]
            (Node''updateUsages-3 this, (:logic this), logic)
            (ยง ass! this (assoc this :logic logic))
            (ยง ass! this (assoc this :negated? negated?))
            nil
        )
    )

    (defm AbstractFixedGuardNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"AbstractFixedGuardNode" this, #_"SimplifierTool" tool]
            (while (satisfies? LogicNegationNode (:logic this))
                (DeoptimizingGuard'''setCondition-3 this, (Unary'''getValue-1 (:logic this)), (not (:negated? this)))
            )
            nil
        )
    )

    (defn #_"DeoptimizeNode" AbstractFixedGuardNode''lowerToIf-1 [#_"AbstractFixedGuardNode" this]
        (let [
            #_"FixedNode" currentNext (:next this)
        ]
            (ยง ass! this (FixedWithNextNode''setNext-2 this, nil))
            (let [
                #_"DeoptimizeNode" deopt (Graph''add-2 (:graph this), (DeoptimizeNode'new-3 (:action this), (:reason this), (:speculation this)))
            ]
                (DeoptBefore'''setStateBefore-2 deopt, (:stateBefore this))
                (let [
                    [#_"IfNode" ifNode #_"AbstractBeginNode" noDeoptSuccessor]
                        (if (:negated? this)
                            (let [
                                ifNode (Graph''add-2 (:graph this), (IfNode'new-4f (:logic this), deopt, currentNext, 0))
                            ]
                                [ifNode (:falseSuccessor ifNode)]
                            )
                            (let [
                                ifNode (Graph''add-2 (:graph this), (IfNode'new-4f (:logic this), currentNext, deopt, 1))
                            ]
                                [ifNode (:trueSuccessor ifNode)]
                            )
                        )
                ]
                    (ยง ass! (:predecessor this) (FixedWithNextNode''setNext-2 (:predecessor this), ifNode))
                    (ยง ass! this (Node''replaceAtUsages-2 this, noDeoptSuccessor))
                    (GraphUtil'killWithUnusedFloatingInputs-1 this)

                    deopt
                )
            )
        )
    )

    (defm AbstractFixedGuardNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"AbstractFixedGuardNode" this]
            true
        )
    )

    (defm AbstractFixedGuardNode StaticDeoptimizingNode
        (#_"void" StaticDeoptimizingNode'''setAction-2 [#_"AbstractFixedGuardNode" this, #_"DeoptimizationAction" action]
            (ยง ass! this (assoc this :action action))
            nil
        )

        (#_"void" StaticDeoptimizingNode'''setReason-2 [#_"AbstractFixedGuardNode" this, #_"DeoptimizationReason" reason]
            (ยง ass! this (assoc this :reason reason))
            nil
        )

        (#_"GuardPriority" StaticDeoptimizingNode'''computePriority-1 [#_"AbstractFixedGuardNode" this]
            (if (and (some? (:speculation this)) (#_"JavaConstant" .isNonNull (:speculation this)))
                GuardPriority'Speculation
                (condp =? (:action this)
                    [DeoptimizationAction/InvalidateReprofile DeoptimizationAction/InvalidateRecompile]                                    GuardPriority'Profile
                    [DeoptimizationAction/RecompileIfTooManyDeopts DeoptimizationAction/InvalidateStopCompiling DeoptimizationAction/None] GuardPriority'None
                )
            )
        )
    )
)

(class-ns FixedGuardNode [AbstractFixedGuardNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Simplifiable, GuardingNode, DeoptimizingGuard, StaticDeoptimizingNode, Lowerable]
    (defn #_"FixedGuardNode" FixedGuardNode'new-3 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action]
        (FixedGuardNode'new-5 logic, reason, action, JavaConstant/NULL_POINTER, false)
    )

    (defn #_"FixedGuardNode" FixedGuardNode'new-4 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"boolean" negated?]
        (FixedGuardNode'new-5 logic, reason, action, JavaConstant/NULL_POINTER, negated?)
    )

    (defn #_"FixedGuardNode" FixedGuardNode'new-5 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"JavaConstant" speculation, #_"boolean" negated?]
        (merge (FixedGuardNode'class.) (AbstractFixedGuardNode'new-5 logic, reason, action, speculation, negated?))
    )

    (defm FixedGuardNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"FixedGuardNode" this, #_"SimplifierTool" tool]
            (Simplifiable'''simplify-2 (ยง super #_"AbstractFixedGuardNode"), tool)
            (let [
                #_"LogicNode" logic (DeoptimizingGuard'''getCondition-1 this)
            ]
                (condp satisfies? logic
                    LogicConstantNode
                        (do
                            (when (= (:value logic) (:negated? this))
                                (let [
                                    #_"FixedNode" currentNext (:next this)
                                ]
                                    (when (some? currentNext)
                                        (SimplifierTool'''deleteBranch-2 tool, currentNext)
                                    )

                                    (let [
                                        #_"DeoptimizeNode" deopt (Graph''add-2 (:graph this), (DeoptimizeNode'new-3 (:action this), (:reason this), (:speculation this)))
                                    ]
                                        (DeoptBefore'''setStateBefore-2 deopt, (:stateBefore this))
                                        (ยง ass! this (FixedWithNextNode''setNext-2 this, deopt))
                                    )
                                )
                            )
                            (ยง ass! this (Node''replaceAtUsages-2 this, nil))
                            (Graph''removeFixed-2 (:graph this), this)
                        )
                    ShortCircuitOrNode
                        (when (and (:negated? this) (Node''hasNoUsages-1 this))
                            (Graph''addAfterFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (FixedGuardNode'new-5 (:y logic), (:reason this), (:action this), (:speculation this), (not (:yNegated logic)))))
                            (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (FixedGuardNode'new-5 (:x logic), (:reason this), (:action this), (:speculation this), (not (:xNegated logic))))))
                        )
                    nil
                )
            )
            nil
        )
    )

    (defm FixedGuardNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"FixedGuardNode" this, #_"LoweringTool" lowerer]
            (if (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph this)))
                (when-not (= (:action this) DeoptimizationAction/None)
                    (let [
                        #_"ValueNode" guard (LoweringTool''createGuard-7 lowerer, this, (DeoptimizingGuard'''getCondition-1 this), (:reason this), (:action this), (:speculation this), (:negated? this))
                    ]
                        (ยง ass! this (Node''replaceAtUsages-2 this, guard))
                        (Graph''removeFixed-2 (:graph this), this)
                    )
                )
                (Lowerable'''lower-2 (AbstractFixedGuardNode''lowerToIf-1 this), lowerer)
            )
            nil
        )
    )

    (defm FixedGuardNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"FixedGuardNode" this]
            true
        )
    )
)

;;;
 ; AbstractNewObjectNode is the base class for the new instance and new array nodes.
 ;;
(class-ns AbstractNewObjectNode [DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Lowerable]
    (defn #_"AbstractNewObjectNode" AbstractNewObjectNode'new-1 [#_"Stamp" stamp]
        (merge (AbstractNewObjectNode'class.) (DeoptimizingFixedWithNextNode'new-1 stamp))
    )

    (defm AbstractNewObjectNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"AbstractNewObjectNode" this]
            true
        )
    )
)

;;;
 ; NewArrayNode represents the allocation of an array.
 ;;
(class-ns NewArrayNode [AbstractNewObjectNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Lowerable, ArrayLengthProvider, VirtualizableAllocation, Virtualizable, Simplifiable]
    (defn #_"NewArrayNode" NewArrayNode'new-2 [#_"ResolvedJavaType" elementType, #_"ValueNode" length]
        (merge (NewArrayNode'class.) (AbstractNewObjectNode'new-1 (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 (#_"ResolvedJavaType" .getArrayClass elementType))))
            (hash-map
                ; @Input
                #_"ValueNode" :length length
                #_"ResolvedJavaType" :elementType elementType
            )
        )
    )

    (defm NewArrayNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"NewArrayNode" this, #_"LoweringTool" lowerer]
            (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                (NewObjectTemplates''lower-3a Lowerer'newObjectSnippets, this, lowerer)
            )
            nil
        )
    )

    (defm NewArrayNode ArrayLengthProvider
        (#_"ValueNode" ArrayLengthProvider'''length-1 [#_"NewArrayNode" this]
            (:length this)
        )
    )

    (defm NewArrayNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"NewArrayNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" lengthAlias (VirtualizerTool'''getAlias-2 tool, (ArrayLengthProvider'''length-1 this))
            ]
                (when (some? (ValueNode''asConstant-1 lengthAlias))
                    (let [
                        #_"int" constantLength (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 lengthAlias))
                    ]
                        (when (< -1 constantLength (VirtualizerTool'''getMaximumEntryCount-1 tool))
                            (let [
                                #_"VirtualObjectNode" virtualObject (NewArrayNode''createVirtualArrayNode-2 this, constantLength)
                                #_"ConstantNode" defaultForKind (when-not (zero? constantLength) (NewArrayNode''defaultElementValue-1 this))
                                #_"ValueNode[]" state (into-array ValueNode'iface (repeat constantLength defaultForKind))
                            ]
                                (VirtualizerTool'''createVirtualObject-5 tool, virtualObject, state, #_"<MonitorIdNode>" (Collections/emptyList), false)
                                (VirtualizerTool'''replaceWithVirtual-2 tool, virtualObject)
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn #_"VirtualArrayNode" NewArrayNode''createVirtualArrayNode-2 [#_"NewArrayNode" this, #_"int" constantLength]
        (VirtualArrayNode'new-2 (:elementType this), constantLength)
    )

    ;; Factored out in a separate method so that subclasses can override it.
    (defn #_"ConstantNode" NewArrayNode''defaultElementValue-1 [#_"NewArrayNode" this]
        (ConstantNode'defaultForKind-2 (#_"ResolvedJavaType" .getJavaKind (:elementType this)), (:graph this))
    )

    (defm NewArrayNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"NewArrayNode" this, #_"SimplifierTool" tool]
            (when (Node''hasNoUsages-1 this)
                (let [
                    #_"Stamp" stamp (:stamp (ArrayLengthProvider'''length-1 this))
                ]
                    (if (and (satisfies? IntegerStamp stamp) (IntegerStamp''isPositive-1 stamp))
                        (GraphUtil'removeFixedWithUnusedInputs-1 this)
                        ;; should be areFrameStatesAtSideEffects, but currently SVM will complain about RuntimeConstraint
                        (when (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph this)))
                            (let [
                                #_"LogicNode" lengthNegativeCondition (CompareNode'createCompareNode-4g (:graph this), CanonicalCondition'LT, (ArrayLengthProvider'''length-1 this), (ConstantNode'forInt-2 0, (:graph this)))
                                ;; we do not have a non-deopting path for that at the moment so action is None.
                                #_"FixedGuardNode" guard (Graph''add-2 (:graph this), (FixedGuardNode'new-4 lengthNegativeCondition, DeoptimizationReason/RuntimeConstraint, DeoptimizationAction/None, true))
                            ]
                                (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, guard))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; NewInstanceNode represents the allocation of an instance class object.
 ;;
(class-ns NewInstanceNode [AbstractNewObjectNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Lowerable, VirtualizableAllocation, Virtualizable]
    (defn #_"NewInstanceNode" NewInstanceNode'new-1 [#_"ResolvedJavaType" type]
        (merge (NewInstanceNode'class.) (AbstractNewObjectNode'new-1 (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 type)))
            (hash-map
                ;;;
                 ; The instance class being allocated by this node.
                 ;;
                #_"ResolvedJavaType" :instanceClass type
            )
        )
    )

    (defm NewInstanceNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"NewInstanceNode" this, #_"LoweringTool" lowerer]
            (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                (NewObjectTemplates''lower-3i Lowerer'newObjectSnippets, this, lowerer)
            )
            nil
        )
    )

    (defm NewInstanceNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"NewInstanceNode" this, #_"VirtualizerTool" tool]
            ;; Reference objects can escape into their ReferenceQueue at any safepoint, therefore they're excluded from escape analysis.
            (when-not (#_"ResolvedJavaType" .isAssignableFrom (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, java.lang.ref.Reference), (:instanceClass this))
                (let [
                    #_"VirtualInstanceNode" virtualObject (NewInstanceNode''createVirtualInstanceNode-2 this, true)
                    #_"ResolvedJavaField[]" fields (VirtualInstanceNode''getFields-1 virtualObject)
                    #_"ValueNode[]" state (make-array ValueNode'iface (count fields))
                ]
                    (dotimes [#_"int" i (count state)]
                        (aset state i (NewInstanceNode''defaultFieldValue-2 this, (nth fields i)))
                    )
                    (VirtualizerTool'''createVirtualObject-5 tool, virtualObject, state, #_"<MonitorIdNode>" (Collections/emptyList), false)
                    (VirtualizerTool'''replaceWithVirtual-2 tool, virtualObject)
                )
            )
            nil
        )
    )

    (defn #_"VirtualInstanceNode" NewInstanceNode''createVirtualInstanceNode-2 [#_"NewInstanceNode" this, #_"boolean" hasIdentity]
        (VirtualInstanceNode'new-2 (:instanceClass this), hasIdentity)
    )

    ;; Factored out in a separate method so that subclasses can override it.
    (defn #_"ConstantNode" NewInstanceNode''defaultFieldValue-2 [#_"NewInstanceNode" this, #_"ResolvedJavaField" field]
        (ConstantNode'defaultForKind-2 (#_"JavaType" .getJavaKind (#_"ResolvedJavaField" .getType field)), (:graph this))
    )
)

;;;
 ; Accesses the value at a memory address not including the nil-check on the object.
 ;;
(class-ns FixedAccessNode [DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess]
    (defn #_"FixedAccessNode" FixedAccessNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"BarrierType" barrierType]
        (merge (FixedAccessNode'class.) (DeoptimizingFixedWithNextNode'new-1 stamp)
            (hash-map
                ; @OptionalInput(InputType'Guard)
                #_"GuardingNode" :guard nil
                ; @Input
                #_"AddressNode" :address address
                #_"LocationIdentity" :location location
                #_"boolean" :nullCheck false
                ;;;
                 ; Write barrier type.
                 ;;
                #_"BarrierType" :barrierType barrierType
            )
        )
    )

    (defn #_"FixedAccessNode" FixedAccessNode''setNullCheck-2 [#_"FixedAccessNode" this, #_"boolean" check]
        (assoc this :nullCheck check)
    )

    (defm FixedAccessNode Access
        (#_"AddressNode" Access'''getAddress-1 [#_"FixedAccessNode" this]
            (:address this)
        )

        (#_"LocationIdentity" Access'''getLocationIdentity-1 [#_"FixedAccessNode" this]
            (:location this)
        )
    )

    (defm FixedAccessNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"FixedAccessNode" this]
            (:nullCheck this)
        )
    )

    (defm FixedAccessNode GuardedNode
        (#_"GuardingNode" GuardedNode'''getGuard-1 [#_"FixedAccessNode" this]
            (:guard this)
        )

        (#_"void" GuardedNode'''setGuard-2 [#_"FixedAccessNode" this, #_"GuardingNode" guard]
            (Node''updateUsages-3 this, (:guard this), guard)
            (ยง ass! this (assoc this :guard guard))
            nil
        )
    )
)

;;;
 ; Low-level atomic compare-and-swap operation.
 ;;
(class-ns AbstractCompareAndSwapNode [FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, LIRLowerableAccess, LIRLowerable, Single, MemoryCheckpoint, MemoryNode]
    (defm AbstractCompareAndSwapNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"AbstractCompareAndSwapNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"AbstractCompareAndSwapNode" this]
            true
        )
    )

    (defn #_"ValueNode" AbstractCompareAndSwapNode''getNewValue-1 [#_"AbstractCompareAndSwapNode" this]
        (:newValue this)
    )

    (defn #_"AbstractCompareAndSwapNode" AbstractCompareAndSwapNode'new-6 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"BarrierType" barrierType, #_"Stamp" stamp]
        (merge (AbstractCompareAndSwapNode'class.) (FixedAccessNode'new-4 address, location, stamp, barrierType)
            (hash-map
                ; @Input
                #_"ValueNode" :expectedValue expectedValue
                ; @Input
                #_"ValueNode" :newValue newValue
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
            )
        )
    )

    (defm AbstractCompareAndSwapNode Access
        (#_"boolean" Access'''canNullCheck-1 [#_"AbstractCompareAndSwapNode" this]
            false
        )
    )

    (defm AbstractCompareAndSwapNode LIRLowerableAccess
        (#_"Stamp" LIRLowerableAccess'''getAccessStamp-1 [#_"AbstractCompareAndSwapNode" this]
            (Stamp'''unrestricted-1 (Stamp'''meet-2 (:stamp (:expectedValue this)), (:stamp (:newValue this))))
        )
    )
)

;;;
 ; Represents the low-level version of an atomic compare-and-swap operation.
 ;
 ; This version returns a boolean indicating is the CAS was successful or not.
 ;;
(class-ns LogicCompareAndSwapNode [AbstractCompareAndSwapNode, FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, LIRLowerableAccess, LIRLowerable, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"LogicCompareAndSwapNode" LogicCompareAndSwapNode'new-4 [#_"ValueNode" address, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"LocationIdentity" location]
        (LogicCompareAndSwapNode'new-5 address, location, expectedValue, newValue, BarrierType'NONE)
    )

    (defn #_"LogicCompareAndSwapNode" LogicCompareAndSwapNode'new-5 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"BarrierType" barrierType]
        (merge (LogicCompareAndSwapNode'class.) (AbstractCompareAndSwapNode'new-6 address, location, expectedValue, newValue, barrierType, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind JavaKind/Boolean))))
    )

    (defm LogicCompareAndSwapNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"LogicCompareAndSwapNode" this, #_"LIRBuilder" builder]
            (let [
                #_"LIRKind" resultKind (Stamp'''getLIRKind-1 (:stamp this))
                #_"Value" trueResult (LIRGenerator''emitConstant-3 (:gen builder), resultKind, JavaConstant/TRUE)
                #_"Value" falseResult (LIRGenerator''emitConstant-3 (:gen builder), resultKind, JavaConstant/FALSE)
                #_"Value" result (LIRGenerator''emitLogicCompareAndSwap-6 (:gen builder), (LIRBuilder''operand-2 builder, (Access'''getAddress-1 this)), (LIRBuilder''operand-2 builder, (:expectedValue this)), (LIRBuilder''operand-2 builder, (AbstractCompareAndSwapNode''getNewValue-1 this)), trueResult, falseResult)
            ]
                (LIRBuilder''setResult-3 builder, this, result)
            )
            nil
        )
    )
)

;;;
 ; A special purpose store node that differs from LogicCompareAndSwapNode in that it returns
 ; either the expected value or the compared against value instead of a boolean.
 ;;
(class-ns ValueCompareAndSwapNode [AbstractCompareAndSwapNode, FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, LIRLowerableAccess, LIRLowerable, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"ValueCompareAndSwapNode" ValueCompareAndSwapNode'new-4 [#_"ValueNode" address, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"LocationIdentity" location]
        (ValueCompareAndSwapNode'new-5 address, expectedValue, newValue, location, BarrierType'NONE)
    )

    (defn #_"ValueCompareAndSwapNode" ValueCompareAndSwapNode'new-5 [#_"AddressNode" address, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"LocationIdentity" location, #_"BarrierType" barrierType]
        (merge (ValueCompareAndSwapNode'class.) (AbstractCompareAndSwapNode'new-6 address, location, expectedValue, newValue, barrierType, (Stamp'''unrestricted-1 (Stamp'''meet-2 (:stamp expectedValue), (:stamp newValue)))))
    )

    (defm ValueCompareAndSwapNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ValueCompareAndSwapNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitValueCompareAndSwap-4 (:gen builder), (LIRBuilder''operand-2 builder, (Access'''getAddress-1 this)), (LIRBuilder''operand-2 builder, (:expectedValue this)), (LIRBuilder''operand-2 builder, (AbstractCompareAndSwapNode''getNewValue-1 this))))
            nil
        )
    )
)

(class-ns AbstractWriteNode [FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, Single, MemoryCheckpoint, MemoryNode, MemoryAccess, GuardingNode]
    (defm AbstractWriteNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"AbstractWriteNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"AbstractWriteNode" this]
            true
        )
    )

    (defn #_"AbstractWriteNode" AbstractWriteNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType]
        (merge (AbstractWriteNode'class.) (FixedAccessNode'new-4 address, location, VoidStamp'instance, barrierType)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
                ; @OptionalInput(InputType'Memory)
                #_"Node" :lastLocationAccess nil
            )
        )
    )

    (defm AbstractWriteNode MemoryAccess
        (#_"void" MemoryAccess'''setLastLocationAccess-2 [#_"AbstractWriteNode" this, #_"MemoryNode" lla]
            (Node''updateUsages-3 this, (:lastLocationAccess this), lla)
            (ยง ass! this (assoc this :lastLocationAccess lla))
            nil
        )
    )
)

;;;
 ; Write a raw memory location according to Java field or array write semantics. It will perform
 ; write barriers, implicit conversions and optionally oop compression.
 ;;
(class-ns JavaWriteNode [AbstractWriteNode, FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, Single, MemoryCheckpoint, MemoryNode, MemoryAccess, GuardingNode, Lowerable]
    (defn #_"JavaWriteNode" JavaWriteNode'new-6 [#_"JavaKind" writeKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType, #_"boolean" compressible?]
        (merge (JavaWriteNode'class.) (AbstractWriteNode'new-4 address, location, value, barrierType)
            (hash-map
                #_"JavaKind" :writeKind writeKind
                #_"boolean" :compressible? compressible?
            )
        )
    )

    (defm JavaWriteNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"JavaWriteNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"ValueNode" value (Lowerer'implicitStoreConvert-4 (:graph this), (:writeKind this), (:value this), (:compressible? this))
                #_"WriteNode" memoryWrite (Graph''add-2 (:graph this), (WriteNode'new-4 (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), value, (:barrierType this)))
            ]
                (StateSplit'''setStateAfter-2 memoryWrite, (:stateAfter this))
                (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, memoryWrite))
                (GuardedNode'''setGuard-2 memoryWrite, (GuardedNode'''getGuard-1 this))
            )
            nil
        )
    )

    (defm JavaWriteNode Access
        (#_"boolean" Access'''canNullCheck-1 [#_"JavaWriteNode" this]
            true
        )
    )
)

;;;
 ; Writes a given {@linkplain #value() value} a memory location.
 ;;
(class-ns WriteNode [AbstractWriteNode, FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, Single, MemoryCheckpoint, MemoryNode, MemoryAccess, GuardingNode, LIRLowerableAccess, LIRLowerable, Canonicalizable]
    (defn #_"WriteNode" WriteNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType]
        (merge (WriteNode'class.) (AbstractWriteNode'new-4 address, location, value, barrierType))
    )

    (defm WriteNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"WriteNode" this, #_"LIRBuilder" builder]
            (let [
                #_"LIRKind" writeKind (Stamp'''getLIRKind-1 (:stamp (:value this)))
            ]
                (LIRGenerator''emitStore-4v (:gen builder), writeKind, (LIRBuilder''operand-2 builder, (:address this)), (LIRBuilder''operand-2 builder, (:value this)))
            )
            nil
        )
    )

    (defm WriteNode Access
        (#_"boolean" Access'''canNullCheck-1 [#_"WriteNode" this]
            true
        )
    )

    (defm WriteNode LIRLowerableAccess
        (#_"Stamp" LIRLowerableAccess'''getAccessStamp-1 [#_"WriteNode" this]
            (:stamp (:value this))
        )
    )

    (defm WriteNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"WriteNode" this, #_"CanonicalizerTool" tool]
            (when (and (CanonicalizerTool'''canonicalizeReads-1 tool) (Node''hasExactlyOneUsage-1 this) (satisfies? WriteNode (:next this))) => this
                (let [
                    #_"WriteNode" write (:next this)
                ]
                    (when (and (= (:lastLocationAccess write) this) (= (Access'''getAddress-1 write) (Access'''getAddress-1 this)) (Stamp'''isCompatible-2s (LIRLowerableAccess'''getAccessStamp-1 this), (LIRLowerableAccess'''getAccessStamp-1 write))) => this
                        (MemoryAccess'''setLastLocationAccess-2 write, (:lastLocationAccess this))
                        write
                    )
                )
            )
        )
    )
)

(class-ns FloatableAccessNode [FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess]
    (defn #_"FloatableAccessNode" FloatableAccessNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"BarrierType" barrierType]
        (merge (FloatableAccessNode'class.) (FixedAccessNode'new-4 address, location, stamp, barrierType)
            (hash-map
                #_"boolean" :forceFixed false
            )
        )
    )

    (defn #_"FloatableAccessNode" FloatableAccessNode''setForceFixed-2 [#_"FloatableAccessNode" this, #_"boolean" flag]
        (assoc this :forceFixed flag)
    )

    ;;;
     ; AccessNodes can float only if their location identities are not ANY_LOCATION. Furthermore,
     ; in case G1 is enabled, any access (read) to the java.lang.ref.Reference.referent field which
     ; has an attached write barrier with pre-semantics can not float either.
     ;;
    (defn #_"boolean" FloatableAccessNode''canFloat-1 [#_"FloatableAccessNode" this]
        (and (not (:forceFixed this)) (LocationIdentity''isSingle-1 (Access'''getLocationIdentity-1 this)) (= (:barrierType this) BarrierType'NONE))
    )
)

;;;
 ; Reads an accessed value.
 ;;
(class-ns ReadNode [FloatableAccessNode, FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, LIRLowerableAccess, LIRLowerable, Canonicalizable, Virtualizable, GuardingNode]
    (defn #_"ReadNode" ReadNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"BarrierType" barrierType]
        (merge (ReadNode'class.) (FloatableAccessNode'new-4 address, location, stamp, barrierType))
    )

    (defm ReadNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ReadNode" this, #_"LIRBuilder" builder]
            (let [
                #_"LIRKind" readKind (Stamp'''getLIRKind-1 (LIRLowerableAccess'''getAccessStamp-1 this))
            ]
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitLoad-3 (:gen builder), readKind, (LIRBuilder''operand-2 builder, (:address this))))
            )
            nil
        )
    )

    (defm ReadNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"ReadNode" this, #_"CanonicalizerTool" tool]
            (cond
                (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                    nil ;; read without usages or guard can be safely removed
                (:nullCheck this)
                    this ;; if this read is a nil-check, then replacing it with the value is incorrect for guard-type usages
                :else
                    (ReadNode'canonicalizeRead-4 this, (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), tool)
            )
        )
    )

    (defm ReadNode FloatableAccessNode
        (#_"FloatingAccessNode" FloatableAccessNode'''asFloatingNode-2 [#_"ReadNode" this, #_"MemoryNode" lastLocationAccess]
            (Graph''add-2 (:graph this), (FloatingReadNode'new-6 (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), lastLocationAccess, (:stamp this), (GuardedNode'''getGuard-1 this), (:barrierType this)))
        )
    )

    (defn #_"ValueNode" ReadNode'canonicalizeRead-4 [#_"ValueNode" read, #_"AddressNode" address, #_"LocationIdentity" location, #_"CanonicalizerTool" tool]
        (when (and (CanonicalizerTool'''canonicalizeReads-1 tool) (satisfies? OffsetAddressNode address)) => read
            (let [
                #_"ValueNode" object (AddressNode'''getBase-1 address)
            ]
                (when (and (satisfies? ConstantNode object) (not (ValueNode''isNullConstant-1 object)) (satisfies? ConstantNode (:offset address)))
                    (let [
                        #_"long" displacement (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset address)))
                        #_"int" stableDimension (:stableDimension object)
                    ]
                        (when (or (:immutable location) (pos? stableDimension))
                            (let [
                                #_"Constant" constant (Stamp'''readConstant-4 (:stamp read), (#_"ConstantReflectionProvider" .getMemoryAccessProvider HotSpot'constantReflection), (:value object), displacement)
                                #_"boolean" isDefaultStable (or (:immutable location) (:isDefaultStable object))
                            ]
                                (when (and (some? constant) (or isDefaultStable (not (#_"Constant" .isDefaultForKind constant))))
                                    (ยง return (ConstantNode'forConstant-4 (:stamp read), constant, (max (dec stableDimension) 0), isDefaultStable))
                                )
                            )
                        )
                    )
                )
                (when (= location NamedLocationIdentity'ARRAY_LENGTH)
                    (let [
                        #_"ValueNode" length (GraphUtil'arrayLength-1 object)
                    ]
                        (when (some? length)
                            (ยง return length)
                        )
                    )
                )
                (when (satisfies? CanonicalizableLocation location) => read
                    (CanonicalizableLocation'''canonicalizeRead-4 location, read, address, object)
                )
            )
        )
    )

    (defm ReadNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"ReadNode" this, #_"VirtualizerTool" tool]
            (throw! "unexpected ReadNode before PEA")
        )
    )

    (defm ReadNode Access
        (#_"boolean" Access'''canNullCheck-1 [#_"ReadNode" this]
            true
        )
    )

    (defm ReadNode LIRLowerableAccess
        (#_"Stamp" LIRLowerableAccess'''getAccessStamp-1 [#_"ReadNode" this]
            (:stamp this)
        )
    )
)

;;;
 ; Read a raw memory location according to Java field or array read semantics. It will perform read
 ; barriers, implicit conversions and optionally oop uncompression.
 ;;
(class-ns JavaReadNode [FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, Lowerable, GuardingNode, Canonicalizable]
    (defn #_"JavaReadNode" JavaReadNode'new-5 [#_"JavaKind" readKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"BarrierType" barrierType, #_"boolean" compressible?]
        (merge (JavaReadNode'class.) (FixedAccessNode'new-4 address, location, (StampFactory'forKind-1 readKind), barrierType)
            (hash-map
                #_"JavaKind" :readKind readKind
                #_"boolean" :compressible? compressible?
            )
        )
    )

    (defm JavaReadNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"JavaReadNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp this), (:readKind this), (:compressible? this))
                #_"ReadNode" memoryRead (Graph''add-2 (:graph this), (ReadNode'new-4 (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), loadStamp, (:barrierType this)))
                #_"ValueNode" readValue (Lowerer'implicitLoadConvert-4 (:graph this), (:readKind this), memoryRead, (:compressible? this))
                #_"GuardingNode" guard (GuardedNode'''getGuard-1 this)
            ]
                (if (some? guard)
                    (GuardedNode'''setGuard-2 memoryRead, guard)
                    ;; An unsafe read must not float, otherwise it may float above a test guaranteeing the read is safe.
                    (ยง ass! memoryRead (FloatableAccessNode''setForceFixed-2 memoryRead, true))
                )
                (ยง ass! this (Node''replaceAtUsages-2 this, readValue))
                (ยง ass! (:graph this) (Graph''replaceFixed-3 (:graph this), this, memoryRead))
            )
            nil
        )
    )

    (defm JavaReadNode Access
        (#_"boolean" Access'''canNullCheck-1 [#_"JavaReadNode" this]
            true
        )
    )

    (defm JavaReadNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"JavaReadNode" this, #_"CanonicalizerTool" tool]
            (ReadNode'canonicalizeRead-4 this, (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), tool)
        )
    )
)

;;;
 ; Represents the lowered version of an atomic read-and-write operation like {@link sun.misc.Unsafe#getAndSetInt(Object, long, int)}.
 ;;
(class-ns LoweredAtomicReadAndWriteNode [FixedAccessNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Access, GuardedNode, HeapAccess, StateSplit, LIRLowerableAccess, LIRLowerable, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"LoweredAtomicReadAndWriteNode" LoweredAtomicReadAndWriteNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" newValue, #_"BarrierType" barrierType]
        (merge (LoweredAtomicReadAndWriteNode'class.) (FixedAccessNode'new-4 address, location, (Stamp'''unrestricted-1 (:stamp newValue)), barrierType)
            (hash-map
                ; @Input
                #_"ValueNode" :newValue newValue
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
            )
        )
    )

    (defm LoweredAtomicReadAndWriteNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"LoweredAtomicReadAndWriteNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"LoweredAtomicReadAndWriteNode" this]
            true
        )
    )

    (defm LoweredAtomicReadAndWriteNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"LoweredAtomicReadAndWriteNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" result (LIRGenerator''emitAtomicReadAndWrite-3 (:gen builder), (LIRBuilder''operand-2 builder, (Access'''getAddress-1 this)), (LIRBuilder''operand-2 builder, (:newValue this)))
            ]
                (LIRBuilder''setResult-3 builder, this, result)
            )
            nil
        )
    )

    (defm LoweredAtomicReadAndWriteNode Access
        (#_"boolean" Access'''canNullCheck-1 [#_"LoweredAtomicReadAndWriteNode" this]
            false
        )
    )

    (defm LoweredAtomicReadAndWriteNode LIRLowerableAccess
        (#_"Stamp" LIRLowerableAccess'''getAccessStamp-1 [#_"LoweredAtomicReadAndWriteNode" this]
            (:stamp this)
        )
    )
)

(class-ns FixedBinaryNode [DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Binary #_"<ValueNode>", Canonicalizable]
    (defn #_"FixedBinaryNode" FixedBinaryNode'new-3 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y]
        (merge (FixedBinaryNode'class.) (DeoptimizingFixedWithNextNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :x x
                ; @Input
                #_"ValueNode" :y y
            )
        )
    )

    (defm FixedBinaryNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"FixedBinaryNode" this, #_"CanonicalizerTool" tool]
            (Binary'''canonical-4 this, tool, (:x this), (:y this))
        )
    )
)

(class-ns IntegerDivRemNode [FixedBinaryNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Binary #_"<ValueNode>", Canonicalizable, Lowerable]
    (defn #_"IntegerDivRemNode" IntegerDivRemNode'new-5 [#_"Stamp" stamp, #_"DivRemOp" op, #_"Signedness" type, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerDivRemNode" this
                (merge (IntegerDivRemNode'class.) (FixedBinaryNode'new-3 stamp, x, y)
                    (hash-map
                        #_"DivRemOp" :op op
                        #_"Signedness" :type type
                        #_"boolean" :canDeopt false
                    )
                )
            ;; Assigning canDeopt during constructor, because it must never change during lifetime of the node.
            #_"IntegerStamp" yStamp (:stamp (:y this))
            this (assoc this :canDeopt (or (IntegerStamp''contains-2 yStamp, 0) (IntegerStamp''contains-2 yStamp, -1)))
        ]
            this
        )
    )

    (defn #_"Signedness" IntegerDivRemNode''getType-1 [#_"IntegerDivRemNode" this]
        (:type this)
    )

    (defm IntegerDivRemNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"IntegerDivRemNode" this, #_"LoweringTool" lowerer]
            nil ;; Nothing to do for division nodes. The HotSpot signal handler catches divisions by zero and the MIN_VALUE / -1 cases.
        )
    )

    (defm IntegerDivRemNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"IntegerDivRemNode" this]
            (:canDeopt this)
        )
    )
)

(class-ns SignedDivNode [IntegerDivRemNode, FixedBinaryNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Binary #_"<ValueNode>", Canonicalizable, Lowerable, LIRLowerable]
    (defn #_"SignedDivNode" SignedDivNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (SignedDivNode'class.) (IntegerDivRemNode'new-5 (BinaryOp'''foldStamp-3 (:div IntegerStamp'OPS), (:stamp x), (:stamp y)), DivRemOp'DIV, Signedness'SIGNED, x, y))
    )

    (defn #_"ValueNode" SignedDivNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (SignedDivNode'canonical-3 (ยง cast #_"SignedDivNode" nil), x, y)
    )

    (defm SignedDivNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"SignedDivNode" this]
            (ValueNode''updateStamp-2 this, (BinaryOp'''foldStamp-3 (:div IntegerStamp'OPS), (:stamp (:x this)), (:stamp (:y this))))
        )
    )

    (defm SignedDivNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"SignedDivNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (SignedDivNode'canonical-3 this, forX, forY)
        )
    )

    (defn #_"ValueNode" SignedDivNode'canonical-3 [#_"SignedDivNode" self, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"Stamp" stamp (if (some? self) (:stamp self) (BinaryOp'''foldStamp-3 (:div IntegerStamp'OPS), (:stamp forX), (:stamp forY)))
        ]
            (cond
                (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
                    (let [
                        #_"long" y (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                    ]
                        (if (zero? y)
                            (ยง return (or self (SignedDivNode'new-2 forX, forY))) ;; this will trap, can not canonicalize
                            (ยง return (ConstantNode'forIntegerStamp-2 stamp, (quot (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)) y)))
                        )
                    )
                (satisfies? ConstantNode forY)
                    (ยง return (SignedDivNode'canonical-2 forX, (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))))
            )

            ;; convert the expression ((a - a % b) / b) into (a / b)
            (when (and (satisfies? SubNode forX) (satisfies? SignedRemNode (:y forX)) (Stamp'''isCompatible-2s (:stamp forX), stamp) (Stamp'''isCompatible-2s (:stamp (:y forX)), stamp) (= (:x forX) (:x (:y forX))) (= forY (:y (:y forX))))
                (ยง return (assoc (SignedDivNode'new-2 (:x forX), forY) :stateBefore (when (some? self) (:stateBefore self))))
            )

            (when (and (some? self) (satisfies? SignedDivNode (:next self)) (= (#_"Object" .getClass (:next self)) (#_"Object" .getClass self)) (NodeClass''equalInputs-3 (:nodeClass self), self, (:next self)) (Node''valueEquals-2 self, (:next self)))
                (ยง return (:next self))
            )

            (or self (SignedDivNode'new-2 forX, forY))
        )
    )

    (defn #_"ValueNode" SignedDivNode'canonical-2 [#_"ValueNode" forX, #_"long" c]
        (case c 1 forX -1 (NegateNode'create-1 forX)
            (let [
                #_"long" a (abs c)
            ]
                (when (and (CodeUtil/isPowerOf2 a) (satisfies? IntegerStamp (:stamp forX)))
                    (let [
                        #_"ValueNode" dividend forX
                        #_"int" log2 (CodeUtil/log2 a)
                        ;; no rounding if dividend is positive or if its low bits are always 0
                        dividend
                            (when (or (IntegerStamp''canBeNegative-1 (:stamp forX)) (not (zero? (& (:upMask (:stamp forX)) (dec a))))) => dividend
                                (let [
                                    #_"int" bits (PrimitiveStamp'getBits-1 (:stamp forX))
                                    #_"RightShiftNode" sign (RightShiftNode'new-2 forX, (ConstantNode'forInt-1 (dec bits)))
                                ]
                                    (BinaryArithmeticNode'add-2 dividend, (UnsignedRightShiftNode'new-2 sign, (ConstantNode'forInt-1 (- bits log2))))
                                )
                            )
                        #_"RightShiftNode" shift (RightShiftNode'new-2 dividend, (ConstantNode'forInt-1 log2))
                    ]
                        (if (neg? c) (NegateNode'create-1 shift) shift)
                    )
                )
            )
        )
    )

    (defm SignedDivNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"SignedDivNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitDiv-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns SignedRemNode [IntegerDivRemNode, FixedBinaryNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Binary #_"<ValueNode>", Canonicalizable, Lowerable, LIRLowerable]
    (defn #_"SignedRemNode" SignedRemNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (SignedRemNode'class.) (IntegerDivRemNode'new-5 (BinaryOp'''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp x), (:stamp y)), DivRemOp'REM, Signedness'SIGNED, x, y))
    )

    (defn- #_"ValueNode" SignedRemNode'canonical-4 [#_"SignedRemNode" self, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (cond
            (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
                (let [
                    #_"long" y (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                ]
                    (if (zero? y)
                        (or self (SignedRemNode'new-2 forX, forY)) ;; this will trap, can not canonicalize
                        (ConstantNode'forIntegerStamp-2 stamp, (% (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)) y))
                    )
                )
            (and (satisfies? ConstantNode forY) (satisfies? IntegerStamp (:stamp forX)) (satisfies? IntegerStamp (:stamp forY)))
                (let [
                    #_"long" constY (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                    #_"IntegerStamp" xStamp (:stamp forX)
                    #_"IntegerStamp" yStamp (:stamp forY)
                ]
                    (cond
                        (and (neg? constY) (not= constY (CodeUtil/minValue (:bits yStamp))))
                            (SignedRemNode'canonical-4 nil, forX, (ConstantNode'forIntegerStamp-2 yStamp, (- constY)), (BinaryOp'''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp forX), (:stamp forY)))
                        (= constY 1)
                            (ConstantNode'forIntegerStamp-2 stamp, 0)
                        (CodeUtil/isPowerOf2 constY)
                            (cond
                                (IntegerStamp''isPositive-1 xStamp) ;; x & (y - 1)
                                    (AndNode'new-2 forX, (ConstantNode'forIntegerStamp-2 stamp, (dec constY)))
                                (IntegerStamp''isNegative-1 xStamp) ;; -((-x) & (y - 1))
                                    (NegateNode'new-1 (AndNode'new-2 (NegateNode'new-1 forX), (ConstantNode'forIntegerStamp-2 stamp, (dec constY))))
                                :else                               ;; x - ((x / y) << log2(y))
                                    (SubNode'create-2 forX, (LeftShiftNode'create-2 (SignedDivNode'canonical-2 forX, constY), (ConstantNode'forInt-1 (CodeUtil/log2 constY))))
                            )
                        :else
                            (or self (SignedRemNode'new-2 forX, forY))
                    )
                )
            :else
                (or self (SignedRemNode'new-2 forX, forY))
        )
    )

    (defn #_"ValueNode" SignedRemNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"Stamp" stamp (BinaryOp'''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp x), (:stamp y))
        ]
            (SignedRemNode'canonical-4 nil, x, y, stamp)
        )
    )

    (defm SignedRemNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"SignedRemNode" this]
            (ValueNode''updateStamp-2 this, (BinaryOp'''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp (:x this)), (:stamp (:y this))))
        )
    )

    (defm SignedRemNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"SignedRemNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (SignedRemNode'canonical-4 this, forX, forY, (:stamp this))
        )
    )

    (defm SignedRemNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"SignedRemNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitRem-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns UnsignedDivNode [IntegerDivRemNode, FixedBinaryNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Binary #_"<ValueNode>", Canonicalizable, Lowerable, LIRLowerable]
    (defn #_"UnsignedDivNode" UnsignedDivNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (UnsignedDivNode'class.) (IntegerDivRemNode'new-5 (Stamp'''unrestricted-1 (:stamp x)), DivRemOp'DIV, Signedness'UNSIGNED, x, y))
    )

    (defn- #_"ValueNode" UnsignedDivNode'canonical-4 [#_"UnsignedDivNode" self, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (let [
            #_"int" bits (:bits stamp)
        ]
            (cond
                (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
                    (let [
                        #_"long" yConst (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (if (zero? yConst)
                            (ยง return (or self (UnsignedDivNode'new-2 forX, forY))) ;; this will trap, cannot canonicalize
                            (ยง return (ConstantNode'forIntegerStamp-2 stamp, (Long/divideUnsigned (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)), bits), yConst)))
                        )
                    )
                (satisfies? ConstantNode forY)
                    (let [
                        #_"long" c (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (when (= c 1)
                            (ยง return forX)
                        )
                        (when (CodeUtil/isPowerOf2 c)
                            (ยง return (UnsignedRightShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 c))))
                        )
                    )
            )
            (or self (UnsignedDivNode'new-2 forX, forY))
        )
    )

    (defn #_"ValueNode" UnsignedDivNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (UnsignedDivNode'canonical-4 nil, x, y, (Stamp'''unrestricted-1 (:stamp x)))
    )

    (defm UnsignedDivNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"UnsignedDivNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (UnsignedDivNode'canonical-4 this, forX, forY, (:stamp this))
        )
    )

    (defm UnsignedDivNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"UnsignedDivNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitUDiv-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns UnsignedRemNode [IntegerDivRemNode, FixedBinaryNode, DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Binary #_"<ValueNode>", Canonicalizable, Lowerable, LIRLowerable]
    (defn #_"UnsignedRemNode" UnsignedRemNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (UnsignedRemNode'class.) (IntegerDivRemNode'new-5 (Stamp'''unrestricted-1 (:stamp x)), DivRemOp'REM, Signedness'UNSIGNED, x, y))
    )

    #_unused
    (defn #_"ValueNode" UnsignedRemNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (UnsignedRemNode'canonical-4 nil, x, y, (Stamp'''unrestricted-1 (:stamp x)))
    )

    (defm UnsignedRemNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"UnsignedRemNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (UnsignedRemNode'canonical-4 this, forX, forY, (:stamp this))
        )
    )

    (defn #_"ValueNode" UnsignedRemNode'canonical-4 [#_"UnsignedRemNode" self, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (let [
            #_"int" bits (:bits stamp)
        ]
            (cond
                (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
                    (let [
                        #_"long" yConst (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (if (zero? yConst)
                            (ยง return (or self (UnsignedRemNode'new-2 forX, forY))) ;; this will trap, cannot canonicalize
                            (ยง return (ConstantNode'forIntegerStamp-2 stamp, (Long/remainderUnsigned (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)), bits), yConst)))
                        )
                    )
                (satisfies? ConstantNode forY)
                    (let [
                        #_"long" c (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (cond
                            (= c 1)
                                (ยง return (ConstantNode'forIntegerStamp-2 stamp, 0))
                            (CodeUtil/isPowerOf2 c)
                                (ยง return (AndNode'new-2 forX, (ConstantNode'forIntegerStamp-2 stamp, (dec c))))
                        )
                    )
            )
            (or self (UnsignedRemNode'new-2 forX, forY))
        )
    )

    (defm UnsignedRemNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"UnsignedRemNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitURem-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns NullCheckNode [DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, LIRLowerable, GuardingNode]
    (ยง intrinsic! #_"void" NullCheckNode'nullCheck-1 [#_"Object" object])

    #_intrinsifier
    (defn #_"NullCheckNode" NullCheckNode'new-1 [#_"ValueNode" object]
        (merge (NullCheckNode'class.) (DeoptimizingFixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defm NullCheckNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"NullCheckNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitNullCheck-2 (:gen builder), (LIRBuilder''operand-2 builder, (:object this)))
            nil
        )
    )

    (defm NullCheckNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"NullCheckNode" this]
            true
        )
    )
)

;;;
 ; Marks a position in the graph where a safepoint should be emitted.
 ;;
(class-ns SafepointNode [DeoptimizingFixedWithNextNode, FixedWithNextNode, FixedNode, ValueNode, Node, DeoptBefore, DeoptimizingNode, NodeWithState, Lowerable, LIRLowerable]
    (defn #_"SafepointNode" SafepointNode'new-0 []
        (merge (SafepointNode'class.) (DeoptimizingFixedWithNextNode'new-1 VoidStamp'instance))
    )

    (defm SafepointNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"SafepointNode" this, #_"LoweringTool" lowerer]
            nil ;; No lowering, we generate LIR directly for this node.
        )
    )

    (defm SafepointNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"SafepointNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''visitSafepointNode-2 builder, this)
            nil
        )
    )

    (defm SafepointNode DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"SafepointNode" this]
            true
        )
    )
)

;;;
 ; Placeholder node to denote to snippet preparation that the following loop must be completely unrolled.
 ;;
(class-ns ExplodeLoopNode [FixedWithNextNode, FixedNode, ValueNode, Node]
    ;;;
     ; A call to this method must be placed immediately prior to the loop that is to be exploded.
     ;;
    (ยง intrinsic! #_"void" ExplodeLoopNode'explodeLoop-0 [])

    #_intrinsifier
    (defn #_"ExplodeLoopNode" ExplodeLoopNode'new-0 []
        (merge (ExplodeLoopNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance))
    )

    (defn #_"LoopBeginNode" ExplodeLoopNode''findLoopBegin-1 [#_"ExplodeLoopNode" this]
        (let [
            #_"ArrayList<Node>" succs (ArrayList.)
        ]
            (loop-when [#_"Node" _next (:next this)] (not (satisfies? LoopBeginNode _next)) => _next
                (doseq [#_"Node" node (Node'''cfgSuccessors-1 _next)]
                    (#_"ArrayList" .add succs, node)
                )
                (when (and (= (count succs) 1) (not= (nth succs 0) _next))
                    (recur (nth succs 0))
                )
            )
        )
    )
)

;;;
 ; Marks the control flow path where an object acquired a biased lock because the lock was already
 ; biased to the object on the current thread.
 ;;
(class-ns FastAcquireBiasedLockNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    (ยง intrinsic! #_"void" FastAcquireBiasedLockNode'mark-1 [#_"Object" object])

    #_intrinsifier
    (defn #_"FastAcquireBiasedLockNode" FastAcquireBiasedLockNode'new-1 [#_"ValueNode" object]
        (merge (FastAcquireBiasedLockNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defm FastAcquireBiasedLockNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"FastAcquireBiasedLockNode" this, #_"LIRBuilder" builder]
            ;; this is just a marker node, so it generates nothing
            nil
        )
    )
)

(class-ns FinalFieldBarrierNode [FixedWithNextNode, FixedNode, ValueNode, Node, Virtualizable, Lowerable]
    (defn #_"FinalFieldBarrierNode" FinalFieldBarrierNode'new-1 [#_"ValueNode" value]
        (merge (FinalFieldBarrierNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @OptionalInput
                #_"ValueNode" :value value
            )
        )
    )

    (defm FinalFieldBarrierNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"FinalFieldBarrierNode" this, #_"VirtualizerTool" tool]
            (when (and (some? (:value this)) (satisfies? VirtualObjectNode (VirtualizerTool'''getAlias-2 tool, (:value this))))
                (VirtualizerTool'''delete-1 tool)
            )
            nil
        )
    )

    (defm FinalFieldBarrierNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"FinalFieldBarrierNode" this, #_"LoweringTool" lowerer]
            (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (MembarNode'new-1 (| MemoryBarriers/LOAD_STORE MemoryBarriers/STORE_STORE)))))
            nil
        )
    )
)

(class-ns FixedValueAnchorNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, ValueProxy, LimitedValueProxy, Proxy, GuardingNode]
    (ยง intrinsic! #_"Object" FixedValueAnchorNode'getObject-1 [#_"Object" object])

    #_intrinsifier
    (defn #_"FixedValueAnchorNode" FixedValueAnchorNode'new-1 [#_"ValueNode" object]
        (merge (FixedValueAnchorNode'class.) (FixedWithNextNode'new-1 (:stamp object))
            (hash-map
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defm FixedValueAnchorNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"FixedValueAnchorNode" this]
            (ValueNode''updateStamp-2 this, (:stamp (:object this)))
        )
    )

    (defm FixedValueAnchorNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"FixedValueAnchorNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:object this)))
            nil
        )
    )

    (defm FixedValueAnchorNode Proxy
        (#_"ValueNode" Proxy'''getOriginalNode-1 [#_"FixedValueAnchorNode" this]
            (:object this)
        )
    )
)

;;;
 ; This node provides a state split along with the functionality of FixedValueAnchorNode.
 ; This is used to capture a state for deoptimization when a node has side effects which aren't
 ; easily represented. The anchored value is usually part of the FrameState since this forces uses
 ; of the value below this node so they will consume this frame state instead of an earlier one.
 ;;
(class-ns StateSplitProxyNode [FixedValueAnchorNode, FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, ValueProxy, LimitedValueProxy, Proxy, GuardingNode, Canonicalizable, StateSplit, NodeWithState]
    (defn #_"StateSplitProxyNode" StateSplitProxyNode'new-1 [#_"ValueNode" object]
        (StateSplitProxyNode'new-2 object, false)
    )

    (defn #_"StateSplitProxyNode" StateSplitProxyNode'new-2 [#_"ValueNode" object, #_"boolean" delayElimination]
        (merge (StateSplitProxyNode'class.) (FixedValueAnchorNode'new-1 object)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
                ;;;
                 ; Disallows elimination of this node until after the FrameState has been consumed.
                 ;;
                #_"boolean" :delayElimination delayElimination
            )
        )
    )

    (defm StateSplitProxyNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"StateSplitProxyNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"StateSplitProxyNode" this]
            true
        )
    )

    (defm StateSplitProxyNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"StateSplitProxyNode" this, #_"CanonicalizerTool" tool]
            (when (or (and (satisfies? ConstantNode (:object this)) (not (:delayElimination this))) (nil? (:stateAfter this))) => this
                (:object this)
            )
        )
    )
)

;;;
 ; Intrinsification for getting the address of an object. The code path(s) between a call to
 ; #get(Object) and all uses of the returned value must not contain safepoints. This can
 ; only be guaranteed if used in a snippet that is instantiated after frame state assignment.
 ; ComputeObjectAddressNode should generally be used in preference to this node.
 ;;
(class-ns GetObjectAddressNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    (defn #_"GetObjectAddressNode" GetObjectAddressNode'new-1 [#_"ValueNode" obj]
        (merge (GetObjectAddressNode'class.) (FixedWithNextNode'new-1 (StampFactory'forKind-1 JavaKind/Long))
            (hash-map
                ; @Input
                #_"ValueNode" :object obj
            )
        )
    )

    (defm GetObjectAddressNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"GetObjectAddressNode" this, #_"LIRBuilder" builder]
            (let [
                #_"AllocatableValue" obj (LIRGenerator''newVariable-2 (:gen builder), (LIRKind'unknownReference-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))))
            ]
                (LIRGenerator''emitMove-3 (:gen builder), obj, (LIRBuilder''operand-2 builder, (:object this)))
                (LIRBuilder''setResult-3 builder, this, obj)
            )
            nil
        )
    )
)

;;;
 ; Macro nodes can be used to temporarily replace an invoke. They can, for example, be used to implement constant folding
 ; for known JDK functions like Class#isInterface().
 ;
 ; During lowering, multiple sources are queried in order to look for a replacement:
 ;
 ; (1) If #getLoweredSnippetGraph(LoweringTool) returns a non-nil result, this graph is used as a replacement.
 ; (3) Otherwise, the macro node is replaced with an InvokeNode. Note that this is only possible if the macro node is a MacroStateSplitNode.
 ;;
(class-ns MacroNode [FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"MacroNode" MacroNode'new-5* [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"Stamp" returnStamp & #_"ValueNode..." arguments]
        (merge (MacroNode'class.) (FixedWithNextNode'new-1 returnStamp)
            (hash-map
                ; @Input
                #_"NodeInputList<ValueNode>" :arguments (NodeInputList'new-2s (ร this), arguments)
                #_"int" :bci bci
                #_"ResolvedJavaMethod" :targetMethod targetMethod
                #_"Stamp" :returnStamp returnStamp
                #_"InvokeKind" :invokeKind invokeKind
            )
        )
    )

    (defm MacroNode Node
        (#_"void" Node'''afterClone-2 [#_"MacroNode" this, #_"Node" other]
            nil
        )
    )

    (defm MacroNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"MacroNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"InvokeNode" invoke (MacroNode''replaceWithInvoke-1 this)
            ]
                (when (BytecodeFrame/isPlaceholderBci (:bci invoke))
                    (throw! (str (:graph this) ": cannot lower to invoke with placeholder BCI: " this))
                )
                (when (nil? (:stateAfter invoke))
                    (let [
                        #_"ResolvedJavaMethod" method (:rootMethod (:graph this))
                    ]
                        (when (some? (#_"ResolvedJavaMethod" .getAnnotation method, Snippet)) => (throw! (str (:graph this) ": cannot lower to invoke without state: " this))
                            ;; One cause for this is that a MacroNode is created for a method that no longer
                            ;; needs a MacroNode. For example, Class.getComponentType() only needs a MacroNode
                            ;; prior to JDK9 as it was given a non-native implementation in JDK9.
                            (throw! (str (#_"Class" .getSimpleName (#_"Object" .getClass this)) " macro created for call to " (#_"ResolvedJavaMethod" .format (:targetMethod this), "%h.\n(%p)") " in " (:graph this) " must be lowerable to a snippet or intrinsic graph. Maybe a macro node is not needed for this method in the current JDK?"))
                        )
                    )
                )
                (Lowerable'''lower-2 invoke, lowerer)
            )
            nil
        )
    )

    (defn #_"InvokeNode" MacroNode''replaceWithInvoke-1 [#_"MacroNode" this]
        (let [
            #_"InvokeNode" invoke (MacroNode''createInvoke-1 this)
        ]
            (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, invoke))
            invoke
        )
    )

    (defn #_"InvokeNode" MacroNode''createInvoke-1 [#_"MacroNode" this]
        (let [
            #_"MethodCallTargetNode" callTarget (Graph''add-2 (:graph this), (MethodCallTargetNode'new-4 (:invokeKind this), (:targetMethod this), (into-array ValueNode'iface (:arguments this)), (:returnStamp this)))
            #_"InvokeNode" invoke (Graph''add-2 (:graph this), (InvokeNode'new-2 callTarget, (:bci this)))
        ]
            (when (some? (:stateAfter this))
                (StateSplit'''setStateAfter-2 invoke, (FrameState''duplicate-1 (:stateAfter this)))
                (when-not (= (ValueNode''getStackKind-1 this) JavaKind/Void)
                    (Node''replaceFirstInput-3 (:stateAfter invoke), this, invoke)
                )
            )
            invoke
        )
    )
)

;;;
 ; This is an extension of MacroNode that is a StateSplit and a MemoryCheckpoint.
 ;;
(class-ns MacroStateSplitNode [MacroNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, StateSplit, NodeWithState, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"MacroStateSplitNode" MacroStateSplitNode'new-5* [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"Stamp" returnStamp & #_"ValueNode..." arguments]
        (merge (MacroStateSplitNode'class.) (apply MacroNode'new-5* invokeKind, targetMethod, bci, returnStamp, arguments)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateAfter nil
            )
        )
    )

    (defm MacroStateSplitNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"MacroStateSplitNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"MacroStateSplitNode" this]
            true
        )
    )

    (defm MacroStateSplitNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"MacroStateSplitNode" this]
            LocationIdentity'ANY
        )
    )
)

(class-ns ReflectionGetCallerClassNode [MacroStateSplitNode, MacroNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, StateSplit, NodeWithState, Single, MemoryCheckpoint, MemoryNode, Canonicalizable]
    (defn #_"ReflectionGetCallerClassNode" ReflectionGetCallerClassNode'new-5* [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"Stamp" returnStamp & #_"ValueNode..." arguments]
        (merge (ReflectionGetCallerClassNode'class.) (apply MacroStateSplitNode'new-5* invokeKind, targetMethod, bci, returnStamp, arguments))
    )

    ;;;
     ; If inlining is deep enough, this method returns a ConstantNode of the caller class by walking the stack.
     ;;
    (defn- #_"ConstantNode" ReflectionGetCallerClassNode''getCallerClassNode-1 [#_"ReflectionGetCallerClassNode" this]
        ;; Walk back up the frame states to find the caller at the required depth (see JVM_GetCallerClass).
        ;; Start the loop at depth 1, because the current frame state does not include the Reflection.getCallerClass() frame.
        (loop-when [#_"int" n 1 #_"FrameState" state (:stateAfter this)] (some? state) => nil ;; let JVM_GetCallerClass do the work
            (let [
                #_"HotSpotResolvedJavaMethod" method (FrameState''getMethod-1 state)
            ]
                (if (< 1 n)
                    (when-not (#_"HotSpotResolvedJavaMethod" .ignoredBySecurityStackWalk method)
                        ;; We have reached the desired frame: return the holder class.
                        (ยง return (ConstantNode'forConstant-1 (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"HotSpotResolvedJavaMethod" .getDeclaringClass method))))
                    )
                    ;; Frame 0 and 1 must be caller sensitive (see JVM_GetCallerClass).
                    (when-not (#_"HotSpotResolvedJavaMethod" .isCallerSensitive method)
                        (ยง return nil) ;; let JVM_GetCallerClass do the work
                    )
                )
                (recur (inc n) (:outerFrameState state))
            )
        )
    )

    (defm ReflectionGetCallerClassNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"ReflectionGetCallerClassNode" this, #_"CanonicalizerTool" tool]
            (or (ReflectionGetCallerClassNode''getCallerClassNode-1 this)
                this
            )
        )
    )

    (defm ReflectionGetCallerClassNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"ReflectionGetCallerClassNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"ConstantNode" callerClassNode (ReflectionGetCallerClassNode''getCallerClassNode-1 this)
            ]
                (if (some? callerClassNode)
                    (ยง ass! (:graph this) (Graph''replaceFixedWithFloating-3 (:graph this), this, (Graph''addOrUniqueWithInputs-2 (:graph this), callerClassNode)))
                    (let [
                        #_"InvokeNode" invoke (MacroNode''createInvoke-1 this)
                    ]
                        (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, invoke))
                        (Lowerable'''lower-2 invoke, lowerer)
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; A helper class to allow elimination of byte code instrumentation that could interfere with escape analysis.
 ;;
(class-ns VirtualizableInvokeMacroNode [MacroStateSplitNode, MacroNode, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, StateSplit, NodeWithState, Single, MemoryCheckpoint, MemoryNode, Virtualizable]
    (defn #_"VirtualizableInvokeMacroNode" VirtualizableInvokeMacroNode'new-5* [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"Stamp" returnStamp & #_"ValueNode..." arguments]
        (merge (VirtualizableInvokeMacroNode'class.) (apply MacroStateSplitNode'new-5* invokeKind, targetMethod, bci, returnStamp, arguments))
    )

    (defm VirtualizableInvokeMacroNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"VirtualizableInvokeMacroNode" this, #_"VirtualizerTool" tool]
            (doseq [#_"ValueNode" arg (:arguments this)]
                (let [
                    #_"ValueNode" alias (VirtualizerTool'''getAlias-2 tool, arg)
                ]
                    (when (satisfies? VirtualObjectNode alias)
                        (VirtualizerTool'''delete-1 tool)
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Creates a memory barrier.
 ;;
(class-ns MembarNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, Single, MemoryCheckpoint, MemoryNode]
    (ยง intrinsic! #_"void" MembarNode'memoryBarrier-1 [#_"int" barriers])

    #_intrinsifier
    (defn #_"MembarNode" MembarNode'new-1 [#_"int" barriers]
        (MembarNode'new-2 barriers, LocationIdentity'ANY)
    )

    (ยง intrinsic! #_"void" MembarNode'memoryBarrier-2 [#_"int" barriers, #_"LocationIdentity" location])

    #_intrinsifier
    (defn #_"MembarNode" MembarNode'new-2 [#_"int" barriers, #_"LocationIdentity" location]
        (merge (MembarNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                #_"int" :barriers barriers
                #_"LocationIdentity" :location location
            )
        )
    )

    (defm MembarNode Single
        (#_"LocationIdentity" Single'''getLocationIdentity-1 [#_"MembarNode" this]
            (:location this)
        )
    )

    (defm MembarNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"MembarNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitMembar-2 (:gen builder), (:barriers this))
            nil
        )
    )
)

(class-ns MemoryAnchorNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, MemoryNode, Canonicalizable]
    (defn #_"MemoryAnchorNode" MemoryAnchorNode'new-0 []
        (merge (MemoryAnchorNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance))
    )

    (defm MemoryAnchorNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"MemoryAnchorNode" this, #_"LIRBuilder" builder]
            ;; Nothing to emit, since this node is used for structural purposes only.
            nil
        )
    )

    (defm MemoryAnchorNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"MemoryAnchorNode" this, #_"CanonicalizerTool" tool]
            (when-not (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                this
            )
        )
    )
)

(class-ns PrefetchAllocateNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    (ยง intrinsic! #_"void" PrefetchAllocateNode'prefetch-1 [#_"Address" address])

    #_intrinsifier
    (defn #_"PrefetchAllocateNode" PrefetchAllocateNode'new-1 [#_"AddressNode" address]
        (merge (PrefetchAllocateNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"AddressNode" :address address
            )
        )
    )

    (defm PrefetchAllocateNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"PrefetchAllocateNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''emitPrefetchAllocate-2 (:gen builder), (LIRBuilder''operand-2 builder, (:address this)))
            nil
        )
    )
)

;;;
 ; Access the value of a specific register.
 ;;
(class-ns ReadRegisterNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    (ยง intrinsic! #_"Word" ReadRegisterNode'registerAsWord-3 [#_"Register" register, #_"boolean" directUse, #_"boolean" incoming])

    #_intrinsifier
    (defn #_"ReadRegisterNode" ReadRegisterNode'new-4i [#_@InjectedNodeParameter #_"Stamp" stamp, #_"Register" register, #_"boolean" directUse, #_"boolean" incoming]
        (merge (ReadRegisterNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ;;;
                 ; The fixed register to access.
                 ;;
                #_"Register" :register register
                ;;;
                 ; When true, subsequent uses of this node use the fixed register; when false, the value is
                 ; moved into a new virtual register so that the fixed register is not seen by uses.
                 ;;
                #_"boolean" :directUse directUse
                ;;;
                 ; When true, this node is also an implicit definition of the value for the register allocator,
                 ; i.e. the register is an implicit incoming value; when false, the register must be defined in
                 ; the same method or must be an register excluded from register allocation.
                 ;;
                #_"boolean" :incoming incoming
            )
        )
    )

    #_unused
    (defn #_"ReadRegisterNode" ReadRegisterNode'new-4r [#_"Register" register, #_"JavaKind" kind, #_"boolean" directUse, #_"boolean" incoming]
        (ReadRegisterNode'new-4i (StampFactory'forKind-1 kind), register, directUse, incoming)
    )

    (defm ReadRegisterNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ReadRegisterNode" this, #_"LIRBuilder" builder]
            (let [
                #_"LIRKind" kind (Stamp'''getLIRKind-1 (:stamp this))
                #_"Value" result (#_"Register" .asValue (:register this), kind)
            ]
                (when (:incoming this)
                    (LIRGenerator''emitIncomingValues-2 (:gen builder), (into-array Value [ result ]))
                )
                (when-not (:directUse this)
                    (ยง ass result (LIRGenerator''emitMove-2 (:gen builder), result))
                )
                (LIRBuilder''setResult-3 builder, this, result)
            )
            nil
        )
    )
)

(class-ns SnippetAnchorNode [FixedWithNextNode, FixedNode, ValueNode, Node, Simplifiable, GuardingNode]
    (ยง intrinsic! #_"GuardingNode" SnippetAnchorNode'anchor-0 [])

    #_intrinsifier
    (defn #_"SnippetAnchorNode" SnippetAnchorNode'new-0 []
        (merge (SnippetAnchorNode'class.) (FixedWithNextNode'new-1 StampFactory'objectStamp))
    )

    (defm SnippetAnchorNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"SnippetAnchorNode" this, #_"SimplifierTool" tool]
            (let [
                #_"AbstractBeginNode" prevBegin (AbstractBeginNode'prevBegin-1 this)
            ]
                (Node''replaceAtUsages-3 this, InputType'Anchor, prevBegin)
                (Node''replaceAtUsages-3 this, InputType'Guard, prevBegin)
                (when (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                    (Graph''removeFixed-2 (:graph this), this)
                )
            )
            nil
        )
    )
)

(class-ns SpillRegistersNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable]
    #_unused
    (defn #_"SpillRegistersNode" SpillRegistersNode'new-0 []
        (merge (SpillRegistersNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance))
    )

    (defm SpillRegistersNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"SpillRegistersNode" this, #_"LIRBuilder" builder]
            (LIRGenerator''append-2 (:gen builder), (SpillRegistersOp'new-0))
            nil
        )
    )
)

(class-ns StoreHubNode [FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (ยง intrinsic! #_"void" StoreHubNode'write-2 [#_"Object" object, #_"Object" value])

    #_intrinsifier
    (defn #_"StoreHubNode" StoreHubNode'new-2 [#_"ValueNode" object, #_"ValueNode" value]
        (merge (StoreHubNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defn- #_"WriteNode" StoreHubNode'createWriteHub-3 [#_"Graph" graph, #_"ValueNode" object, #_"ValueNode" value]
        (let [
            #_"ValueNode" writeValue (if HotSpot'useCompressedClassPointers (HotSpotCompressionNode'compress-2 value, HotSpot'klassEncoding) value)
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, object, HotSpot'hubOffset)
        ]
            (Graph''add-2 graph, (WriteNode'new-4 address, NamedLocationIdentity'HUB_WRITE, writeValue, BarrierType'NONE))
        )
    )

    (defm StoreHubNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"StoreHubNode" this, #_"LoweringTool" lowerer]
            (ยง ass! (:graph this) (Graph''replaceFixed-3 (:graph this), this, (StoreHubNode'createWriteHub-3 (:graph this), (:object this), (:value this))))
            nil
        )
    )
)

;;;
 ; If the stub returns an object, the graph corresponds to this pseudo code:
 ;
 ;     Object foreignFunctionStub(args...) {
 ;         foreignFunction(currentThread, args);
 ;         if (clearPendingException(thread())) {
 ;             getAndClearObjectResult(thread());
 ;             DeoptimizeCallerNode.deopt(InvalidateReprofile, RuntimeConstraint);
 ;         }
 ;         return getAndClearObjectResult(thread());
 ;     }
 ;
 ; If the stub returns a primitive or word, the graph corresponds to this pseudo code
 ; (using {@code int} as the primitive return type):
 ;
 ;     int foreignFunctionStub(args...) {
 ;         int result = foreignFunction(currentThread, args);
 ;         if (clearPendingException(thread())) {
 ;             DeoptimizeCallerNode.deopt(InvalidateReprofile, RuntimeConstraint);
 ;         }
 ;         return result;
 ;     }
 ;
 ; If the stub is void, the graph corresponds to this pseudo code:
 ;
 ;     void foreignFunctionStub(args...) {
 ;         foreignFunction(currentThread, args);
 ;         if (clearPendingException(thread())) {
 ;             DeoptimizeCallerNode.deopt(InvalidateReprofile, RuntimeConstraint);
 ;         }
 ;     }
 ;
 ; In each example above, the {@code currentThread} argument is the C++ JavaThread value
 ; (i.e. %r15 on AMD64) and is only prepended if #prependThread is true.
 ;;

;;;
 ; Node for a foreign call from within a stub.
 ;;
(class-ns StubForeignCallNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, Multi, MemoryCheckpoint, MemoryNode]
    #_intrinsifier
    (defn #_"StubForeignCallNode" StubForeignCallNode'new-3* [#_@InjectedNodeParameter #_"Stamp" stamp, #_"ForeignCallDescriptor" descriptor & #_"ValueNode..." arguments]
        (merge (StubForeignCallNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"NodeInputList<ValueNode>" :arguments (NodeInputList'new-2s (ร this), arguments)
                #_"ForeignCallDescriptor" :descriptor descriptor
            )
        )
    )

    (ยง intrinsic! #_"void" StubForeignCallNode'newInstance-3 [#_"ForeignCallDescriptor" descriptor, #_"Word" thread, #_"KlassPointer" hub])
    (ยง intrinsic! #_"void" StubForeignCallNode'newArray-4 [#_"ForeignCallDescriptor" descriptor, #_"Word" thread, #_"KlassPointer" hub, #_"int" length])

    (ยง intrinsic! #_"void" StubForeignCallNode'monitorenter-4 [#_"ForeignCallDescriptor" descriptor, #_"Word" thread, #_"Object" object, #_"Word" lock])
    (ยง intrinsic! #_"void" StubForeignCallNode'monitorexit-4 [#_"ForeignCallDescriptor" descriptor, #_"Word" thread, #_"Object" object, #_"Word" lock])

    (ยง intrinsic! #_"void" StubForeignCallNode'g1PreBarrier-3 [#_"ForeignCallDescriptor" descriptor, #_"Word" thread, #_"Object" object])
    (ยง intrinsic! #_"void" StubForeignCallNode'g1PostBarrier-3 [#_"ForeignCallDescriptor" descriptor, #_"Word" thread, #_"Word" card])

    (defm StubForeignCallNode Multi
        (#_"LocationIdentity*" Multi'''getLocationIdentities-1 [#_"StubForeignCallNode" this]
            (let [
                #_"LocationIdentity[]" killedLocations (ForeignCalls''getKilledLocations-2 HotSpot'foreignCalls, (:descriptor this))
                killedLocations (Arrays/copyOf killedLocations, (inc (count killedLocations)))
            ]
                (aset killedLocations (dec (count killedLocations)) NamedLocationIdentity'PENDING_EXCEPTION)
                killedLocations
            )
        )
    )

    (defn #_"Value[]" StubForeignCallNode''operands-2 [#_"StubForeignCallNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value[]" operands (make-array Value (count (:arguments this)))
        ]
            (dotimes [#_"int" i (count operands)]
                (aset operands i (LIRBuilder''operand-2 builder, (nth (:arguments this) i)))
            )
            operands
        )
    )

    (defm StubForeignCallNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"StubForeignCallNode" this, #_"LIRBuilder" builder]
            (let [
                #_"ForeignCallLinkage" linkage (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, (:descriptor this))
                #_"Value[]" operands (StubForeignCallNode''operands-2 this, builder)
                #_"Value" result (apply LIRGenerator''emitForeignCall-3* (:gen builder), linkage, operands)
            ]
                (when (some? result)
                    (LIRBuilder''setResult-3 builder, this, result)
                )
            )
            nil
        )
    )
)

(class-ns UnboxNode [FixedWithNextNode, FixedNode, ValueNode, Node, Virtualizable, Lowerable, Unary #_"<ValueNode>", Canonicalizable]
    (defm UnboxNode Unary
        (#_"ValueNode" Unary'''getValue-1 [#_"UnboxNode" this]
            (:value this)
        )
    )

    (defn #_"UnboxNode" UnboxNode'new-2 [#_"ValueNode" value, #_"JavaKind" boxingKind]
        (merge (UnboxNode'class.) (FixedWithNextNode'new-1 (StampFactory'forKind-1 (#_"JavaKind" .getStackKind boxingKind)))
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                #_"JavaKind" :boxingKind boxingKind
            )
        )
    )

    (defn- #_"ValueNode" UnboxNode'findSynonym-2 [#_"ValueNode" value, #_"JavaKind" boxingKind]
        (cond
            (satisfies? ConstantNode value)
                (let [
                    #_"JavaConstant" unboxed (#_"ConstantReflectionProvider" .unboxPrimitive HotSpot'constantReflection, (ValueNode''asJavaConstant-1 value))
                ]
                    (when (and (some? unboxed) (= (#_"JavaConstant" .getJavaKind unboxed) boxingKind))
                        (ConstantNode'forConstant-1 unboxed)
                    )
                )
            (satisfies? BoxNode value)
                (when (= boxingKind (:boxingKind value))
                    (Unary'''getValue-1 value)
                )
        )
    )

    #_unused
    (defn #_"ValueNode" UnboxNode'create-2 [#_"ValueNode" value, #_"JavaKind" boxingKind]
        (or (UnboxNode'findSynonym-2 value, boxingKind) (UnboxNode'new-2 value, boxingKind))
    )

    (defm UnboxNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"UnboxNode" this, #_"LoweringTool" lowerer]
            (BoxingTemplates''lower-3u Lowerer'boxingSnippets, this, lowerer)
            nil
        )
    )

    (defm UnboxNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"UnboxNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" alias (VirtualizerTool'''getAlias-2 tool, (Unary'''getValue-1 this))
            ]
                (when (satisfies? VirtualObjectNode alias)
                    (let [
                        #_"ResolvedJavaType" objectType (VirtualObjectNode'''type-1 alias)
                        #_"ResolvedJavaType" expectedType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (#_"JavaKind" .toBoxedJavaClass (:boxingKind this)))
                    ]
                        (when (= objectType expectedType)
                            (VirtualizerTool'''replaceWithValue-2 tool, (VirtualizerTool'''getEntry-3 tool, alias, 0))
                        )
                    )
                )
            )
            nil
        )
    )

    (defm UnboxNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"UnboxNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (when-not (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this) (StampTool'isPointerNeverNull-1 (:stamp value)))
                (or (UnboxNode'findSynonym-2 value, (:boxingKind this))
                    this
                )
            )
        )
    )

    (defm UnboxNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"UnboxNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )
)

(class-ns UnsafeAccessNode [FixedWithNextNode, FixedNode, ValueNode, Node, Canonicalizable]
    (defn #_"UnsafeAccessNode" UnsafeAccessNode'new-6 [#_"Stamp" stamp, #_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity, #_"boolean" forceAnyLocation]
        (merge (UnsafeAccessNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :object object
                ; @Input
                #_"ValueNode" :offset offset
                #_"JavaKind" :accessKind accessKind
                #_"LocationIdentity" :locationIdentity locationIdentity
                #_"boolean" :forceAnyLocation forceAnyLocation
            )
        )
    )

    (defm UnsafeAccessNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"UnsafeAccessNode" this, #_"CanonicalizerTool" tool]
            (when (and (not (:forceAnyLocation this)) (LocationIdentity''isAny-1 (:locationIdentity this))) => this
                (when (satisfies? ConstantNode (:offset this))
                    (let [
                        #_"long" constantOffset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this)))
                        ;; Try to canonicalize to a field access.
                        #_"ResolvedJavaType" receiverType (StampTool'typeOrNull-1 (:stamp (:object this)))
                    ]
                        (when (some? receiverType)
                            (let [
                                #_"ResolvedJavaField" field (#_"ResolvedJavaType" .findInstanceFieldWithOffset receiverType, constantOffset, (:accessKind this))
                            ]
                                ;; No need for checking that the receiver is non-nil. The field access includes
                                ;; the nil-check and if a field is found, the offset is so small that this is
                                ;; never a valid access of an arbitrary address.
                                (when (and (some? field) (= (#_"JavaType" .getJavaKind field) (:accessKind this)))
                                    (ยง return (UnsafeAccessNode'''cloneAsFieldAccess-2 this, field))
                                )
                            )
                        )
                    )
                )
                (let [
                    #_"ResolvedJavaType" receiverType (StampTool'typeOrNull-1 (:stamp (:object this)))
                ]
                    ;; Try to build a better location identity.
                    (when (and (some? receiverType) (#_"ResolvedJavaType" .isArray receiverType)) => this
                        (UnsafeAccessNode'''cloneAsArrayAccess-3 this, (:offset this), (NamedLocationIdentity'getArrayLocation-1 (#_"JavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType receiverType))))
                    )
                )
            )
        )
    )
)

;;;
 ; Load of a value from a location specified as an offset relative to an object. No nil-check is performed before the load.
 ;;
(class-ns RawLoadNode [UnsafeAccessNode, FixedWithNextNode, FixedNode, ValueNode, Node, Canonicalizable, Lowerable, Virtualizable]
    (ยง intrinsic! #_"Word" RawLoadNode'loadWordFromObjectIntrinsic-4 [#_"Object" object, #_"long" offset, #_"LocationIdentity" location, #_"JavaKind" wordKind])

    #_unused
    (ยง intrinsic! #_"KlassPointer" RawLoadNode'loadKlassFromObjectIntrinsic-4 [#_"Object" object, #_"long" offset, #_"LocationIdentity" location, #_"JavaKind" wordKind])

    #_intrinsifier
    (defn #_"RawLoadNode" RawLoadNode'new-5 [#_@InjectedNodeParameter #_"Stamp" stamp, #_"ValueNode" object, #_"ValueNode" offset, #_"LocationIdentity" location, #_"JavaKind" accessKind]
        (merge (RawLoadNode'class.) (UnsafeAccessNode'new-6 stamp, object, offset, accessKind, location, false))
    )

    (defn #_"RawLoadNode" RawLoadNode'new-4 [#_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" location]
        (merge (RawLoadNode'class.) (UnsafeAccessNode'new-6 (StampFactory'forKind-1 (#_"JavaKind" .getStackKind accessKind)), object, offset, accessKind, location, false))
    )

    (defn- #_"boolean" RawLoadNode''addReadBarrier-1 [#_"RawLoadNode" this]
        (and HotSpot'useG1GC
            (= (:guardsStage (:graph this)) GuardsStage'FIXED_DEOPTS)
            (= (ValueNode''getStackKind-1 (:object this)) JavaKind/Object)
            (= (:accessKind this) JavaKind/Object)
            (not (StampTool'isPointerAlwaysNull-1 (:stamp (:object this))))
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object this)))
            ]
                (and (some? type) (not (#_"ResolvedJavaType" .isArray type)))
            )
        )
    )

    (defn- #_"ValueNode" RawLoadNode'performBooleanCoercionIfNecessary-2 [#_"ValueNode" readValue, #_"JavaKind" readKind]
        (when (= readKind JavaKind/Boolean) => readValue
            (let [
                #_"Graph" graph (:graph readValue)
                #_"IntegerEqualsNode" eq (Graph''add-2 graph, (IntegerEqualsNode'new-2 readValue, (ConstantNode'forInt-2 0, graph)))
            ]
                (Graph''add-2 graph, (ConditionalNode'new-3 eq, (ConstantNode'forBoolean-2 false, graph), (ConstantNode'forBoolean-2 true, graph)))
            )
        )
    )

    (defn #_"ReadNode" RawLoadNode''createUnsafeRead-2 [#_"RawLoadNode" this, #_"GuardingNode" guard]
        (let [
            #_"boolean" compressible? (= (:accessKind this) JavaKind/Object)
            #_"JavaKind" readKind (:accessKind this)
            #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp this), readKind, compressible?)
            #_"AddressNode" address (Lowerer'createUnsafeAddress-3 (:graph this), (:object this), (:offset this))
            #_"ReadNode" memoryRead (Graph''add-2 (:graph this), (ReadNode'new-4 address, (:locationIdentity this), loadStamp, BarrierType'NONE))
        ]
            (if (some? guard)
                (GuardedNode'''setGuard-2 memoryRead, guard)
                ;; An unsafe read must not float, otherwise it may float above a test guaranteeing the read is safe.
                (ยง ass! memoryRead (FloatableAccessNode''setForceFixed-2 memoryRead, true))
            )
            (let [
                #_"ValueNode" readValue (RawLoadNode'performBooleanCoercionIfNecessary-2 (Lowerer'implicitLoadConvert-4 (:graph this), readKind, memoryRead, compressible?), readKind)
            ]
                (ยง ass! this (Node''replaceAtUsages-2 this, readValue))
                memoryRead
            )
        )
    )

    (defm RawLoadNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"RawLoadNode" this, #_"LoweringTool" lowerer]
            (if (and (not (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph this)))) (RawLoadNode''addReadBarrier-1 this))
                (UnsafeLoadTemplates''lower-3 Lowerer'unsafeLoadSnippets, this, lowerer)
                ;; never had a guarding condition, so it must be fixed, creation of the read will force it to be fixed
                (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, (RawLoadNode''createUnsafeRead-2 this, nil)))
            )
            nil
        )
    )

    (defm RawLoadNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"RawLoadNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (satisfies? VirtualObjectNode object)
                    (let [
                        #_"ValueNode" offset (VirtualizerTool'''getAlias-2 tool, (:offset this))
                    ]
                        (when (satisfies? ConstantNode offset)
                            (let [
                                #_"int" i (VirtualObjectNode'''entryIndexForOffset-3 object, (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 offset)), (:accessKind this))
                            ]
                                (when-not (= i -1)
                                    (let [
                                        #_"ValueNode" entry (VirtualizerTool'''getEntry-3 tool, object, i)
                                    ]
                                        (when (or (= (ValueNode''getStackKind-1 entry) (ValueNode''getStackKind-1 this)) (= (VirtualObjectNode'''entryKind-2 object, i) (:accessKind this)))
                                            (cond
                                                (Stamp'''isCompatible-2s (:stamp entry), (:stamp this))
                                                    (VirtualizerTool'''replaceWith-2 tool, entry)
                                                (and (satisfies? PrimitiveStamp (:stamp entry)) (satisfies? PrimitiveStamp (:stamp this)))
                                                    (when (= (:bits (:stamp this)) (:bits (:stamp entry)))
                                                        (VirtualizerTool'''replaceWith-2 tool, (ร ReinterpretNode'create-2 (:stamp entry), entry))
                                                    )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defm RawLoadNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"RawLoadNode" this, #_"CanonicalizerTool" tool]
            (or
                (when (and (not (:forceAnyLocation this)) (LocationIdentity''isAny-1 (:locationIdentity this)))
                    (let [
                        #_"ValueNode" object (:object this)
                    ]
                        (when (and (satisfies? ConstantNode (:offset this)) (satisfies? ConstantNode object) (not (ValueNode''isNullConstant-1 object)))
                            (let [
                                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp object))
                            ]
                                (when (and (some? type) (#_"ResolvedJavaType" .isArray type))
                                    (let [
                                        #_"JavaConstant" array (ValueNode''asJavaConstant-1 object)
                                    ]
                                        (when (some? array)
                                            (let [
                                                #_"int" stableDimension (:stableDimension object)
                                            ]
                                                (when (pos? stableDimension)
                                                    (let [
                                                        #_"long" offset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this)))
                                                        #_"Constant" constant (Stamp'''readConstant-4 (:stamp this), (#_"ConstantReflectionProvider" .getMemoryAccessProvider HotSpot'constantReflection), array, offset)
                                                        #_"boolean" isDefaultStable (:isDefaultStable object)
                                                    ]
                                                        (when (and (some? constant) (or isDefaultStable (not (#_"Constant" .isDefaultForKind constant))))
                                                            (ConstantNode'forConstant-4 (:stamp this), constant, (dec stableDimension), isDefaultStable)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (Canonicalizable'''canonical-2 (ยง super UnsafeAccessNode'iface), tool)
            )
        )
    )

    (defm RawLoadNode UnsafeAccessNode
        (#_"ValueNode" UnsafeAccessNode'''cloneAsFieldAccess-2 [#_"RawLoadNode" this, #_"ResolvedJavaField" field]
            (LoadFieldNode'create-2 (:object this), field)
        )

        (#_"ValueNode" UnsafeAccessNode'''cloneAsArrayAccess-3 [#_"RawLoadNode" this, #_"ValueNode" offset, #_"LocationIdentity" location]
            (RawLoadNode'new-4 (:object this), offset, (:accessKind this), location)
        )
    )
)

;;;
 ; Store of a value at a location specified as an offset relative to an object. No nil-check is performed before the store.
 ;;
(class-ns RawStoreNode [UnsafeAccessNode, FixedWithNextNode, FixedNode, ValueNode, Node, Canonicalizable, StateSplit, NodeWithState, Lowerable, Virtualizable, Single, MemoryCheckpoint, MemoryNode]
    (defn #_"RawStoreNode" RawStoreNode'new-8 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" value, #_"JavaKind" accessKind, #_"LocationIdentity" location, #_"boolean" needsBarrier, #_"FrameState" stateAfter, #_"boolean" forceAnyLocation]
        (merge (RawStoreNode'class.) (UnsafeAccessNode'new-6 VoidStamp'instance, object, offset, accessKind, location, forceAnyLocation)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                #_"boolean" :needsBarrier needsBarrier
                ; @OptionalInput
                #_"FrameState" :stateAfter stateAfter
            )
        )
    )

    (defm RawStoreNode StateSplit
        (#_"void" StateSplit'''setStateAfter-2 [#_"RawStoreNode" this, #_"FrameState" x]
            (Node''updateUsages-3 this, (:stateAfter this), x)
            (ยง ass! this (assoc this :stateAfter x))
            nil
        )

        (#_"boolean" StateSplit'''hasSideEffect-1 [#_"RawStoreNode" this]
            true
        )
    )

    (defn- #_"BarrierType" RawStoreNode''unsafeStoreBarrierType-1 [#_"RawStoreNode" this]
        (when (:needsBarrier this) => BarrierType'NONE
            (Lowerer'storeBarrierType-2 (:object this), (:value this))
        )
    )

    (defm RawStoreNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"RawStoreNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"boolean" compressible? (= (ValueNode''getStackKind-1 (:value this)) JavaKind/Object)
                #_"ValueNode" value (Lowerer'implicitStoreConvert-4 (:graph this), (:accessKind this), (:value this), compressible?)
                #_"AddressNode" address (Lowerer'createUnsafeAddress-3 (:graph this), (:object this), (:offset this))
                #_"WriteNode" write (Graph''add-2 (:graph this), (WriteNode'new-4 address, (:locationIdentity this), value, (RawStoreNode''unsafeStoreBarrierType-1 this)))
            ]
                (StateSplit'''setStateAfter-2 write, (:stateAfter this))
                (ยง ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, write))
            )
            nil
        )
    )

    (defm RawStoreNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"RawStoreNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (satisfies? VirtualObjectNode object)
                    (let [
                        #_"ValueNode" offset (VirtualizerTool'''getAlias-2 tool, (:offset this))
                    ]
                        (when (satisfies? ConstantNode offset)
                            (let [
                                #_"long" off (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 offset))
                                #_"int" i (VirtualObjectNode'''entryIndexForOffset-3 object, off, (:accessKind this))
                            ]
                                (when (and (not= i -1) (VirtualizerTool'''setVirtualEntry-6 tool, object, i, (:value this), (:accessKind this), off))
                                    (VirtualizerTool'''delete-1 tool)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defm RawStoreNode UnsafeAccessNode
        (#_"ValueNode" UnsafeAccessNode'''cloneAsFieldAccess-2 [#_"RawStoreNode" this, #_"ResolvedJavaField" field]
            (StoreFieldNode'new-4 (:object this), field, (:value this), (:stateAfter this))
        )

        (#_"ValueNode" UnsafeAccessNode'''cloneAsArrayAccess-3 [#_"RawStoreNode" this, #_"ValueNode" offset, #_"LocationIdentity" location]
            (RawStoreNode'new-8 (:object this), offset, (:value this), (:accessKind this), location, (:needsBarrier this), (:stateAfter this), (:forceAnyLocation this))
        )
    )
)

;;;
 ; The ValueAnchor instruction keeps non-CFG (floating) nodes above a certain point in the graph.
 ;;
(class-ns ValueAnchorNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, Simplifiable, Virtualizable, AnchoringNode, GuardingNode]
    (defn #_"ValueAnchorNode" ValueAnchorNode'new-1 [#_"ValueNode" value]
        (merge (ValueAnchorNode'class.) (FixedWithNextNode'new-1 VoidStamp'instance)
            (hash-map
                ; @OptionalInput(InputType'Guard)
                #_"ValueNode" :anchored value
            )
        )
    )

    (defm ValueAnchorNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ValueAnchorNode" this, #_"LIRBuilder" builder]
            ;; Nothing to emit, since this node is used for structural purposes only.
            nil
        )
    )

    (defm ValueAnchorNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"ValueAnchorNode" this, #_"SimplifierTool" tool]
            (loop-when [#_"ValueAnchorNode" nextAnchor (:next this)] (satisfies? ValueAnchorNode nextAnchor)
                (when (or (nil? (:anchored nextAnchor)) (= (:anchored nextAnchor) (:anchored this)))
                    ;; two anchors for the same anchored -> coalesce
                    ;; nothing anchored on the next anchor -> coalesce
                    (ยง ass! nextAnchor (Node''replaceAtUsages-2 nextAnchor, this))
                    (GraphUtil'removeFixedWithUnusedInputs-1 nextAnchor)
                    (recur (:next this))
                )
            )
            (if (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this) (satisfies? FixedAccessNode (:next this)) (= (GuardedNode'''getGuard-1 (:next this)) (:anchored this)))
                (GraphUtil'removeFixedWithUnusedInputs-1 this)
                (do
                    (when (and (some? (:anchored this)) (or (satisfies? ConstantNode (:anchored this)) (satisfies? FixedNode (:anchored this))))
                        ;; anchoring fixed nodes and constants is useless
                        (ยง ass! this (ValueAnchorNode''removeAnchoredNode-1 this))
                    )
                    (when (and (nil? (:anchored this)) (Node''hasNoUsages-1 this))
                        ;; anchor is not necessary any more => remove.
                        (GraphUtil'removeFixedWithUnusedInputs-1 this)
                    )
                )
            )
            nil
        )
    )

    (defm ValueAnchorNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"ValueAnchorNode" this, #_"VirtualizerTool" tool]
            (if (or (nil? (:anchored this)) (satisfies? AbstractBeginNode (:anchored this)))
                (VirtualizerTool'''delete-1 tool)
                (when (satisfies? VirtualObjectNode (VirtualizerTool'''getAlias-2 tool, (:anchored this)))
                    (VirtualizerTool'''delete-1 tool)
                )
            )
            nil
        )
    )

    (defn #_"ValueAnchorNode" ValueAnchorNode''removeAnchoredNode-1 [#_"ValueAnchorNode" this]
        (Node''updateUsages-3 this, (:anchored this), nil)
        (assoc this :anchored nil)
    )
)

;;;
 ; Casts between Word and Object exposed by the Word#fromAddress, Word#objectToTrackedPointer,
 ; Word#objectToUntrackedPointer and Word#toObject() operations. It has an impact on the pointer
 ; maps for the GC, so it must not be scheduled or optimized away.
 ;;
(class-ns WordCastNode [FixedWithNextNode, FixedNode, ValueNode, Node, LIRLowerable, Canonicalizable]
    (defn #_"WordCastNode" WordCastNode'new-2 [#_"Stamp" stamp, #_"ValueNode" input]
        (merge (WordCastNode'class.) (FixedWithNextNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :input input
            )
        )
    )

    (defn #_"WordCastNode" WordCastNode'wordToObject-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 StampFactory'objectStamp, input)
    )

    (defn #_"WordCastNode" WordCastNode'wordToObjectNonNull-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 StampFactory'objectNonNullStamp, input)
    )

    (defn #_"WordCastNode" WordCastNode'objectToWord-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 (StampFactory'forKind-1 wordKind), input)
    )

    (defn #_"WordCastNode" WordCastNode'addressToWord-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 (StampFactory'forKind-1 wordKind), input)
    )

    (defm WordCastNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"WordCastNode" this, #_"CanonicalizerTool" tool]
            (cond
                (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                    ;; if the cast is unused, it can be eliminated
                    (:input this)
                (satisfies? ConstantNode (:input this))
                    ;; null pointers are uncritical for GC, so they can be constant folded
                    (cond
                        (#_"JavaConstant" .isNull (ValueNode''asJavaConstant-1 (:input this)))
                            (ConstantNode'forIntegerStamp-2 (:stamp this), 0)
                        (and (-> (ValueNode''asJavaConstant-1 (:input this)) (#_"JavaConstant" .getJavaKind) (#_"JavaKind" .isNumericInteger))
                            (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:input this))))
                        )
                            (ConstantNode'forConstant-2s (:stamp this), JavaConstant/NULL_POINTER)
                        :else
                            this
                    )
                :else
                    this
            )
        )
    )

    (defm WordCastNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"WordCastNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" value (LIRBuilder''operand-2 builder, (:input this))
                #_"ValueKind" kind (Stamp'''getLIRKind-1 (:stamp this))
                kind
                    (when (and (LIRKind'isValue-1k kind) (not (LIRKind'isValue-1v value))) => kind
                        ;; just change the PlatformKind, but don't drop reference information
                        (#_"ValueKind" .changeType (#_"Value" .getValueKind value), (#_"ValueKind" .getPlatformKind kind))
                    )
            ]
                (if (and (= kind (#_"Value" .getValueKind value)) (not (satisfies? ConstantValue value)))
                    (LIRBuilder''setResult-3 builder, this, value)
                    (let [
                        #_"AllocatableValue" result (LIRGenerator''newVariable-2 (:gen builder), kind)
                    ]
                        (LIRGenerator''emitMove-3 (:gen builder), result, value)
                        (LIRBuilder''setResult-3 builder, this, result)
                    )
                )
            )
            nil
        )
    )
)

(class-ns WriteBarrier [FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"WriteBarrier" WriteBarrier'new-0 []
        (merge (WriteBarrier'class.) (FixedWithNextNode'new-1 VoidStamp'instance))
    )

    (defm WriteBarrier Lowerable
        (#_"void" Lowerable'''lower-2 [#_"WriteBarrier" this, #_"LoweringTool" lowerer]
            (ร WriteBarrierTemplates''lower-3 Lowerer'writeBarrierSnippets, this, lowerer)
            nil
        )
    )
)

(class-ns ObjectWriteBarrier [WriteBarrier, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"ObjectWriteBarrier" ObjectWriteBarrier'new-3 [#_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?]
        (merge (ObjectWriteBarrier'class.) (WriteBarrier'new-0)
            (hash-map
                ; @Input
                #_"AddressNode" :address address
                ; @OptionalInput
                #_"ValueNode" :value value
                #_"boolean" :precise? precise?
            )
        )
    )
)

(class-ns G1PostWriteBarrier [ObjectWriteBarrier, WriteBarrier, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"G1PostWriteBarrier" G1PostWriteBarrier'new-4 [#_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"boolean" always-nil?]
        (merge (G1PostWriteBarrier'class.) (ObjectWriteBarrier'new-3 address, value, precise?)
            (hash-map
                #_"boolean" :always-nil? always-nil?
            )
        )
    )
)

(class-ns G1PreWriteBarrier [ObjectWriteBarrier, WriteBarrier, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable, DeoptBefore, DeoptimizingNode, NodeWithState]
    (defn #_"G1PreWriteBarrier" G1PreWriteBarrier'new-4 [#_"AddressNode" address, #_"ValueNode" expectedObject, #_"boolean" doLoad, #_"boolean" nullCheck]
        (merge (G1PreWriteBarrier'class.) (ObjectWriteBarrier'new-3 address, expectedObject, true)
            (hash-map
                ; @OptionalInput
                #_"FrameState" :stateBefore nil
                #_"boolean" :nullCheck nullCheck
                #_"boolean" :doLoad doLoad
            )
        )
    )

    (defm G1PreWriteBarrier DeoptimizingNode
        (#_"boolean" DeoptimizingNode'''canDeoptimize-1 [#_"G1PreWriteBarrier" this]
            (:nullCheck this)
        )
    )

    (defm G1PreWriteBarrier DeoptBefore
        (#_"void" DeoptBefore'''setStateBefore-2 [#_"G1PreWriteBarrier" this, #_"FrameState" state]
            (Node''updateUsages-3 this, (:stateBefore this), state)
            (ยง ass! this (assoc this :stateBefore state))
            nil
        )
    )
)

;;;
 ; The G1ReferentFieldReadBarrier is added when a read access is performed to the referent field
 ; of a {@link java.lang.ref.Reference} object (through a LoadFieldNode or an UnsafeLoadNode).
 ; The return value of the read is passed to the snippet implementing the read barrier and
 ; consequently is added to the SATB queue if the concurrent marker is enabled.
 ;;
(class-ns G1ReferentFieldReadBarrier [ObjectWriteBarrier, WriteBarrier, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"G1ReferentFieldReadBarrier" G1ReferentFieldReadBarrier'new-3 [#_"AddressNode" address, #_"ValueNode" expectedObject, #_"boolean" doLoad]
        (merge (G1ReferentFieldReadBarrier'class.) (ObjectWriteBarrier'new-3 address, expectedObject, true)
            (hash-map
                #_"boolean" :doLoad doLoad
            )
        )
    )

    (defn #_"ValueNode" G1ReferentFieldReadBarrier''getExpectedObject-1 [#_"G1ReferentFieldReadBarrier" this]
        (:value this)
    )
)

(class-ns SerialWriteBarrier [ObjectWriteBarrier, WriteBarrier, FixedWithNextNode, FixedNode, ValueNode, Node, Lowerable]
    (defn #_"SerialWriteBarrier" SerialWriteBarrier'new-2 [#_"AddressNode" address, #_"boolean" precise?]
        (merge (SerialWriteBarrier'class.) (ObjectWriteBarrier'new-3 address, nil, precise?))
    )
)

(class-ns FloatingNode [ValueNode, Node]
    (defn #_"FloatingNode" FloatingNode'new-1 [#_"Stamp" stamp]
        (merge (FloatingNode'class.) (ValueNode'new-1 stamp))
    )
)

(class-ns AbstractLocalNode [FloatingNode, ValueNode, Node]
    (defn #_"AbstractLocalNode" AbstractLocalNode'new-2 [#_"int" index, #_"Stamp" stamp]
        (merge (AbstractLocalNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                #_"int" :index index
            )
        )
    )

    ;;;
     ; Gets the index of this local in the array of parameters. This is NOT the JVM local index.
     ;
     ; @return the index
     ;;
    (defn #_"int" AbstractLocalNode''index-1 [#_"AbstractLocalNode" this]
        (:index this)
    )
)

;;;
 ; The Parameter instruction is a placeholder for an incoming argument to a function call.
 ;;
(class-ns ParameterNode [AbstractLocalNode, FloatingNode, ValueNode, Node]
    (defn #_"ParameterNode" ParameterNode'new-2 [#_"int" index, #_"Stamp" stamp]
        (merge (ParameterNode'class.) (AbstractLocalNode'new-2 index, stamp))
    )
)

(class-ns AddressNode [FloatingNode, ValueNode, Node, IndirectCanonicalization]
    (defn #_"AddressNode" AddressNode'new-0 []
        (merge (AddressNode'class.) (FloatingNode'new-1 StampFactory'rawPointer))
    )
)

;;;
 ; Represents an address of the form [base + index*scale + displacement]. Both base and index are optional.
 ;;
(class-ns AMD64AddressNode [AddressNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, Simplifiable, LIRLowerable]
    (defn #_"AMD64AddressNode" AMD64AddressNode'new-2 [#_"ValueNode" base, #_"ValueNode" index]
        (merge (AMD64AddressNode'class.) (AddressNode'new-0)
            (hash-map
                ; @OptionalInput
                #_"ValueNode" :base base
                ; @OptionalInput
                #_"ValueNode" :index index
                #_"Scale" :scale Scale'Times1
                #_"int" :displacement 0
            )
        )
    )

    (defn #_"AMD64AddressNode" AMD64AddressNode''canonicalizeIndex-2 [#_"AMD64AddressNode" this, #_"SimplifierTool" tool]
        (when (and (satisfies? AddNode (:index this)) (= (:bits (:stamp (:index this))) 64)) => this
            (let [
                #_"AddNode" add (:index this)
            ]
                (when (and (satisfies? PhiNode (:x add)) (satisfies? LoopBeginNode (:merge (:x add)))) => this
                    (let [
                        #_"LoopBeginNode" loopNode (:merge (:x add))
                    ]
                        (when (and (not (LoopBeginNode''isSimpleLoop-1 loopNode)) (satisfies? ConstantNode (:y add))) => this
                            (let [
                                #_"int" addBy (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y add)))
                                this (assoc this :displacement (+ (:displacement this) (* (:value (:scale this)) addBy)))
                            ]
                                (Node''replaceFirstInput-3 this, (:index this), (:x add))
                                (SimplifierTool'''addToWorkList-2n tool, (:index this))
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    (defm AMD64AddressNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AMD64AddressNode" this, #_"LIRBuilder" builder]
            (let [
                #_"AllocatableValue" baseValue (if (some? (:base this)) (LIRGenerator''asAllocatable-2 (:gen builder), (LIRBuilder''operand-2 builder, (:base this))) Value/ILLEGAL)
                #_"AllocatableValue" indexValue (if (some? (:index this)) (LIRGenerator''asAllocatable-2 (:gen builder), (LIRBuilder''operand-2 builder, (:index this))) Value/ILLEGAL)
                #_"AllocatableValue" baseReference (LIRKind'derivedBaseFromValue-1 baseValue)
                #_"AllocatableValue" indexReference
                    (cond
                        (nil? (:index this))           nil
                        (= (:scale this) Scale'Times1) (LIRKind'derivedBaseFromValue-1 indexValue)
                        (LIRKind'isValue-1v indexValue) nil
                        :else                          Value/ILLEGAL
                    )
                #_"LIRKind" kind (LIRKind'combineDerived-3 (Stamp'''getLIRKind-1 (:stamp this)), baseReference, indexReference)
            ]
                (LIRBuilder''setResult-3 builder, this, (AMD64AddressValue'new-5 kind, baseValue, indexValue, (:scale this), (:displacement this)))
            )
            nil
        )
    )

    (defm AMD64AddressNode AddressNode
        (#_"ValueNode" AddressNode'''getBase-1 [#_"AMD64AddressNode" this]
            (:base this)
        )
    )

    (defn #_"AMD64AddressNode" AMD64AddressNode''setBase-2 [#_"AMD64AddressNode" this, #_"ValueNode" base]
        ;; allow modification before inserting into the graph
        (when (Node''isAlive-1 this)
            (Node''updateUsages-3 this, (:base this), base)
        )
        (assoc this :base base)
    )

    (defm AMD64AddressNode AddressNode
        (#_"ValueNode" AddressNode'''getIndex-1 [#_"AMD64AddressNode" this]
            (:index this)
        )
    )

    (defn #_"AMD64AddressNode" AMD64AddressNode''setIndex-2 [#_"AMD64AddressNode" this, #_"ValueNode" index]
        ;; allow modification before inserting into the graph
        (when (Node''isAlive-1 this)
            (Node''updateUsages-3 this, (:index this), index)
        )
        (assoc this :index index)
    )

    (defn #_"AMD64AddressNode" AMD64AddressNode''setScale-2 [#_"AMD64AddressNode" this, #_"Scale" scale]
        (assoc this :scale scale)
    )

    (defn #_"AMD64AddressNode" AMD64AddressNode''setDisplacement-2 [#_"AMD64AddressNode" this, #_"int" displacement]
        (assoc this :displacement displacement)
    )

    (defm AMD64AddressNode AddressNode
        (#_"long" AddressNode'''getMaxConstantDisplacement-1 [#_"AMD64AddressNode" this]
            (:displacement this)
        )
    )

    (defm AMD64AddressNode Simplifiable
        (#_"void" Simplifiable'''simplify-2 [#_"AMD64AddressNode" this, #_"SimplifierTool" tool]
            (ยง ass! this (AMD64AddressNode''canonicalizeIndex-2 this, tool))
            nil
        )
    )
)

;;;
 ; Represents an address that is composed of a base and an offset. The base can be either a
 ; JavaKind#Object, a word-sized integer or another pointer. The offset must be a word-sized integer.
 ;;
(class-ns OffsetAddressNode [AddressNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, Canonicalizable]
    (ยง intrinsic! #_"Address" OffsetAddressNode'address-2 [#_"Object" base, #_"long" offset])

    #_intrinsifier
    (defn #_"OffsetAddressNode" OffsetAddressNode'new-2 [#_"ValueNode" base, #_"ValueNode" offset]
        (merge (OffsetAddressNode'class.) (AddressNode'new-0)
            (hash-map
                ; @Input
                #_"ValueNode" :base base
                ; @Input
                #_"ValueNode" :offset offset
            )
        )
    )

    (defn #_"OffsetAddressNode" OffsetAddressNode'create-1 [#_"ValueNode" base]
        (OffsetAddressNode'new-2 base, (ConstantNode'forIntegerBits-2l (PrimitiveStamp'getBits-1 (:stamp base)), 0))
    )

    (defm OffsetAddressNode AddressNode
        (#_"ValueNode" AddressNode'''getBase-1 [#_"OffsetAddressNode" this]
            (:base this)
        )
    )

    (defm OffsetAddressNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"OffsetAddressNode" this, #_"CanonicalizerTool" tool]
            (condp satisfies? (:base this)
                OffsetAddressNode
                    ;; Rewrite (&base[offset1])[offset2] to base[offset1 + offset2].
                    (OffsetAddressNode'new-2 (AddressNode'''getBase-1 (:base this)), (BinaryArithmeticNode'add-2 (:offset (:base this)), (:offset this)))
                AddNode
                    (if (satisfies? ConstantNode (:y (:base this)))
                        (OffsetAddressNode'new-2 (:x (:base this)), (AddNode'new-2 (:y (:base this)), (:offset this)))
                        this
                    )
                this
            )
        )
    )

    (defm OffsetAddressNode AddressNode
        (#_"long" AddressNode'''getMaxConstantDisplacement-1 [#_"OffsetAddressNode" this]
            (let [
                #_"Stamp" stamp (:stamp (:offset this))
            ]
                (if (and (satisfies? IntegerStamp stamp) (<= 0 (:lowerBound stamp))) (:upperBound stamp) Long/MAX_VALUE)
            )
        )

        (#_"ValueNode" AddressNode'''getIndex-1 [#_"OffsetAddressNode" this]
            nil
        )
    )
)

;;;
 ; Selects one object from a CommitAllocationNode. The object is identified by its
 ; VirtualObjectNode.
 ;;
(class-ns AllocatedObjectNode [FloatingNode, ValueNode, Node, Virtualizable, ArrayLengthProvider]
    (defn #_"AllocatedObjectNode" AllocatedObjectNode'new-1 [#_"VirtualObjectNode" virtualObject]
        (merge (AllocatedObjectNode'class.) (FloatingNode'new-1 (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 (VirtualObjectNode'''type-1 virtualObject))))
            (hash-map
                ; @Input
                #_"VirtualObjectNode" :virtualObject virtualObject
                ; @Input
                #_"CommitAllocationNode" :commit nil
            )
        )
    )

    (defn #_"AllocatedObjectNode" AllocatedObjectNode''setCommit-2 [#_"AllocatedObjectNode" this, #_"CommitAllocationNode" node]
        (Node''updateUsages-3 this, (:commit this), node)
        (assoc this :commit node)
    )

    (defm AllocatedObjectNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"AllocatedObjectNode" this, #_"VirtualizerTool" tool]
            (VirtualizerTool'''replaceWithVirtual-2 tool, (:virtualObject this))
            nil
        )
    )

    (defm AllocatedObjectNode ArrayLengthProvider
        (#_"ValueNode" ArrayLengthProvider'''length-1 [#_"AllocatedObjectNode" this]
            (when (satisfies? ArrayLengthProvider (:virtualObject this))
                (ArrayLengthProvider'''length-1 (:virtualObject this))
            )
        )
    )
)

(class-ns BinaryNode [FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable]
    ;;;
     ; Creates a new BinaryNode instance.
     ;
     ; @param stamp the result type of this instruction
     ; @param x the first input instruction
     ; @param y the second input instruction
     ;;
    (defn #_"BinaryNode" BinaryNode'new-3 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y]
        (merge (BinaryNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :x x
                ; @Input
                #_"ValueNode" :y y
            )
        )
    )

    (defm BinaryNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"BinaryNode" this, #_"CanonicalizerTool" tool]
            (Binary'''canonical-4 this, tool, (:x this), (:y this))
        )
    )

    (defm BinaryNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"BinaryNode" this]
            (ValueNode''updateStamp-2 this, (BinaryNode'''foldStamp-3 this, (:stamp (:x this)), (:stamp (:y this))))
        )
    )
)

(class-ns BinaryArithmeticNode #_"<OP>" [BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    (defn #_"BinaryArithmeticNode" BinaryArithmeticNode'new-3 [#_"SerializableBinaryFunction<OP>" f'getOp-1, #_"ValueNode" x, #_"ValueNode" y]
        (merge (BinaryArithmeticNode'class.) (BinaryNode'new-3 (BinaryOp'''foldStamp-3 (f'getOp-1 (ArithmeticOpTable'forStamp-1 (:stamp x))), (:stamp x), (:stamp y)), x, y)
            (hash-map
                #_"SerializableBinaryFunction<OP>" :f'getOp-1 f'getOp-1
            )
        )
    )

    (defn #_"BinaryOp<OP>" BinaryArithmeticNode''getOp-3 [#_"BinaryArithmeticNode<OP>" this, #_"ValueNode" forX, #_"ValueNode" forY]
        ((:f'getOp-1 this) (ArithmeticOpTable'forStamp-1 (:stamp forX)))
    )

    (defm BinaryArithmeticNode #_"<OP>" ArithmeticOperation
        (#_"BinaryOp<OP>" ArithmeticOperation'''getArithmeticOp-1 [#_"BinaryArithmeticNode<OP>" this]
            (BinaryArithmeticNode''getOp-3 this, (:x this), (:y this))
        )
    )

    (defm BinaryArithmeticNode #_"<OP>" BinaryArithmeticNode
        (#_"boolean" BinaryArithmeticNode'''isAssociative-1 [#_"BinaryArithmeticNode<OP>" this]
            (BinaryOp''isAssociative-1 (ArithmeticOperation'''getArithmeticOp-1 this))
        )
    )

    (defm BinaryArithmeticNode #_"<OP>" Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"BinaryArithmeticNode<OP>" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (BinaryArithmeticNode'tryConstantFold-4 (BinaryArithmeticNode''getOp-3 this, forX, forY), forX, forY, (:stamp this))
                this
            )
        )
    )

    (defn #_"<OP> ConstantNode" BinaryArithmeticNode'tryConstantFold-4 [#_"BinaryOp<OP>" op, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (when (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
            (let [
                #_"Constant" constant (BinaryOp'''foldConstant-3 op, (:value forX), (:value forY))
            ]
                (when (some? constant)
                    (ConstantNode'forPrimitive-2s stamp, constant)
                )
            )
        )
    )

    (defm BinaryArithmeticNode #_"<OP>" BinaryNode
        (#_"Stamp" BinaryNode'''foldStamp-3 [#_"BinaryArithmeticNode<OP>" this, #_"Stamp" stampX, #_"Stamp" stampY]
            (BinaryOp'''foldStamp-3 (ArithmeticOperation'''getArithmeticOp-1 this), stampX, stampY)
        )
    )

    (defn #_"ValueNode" BinaryArithmeticNode'add-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (Graph''addOrUniqueWithInputs-2 graph, (AddNode'create-2 v1, v2))
    )

    (defn #_"ValueNode" BinaryArithmeticNode'add-2 [#_"ValueNode" v1, #_"ValueNode" v2]
        (AddNode'create-2 v1, v2)
    )

    (defn #_"ValueNode" BinaryArithmeticNode'mul-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (Graph''addOrUniqueWithInputs-2 graph, (MulNode'create-2 v1, v2))
    )

    (defn #_"ValueNode" BinaryArithmeticNode'mul-2 [#_"ValueNode" v1, #_"ValueNode" v2]
        (MulNode'create-2 v1, v2)
    )

    (defn #_"ValueNode" BinaryArithmeticNode'sub-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (Graph''addOrUniqueWithInputs-2 graph, (SubNode'create-2 v1, v2))
    )

    (defn #_"ValueNode" BinaryArithmeticNode'sub-2 [#_"ValueNode" v1, #_"ValueNode" v2]
        (SubNode'create-2 v1, v2)
    )

    (defn- #_"ReassociateMatch" BinaryArithmeticNode'findReassociate-2 [#_"BinaryNode" binary, #_"NodePredicate" criterion]
        (let [
            #_"boolean" resultX (NodePredicate'''apply-2 criterion, (:x binary))
            #_"boolean" resultY (NodePredicate'''apply-2 criterion, (:y binary))
        ]
            (cond
                (and resultX (not resultY)) :ReassociateMatch'x
                (and (not resultX) resultY) :ReassociateMatch'y
            )
        )
    )

    ;; In reassociate, complexity comes from the handling of IntegerSub (non commutative) which can
    ;; be mixed with IntegerAdd. It first tries to find m1, m2 which match the criterion :
    ;; (a o m2) o m1
    ;; (m2 o a) o m1
    ;; m1 o (a o m2)
    ;; m1 o (m2 o a)
    ;; It then produces 4 boolean for the -/+ cases:
    ;; invertA : should the final expression be like *-a (rather than a+*)
    ;; aSub : should the final expression be like a-* (rather than a+*)
    ;; invertM1 : should the final expression contain -m1
    ;; invertM2 : should the final expression contain -m2

    ;;;
     ; Tries to re-associate values which satisfy the criterion. For example with a constantness
     ; criterion: {@code (a + 2) + 1 => a + (1 + 2)}.
     ;
     ; This method accepts only {@linkplain BinaryOp#isAssociative() associative}
     ; operations such as +, -, *, &, | and ^.
     ;;
    (defn #_"ValueNode" BinaryArithmeticNode'reassociate-4 [#_"BinaryArithmeticNode" self, #_"NodePredicate" criterion, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ReassociateMatch" match1 (BinaryArithmeticNode'findReassociate-2 self, criterion)
        ]
            (when (some? match1) => self
                (let [
                    #_"ValueNode" other (ReassociateMatch''getOtherValue-2 match1, self)
                    [#_"boolean" addSub #_"boolean" subAdd]
                        (when-not (= (#_"Object" .getClass other) (#_"Object" .getClass self)) => [false false]
                            (cond
                                (and (satisfies? AddNode self) (satisfies? SubNode other)) [true false]
                                (and (satisfies? SubNode self) (satisfies? AddNode other)) [false true]
                                :else
                                    (ยง return self)
                            )
                        )
                ]
                    (let [
                        #_"ReassociateMatch" match2 (BinaryArithmeticNode'findReassociate-2 other, criterion)
                    ]
                        (when (some? match2) => self
                            (let [
                                [#_"boolean" invertA #_"boolean" aSub #_"boolean" invertM1 #_"boolean" invertM2]
                                    (cond
                                        addSub
                                            (let [
                                                invertM2 (= match2 :ReassociateMatch'y)
                                            ]
                                                [(not invertM2) false false invertM2]
                                            )
                                        subAdd
                                            (let [
                                                invertM2 (= match1 :ReassociateMatch'x)
                                            ]
                                                [invertM2 false (not invertM2) invertM2]
                                            )
                                        (and (satisfies? SubNode self) (satisfies? SubNode other))
                                            [
                                                (bit-xor (= match1 :ReassociateMatch'x) (= match2 :ReassociateMatch'x))
                                                (and     (= match1 :ReassociateMatch'y) (= match2 :ReassociateMatch'y))
                                                (and     (= match1 :ReassociateMatch'y) (= match2 :ReassociateMatch'x))
                                                (and     (= match1 :ReassociateMatch'x) (= match2 :ReassociateMatch'x))
                                            ]
                                        :else
                                            [false false false false]
                                    )
                                #_"ValueNode" m1 (ReassociateMatch''getValue-2 match1, self)
                                #_"ValueNode" m2 (ReassociateMatch''getValue-2 match2, other)
                                #_"ValueNode" a (ReassociateMatch''getOtherValue-2 match2, other)
                            ]
                                (if (or (satisfies? AddNode self) (satisfies? SubNode self))
                                    (let [
                                        #_"ValueNode" associated
                                            (cond
                                                invertM1 (BinaryArithmeticNode'sub-2 m2, m1)
                                                invertM2 (BinaryArithmeticNode'sub-2 m1, m2)
                                                :else    (BinaryArithmeticNode'add-2 m1, m2)
                                            )
                                    ]
                                        (cond
                                            invertA (BinaryArithmeticNode'sub-2 associated, a)
                                            aSub    (BinaryArithmeticNode'sub-2 a, associated)
                                            :else   (BinaryArithmeticNode'add-2 a, associated)
                                        )
                                    )
                                    (condp satisfies? self
                                        MulNode (BinaryArithmeticNode'mul-2 a, (BinaryArithmeticNode'mul-2 m1, m2))
                                        AndNode (AndNode'new-2 a, (AndNode'new-2 m1, m2))
                                        OrNode  (OrNode'new-2 a, (OrNode'new-2 m1, m2))
                                        XorNode (XorNode'new-2 a, (XorNode'new-2 m1, m2))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Ensure a canonical ordering of inputs for commutative nodes to improve GVN results. Order the
     ; inputs by increasing Node#id and call Graph#findDuplicate(Node) on the node
     ; if it's currently in a graph. It's assumed that if there was a constant on the left it's been
     ; moved to the right by other code and that ordering is left alone.
     ;
     ; @return the original node or another node with the same input ordering
     ;;
    (defm BinaryArithmeticNode #_"<OP>" Binary
        (#_"BinaryNode" Binary'''maybeCommuteInputs-1 [#_"BinaryArithmeticNode<OP>" this]
            (when (and (not (satisfies? ConstantNode (:y this))) (or (satisfies? ConstantNode (:x this)) (< (:nid (:y this)) (:nid (:x this))))) => this
                (assoc this :x (:y this) :y (:x this))
            )
        )
    )

    ;;;
     ; Determines if it would be better to swap the inputs in order to produce better assembly code.
     ; First we try to pick a value which is dead after this use. If both values are dead at this
     ; use then we try pick an induction variable phi to encourage the phi to live in a single register.
     ;
     ; @return true if inputs should be swapped, false otherwise
     ;;
    (defn #_"boolean" BinaryArithmeticNode''shouldSwapInputs-2 [#_"BinaryArithmeticNode<OP>" this, #_"LIRBuilder" builder]
        (let [
            #_"boolean" xHasOtherUsages (ValueNode''hasUsagesOtherThan-3 (:x this), this, builder)
            #_"boolean" yHasOtherUsages (ValueNode''hasUsagesOtherThan-3 (:y this), this, builder)
        ]
            (and (not (satisfies? ConstantNode (:y this)))
                 (not yHasOtherUsages)
                (or (not (= xHasOtherUsages yHasOtherUsages))
                    (and (satisfies? ValuePhiNode (:y this))
                         (some #(= % this) (Node''inputs-1 (:y this)))
                    )
                )
            )
        )
    )
)

(class-ns AddNode [BinaryArithmeticNode #_"<Add>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"AddNode" AddNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (AddNode'class.) (BinaryArithmeticNode'new-3 :add, x, y))
    )

    (defn- #_"ValueNode" AddNode'canonical-4 [#_"AddNode" self, #_"BinaryOp<Add>" op, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"boolean" associative? (BinaryOp''isAssociative-1 op)
        ]
            (when associative?
                (when (and (satisfies? SubNode forX) (= (:y forX) forY)) ;; (a - b) + b
                    (ยง return (:x forX))
                )
                (when (and (satisfies? SubNode forY) (= (:y forY) forX)) ;; b + (a - b)
                    (ยง return (:x forY))
                )
            )
            (when (satisfies? ConstantNode forY)
                (when (BinaryOp'''isNeutral-2 op, (:value forY))
                    (ยง return forX)
                )
                (when (and associative? (some? self))
                    ;; canonicalize expressions like "(a + 1) + 2"
                    (let [
                        #_"ValueNode" reassociated (BinaryArithmeticNode'reassociate-4 self, ValueNode'IS_CONSTANT, forX, forY)
                    ]
                        (when-not (= reassociated self)
                            (ยง return reassociated)
                        )
                    )
                )
            )
            (cond
                (satisfies? NegateNode forX) (BinaryArithmeticNode'sub-2 forY, (Unary'''getValue-1 forX))
                (satisfies? NegateNode forY) (BinaryArithmeticNode'sub-2 forX, (Unary'''getValue-1 forY))
                :else                       (or self (Binary'''maybeCommuteInputs-1 (AddNode'new-2 forX, forY)))
            )
        )
    )

    (defn #_"ValueNode" AddNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Add>" op (:add (ArithmeticOpTable'forStamp-1 (:stamp x)))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, (BinaryOp'''foldStamp-3 op, (:stamp x), (:stamp y)))
                (if (and (satisfies? ConstantNode x) (not (satisfies? ConstantNode y)))
                    (AddNode'canonical-4 nil, op, y, x)
                    (AddNode'canonical-4 nil, op, x, y)
                )
            )
        )
    )

    (defm AddNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"AddNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (if (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                        ;; we try to swap and canonicalize
                        (let [
                            #_"ValueNode" improvement (Binary'''canonical-4 this, tool, forY, forX)
                        ]
                            (when (= improvement this) => improvement
                                ;; if this fails we only swap
                                (AddNode'new-2 forY, forX)
                            )
                        )
                        (AddNode'canonical-4 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), forX, forY)
                    )
                )
            )
        )
    )

    (defm AddNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AddNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" op1 (LIRBuilder''operand-2 builder, (:x this))
                #_"Value" op2 (LIRBuilder''operand-2 builder, (:y this))
                [op1 op2]
                    (when (BinaryArithmeticNode''shouldSwapInputs-2 this, builder) => [op1 op2]
                        [op2 op1]
                    )
            ]
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAdd-4 (:gen builder), op1, op2, false))
            )
            nil
        )
    )
)

;;;
 ; Node representing an exact integer addition that will throw an ArithmeticException in
 ; case the addition would overflow the 32 bit range.
 ;;
(class-ns IntegerAddExactNode [AddNode, BinaryArithmeticNode #_"<Add>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative, IntegerExactArithmeticNode, Lowerable]
    (defn #_"IntegerAddExactNode" IntegerAddExactNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerAddExactNode" this (merge (IntegerAddExactNode'class.) (AddNode'new-2 x, y))
        ]
            (ValueNode''setStamp-2 this, (Stamp'''unrestricted-1 (:stamp x)))
        )
    )

    (defm IntegerAddExactNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"IntegerAddExactNode" this]
            ;; Note: it is not allowed to use the foldStamp method of the regular add node as we do not know
            ;; the result stamp of this node if we do not know whether we may deopt. If we know we can never
            ;; overflow we will replace this node with its non overflow checking counterpart anyway.
            false
        )
    )

    (defm IntegerAddExactNode BinaryNode
        (#_"Stamp" BinaryNode'''foldStamp-3 [#_"IntegerAddExactNode" this, #_"Stamp" a, #_"Stamp" b]
            (let [
                #_"int" bits (:bits a)
                #_"long" defaultMask (CodeUtil/mask bits)
                #_"long" variableBits (| (bit-xor (:downMask a) (:upMask a)) (bit-xor (:downMask b) (:upMask b)))
                #_"long" variableBitsWithCarry (| variableBits (bit-xor (IntegerStamp'carryBits-2 (:downMask a), (:downMask b)) (IntegerStamp'carryBits-2 (:upMask a), (:upMask b))))
                #_"long" newDownMask (& (+ (:downMask a) (:downMask b)) (bit-not variableBitsWithCarry))
                #_"long" newUpMask (| (+ (:downMask a) (:downMask b)) variableBitsWithCarry)
                newDownMask (& newDownMask defaultMask)
                newUpMask (& newUpMask defaultMask)
                #_"long" lower
                    (cond
                        (IntegerStamp'addOverflowsPositively-3 (:lowerBound a), (:lowerBound b), bits) (CodeUtil/maxValue bits)
                        (IntegerStamp'addOverflowsNegatively-3 (:lowerBound a), (:lowerBound b), bits) (CodeUtil/minValue bits)
                        :else
                            (CodeUtil/signExtend (& (+ (:lowerBound a) (:lowerBound b)) defaultMask), bits)
                    )
                #_"long" upper
                    (cond
                        (IntegerStamp'addOverflowsPositively-3 (:upperBound a), (:upperBound b), bits) (CodeUtil/maxValue bits)
                        (IntegerStamp'addOverflowsNegatively-3 (:upperBound a), (:upperBound b), bits) (CodeUtil/minValue bits)
                        :else
                            (CodeUtil/signExtend (& (+ (:upperBound a) (:upperBound b)) defaultMask), bits)
                    )
                #_"IntegerStamp" limit (StampFactory'forInteger-3i bits, lower, upper)
                newUpMask (& newUpMask (:upMask limit))
                upper (CodeUtil/signExtend (& upper newUpMask), bits)
                newDownMask (| newDownMask (:downMask limit))
                lower (| lower newDownMask)
            ]
                (IntegerStamp'create-5 bits, lower, upper, newDownMask, newUpMask)
            )
        )
    )

    (defn- #_"ConstantNode" IntegerAddExactNode'canonicalXconstant-2 [#_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"JavaConstant" xConst (ValueNode''asJavaConstant-1 forX)
            #_"JavaConstant" yConst (ValueNode''asJavaConstant-1 forY)
        ]
            (when (and (some? xConst) (some? yConst))
                (try
                    (if (= (#_"JavaConstant" .getJavaKind xConst) JavaKind/Int)
                        (ConstantNode'forInt-1 (Math/addExact (#_"JavaConstant" .asInt xConst), (#_"JavaConstant" .asInt yConst)))
                        (ConstantNode'forLong-1 (Math/addExact (#_"JavaConstant" .asLong xConst), (#_"JavaConstant" .asLong yConst)))
                    )
                    (catch ArithmeticException _
                        nil ;; the operation will result in an overflow exception, so do not canonicalize
                    )
                )
            )
        )
    )

    (defm IntegerAddExactNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"IntegerAddExactNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (if (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                (Canonicalizable'''canonical-2 (IntegerAddExactNode'new-2 forY, forX), tool)
                (do
                    (cond
                        (satisfies? ConstantNode forX)
                            (let [
                                #_"ConstantNode" constantNode (IntegerAddExactNode'canonicalXconstant-2 forX, forY)
                            ]
                                (when (some? constantNode)
                                    (ยง return constantNode)
                                )
                            )
                        (satisfies? ConstantNode forY)
                            (when (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)))
                                (ยง return forX)
                            )
                    )
                    (when-not (IntegerStamp'addCanOverflow-2 (:stamp forX), (:stamp forY)) => this
                        (Canonicalizable'''canonical-2 (AddNode'new-2 forX, forY), tool)
                    )
                )
            )
        )
    )

    (defm IntegerAddExactNode IntegerExactArithmeticNode
        (#_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticNode'''createSplit-3 [#_"IntegerAddExactNode" this, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" deopt]
            (Graph''add-2 (:graph this), (IntegerAddExactSplitNode'new-5 (:stamp this), (:x this), (:y this), _next, deopt))
        )
    )

    (defm IntegerAddExactNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"IntegerAddExactNode" this, #_"LoweringTool" lowerer]
            (IntegerExactArithmeticSplitNode'lower-2 lowerer, this)
            nil
        )
    )
)

(class-ns AndNode [BinaryArithmeticNode #_"<And>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"AndNode" AndNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (AndNode'class.) (BinaryArithmeticNode'new-3 :and, x, y))
    )

    (defn- #_"ValueNode" AndNode'canonical-5 [#_"AndNode" self, #_"BinaryOp<And>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY))
                forX
            (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                (AndNode'new-2 forY, forX)
            (satisfies? ConstantNode forY)
                (let [
                    #_"Constant" c (:value forY)
                ]
                    (when-not (BinaryOp'''isNeutral-2 op, c) => forX
                        (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                            (let [
                                #_"long" rawY (#_"PrimitiveConstant" .asLong c)
                            ]
                                (when (zero? (& rawY (CodeUtil/mask (PrimitiveStamp'getBits-1 stamp))))
                                    (ยง return (ConstantNode'forIntegerStamp-2 stamp, 0))
                                )
                                (when (and (satisfies? SignExtendNode forX) (= rawY (dec (<< 1 (IntegerConvertNode''getInputBits-1 forX)))))
                                    (ยง return (ZeroExtendNode'new-2 (Unary'''getValue-1 forX), (IntegerConvertNode''getResultBits-1 forX)))
                                )
                                (when (zero? (& (| (:upMask (:stamp forX)) (:downMask (:stamp forX))) (bit-not rawY)))
                                    ;; No bits are set which are outside the mask, so the mask will have no effect.
                                    (ยง return forX)
                                )
                            )
                        )
                        (BinaryArithmeticNode'reassociate-4 (or self (Binary'''maybeCommuteInputs-1 (AndNode'new-2 forX, forY))), ValueNode'IS_CONSTANT, forX, forY)
                    )
                )
            (and (satisfies? NotNode forX) (satisfies? NotNode forY))
                (NotNode'new-1 (OrNode'create-2 (Unary'''getValue-1 forX), (Unary'''getValue-1 forY)))
            :else
                (or self (Binary'''maybeCommuteInputs-1 (AndNode'new-2 forX, forY)))
        )
    )

    (defn #_"ValueNode" AndNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<And>" op (:and (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp)
                (AndNode'canonical-5 nil, op, stamp, x, y)
            )
        )
    )

    (defm AndNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"AndNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (AndNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm AndNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"AndNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAnd-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns IntegerMulHighNode [BinaryArithmeticNode #_"<MulHigh>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"IntegerMulHighNode" IntegerMulHighNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (IntegerMulHighNode'class.) (BinaryArithmeticNode'new-3 :mulHigh, x, y))
    )

    (defm IntegerMulHighNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"IntegerMulHighNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" a (LIRBuilder''operand-2 builder, (:x this))
                #_"Value" b (LIRBuilder''operand-2 builder, (:y this))
            ]
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitMulHigh-3 (:gen builder), a, b))
            )
            nil
        )
    )

    (defn- #_"ValueNode" IntegerMulHighNode'canonical-2 [#_"IntegerMulHighNode" self, #_"ValueNode" forY]
        (when (satisfies? ConstantNode forY) => self
            (let [
                #_"Constant" constant (:value forY)
            ]
                (when (and (instance? PrimitiveConstant constant) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant)) (any = (#_"PrimitiveConstant" .asLong constant) 0 1)) => self
                    (ConstantNode'forIntegerStamp-2 (:stamp self), 0)
                )
            )
        )
    )

    (defm IntegerMulHighNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"IntegerMulHighNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (when (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY))) => (IntegerMulHighNode'canonical-2 this, forY)
                        ;; we try to swap and canonicalize
                        (let [
                            #_"ValueNode" improvement (Binary'''canonical-4 this, tool, forY, forX)
                        ]
                            (when (= improvement this) => improvement
                                ;; if this fails we only swap
                                (IntegerMulHighNode'new-2 forY, forX)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns MulNode [BinaryArithmeticNode #_"<Mul>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"MulNode" MulNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (MulNode'class.) (BinaryArithmeticNode'new-3 :mul, x, y))
    )

    (defn- #_"ValueNode" MulNode'canonical-5 [#_"MulNode" self, #_"BinaryOp<Mul>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (satisfies? ConstantNode forY)
            (let [
                #_"Constant" c (:value forY)
            ]
                (when (BinaryOp'''isNeutral-2 op, c)
                    (ยง return forX)
                )

                (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                    (let [
                        #_"ValueNode" result (MulNode'canonical-3 stamp, forX, (#_"PrimitiveConstant" .asLong c))
                    ]
                        (when (some? result)
                            (ยง return result)
                        )
                    )
                )

                (when (BinaryOp''isAssociative-1 op)
                    ;; canonicalize expressions like "(a * 1) * 2"
                    (ยง return (BinaryArithmeticNode'reassociate-4 (or self (Binary'''maybeCommuteInputs-1 (MulNode'new-2 forX, forY))), ValueNode'IS_CONSTANT, forX, forY))
                )
            )
        )
        (or self (Binary'''maybeCommuteInputs-1 (MulNode'new-2 forX, forY)))
    )

    (defn #_"ValueNode" MulNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Mul>" op (:mul (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp) (MulNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    (defm MulNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"MulNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (if (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                        ;; we try to swap and canonicalize
                        (let [
                            #_"ValueNode" improvement (Binary'''canonical-4 this, tool, forY, forX)
                        ]
                            (when (= improvement this) => improvement
                                ;; if this fails we only swap
                                (MulNode'new-2 forY, forX)
                            )
                        )
                        (MulNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
                    )
                )
            )
        )
    )

    (defn #_"ValueNode" MulNode'canonical-3 [#_"Stamp" stamp, #_"ValueNode" forX, #_"long" i]
        (cond
            (zero? i) (ConstantNode'forIntegerStamp-2 stamp, 0)
            (= i 1)   forX
            (= i -1)  (NegateNode'create-1 forX)
            (pos? i)
                (cond
                    (CodeUtil/isPowerOf2 i)       (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 i)))
                    (CodeUtil/isPowerOf2 (dec i)) (AddNode'create-2 (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 (dec i)))), forX)
                    (CodeUtil/isPowerOf2 (inc i)) (SubNode'create-2 (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 (inc i)))), forX)
                    :else
                        (let [
                            #_"long" highestBitValue (Long/highestOneBit i)
                        ]
                            (if (= (Long/bitCount i) 2)
                                ;; e.g. 0b1000_0010
                                (let [
                                    #_"long" lowerBitValue (- i highestBitValue)
                                    #_"ValueNode" left (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 highestBitValue)))
                                    #_"ValueNode" right (if (= lowerBitValue 1) forX (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 lowerBitValue))))
                                ]
                                    (AddNode'create-2 left, right)
                                )
                                ;; e.g. 0b1111_1101
                                (let [
                                    #_"int" shiftToRoundUpToPowerOf2 (inc (CodeUtil/log2 highestBitValue))
                                    #_"long" subValue (- (<< 1 shiftToRoundUpToPowerOf2) i)
                                ]
                                    (when (and (CodeUtil/isPowerOf2 subValue) (< shiftToRoundUpToPowerOf2 (:bits stamp)))
                                        (let [
                                            #_"ValueNode" left (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 shiftToRoundUpToPowerOf2))
                                            #_"ValueNode" right (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 subValue)))
                                        ]
                                            (SubNode'create-2 left, right)
                                        )
                                    )
                                )
                            )
                        )
                )
            (neg? i)
                (when (CodeUtil/isPowerOf2 (- i))
                    (NegateNode'create-1 (LeftShiftNode'create-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 (- i)))))
                )
        )
    )

    (defm MulNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"MulNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" op1 (LIRBuilder''operand-2 builder, (:x this))
                #_"Value" op2 (LIRBuilder''operand-2 builder, (:y this))
                [op1 op2] (if (BinaryArithmeticNode''shouldSwapInputs-2 this, builder) [op2 op1] [op1 op2])
            ]
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitMul-4 (:gen builder), op1, op2, false))
            )
            nil
        )
    )
)

;;;
 ; Node representing an exact integer multiplication that will throw an ArithmeticException
 ; in case the addition would overflow the 32 bit range.
 ;;
(class-ns IntegerMulExactNode [MulNode, BinaryArithmeticNode #_"<Mul>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative, IntegerExactArithmeticNode, Lowerable]
    (defn #_"IntegerMulExactNode" IntegerMulExactNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerMulExactNode" this (merge (IntegerMulExactNode'class.) (MulNode'new-2 x, y))
        ]
            (ValueNode''setStamp-2 this, (Stamp'''unrestricted-1 (:stamp x)))
        )
    )

    (defm IntegerMulExactNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"IntegerMulExactNode" this]
            ;; Note: it is not allowed to use the foldStamp method of the regular mul node as we do not know
            ;; the result stamp of this node if we do not know whether we may deopt. If we know we can never
            ;; overflow we will replace this node with its non overflow checking counterpart anyway.
            false
        )
    )

    (defn- #_"ValueNode" IntegerMulExactNode''canonicalXconstant-3 [#_"IntegerMulExactNode" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"JavaConstant" xConst (ValueNode''asJavaConstant-1 forX)
            #_"JavaConstant" yConst (ValueNode''asJavaConstant-1 forY)
        ]
            (try
                (if (= (#_"JavaConstant" .getJavaKind xConst) JavaKind/Int)
                    (ConstantNode'forInt-1 (Math/multiplyExact (#_"JavaConstant" .asInt xConst), (#_"JavaConstant" .asInt yConst)))
                    (ConstantNode'forLong-1 (Math/multiplyExact (#_"JavaConstant" .asLong xConst), (#_"JavaConstant" .asLong yConst)))
                )
                (catch ArithmeticException _
                    this ;; the operation will result in an overflow exception, so do not canonicalize
                )
            )
        )
    )

    (defm IntegerMulExactNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"IntegerMulExactNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (cond
                (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                    (ยง return (Canonicalizable'''canonical-2 (IntegerMulExactNode'new-2 forY, forX), tool))
                (satisfies? ConstantNode forX)
                    (ยง return (IntegerMulExactNode''canonicalXconstant-3 this, forX, forY))
                (satisfies? ConstantNode forY)
                    (let [
                        #_"long" c (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                    ]
                        (cond
                            (= c 1)
                                (ยง return forX)
                            (= c 0)
                                (ยง return (ConstantNode'forIntegerStamp-2 (:stamp this), 0))
                        )
                    )
            )
            (when-not (IntegerStamp'multiplicationCanOverflow-2 (:stamp (:x this)), (:stamp (:y this))) => this
                (Canonicalizable'''canonical-2 (MulNode'new-2 (:x this), (:y this)), tool)
            )
        )
    )

    (defm IntegerMulExactNode IntegerExactArithmeticNode
        (#_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticNode'''createSplit-3 [#_"IntegerMulExactNode" this, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" deopt]
            (Graph''add-2 (:graph this), (IntegerMulExactSplitNode'new-5 (:stamp this), (:x this), (:y this), _next, deopt))
        )
    )

    (defm IntegerMulExactNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"IntegerMulExactNode" this, #_"LoweringTool" lowerer]
            (IntegerExactArithmeticSplitNode'lower-2 lowerer, this)
            nil
        )
    )
)

(class-ns OrNode [BinaryArithmeticNode #_"<Or>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"OrNode" OrNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (OrNode'class.) (BinaryArithmeticNode'new-3 :or, x, y))
    )

    (defn- #_"ValueNode" OrNode'canonical-5 [#_"OrNode" self, #_"BinaryOp<Or>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY))
                forX
            (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                (OrNode'new-2 forY, forX)
            (satisfies? ConstantNode forY)
                (let [
                    #_"Constant" c (:value forY)
                ]
                    (if (BinaryOp'''isNeutral-2 op, c)
                        forX
                        (do
                            (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                                (let [
                                    #_"long" rawY (#_"PrimitiveConstant" .asLong c)
                                    #_"long" mask (CodeUtil/mask (PrimitiveStamp'getBits-1 stamp))
                                ]
                                    (when (= (& rawY mask) mask)
                                        (ยง return (ConstantNode'forIntegerStamp-2 stamp, mask))
                                    )
                                )
                            )
                            (BinaryArithmeticNode'reassociate-4 (or self (Binary'''maybeCommuteInputs-1 (OrNode'new-2 forX, forY))), ValueNode'IS_CONSTANT, forX, forY)
                        )
                    )
                )
            (and (satisfies? NotNode forX) (satisfies? NotNode forY))
                (NotNode'new-1 (AndNode'create-2 (Unary'''getValue-1 forX), (Unary'''getValue-1 forY)))
            :else
                (or self (Binary'''maybeCommuteInputs-1 (OrNode'new-2 forX, forY)))
        )
    )

    (defn #_"ValueNode" OrNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Or>" op (:or (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp)
                (OrNode'canonical-5 nil, op, stamp, x, y)
            )
        )
    )

    (defm OrNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"OrNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (OrNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm OrNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"OrNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitOr-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns RemNode [BinaryArithmeticNode #_"<Rem>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, Lowerable]
    (defn #_"RemNode" RemNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (RemNode'class.) (BinaryArithmeticNode'new-3 :rem, x, y))
    )

    #_unused
    (defn #_"ValueNode" RemNode'create-2 [#_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"BinaryOp<Rem>" op (:rem (ArithmeticOpTable'forStamp-1 (:stamp forX)))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, forX, forY, (BinaryOp'''foldStamp-3 op, (:stamp forX), (:stamp forY)))
                (RemNode'new-2 forX, forY)
            )
        )
    )

    (defm RemNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"RemNode" this, #_"LoweringTool" lowerer]
            nil ;; No lowering, we generate LIR directly for this node.
        )
    )

    (defm RemNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"RemNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitRem-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns SubNode [BinaryArithmeticNode #_"<Sub>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    (defn #_"SubNode" SubNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (SubNode'class.) (BinaryArithmeticNode'new-3 :sub, x, y))
    )

    (defn- #_"ValueNode" SubNode'canonical-5 [#_"SubNode" self, #_"BinaryOp<Sub>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY))
            (let [
                #_"Constant" zero (BinaryOp'''getZero-2 op, (:stamp forX))
            ]
                (when (some? zero)
                    (ยง return (ConstantNode'forPrimitive-2s stamp, zero))
                )
            )
        )
        (let [
            #_"boolean" associative? (BinaryOp''isAssociative-1 op)
        ]
            (when associative?
                (condp satisfies? forX
                    AddNode
                        (do
                            (when (= (:y forX) forY) ;; (a + b) - b
                                (ยง return (:x forX))
                            )
                            (when (= (:x forX) forY) ;; (a + b) - a
                                (ยง return (:y forX))
                            )
                        )
                    SubNode
                        (do
                            (when (= (:x forX) forY) ;; (a - b) - a
                                (ยง return (NegateNode'create-1 (:y forX)))
                            )
                        )
                    nil
                )
                (condp satisfies? forY
                    AddNode
                        (do
                            (when (= (:x forY) forX) ;; a - (a + b)
                                (ยง return (NegateNode'create-1 (:y forY)))
                            )
                            (when (= (:y forY) forX) ;; b - (a + b)
                                (ยง return (NegateNode'create-1 (:x forY)))
                            )
                        )
                    SubNode
                        (do
                            (when (= (:x forY) forX) ;; a - (a - b)
                                (ยง return (:y forY))
                            )
                        )
                    nil
                )
            )
            (cond
                (satisfies? ConstantNode forY)
                    (let [
                        #_"Constant" c (:value forY)
                    ]
                        (when (BinaryOp'''isNeutral-2 op, c)
                            (ยง return forX)
                        )
                        (when (and associative? (some? self))
                            (let [
                                #_"ValueNode" reassociated (BinaryArithmeticNode'reassociate-4 self, ValueNode'IS_CONSTANT, forX, forY)
                            ]
                                (when-not (= reassociated self)
                                    (ยง return reassociated)
                                )
                            )
                        )
                        (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                            (let [
                                #_"long" i (#_"PrimitiveConstant" .asLong c)
                            ]
                                (when (or (neg? i) (IntegerStamp''contains-2 (StampFactory'forKind-1 (ValueNode''getStackKind-1 forY)), (- i)))
                                    ;; Adding a negative is more friendly to the backend since adds are
                                    ;; commutative, so prefer add when it fits.
                                    (ยง return (BinaryArithmeticNode'add-2 forX, (ConstantNode'forIntegerStamp-2 stamp, (- i))))
                                )
                            )
                        )
                    )
                (satisfies? ConstantNode forX)
                    (let [
                        #_"Constant" c (:value forX)
                    ]
                        (when (BinaryOp'''isNeutral-2 (:add (ArithmeticOpTable'forStamp-1 stamp)), c)
                            ;; Note that for floating point numbers, + and - have different neutral elements.
                            ;; We have to test for the neutral element of +, because we are doing this
                            ;; transformation: 0 - x == (-x) + 0 == -x.
                            (ยง return (NegateNode'create-1 forY))
                        )
                        (when (and associative? (some? self))
                            (ยง return (BinaryArithmeticNode'reassociate-4 self, ValueNode'IS_CONSTANT, forX, forY))
                        )
                    )
            )
            (if (satisfies? NegateNode forY)
                (BinaryArithmeticNode'add-2 forX, (Unary'''getValue-1 forY))
                (or self (SubNode'new-2 forX, forY))
            )
        )
    )

    (defn #_"ValueNode" SubNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Sub>" op (:sub (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp)
                (SubNode'canonical-5 nil, op, stamp, x, y)
            )
        )
    )

    (defm SubNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"SubNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (SubNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm SubNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"SubNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitSub-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), false))
            nil
        )
    )
)

;;;
 ; Node representing an exact integer substraction that will throw an ArithmeticException in
 ; case the addition would overflow the 32 bit range.
 ;;
(class-ns IntegerSubExactNode [SubNode, BinaryArithmeticNode #_"<Sub>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, IntegerExactArithmeticNode, Lowerable]
    #_unused
    (defn #_"IntegerSubExactNode" IntegerSubExactNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerSubExactNode" this (merge (IntegerSubExactNode'class.) (SubNode'new-2 x, y))
            this (ValueNode''setStamp-2 this, (Stamp'''unrestricted-1 (:stamp x)))
        ]
            this
        )
    )

    (defm IntegerSubExactNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"IntegerSubExactNode" this]
            ;; Note: it is not allowed to use the foldStamp method of the regular sub node as we do not know
            ;; the result stamp of this node if we do not know whether we may deopt. If we know we can never
            ;; overflow we will replace this node with its non overflow checking counterpart anyway.
            false
        )
    )

    (defn- #_"ValueNode" IntegerSubExactNode''canonicalXYconstant-3 [#_"IntegerSubExactNode" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"JavaConstant" xConst (ValueNode''asJavaConstant-1 forX)
            #_"JavaConstant" yConst (ValueNode''asJavaConstant-1 forY)
        ]
            (try
                (if (= (#_"JavaConstant" .getJavaKind xConst) JavaKind/Int)
                    (ConstantNode'forInt-1 (Math/subtractExact (#_"JavaConstant" .asInt xConst), (#_"JavaConstant" .asInt yConst)))
                    (ConstantNode'forLong-1 (Math/subtractExact (#_"JavaConstant" .asLong xConst), (#_"JavaConstant" .asLong yConst)))
                )
                (catch ArithmeticException _
                    this ;; the operation will result in an overflow exception, so do not canonicalize
                )
            )
        )
    )

    (defm IntegerSubExactNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"IntegerSubExactNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (cond
                (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY))                                            (ConstantNode'forIntegerStamp-2 (:stamp this), 0)
                (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))                                        (IntegerSubExactNode''canonicalXYconstant-3 this, forX, forY)
                (and (satisfies? ConstantNode forY) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)))) forX
                (IntegerStamp'subtractionCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))                             this
                :else                                                                                                      (Canonicalizable'''canonical-2 (SubNode'new-2 (:x this), (:y this)), tool)
            )
        )
    )

    (defm IntegerSubExactNode IntegerExactArithmeticNode
        (#_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticNode'''createSplit-3 [#_"IntegerSubExactNode" this, #_"AbstractBeginNode" _next, #_"AbstractBeginNode" deopt]
            (Graph''add-2 (:graph this), (IntegerSubExactSplitNode'new-5 (:stamp this), (:x this), (:y this), _next, deopt))
        )
    )

    (defm IntegerSubExactNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"IntegerSubExactNode" this, #_"LoweringTool" lowerer]
            (IntegerExactArithmeticSplitNode'lower-2 lowerer, this)
            nil
        )
    )
)

(class-ns UnsignedMulHighNode [BinaryArithmeticNode #_"<UMulHigh>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"UnsignedMulHighNode" UnsignedMulHighNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (UnsignedMulHighNode'class.) (BinaryArithmeticNode'new-3 :umulHigh, x, y))
    )

    (defm UnsignedMulHighNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"UnsignedMulHighNode" this, #_"LIRBuilder" builder]
            (let [
                #_"Value" a (LIRBuilder''operand-2 builder, (:x this))
                #_"Value" b (LIRBuilder''operand-2 builder, (:y this))
            ]
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitUMulHigh-3 (:gen builder), a, b))
            )
            nil
        )
    )

    (defn- #_"ValueNode" UnsignedMulHighNode'canonical-2 [#_"UnsignedMulHighNode" self, #_"ValueNode" forY]
        (when (satisfies? ConstantNode forY) => self
            (let [
                #_"Constant" constant (:value forY)
            ]
                (when (and (instance? PrimitiveConstant constant) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant)) (any = (#_"PrimitiveConstant" .asLong constant) 0 1)) => self
                    (ConstantNode'forIntegerStamp-2 (:stamp self), 0)
                )
            )
        )
    )

    (defm UnsignedMulHighNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"UnsignedMulHighNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (when (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY))) => (UnsignedMulHighNode'canonical-2 this, forY)
                        ;; we try to swap and canonicalize
                        (let [
                            #_"ValueNode" improvement (Binary'''canonical-4 this, tool, forY, forX)
                        ]
                            (when (= improvement this) => improvement
                                ;; if this fails we only swap
                                (UnsignedMulHighNode'new-2 forY, forX)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns XorNode [BinaryArithmeticNode #_"<Xor>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, BinaryCommutative]
    (defn #_"XorNode" XorNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (XorNode'class.) (BinaryArithmeticNode'new-3 :xor, x, y))
    )

    (defn- #_"ValueNode" XorNode'canonical-5 [#_"XorNode" self, #_"BinaryOp<Xor>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY))
                (ConstantNode'forPrimitive-2s stamp, (BinaryOp'''getZero-2 op, (:stamp forX)))
            (and (satisfies? ConstantNode forX) (not (satisfies? ConstantNode forY)))
                (XorNode'new-2 forY, forX)
            (satisfies? ConstantNode forY)
                (let [
                    #_"Constant" c (:value forY)
                ]
                    (if (BinaryOp'''isNeutral-2 op, c)
                        forX
                        (do
                            (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                                (let [
                                    #_"long" mask (CodeUtil/mask (PrimitiveStamp'getBits-1 stamp))
                                ]
                                    (when (= (& (#_"PrimitiveConstant" .asLong c) mask) mask)
                                        (ยง return (NotNode'new-1 forX))
                                    )
                                )
                            )
                            (BinaryArithmeticNode'reassociate-4 (or self (Binary'''maybeCommuteInputs-1 (XorNode'new-2 forX, forY))), ValueNode'IS_CONSTANT, forX, forY)
                        )
                    )
                )
            :else
                (or self (Binary'''maybeCommuteInputs-1 (XorNode'new-2 forX, forY)))
        )
    )

    (defn #_"ValueNode" XorNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Xor>" op (:xor (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp) (XorNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    (defm XorNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"XorNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super BinaryArithmeticNode'iface), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (XorNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm XorNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"XorNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitXor-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

;;;
 ; Returns -1, 0, or 1 if either x < y, x == y, or x > y.
 ;;
(class-ns NormalizeCompareNode [BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable]
    (defn #_"NormalizeCompareNode" NormalizeCompareNode'new-3 [#_"ValueNode" x, #_"ValueNode" y, #_"JavaKind" kind]
        (merge (NormalizeCompareNode'class.) (BinaryNode'new-3 (StampFactory'forInteger-3k kind, -1, 1), x, y))
    )

    (defn #_"ValueNode" NormalizeCompareNode'create-3 [#_"ValueNode" x, #_"ValueNode" y, #_"JavaKind" kind]
        (or (NormalizeCompareNode'tryConstantFold-3 x, y, kind)
            (NormalizeCompareNode'new-3 x, y, kind)
        )
    )

    (defn #_"ValueNode" NormalizeCompareNode'tryConstantFold-3 [#_"ValueNode" x, #_"ValueNode" y, #_"JavaKind" kind]
        (let [
            #_"LogicNode" result (CompareNode'tryConstantFold-3 CanonicalCondition'EQ, x, y)
        ]
            (when (satisfies? LogicConstantNode result)
                (let [
                    #_"LogicNode" resultLT (CompareNode'tryConstantFold-3 CanonicalCondition'LT, x, y)
                ]
                    (when (satisfies? LogicConstantNode resultLT)
                        (cond
                            (:value resultLT) (ConstantNode'forIntegerKind-2 kind, -1)
                            (:value result)   (ConstantNode'forIntegerKind-2 kind,  0)
                            :else             (ConstantNode'forIntegerKind-2 kind,  1)
                        )
                    )
                )
            )
        )
    )

    (defm NormalizeCompareNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"NormalizeCompareNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (NormalizeCompareNode'tryConstantFold-3 (:x this), (:y this), (Stamp'''getStackKind-1 (:stamp this)))
                this
            )
        )
    )

    (defm NormalizeCompareNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"NormalizeCompareNode" this]
            false
        )
    )

    (defm NormalizeCompareNode BinaryNode
        (#_"Stamp" BinaryNode'''foldStamp-3 [#_"NormalizeCompareNode" this, #_"Stamp" stampX, #_"Stamp" stampY]
            (:stamp this)
        )
    )
)

;;;
 ; The ShiftOp class represents shift operations.
 ;;
(class-ns ShiftNode #_"<OP>" [BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    ;;;
     ; Creates a new shift operation.
     ;
     ; @param x the first input value
     ; @param s the second input value
     ;;
    (defn #_"ShiftNode" ShiftNode'new-3 [#_"SerializableShiftFunction<OP>" f'getOp-1, #_"ValueNode" x, #_"ValueNode" s]
        (merge (ShiftNode'class.) (BinaryNode'new-3 (ShiftOp'''foldStamp-3 (f'getOp-1 (ArithmeticOpTable'forStamp-1 (:stamp x))), (:stamp x), (:stamp s)), x, s)
            (hash-map
                #_"SerializableShiftFunction<OP>" :f'getOp-1 f'getOp-1
            )
        )
    )

    (defn #_"ShiftOp<OP>" ShiftNode''getOp-2 [#_"ShiftNode<OP>" this, #_"ValueNode" value]
        ((:f'getOp-1 this) (ArithmeticOpTable'forStamp-1 (:stamp value)))
    )

    (defm ShiftNode #_"<OP>" ArithmeticOperation
        (#_"ShiftOp<OP>" ArithmeticOperation'''getArithmeticOp-1 [#_"ShiftNode<OP>" this]
            (ShiftNode''getOp-2 this, (:x this))
        )
    )

    (defm ShiftNode #_"<OP>" BinaryNode
        (#_"Stamp" BinaryNode'''foldStamp-3 [#_"ShiftNode<OP>" this, #_"Stamp" stampX, #_"Stamp" stampY]
            (ShiftOp'''foldStamp-3 (ArithmeticOperation'''getArithmeticOp-1 this), stampX, stampY)
        )
    )

    (defm ShiftNode #_"<OP>" Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"ShiftNode<OP>" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (ShiftNode'canonical-4 (ShiftNode''getOp-2 this, forX), (:stamp this), forX, forY)
                this
            )
        )
    )

    (defn #_"<OP> ValueNode" ShiftNode'canonical-4 [#_"ShiftOp<OP>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
            (ConstantNode'forPrimitive-2s stamp, (ShiftOp'''foldConstant-3 op, (:value forX), (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))))
        )
    )

    (defn #_"int" ShiftNode''getShiftAmountMask-1 [#_"ShiftNode<OP>" this]
        (ShiftOp'getShiftAmountMask-1 (:stamp this))
    )
)

(class-ns LeftShiftNode [ShiftNode #_"<Shl>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    (defn #_"LeftShiftNode" LeftShiftNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (LeftShiftNode'class.) (ShiftNode'new-3 :shl, x, y))
    )

    (defn- #_"ValueNode" LeftShiftNode'canonical-5 [#_"LeftShiftNode" self, #_"ShiftOp<Shl>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (satisfies? ConstantNode forY)
            (let [
                #_"int" amount (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))
                #_"int" o'amount amount
                #_"int" mask (ShiftOp'getShiftAmountMask-1 stamp)
                amount (& amount mask)
            ]
                (when (zero? amount)
                    (ยง return forX)
                )
                (when (and (satisfies? ShiftNode forX) (satisfies? ConstantNode (:y forX)))
                    (let [
                        #_"int" amount' (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y forX))) mask)
                    ]
                        (cond
                            (satisfies? LeftShiftNode forX)
                                (let [
                                    #_"int" total (+ amount amount')
                                ]
                                    (if (= total (& total mask))
                                        (ยง return (LeftShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 total)))
                                        (ยง return (ConstantNode'forIntegerKind-2 (Stamp'''getStackKind-1 stamp), 0))
                                    )
                                )
                            (and (or (satisfies? RightShiftNode forX) (satisfies? UnsignedRightShiftNode forX)) (= amount amount'))
                                (if (= (Stamp'''getStackKind-1 stamp) JavaKind/Long)
                                    (ยง return (AndNode'new-2 (:x forX), (ConstantNode'forLong-1 (<< -1 amount))))
                                    (ยง return (AndNode'new-2 (:x forX), (ConstantNode'forInt-1 (<< -1 amount))))
                                )
                        )
                    )
                )
                (when-not (= o'amount amount)
                    (ยง return (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 amount)))
                )
            )
        )
        (or self (LeftShiftNode'new-2 forX, forY))
    )

    (defn #_"ValueNode" LeftShiftNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"ShiftOp<Shl>" op (:shl (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (ShiftOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (ShiftNode'canonical-4 op, stamp, x, y) (LeftShiftNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    (defm LeftShiftNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"LeftShiftNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super #_"ShiftNode"), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (LeftShiftNode'canonical-5 this, (ArithmeticOperation'''getArithmeticOp-1 this), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm LeftShiftNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"LeftShiftNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitShl-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns RightShiftNode [ShiftNode #_"<Shr>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    (defn #_"RightShiftNode" RightShiftNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (RightShiftNode'class.) (ShiftNode'new-3 :shr, x, y))
    )

    (defn- #_"ValueNode" RightShiftNode'canonical-5 [#_"RightShiftNode" self, #_"ShiftOp<Shr>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (if (and (satisfies? IntegerStamp (:stamp forX)) (IntegerStamp''isPositive-1 (:stamp forX)))
            (UnsignedRightShiftNode'new-2 forX, forY)
            (when (satisfies? ConstantNode forY) => (or self (RightShiftNode'new-2 forX, forY))
                (let [
                    #_"int" amount (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))
                    #_"int" o'amount amount
                    #_"int" mask (ShiftOp'getShiftAmountMask-1 stamp)
                    amount (& amount mask)
                ]
                    (if (zero? amount)
                        forX
                        (if (and (satisfies? ShiftNode forX) (satisfies? ConstantNode (:y forX)) (satisfies? RightShiftNode forX))
                            (let [
                                #_"int" total (+ amount (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y forX))) mask))
                            ]
                                (cond
                                    (= total (& total mask))                                (RightShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 total))
                                    (IntegerStamp''isPositive-1 (:stamp (:x forX)))         (ConstantNode'forIntegerKind-2 (Stamp'''getStackKind-1 stamp), 0)
                                    (IntegerStamp''isStrictlyNegative-1 (:stamp (:x forX))) (ConstantNode'forIntegerKind-2 (Stamp'''getStackKind-1 stamp), -1)
                                    ;; if we cannot replace both shifts with a constant, replace them by a full shift for this kind
                                    :else                                                   (RightShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 mask))
                                )
                            )
                            (when-not (= amount o'amount) => (or self (RightShiftNode'new-2 forX, forY))
                                (RightShiftNode'new-2 forX, (ConstantNode'forInt-1 amount))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"ValueNode" RightShiftNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"ShiftOp<Shr>" op (:shr (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (ShiftOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (ShiftNode'canonical-4 op, stamp, x, y) (RightShiftNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    (defm RightShiftNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"RightShiftNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super #_"ShiftNode"), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (RightShiftNode'canonical-5 this, (ArithmeticOperation'''getArithmeticOp-1 this), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm RightShiftNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"RightShiftNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitShr-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

(class-ns UnsignedRightShiftNode [ShiftNode #_"<UShr>", BinaryNode, FloatingNode, ValueNode, Node, Binary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    (defn #_"UnsignedRightShiftNode" UnsignedRightShiftNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (UnsignedRightShiftNode'class.) (ShiftNode'new-3 :ushr, x, y))
    )

    (defn- #_"ValueNode" UnsignedRightShiftNode'canonical-5 [#_"UnsignedRightShiftNode" self, #_"ShiftOp<UShr>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (satisfies? ConstantNode forY) => (or self (UnsignedRightShiftNode'new-2 forX, forY))
            (let [
                #_"int" amount (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))
                #_"int" o'amount amount
                #_"int" mask (ShiftOp'getShiftAmountMask-1 stamp)
                amount (& amount mask)
            ]
                (if (zero? amount)
                    forX
                    (do
                        (when (and (satisfies? ShiftNode forX) (satisfies? ConstantNode (:y forX)))
                            (let [
                                #_"int" otherAmount (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y forX))) mask)
                            ]
                                (cond
                                    (satisfies? UnsignedRightShiftNode forX)
                                        (let [
                                            #_"int" total (+ amount otherAmount)
                                        ]
                                            (if (= total (& total mask))
                                                (ยง return (UnsignedRightShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 total)))
                                                (ยง return (ConstantNode'forIntegerKind-2 (Stamp'''getStackKind-1 stamp), 0))
                                            )
                                        )
                                    (and (satisfies? LeftShiftNode forX) (= amount otherAmount))
                                        (if (= (Stamp'''getStackKind-1 stamp) JavaKind/Long)
                                            (ยง return (AndNode'new-2 (:x forX), (ConstantNode'forLong-1 (>>> -1 amount))))
                                            (ยง return (AndNode'new-2 (:x forX), (ConstantNode'forInt-1 (>>> -1 amount))))
                                        )
                                )
                            )
                        )
                        (when-not (= amount o'amount) => (or self (UnsignedRightShiftNode'new-2 forX, forY))
                            (UnsignedRightShiftNode'new-2 forX, (ConstantNode'forInt-1 amount))
                        )
                    )
                )
            )
        )
    )

    (defn #_"ValueNode" UnsignedRightShiftNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"ShiftOp<UShr>" op (:ushr (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (ShiftOp'''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (ShiftNode'canonical-4 op, stamp, x, y) (UnsignedRightShiftNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    (defm UnsignedRightShiftNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"UnsignedRightShiftNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (let [
                #_"ValueNode" ret (Binary'''canonical-4 (ยง super #_"ShiftNode"), tool, forX, forY)
            ]
                (when (= ret this) => ret
                    (UnsignedRightShiftNode'canonical-5 this, (ArithmeticOperation'''getArithmeticOp-1 this), (:stamp this), forX, forY)
                )
            )
        )
    )

    (defm UnsignedRightShiftNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"UnsignedRightShiftNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitUShr-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
            nil
        )
    )
)

;;;
 ; Read {@code Class::_klass} to get the hub for a {@link java.lang.Class}. This node mostly exists
 ; to replace {@code _klass._java_mirror._klass} with {@code _klass}. The constant folding could be
 ; handled by ReadNode#canonicalizeRead(ValueNode, AddressNode, LocationIdentity, CanonicalizerTool).
 ;;
(class-ns ClassGetHubNode [FloatingNode, ValueNode, Node, Lowerable, Canonicalizable, ConvertNode]
    (defn #_"ClassGetHubNode" ClassGetHubNode'new-1 [#_"ValueNode" clazz]
        (merge (ClassGetHubNode'class.) (FloatingNode'new-1 KlassPointerStamp'KLASS)
            (hash-map
                ; @Input
                #_"ValueNode" :class clazz
            )
        )
    )

    (defn #_"ValueNode" ClassGetHubNode'create-2 [#_"ValueNode" clazz, #_"boolean" allUsagesAvailable]
        (ClassGetHubNode'canonical-4 nil, allUsagesAvailable, KlassPointerStamp'KLASS, clazz)
    )

    (defn #_"ValueNode" ClassGetHubNode'canonical-4 [#_"ClassGetHubNode" node, #_"boolean" allUsagesAvailable, #_"Stamp" stamp, #_"ValueNode" clazz]
        (when-not (and allUsagesAvailable (some? node) (Node''hasNoUsages-1 node))
            (condp satisfies? clazz
                ConstantNode
                    (let [
                        #_"ResolvedJavaType" exact (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (ValueNode''asJavaConstant-1 clazz))
                    ]
                        (ConstantNode'forConstant-2s stamp, (if (#_"ResolvedJavaType" .isPrimitive exact) JavaConstant/NULL_POINTER (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, exact)))
                    )
                GetClassNode
                    (LoadHubNode'new-2 KlassPointerStamp'KLASS_NON_NULL, (:object clazz))
                HubGetClassNode
                    (:hub clazz) ;; replace: _klass._java_mirror._klass -> _klass
                (or node (ClassGetHubNode'new-1 clazz))
            )
        )
    )

    (defm ClassGetHubNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"ClassGetHubNode" this, #_"CanonicalizerTool" tool]
            (ClassGetHubNode'canonical-4 this, (CanonicalizerTool'''allUsagesAvailable-1 tool), (:stamp this), (:class this))
        )
    )

    (defm ClassGetHubNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"ClassGetHubNode" this, #_"LoweringTool" lowerer]
            (when-not (= (:loweringStage (:phase lowerer)) LoweringStage'HIGH_TIER)
                (let [
                    #_"Graph" graph (:graph this)
                    #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, (ConvertNode'''getValue-1 this), HotSpot'klassOffset)
                    #_"FloatingReadNode" read (Graph''add-2 graph, (FloatingReadNode'new-6 address, NamedLocationIdentity'CLASS_KLASS, nil, (:stamp this), nil, BarrierType'NONE))
                ]
                    (ยง ass! this (Node''replaceAtUsagesAndDelete-2 this, read))
                )
            )
            nil
        )
    )

    #_unused
    (ยง intrinsic! #_"KlassPointer" ClassGetHubNode'readClass-1 [#_"Class" clazzNonNull])

    #_intrinsifier
    (defn #_"boolean" ClassGetHubNode'intrinsify-3 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode" clazz]
        (BytecodeParser''push-3 parser, JavaKind/Object, (BytecodeParser''append-2 parser, (ClassGetHubNode'create-2 clazz, false)))
        true
    )

    (defm ClassGetHubNode ConvertNode
        (#_"ValueNode" ConvertNode'''getValue-1 [#_"ClassGetHubNode" this]
            (:class this)
        )

        (#_"Constant" ConvertNode'''convert-2 [#_"ClassGetHubNode" this, #_"Constant" constant]
            (let [
                #_"ResolvedJavaType" exact (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant)
            ]
                (if (#_"ResolvedJavaType" .isPrimitive exact) JavaConstant/NULL_POINTER (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, exact))
            )
        )

        (#_"Constant" ConvertNode'''reverse-2 [#_"ClassGetHubNode" this, #_"Constant" constant]
            (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant))
        )

        (#_"boolean" ConvertNode'''isLossless-1 [#_"ClassGetHubNode" this]
            false
        )
    )

    ;;;
     ; There is more than one {@link java.lang.Class} value that has a NULL hub.
     ;;
    (defm ClassGetHubNode ConvertNode
        (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"ClassGetHubNode" this]
            false
        )

        (#_"boolean" ConvertNode'''preservesOrder-2 [#_"ClassGetHubNode" this, #_"CanonicalCondition" op]
            (ConvertNode'''isLossless-1 this)
        )

        (#_"boolean" ConvertNode'''preservesOrder-3 [#_"ClassGetHubNode" this, #_"CanonicalCondition" op, #_"Constant" value]
            (not (#_"ResolvedJavaType" .isPrimitive (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, value)))
        )
    )
)

;;;
 ; The ConditionalNode class represents a comparison that yields one of two (eagerly
 ; evaluated) values.
 ;;
(class-ns ConditionalNode [FloatingNode, ValueNode, Node, Canonicalizable, LIRLowerable]
    (defn #_"ConditionalNode" ConditionalNode'new-3 [#_"LogicNode" logic, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (merge (ConditionalNode'class.) (FloatingNode'new-1 (Stamp'''meet-2 (:stamp trueValue), (:stamp falseValue)))
            (hash-map
                ; @Input
                #_"LogicNode" :logic logic
                ; @Input(InputType'Value)
                #_"ValueNode" :trueValue trueValue
                ; @Input(InputType'Value)
                #_"ValueNode" :falseValue falseValue
            )
        )
    )

    (defn #_"ConditionalNode" ConditionalNode'new-1 [#_"LogicNode" logic]
        (ConditionalNode'new-3 logic, (ConstantNode'forInt-2 1, (:graph logic)), (ConstantNode'forInt-2 0, (:graph logic)))
    )

    #_unused
    (defn #_"ConditionalNode" ConditionalNode'new-4 [#_"Graph" graph, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (ConditionalNode'new-1 (CompareNode'createCompareNode-4g graph, condition, x, y))
    )

    (defn- #_"ValueNode" ConditionalNode'findSynonym-3 [#_"ValueNode" condition, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (condp satisfies? condition
            LogicNegationNode (ConditionalNode'create-3 (Unary'''getValue-1 condition), falseValue, trueValue)
            LogicConstantNode (if (:value condition) trueValue falseValue)
            nil
        )
    )

    (defn #_"ValueNode" ConditionalNode'canonicalizeConditional-4 [#_"LogicNode" logic, #_"ValueNode" trueValue, #_"ValueNode" falseValue, #_"Stamp" stamp]
        (cond
            (= trueValue falseValue)
                trueValue
            ;; optimize the pattern (x == y) ? x : y
            (and (satisfies? CompareNode logic)
                 (CompareNode''isIdentityComparison-1 logic)
                 (or (and (= (:x logic) trueValue) (= (:y logic) falseValue))
                     (and (= (:x logic) falseValue) (= (:y logic) trueValue))
                 )
            )
                falseValue
            (satisfies? IntegerStamp (:stamp trueValue))
                (do
                    ;; check if the conditional is redundant
                    (when (satisfies? IntegerLessThanNode logic)
                        (cond
                            (and (= (:x logic) trueValue) (= (:y logic) falseValue))
                                ;; return "x" for "x < y ? x : y" in case that we know "x <= y"
                                (when (<= (:upperBound (:stamp trueValue)) (:lowerBound (:stamp falseValue)))
                                    (ยง return trueValue)
                                )
                            (and (= (:x logic) falseValue) (= (:y logic) trueValue))
                                ;; return "y" for "x < y ? y : x" in case that we know "x <= y"
                                (when (<= (:upperBound (:stamp falseValue)) (:lowerBound (:stamp trueValue)))
                                    (ยง return trueValue)
                                )
                        )
                    )
                    ;; this optimizes the case where a value from the range 0 - 1 is mapped to the range 0 - 1
                    (when (and (satisfies? ConstantNode trueValue) (satisfies? ConstantNode falseValue))
                        (let [
                            #_"long" constTrueValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 trueValue))
                            #_"long" constFalseValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 falseValue))
                        ]
                            (condp satisfies? logic
                                IntegerEqualsNode
                                    (when (and (satisfies? ConstantNode (:y logic)) (satisfies? IntegerStamp (:stamp (:x logic))) (= (:upMask (:stamp (:x logic))) 1))
                                        (let [
                                            #_"long" equalsY (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y logic)))
                                        ]
                                            (cond
                                                (zero? equalsY)
                                                    (cond
                                                        (and (zero? constTrueValue) (= constFalseValue 1))
                                                            ;; return x when: x == 0 ? 0 : 1;
                                                            (ยง return (IntegerConvertNode'convertUnsigned-2 (:x logic), stamp))
                                                        (and (= constTrueValue 1) (zero? constFalseValue))
                                                            ;; negate a boolean value via xor
                                                            (ยง return (IntegerConvertNode'convertUnsigned-2 (XorNode'create-2 (:x logic), (ConstantNode'forIntegerStamp-2 (:stamp (:x logic)), 1)), stamp))
                                                    )
                                                (= equalsY 1)
                                                    (cond
                                                        (and (= constTrueValue 1) (zero? constFalseValue))
                                                            ;; return x when: x == 1 ? 1 : 0;
                                                            (ยง return (IntegerConvertNode'convertUnsigned-2 (:x logic), stamp))
                                                        (and (zero? constTrueValue) (= constFalseValue 1))
                                                            ;; negate a boolean value via xor
                                                            (ยง return (IntegerConvertNode'convertUnsigned-2 (XorNode'create-2 (:x logic), (ConstantNode'forIntegerStamp-2 (:stamp (:x logic)), 1)), stamp))
                                                    )
                                            )
                                        )
                                    )
                                IntegerTestNode
                                    ;; replace IntegerTestNode with AndNode for the following patterns:
                                    ;; (value & 1) == 0 ? 0 : 1
                                    ;; (value & 1) == 1 ? 1 : 0
                                    (when (satisfies? ConstantNode (:y logic))
                                        (let [
                                            #_"long" testY (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y logic)))
                                        ]
                                            (when (and (= testY 1) (zero? constTrueValue) (= constFalseValue 1))
                                                (ยง return (IntegerConvertNode'convertUnsigned-2 (AndNode'create-2 (:x logic), (:y logic)), stamp))
                                            )
                                        )
                                    )
                                nil
                            )
                        )
                    )
                    ;; convert a conditional add ((x < 0) ? (x + y) : x) into (x + (y & (x >> (bits - 1)))) to avoid the test
                    (when (satisfies? IntegerLessThanNode logic)
                        (when (and (satisfies? ConstantNode (:y logic)) (#_"Constant" .isDefaultForKind (:value (:y logic))) (= falseValue (:x logic)) (satisfies? AddNode trueValue) (= (:x trueValue) falseValue))
                            (AddNode'new-2 (:x trueValue), (AndNode'new-2 (RightShiftNode'new-2 (:x logic), (ConstantNode'forIntegerBits-2l 32, (dec (:bits (:stamp trueValue))))), (:y trueValue)))
                        )
                    )
                )
        )
    )

    (defn #_"ValueNode" ConditionalNode'create-3 [#_"LogicNode" logic, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (or (ConditionalNode'findSynonym-3 logic, trueValue, falseValue)
            (ConditionalNode'canonicalizeConditional-4 logic, trueValue, falseValue, (Stamp'''meet-2 (:stamp trueValue), (:stamp falseValue)))
            (ConditionalNode'new-3 logic, trueValue, falseValue)
        )
    )

    (defn #_"ValueNode" ConditionalNode'create-1 [#_"LogicNode" logic]
        (ConditionalNode'create-3 logic, (ConstantNode'forInt-2 1, (:graph logic)), (ConstantNode'forInt-2 0, (:graph logic)))
    )

    (defm ConditionalNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"ConditionalNode" this]
            (let [
                #_"Stamp" valueStamp (Stamp'''meet-2 (:stamp (:trueValue this)), (:stamp (:falseValue this)))
            ]
                (when (satisfies? IntegerLessThanNode (:logic this))
                    (let [
                        #_"IntegerLessThanNode" lessThan (:logic this)
                    ]
                        (cond
                            (and (= (:x lessThan) (:trueValue this)) (= (:y lessThan) (:falseValue this)))
                                ;; this encodes a min operation
                                (let [
                                    #_"JavaConstant" constant
                                        (or (ValueNode''asJavaConstant-1 (:x lessThan))
                                            (ValueNode''asJavaConstant-1 (:y lessThan))
                                        )
                                ]
                                    (when (some? constant)
                                        (let [
                                            #_"IntegerStamp" bounds (StampFactory'forInteger-3k (#_"JavaConstant" .getJavaKind constant), (#_"JavaKind" .getMinValue (#_"JavaConstant" .getJavaKind constant)), (#_"JavaConstant" .asLong constant))
                                        ]
                                            (ยง ass valueStamp (Stamp'''join-2 valueStamp, bounds))
                                        )
                                    )
                                )
                            (and (= (:x lessThan) (:falseValue this)) (= (:y lessThan) (:trueValue this)))
                                ;; this encodes a max operation
                                (let [
                                    #_"JavaConstant" constant
                                        (or (ValueNode''asJavaConstant-1 (:x lessThan))
                                            (ValueNode''asJavaConstant-1 (:y lessThan))
                                        )
                                ]
                                    (when (some? constant)
                                        (let [
                                            #_"IntegerStamp" bounds (StampFactory'forInteger-3k (#_"JavaConstant" .getJavaKind constant), (#_"JavaConstant" .asLong constant), (#_"JavaKind" .getMaxValue (#_"JavaConstant" .getJavaKind constant)))
                                        ]
                                            (ยง ass valueStamp (Stamp'''join-2 valueStamp, bounds))
                                        )
                                    )
                                )
                        )
                    )
                )
                (ValueNode''updateStamp-2 this, valueStamp)
            )
        )
    )

    (defm ConditionalNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"ConditionalNode" this, #_"CanonicalizerTool" tool]
            (or (ConditionalNode'findSynonym-3 (:logic this), (:trueValue this), (:falseValue this))
                (ConditionalNode'canonicalizeConditional-4 (:logic this), (:trueValue this), (:falseValue this), (:stamp this))
                this
            )
        )
    )

    (defm ConditionalNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ConditionalNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''emitConditional-2 builder, this)
            nil
        )
    )
)

;;;
 ; The ConstantNode represents a {@link Constant constant}.
 ;;
(class-ns ConstantNode [FloatingNode, ValueNode, Node, LIRLowerable]
    (defn- #_"ConstantNode" ConstantNode'new-4 [#_"Constant" value, #_"Stamp" stamp, #_"int" stableDimension, #_"boolean" isDefaultStable]
        (merge (ConstantNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ;;;
                 ; the constant value represented by this node
                 ;;
                #_"Constant" :value value
                ;;;
                 ; the number of stable dimensions if this is a stable array, otherwise 0
                 ;;
                #_"int" :stableDimension stableDimension
                ;;;
                 ; true if this is a stable array and the default elements are considered stable
                 ;;
                ;; Ensure that isDefaultStable has a canonical value to avoid having two constant nodes that only differ
                ;; in this field. The value of isDefaultStable is only used when we have a stable array dimension.
                #_"boolean" :isDefaultStable (and isDefaultStable (not (zero? stableDimension)))
            )
        )
    )

    ;;;
     ; Constructs a new node representing the specified constant.
     ;
     ; @param value the constant
     ;;
    (defn #_"ConstantNode" ConstantNode'new-2 [#_"Constant" value, #_"Stamp" stamp]
        (ConstantNode'new-4 value, stamp, 0, false)
    )

    (defn- #_"boolean" ConstantNode''onlyUsedInVirtualState-1 [#_"ConstantNode" this]
        (loop-when [#_"ISeq" s (seq (:nodeUsages this))] (some? s) => true
            (and (satisfies? VirtualState (first s))
                (recur (next s))
            )
        )
    )

    (defm ConstantNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ConstantNode" this, #_"LIRBuilder" builder]
            (let [
                #_"LIRKind" kind (Stamp'''getLIRKind-1 (:stamp this))
            ]
                (if (ConstantNode''onlyUsedInVirtualState-1 this)
                    (LIRBuilder''setResult-3 builder, this, (ConstantValue'new-2 kind, (:value this)))
                    (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitConstant-3 (:gen builder), kind, (:value this)))
                )
            )
            nil
        )
    )

    (defn- #_"ConstantNode" ConstantNode'createPrimitive-1 [#_"JavaConstant" value]
        (ConstantNode'new-2 value, (StampFactory'forPrimitiveConstant-1 value))
    )

    (defn #_"ConstantNode" ConstantNode'forConstant-2c [#_"JavaConstant" constant, #_"Graph" graph]
        (cond
            (and (= (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind constant)) JavaKind/Int) (not= (#_"JavaConstant" .getJavaKind constant) JavaKind/Int))
                (ConstantNode'forInt-2 (#_"JavaConstant" .asInt constant), graph)
            (= (#_"JavaConstant" .getJavaKind constant) JavaKind/Object)
                (Graph''add-2 graph, (ConstantNode'new-2 constant, (StampFactory'forConstant-1 constant)))
            :else
                (Graph''add-2 graph, (ConstantNode'createPrimitive-1 constant))
        )
    )

    (defn #_"ConstantNode" ConstantNode'forConstant-3c [#_"JavaConstant" constant, #_"int" stableDimension, #_"boolean" isDefaultStable]
        (cond
            (and (= (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind constant)) JavaKind/Int) (not= (#_"JavaConstant" .getJavaKind constant) JavaKind/Int))
                (ConstantNode'forInt-1 (#_"JavaConstant" .asInt constant))
            (= (#_"JavaConstant" .getJavaKind constant) JavaKind/Object)
                (ConstantNode'new-4 constant, (StampFactory'forConstant-1 constant), stableDimension, isDefaultStable)
            :else
                (ConstantNode'createPrimitive-1 constant)
        )
    )

    (defn #_"ConstantNode" ConstantNode'forConstant-1 [#_"JavaConstant" array]
        (ConstantNode'forConstant-3c array, 0, false)
    )

    (defn #_"ConstantNode" ConstantNode'forConstant-3s [#_"Stamp" stamp, #_"Constant" constant, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'new-2 constant, (Stamp'''constant-2 stamp, constant)))
    )

    (defn #_"ConstantNode" ConstantNode'forConstant-4 [#_"Stamp" stamp, #_"Constant" constant, #_"int" stableDimension, #_"boolean" isDefaultStable]
        (ConstantNode'new-4 constant, (Stamp'''constant-2 stamp, constant), stableDimension, isDefaultStable)
    )

    (defn #_"ConstantNode" ConstantNode'forConstant-2s [#_"Stamp" stamp, #_"Constant" constant]
        (ConstantNode'new-2 constant, (Stamp'''constant-2 stamp, constant))
    )

    (defn- #_"ConstantNode" ConstantNode'forIntegerBits-3c [#_"int" bits, #_"JavaConstant" constant, #_"Graph" graph]
        (let [
            #_"long" bounds (CodeUtil/signExtend (#_"JavaConstant" .asLong constant), bits)
        ]
            (Graph''add-2 graph, (ConstantNode'new-2 constant, (StampFactory'forInteger-3i bits, bounds, bounds)))
        )
    )

    ;;;
     ; Returns a node for a constant integer that's not directly representable as Java primitive (e.g. short).
     ;;
    (defn #_"ConstantNode" ConstantNode'forIntegerBits-3l [#_"int" bits, #_"long" value, #_"Graph" graph]
        (ConstantNode'forIntegerBits-3c bits, (JavaConstant/forPrimitiveInt bits, value), graph)
    )

    (defn- #_"ConstantNode" ConstantNode'forIntegerBits-2c [#_"int" bits, #_"JavaConstant" constant]
        (let [
            #_"long" bounds (CodeUtil/signExtend (#_"JavaConstant" .asLong constant), bits)
        ]
            (ConstantNode'new-2 constant, (StampFactory'forInteger-3i bits, bounds, bounds))
        )
    )

    ;;;
     ; Returns a node for a constant integer that's not directly representable as Java primitive (e.g. short).
     ;;
    (defn #_"ConstantNode" ConstantNode'forIntegerBits-2l [#_"int" bits, #_"long" value]
        (ConstantNode'forIntegerBits-2c bits, (JavaConstant/forPrimitiveInt bits, value))
    )

    ;;;
     ; Returns a node for a Java primitive.
     ;;
    (defn #_"ConstantNode" ConstantNode'forPrimitive-2c [#_"JavaConstant" constant, #_"Graph" graph]
        (ConstantNode'forConstant-2c constant, graph)
    )

    ;;;
     ; Returns a node for a Java primitive.
     ;;
    #_unused
    (defn #_"ConstantNode" ConstantNode'forPrimitive-1 [#_"JavaConstant" constant]
        (ConstantNode'forConstant-1 constant)
    )

    ;;;
     ; Returns a node for a primitive of a given type.
     ;;
    #_unused
    (defn #_"ConstantNode" ConstantNode'forPrimitive-3 [#_"Stamp" stamp, #_"JavaConstant" constant, #_"Graph" graph]
        (if (satisfies? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-3c (:bits stamp), constant, graph)
            (ConstantNode'forPrimitive-2c constant, graph)
        )
    )

    ;;;
     ; Returns a node for a primitive of a given type.
     ;;
    (defn #_"ConstantNode" ConstantNode'forPrimitive-2s [#_"Stamp" stamp, #_"Constant" constant]
        (if (satisfies? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-2c (:bits stamp), constant)
            (ConstantNode'new-2 constant, (Stamp'''constant-2 stamp, constant))
        )
    )

    ;;;
     ; Returns a node for an long constant.
     ;
     ; @param i the long value for which to create the instruction
     ; @return a node for an long constant
     ;;
    (defn #_"ConstantNode" ConstantNode'forLong-2 [#_"long" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forLong i)))
    )

    ;;;
     ; Returns a node for an long constant.
     ;
     ; @param i the long value for which to create the instruction
     ; @return a node for an long constant
     ;;
    (defn #_"ConstantNode" ConstantNode'forLong-1 [#_"long" i]
        (ConstantNode'createPrimitive-1 (JavaConstant/forLong i))
    )

    ;;;
     ; Returns a node for an integer constant.
     ;
     ; @param i the integer value for which to create the instruction
     ; @return a node for an integer constant
     ;;
    (defn #_"ConstantNode" ConstantNode'forInt-2 [#_"int" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for an integer constant.
     ;
     ; @param i the integer value for which to create the instruction
     ; @return a node for an integer constant
     ;;
    (defn #_"ConstantNode" ConstantNode'forInt-1 [#_"int" i]
        (ConstantNode'createPrimitive-1 (JavaConstant/forInt i))
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param i the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (defn #_"ConstantNode" ConstantNode'forBoolean-2 [#_"boolean" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt (if i 1 0))))
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param i the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (defn #_"ConstantNode" ConstantNode'forBoolean-1 [#_"boolean" i]
        (ConstantNode'createPrimitive-1 (JavaConstant/forInt (if i 1 0)))
    )

    ;;;
     ; Returns a node for a byte constant.
     ;
     ; @param i the byte value for which to create the instruction
     ; @return a node representing the byte
     ;;
    #_unused
    (defn #_"ConstantNode" ConstantNode'forByte-2 [#_"byte" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for a char constant.
     ;
     ; @param i the char value for which to create the instruction
     ; @return a node representing the char
     ;;
    #_unused
    (defn #_"ConstantNode" ConstantNode'forChar-2 [#_"char" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for a short constant.
     ;
     ; @param i the short value for which to create the instruction
     ; @return a node representing the short
     ;;
    #_unused
    (defn #_"ConstantNode" ConstantNode'forShort-2 [#_"short" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for a constant integer that's compatible to a given stamp.
     ;;
    (defn #_"ConstantNode" ConstantNode'forIntegerStamp-3 [#_"Stamp" stamp, #_"long" value, #_"Graph" graph]
        (if (satisfies? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-3l (:bits stamp), value, graph)
            (ConstantNode'forIntegerKind-3 (Stamp'''getStackKind-1 stamp), value, graph)
        )
    )

    ;;;
     ; Returns a node for a constant integer that's compatible to a given stamp.
     ;;
    (defn #_"ConstantNode" ConstantNode'forIntegerStamp-2 [#_"Stamp" stamp, #_"long" value]
        (if (satisfies? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-2l (:bits stamp), value)
            (ConstantNode'forIntegerKind-2 (Stamp'''getStackKind-1 stamp), value)
        )
    )

    (defn #_"ConstantNode" ConstantNode'forIntegerKind-3 [#_"JavaKind" kind, #_"long" value, #_"Graph" graph]
        (condp =? kind
           [JavaKind/Byte JavaKind/Short JavaKind/Int] (ConstantNode'forInt-2 (int value), graph)
            JavaKind/Long                              (ConstantNode'forLong-2 value, graph)
        )
    )

    (defn #_"ConstantNode" ConstantNode'forIntegerKind-2 [#_"JavaKind" kind, #_"long" value]
        (condp =? kind
           [JavaKind/Byte JavaKind/Short JavaKind/Int] (ConstantNode'createPrimitive-1 (JavaConstant/forInt (int value)))
            JavaKind/Long                              (ConstantNode'createPrimitive-1 (JavaConstant/forLong value))
        )
    )

    (defn #_"ConstantNode" ConstantNode'defaultForKind-2 [#_"JavaKind" kind, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'defaultForKind-1 kind))
    )

    (defn #_"ConstantNode" ConstantNode'defaultForKind-1 [#_"JavaKind" kind]
        (condp =? kind
           [JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Short JavaKind/Int] (ConstantNode'forInt-1 0)
            JavaKind/Long                                                             (ConstantNode'forLong-1 0)
            JavaKind/Object                                                           (ConstantNode'forConstant-1 JavaConstant/NULL_POINTER)
            nil
        )
    )
)

(class-ns FloatingAnchoredNode [FloatingNode, ValueNode, Node]
    (defn #_"FloatingAnchoredNode" FloatingAnchoredNode'new-2 [#_"Stamp" stamp, #_"AnchoringNode" anchor]
        (merge (FloatingAnchoredNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input(InputType'Anchor)
                #_"AnchoringNode" :anchor anchor
            )
        )
    )

    (defn #_"AnchoringNode" FloatingAnchoredNode''getAnchor-1 [#_"FloatingAnchoredNode" this]
        (:anchor this)
    )
)

;;;
 ; A guard is a node that deoptimizes based on a conditional expression. Guards are not attached to
 ; a certain frame state, they can move around freely and will always use the correct frame state
 ; when the nodes are scheduled (i.e. the last emitted frame state). The node that is guarded has a
 ; data dependency on the guard and the guard in turn has a data dependency on the condition. A
 ; guard may only be executed if it is guaranteed that the guarded node is executed too (if no
 ; exceptions are thrown). Therefore, an anchor is placed after a control flow split and the guard
 ; has a data dependency to the anchor. The anchor is the most distant node that is post-dominated
 ; by the guarded node and the guard can be scheduled anywhere between those two nodes. This ensures
 ; maximum flexibility for the guard node and guarantees that deoptimization occurs only if the
 ; control flow would have reached the guarded node (without taking exceptions into account).
 ;;
(class-ns GuardNode [FloatingAnchoredNode, FloatingNode, ValueNode, Node, Canonicalizable, GuardingNode, DeoptimizingGuard, StaticDeoptimizingNode]
    (defn #_"GuardNode" GuardNode'new-6 [#_"LogicNode" logic, #_"AnchoringNode" anchor, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"boolean" negated?, #_"JavaConstant" speculation]
        (merge (GuardNode'class.) (FloatingAnchoredNode'new-2 VoidStamp'instance, anchor)
            (hash-map
                ; @Input
                #_"LogicNode" :logic logic
                #_"DeoptimizationReason" :reason reason
                #_"DeoptimizationAction" :action action
                #_"JavaConstant" :speculation speculation
                #_"boolean" :negated? negated?
            )
        )
    )

    ;;;
     ; The instruction that produces the tested boolean value.
     ;;
    (defm GuardNode DeoptimizingGuard
        (#_"LogicNode" DeoptimizingGuard'''getCondition-1 [#_"GuardNode" this]
            (:logic this)
        )

        (#_"void" DeoptimizingGuard'''setCondition-3 [#_"GuardNode" this, #_"LogicNode" logic, #_"boolean" negated?]
            (Node''updateUsages-3 this, (:logic this), logic)
            (ยง ass! this (assoc this :logic logic))
            (ยง ass! this (assoc this :negated? negated?))
            nil
        )
    )

    (defm GuardNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"GuardNode" this, #_"CanonicalizerTool" tool]
            (let [
                #_"LogicNode" logic (DeoptimizingGuard'''getCondition-1 this)
            ]
                (cond
                    (satisfies? LogicNegationNode logic)
                        (GuardNode'new-6 (Unary'''getValue-1 logic), (FloatingAnchoredNode''getAnchor-1 this), (:reason this), (:action this), (not (:negated? this)), (:speculation this))
                    (or (not (satisfies? LogicConstantNode logic)) (= (:value logic) (:negated? this)))
                        this
                )
            )
        )
    )

    (defm GuardNode StaticDeoptimizingNode
        (#_"void" StaticDeoptimizingNode'''setAction-2 [#_"GuardNode" this, #_"DeoptimizationAction" invalidaterecompile]
            (ยง ass! this (assoc this :action invalidaterecompile))
            nil
        )

        (#_"void" StaticDeoptimizingNode'''setReason-2 [#_"GuardNode" this, #_"DeoptimizationReason" reason]
            (ยง ass! this (assoc this :reason reason))
            nil
        )
    )

    (defm GuardNode StaticDeoptimizingNode
        (#_"GuardPriority" StaticDeoptimizingNode'''computePriority-1 [#_"GuardNode" this]
            (if (and (some? (:speculation this)) (#_"JavaConstant" .isNonNull (:speculation this)))
                GuardPriority'Speculation
                (condp =? (:action this)
                    [DeoptimizationAction/InvalidateReprofile DeoptimizationAction/InvalidateRecompile]                                    GuardPriority'Profile
                    [DeoptimizationAction/RecompileIfTooManyDeopts DeoptimizationAction/InvalidateStopCompiling DeoptimizationAction/None] GuardPriority'None
                )
            )
        )
    )
)

(class-ns FloatingGuardedNode [FloatingNode, ValueNode, Node, GuardedNode]
    (defn #_"FloatingGuardedNode" FloatingGuardedNode'new-2 [#_"Stamp" stamp, #_"GuardingNode" guard]
        (merge (FloatingGuardedNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @OptionalInput(InputType'Guard)
                #_"GuardingNode" :guard guard
            )
        )
    )

    (defm FloatingGuardedNode GuardedNode
        (#_"GuardingNode" GuardedNode'''getGuard-1 [#_"FloatingGuardedNode" this]
            (:guard this)
        )

        (#_"void" GuardedNode'''setGuard-2 [#_"FloatingGuardedNode" this, #_"GuardingNode" guard]
            (Node''updateUsages-3 this, (:guard this), guard)
            (ยง ass! this (assoc this :guard guard))
            nil
        )
    )
)

(class-ns FloatingAccessNode [FloatingGuardedNode, FloatingNode, ValueNode, Node, GuardedNode, Access, HeapAccess, MemoryAccess]
    (defn #_"FloatingAccessNode" FloatingAccessNode'new-5 [#_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType]
        (merge (FloatingAccessNode'class.) (FloatingGuardedNode'new-2 stamp, guard)
            (hash-map
                ; @Input
                #_"AddressNode" :address address
                #_"LocationIdentity" :location location
                ;;;
                 ; Write barrier type.
                 ;;
                #_"BarrierType" :barrierType barrierType
            )
        )
    )

    (defm FloatingAccessNode Access
        (#_"AddressNode" Access'''getAddress-1 [#_"FloatingAccessNode" this]
            (:address this)
        )

        (#_"LocationIdentity" Access'''getLocationIdentity-1 [#_"FloatingAccessNode" this]
            (:location this)
        )

        (#_"boolean" Access'''canNullCheck-1 [#_"FloatingAccessNode" this]
            true
        )
    )

    (defm FloatingAccessNode MemoryAccess
        (#_"LocationIdentity" MemoryAccess'''getLocationIdentity-1 [#_"FloatingAccessNode" this]
            (:location this)
        )
    )
)

;;;
 ; A floating read of a value from memory specified in terms of an object base and an object
 ; relative location. This node does not nil-check the object.
 ;;
(class-ns FloatingReadNode [FloatingAccessNode, FloatingGuardedNode, FloatingNode, ValueNode, Node, GuardedNode, Access, HeapAccess, MemoryAccess, LIRLowerableAccess, LIRLowerable, Canonicalizable]
    #_unused
    (defn #_"FloatingReadNode" FloatingReadNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"MemoryNode" lastLocationAccess, #_"Stamp" stamp]
        (FloatingReadNode'new-6 address, location, lastLocationAccess, stamp, nil, BarrierType'NONE)
    )

    (defn #_"FloatingReadNode" FloatingReadNode'new-5 [#_"AddressNode" address, #_"LocationIdentity" location, #_"MemoryNode" lastLocationAccess, #_"Stamp" stamp, #_"GuardingNode" guard]
        (FloatingReadNode'new-6 address, location, lastLocationAccess, stamp, guard, BarrierType'NONE)
    )

    (defn #_"FloatingReadNode" FloatingReadNode'new-6 [#_"AddressNode" address, #_"LocationIdentity" location, #_"MemoryNode" lastLocationAccess, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType]
        ;; The input to floating reads must be always non-nil or have at least a guard.
        (merge (FloatingReadNode'class.) (FloatingAccessNode'new-5 address, location, stamp, guard, barrierType)
            (hash-map
                ; @OptionalInput(InputType'Memory)
                #_"MemoryNode" :lastLocationAccess lastLocationAccess
            )
        )
    )

    (defm FloatingReadNode MemoryAccess
        (#_"void" MemoryAccess'''setLastLocationAccess-2 [#_"FloatingReadNode" this, #_"MemoryNode" newlla]
            (Node''updateUsages-3 this, (:lastLocationAccess this), newlla)
            (ยง ass! this (assoc this :lastLocationAccess newlla))
            nil
        )
    )

    (defm FloatingReadNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"FloatingReadNode" this, #_"LIRBuilder" builder]
            (let [
                #_"LIRKind" readKind (Stamp'''getLIRKind-1 (:stamp this))
            ]
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitLoad-3 (:gen builder), readKind, (LIRBuilder''operand-2 builder, (:address this))))
            )
            nil
        )
    )

    (defm FloatingReadNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"FloatingReadNode" this, #_"CanonicalizerTool" tool]
            (let [
                #_"Node" result (ReadNode'canonicalizeRead-4 this, (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), tool)
            ]
                (when (= result this) => result
                    (when (and (CanonicalizerTool'''canonicalizeReads-1 tool) (Node''hasMoreThanOneUsage-1 (Access'''getAddress-1 this)) (satisfies? WriteNode (:lastLocationAccess this))) => this
                        (let [
                            #_"WriteNode" write (:lastLocationAccess this)
                        ]
                            (when (and (= (Access'''getAddress-1 write) (Access'''getAddress-1 this)) (Stamp'''isCompatible-2s (LIRLowerableAccess'''getAccessStamp-1 write), (LIRLowerableAccess'''getAccessStamp-1 this))) => this
                                ;; same memory location with no intervening write
                                (:value write)
                            )
                        )
                    )
                )
            )
        )
    )

    (defm FloatingReadNode FloatingAccessNode
        (#_"FixedAccessNode" FloatingAccessNode'''asFixedNode-1 [#_"FloatingReadNode" this]
            (let [
                #_"ReadNode" result (Graph''add-2 (:graph this), (ReadNode'new-4 (Access'''getAddress-1 this), (Access'''getLocationIdentity-1 this), (:stamp this), (:barrierType this)))
            ]
                (GuardedNode'''setGuard-2 result, (GuardedNode'''getGuard-1 this))
                result
            )
        )
    )

    (defm FloatingReadNode LIRLowerableAccess
        (#_"Stamp" LIRLowerableAccess'''getAccessStamp-1 [#_"FloatingReadNode" this]
            (:stamp this)
        )
    )
)

;;;
 ; A node that changes the type of its input, usually narrowing it. For example, a PiNode
 ; refines the type of a receiver during type-guarded inlining to be the type tested by the guard.
 ;
 ; In contrast to a GuardedValueNode, a PiNode is useless as soon as the type of its
 ; input is as narrow or narrower than the PiNode's type. The PiNode, and therefore
 ; also the scheduling restriction enforced by the guard, will go away.
 ;;
(class-ns PiNode [FloatingGuardedNode, FloatingNode, ValueNode, Node, GuardedNode, LIRLowerable, Virtualizable, Canonicalizable, ValueProxy, LimitedValueProxy, Proxy]
    (defn #_"PiNode" PiNode'new-2 [#_"ValueNode" object, #_"Stamp" stamp]
        (PiNode'new-3 object, stamp, nil)
    )

    (defn #_"PiNode" PiNode'new-3 [#_"ValueNode" object, #_"Stamp" stamp, #_"GuardingNode" guard]
        (let [
            #_"PiNode" this
                (merge (PiNode'class.) (FloatingGuardedNode'new-2 stamp, guard)
                    (hash-map
                        ; @Input
                        #_"ValueNode" :object object
                        #_"Stamp" :piStamp stamp
                    )
                )
        ]
            (ValueNode'''inferStamp-1 this)
            this
        )
    )

    (defn #_"ValueNode" PiNode'create-3 [#_"ValueNode" object, #_"Stamp" stamp, #_"ValueNode" guard]
        (or (PiNode'canonical-3 object, stamp, guard)
            (PiNode'new-3 object, stamp, guard)
        )
    )

    ;;;
     ; Changes the stamp of an object and ensures the newly stamped value is non-nil and does not
     ; float above a given guard.
     ;;
    (ยง intrinsic! #_"Object" PiNode'piCastNonNull-2 [#_"Object" object, #_"GuardingNode" guard])

    #_intrinsifier
    (defn #_"boolean" PiNode'intrinsify-4 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode" object, #_"ValueNode" guard]
        (let [
            #_"Stamp" stamp (AbstractPointerStamp''asNonNull-1 (:stamp object))
            #_"ValueNode" value
                (or (PiNode'canonical-3 object, stamp, guard)
                    (PiNode'new-3 object, stamp, guard)
                )
        ]
            (BytecodeParser''push-3 parser, JavaKind/Object, (BytecodeParser''append-2 parser, value))
            true
        )
    )

    (defm PiNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"PiNode" this, #_"LIRBuilder" builder]
            (when (LIRBuilder''hasOperand-2 builder, (:object this))
                (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:object this)))
            )
            nil
        )
    )

    (defm PiNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"PiNode" this]
            (ValueNode''updateStamp-2 this, (Stamp'''improveWith-2 (:piStamp this), (:stamp (:object this))))
        )
    )

    (defm PiNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"PiNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" object (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (and (satisfies? VirtualObjectNode object) (some? (StampTool'typeOrNull-1 (:stamp this))) (#_"ResolvedJavaType" .isAssignableFrom (StampTool'typeOrNull-1 (:stamp this)), (VirtualObjectNode'''type-1 object)))
                    (VirtualizerTool'''replaceWithVirtual-2 tool, object)
                )
            )
            nil
        )
    )

    (defn #_"ValueNode" PiNode'canonical-3 [#_"ValueNode" object, #_"Stamp" stamp, #_"GuardingNode" guard]
        ;; Use most up to date stamp.
        (let [
            #_"Stamp" improved (Stamp'''improveWith-2 stamp, (:stamp object))
        ]
            ;; The pi node does not give any additional information => skip it.
            (cond
                (= improved (:stamp object))
                    object
                (nil? guard) ;; Try to merge the pi node with a load node.
                    (when (and (satisfies? ReadNode object) (not (Node''hasMoreThanOneUsage-1 object)))
                        (ValueNode''setStamp-2 object, (Stamp'''improveWith-2 (:stamp object), stamp))
                    )
                :else
                    (loop-when [#_"ISeq" s (seq (:nodeUsages guard))] (some? s)
                        (let [
                            #_"Node" node (first s)
                        ]
                            ;; Two PiNodes with the same guard and same result, so return the one with the more precise piStamp.
                            (if (and (satisfies? PiNode node) (= (:object node) object) (= (:stamp node) improved) (= (:piStamp node) (Stamp'''join-2 stamp, (:piStamp node))))
                                node
                                (recur (next s))
                            )
                        )
                    )
            )
        )
    )

    (defm PiNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"PiNode" this, #_"CanonicalizerTool" tool]
            (or (PiNode'canonical-3 (:object this), (:stamp this), (GuardedNode'''getGuard-1 this))
                this
            )
        )
    )

    (defm PiNode Proxy
        (#_"ValueNode" Proxy'''getOriginalNode-1 [#_"PiNode" this]
            (:object this)
        )
    )
)

;;;
 ; A PiNode that also provides an array length in addition to a more refined stamp. A usage
 ; that reads the array length, such as an ArrayLengthNode, can be canonicalized based on
 ; this information.
 ;;
(class-ns PiArrayNode [PiNode, FloatingGuardedNode, FloatingNode, ValueNode, Node, GuardedNode, LIRLowerable, Virtualizable, Canonicalizable, ValueProxy, LimitedValueProxy, Proxy, ArrayLengthProvider]
    (defm PiArrayNode ArrayLengthProvider
        (#_"ValueNode" ArrayLengthProvider'''length-1 [#_"PiArrayNode" this]
            (:length this)
        )
    )

    (defn #_"PiArrayNode" PiArrayNode'new-3 [#_"ValueNode" object, #_"ValueNode" length, #_"Stamp" stamp]
        (merge (PiArrayNode'class.) (PiNode'new-3 object, stamp, nil)
            (hash-map
                ; @Input
                #_"ValueNode" :length length
            )
        )
    )

    (defm PiArrayNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"PiArrayNode" this, #_"CanonicalizerTool" tool]
            (when (= (GraphUtil'arrayLength-1 (:object this)) (ArrayLengthProvider'''length-1 this)) => this
                (Canonicalizable'''canonical-2 (ยง super #_"PiNode"), tool)
            )
        )
    )
)

(class-ns Placeholder [FloatingGuardedNode, FloatingNode, ValueNode, Node, GuardedNode]
    ;;;
     ; Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.
     ;;
    (ยง intrinsic! #_"Object" Placeholder'piCastToSnippetReplaceeStamp-1 [#_"Object" object])

    #_intrinsifier
    (defn #_"Placeholder" Placeholder'new-1 [#_"ValueNode" object]
        (merge (Placeholder'class.) (FloatingGuardedNode'new-2 PlaceholderStamp'SINGLETON, nil)
            (hash-map
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defm Placeholder Placeholder
        (#_"void" Placeholder'''makeReplacement-2 [#_"Placeholder" this, #_"Stamp" snippetReplaceeStamp]
            (ยง ass! this (Node''replaceAndDelete-2 this, (Graph''maybeAddOrUnique-2 (:graph this), (PiNode'create-3 (:object this), snippetReplaceeStamp, nil))))
            nil
        )
    )
)

;;;
 ; A placeholder node in a snippet that will be replaced with a PiArrayNode when the
 ; snippet is instantiated.
 ;;
(class-ns ArrayPlaceholder [Placeholder, FloatingGuardedNode, FloatingNode, ValueNode, Node, GuardedNode]
    ;;;
     ; Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.
     ;;
    (ยง intrinsic! #_"Object" ArrayPlaceholder'piArrayCastToSnippetReplaceeStamp-2 [#_"Object" object, #_"int" length])

    #_intrinsifier
    (defn #_"ArrayPlaceholder" ArrayPlaceholder'new-2 [#_"ValueNode" object, #_"ValueNode" length]
        (merge (ArrayPlaceholder'class.) (Placeholder'new-1 object)
            (hash-map
                ; @Input
                #_"ValueNode" :length length
            )
        )
    )

    (defm ArrayPlaceholder Placeholder
        (#_"void" Placeholder'''makeReplacement-2 [#_"ArrayPlaceholder" this, #_"Stamp" snippetReplaceeStamp]
            (let [
                #_"PiArrayNode" piArray (Graph''add-2 (:graph this), (PiArrayNode'new-3 (:object this), (:length this), snippetReplaceeStamp))
            ]
                (ยง ass! this (Node''replaceAndDelete-2 this, piArray))
            )
            nil
        )
    )
)

;;;
 ; Loads an object's class (i.e. this node can be created for {@code object.getClass()}).
 ;;
(class-ns GetClassNode [FloatingNode, ValueNode, Node, Lowerable, Canonicalizable, Virtualizable]
    #_unused
    (defn #_"GetClassNode" GetClassNode'new-2 [#_"Stamp" stamp, #_"ValueNode" object]
        (merge (GetClassNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :object object
            )
        )
    )

    (defm GetClassNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"GetClassNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"LoadHubNode" hub (Graph''add-2 (:graph this), (LoadHubNode'new-1 (:object this)))
                #_"HubGetClassNode" hubGetClass (Graph''add-2 (:graph this), (HubGetClassNode'new-1 hub))
            ]
                (ยง ass! this (Node''replaceAtUsagesAndDelete-2 this, hubGetClass))
                (Lowerable'''lower-2 hub, lowerer)
                (Lowerable'''lower-2 hubGetClass, lowerer)
            )
            nil
        )
    )

    (defn #_"ValueNode" GetClassNode'tryFold-1 [#_"ValueNode" object]
        (when (and (some? object) (satisfies? ObjectStamp (:stamp object)) (AbstractObjectStamp''isExactType-1 (:stamp object)))
            (ConstantNode'forConstant-1 (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (:type (:stamp object))))
        )
    )

    (defm GetClassNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"GetClassNode" this, #_"CanonicalizerTool" tool]
            (or (GetClassNode'tryFold-1 (:object this))
                this
            )
        )
    )

    (defm GetClassNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"GetClassNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" alias (VirtualizerTool'''getAlias-2 tool, (:object this))
            ]
                (when (satisfies? VirtualObjectNode alias)
                    (VirtualizerTool'''replaceWithValue-2 tool, (ConstantNode'forConstant-3s (:stamp this), (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (VirtualObjectNode'''type-1 alias)), (:graph this)))
                )
            )
            nil
        )
    )
)

(class-ns HeapBaseNode [FloatingNode, ValueNode, Node, LIRLowerable]
    (defn #_"HeapBaseNode" HeapBaseNode'new-1 [#_"Register" heapBaseRegister]
        (merge (HeapBaseNode'class.) (FloatingNode'new-1 StampFactory'rawPointer)
            (hash-map
                #_"Register" :heapBaseRegister heapBaseRegister
            )
        )
    )

    (defm HeapBaseNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"HeapBaseNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (#_"Register" .asValue (:heapBaseRegister this), (Stamp'''getLIRKind-1 (:stamp this))))
            nil
        )
    )
)

;;;
 ; Read {@code Klass::_java_mirror} and incorporate non-nil type information into stamp. This is
 ; also used by ClassGetHubNode to eliminate chains of {@code klass._java_mirror._klass}.
 ;;
(class-ns HubGetClassNode [FloatingNode, ValueNode, Node, Lowerable, Canonicalizable, ConvertNode]
    (defn #_"HubGetClassNode" HubGetClassNode'new-1 [#_"ValueNode" hub]
        (merge (HubGetClassNode'class.) (FloatingNode'new-1 (StampFactory'objectNonNull-1 (TypeReference'create-1 (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Class))))
            (hash-map
                ; @Input
                #_"ValueNode" :hub hub
            )
        )
    )

    (defm HubGetClassNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"HubGetClassNode" this, #_"CanonicalizerTool" tool]
            (when-not (and (CanonicalizerTool'''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                (when (satisfies? ConstantNode (:hub this)) => this
                    (let [
                        #_"ResolvedJavaType" exact (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value (:hub this)))
                    ]
                        (when (some? exact) => this
                            (ConstantNode'forConstant-1 (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, exact))
                        )
                    )
                )
            )
        )
    )

    (defm HubGetClassNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"HubGetClassNode" this, #_"LoweringTool" lowerer]
            (when-not (= (:loweringStage (:phase lowerer)) LoweringStage'HIGH_TIER)
                (let [
                    #_"Graph" graph (:graph this)
                    #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, (:hub this), HotSpot'classMirrorOffset)
                    #_"FloatingReadNode" read (Graph''add-2 graph, (FloatingReadNode'new-6 address, NamedLocationIdentity'CLASS_MIRROR, nil, (StampFactory'forKind-1 (.wordJavaKind HotSpot'target)), nil, BarrierType'NONE))
                    address (Lowerer'createOffsetAddress-3 graph, read, 0)
                    read (Graph''add-2 graph, (FloatingReadNode'new-6 address, NamedLocationIdentity'CLASS_MIRROR_HANDLE, nil, (:stamp this), nil, BarrierType'NONE))
                ]
                    (ยง ass! this (Node''replaceAtUsagesAndDelete-2 this, read))
                )
            )
            nil
        )
    )

    (defm HubGetClassNode ConvertNode
        (#_"ValueNode" ConvertNode'''getValue-1 [#_"HubGetClassNode" this]
            (:hub this)
        )

        (#_"Constant" ConvertNode'''convert-2 [#_"HubGetClassNode" this, #_"Constant" constant]
            (if (= JavaConstant/NULL_POINTER constant)
                constant
                (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant))
            )
        )

        (#_"Constant" ConvertNode'''reverse-2 [#_"HubGetClassNode" this, #_"Constant" constant]
            (if (= JavaConstant/NULL_POINTER constant)
                constant
                (let [
                    #_"ResolvedJavaType" type (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant)
                ]
                    (if (#_"ResolvedJavaType" .isPrimitive type)
                        JavaConstant/NULL_POINTER
                        (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, type)
                    )
                )
            )
        )
    )

    ;;;
     ; Any concrete Klass* has a corresponding {@link java.lang.Class}.
     ;;
    (defm HubGetClassNode ConvertNode
        (#_"boolean" ConvertNode'''isLossless-1 [#_"HubGetClassNode" this]
            true
        )

        (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"HubGetClassNode" this]
            true
        )

        (#_"boolean" ConvertNode'''preservesOrder-2 [#_"HubGetClassNode" this, #_"CanonicalCondition" op]
            (ConvertNode'''isLossless-1 this)
        )

        (#_"boolean" ConvertNode'''preservesOrder-3 [#_"HubGetClassNode" this, #_"CanonicalCondition" op, #_"Constant" value]
            (ConvertNode'''preservesOrder-2 this, op)
        )
    )
)

;;;
 ; Loads an object's hub. The object is not nil-checked by this operation.
 ;;
(class-ns LoadHubNode [FloatingNode, ValueNode, Node, Lowerable, Canonicalizable, Virtualizable]
    (defn #_"ValueNode" LoadHubNode'create-1 [#_"ValueNode" value]
        (let [
            #_"Stamp" stamp KlassPointerStamp'KLASS_NON_NULL
        ]
            (or (LoadHubNode'findSynonym-2 value, stamp)
                (LoadHubNode'new-2 stamp, value)
            )
        )
    )

    (ยง intrinsic! #_"KlassPointer" LoadHubNode'loadHubIntrinsic-1 [#_"Object" object])

    #_intrinsifier
    (defn #_"LoadHubNode" LoadHubNode'new-1 [#_"ValueNode" value]
        (LoadHubNode'new-2 KlassPointerStamp'KLASS_NON_NULL, value)
    )

    (defn #_"LoadHubNode" LoadHubNode'new-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (merge (LoadHubNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
            )
        )
    )

    (defm LoadHubNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"LoadHubNode" this, #_"LoweringTool" lowerer]
            (when (and (= (:loweringStage (:phase lowerer)) LoweringStage'LOW_TIER) (not (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph this)))))
                (ยง ass! this (Node''replaceAtUsagesAndDelete-2 this, (Lowerer'createReadHub-3 (:graph this), (:value this), lowerer)))
            )
            nil
        )
    )

    (defm LoadHubNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"LoadHubNode" this, #_"CanonicalizerTool" tool]
            (or (LoadHubNode'findSynonym-2 (:value this), (:stamp this))
                this
            )
        )
    )

    (defn #_"ValueNode" LoadHubNode'findSynonym-2 [#_"ValueNode" curValue, #_"Stamp" stamp]
        (let [
            #_"TypeReference" type (StampTool'typeReferenceOrNull-1 (:stamp curValue))
        ]
            (when (and (some? type) (:exactReference type))
                (ConstantNode'forConstant-2s stamp, (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type type)))
            )
        )
    )

    (defm LoadHubNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"LoadHubNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"TypeReference" type (StampTool'typeReferenceOrNull-1 (:stamp (VirtualizerTool'''getAlias-2 tool, (:value this))))
            ]
                (when (and (some? type) (:exactReference type))
                    (VirtualizerTool'''replaceWithValue-2 tool, (ConstantNode'forConstant-3s (:stamp this), (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type type)), (:graph this)))
                )
            )
            nil
        )
    )
)

(class-ns LogicNode [FloatingNode, ValueNode, Node, IndirectCanonicalization]
    (defn #_"LogicNode" LogicNode'new-0 []
        (merge (LogicNode'class.) (FloatingNode'new-1 VoidStamp'instance))
    )

    #_unused
    (defn #_"LogicNode" LogicNode'and-3 [#_"LogicNode" a, #_"LogicNode" b, #_"double" shortCircuitProbability]
        (LogicNode'and-5 a, false, b, false, shortCircuitProbability)
    )

    (defn #_"LogicNode" LogicNode'and-5 [#_"LogicNode" a, #_"boolean" negateA, #_"LogicNode" b, #_"boolean" negateB, #_"double" shortCircuitProbability]
        (let [
            #_"Graph" graph (:graph a)
            #_"ShortCircuitOrNode" notAorNotB (Graph''add-2 graph, (ShortCircuitOrNode'new-5 a, (not negateA), b, (not negateB), shortCircuitProbability))
        ]
            (Graph''add-2 graph, (LogicNegationNode'new-1 notAorNotB))
        )
    )

    (defn #_"LogicNode" LogicNode'or-3 [#_"LogicNode" a, #_"LogicNode" b, #_"double" shortCircuitProbability]
        (LogicNode'or-5 a, false, b, false, shortCircuitProbability)
    )

    (defn #_"LogicNode" LogicNode'or-5 [#_"LogicNode" a, #_"boolean" negateA, #_"LogicNode" b, #_"boolean" negateB, #_"double" shortCircuitProbability]
        (Graph''add-2 (:graph a), (ShortCircuitOrNode'new-5 a, negateA, b, negateB, shortCircuitProbability))
    )

    (defn #_"boolean" LogicNode''isTautology-1 [#_"LogicNode" this]
        (and (satisfies? LogicConstantNode this)
            (:value this)
        )
    )

    #_unused
    (defn #_"boolean" LogicNode''isContradiction-1 [#_"LogicNode" this]
        (and (satisfies? LogicConstantNode this)
            (not (:value this))
        )
    )
)

(class-ns BinaryOpLogicNode [LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable]
    (defn #_"BinaryOpLogicNode" BinaryOpLogicNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (BinaryOpLogicNode'class.) (LogicNode'new-0)
            (hash-map
                ; @Input
                #_"ValueNode" :x x
                ; @Input
                #_"ValueNode" :y y
            )
        )
    )

    (defm BinaryOpLogicNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"BinaryOpLogicNode" this, #_"CanonicalizerTool" tool]
            (Binary'''canonical-4 this, tool, (:x this), (:y this))
        )
    )

    (defm BinaryOpLogicNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"BinaryOpLogicNode" this, #_"LIRBuilder" builder]
            nil
        )
    )

    ;;;
     ; Ensure a canonical ordering of inputs for commutative nodes to improve GVN results. Order the inputs
     ; by increasing Node#id and call Graph#findDuplicate(Node) on the node if it's currently in a graph.
     ;
     ; @return the original node or another node with the same inputs, ignoring ordering
     ;;
    (defm BinaryOpLogicNode Binary
        (#_"LogicNode" Binary'''maybeCommuteInputs-1 [#_"BinaryOpLogicNode" this]
            (when (and (not (satisfies? ConstantNode (:y this))) (or (satisfies? ConstantNode (:x this)) (< (:nid (:y this)) (:nid (:x this))))) => this
                (assoc this :x (:y this) :y (:x this))
            )
        )
    )
)

(class-ns CompareNode [BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable]
    ;;;
     ; Constructs a new Compare instruction.
     ;
     ; @param x the instruction producing the first input to the instruction
     ; @param y the instruction that produces the second input to this instruction
     ;;
    (defn #_"CompareNode" CompareNode'new-3 [#_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (merge (CompareNode'class.) (BinaryOpLogicNode'new-2 x, y)
            (hash-map
                ;;;
                 ; The condition (comparison operation) for this instruction.
                 ;;
                #_"CanonicalCondition" :condition condition
            )
        )
    )

    (defn #_"LogicNode" CompareNode'tryConstantFold-3 [#_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY) (or (some? HotSpot'constantReflection) (instance? PrimitiveConstant (:value forX))))
            (LogicConstantNode'forBoolean-1 (Condition''foldCondition-3c (:canonical condition), (:value forX), (:value forY)))
        )
    )

    (defn #_"LogicNode" CompareNode'tryConstantFoldPrimitive-3 [#_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (instance? PrimitiveConstant (ValueNode''asConstant-1 forX)) (instance? PrimitiveConstant (ValueNode''asConstant-1 forY)))
            (LogicConstantNode'forBoolean-1 (Condition''foldCondition-3p (:canonical condition), (ValueNode''asConstant-1 forX), (ValueNode''asConstant-1 forY)))
        )
    )

    ;;;
     ; Does this operation represent an identity check such that for x == y,
     ; x is exactly the same thing as y.
     ;
     ; @return true for identity comparisons
     ;;
    (defn #_"boolean" CompareNode''isIdentityComparison-1 [#_"CompareNode" this]
        (= (:condition this) CanonicalCondition'EQ)
    )

    (defn #_"LogicNode" CompareNode'createCompareNode-4g [#_"Graph" graph, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"LogicNode" result (CompareNode'createCompareNode-3 condition, x, y)
        ]
            (if (nil? (:graph result)) (Graph''addOrUniqueWithInputs-2 graph, result) result)
        )
    )

    (defn #_"LogicNode" CompareNode'createCompareNode-3 [#_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (condp = condition
            CanonicalCondition'EQ
                (condp satisfies? (:stamp x)
                    AbstractObjectStamp  (ObjectEqualsNode'create-2 x, y)
                    AbstractPointerStamp (PointerEqualsNode'create-2 x, y)
                                         (IntegerEqualsNode'create-2 x, y)
                )
            CanonicalCondition'LT (IntegerLessThanNode'create-2 x, y)
                                  (IntegerBelowNode'create-2 x, y)
        )
    )

    #_unused
    (defn #_"LogicNode" CompareNode'createCompareNode-5 [#_"Graph" graph, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"LogicNode" result (CompareNode'createCompareNode-4i smallestCompareWidth, condition, x, y)
        ]
            (if (nil? (:graph result)) (Graph''addOrUniqueWithInputs-2 graph, result) result)
        )
    )

    (defn #_"LogicNode" CompareNode'createCompareNode-4i [#_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (condp = condition
            CanonicalCondition'EQ
                (condp satisfies? (:stamp x)
                    AbstractObjectStamp  (ObjectEqualsNode'createCanonical-2 x, y)
                    AbstractPointerStamp (PointerEqualsNode'create-2 x, y)
                                         (IntegerEqualsNode'create-3 smallestCompareWidth, x, y)
                )
            CanonicalCondition'LT (IntegerLessThanNode'create-3 smallestCompareWidth, x, y)
                                  (IntegerBelowNode'create-3 smallestCompareWidth, x, y)
        )
    )
)

(class-ns IntegerEqualsNode [CompareNode, BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable, BinaryCommutative]
    (def- #_"IntegerEqualsOp" IntegerEqualsNode'OP (ยง soon IntegerEqualsOp'new-0))

    (defn #_"IntegerEqualsNode" IntegerEqualsNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (IntegerEqualsNode'class.) (CompareNode'new-3 CanonicalCondition'EQ, x, y))
    )

    (defn #_"LogicNode" IntegerEqualsNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (CompareNode'tryConstantFoldPrimitive-3 CanonicalCondition'EQ, x, y)
            (do
                (cond
                    (satisfies? ConditionalNode x)
                        (condp = y
                            (:trueValue x)
                                (ยง return (:logic x))
                            (:falseValue x)
                                (ยง return (LogicNegationNode'create-1 (:logic x)))
                            nil
                        )
                    (satisfies? ConditionalNode y)
                        (condp = x
                            (:trueValue y)
                                (ยง return (:logic y))
                            (:falseValue y)
                                (ยง return (LogicNegationNode'create-1 (:logic y)))
                            nil
                        )
                )
                (Binary'''maybeCommuteInputs-1 (IntegerEqualsNode'new-2 x, y))
            )
        )
    )

    (defn #_"LogicNode" IntegerEqualsNode'create-3 [#_"Integer" smallestCompareWidth, #_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp'''canonical-5 IntegerEqualsNode'OP, smallestCompareWidth, CanonicalCondition'EQ, x, y)
            (IntegerEqualsNode'create-2 x, y)
        )
    )

    (defm IntegerEqualsNode Binary
        (#_"Node" Binary'''canonical-4 [#_"IntegerEqualsNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareOp'''canonical-5 IntegerEqualsNode'OP, (CanonicalizerTool'''smallestCompareWidth-1 tool), CanonicalCondition'EQ, forX, forY)
                this
            )
        )
    )

    (defm IntegerEqualsNode BinaryOpLogicNode
        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForX-4 [#_"IntegerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when-not negated? (Stamp'''join-2 xStamp, yStamp))
        )

        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForY-4 [#_"IntegerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when-not negated? (Stamp'''join-2 xStamp, yStamp))
        )

        (#_"TriState" BinaryOpLogicNode'''tryFold-3 [#_"IntegerEqualsNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when (and (satisfies? IntegerStamp xStamp) (satisfies? IntegerStamp yStamp)) => TriState/UNKNOWN
                (cond
                    (Stamp'''alwaysDistinct-2 xStamp, yStamp) TriState/FALSE
                    (Stamp''neverDistinct-2 xStamp, yStamp)  TriState/TRUE
                    :else                                    TriState/UNKNOWN
                )
            )
        )
    )
)

;;;
 ; Common super-class for "a < b" comparisons both signed and unsigned.
 ;;
(class-ns IntegerLowerThanNode [CompareNode, BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable]
    (defn #_"IntegerLowerThanNode" IntegerLowerThanNode'new-3 [#_"ValueNode" x, #_"ValueNode" y, #_"LowerOp" op]
        (merge (IntegerLowerThanNode'class.) (CompareNode'new-3 (LowerOp'''getCondition-1 op), x, y)
            (hash-map
                #_"LowerOp" :op op
            )
        )
    )

    (defn- #_"Stamp" IntegerLowerThanNode''getSucceedingStampForX-5 [#_"IntegerLowerThanNode" this, #_"boolean" mirror?, #_"boolean" strict?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (satisfies? IntegerStamp xStamp) (satisfies? IntegerStamp yStamp))
            (LowerOp''getSucceedingStampForX-5 (:op this), xStamp, yStamp, mirror?, strict?)
        )
    )

    (defn- #_"Stamp" IntegerLowerThanNode''getSucceedingStampForX-7 [#_"IntegerLowerThanNode" this, #_"boolean" mirror?, #_"boolean" strict?, #_"Stamp" xStamp, #_"Stamp" yStamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"Stamp" s (IntegerLowerThanNode''getSucceedingStampForX-5 this, mirror?, strict?, xStamp, yStamp)
            s (if (and (some? s) (Stamp'''isUnrestricted-1 s)) nil s)
        ]
            (when (and (satisfies? AddNode forY) (satisfies? IntegerStamp xStamp)) => s
                (let [
                    #_"IntegerStamp" aStamp
                        (cond
                            (and (= (:x forY) forX) (satisfies? IntegerStamp (:stamp (:y forY)))) (:stamp (:y forY)) ;; x < x + a
                            (and (= (:y forY) forX) (satisfies? IntegerStamp (:stamp (:x forY)))) (:stamp (:x forY)) ;; x < a + x
                        )
                ]
                    (when (some? aStamp) => s
                        (let [
                            aStamp (Stamp''tryImproveWith-2 xStamp, (LowerOp''getSucceedingStampForXLowerXPlusA-4 (:op this), mirror?, strict?, aStamp))
                        ]
                            (when (some? aStamp) => s
                                (when (some? s) => aStamp
                                    (Stamp'''improveWith-2 s, aStamp)
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defm IntegerLowerThanNode BinaryOpLogicNode
        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForX-4 [#_"IntegerLowerThanNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (IntegerLowerThanNode''getSucceedingStampForX-7 this, negated?, (not negated?), xStamp, yStamp, (:x this), (:y this))
        )

        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForY-4 [#_"IntegerLowerThanNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (IntegerLowerThanNode''getSucceedingStampForX-7 this, (not negated?), (not negated?), yStamp, xStamp, (:y this), (:x this))
        )

        (#_"TriState" BinaryOpLogicNode'''tryFold-3 [#_"IntegerLowerThanNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (LowerOp''tryFold-3 (:op this), xStamp, yStamp)
        )
    )
)

(class-ns IntegerBelowNode [IntegerLowerThanNode, CompareNode, BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable]
    (def- #_"BelowOp" IntegerBelowNode'OP (ยง soon BelowOp'new-0))

    (defn #_"IntegerBelowNode" IntegerBelowNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (IntegerBelowNode'class.) (IntegerLowerThanNode'new-3 x, y, IntegerBelowNode'OP))
    )

    (defn #_"LogicNode" IntegerBelowNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (LowerOp'''create-3 IntegerBelowNode'OP, x, y)
    )

    (defn #_"LogicNode" IntegerBelowNode'create-3 [#_"Integer" smallestCompareWidth, #_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp'''canonical-5 IntegerBelowNode'OP, smallestCompareWidth, (LowerOp'''getCondition-1 IntegerBelowNode'OP), x, y)
            (IntegerBelowNode'create-2 x, y)
        )
    )

    (defm IntegerBelowNode Binary
        (#_"Node" Binary'''canonical-4 [#_"IntegerBelowNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareOp'''canonical-5 IntegerBelowNode'OP, (CanonicalizerTool'''smallestCompareWidth-1 tool), (LowerOp'''getCondition-1 IntegerBelowNode'OP), forX, forY)
                this
            )
        )
    )
)

(class-ns IntegerLessThanNode [IntegerLowerThanNode, CompareNode, BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable]
    (def #_"LessThanOp" IntegerLessThanNode'OP (ยง soon LessThanOp'new-0))

    (defn #_"IntegerLessThanNode" IntegerLessThanNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (IntegerLessThanNode'class.) (IntegerLowerThanNode'new-3 x, y, IntegerLessThanNode'OP))
    )

    (defn #_"LogicNode" IntegerLessThanNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (LowerOp'''create-3 IntegerLessThanNode'OP, x, y)
    )

    (defn #_"LogicNode" IntegerLessThanNode'create-3 [#_"Integer" smallestCompareWidth, #_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp'''canonical-5 IntegerLessThanNode'OP, smallestCompareWidth, (LowerOp'''getCondition-1 IntegerLessThanNode'OP), x, y)
            (IntegerLessThanNode'create-2 x, y)
        )
    )

    (defm IntegerLessThanNode Binary
        (#_"Node" Binary'''canonical-4 [#_"IntegerLessThanNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareOp'''canonical-5 IntegerLessThanNode'OP, (CanonicalizerTool'''smallestCompareWidth-1 tool), (LowerOp'''getCondition-1 IntegerLessThanNode'OP), forX, forY)
                this
            )
        )
    )

    (defn #_"boolean" IntegerLessThanNode'subtractMayUnderflow-3 [#_"long" x, #_"long" y, #_"long" minValue]
        (let [
            #_"long" z (- x y)
        ]
            ;; HD 2-12 Overflow iff the arguments have different signs and
            ;; the sign of the result is different than the sign of x
            (or (neg? (& (bit-xor x y) (bit-xor x z))) (<= z minValue))
        )
    )

    (defn #_"boolean" IntegerLessThanNode'subtractMayOverflow-3 [#_"long" x, #_"long" y, #_"long" maxValue]
        (let [
            #_"long" z (- x y)
        ]
            ;; HD 2-12 Overflow iff the arguments have different signs and
            ;; the sign of the result is different than the sign of x
            (or (neg? (& (bit-xor x y) (bit-xor x z))) (< maxValue z))
        )
    )
)

(class-ns PointerEqualsNode [CompareNode, BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable, BinaryCommutative]
    (def- #_"PointerEqualsOp" PointerEqualsNode'OP (ยง soon PointerEqualsOp'new-0))

    (defn #_"PointerEqualsNode" PointerEqualsNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (PointerEqualsNode'class.) (CompareNode'new-3 CanonicalCondition'EQ, x, y))
    )

    (defn #_"LogicNode" PointerEqualsNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (PointerEqualsNode'findSynonym-2 x, y) (PointerEqualsNode'new-2 x, y))
    )

    (defm PointerEqualsNode Binary
        (#_"Node" Binary'''canonical-4 [#_"PointerEqualsNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareOp'''canonical-5 PointerEqualsNode'OP, (CanonicalizerTool'''smallestCompareWidth-1 tool), CanonicalCondition'EQ, forX, forY)
                this
            )
        )
    )

    (defn #_"LogicNode" PointerEqualsNode'findSynonym-2 [#_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1n forX) (GraphUtil'unproxify-1n forY)) (LogicConstantNode'tautology-0)
            (Stamp'''alwaysDistinct-2 (:stamp forX), (:stamp forY))        (LogicConstantNode'contradiction-0)
            (:always-nil? (:stamp forX))                                  (IsNullNode'create-1 forY)
            (:always-nil? (:stamp forY))                                  (IsNullNode'create-1 forX)
        )
    )

    (defm PointerEqualsNode BinaryOpLogicNode
        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForX-4 [#_"PointerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when-not negated?
                (let [
                    #_"Stamp" newStamp (Stamp'''join-2 xStamp, yStamp)
                ]
                    (when-not (= newStamp xStamp)
                        newStamp
                    )
                )
            )
        )

        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForY-4 [#_"PointerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when-not negated?
                (let [
                    #_"Stamp" newStamp (Stamp'''join-2 yStamp, xStamp)
                ]
                    (when-not (= newStamp yStamp)
                        newStamp
                    )
                )
            )
        )

        (#_"TriState" BinaryOpLogicNode'''tryFold-3 [#_"PointerEqualsNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when (and (satisfies? ObjectStamp xStamp) (satisfies? ObjectStamp yStamp)) => TriState/UNKNOWN
                (cond
                    (Stamp'''alwaysDistinct-2 xStamp, yStamp) TriState/FALSE
                    (Stamp''neverDistinct-2 xStamp, yStamp)  TriState/TRUE
                    :else                                    TriState/UNKNOWN
                )
            )
        )
    )
)

(class-ns ObjectEqualsNode [PointerEqualsNode, CompareNode, BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable, BinaryCommutative, Virtualizable]
    (def- #_"ObjectEqualsOp" ObjectEqualsNode'OP (ยง soon ObjectEqualsOp'new-0))

    (defn #_"ObjectEqualsNode" ObjectEqualsNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (ObjectEqualsNode'class.) (PointerEqualsNode'new-2 x, y))
    )

    (defn #_"LogicNode" ObjectEqualsNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (CompareNode'tryConstantFold-3 CanonicalCondition'EQ, x, y)
            (PointerEqualsNode'findSynonym-2 x, y)
            (ObjectEqualsNode'new-2 x, y)
        )
    )

    (defn #_"LogicNode" ObjectEqualsNode'createCanonical-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp'''canonical-5 ObjectEqualsNode'OP, nil, CanonicalCondition'EQ, x, y)
            (ObjectEqualsNode'create-2 x, y)
        )
    )

    (defm ObjectEqualsNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"ObjectEqualsNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (or (CompareOp'''canonical-5 ObjectEqualsNode'OP, (CanonicalizerTool'''smallestCompareWidth-1 tool), CanonicalCondition'EQ, forX, forY)
                this
            )
        )
    )

    (defn- #_"void" ObjectEqualsNode''virtualizeNonVirtualComparison-4 [#_"ObjectEqualsNode" this, #_"VirtualObjectNode" virtual, #_"ValueNode" other, #_"VirtualizerTool" tool]
        (when (and (satisfies? VirtualBoxingNode virtual) (satisfies? ConstantNode other) (= (:boxingKind virtual) JavaKind/Boolean))
            (let [
                #_"JavaConstant" otherUnboxed (#_"ConstantReflectionProvider" .unboxPrimitive HotSpot'constantReflection, (ValueNode''asJavaConstant-1 other))
            ]
                (if (and (some? otherUnboxed) (= (#_"JavaConstant" .getJavaKind otherUnboxed) JavaKind/Boolean))
                    (let [
                        #_"int" expectedValue (if (#_"JavaConstant" .asBoolean otherUnboxed) 1 0)
                        #_"IntegerEqualsNode" equals (IntegerEqualsNode'new-2 (VirtualBoxingNode''getBoxedValue-2 virtual, tool), (ConstantNode'forInt-2 expectedValue, (:graph this)))
                    ]
                        (VirtualizerTool'''addNode-2 tool, equals)
                        (VirtualizerTool'''replaceWithValue-2 tool, equals)
                    )
                    (VirtualizerTool'''replaceWithValue-2 tool, (LogicConstantNode'contradiction-1 (:graph this)))
                )
            )
        )
        (when (:hasIdentity virtual)
            ;; one of them is virtual: they can never be the same objects
            (VirtualizerTool'''replaceWithValue-2 tool, (LogicConstantNode'contradiction-1 (:graph this)))
        )
        nil
    )

    (defm ObjectEqualsNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"ObjectEqualsNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" xAlias (VirtualizerTool'''getAlias-2 tool, (:x this))
                #_"ValueNode" yAlias (VirtualizerTool'''getAlias-2 tool, (:y this))
                #_"VirtualObjectNode" xVirtual (when (satisfies? VirtualObjectNode xAlias) xAlias)
                #_"VirtualObjectNode" yVirtual (when (satisfies? VirtualObjectNode yAlias) yAlias)
            ]
                (cond
                    (and (some? xVirtual) (nil? yVirtual))
                        (ObjectEqualsNode''virtualizeNonVirtualComparison-4 this, xVirtual, yAlias, tool)
                    (and (nil? xVirtual) (some? yVirtual))
                        (ObjectEqualsNode''virtualizeNonVirtualComparison-4 this, yVirtual, xAlias, tool)
                    (and (some? xVirtual) (some? yVirtual))
                        (cond
                            (bit-xor (:hasIdentity xVirtual) (:hasIdentity yVirtual))
                                ;; One of the two objects has identity, the other doesn't. In code, this looks like
                                ;; "Integer.valueOf(a) == new Integer(b)", which is always false.
                                ;;
                                ;; In other words: an object created via valueOf can never be equal to one created
                                ;; by new in the same compilation unit.
                                (VirtualizerTool'''replaceWithValue-2 tool, (LogicConstantNode'contradiction-1 (:graph this)))
                            (and (not (:hasIdentity xVirtual)) (not (:hasIdentity yVirtual)))
                                (let [
                                    #_"ResolvedJavaType" type (VirtualObjectNode'''type-1 xVirtual)
                                ]
                                    (when (and (= type (VirtualObjectNode'''type-1 yVirtual)) (any = type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Integer) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Long)))
                                        ;; both are virtual without identity: check contents
                                        (let [
                                            #_"IntegerEqualsNode" equals (IntegerEqualsNode'new-2 (VirtualizerTool'''getEntry-3 tool, xVirtual, 0), (VirtualizerTool'''getEntry-3 tool, yVirtual, 0))
                                        ]
                                            (VirtualizerTool'''addNode-2 tool, equals)
                                            (VirtualizerTool'''replaceWithValue-2 tool, equals)
                                        )
                                    )
                                )
                            :else
                                ;; both are virtual with identity: check if they refer to the same object
                                (VirtualizerTool'''replaceWithValue-2 tool, (LogicConstantNode'forBoolean-2 (= xVirtual yVirtual), (:graph this)))
                        )
                )
            )
            nil
        )
    )
)

;;;
 ; The InstanceOfDynamicNode represents a type check where the type being checked is not
 ; known at compile time. This is used, for instance, to intrinsify Class#isInstance(Object).
 ;;
(class-ns InstanceOfDynamicNode [BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable, Lowerable]
    (defn #_"InstanceOfDynamicNode" InstanceOfDynamicNode'new-4 [#_"ValueNode" mirror, #_"ValueNode" object, #_"boolean" allow-nil?, #_"boolean" exact?]
        (merge (InstanceOfDynamicNode'class.) (BinaryOpLogicNode'new-2 mirror, object)
            (hash-map
                #_"boolean" :allow-nil? allow-nil?
                #_"boolean" :exact? exact?
            )
        )
    )

    (defn- #_"LogicNode" InstanceOfDynamicNode'findSynonym-4 [#_"ValueNode" forMirror, #_"ValueNode" forObject, #_"boolean" allow-nil?, #_"boolean" exact?]
        (when (satisfies? ConstantNode forMirror)
            (let [
                #_"ResolvedJavaType" t (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value forMirror))
            ]
                (when (some? t)
                    (if (#_"ResolvedJavaType" .isPrimitive t)
                        (if allow-nil?
                            (IsNullNode'create-1 forObject)
                            (LogicConstantNode'contradiction-0)
                        )
                        (let [
                            #_"TypeReference" type (if exact? (TypeReference'createExactTrusted-1 t) (TypeReference'createTrusted-1 t))
                        ]
                            (if allow-nil?
                                (InstanceOfNode'createAllowNull-2 type, forObject)
                                (InstanceOfNode'create-2 type, forObject)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"LogicNode" InstanceOfDynamicNode'create-4 [#_"ValueNode" mirror, #_"ValueNode" object, #_"boolean" allow-nil?, #_"boolean" exact?]
        (or (InstanceOfDynamicNode'findSynonym-4 mirror, object, allow-nil?, exact?)
            (InstanceOfDynamicNode'new-4 mirror, object, allow-nil?, exact?)
        )
    )

    (defn #_"LogicNode" InstanceOfDynamicNode'create-3 [#_"ValueNode" mirror, #_"ValueNode" object, #_"boolean" allow-nil?]
        (InstanceOfDynamicNode'create-4 mirror, object, allow-nil?, false)
    )

    (defn #_"boolean" InstanceOfDynamicNode''isMirror-1 [#_"InstanceOfDynamicNode" this]
        (= (ValueNode''getStackKind-1 (:x this)) JavaKind/Object)
    )

    #_unused
    (defn #_"boolean" InstanceOfDynamicNode''isHub-1 [#_"InstanceOfDynamicNode" this]
        (not (InstanceOfDynamicNode''isMirror-1 this))
    )

    (defm InstanceOfDynamicNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"InstanceOfDynamicNode" this, #_"LoweringTool" lowerer]
            (if (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph this)))
                (InstanceOfSnippetsTemplates''lower-3 Lowerer'instanceofSnippets, this, lowerer)
                (do
                    (when (= (Stamp'''getStackKind-1 (:stamp (:x this))) JavaKind/Object)
                        (ยง ass! this (InstanceOfDynamicNode''setMirror-2 this, (Graph''add-2 (:graph this), (ClassGetHubNode'new-1 (:x this)))))
                    )
                    (when (:allow-nil? this)
                        (let [
                            #_"LogicNode" newTypeCheck (Graph''addOrUniqueWithInputs-2 (:graph this), (InstanceOfDynamicNode'create-3 (:x this), (:y this), false))
                            #_"LogicNode" newNode (LogicNode'or-3 (Graph''add-2 (:graph this), (IsNullNode'create-1 (:y this))), newTypeCheck, GraalDirectives'UNLIKELY_PROBABILITY)
                        ]
                            (ยง ass! this (Node''replaceAndDelete-2 this, newNode))
                        )
                    )
                )
            )
            nil
        )
    )

    (defm InstanceOfDynamicNode Binary
        (#_"LogicNode" Binary'''canonical-4 [#_"InstanceOfDynamicNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forMirror, #_"ValueNode" forObject]
            (or (InstanceOfDynamicNode'findSynonym-4 forMirror, forObject, (:allow-nil? this), (:exact? this))
                this
            )
        )
    )

    (defn #_"InstanceOfDynamicNode" InstanceOfDynamicNode''setMirror-2 [#_"InstanceOfDynamicNode" this, #_"ValueNode" newObject]
        (Node''updateUsages-3 this, (:x this), newObject)
        (assoc this :x newObject)
    )

    (defm InstanceOfDynamicNode BinaryOpLogicNode
        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForX-4 [#_"InstanceOfDynamicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            nil
        )

        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForY-4 [#_"InstanceOfDynamicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            nil
        )

        (#_"TriState" BinaryOpLogicNode'''tryFold-3 [#_"InstanceOfDynamicNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
            TriState/UNKNOWN
        )
    )
)

;;;
 ; This node will perform a "test" operation on its arguments. Its result is equivalent to the expression
 ; "(x & y) == 0", meaning that it will return true if (and only if) no bit is set in both x and y.
 ;;
(class-ns IntegerTestNode [BinaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Binary #_"<ValueNode>", Canonicalizable, BinaryCommutative]
    (defn #_"IntegerTestNode" IntegerTestNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (merge (IntegerTestNode'class.) (BinaryOpLogicNode'new-2 x, y))
    )

    (defm IntegerTestNode Binary
        (#_"ValueNode" Binary'''canonical-4 [#_"IntegerTestNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
            (cond
                (and (satisfies? ConstantNode forX) (satisfies? ConstantNode forY))
                    (LogicConstantNode'forBoolean-1 (zero? (& (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)))))
                (and (satisfies? IntegerStamp (:stamp forX)) (satisfies? IntegerStamp (:stamp forY)))
                    (let [
                        #_"IntegerStamp" xStamp (:stamp forX)
                        #_"IntegerStamp" yStamp (:stamp forY)
                    ]
                        (cond
                            (zero? (& (:upMask xStamp) (:upMask yStamp)))           (LogicConstantNode'tautology-0)
                            (not (zero? (& (:downMask xStamp) (:downMask yStamp)))) (LogicConstantNode'contradiction-0)
                            :else                                                   this
                        )
                    )
                :else
                    this
            )
        )
    )

    (defn- #_"Stamp" IntegerTestNode'getSucceedingStamp-3 [#_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" otherStamp]
        (when (and (satisfies? IntegerStamp xStamp) (satisfies? IntegerStamp otherStamp))
            (if negated?
                (when (= (Long/bitCount (:upMask otherStamp)) 1)
                    (let [
                        #_"long" newDownMask (| (:downMask xStamp) (:upMask otherStamp))
                    ]
                        (when-not (= (:downMask xStamp) newDownMask)
                            (Stamp'''join-2 (IntegerStamp'stampForMask-3 (:bits xStamp), newDownMask, (:upMask xStamp)), xStamp)
                        )
                    )
                )
                (let [
                    #_"long" restrictedUpMask (& (bit-not (:downMask otherStamp)) (:upMask xStamp))
                ]
                    (when-not (= (:upMask xStamp) restrictedUpMask)
                        (Stamp'''join-2 (IntegerStamp'stampForMask-3 (:bits xStamp), (:downMask xStamp), restrictedUpMask), xStamp)
                    )
                )
            )
        )
    )

    (defm IntegerTestNode BinaryOpLogicNode
        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForX-4 [#_"IntegerTestNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (IntegerTestNode'getSucceedingStamp-3 negated?, xStamp, yStamp)
        )

        (#_"Stamp" BinaryOpLogicNode'''getSucceedingStampForY-4 [#_"IntegerTestNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (IntegerTestNode'getSucceedingStamp-3 negated?, yStamp, xStamp)
        )

        (#_"TriState" BinaryOpLogicNode'''tryFold-3 [#_"IntegerTestNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
            (when (and (satisfies? IntegerStamp xStamp) (satisfies? IntegerStamp yStamp)) => TriState/UNKNOWN
                (cond
                    (zero? (& (:upMask xStamp) (:upMask yStamp)))           TriState/TRUE
                    (not (zero? (& (:downMask xStamp) (:downMask yStamp)))) TriState/FALSE
                    :else                                                   TriState/UNKNOWN
                )
            )
        )
    )
)

;;;
 ; The LogicConstantNode represents a boolean constant.
 ;;
(class-ns LogicConstantNode [LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable]
    (defn #_"LogicConstantNode" LogicConstantNode'new-1 [#_"boolean" value]
        (merge (LogicConstantNode'class.) (LogicNode'new-0)
            (hash-map
                #_"boolean" :value value
            )
        )
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param v the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (defn #_"LogicConstantNode" LogicConstantNode'forBoolean-2 [#_"boolean" v, #_"Graph" graph]
        (Graph''add-2 graph, (LogicConstantNode'new-1 v))
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param v the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (defn #_"LogicConstantNode" LogicConstantNode'forBoolean-1 [#_"boolean" v]
        (LogicConstantNode'new-1 v)
    )

    ;;;
     ; Gets a constant for true.
     ;;
    #_unused
    (defn #_"LogicConstantNode" LogicConstantNode'tautology-1 [#_"Graph" graph]
        (LogicConstantNode'forBoolean-2 true, graph)
    )

    ;;;
     ; Gets a constant for false.
     ;;
    (defn #_"LogicConstantNode" LogicConstantNode'contradiction-1 [#_"Graph" graph]
        (LogicConstantNode'forBoolean-2 false, graph)
    )

    ;;;
     ; Gets a constant for true.
     ;;
    (defn #_"LogicConstantNode" LogicConstantNode'tautology-0 []
        (LogicConstantNode'forBoolean-1 true)
    )

    ;;;
     ; Gets a constant for false.
     ;;
    (defn #_"LogicConstantNode" LogicConstantNode'contradiction-0 []
        (LogicConstantNode'forBoolean-1 false)
    )

    (defm LogicConstantNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"LogicConstantNode" this, #_"LIRBuilder" builder]
            ;; nothing to do
            nil
        )
    )
)

;;;
 ; Logic node that negates its argument.
 ;;
(class-ns LogicNegationNode [LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, Unary #_"<LogicNode>", Canonicalizable]
    (defn #_"LogicNegationNode" LogicNegationNode'new-1 [#_"LogicNode" value]
        (merge (LogicNegationNode'class.) (LogicNode'new-0)
            (hash-map
                ; @Input
                #_"LogicNode" :value value
            )
        )
    )

    (defn- #_"LogicNode" LogicNegationNode'findSynonym-1 [#_"LogicNode" value]
        (condp satisfies? value
            LogicConstantNode (LogicConstantNode'forBoolean-1 (not (:value value)))
            LogicNegationNode (Unary'''getValue-1 value)
            nil
        )
    )

    (defn #_"LogicNode" LogicNegationNode'create-1 [#_"LogicNode" value]
        (or (LogicNegationNode'findSynonym-1 value)
            (LogicNegationNode'new-1 value)
        )
    )

    (defm LogicNegationNode Unary
        (#_"LogicNode" Unary'''getValue-1 [#_"LogicNegationNode" this]
            (:value this)
        )

        (#_"LogicNode" Unary'''canonical-3 [#_"LogicNegationNode" this, #_"CanonicalizerTool" tool, #_"LogicNode" value]
            (or (LogicNegationNode'findSynonym-1 value)
                this
            )
        )
    )

    (defm LogicNegationNode Canonicalizable
        (#_"LogicNode" Canonicalizable'''canonical-2 [#_"LogicNegationNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )
)

(class-ns ShortCircuitOrNode [LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, Binary #_"<LogicNode>", Canonicalizable]
    (defn #_"ShortCircuitOrNode" ShortCircuitOrNode'new-5 [#_"LogicNode" x, #_"boolean" xNegated, #_"LogicNode" y, #_"boolean" yNegated, #_"double" shortCircuitProbability]
        (merge (ShortCircuitOrNode'class.) (LogicNode'new-0)
            (hash-map
                ; @Input
                #_"LogicNode" :x x
                ; @Input
                #_"LogicNode" :y y
                #_"boolean" :xNegated xNegated
                #_"boolean" :yNegated yNegated
                ;;;
                 ; The probability that the {@link #getY() y} part of this binary node is <b>not</b> evaluated.
                 ; This is the probability that this operator will short-circuit its execution.
                 ;;
                #_"double" :shortCircuitProbability shortCircuitProbability
            )
        )
    )

    (defn #_"ShortCircuitOrNode" ShortCircuitOrNode''canonicalizeNegation-3 [#_"ShortCircuitOrNode" this, #_"LogicNode" forX, #_"LogicNode" forY]
        (let [
            [#_"LogicNode" xCond #_"boolean" xNeg]
                (loop-when-recur [xCond forX xNeg (:xNegated this)]
                                 (satisfies? LogicNegationNode xCond)
                                 [(Unary'''getValue-1 xCond) (not xNeg)]
                              => [xCond xNeg]
                )
            [#_"LogicNode" yCond #_"boolean" yNeg]
                (loop-when-recur [yCond forY yNeg (:yNegated this)]
                                 (satisfies? LogicNegationNode yCond)
                                 [(Unary'''getValue-1 yCond) (not yNeg)]
                              => [yCond yNeg]
                )
        ]
            (when-not (and (= xCond forX) (= yCond forY)) => this
                (ShortCircuitOrNode'new-5 xCond, xNeg, yCond, yNeg, (:shortCircuitProbability this))
            )
        )
    )

    (defn- #_"LogicNode" ShortCircuitOrNode'optimizeShortCircuit-4 [#_"ShortCircuitOrNode" inner, #_"boolean" innerNegated, #_"boolean" matchNegated, #_"boolean" matchIsInnerX]
        (let [
            #_"boolean" innerMatchNegated (if matchIsInnerX (:xNegated inner) (:yNegated inner))
        ]
            (if (not innerNegated)
                ;; The four digit results of the expression used in the 16 subsequent formula
                ;; comments correspond to results when using the following truth table for
                ;; inputs a and b and testing all 4 possible input combinations:
                ;; _ 1234
                ;; a 1100
                ;; b 1010
                (if (= innerMatchNegated matchNegated)
                    ;; ( (!a ||!b) ||!a) => 0111 (!a ||!b)
                    ;; ( (!a || b) ||!a) => 1011 (!a || b)
                    ;; ( ( a ||!b) || a) => 1101 ( a ||!b)
                    ;; ( ( a || b) || a) => 1110 ( a || b)
                    ;; Only the inner or is relevant, the outer or never adds information.
                    inner
                    ;; ( ( a || b) ||!a) => 1111 (true)
                    ;; ( (!a ||!b) || a) => 1111 (true)
                    ;; ( (!a || b) || a) => 1111 (true)
                    ;; ( ( a ||!b) ||!a) => 1111 (true)
                    ;; The result of the expression is always true.
                    (LogicConstantNode'tautology-0)
                )
                (if (= innerMatchNegated matchNegated)
                    ;; (!(!a ||!b) ||!a) => 1011 (!a || b)
                    ;; (!(!a || b) ||!a) => 0111 (!a ||!b)
                    ;; (!( a ||!b) || a) => 1110 ( a || b)
                    ;; (!( a || b) || a) => 1101 ( a ||!b)
                    (let [
                        #_"boolean" newInnerXNegated (:xNegated inner)
                        #_"boolean" newInnerYNegated (:yNegated inner)
                        #_"double" newProbability (:shortCircuitProbability inner)
                        [newInnerXNegated newInnerYNegated newProbability]
                            (if matchIsInnerX
                                [newInnerXNegated (not newInnerYNegated) newProbability]
                                [(not newInnerXNegated) newInnerYNegated (- 1.0 newProbability)]
                            )
                    ]
                        ;; The expression can be transformed into a single or.
                        (ShortCircuitOrNode'new-5 (:x inner), newInnerXNegated, (:y inner), newInnerYNegated, newProbability)
                    )
                    ;; (!(!a ||!b) || a) => 1100 (a)
                    ;; (!(!a || b) || a) => 1100 (a)
                    ;; (!( a ||!b) ||!a) => 0011 (!a)
                    ;; (!( a || b) ||!a) => 0011 (!a)
                    (let [
                        #_"LogicNode" result (if matchIsInnerX (:x inner) (:y inner))
                    ]
                        ;; Only the second part of the outer or is relevant.
                        (if matchNegated (LogicNegationNode'create-1 result) result)
                    )
                )
            )
        )
    )

    (defn- #_"ValueNode" ShortCircuitOrNode'skipThroughPisAndProxies-1 [#_"ValueNode" node]
        (loop [node node]
            (condp satisfies? node
                PiNode     (recur (Proxy'''getOriginalNode-1 node))
                ValueProxy (recur (Proxy'''getOriginalNode-1 node))
                node
            )
        )
    )

    (defm ShortCircuitOrNode Binary
        (#_"LogicNode" Binary'''canonical-4 [#_"ShortCircuitOrNode" this, #_"CanonicalizerTool" tool, #_"LogicNode" forX, #_"LogicNode" forY]
            (let [
                #_"ShortCircuitOrNode" canon (ShortCircuitOrNode''canonicalizeNegation-3 this, forX, forY)
            ]
                (when (= canon this) => canon
                    (cond
                        (= forX forY)
                            ;;  a ||  a = a
                            ;;  a || !a = true
                            ;; !a ||  a = true
                            ;; !a || !a = !a
                            (if (:xNegated this)
                                (if (:yNegated this) (LogicNegationNode'create-1 forX) (LogicConstantNode'tautology-0))
                                (if (:yNegated this) (LogicConstantNode'tautology-0) forX)
                            )
                        (satisfies? LogicConstantNode forX)
                            (if (bit-xor (:value forX) (:xNegated this))
                                (LogicConstantNode'tautology-0)
                                (if (:yNegated this) (LogicNegationNode'new-1 forY) forY)
                            )
                        (satisfies? LogicConstantNode forY)
                            (if (bit-xor (:value forY) (:yNegated this))
                                (LogicConstantNode'tautology-0)
                                (if (:xNegated this) (LogicNegationNode'new-1 forX) forX)
                            )
                        :else
                        (do
                            (cond
                                (satisfies? ShortCircuitOrNode forX)
                                    (cond
                                        (= forY (:x forX))
                                            (ยง return (ShortCircuitOrNode'optimizeShortCircuit-4 forX, (:xNegated this), (:yNegated this), true))
                                        (= forY (:y forX))
                                            (ยง return (ShortCircuitOrNode'optimizeShortCircuit-4 forX, (:xNegated this), (:yNegated this), false))
                                    )
                                (satisfies? ShortCircuitOrNode forY)
                                    (cond
                                        (= (:x forY) forX)
                                            (ยง return (ShortCircuitOrNode'optimizeShortCircuit-4 forY, (:yNegated this), (:xNegated this), true))
                                        (= (:y forY) forX)
                                            (ยง return (ShortCircuitOrNode'optimizeShortCircuit-4 forY, (:yNegated this), (:xNegated this), false))
                                    )
                            )

                            ;; check whether !X => Y constant
                            (when (and (satisfies? UnaryOpLogicNode forX) (satisfies? UnaryOpLogicNode forY) (= (ShortCircuitOrNode'skipThroughPisAndProxies-1 (Unary'''getValue-1 forX)) (ShortCircuitOrNode'skipThroughPisAndProxies-1 (Unary'''getValue-1 forY)))) => this
                                (let [
                                    #_"TriState" fold (UnaryOpLogicNode'''tryFold-2 forY, (UnaryOpLogicNode'''getSucceedingStampForValue-2 forX, (not (:xNegated this))))
                                ]
                                    (when (#_"TriState" .isKnown fold) => this
                                        (cond
                                            (bit-xor (#_"TriState" .toBoolean fold) (:yNegated this)) (LogicConstantNode'tautology-0)
                                            (:xNegated this)                                          (LogicNegationNode'create-1 forX)
                                            :else                                                     forX
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defm ShortCircuitOrNode Canonicalizable
        (#_"LogicNode" Canonicalizable'''canonical-2 [#_"ShortCircuitOrNode" this, #_"CanonicalizerTool" tool]
            (Binary'''canonical-4 this, tool, (:x this), (:y this))
        )
    )
)

(class-ns UnaryOpLogicNode [LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Unary #_"<ValueNode>", Canonicalizable]
    (defm UnaryOpLogicNode Unary
        (#_"ValueNode" Unary'''getValue-1 [#_"UnaryOpLogicNode" this]
            (:value this)
        )
    )

    (defn #_"UnaryOpLogicNode" UnaryOpLogicNode'new-1 [#_"ValueNode" value]
        (merge (UnaryOpLogicNode'class.) (LogicNode'new-0)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
            )
        )
    )

    (defm UnaryOpLogicNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"UnaryOpLogicNode" this, #_"LIRBuilder" builder]
            nil
        )
    )

    #_unused
    (defn #_"Stamp" UnaryOpLogicNode''getSucceedingStampForValue-3 [#_"UnaryOpLogicNode" this, #_"boolean" negated?, #_"Stamp" valueStamp]
        (let [
            #_"Stamp" succStamp (UnaryOpLogicNode'''getSucceedingStampForValue-2 this, negated?)
        ]
            (when (some? succStamp)
                (Stamp'''join-2 succStamp, valueStamp)
            )
        )
    )

    (defm UnaryOpLogicNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"UnaryOpLogicNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )
)

;;;
 ; The InstanceOfNode represents an instanceof test.
 ;;
(class-ns InstanceOfNode [UnaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Unary #_"<ValueNode>", Canonicalizable, Lowerable, Virtualizable]
    (defn #_"InstanceOfNode" InstanceOfNode'new-3 [#_"ObjectStamp" checkedStamp, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (merge (InstanceOfNode'class.) (UnaryOpLogicNode'new-1 object)
            (hash-map
                #_"ObjectStamp" :checkedStamp checkedStamp
                ; @OptionalInput(InputType'Anchor)
                #_"AnchoringNode" :anchor anchor
            )
        )
    )

    (defn #_"LogicNode" InstanceOfNode'createAllowNull-2 [#_"TypeReference" type, #_"ValueNode" object]
        (if (StampTool'isPointerNeverNull-1 (:stamp object))
            (InstanceOfNode'create-2 type, object)
            (InstanceOfNode'createHelper-3 (StampFactory'object-1 type), object, nil)
        )
    )

    (defn #_"LogicNode" InstanceOfNode'create-2 [#_"TypeReference" type, #_"ValueNode" object]
        (InstanceOfNode'create-3 type, object, nil)
    )

    (defn #_"LogicNode" InstanceOfNode'create-3 [#_"TypeReference" type, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (InstanceOfNode'createHelper-3 (StampFactory'objectNonNull-1 type), object, anchor)
    )

    (defn #_"LogicNode" InstanceOfNode'createHelper-3 [#_"ObjectStamp" checkedStamp, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (or (InstanceOfNode'findSynonym-2 checkedStamp, object) (InstanceOfNode'new-3 checkedStamp, object, anchor))
    )

    (defm InstanceOfNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"InstanceOfNode" this, #_"LoweringTool" lowerer]
            (if (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph this)))
                (InstanceOfSnippetsTemplates''lower-3 Lowerer'instanceofSnippets, this, lowerer)
                (when (InstanceOfNode''allowsNull-1 this)
                    (let [
                        #_"ValueNode" object (Unary'''getValue-1 this)
                        #_"LogicNode" newTypeCheck (Graph''addOrUniqueWithInputs-2 (:graph this), (InstanceOfNode'create-3 (InstanceOfNode''type-1 this), object, (:anchor this)))
                        #_"LogicNode" newNode (LogicNode'or-3 (Graph''add-2 (:graph this), (IsNullNode'create-1 object)), newTypeCheck, GraalDirectives'UNLIKELY_PROBABILITY)
                    ]
                        (ยง ass! this (Node''replaceAndDelete-2 this, newNode))
                    )
                )
            )
            nil
        )
    )

    (defm InstanceOfNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"InstanceOfNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (InstanceOfNode'findSynonym-2 (:checkedStamp this), value)
                this
            )
        )
    )

    (defn #_"LogicNode" InstanceOfNode'findSynonym-2 [#_"ObjectStamp" checkedStamp, #_"ValueNode" object]
        (let [
            #_"ObjectStamp" inputStamp (:stamp object)
        ]
            (if (Stamp''isEmpty-1 (Stamp'''join-2 checkedStamp, inputStamp))
                ;; The check can never succeed, the intersection of the two stamps is empty.
                (LogicConstantNode'contradiction-0)
                (let [
                    #_"ObjectStamp" meetStamp (Stamp'''meet-2 checkedStamp, inputStamp)
                ]
                    (cond
                        ;; The check will always succeed, the union of the two stamps is equal to the checked stamp.
                        (= checkedStamp meetStamp)  (LogicConstantNode'tautology-0)
                        (:always-nil? checkedStamp) (IsNullNode'create-1 object)
                        (and (= (:type checkedStamp) (:type meetStamp))
                             (= (AbstractObjectStamp''isExactType-1 checkedStamp) (AbstractObjectStamp''isExactType-1 meetStamp))
                             (= (:always-nil? checkedStamp) (:always-nil? meetStamp))
                        )
                            ;; The only difference makes the nil-ness of the value => simplify the check.
                            (if (:never-nil? checkedStamp)
                                (LogicNegationNode'create-1 (IsNullNode'create-1 object))
                                (IsNullNode'create-1 object)
                            )
                    )
                )
            )
        )
    )

    ;;;
     ; Gets the type being tested.
     ;;
    (defn #_"TypeReference" InstanceOfNode''type-1 [#_"InstanceOfNode" this]
        (StampTool'typeReferenceOrNull-1 (:checkedStamp this))
    )

    (defm InstanceOfNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"InstanceOfNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"TriState" fold (UnaryOpLogicNode'''tryFold-2 this, (:stamp (VirtualizerTool'''getAlias-2 tool, (Unary'''getValue-1 this))))
            ]
                (when-not (= fold TriState/UNKNOWN)
                    (VirtualizerTool'''replaceWithValue-2 tool, (LogicConstantNode'forBoolean-2 (#_"TriState" .isTrue fold), (:graph this)))
                )
            )
            nil
        )
    )

    (defm InstanceOfNode UnaryOpLogicNode
        (#_"Stamp" UnaryOpLogicNode'''getSucceedingStampForValue-2 [#_"InstanceOfNode" this, #_"boolean" negated?]
            (when-not negated? (:checkedStamp this))
        )

        (#_"TriState" UnaryOpLogicNode'''tryFold-2 [#_"InstanceOfNode" this, #_"Stamp" stamp]
            (when (satisfies? ObjectStamp stamp) => TriState/UNKNOWN
                (cond
                    ;; The check can never succeed, the intersection of the two stamps is empty.
                    (Stamp''isEmpty-1 (Stamp'''join-2 (:checkedStamp this), stamp))       TriState/FALSE
                    ;; The check will always succeed, the union of the two stamps is equal to the checked stamp.
                    (= (:checkedStamp this) (Stamp'''meet-2 (:checkedStamp this), stamp)) TriState/TRUE
                    :else                                                                TriState/UNKNOWN
                )
            )
        )
    )

    (defn #_"boolean" InstanceOfNode''allowsNull-1 [#_"InstanceOfNode" this]
        (not (:never-nil? (:checkedStamp this)))
    )
)

;;;
 ; An IsNullNode will be true if the supplied value is nil, and false if it is non-nil.
 ;;
(class-ns IsNullNode [UnaryOpLogicNode, LogicNode, FloatingNode, ValueNode, Node, IndirectCanonicalization, LIRLowerable, Unary #_"<ValueNode>", Canonicalizable, Virtualizable]
    (defn #_"IsNullNode" IsNullNode'new-1 [#_"ValueNode" object]
        (merge (IsNullNode'class.) (UnaryOpLogicNode'new-1 object))
    )

    (defn- #_"LogicNode" IsNullNode'canonicalized-2 [#_"IsNullNode" self, #_"ValueNode" value]
        (or (IsNullNode'tryCanonicalize-1 value)
            (cond
                (satisfies? PiNode value)                                                               (IsNullNode'create-1 (GraphUtil'skipPi-1 value))
                (and (satisfies? ConvertNode value) (ConvertNode'''mayNullCheckSkipConversion-1 value)) (IsNullNode'create-1 (ConvertNode'''getValue-1 value))
                :else                                                                                   (or self (IsNullNode'new-1 (GraphUtil'skipPi-1 value)))
            )
        )
    )

    (defn #_"LogicNode" IsNullNode'create-1 [#_"ValueNode" value]
        (IsNullNode'canonicalized-2 nil, value)
    )

    (defn #_"LogicNode" IsNullNode'tryCanonicalize-1 [#_"ValueNode" value]
        (cond
            (StampTool'isPointerAlwaysNull-1 (:stamp value)) (LogicConstantNode'tautology-0)
            (StampTool'isPointerNeverNull-1 (:stamp value))  (LogicConstantNode'contradiction-0)
        )
    )

    (defm IsNullNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"IsNullNode" this, #_"LIRBuilder" builder]
            ;; Nothing to do.
            nil
        )
    )

    (defm IsNullNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"IsNullNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (IsNullNode'canonicalized-2 this, value)
        )
    )

    (defm IsNullNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"IsNullNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"TriState" fold (UnaryOpLogicNode'''tryFold-2 this, (:stamp (VirtualizerTool'''getAlias-2 tool, (Unary'''getValue-1 this))))
            ]
                (when-not (= fold TriState/UNKNOWN)
                    (VirtualizerTool'''replaceWithValue-2 tool, (LogicConstantNode'forBoolean-2 (#_"TriState" .isTrue fold), (:graph this)))
                )
            )
            nil
        )
    )

    (defm IsNullNode UnaryOpLogicNode
        (#_"Stamp" UnaryOpLogicNode'''getSucceedingStampForValue-2 [#_"IsNullNode" this, #_"boolean" negated?]
            ;; ignore any more precise input stamp, since canonicalization will skip through PiNodes
            (let [
                #_"AbstractPointerStamp" stamp (Stamp'''unrestricted-1 (:stamp (Unary'''getValue-1 this)))
            ]
                (if negated? (AbstractPointerStamp''asNonNull-1 stamp) (AbstractPointerStamp''asAlwaysNull-1 stamp))
            )
        )

        (#_"TriState" UnaryOpLogicNode'''tryFold-2 [#_"IsNullNode" this, #_"Stamp" stamp]
            (when (satisfies? ObjectStamp stamp) => TriState/UNKNOWN
                (cond
                    (:always-nil? stamp) TriState/TRUE
                    (:never-nil? stamp)  TriState/FALSE
                    :else                TriState/UNKNOWN
                )
            )
        )
    )
)

(class-ns MemoryMapNode [FloatingNode, ValueNode, Node, MemoryMap, MemoryNode, LIRLowerable]
    (defn #_"MemoryMapNode" MemoryMapNode'new-1 [#_"EconomicMap<LocationIdentity, MemoryNode>" mmap]
        (let [
            #_"MemoryMapNode" this
                (merge (MemoryMapNode'class.) (FloatingNode'new-1 VoidStamp'instance)
                    (hash-map
                        #_"List<LocationIdentity>" :locationIdentities (ArrayList.)
                        ; @Input(InputType'Memory)
                        #_"NodeInputList<ValueNode>" :nodes nil
                    )
                )
            this (assoc this :nodes (NodeInputList'new-2i this, (count mmap)))
            #_"MapCursor<LocationIdentity, MemoryNode>" cursor (#_"EconomicMap" .getEntries mmap)
            _
                (loop-when-recur [#_"int" i 0] (#_"MapCursor" .advance cursor) [(inc i)]
                    (#_"List" .add (:locationIdentities this), (#_"MapCursor" .getKey cursor))
                    (NodeList''initialize-3 (:nodes this), i, (#_"MapCursor" .getValue cursor))
                )
        ]
            this
        )
    )

    #_unused
    (defn #_"boolean" MemoryMapNode''isEmpty-1 [#_"MemoryMapNode" this]
        (or (empty? (:locationIdentities this))
            (and (= (count (:locationIdentities this)) 1)
                (satisfies? StartNode (nth (:nodes this) 0))
            )
        )
    )

    (defm MemoryMapNode MemoryMap
        (#_"MemoryNode" MemoryMap'''getLastLocationAccess-2 [#_"MemoryMapNode" this, #_"LocationIdentity" location]
            (when-not (:immutable location)
                (let [
                    #_"int" index (#_"List" .indexOf (:locationIdentities this), location)
                    index
                        (when (= index -1) => index
                            (#_"List" .indexOf (:locationIdentities this), LocationIdentity'ANY)
                        )
                ]
                    (nth (:nodes this) index)
                )
            )
        )

        (#_"LocationIdentity*" MemoryMap'''getLocations-1 [#_"MemoryMapNode" this]
            (:locationIdentities this)
        )
    )

    (defm MemoryMapNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"MemoryMapNode" this, #_"LIRBuilder" builder]
            ;; nothing to do...
            nil
        )
    )
)

(class-ns OpaqueNode [FloatingNode, ValueNode, Node, LIRLowerable]
    #_unused
    (defn #_"OpaqueNode" OpaqueNode'new-1 [#_"ValueNode" value]
        (merge (OpaqueNode'class.) (FloatingNode'new-1 (Stamp'''unrestricted-1 (:stamp value)))
            (hash-map
                ; @Input
                #_"ValueNode" :value value
            )
        )
    )

    (defm OpaqueNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"OpaqueNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:value this)))
            nil
        )
    )
)

(class-ns PhiNode [FloatingNode, ValueNode, Node, Canonicalizable]
    (defn #_"PhiNode" PhiNode'new-2 [#_"Stamp" stamp, #_"AbstractMergeNode" merge]
        (merge (PhiNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"AbstractMergeNode" :merge merge
            )
        )
    )

    ;;;
     ; Get the instruction that produces the value associated with the i'th predecessor of the merge.
     ;
     ; @param i the index of the predecessor
     ; @return the instruction that produced the value in the i'th predecessor
     ;;
    (defn #_"ValueNode" PhiNode''valueAt-2i [#_"PhiNode" this, #_"int" i]
        (nth (:values this) i)
    )

    ;;;
     ; Sets the value at the given index and makes sure that the values list is large enough.
     ;
     ; @param i the index at which to set the value
     ; @param x the new phi input value for the given location
     ;;
    (defn #_"void" PhiNode''initializeValueAt-3 [#_"PhiNode" this, #_"int" i, #_"ValueNode" x]
        (while (<= (count (:values this)) i)
            (#_"List" .add (:values this), nil)
        )
        (#_"List" .set (:values this), i, x)
        nil
    )

    (defn #_"void" PhiNode''setValueAt-3i [#_"PhiNode" this, #_"int" i, #_"ValueNode" x]
        (#_"List" .set (:values this), i, x)
        nil
    )

    (defn #_"void" PhiNode''setValueAt-3n [#_"PhiNode" this, #_"AbstractEndNode" end, #_"ValueNode" x]
        (PhiNode''setValueAt-3i this, (AbstractMergeNode'''phiPredecessorIndex-2 (:merge this), end), x)
        nil
    )

    (defn #_"ValueNode" PhiNode''valueAt-2n [#_"PhiNode" this, #_"AbstractEndNode" pred]
        (PhiNode''valueAt-2i this, (AbstractMergeNode'''phiPredecessorIndex-2 (:merge this), pred))
    )

    ;;;
     ; Get the number of inputs to this phi (i.e. the number of predecessors to the merge).
     ;
     ; @return the number of inputs in this phi
     ;;
    (defn #_"int" PhiNode''valueCount-1 [#_"PhiNode" this]
        (count (:values this))
    )

    (defn #_"void" PhiNode''addInput-2 [#_"PhiNode" this, #_"ValueNode" x]
        (#_"List" .add (:values this), x)
        nil
    )

    (defn #_"void" PhiNode''removeInput-2 [#_"PhiNode" this, #_"int" index]
        (#_"List" .remove (:values this), index)
        nil
    )

    ;;;
     ; If all inputs are the same value, this value is returned, otherwise {@code this}.
     ; Note that nil is a valid return value, since GuardPhiNodes can have nil inputs.
     ;;
    (defn #_"ValueNode" PhiNode''singleValueOrThis-1 [#_"PhiNode" this]
        (let [
            #_"ValueNode" singleValue (PhiNode''valueAt-2i this, 0)
        ]
            (loop-when [#_"int" i 1] (< i (PhiNode''valueCount-1 this)) => singleValue
                (recur-if (any = (PhiNode''valueAt-2i this, i) this singleValue) [(inc i)] => this)
            )
        )
    )

    ;;;
     ; If all inputs (but the first one) are the same value, the value is returned, otherwise {@code this}.
     ; Note that nil is a valid return value, since GuardPhiNodes can have nil inputs.
     ;;
    (defn #_"ValueNode" PhiNode''singleBackValueOrThis-1 [#_"PhiNode" this]
        (let [
            ;; Skip first value, assume second value as single value.
            #_"ValueNode" singleValue (PhiNode''valueAt-2i this, 1)
        ]
            (loop-when [#_"int" i 2] (< i (PhiNode''valueCount-1 this)) => singleValue
                (recur-if (= (PhiNode''valueAt-2i this, i) singleValue) [(inc i)] => this)
            )
        )
    )

    (defm PhiNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"PhiNode" this, #_"CanonicalizerTool" tool]
            (when (PhiNode''isLoopPhi-1 this) => (PhiNode''singleValueOrThis-1 this)
                (let [
                    #_"int" n (PhiNode''valueCount-1 this)
                    #_"int" i
                        (loop-when [i 1] (< i n) => i
                            (recur-if (= (PhiNode''valueAt-2i this, i) this) [(inc i)] => i)
                        )
                ]
                    ;; All back edges are self-references => return forward edge input value.
                    (when-not (= i n) => (PhiNode''firstValue-1 this)
                        (let [
                            #_"boolean" onlySelfUsage
                                (loop-when [#_"ISeq" s (seq (:nodeUsages this))] (some? s) => true
                                    (and (= (first s) this)
                                        (recur (next s))
                                    )
                                )
                        ]
                            (when-not onlySelfUsage
                                (PhiNode''singleValueOrThis-1 this)
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"ValueNode" PhiNode''firstValue-1 [#_"PhiNode" this]
        (PhiNode''valueAt-2i this, 0)
    )

    (defn #_"boolean" PhiNode''isLoopPhi-1 [#_"PhiNode" this]
        (satisfies? LoopBeginNode (:merge this))
    )
)

;;;
 ; Guard PhiNodes merge guard dependencies at control flow merges.
 ;;
(class-ns GuardPhiNode [PhiNode, FloatingNode, ValueNode, Node, Canonicalizable, GuardingNode]
    (defn #_"GuardPhiNode" GuardPhiNode'new-1 [#_"AbstractMergeNode" merge]
        (merge (GuardPhiNode'class.) (PhiNode'new-2 VoidStamp'instance, merge)
            (hash-map
                ; @OptionalInput(InputType'Guard)
                #_"NodeInputList<ValueNode>" :values (NodeInputList'new-1 (ร this))
            )
        )
    )
)

;;;
 ; Memory PhiNodes merge memory dependencies at control flow merges.
 ;;
(class-ns MemoryPhiNode [PhiNode, FloatingNode, ValueNode, Node, Canonicalizable, MemoryNode]
    (defn #_"MemoryPhiNode" MemoryPhiNode'new-2 [#_"AbstractMergeNode" merge, #_"LocationIdentity" locationIdentity]
        (merge (MemoryPhiNode'class.) (PhiNode'new-2 VoidStamp'instance, merge)
            (hash-map
                ; @Input(InputType'Memory)
                #_"NodeInputList<ValueNode>" :values (NodeInputList'new-1 (ร this))
                #_"LocationIdentity" :locationIdentity locationIdentity
            )
        )
    )
)

;;;
 ; Value PhiNodes merge data flow values at control flow merges.
 ;;
(class-ns ValuePhiNode [PhiNode, FloatingNode, ValueNode, Node, Canonicalizable, ArrayLengthProvider]
    (defn #_"ValuePhiNode" ValuePhiNode'new-2 [#_"Stamp" stamp, #_"AbstractMergeNode" merge]
        (merge (ValuePhiNode'class.) (PhiNode'new-2 stamp, merge)
            (hash-map
                ; @Input
                #_"NodeInputList<ValueNode>" :values (NodeInputList'new-1 (ร this))
            )
        )
    )

    (defn #_"ValuePhiNode" ValuePhiNode'new-3 [#_"Stamp" stamp, #_"AbstractMergeNode" merge, #_"ValueNode*" values]
        (merge (ValuePhiNode'class.) (PhiNode'new-2 stamp, merge)
            (hash-map
                ; @Input
                #_"NodeInputList<ValueNode>" :values (NodeInputList'new-2s (ร this), values)
            )
        )
    )

    (defm ValuePhiNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"ValuePhiNode" this]
            ;; Meet all the values feeding this Phi but don't use the stamp of this Phi since that's what's being computed.
            (let [
                #_"Stamp" stamp (StampTool'meetOrNull-2 (:values this), this)
                stamp
                    (cond
                        (nil? stamp)                                   (:stamp this)
                        (Stamp'''isCompatible-2s (:stamp this), stamp) (Stamp'''join-2 (:stamp this), stamp)
                        :else                                          stamp
                    )
            ]
                (ValueNode''updateStamp-2 this, stamp)
            )
        )
    )

    (defm ValuePhiNode ArrayLengthProvider
        (#_"ValueNode" ArrayLengthProvider'''length-1 [#_"ValuePhiNode" this]
            (when-not (satisfies? LoopBeginNode (:merge this))
                (loop-when [#_"ValueNode" n nil #_"ISeq" s (seq (:values this))] (some? s) => n
                    (let [
                        #_"ValueNode" l (GraphUtil'arrayLength-1 (first s))
                    ]
                        (when (some? l)
                            (when (some? n) => (recur l (next s))
                                (when (= n l)
                                    (recur n (next s))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; Cast between Word and metaspace pointers exposed by the MetaspaceOpcode#FROM_POINTER
 ; and MetaspaceOpcode#TO_KLASS_POINTER operations.
 ;;
(class-ns PointerCastNode [FloatingNode, ValueNode, Node, LIRLowerable]
    (defn #_"PointerCastNode" PointerCastNode'new-2 [#_"Stamp" stamp, #_"ValueNode" input]
        (merge (PointerCastNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :input input
            )
        )
    )

    (defm PointerCastNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"PointerCastNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:input this)))
            nil
        )
    )
)

;;;
 ; A proxy is inserted at loop exits for any value that is created inside the loop (i.e. was not
 ; live on entry to the loop) and is (potentially) used after the loop.
 ;;
(class-ns ProxyNode [FloatingNode, ValueNode, Node]
    (defn #_"ProxyNode" ProxyNode'new-2 [#_"Stamp" stamp, #_"LoopExitNode" proxyPoint]
        (merge (ProxyNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"LoopExitNode" :loopExit proxyPoint
            )
        )
    )

    (defn #_"ValueProxyNode" ProxyNode'forValue-3 [#_"ValueNode" value, #_"LoopExitNode" exit, #_"Graph" graph]
        (Graph''add-2 graph, (ValueProxyNode'new-2 value, exit))
    )

    (defn #_"GuardProxyNode" ProxyNode'forGuard-3 [#_"GuardingNode" value, #_"LoopExitNode" exit, #_"Graph" graph]
        (Graph''add-2 graph, (GuardProxyNode'new-2 value, exit))
    )
)

(class-ns GuardProxyNode [ProxyNode, FloatingNode, ValueNode, Node, GuardingNode, Proxy, LIRLowerable, Canonicalizable]
    (defn #_"GuardProxyNode" GuardProxyNode'new-2 [#_"GuardingNode" value, #_"LoopExitNode" proxyPoint]
        (merge (GuardProxyNode'class.) (ProxyNode'new-2 VoidStamp'instance, proxyPoint)
            (hash-map
                ; @OptionalInput(InputType'Guard)
                #_"GuardingNode" :value value
            )
        )
    )

    (defm GuardProxyNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"GuardProxyNode" this, #_"LIRBuilder" builder]
            nil
        )
    )

    (defm GuardProxyNode Proxy
        (#_"Node" Proxy'''getOriginalNode-1 [#_"GuardProxyNode" this]
            (:value this)
        )
    )

    (defm GuardProxyNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"GuardProxyNode" this, #_"CanonicalizerTool" tool]
            (when (some? (:value this))
                this
            )
        )
    )
)

(class-ns ValueProxyNode [ProxyNode, FloatingNode, ValueNode, Node, Canonicalizable, Virtualizable, ValueProxy, LimitedValueProxy, Proxy]
    (defn #_"ValueProxyNode" ValueProxyNode'new-2 [#_"ValueNode" value, #_"LoopExitNode" loopExit]
        (merge (ValueProxyNode'class.) (ProxyNode'new-2 (:stamp value), loopExit)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
                #_"boolean" :loopPhiProxy (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)
            )
        )
    )

    (defm ValueProxyNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"ValueProxyNode" this]
            (ValueNode''updateStamp-2 this, (:stamp (:value this)))
        )
    )

    (defm ValueProxyNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"ValueProxyNode" this, #_"CanonicalizerTool" tool]
            (if (or (satisfies? ConstantNode (:value this))
                    (and (:loopPhiProxy this) (not (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin (:loopExit this)), (:value this))))
                )
                (:value this)
                this
            )
        )
    )

    (defm ValueProxyNode Virtualizable
        (#_"void" Virtualizable'''virtualize-2 [#_"ValueProxyNode" this, #_"VirtualizerTool" tool]
            (let [
                #_"ValueNode" alias (VirtualizerTool'''getAlias-2 tool, (:value this))
            ]
                (when (satisfies? VirtualObjectNode alias)
                    (VirtualizerTool'''replaceWithVirtual-2 tool, alias)
                )
            )
            nil
        )
    )

    (defm ValueProxyNode Proxy
        (#_"ValueNode" Proxy'''getOriginalNode-1 [#_"ValueProxyNode" this]
            (:value this)
        )
    )
)

(class-ns RandomSeedNode [FloatingNode, ValueNode, Node, LIRLowerable]
    #_unused
    (defn #_"RandomSeedNode" RandomSeedNode'new-0 []
        (merge (RandomSeedNode'class.) (FloatingNode'new-1 (StampFactory'forKind-1 JavaKind/Int)))
    )

    (defm RandomSeedNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"RandomSeedNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitRandomSeed-1 (:gen builder)))
            nil
        )
    )
)

(class-ns UnaryNode [FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable]
    (defm UnaryNode Unary
        (#_"ValueNode" Unary'''getValue-1 [#_"UnaryNode" this]
            (:value this)
        )
    )

    ;;;
     ; Creates a new UnaryNode instance.
     ;
     ; @param stamp the result type of this instruction
     ; @param value the input instruction
     ;;
    (defn #_"UnaryNode" UnaryNode'new-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (merge (UnaryNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                ; @Input
                #_"ValueNode" :value value
            )
        )
    )

    (defm UnaryNode Canonicalizable
        (#_"ValueNode" Canonicalizable'''canonical-2 [#_"UnaryNode" this, #_"CanonicalizerTool" tool]
            (Unary'''canonical-3 this, tool, (Unary'''getValue-1 this))
        )
    )

    (defm UnaryNode ValueNode
        (#_"boolean" ValueNode'''inferStamp-1 [#_"UnaryNode" this]
            (ValueNode''updateStamp-2 this, (UnaryNode'''foldStamp-2 this, (:stamp (:value this))))
        )
    )

    (defm UnaryNode UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"UnaryNode" this, #_"Stamp" stamp]
            (:stamp this)
        )
    )
)

(class-ns BitCountNode [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, LIRLowerable]
    #_unused
    (defn #_"BitCountNode" BitCountNode'new-1 [#_"ValueNode" value]
        (merge (BitCountNode'class.) (UnaryNode'new-2 (BitCountNode'computeStamp-2 (:stamp value), value), value))
    )

    (defm BitCountNode UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"BitCountNode" this, #_"Stamp" stamp]
            (BitCountNode'computeStamp-2 stamp, (Unary'''getValue-1 this))
        )
    )

    (defn #_"Stamp" BitCountNode'computeStamp-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (StampFactory'forInteger-3k JavaKind/Int, (Long/bitCount (:downMask stamp)), (Long/bitCount (:upMask stamp)))
    )

    (defm BitCountNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"BitCountNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (when (satisfies? ConstantNode value) => this
                (let [
                    #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
                ]
                    (ConstantNode'forInt-1 (if (= (ValueNode''getStackKind-1 value) JavaKind/Int) (Integer/bitCount (#_"JavaConstant" .asInt constant)) (Long/bitCount (#_"JavaConstant" .asLong constant))))
                )
            )
        )
    )

    (defm BitCountNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"BitCountNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitBitCount-2 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this))))
            nil
        )
    )
)

(class-ns CompressionNode [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ConvertNode, LIRLowerable]
    (defn #_"CompressionNode" CompressionNode'new-4 [#_"CompressionOp" op, #_"ValueNode" input, #_"Stamp" stamp, #_"CompressEncoding" encoding]
        (merge (CompressionNode'class.) (UnaryNode'new-2 stamp, input)
            (hash-map
                #_"CompressionOp" :op op
                #_"CompressEncoding" :encoding encoding
            )
        )
    )

    (defm CompressionNode UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"CompressionNode" this, #_"Stamp" stamp]
            (CompressionNode'''mkStamp-2 this, stamp)
        )
    )

    (defm CompressionNode ConvertNode
        (#_"Constant" ConvertNode'''convert-2 [#_"CompressionNode" this, #_"Constant" constant]
            (condp = (:op this)
                CompressionOp'Compress   (CompressionNode'''compress-2 this, constant)
                CompressionOp'Uncompress (CompressionNode'''uncompress-2 this, constant)
            )
        )

        (#_"Constant" ConvertNode'''reverse-2 [#_"CompressionNode" this, #_"Constant" constant]
            (condp = (:op this)
                CompressionOp'Compress   (CompressionNode'''uncompress-2 this, constant)
                CompressionOp'Uncompress (CompressionNode'''compress-2 this, constant)
            )
        )

        (#_"boolean" ConvertNode'''isLossless-1 [#_"CompressionNode" this]
            true
        )
    )

    (defn #_"CompressEncoding" CompressionNode''getEncoding-1 [#_"CompressionNode" this]
        (:encoding this)
    )

    (defm CompressionNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"CompressionNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (cond
                (satisfies? ConstantNode value)
                    (ConstantNode'forConstant-4 (:stamp this), (ConvertNode'''convert-2 this, (:value value)), (:stableDimension value), (:isDefaultStable value))
                (satisfies? CompressionNode value)
                    (when (and (not= (:op this) (:op value)) (= (:encoding this) (:encoding value))) => this
                        (Unary'''getValue-1 value)
                    )
                :else
                    this
            )
        )
    )

    (defm CompressionNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"CompressionNode" this, #_"LIRBuilder" builder]
            (let [
                #_"boolean" never-nil?
                    (if (satisfies? AbstractObjectStamp (:stamp (:value this)))
                        (StampTool'isPointerNeverNull-1 (:stamp (:value this)))
                        true ;; metaspace pointers are never nil
                    )
                #_"Value" result
                    (condp = (:op this)
                        CompressionOp'Compress
                            (LIRGenerator''emitCompress-4 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)), (:encoding this), never-nil?)
                        CompressionOp'Uncompress
                            (LIRGenerator''emitUncompress-4 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)), (:encoding this), never-nil?)
                    )
            ]
                (LIRBuilder''setResult-3 builder, this, result)
            )
            nil
        )
    )

    (defm CompressionNode ConvertNode
        (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"CompressionNode" this]
            true
        )

        (#_"boolean" ConvertNode'''preservesOrder-2 [#_"CompressionNode" this, #_"CanonicalCondition" op]
            (ConvertNode'''isLossless-1 this)
        )

        (#_"boolean" ConvertNode'''preservesOrder-3 [#_"CompressionNode" this, #_"CanonicalCondition" op, #_"Constant" value]
            (ConvertNode'''preservesOrder-2 this, op)
        )
    )
)

(class-ns HotSpotCompressionNode [CompressionNode, UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ConvertNode, LIRLowerable]
    (defn #_"HotSpotCompressionNode" HotSpotCompressionNode'new-3 [#_"CompressionOp" op, #_"ValueNode" input, #_"CompressEncoding" encoding]
        (merge (HotSpotCompressionNode'class.) (CompressionNode'new-4 op, input, (HotSpotNarrowOopStamp'mkStamp-3 op, (:stamp input), encoding), encoding))
    )

    (defn #_"HotSpotCompressionNode" HotSpotCompressionNode'compress-2 [#_"ValueNode" input, #_"CompressEncoding" encoding]
        (Graph''add-2 (:graph input), (HotSpotCompressionNode'new-3 CompressionOp'Compress, input, encoding))
    )

    (defn #_"CompressionNode" HotSpotCompressionNode'uncompress-2 [#_"ValueNode" input, #_"CompressEncoding" encoding]
        (Graph''add-2 (:graph input), (HotSpotCompressionNode'new-3 CompressionOp'Uncompress, input, encoding))
    )

    (defm HotSpotCompressionNode CompressionNode
        (#_"Constant" CompressionNode'''compress-2 [#_"HotSpotCompressionNode" this, #_"Constant" constant]
            (if (= constant JavaConstant/NULL_POINTER)
                HotSpotCompressedNullConstant/COMPRESSED_NULL
                (condp instance? constant
                    HotSpotConstant (#_"HotSpotConstant" .compress constant)
                )
            )
        )

        (#_"Constant" CompressionNode'''uncompress-2 [#_"HotSpotCompressionNode" this, #_"Constant" constant]
            (condp instance? constant
                HotSpotConstant (#_"HotSpotConstant" .uncompress constant)
            )
        )

        (#_"Stamp" CompressionNode'''mkStamp-2 [#_"HotSpotCompressionNode" this, #_"Stamp" input]
            (HotSpotNarrowOopStamp'mkStamp-3 (:op this), input, (:encoding this))
        )
    )
)

;;;
 ; Count the number of leading zeros using the {@code lzcntq} or {@code lzcntl} instructions.
 ;;
(class-ns CountLeadingZerosNode [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, LIRLowerable]
    #_unused
    (defn #_"CountLeadingZerosNode" CountLeadingZerosNode'new-1 [#_"ValueNode" value]
        (merge (CountLeadingZerosNode'class.) (UnaryNode'new-2 (StampTool'stampForLeadingZeros-1 (:stamp value)), value))
    )

    (defm CountLeadingZerosNode UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"CountLeadingZerosNode" this, #_"Stamp" stamp]
            (StampTool'stampForLeadingZeros-1 stamp)
        )
    )

    (defn #_"ValueNode" CountLeadingZerosNode'tryFold-1 [#_"ValueNode" value]
        (when (satisfies? ConstantNode value)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (if (= (ValueNode''getStackKind-1 value) JavaKind/Int)
                    (ConstantNode'forInt-1 (Integer/numberOfLeadingZeros (#_"JavaConstant" .asInt constant)))
                    (ConstantNode'forInt-1 (Long/numberOfLeadingZeros (#_"JavaConstant" .asLong constant)))
                )
            )
        )
    )

    (defm CountLeadingZerosNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"CountLeadingZerosNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (CountLeadingZerosNode'tryFold-1 value)
                this
            )
        )
    )

    (defm CountLeadingZerosNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"CountLeadingZerosNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitCountLeadingZeros-2 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this))))
            nil
        )
    )
)

;;;
 ; Count the number of trailing zeros using the {@code tzcntq} or {@code tzcntl} instructions.
 ;;
(class-ns CountTrailingZerosNode [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, LIRLowerable]
    #_unused
    (defn #_"CountTrailingZerosNode" CountTrailingZerosNode'new-1 [#_"ValueNode" value]
        (merge (CountTrailingZerosNode'class.) (UnaryNode'new-2 (CountTrailingZerosNode'computeStamp-2 (:stamp value), value), value))
    )

    (defm CountTrailingZerosNode UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"CountTrailingZerosNode" this, #_"Stamp" stamp]
            (CountTrailingZerosNode'computeStamp-2 stamp, (Unary'''getValue-1 this))
        )
    )

    (defn #_"Stamp" CountTrailingZerosNode'computeStamp-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (StampTool'stampForTrailingZeros-1 stamp)
    )

    (defn #_"ValueNode" CountTrailingZerosNode'tryFold-1 [#_"ValueNode" value]
        (when (satisfies? ConstantNode value)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (if (= (ValueNode''getStackKind-1 value) JavaKind/Int)
                    (ConstantNode'forInt-1 (Integer/numberOfTrailingZeros (#_"JavaConstant" .asInt constant)))
                    (ConstantNode'forInt-1 (Long/numberOfTrailingZeros (#_"JavaConstant" .asLong constant)))
                )
            )
        )
    )

    (defm CountTrailingZerosNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"CountTrailingZerosNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (CountTrailingZerosNode'tryFold-1 value)
                this
            )
        )
    )

    (defm CountTrailingZerosNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"CountTrailingZerosNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitCountTrailingZeros-2 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this))))
            nil
        )
    )
)

;;;
 ; An IntegerConvert converts an integer to an integer of different width.
 ;;
(class-ns IntegerConvertNode #_"<OP, REV>" [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, ConvertNode, LIRLowerable, StampInverter]
    (defn #_"IntegerConvertNode" IntegerConvertNode'new-5 [#_"SerializableIntegerConvertFunction<OP>" f'getOp-1, #_"SerializableIntegerConvertFunction<REV>" f'getReverseOp-1, #_"int" inputBits, #_"int" resultBits, #_"ValueNode" input]
        (merge (IntegerConvertNode'class.) (UnaryNode'new-2 (IntegerConvertOp'''foldStamp-4 (f'getOp-1 (ArithmeticOpTable'forStamp-1 (:stamp input))), inputBits, resultBits, (:stamp input)), input)
            (hash-map
                #_"SerializableIntegerConvertFunction<OP>" :f'getOp-1 f'getOp-1
                #_"SerializableIntegerConvertFunction<REV>" :f'getReverseOp-1 f'getReverseOp-1
                #_"int" :inputBits inputBits
                #_"int" :resultBits resultBits
            )
        )
    )

    (defn #_"int" IntegerConvertNode''getInputBits-1 [#_"IntegerConvertNode<OP, REV>" this]
        (:inputBits this)
    )

    (defn #_"int" IntegerConvertNode''getResultBits-1 [#_"IntegerConvertNode<OP, REV>" this]
        (:resultBits this)
    )

    (defn #_"IntegerConvertOp<OP>" IntegerConvertNode''getOp-2 [#_"IntegerConvertNode<OP, REV>" this, #_"ValueNode" value]
        ((:f'getOp-1 this) (ArithmeticOpTable'forStamp-1 (:stamp value)))
    )

    (defm IntegerConvertNode #_"<OP, REV>" ArithmeticOperation
        (#_"IntegerConvertOp<OP>" ArithmeticOperation'''getArithmeticOp-1 [#_"IntegerConvertNode<OP, REV>" this]
            (IntegerConvertNode''getOp-2 this, (Unary'''getValue-1 this))
        )
    )

    (defm IntegerConvertNode #_"<OP, REV>" ConvertNode
        (#_"Constant" ConvertNode'''convert-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Constant" constant]
            (IntegerConvertOp'''foldConstant-4 (ArithmeticOperation'''getArithmeticOp-1 this), (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this), constant)
        )
    )

    (defm IntegerConvertNode #_"<OP, REV>" ConvertNode
        (#_"Constant" ConvertNode'''reverse-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Constant" constant]
            (let [
                #_"IntegerConvertOp<REV>" reverse ((:f'getReverseOp-1 this) (ArithmeticOpTable'forStamp-1 (:stamp this)))
            ]
                (IntegerConvertOp'''foldConstant-4 reverse, (IntegerConvertNode''getResultBits-1 this), (IntegerConvertNode''getInputBits-1 this), constant)
            )
        )
    )

    (defm IntegerConvertNode #_"<OP, REV>" UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Stamp" stamp]
            (IntegerConvertOp'''foldStamp-4 (ArithmeticOperation'''getArithmeticOp-1 this), (:inputBits this), (:resultBits this), stamp)
        )
    )

    (defm IntegerConvertNode #_"<OP, REV>" Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"IntegerConvertNode<OP, REV>" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (IntegerConvertNode'findSynonym-5 (IntegerConvertNode''getOp-2 this, value), value, (:inputBits this), (:resultBits this), (:stamp this))
                this
            )
        )
    )

    (defn #_"<T> ValueNode" IntegerConvertNode'findSynonym-5 [#_"IntegerConvertOp<T>" operation, #_"ValueNode" value, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
        (cond
            (= inputBits resultBits)       value
            (satisfies? ConstantNode value) (ConstantNode'forPrimitive-2s stamp, (IntegerConvertOp'''foldConstant-4 operation, inputBits, resultBits, (:value value)))
        )
    )

    (defn #_"ValueNode" IntegerConvertNode'convert-3b [#_"ValueNode" input, #_"Stamp" stamp, #_"boolean" zero-extend?]
        (let [
            #_"IntegerStamp" fromStamp (:stamp input)
            #_"IntegerStamp" toStamp stamp
        ]
            (cond
                (= (:bits toStamp) (:bits fromStamp)) input
                (< (:bits toStamp) (:bits fromStamp)) (NarrowNode'new-3 input, (:bits fromStamp), (:bits toStamp))
                zero-extend?                          (ZeroExtendNode'create-2 input, (:bits toStamp))
                :else                                 (SignExtendNode'create-2 input, (:bits toStamp))
            )
        )
    )

    (defn #_"ValueNode" IntegerConvertNode'convert-3g [#_"ValueNode" input, #_"Stamp" stamp, #_"Graph" graph]
        (let [
            #_"ValueNode" convert (IntegerConvertNode'convert-3b input, stamp, false)
        ]
            (when-not (Node''isAlive-1 convert) => convert
                (Graph''addOrUniqueWithInputs-2 graph, convert)
            )
        )
    )

    #_unused
    (defn #_"ValueNode" IntegerConvertNode'convert-2 [#_"ValueNode" input, #_"Stamp" stamp]
        (IntegerConvertNode'convert-3b input, stamp, false)
    )

    #_unused
    (defn #_"ValueNode" IntegerConvertNode'convertUnsigned-3 [#_"ValueNode" input, #_"Stamp" stamp, #_"Graph" graph]
        (let [
            #_"ValueNode" convert (IntegerConvertNode'convert-3b input, stamp, true)
        ]
            (when-not (Node''isAlive-1 convert) => convert
                (Graph''addOrUniqueWithInputs-2 graph, convert)
            )
        )
    )

    (defn #_"ValueNode" IntegerConvertNode'convertUnsigned-2 [#_"ValueNode" input, #_"Stamp" stamp]
        (IntegerConvertNode'convert-3b input, stamp, true)
    )

    (defm IntegerConvertNode #_"<OP, REV>" StampInverter
        (#_"Stamp" StampInverter'''invertStamp-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Stamp" outStamp]
            (IntegerConvertOp'''invertStamp-4 (ArithmeticOperation'''getArithmeticOp-1 this), (:inputBits this), (:resultBits this), outStamp)
        )
    )

    (defm IntegerConvertNode ConvertNode
        (#_"boolean" ConvertNode'''preservesOrder-2 [#_"IntegerConvertNode" this, #_"CanonicalCondition" op]
            (ConvertNode'''isLossless-1 this)
        )

        (#_"boolean" ConvertNode'''preservesOrder-3 [#_"IntegerConvertNode" this, #_"CanonicalCondition" op, #_"Constant" value]
            (ConvertNode'''preservesOrder-2 this, op)
        )
    )
)

;;;
 ; The NarrowNode converts an integer to a narrower integer.
 ;;
(class-ns NarrowNode [IntegerConvertNode #_"<Narrow, SignExtend>", UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, ConvertNode, LIRLowerable, StampInverter]
    (defn #_"NarrowNode" NarrowNode'new-2 [#_"ValueNode" input, #_"int" resultBits]
        (NarrowNode'new-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (defn #_"NarrowNode" NarrowNode'new-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (merge (NarrowNode'class.) (IntegerConvertNode'new-5 :narrow, :signExtend, inputBits, resultBits, input))
    )

    (defn #_"ValueNode" NarrowNode'create-2 [#_"ValueNode" input, #_"int" resultBits]
        (NarrowNode'create-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (defn #_"ValueNode" NarrowNode'create-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (let [
            #_"IntegerConvertOp<Narrow>" signExtend (:narrow (ArithmeticOpTable'forStamp-1 (:stamp input)))
        ]
            (or (IntegerConvertNode'findSynonym-5 signExtend, input, inputBits, resultBits, (IntegerConvertOp'''foldStamp-4 signExtend, inputBits, resultBits, (:stamp input)))
                (NarrowNode'new-3 input, inputBits, resultBits)
            )
        )
    )

    (defm NarrowNode ConvertNode
        (#_"boolean" ConvertNode'''isLossless-1 [#_"NarrowNode" this]
            false
        )
    )

    (defm NarrowNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"NarrowNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (let [
                #_"ValueNode" canon (Unary'''canonical-3 (ยง super #_"IntegerConvertNode"), tool, value)
            ]
                (when (= canon this) => canon
                    (condp satisfies? value
                        NarrowNode
                            ;; zzzzzzzz yyyyxxxx -(narrow)-> yyyyxxxx -(narrow)-> xxxx
                            ;; ==> zzzzzzzz yyyyxxxx -(narrow)-> xxxx
                            (NarrowNode'new-3 (Unary'''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this))
                        IntegerConvertNode
                            ;; SignExtendNode or ZeroExtendNode
                            (cond
                                (and (Node''hasExactlyOneUsage-1 (Unary'''getValue-1 value)) (Node''hasMoreThanOneUsage-1 value))
                                    ;; Do not perform if this will introduce a new live value.
                                    ;; If the original value's usage count is > 1, there is already another user.
                                    ;; If the convert's usage count is <=1, it will be dead code eliminated.
                                    this
                                (= (IntegerConvertNode''getResultBits-1 this) (IntegerConvertNode''getInputBits-1 value))
                                    ;; xxxx -(extend)-> yyyy xxxx -(narrow)-> xxxx
                                    ;; ==> no-op
                                    (Unary'''getValue-1 value)
                                (< (IntegerConvertNode''getResultBits-1 this) (IntegerConvertNode''getInputBits-1 value))
                                    ;; yyyyxxxx -(extend)-> zzzzzzzz yyyyxxxx -(narrow)-> xxxx
                                    ;; ==> yyyyxxxx -(narrow)-> xxxx
                                    (NarrowNode'new-3 (Unary'''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this))
                                :else
                                    (condp satisfies? value
                                        SignExtendNode
                                            ;; sxxx -(sign-extend)-> ssssssss sssssxxx -(narrow)-> sssssxxx
                                            ;; ==> sxxx -(sign-extend)-> sssssxxx
                                            (SignExtendNode'create-3 (Unary'''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this))
                                        ZeroExtendNode
                                            ;; xxxx -(zero-extend)-> 00000000 0000xxxx -(narrow)-> 0000xxxx
                                            ;; ==> xxxx -(zero-extend)-> 0000xxxx
                                            (ZeroExtendNode'new-4 (Unary'''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this), (:inputAlwaysPositive value))
                                        this
                                    )
                            )
                        AndNode
                            (let [
                                #_"long" relevantMask (CodeUtil/mask (IntegerConvertNode''getResultBits-1 this))
                            ]
                                (condp = relevantMask
                                    (& relevantMask (:downMask (:stamp (:y value)))) (NarrowNode'create-2 (:x value), (IntegerConvertNode''getResultBits-1 this))
                                    (& relevantMask (:downMask (:stamp (:x value)))) (NarrowNode'create-2 (:y value), (IntegerConvertNode''getResultBits-1 this))
                                    this
                                )
                            )
                        this
                    )
                )
            )
        )
    )

    (defm NarrowNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"NarrowNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitNarrow-3 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this)), (IntegerConvertNode''getResultBits-1 this)))
            nil
        )
    )

    (defm NarrowNode ConvertNode
        (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"NarrowNode" this]
            false
        )
    )
)

;;;
 ; The SignExtendNode converts an integer to a wider integer using sign extension.
 ;;
(class-ns SignExtendNode [IntegerConvertNode #_"<SignExtend, Narrow>", UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, ConvertNode, LIRLowerable, StampInverter]
    (defn #_"SignExtendNode" SignExtendNode'new-2 [#_"ValueNode" input, #_"int" resultBits]
        (SignExtendNode'new-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (defn #_"SignExtendNode" SignExtendNode'new-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (merge (SignExtendNode'class.) (IntegerConvertNode'new-5 :signExtend, :narrow, inputBits, resultBits, input))
    )

    (defn- #_"ValueNode" SignExtendNode'canonical-4 [#_"SignExtendNode" self, #_"ValueNode" forValue, #_"int" inputBits, #_"int" resultBits]
        (condp satisfies? forValue
            SignExtendNode
                ;; sxxx -(sign-extend)-> ssss sxxx -(sign-extend)-> ssssssss sssssxxx
                ;; ==> sxxx -(sign-extend)-> ssssssss sssssxxx
                (ยง return (SignExtendNode'create-3 (Unary'''getValue-1 forValue), (IntegerConvertNode''getInputBits-1 forValue), resultBits))
            ZeroExtendNode
                (when (< (IntegerConvertNode''getInputBits-1 forValue) (IntegerConvertNode''getResultBits-1 forValue))
                    ;; sxxx -(zero-extend)-> 0000 sxxx -(sign-extend)-> 00000000 0000sxxx
                    ;; ==> sxxx -(zero-extend)-> 00000000 0000sxxx
                    (ยง return (ZeroExtendNode'create-4 (Unary'''getValue-1 forValue), (IntegerConvertNode''getInputBits-1 forValue), resultBits, (:inputAlwaysPositive forValue)))
                )
            nil
        )

        (when (and (satisfies? IntegerStamp (:stamp forValue)) (zero? (& (:upMask (:stamp forValue)) (<< 1 (dec inputBits))))) => (or self (SignExtendNode'new-3 forValue, inputBits, resultBits))
            ;; 0xxx -(sign-extend)-> 0000 0xxx
            ;; ==> 0xxx -(zero-extend)-> 0000 0xxx
            (ZeroExtendNode'create-4 forValue, inputBits, resultBits, true)
        )
    )

    (defn #_"ValueNode" SignExtendNode'create-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (let [
            #_"IntegerConvertOp<SignExtend>" signExtend (:signExtend (ArithmeticOpTable'forStamp-1 (:stamp input)))
        ]
            (or (IntegerConvertNode'findSynonym-5 signExtend, input, inputBits, resultBits, (IntegerConvertOp'''foldStamp-4 signExtend, inputBits, resultBits, (:stamp input)))
                (SignExtendNode'canonical-4 nil, input, inputBits, resultBits)
            )
        )
    )

    (defn #_"ValueNode" SignExtendNode'create-2 [#_"ValueNode" input, #_"int" resultBits]
        (SignExtendNode'create-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (defm SignExtendNode ConvertNode
        (#_"boolean" ConvertNode'''isLossless-1 [#_"SignExtendNode" this]
            true
        )

        (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"SignExtendNode" this]
            true
        )
    )

    (defm SignExtendNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"SignExtendNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (let [
                #_"ValueNode" ret (Unary'''canonical-3 (ยง super #_"IntegerConvertNode"), tool, value)
            ]
                (when (= ret this) => ret
                    (SignExtendNode'canonical-4 this, value, (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this))
                )
            )
        )
    )

    (defm SignExtendNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"SignExtendNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitSignExtend-4 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this)), (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this)))
            nil
        )
    )
)

;;;
 ; The ZeroExtendNode converts an integer to a wider integer using zero extension.
 ;;
(class-ns ZeroExtendNode [IntegerConvertNode #_"<ZeroExtend, Narrow>", UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, ConvertNode, LIRLowerable, StampInverter]
    (defn #_"ZeroExtendNode" ZeroExtendNode'new-2 [#_"ValueNode" input, #_"int" resultBits]
        (ZeroExtendNode'new-4 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits, false)
    )

    (defn #_"ZeroExtendNode" ZeroExtendNode'new-4 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits, #_"boolean" inputAlwaysPositive]
        (merge (ZeroExtendNode'class.) (IntegerConvertNode'new-5 :zeroExtend, :narrow, inputBits, resultBits, input)
            (hash-map
                #_"boolean" :inputAlwaysPositive inputAlwaysPositive
            )
        )
    )

    (defn- #_"ValueNode" ZeroExtendNode'canonical-5 [#_"ZeroExtendNode" self, #_"ValueNode" forValue, #_"int" inputBits, #_"int" resultBits, #_"boolean" alwaysPositive]
        (condp satisfies? forValue
            ZeroExtendNode
                ;; xxxx -(zero-extend)-> 0000 xxxx -(zero-extend)-> 00000000 0000xxxx
                ;; ==> xxxx -(zero-extend)-> 00000000 0000xxxx
                (ZeroExtendNode'new-4 (Unary'''getValue-1 forValue), (IntegerConvertNode''getInputBits-1 forValue), resultBits, (:inputAlwaysPositive forValue))
            NarrowNode
                (let [
                    #_"ValueNode" inputValue (Unary'''getValue-1 forValue)
                    #_"Stamp" inputStamp (:stamp inputValue)
                ]
                    (if (and (satisfies? IntegerStamp inputStamp) (zero? (& (:upMask inputStamp) (bit-not (CodeUtil/mask (PrimitiveStamp'getBits-1 (:stamp forValue)))))))
                        ;; The original value cannot change because of the narrow and zero extend.
                        (cond
                            ;; Need to keep the zero extend, skip the narrow.
                            (< (:bits inputStamp) resultBits) (ZeroExtendNode'create-2 inputValue, resultBits)
                            ;; Need to keep the narrow, skip the zero extend.
                            (< resultBits (:bits inputStamp)) (NarrowNode'create-2 inputValue, resultBits)
                            ;; Just return the original value.
                            :else                             inputValue
                        )
                        (or self (ZeroExtendNode'new-4 forValue, inputBits, resultBits, alwaysPositive))
                    )
                )
            (or self (ZeroExtendNode'new-4 forValue, inputBits, resultBits, alwaysPositive))
        )
    )

    (defn #_"ValueNode" ZeroExtendNode'create-4 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits, #_"boolean" alwaysPositive]
        (let [
            #_"IntegerConvertOp<ZeroExtend>" signExtend (:zeroExtend (ArithmeticOpTable'forStamp-1 (:stamp input)))
        ]
            (or (IntegerConvertNode'findSynonym-5 signExtend, input, inputBits, resultBits, (IntegerConvertOp'''foldStamp-4 signExtend, inputBits, resultBits, (:stamp input)))
                (ZeroExtendNode'canonical-5 nil, input, inputBits, resultBits, alwaysPositive)
            )
        )
    )

    (defn #_"ValueNode" ZeroExtendNode'create-2 [#_"ValueNode" input, #_"int" resultBits]
        (ZeroExtendNode'create-4 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits, false)
    )

    #_unused
    (defn #_"ValueNode" ZeroExtendNode'create-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (ZeroExtendNode'create-4 input, inputBits, resultBits, false)
    )

    (defm ZeroExtendNode ConvertNode
        (#_"boolean" ConvertNode'''isLossless-1 [#_"ZeroExtendNode" this]
            true
        )

        (#_"boolean" ConvertNode'''preservesOrder-2 [#_"ZeroExtendNode" this, #_"CanonicalCondition" condition]
            (not= condition CanonicalCondition'LT)
        )
    )

    (defm ZeroExtendNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"ZeroExtendNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (let [
                #_"ValueNode" ret (Unary'''canonical-3 (ยง super #_"IntegerConvertNode"), tool, value)
            ]
                (when (= ret this) => ret
                    (ZeroExtendNode'canonical-5 this, value, (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this), (:inputAlwaysPositive this))
                )
            )
        )
    )

    (defm ZeroExtendNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"ZeroExtendNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitZeroExtend-4 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this)), (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this)))
            nil
        )
    )

    (defm ZeroExtendNode ConvertNode
        (#_"boolean" ConvertNode'''mayNullCheckSkipConversion-1 [#_"ZeroExtendNode" this]
            true
        )
    )
)

(class-ns UnaryArithmeticNode #_"<OP>" [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable]
    (defn #_"UnaryArithmeticNode" UnaryArithmeticNode'new-2 [#_"SerializableUnaryFunction<OP>" f'getOp-1, #_"ValueNode" value]
        (merge (UnaryArithmeticNode'class.) (UnaryNode'new-2 (UnaryOp'''foldStamp-2 (f'getOp-1 (ArithmeticOpTable'forStamp-1 (:stamp value))), (:stamp value)), value)
            (hash-map
                #_"SerializableUnaryFunction<OP>" :f'getOp-1 f'getOp-1
            )
        )
    )

    (defn #_"UnaryOp<OP>" UnaryArithmeticNode''getOp-2 [#_"UnaryArithmeticNode<OP>" this, #_"ValueNode" value]
        ((:f'getOp-1 this) (ArithmeticOpTable'forStamp-1 (:stamp value)))
    )

    (defm UnaryArithmeticNode #_"<OP>" ArithmeticOperation
        (#_"UnaryOp<OP>" ArithmeticOperation'''getArithmeticOp-1 [#_"UnaryArithmeticNode<OP>" this]
            (UnaryArithmeticNode''getOp-2 this, (Unary'''getValue-1 this))
        )
    )

    (defm UnaryArithmeticNode #_"<OP>" UnaryNode
        (#_"Stamp" UnaryNode'''foldStamp-2 [#_"UnaryArithmeticNode<OP>" this, #_"Stamp" stamp]
            (UnaryOp'''foldStamp-2 (UnaryArithmeticNode''getOp-2 this, (Unary'''getValue-1 this)), stamp)
        )
    )

    (defm UnaryArithmeticNode #_"<OP>" Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"UnaryArithmeticNode<OP>" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (UnaryArithmeticNode'findSynonym-2 value, (UnaryArithmeticNode''getOp-2 this, value))
                this
            )
        )
    )

    (defn #_"<OP> ValueNode" UnaryArithmeticNode'findSynonym-2 [#_"ValueNode" value, #_"UnaryOp<OP>" op]
        (when (satisfies? ConstantNode value)
            (ConstantNode'forPrimitive-2s (UnaryOp'''foldStamp-2 op, (:stamp value)), (UnaryOp'''foldConstant-2 op, (:value value)))
        )
    )
)

;;;
 ; The NegateNode node negates its operand.
 ;;
(class-ns NegateNode [UnaryArithmeticNode #_"<Neg>", UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, StampInverter]
    (defn #_"NegateNode" NegateNode'new-1 [#_"ValueNode" value]
        (merge (NegateNode'class.) (UnaryArithmeticNode'new-2 :neg, value))
    )

    (defn #_"ValueNode" NegateNode'create-1 [#_"ValueNode" value]
        (or (NegateNode'findSynonym-1 value)
            (NegateNode'new-1 value)
        )
    )

    (defm NegateNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"NegateNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (or (UnaryArithmeticNode'findSynonym-2 value, (UnaryArithmeticNode''getOp-2 this, value))
                this
            )
        )
    )

    (defn #_"ValueNode" NegateNode'findSynonym-1 [#_"ValueNode" value]
        (or (UnaryArithmeticNode'findSynonym-2 value, (:neg (ArithmeticOpTable'forStamp-1 (:stamp value))))
            (condp satisfies? value
                NegateNode (Unary'''getValue-1 value)
                SubNode    (SubNode'create-2 (:y value), (:x value))
                nil
            )
        )
    )

    (defm NegateNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"NegateNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitNegate-2 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this))))
            nil
        )
    )

    (defm NegateNode StampInverter
        (#_"Stamp" StampInverter'''invertStamp-2 [#_"NegateNode" this, #_"Stamp" outStamp]
            (UnaryOp'''foldStamp-2 (ArithmeticOperation'''getArithmeticOp-1 this), outStamp)
        )
    )
)

;;;
 ; Binary negation of long or integer values.
 ;;
(class-ns NotNode [UnaryArithmeticNode #_"<Not>", UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, ArithmeticOperation, LIRLowerable, StampInverter]
    (defn #_"NotNode" NotNode'new-1 [#_"ValueNode" value]
        (merge (NotNode'class.) (UnaryArithmeticNode'new-2 :not, value))
    )

    (defn- #_"ValueNode" NotNode'canonicalize-2 [#_"NotNode" node, #_"ValueNode" value]
        (cond
            (satisfies? NotNode value) (Unary'''getValue-1 value)
            (some? node)              node
            :else                     (NotNode'new-1 value)
        )
    )

    #_unused
    (defn #_"ValueNode" NotNode'create-1 [#_"ValueNode" value]
        (NotNode'canonicalize-2 nil, value)
    )

    (defm NotNode Unary
        (#_"ValueNode" Unary'''canonical-3 [#_"NotNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (let [
                #_"ValueNode" ret (Unary'''canonical-3 (ยง super #_"UnaryArithmeticNode"), tool, value)
            ]
                (when (= ret this) => ret
                    (NotNode'canonicalize-2 this, value)
                )
            )
        )
    )

    (defm NotNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"NotNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitNot-2 (:gen builder), (LIRBuilder''operand-2 builder, (Unary'''getValue-1 this))))
            nil
        )
    )

    (defm NotNode StampInverter
        (#_"Stamp" StampInverter'''invertStamp-2 [#_"NotNode" this, #_"Stamp" outStamp]
            (UnaryOp'''foldStamp-2 (ArithmeticOperation'''getArithmeticOp-1 this), outStamp)
        )
    )
)

;;;
 ; Produces the platform dependent first or second half of a long or double value as an int.
 ;;
(class-ns UnpackEndianHalfNode [UnaryNode, FloatingNode, ValueNode, Node, Unary #_"<ValueNode>", Canonicalizable, Lowerable]
    (defn #_"UnpackEndianHalfNode" UnpackEndianHalfNode'new-2 [#_"ValueNode" value, #_"boolean" firstHalf]
        (merge (UnpackEndianHalfNode'class.) (UnaryNode'new-2 (StampFactory'forKind-1 JavaKind/Int), value)
            (hash-map
                #_"boolean" :firstHalf firstHalf
            )
        )
    )

    (defn #_"ValueNode" UnpackEndianHalfNode'create-2 [#_"ValueNode" value, #_"boolean" firstHalf]
        (if (and (satisfies? ConstantNode value) (#_"Constant" .isDefaultForKind (:value value)))
            (ConstantNode'defaultForKind-1 JavaKind/Int)
            (UnpackEndianHalfNode'new-2 value, firstHalf)
        )
    )

    (defm UnpackEndianHalfNode Unary
        (#_"Node" Unary'''canonical-3 [#_"UnpackEndianHalfNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
            (if (and (satisfies? ConstantNode value) (#_"Constant" .isDefaultForKind (:value value)))
                (ConstantNode'defaultForKind-1 (Stamp'''getStackKind-1 (:stamp this)))
                this
            )
        )
    )

    (defm UnpackEndianHalfNode Lowerable
        (#_"void" Lowerable'''lower-2 [#_"UnpackEndianHalfNode" this, #_"LoweringTool" lowerer]
            (let [
                #_"ValueNode" result
                    (when (= (= (#_"Architecture" .getByteOrder (.arch HotSpot'target)) ByteOrder/BIG_ENDIAN) (:firstHalf this)) => (:value this)
                        (Graph''add-2 (:graph this), (UnsignedRightShiftNode'new-2 (:value this), (ConstantNode'forInt-2 32, (:graph this))))
                    )
            ]
                (ยง ass! this (Node''replaceAtUsagesAndDelete-2 this, (IntegerConvertNode'convert-3g result, (StampFactory'forKind-1 JavaKind/Int), (:graph this))))
            )
            nil
        )
    )
)

;;;
 ; Represents HotSpot values that may change after compilation.
 ;;
(class-ns VMConfigNode [FloatingNode, ValueNode, Node, LIRLowerable, Canonicalizable]
    (ยง intrinsic! #_"boolean" VMConfigNode'areConfigValuesConstant-0 [])

    #_intrinsifier
    (defn #_"VMConfigNode" VMConfigNode'new-0 []
        (merge (VMConfigNode'class.) (FloatingNode'new-1 (StampFactory'forKind-1 JavaKind/Boolean))
            (hash-map
                #_"int" :markId 0
            )
        )
    )

    (ยง intrinsic! #_"long" VMConfigNode'loadLongConfigValue-1 [#_"int" markId])
    (ยง intrinsic! #_"int"  VMConfigNode'loadIntConfigValue-1  [#_"int" markId])

    #_intrinsifier
    (defn #_"VMConfigNode" VMConfigNode'new-2 [#_@InjectedNodeParameter #_"Stamp" stamp, #_"int" markId]
        (merge (VMConfigNode'class.) (FloatingNode'new-1 stamp)
            (hash-map
                #_"int" :markId markId
            )
        )
    )

    (defm VMConfigNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"VMConfigNode" this, #_"LIRBuilder" builder]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitLoadConfigValue-3 (:gen builder), (:markId this), (Stamp'''getLIRKind-1 (:stamp this))))
            nil
        )
    )

    (defn #_"boolean" VMConfigNode'isCardTableAddressConstant-0 [] (VMConfigNode'areConfigValuesConstant-0))
    (defn #_"long"    VMConfigNode'cardTableAddress-0 []           (VMConfigNode'loadLongConfigValue-1 HotSpot'cardTableAddressMark))
    (defn #_"int"     VMConfigNode'logOfHeapRegionGrainBytes-0 []  (VMConfigNode'loadIntConfigValue-1 HotSpot'logOfHeapRegionGrainBytesMark))

    (defm VMConfigNode Canonicalizable
        (#_"Node" Canonicalizable'''canonical-2 [#_"VMConfigNode" this, #_"CanonicalizerTool" tool]
            (condp = (:markId this)
                0                                               (ConstantNode'forBoolean-1 true)
                HotSpot'cardTableAddressMark                    (ConstantNode'forLong-1 HotSpot'cardTableAddress)
                HotSpot'logOfHeapRegionGrainBytesMark           (ConstantNode'forInt-1 HotSpot'logOfHeapRegionGrainBytes)
                this
            )
        )
    )
)

;;;
 ; This node describes one locking scope; it ties the monitor enter, monitor exit and the frame states together.
 ; It is thus referenced from the MonitorEnterNode, from the MonitorExitNode and from the FrameState.
 ;;
(class-ns MonitorIdNode [ValueNode, Node, LIRLowerable]
    (defn #_"MonitorIdNode" MonitorIdNode'new-1 [#_"int" lockDepth]
        (merge (MonitorIdNode'class.) (ValueNode'new-1 VoidStamp'instance)
            (hash-map
                #_"int" :lockDepth lockDepth
            )
        )
    )

    (defn #_"MonitorIdNode" MonitorIdNode''setLockDepth-2 [#_"MonitorIdNode" this, #_"int" lockDepth]
        (assoc this :lockDepth lockDepth)
    )

    (defm MonitorIdNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"MonitorIdNode" this, #_"LIRBuilder" builder]
            ;; nothing to do
            nil
        )
    )
)

(class-ns TwoSlotMarker [ValueNode, Node]
    (defn #_"TwoSlotMarker" TwoSlotMarker'new-0 []
        (merge (TwoSlotMarker'class.) (ValueNode'new-1 (StampFactory'forKind-1 JavaKind/Illegal)))
    )
)

(class-ns VirtualObjectNode [ValueNode, Node, LIRLowerable]
    (defn #_"VirtualObjectNode" VirtualObjectNode'new-2 [#_"ResolvedJavaType" type, #_"boolean" hasIdentity]
        (merge (VirtualObjectNode'class.) (ValueNode'new-1 (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 type)))
            (hash-map
                ;;;
                 ; Specifies whether this virtual object has an object identity. If not, then the result of
                 ; a comparison of two virtual objects is determined by comparing their contents.
                 ;;
                #_"boolean" :hasIdentity hasIdentity
                #_"int" :oid -1
            )
        )
    )

    (defn #_"VirtualObjectNode" VirtualObjectNode''resetObjectId-1 [#_"VirtualObjectNode" this]
        (assoc this :oid -1)
    )

    (defn #_"VirtualObjectNode" VirtualObjectNode''setObjectId-2 [#_"VirtualObjectNode" this, #_"int" objectId]
        (assoc this :oid objectId)
    )

    (defm VirtualObjectNode Node
        (#_"void" Node'''afterClone-2 [#_"VirtualObjectNode" this, #_"Node" other]
            (Node'''afterClone-2 (ยง super #_"ValueNode"), other)
            (ยง ass! this (VirtualObjectNode''resetObjectId-1 this))
            nil
        )
    )

    (defm VirtualObjectNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"VirtualObjectNode" this, #_"LIRBuilder" builder]
            ;; nothing to do...
            nil
        )
    )
)

(class-ns VirtualArrayNode [VirtualObjectNode, ValueNode, Node, LIRLowerable, ArrayLengthProvider]
    (defn #_"VirtualArrayNode" VirtualArrayNode'new-2 [#_"ResolvedJavaType" componentType, #_"int" length]
        (merge (VirtualArrayNode'class.) (VirtualObjectNode'new-2 (#_"ResolvedJavaType" .getArrayClass componentType), true)
            (hash-map
                #_"ResolvedJavaType" :componentType componentType
                #_"int" :length length
            )
        )
    )

    (defm VirtualArrayNode VirtualObjectNode
        (#_"ResolvedJavaType" VirtualObjectNode'''type-1 [#_"VirtualArrayNode" this]
            (#_"ResolvedJavaType" .getArrayClass (:componentType this))
        )

        (#_"int" VirtualObjectNode'''entryCount-1 [#_"VirtualArrayNode" this]
            (:length this)
        )
    )

    (defm VirtualArrayNode LIRLowerable
        (#_"void" LIRLowerable'''generate-2 [#_"VirtualArrayNode" this, #_"LIRBuilder" builder]
            ;; nothing to do...
            nil
        )
    )

    (defm VirtualArrayNode VirtualObjectNode
        (#_"int" VirtualObjectNode'''entryIndexForOffset-3 [#_"VirtualArrayNode" this, #_"long" constantOffset, #_"JavaKind" expectedEntryKind]
            (VirtualArrayNode'entryIndexForOffset-4 constantOffset, expectedEntryKind, (:componentType this), (:length this))
        )
    )

    (defn #_"int" VirtualArrayNode'entryIndexForOffset-4 [#_"long" constantOffset, #_"JavaKind" expectedEntryKind, #_"ResolvedJavaType" componentType, #_"int" length]
        (let [
            #_"int" baseOffset (HotSpot'arrayBaseOffset-1 (#_"ResolvedJavaType" .getJavaKind componentType))
            #_"int" indexScale (HotSpot'arrayIndexScale-1 (#_"ResolvedJavaType" .getJavaKind componentType))
            #_"long" offset
                (when (and (= (ByteOrder/nativeOrder) ByteOrder/BIG_ENDIAN) (#_"ResolvedJavaType" .isPrimitive componentType)) => constantOffset
                    ;; on big endian, we expect the value to be correctly aligned in memory
                    (let [
                        #_"int" componentByteCount (#_"JavaKind" .getByteCount (#_"ResolvedJavaType" .getJavaKind componentType))
                    ]
                        (- constantOffset (- componentByteCount (min componentByteCount (+ 4 (#_"JavaKind" .getByteCount expectedEntryKind)))))
                    )
                )
            #_"long" index (- offset baseOffset)
        ]
            (when (zero? (% index indexScale)) => -1
                (let [
                    #_"long" elementIndex (quot index indexScale)
                ]
                    (when (< -1 elementIndex length) => -1
                        (int elementIndex)
                    )
                )
            )
        )
    )

    (defm VirtualArrayNode VirtualObjectNode
        (#_"JavaKind" VirtualObjectNode'''entryKind-2 [#_"VirtualArrayNode" this, #_"int" index]
            (#_"ResolvedJavaType" .getJavaKind (:componentType this))
        )

        (#_"VirtualArrayNode" VirtualObjectNode'''duplicate-1 [#_"VirtualArrayNode" this]
            (VirtualArrayNode'new-2 (:componentType this), (:length this))
        )

        (#_"ValueNode" VirtualObjectNode'''getMaterializedRepresentation-4 [#_"VirtualArrayNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks]
            (AllocatedObjectNode'new-1 this)
        )
    )

    (defm VirtualArrayNode ArrayLengthProvider
        (#_"ValueNode" ArrayLengthProvider'''length-1 [#_"VirtualArrayNode" this]
            (ConstantNode'forInt-1 (:length this))
        )
    )
)

(class-ns VirtualInstanceNode [VirtualObjectNode, ValueNode, Node, LIRLowerable]
    (defn #_"VirtualInstanceNode" VirtualInstanceNode'new-3 [#_"ResolvedJavaType" type, #_"ResolvedJavaField[]" fields, #_"boolean" hasIdentity]
        (merge (VirtualInstanceNode'class.) (VirtualObjectNode'new-2 type, hasIdentity)
            (hash-map
                #_"ResolvedJavaType" :type type
                #_"ResolvedJavaField[]" :fields fields
            )
        )
    )

    (defn #_"VirtualInstanceNode" VirtualInstanceNode'new-2 [#_"ResolvedJavaType" type, #_"boolean" hasIdentity]
        (VirtualInstanceNode'new-3 type, (#_"ResolvedJavaType" .getInstanceFields type, true), hasIdentity)
    )

    (defm VirtualInstanceNode VirtualObjectNode
        (#_"ResolvedJavaType" VirtualObjectNode'''type-1 [#_"VirtualInstanceNode" this]
            (:type this)
        )

        (#_"int" VirtualObjectNode'''entryCount-1 [#_"VirtualInstanceNode" this]
            (count (:fields this))
        )
    )

    (defn #_"ResolvedJavaField" VirtualInstanceNode''field-2 [#_"VirtualInstanceNode" this, #_"int" index]
        (nth (:fields this) index)
    )

    (defn #_"ResolvedJavaField[]" VirtualInstanceNode''getFields-1 [#_"VirtualInstanceNode" this]
        (:fields this)
    )

    (defn #_"int" VirtualInstanceNode''fieldIndex-2 [#_"VirtualInstanceNode" this, #_"ResolvedJavaField" field]
        ;; on average fields.length == ~6, so a linear search is fast enough
        (loop-when [#_"int" i 0] (< i (count (:fields this))) => -1
            (if (= (nth (:fields this) i) field)
                i
                (recur (inc i))
            )
        )
    )

    (defm VirtualInstanceNode VirtualObjectNode
        (#_"int" VirtualObjectNode'''entryIndexForOffset-3 [#_"VirtualInstanceNode" this, #_"long" constantOffset, #_"JavaKind" expectedEntryKind]
            (VirtualInstanceNode''fieldIndex-2 this, (#_"ResolvedJavaType" .findInstanceFieldWithOffset (:type this), constantOffset, expectedEntryKind))
        )

        (#_"JavaKind" VirtualObjectNode'''entryKind-2 [#_"VirtualInstanceNode" this, #_"int" index]
            (#_"ResolvedJavaField" .getJavaKind (nth (:fields this) index))
        )

        (#_"VirtualInstanceNode" VirtualObjectNode'''duplicate-1 [#_"VirtualInstanceNode" this]
            (VirtualInstanceNode'new-3 (:type this), (:fields this), (:hasIdentity this))
        )

        (#_"ValueNode" VirtualObjectNode'''getMaterializedRepresentation-4 [#_"VirtualInstanceNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks]
            (AllocatedObjectNode'new-1 this)
        )
    )
)

(class-ns VirtualBoxingNode [VirtualInstanceNode, VirtualObjectNode, ValueNode, Node, LIRLowerable]
    (defn #_"VirtualBoxingNode" VirtualBoxingNode'new-2 [#_"ResolvedJavaType" type, #_"JavaKind" boxingKind]
        (merge (VirtualBoxingNode'class.) (VirtualInstanceNode'new-2 type, false)
            (hash-map
                #_"JavaKind" :boxingKind boxingKind
            )
        )
    )

    (defm VirtualBoxingNode VirtualObjectNode
        (#_"VirtualBoxingNode" VirtualObjectNode'''duplicate-1 [#_"VirtualBoxingNode" this]
            (VirtualBoxingNode'new-2 (VirtualObjectNode'''type-1 this), (:boxingKind this))
        )

        (#_"ValueNode" VirtualObjectNode'''getMaterializedRepresentation-4 [#_"VirtualBoxingNode" this, #_"FixedNode" fixed, #_"ValueNode*" entries, #_"LockState" locks]
            (BoxNode'new-3 (nth entries 0), (VirtualObjectNode'''type-1 this), (:boxingKind this))
        )
    )

    (defn #_"ValueNode" VirtualBoxingNode''getBoxedValue-2 [#_"VirtualBoxingNode" this, #_"VirtualizerTool" tool]
        (VirtualizerTool'''getEntry-3 tool, this, 0)
    )
)

(class-ns VirtualState [Node]
    (defn #_"VirtualState" VirtualState'new-0 []
        (merge (VirtualState'class.) (Node'new-0))
    )
)

(class-ns EscapeObjectState [VirtualState, Node]
    (defn #_"EscapeObjectState" EscapeObjectState'new-1 [#_"VirtualObjectNode" object]
        (merge (EscapeObjectState'class.) (VirtualState'new-0)
            (hash-map
                ; @Input
                #_"VirtualObjectNode" :object object
            )
        )
    )

    (defm EscapeObjectState VirtualState
        (#_"boolean" VirtualState'''isPartOfThisState-2 [#_"EscapeObjectState" this, #_"VirtualState" state]
            (= this state)
        )

        (#_"void" VirtualState'''applyToVirtual-2 [#_"EscapeObjectState" this, #_"VirtualClosure" closure]
            (VirtualClosure'''apply-2 closure, this)
            nil
        )
    )
)

;;;
 ; This class encapsulated the materialized state of an escape analyzed object.
 ;;
(class-ns MaterializedObjectState [EscapeObjectState, VirtualState, Node]
    (defn #_"MaterializedObjectState" MaterializedObjectState'new-2 [#_"VirtualObjectNode" object, #_"ValueNode" materializedValue]
        (merge (MaterializedObjectState'class.) (EscapeObjectState'new-1 object)
            (hash-map
                ; @Input
                #_"ValueNode" :materializedValue materializedValue
            )
        )
    )

    (defm MaterializedObjectState VirtualState
        (#_"MaterializedObjectState" VirtualState'''duplicateWithVirtualState-1 [#_"MaterializedObjectState" this]
            (Graph''add-2 (:graph this), (MaterializedObjectState'new-2 (:object this), (:materializedValue this)))
        )

        (#_"void" VirtualState'''applyToNonVirtual-2 [#_"MaterializedObjectState" this, #_"NodeClosure<? super ValueNode>" closure]
            (NodeClosure'''apply-3 closure, this, (:materializedValue this))
            nil
        )
    )
)

;;;
 ; This class encapsulated the virtual state of an escape analyzed object.
 ;;
(class-ns VirtualObjectState [EscapeObjectState, VirtualState, Node]
    (defn #_"VirtualObjectState" VirtualObjectState'new-2 [#_"VirtualObjectNode" object, #_"ValueNode*" values]
        (merge (VirtualObjectState'class.) (EscapeObjectState'new-1 object)
            (hash-map
                ; @OptionalInput
                #_"NodeInputList<ValueNode>" :values (NodeInputList'new-2s (ร this), values)
            )
        )
    )

    (defm VirtualObjectState VirtualState
        (#_"VirtualObjectState" VirtualState'''duplicateWithVirtualState-1 [#_"VirtualObjectState" this]
            (Graph''add-2 (:graph this), (VirtualObjectState'new-2 (:object this), (:values this)))
        )

        (#_"void" VirtualState'''applyToNonVirtual-2 [#_"VirtualObjectState" this, #_"NodeClosure<? super ValueNode>" closure]
            (doseq [#_"ValueNode" value (:values this)]
                (when (some? value)
                    (NodeClosure'''apply-3 closure, this, value)
                )
            )
            nil
        )
    )
)

;;;
 ; The FrameState class encapsulates the frame state (i.e. local variables and operand stack) at a particular
 ; point in the abstract interpretation.
 ;
 ; This can be used as debug or deoptimization information.
 ;;
(class-ns FrameState [VirtualState, Node]
    ;;;
     ; Marker value for the second slot of values that occupy two local variable or expression stack slots.
     ; The marker value is used by the bytecode parser, but replaced with nil in the #values of the FrameState.
     ;;
    (ยง def #_"ValueNode" FrameState'TWO_SLOT_MARKER (TwoSlotMarker'new-0))

    (defn #_"FrameState" FrameState'new-9i [#_"FrameState" outerFrameState, #_"Bytecode" code, #_"int" bci, #_"int" localsSize, #_"int" stackSize, #_"int" lockSize, #_"boolean" duringCall, #_"MonitorIdNode*" monitorIds, #_"EscapeObjectState*" virtualObjectMappings]
        (when (some? code)
            ;; Make sure the bci is within range of the bytecodes. If the code size is 0 then allow any value, otherwise the
            ;; bci must be less than the code size. Any negative value is also allowed to represent special bytecode states.
            (let [
                #_"int" codeSize (Bytecode'''getCodeSize-1 code)
            ]
                (when (and (not (zero? codeSize)) (<= codeSize bci))
                    (throw! (str "bci " bci " is out of range for " (#_"ResolvedJavaMethod" .format (Bytecode'''getMethod-1 code), "%H.\n(%p)") " " codeSize " bytes"))
                )
            )
        )
        (let [
            #_"FrameState" this
                (merge (FrameState'class.) (VirtualState'new-0)
                    (hash-map
                        ;;;
                         ; Size of the local variables.
                         ;;
                        #_"int" :localsSize localsSize
                        ;;;
                         ; Current size (height) of the stack.
                         ;;
                        #_"int" :stackSize stackSize
                        #_"boolean" :duringCall duringCall
                        ; @OptionalInput
                        #_"FrameState" :outerFrameState outerFrameState
                        ;;;
                         ; Contains the locals, the expressions and the locked objects, in this order.
                         ;;
                        ; @OptionalInput
                        #_"NodeInputList<ValueNode>" :values nil
                        ; @Input
                        #_"NodeInputList<MonitorIdNode>" :monitorIds nil
                        ; @OptionalInput
                        #_"NodeInputList<EscapeObjectState>" :virtualObjectMappings nil
                        ;;;
                         ; The bytecode index to which this frame state applies.
                         ;;
                        #_"int" :bci bci
                        ;;;
                         ; The bytecode to which this frame state applies.
                         ;;
                        #_"Bytecode" :code code
                    )
                )
            this (assoc this :values (NodeInputList'new-2i this, (+ localsSize stackSize lockSize)))
            this
                (when (seq monitorIds) => this
                    (assoc this :monitorIds (NodeInputList'new-2s this, monitorIds))
                )
            this
                (when (seq virtualObjectMappings) => this
                    (assoc this :virtualObjectMappings (NodeInputList'new-2s this, virtualObjectMappings))
                )
        ]
            this
        )
    )

    (defn #_"FrameState" FrameState'new-9l [#_"FrameState" outerFrameState, #_"Bytecode" code, #_"int" bci, #_"List<ValueNode>" values, #_"int" localsSize, #_"int" stackSize, #_"boolean" duringCall, #_"MonitorIdNode*" monitorIds, #_"EscapeObjectState*" virtualObjectMappings]
        (let [
            #_"FrameState" this (merge (FrameState'class.) (FrameState'new-9i outerFrameState, code, bci, localsSize, stackSize, (- (count values) localsSize stackSize), duringCall, monitorIds, virtualObjectMappings))
        ]
            (dotimes [#_"int" i (count values)]
                (NodeList''initialize-3 (:values this), i, (nth values i))
            )
            this
        )
    )

    (defn #_"FrameState" FrameState'new-1 [#_"int" bci]
        (FrameState'new-9i nil, nil, bci, 0, 0, 0, false, nil, nil)
    )

    ;;;
     ; Creates a placeholder frame state with a single element on the stack representing a return
     ; value or thrown exception. This allows the parsing of an intrinsic to communicate the returned
     ; or thrown value in a {@link StateSplit#stateAfter() stateAfter} to the inlining call site.
     ;
     ; @param bci this must be BytecodeFrame#AFTER_BCI
     ;;
    (defn #_"FrameState" FrameState'new-2 [#_"int" bci, #_"ValueNode" returnValue]
        (let [
            #_"FrameState" this (merge (FrameState'class.) (FrameState'new-9i nil, nil, bci, 0, (#_"JavaKind" .getSlotCount (ValueNode''getStackKind-1 returnValue)), 0, false, nil, nil))
        ]
            (NodeList''initialize-3 (:values this), 0, returnValue)
            this
        )
    )

    (defn #_"FrameState" FrameState'new-9a [#_"FrameState" outerFrameState, #_"Bytecode" code, #_"int" bci, #_"ValueNode[]" locals, #_"ValueNode[]" stack, #_"int" stackSize, #_"ValueNode[]" locks, #_"List<MonitorIdNode>" monitorIds, #_"boolean" duringCall]
        (let [
            #_"FrameState" this (merge (FrameState'class.) (FrameState'new-9i outerFrameState, code, bci, (count locals), stackSize, (count locks), duringCall, monitorIds, nil))
            #_"int" index
                (loop-when-recur [index 0 #_"int" i 0] (< i (count locals)) [(inc index) (inc i)] => index
                    (let [
                        #_"ValueNode" value (nth locals i)
                    ]
                        (NodeList''initialize-3 (:values this), index, (when-not (= value FrameState'TWO_SLOT_MARKER) value))
                    )
                )
            index
                (loop-when-recur [index index #_"int" i 0] (< i (:stackSize this)) [(inc index) (inc i)] => index
                    (let [
                        #_"ValueNode" value (nth stack i)
                    ]
                        (NodeList''initialize-3 (:values this), index, (when-not (= value FrameState'TWO_SLOT_MARKER) value))
                    )
                )
        ]
            (loop-when-recur [index index #_"int" i 0] (< i (count locks)) [(inc index) (inc i)]
                (NodeList''initialize-3 (:values this), index, (nth locks i))
            )
            this
        )
    )

    (defn #_"FrameState" FrameState''setOuterFrameState-2 [#_"FrameState" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:outerFrameState this), x)
        (assoc this :outerFrameState x)
    )

    (defn #_"ResolvedJavaMethod" FrameState''getMethod-1 [#_"FrameState" this]
        (when (some? (:code this)) (Bytecode'''getMethod-1 (:code this)))
    )

    (defn #_"this" FrameState''addVirtualObjectMapping-2 [#_"FrameState" this, #_"EscapeObjectState" virtualObject]
        (let [
            this
                (when (nil? (:virtualObjectMappings this)) => this
                    (assoc this :virtualObjectMappings (NodeInputList'new-1 this))
                )
        ]
            (#_"List" .add (:virtualObjectMappings this), virtualObject)
            this
        )
    )

    (defn #_"int" FrameState''virtualObjectMappingCount-1 [#_"FrameState" this]
        (if (some? (:virtualObjectMappings this)) (count (:virtualObjectMappings this)) 0)
    )

    (defn #_"EscapeObjectState" FrameState''virtualObjectMappingAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:virtualObjectMappings this) i)
    )

    ;;;
     ; Gets a copy of this frame state.
     ;;
    (defn #_"FrameState" FrameState''duplicate-2 [#_"FrameState" this, #_"int" newBci]
        (Graph''add-2 (:graph this), (FrameState'new-9l (:outerFrameState this), (:code this), newBci, (:values this), (:localsSize this), (:stackSize this), (:duringCall this), (:monitorIds this), (:virtualObjectMappings this)))
    )

    ;;;
     ; Gets a copy of this frame state.
     ;;
    (defn #_"FrameState" FrameState''duplicate-1 [#_"FrameState" this]
        (FrameState''duplicate-2 this, (:bci this))
    )

    ;;;
     ; Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer
     ; FrameStates, VirtualObjectStates, ...).
     ;;
    (defm FrameState VirtualState
        (#_"FrameState" VirtualState'''duplicateWithVirtualState-1 [#_"FrameState" this]
            (let [
                #_"FrameState" newOuterFrameState (:outerFrameState this)
                newOuterFrameState (when (some? newOuterFrameState) (VirtualState'''duplicateWithVirtualState-1 newOuterFrameState))
                #_"ArrayList<EscapeObjectState>" newVirtualMappings
                    (when (some? (:virtualObjectMappings this))
                        (let [
                            newVirtualMappings (ArrayList.)
                            _
                                (doseq [#_"EscapeObjectState" state (:virtualObjectMappings this)]
                                    (#_"ArrayList" .add newVirtualMappings, (VirtualState'''duplicateWithVirtualState-1 state))
                                )
                        ]
                            newVirtualMappings
                        )
                    )
            ]
                (Graph''add-2 (:graph this), (FrameState'new-9l newOuterFrameState, (:code this), (:bci this), (:values this), (:localsSize this), (:stackSize this), (:duringCall this), (:monitorIds this), newVirtualMappings))
            )
        )
    )

    ;;;
     ; Creates a copy of this frame state with one stack element of type {@code popKind} popped from the stack.
     ;;
    (defn #_"FrameState" FrameState''duplicateModifiedDuringCall-3 [#_"FrameState" this, #_"int" newBci, #_"JavaKind" popKind]
        (FrameState''duplicateModified-7 this, (:graph this), newBci, true, popKind, nil, nil)
    )

    (defn #_"FrameState" FrameState''duplicateModifiedBeforeCall-5 [#_"FrameState" this, #_"int" newBci, #_"JavaKind" popKind, #_"JavaKind[]" pushedSlotKinds, #_"ValueNode[]" pushedValues]
        (FrameState''duplicateModified-7 this, (:graph this), newBci, false, popKind, pushedSlotKinds, pushedValues)
    )

    ;;;
     ; Creates a copy of this frame state with the top of stack replaced with with
     ; {@code pushedValue} which must be of type {@code popKind}.
     ;;
    (defn #_"FrameState" FrameState''duplicateModified-4 [#_"FrameState" this, #_"JavaKind" popKind, #_"JavaKind" pushedSlotKind, #_"ValueNode" pushedValue]
        (FrameState''duplicateModified-7 this, (:graph this), (:bci this), (:duringCall this), popKind, (into-array JavaKind [ pushedSlotKind ]), (into-array ValueNode'iface [ pushedValue ]))
    )

    ;;;
     ; Creates a copy of this frame state with one stack element of type popKind popped from the
     ; stack and the values in pushedValues pushed on the stack. The pushedValues will be formatted
     ; correctly in slot encoding: a long or double will be followed by a nil slot. The bci will be
     ; changed to newBci.
     ;;
    (defn #_"FrameState" FrameState''duplicateModified-7 [#_"FrameState" this, #_"Graph" graph, #_"int" newBci, #_"boolean" newDuringCall, #_"JavaKind" popKind, #_"JavaKind[]" pushedSlotKinds, #_"ValueNode[]" pushedValues]
        (let [
            #_"ArrayList<ValueNode>" copy
                (let [
                    copy (ArrayList. (#_"List" .subList (:values this), 0, (+ (:localsSize this) (:stackSize this))))
                ]
                    (when-not (= popKind JavaKind/Void)
                        (when (nil? (FrameState''stackAt-2 this, (dec (:stackSize this))))
                            (#_"ArrayList" .remove copy, (dec (count copy)))
                        )
                        (#_"ArrayList" .remove copy, (dec (count copy)))
                    )
                    copy
                )
        ]
            (when (some? pushedValues)
                (dotimes [#_"int" i (count pushedValues)]
                    (#_"ArrayList" .add copy, (nth pushedValues i))
                    (when (#_"JavaKind" .needsTwoSlots (nth pushedSlotKinds i))
                        (#_"ArrayList" .add copy, nil)
                    )
                )
            )
            (let [
                #_"int" newStackSize (- (count copy) (:localsSize this))
            ]
                (#_"ArrayList" .addAll copy, (#_"List" .subList (:values this), (+ (:localsSize this) (:stackSize this)), (count (:values this))))

                (Graph''add-2 graph, (FrameState'new-9l (:outerFrameState this), (:code this), newBci, copy, (:localsSize this), newStackSize, newDuringCall, (:monitorIds this), (:virtualObjectMappings this)))
            )
        )
    )

    ;;;
     ; Gets the number of locked monitors in this frame state.
     ;;
    (defn #_"int" FrameState''locksSize-1 [#_"FrameState" this]
        (- (count (:values this)) (:localsSize this) (:stackSize this))
    )

    ;;;
     ; Gets the number of locked monitors in this frame state and all {@linkplain #outerFrameState() outer} frame states.
     ;;
    (defn #_"int" FrameState''nestedLockDepth-1 [#_"FrameState" this]
        (loop-when-recur [#_"int" depth (FrameState''locksSize-1 this) #_"FrameState" outer (:outerFrameState this)]
                         (some? outer)
                         [(+ depth (FrameState''locksSize-1 outer)) (:outerFrameState outer)]
                      => depth
        )
    )

    ;;;
     ; Gets the value in the local variables at the specified index.
     ;
     ; @param i the index into the locals
     ; @return the instruction that produced the value for the specified local
     ;;
    #_unused
    (defn #_"ValueNode" FrameState''localAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:values this) i)
    )

    ;;;
     ; Get the value on the stack at the specified stack index.
     ;
     ; @param i the index into the stack, with {@code 0} being the bottom of the stack
     ; @return the instruction at the specified position in the stack
     ;;
    (defn #_"ValueNode" FrameState''stackAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:values this) (+ (:localsSize this) i))
    )

    ;;;
     ; Get the monitor owner at the specified index.
     ;
     ; @param i the index into the list of locked monitors.
     ; @return the lock owner at the given index
     ;;
    #_unused
    (defn #_"ValueNode" FrameState''lockAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:values this) (+ (:localsSize this) (:stackSize this) i))
    )

    ;;;
     ; Get the MonitorIdNode that corresponds to the locked object at the specified index.
     ;;
    #_unused
    (defn #_"MonitorIdNode" FrameState''monitorIdAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:monitorIds this) i)
    )

    (defm FrameState VirtualState
        (#_"void" VirtualState'''applyToNonVirtual-2 [#_"FrameState" this, #_"NodeClosure<? super ValueNode>" closure]
            (doseq [#_"ValueNode" value (:values this)]
                (when (some? value)
                    (NodeClosure'''apply-3 closure, this, value)
                )
            )
            (when (some? (:monitorIds this))
                (doseq [#_"MonitorIdNode" monitorId (:monitorIds this)]
                    (when (some? monitorId)
                        (NodeClosure'''apply-3 closure, this, monitorId)
                    )
                )
            )
            (when (some? (:virtualObjectMappings this))
                (doseq [#_"EscapeObjectState" state (:virtualObjectMappings this)]
                    (VirtualState'''applyToNonVirtual-2 state, closure)
                )
            )
            (when (some? (:outerFrameState this))
                (VirtualState'''applyToNonVirtual-2 (:outerFrameState this), closure)
            )
            nil
        )

        (#_"void" VirtualState'''applyToVirtual-2 [#_"FrameState" this, #_"VirtualClosure" closure]
            (VirtualClosure'''apply-2 closure, this)
            (when (some? (:virtualObjectMappings this))
                (doseq [#_"EscapeObjectState" state (:virtualObjectMappings this)]
                    (VirtualState'''applyToVirtual-2 state, closure)
                )
            )
            (when (some? (:outerFrameState this))
                (VirtualState'''applyToVirtual-2 (:outerFrameState this), closure)
            )
            nil
        )

        (#_"boolean" VirtualState'''isPartOfThisState-2 [#_"FrameState" this, #_"VirtualState" state]
            (or (= state this)
                (and (some? (:outerFrameState this)) (VirtualState'''isPartOfThisState-2 (:outerFrameState this), state))
                (loop [#_"ISeq" s (seq (:virtualObjectMappings this))]
                    (and (some? s)
                        (or (VirtualState'''isPartOfThisState-2 (first s), state)
                            (recur (next s))
                        )
                    )
                )
            )
        )
    )
)

(class-ns NodeIteratorClosure #_"<T>" []
    (defn #_"NodeIteratorClosure" NodeIteratorClosure'new-0 []
        (NodeIteratorClosure'class.)
    )
)

(class-ns ComputeLoopFrequenciesClosure [NodeIteratorClosure #_"<Double>"]
    (defn- #_"ComputeLoopFrequenciesClosure" ComputeLoopFrequenciesClosure'new-0 []
        (merge (ComputeLoopFrequenciesClosure'class.) (NodeIteratorClosure'new-0))
    )

    (def- #_"ComputeLoopFrequenciesClosure" ComputeLoopFrequenciesClosure'INSTANCE (ยง soon ComputeLoopFrequenciesClosure'new-0))

    (defm ComputeLoopFrequenciesClosure NodeIteratorClosure
        (#_"Double" NodeIteratorClosure'''processNode-3 [#_"ComputeLoopFrequenciesClosure" this, #_"FixedNode" node, #_"Double" currentState]
            ;; normal nodes never change the probability of a path
            currentState
        )

        (#_"Double" NodeIteratorClosure'''merge-3 [#_"ComputeLoopFrequenciesClosure" this, #_"AbstractMergeNode" merge, #_"List<Double>" states]
            ;; a merge has the sum of all predecessor probabilities
            (reduce + 0.0 states)
        )

        (#_"Double" NodeIteratorClosure'''afterSplit-3 [#_"ComputeLoopFrequenciesClosure" this, #_"AbstractBeginNode" node, #_"Double" oldState]
            ;; a control split splits up the probability
            (* oldState (ControlSplitNode'''probability-2 (:predecessor node), node))
        )

        (#_"EconomicMap<LoopExitNode, Double>" NodeIteratorClosure'''processLoop-3 [#_"ComputeLoopFrequenciesClosure" this, #_"LoopBeginNode" _loop, #_"Double" initialState]
            (let [
                #_"EconomicMap<LoopExitNode, Double>" exitStates (:exitStates (ReentrantNodeIterator'processLoop-3 this, _loop, 1.0))
                #_"double" exitProbability (reduce + 0.0 (vals exitStates))
                exitProbability (max ControlFlowGraph'MIN_PROBABILITY (min exitProbability 1.0))
                #_"double" loopFrequency (/ 1.0 exitProbability)
            ]
                (ยง ass! _loop (LoopBeginNode''setLoopFrequency-2 _loop, loopFrequency))

                (let [
                    #_"double" adjustmentFactor (* initialState loopFrequency)
                ]
                    (#_"EconomicMap" .replaceAll exitStates, (ร (exitNode, probability)  (ยง fun (ControlFlowGraph'multiplyProbabilities-2 probability, adjustmentFactor))))

                    exitStates
                )
            )
        )
    )

    ;;;
     ; Computes the frequencies of all loops in the given graph. This is done by performing a
     ; reverse postorder iteration and computing the probability of all fixed nodes. The combined
     ; probability of all exits of a loop can be used to compute the loop's expected frequency.
     ;;
    (defn #_"void" ComputeLoopFrequenciesClosure'compute-1 [#_"Graph" graph]
        (when (Graph''hasLoops-1 graph)
            (ReentrantNodeIterator'apply-3 ComputeLoopFrequenciesClosure'INSTANCE, (:start graph), 1.0)
        )
        nil
    )

    (ยง def #_"ComputeLoopFrequencyPhase" ComputeLoopFrequenciesClosure'PHASE_INSTANCE (ComputeLoopFrequencyPhase'new-0))
)

(class-ns FloatingReadClosure [NodeIteratorClosure #_"<MemoryMap0>"]
    (defn #_"FloatingReadClosure" FloatingReadClosure'new-3 [#_"{LoopBeginNode {LocationIdentity}}" modifiedInLoops, #_"boolean" createFloatingReads, #_"boolean" createMemoryMapNodes]
        (merge (FloatingReadClosure'class.) (NodeIteratorClosure'new-0)
            (hash-map
                #_"{LoopBeginNode {LocationIdentity}}" :modifiedInLoops modifiedInLoops
                #_"boolean" :createFloatingReads createFloatingReads
                #_"boolean" :createMemoryMapNodes createMemoryMapNodes
            )
        )
    )

    ;;;
     ; Improve the memory graph by re-wiring all usages of a MemoryAnchorNode to the real last access location.
     ;;
    (defn- #_"void" FloatingReadClosure'processAnchor-2 [#_"MemoryAnchorNode" anchor, #_"MemoryMap0" state]
        (doseq [#_"Node" node (:nodeUsages anchor)]
            (when (and (satisfies? MemoryAccess node) (= (:lastLocationAccess node) anchor))
                (MemoryAccess'''setLastLocationAccess-2 node, (MemoryMap'''getLastLocationAccess-2 state, (MemoryAccess'''getLocationIdentity-1 node)))
            )
        )

        (when (Node''hasNoUsages-1 anchor)
            (Graph''removeFixed-2 (:graph anchor), anchor)
        )
        nil
    )

    (defn- #_"void" FloatingReadClosure'processAccess-2 [#_"MemoryAccess" access, #_"MemoryMap0" state]
        (let [
            #_"LocationIdentity" location (MemoryAccess'''getLocationIdentity-1 access)
        ]
            (when-not (= location LocationIdentity'ANY)
                (MemoryAccess'''setLastLocationAccess-2 access, (MemoryMap'''getLastLocationAccess-2 state, location))
            )
        )
        nil
    )

    (defn- #_"void" FloatingReadClosure'processFloatable-2 [#_"FloatableAccessNode" accessNode, #_"MemoryMap0" state]
        (let [
            #_"LocationIdentity" location (MemoryAccess'''getLocationIdentity-1 accessNode)
        ]
            (when (FloatableAccessNode''canFloat-1 accessNode)
                (let [
                    #_"FloatingAccessNode" floatingNode (FloatableAccessNode'''asFloatingNode-2 accessNode, (MemoryMap'''getLastLocationAccess-2 state, location))
                ]
                    (ยง ass! (:graph accessNode) (Graph''replaceFixedWithFloating-3 (:graph accessNode), accessNode, floatingNode))
                )
            )
        )
        nil
    )

    (defn- #_"void" FloatingReadClosure'processIdentity-3 [#_"LocationIdentity" location, #_"MemoryCheckpoint" checkpoint, #_"MemoryMap0" state]
        (when (LocationIdentity''isAny-1 location)
            (#_"EconomicMap" .clear (:lastMemorySnapshot state))
        )
        (when-not (:immutable location)
            (#_"EconomicMap" .put (:lastMemorySnapshot state), location, checkpoint)
        )
        nil
    )

    (defn- #_"void" FloatingReadClosure'processCheckpoint-2s [#_"Single" checkpoint, #_"MemoryMap0" state]
        (FloatingReadClosure'processIdentity-3 (Single'''getLocationIdentity-1 checkpoint), checkpoint, state)
        nil
    )

    (defn- #_"void" FloatingReadClosure'processCheckpoint-2m [#_"Multi" checkpoint, #_"MemoryMap0" state]
        (doseq [#_"LocationIdentity" location (Multi'''getLocationIdentities-1 checkpoint)]
            (FloatingReadClosure'processIdentity-3 location, checkpoint, state)
        )
        nil
    )

    (defm FloatingReadClosure NodeIteratorClosure
        (#_"MemoryMap0" NodeIteratorClosure'''processNode-3 [#_"FloatingReadClosure" this, #_"FixedNode" node, #_"MemoryMap0" state]
            (if (satisfies? MemoryAnchorNode node)
                (do
                    (FloatingReadClosure'processAnchor-2 node, state)
                    state
                )
                (do
                    (when (satisfies? MemoryAccess node)
                        (FloatingReadClosure'processAccess-2 node, state)
                    )
                    (cond
                        (and (:createFloatingReads this) (satisfies? FloatableAccessNode node))
                            (FloatingReadClosure'processFloatable-2 node, state)
                        (satisfies? Single node)
                            (FloatingReadClosure'processCheckpoint-2s node, state)
                        (satisfies? Multi node)
                            (FloatingReadClosure'processCheckpoint-2m node, state)
                    )
                    (when (and (:createMemoryMapNodes this) (satisfies? ReturnNode node))
                        (ยง ass! node (ReturnNode''setMemoryMap-2 node, (Graph''add-2 (:graph node), (MemoryMapNode'new-1 (:lastMemorySnapshot state)))))
                    )
                    state
                )
            )
        )
    )

    (defn- #_"void" FloatingReadClosure'createMemoryPhi-4 [#_"LoopBeginNode" _loop, #_"MemoryMap0" initialState, #_"EconomicMap<LocationIdentity, MemoryPhiNode>" phis, #_"LocationIdentity" location]
        (let [
            #_"MemoryPhiNode" phi (Graph''add-2 (:graph _loop), (MemoryPhiNode'new-2 _loop, location))
        ]
            (PhiNode''addInput-2 phi, (MemoryMap'''getLastLocationAccess-2 initialState, location))
            (#_"EconomicMap" .put phis, location, phi)
        )
        nil
    )

    (defm FloatingReadClosure NodeIteratorClosure
        (#_"MemoryMap0" NodeIteratorClosure'''merge-3 [#_"FloatingReadClosure" this, #_"AbstractMergeNode" merge, #_"List<MemoryMap0>" states]
            (FloatingReadPhase'mergeMemoryMaps-2 merge, states)
        )

        (#_"MemoryMap0" NodeIteratorClosure'''afterSplit-3 [#_"FloatingReadClosure" this, #_"AbstractBeginNode" node, #_"MemoryMap0" oldState]
            (MemoryMap0'copy-1 oldState)
        )

        (#_"EconomicMap<LoopExitNode, MemoryMap0>" NodeIteratorClosure'''processLoop-3 [#_"FloatingReadClosure" this, #_"LoopBeginNode" _loop, #_"MemoryMap0" initialState]
            (let [
                #_"{LocationIdentity}" modifiedLocations (get (:modifiedInLoops this) _loop)
                modifiedLocations
                    (when (contains? modifiedLocations LocationIdentity'ANY) => modifiedLocations
                        ;; create phis for all locations if ANY is modified in the loop
                        (into modifiedLocations (keys (:lastMemorySnapshot initialState)))
                    )
                #_"EconomicMap<LocationIdentity, MemoryPhiNode>" phis (EconomicMap/create)
                _
                    (doseq [#_"LocationIdentity" location modifiedLocations]
                        (FloatingReadClosure'createMemoryPhi-4 _loop, initialState, phis, location)
                    )
            ]
                (#_"EconomicMap" .putAll (:lastMemorySnapshot initialState), phis)

                (let [
                    #_"NodeLoopInfo<MemoryMap0>" loopInfo (ReentrantNodeIterator'processLoop-3 this, _loop, initialState)
                    #_"UnmodifiableMapCursor<LoopEndNode, MemoryMap0>" endStateCursor (#_"EconomicMap" .getEntries (:endStates loopInfo))
                ]
                    (while (#_"UnmodifiableMapCursor" .advance endStateCursor)
                        (let [
                            #_"int" endIndex (AbstractMergeNode'''phiPredecessorIndex-2 _loop, (#_"UnmodifiableMapCursor" .getKey endStateCursor))
                            #_"UnmodifiableMapCursor<LocationIdentity, MemoryPhiNode>" phiCursor (#_"EconomicMap" .getEntries phis)
                        ]
                            (while (#_"UnmodifiableMapCursor" .advance phiCursor)
                                (let [
                                    #_"LocationIdentity" key (#_"UnmodifiableMapCursor" .getKey phiCursor)
                                    #_"PhiNode" phi (#_"UnmodifiableMapCursor" .getValue phiCursor)
                                ]
                                    (PhiNode''initializeValueAt-3 phi, endIndex, (MemoryMap'''getLastLocationAccess-2 (#_"UnmodifiableMapCursor" .getValue endStateCursor), key))
                                )
                            )
                        )
                    )
                    (:exitStates loopInfo)
                )
            )
        )
    )
)

(class-ns FrameStateAssignmentClosure [NodeIteratorClosure #_"<FrameState>"]
    (defn #_"FrameStateAssignmentClosure" FrameStateAssignmentClosure'new-0 []
        (merge (FrameStateAssignmentClosure'class.) (NodeIteratorClosure'new-0))
    )

    (defm FrameStateAssignmentClosure NodeIteratorClosure
        (#_"FrameState" NodeIteratorClosure'''processNode-3 [#_"FrameStateAssignmentClosure" this, #_"FixedNode" node, #_"FrameState" state]
            (when (and (satisfies? DeoptBefore node) (DeoptimizingNode'''canDeoptimize-1 node) (nil? (:stateBefore node)))
                (when (some? state) => (throw! (str "no FrameState at DeoptimizingNode " node))
                    (DeoptBefore'''setStateBefore-2 node, state)
                )
            )
            (let [
                state
                    (when (satisfies? StateSplit node) => state
                        (let [
                            #_"FrameState" stateAfter (:stateAfter node)
                        ]
                            (when (some? stateAfter) => state
                                (let [
                                    state
                                        (when-not (= (:bci stateAfter) BytecodeFrame/INVALID_FRAMESTATE_BCI)
                                            stateAfter
                                        )
                                ]
                                    (StateSplit'''setStateAfter-2 node, nil)
                                    state
                                )
                            )
                        )
                    )
            ]
                (when (and (satisfies? DeoptDuring node) (DeoptimizingNode'''canDeoptimize-1 node))
                    (when (some? state) => (throw! (str "no FrameState at DeoptimizingNode " node))
                        (DeoptDuring'''computeStateDuring-2 node, state)
                    )
                )
                (when (and (satisfies? DeoptAfter node) (DeoptimizingNode'''canDeoptimize-1 node) (nil? (:stateAfter node)))
                    (when (some? state) => (throw! (str "no FrameState at DeoptimizingNode " node))
                        (StateSplit'''setStateAfter-2 node, state)
                    )
                )
                state
            )
        )
    )

    (defn- #_"FrameState" FrameStateAssignmentClosure'singleFrameState-1 [#_"List<FrameState>" states]
        (let [
            #_"FrameState" singleState (nth states 0)
        ]
            (loop [#_"int" i 1]
                (if (< i (count states))
                    (when (= (nth states i) singleState)
                        (recur (inc i))
                    )
                    (when (and (some? singleState) (not= (:bci singleState) BytecodeFrame/INVALID_FRAMESTATE_BCI))
                        singleState
                    )
                )
            )
        )
    )

    (defm FrameStateAssignmentClosure NodeIteratorClosure
        (#_"FrameState" NodeIteratorClosure'''merge-3 [#_"FrameStateAssignmentClosure" this, #_"AbstractMergeNode" merge, #_"List<FrameState>" states]
            (or (FrameStateAssignmentClosure'singleFrameState-1 states) (:stateAfter merge))
        )

        (#_"FrameState" NodeIteratorClosure'''afterSplit-3 [#_"FrameStateAssignmentClosure" this, #_"AbstractBeginNode" node, #_"FrameState" oldState]
            oldState
        )

        (#_"EconomicMap<LoopExitNode, FrameState>" NodeIteratorClosure'''processLoop-3 [#_"FrameStateAssignmentClosure" this, #_"LoopBeginNode" _loop, #_"FrameState" initialState]
            (:exitStates (ReentrantNodeIterator'processLoop-3 this, _loop, initialState))
        )
    )
)

(class-ns NodeLoopInfo #_"<T>" []
    (defn #_"NodeLoopInfo" NodeLoopInfo'new-0 []
        (merge (NodeLoopInfo'class.)
            (hash-map
                #_"EconomicMap<LoopEndNode, T>" :endStates (EconomicMap/create)
                #_"EconomicMap<LoopExitNode, T>" :exitStates (EconomicMap/create)
            )
        )
    )
)

(class-ns NodeMap #_"<T>" [#_"EconomicMap" #_"<Node, T>"]
    (def- #_"int" NodeMap'MIN_REALLOC_SIZE 16)

    (defn #_"NodeMap" NodeMap'new-1g [#_"Graph" graph]
        (merge (NodeMap'class.)
            (hash-map
                #_"Graph" :graph graph
                #_"Object[]" :values (make-array Object (count (:gNodes graph)))
            )
        )
    )

    (defn #_"NodeMap" NodeMap'new-1m [#_"NodeMap<T>" copyFrom]
        (merge (NodeMap'class.)
            (hash-map
                #_"Graph" :graph (:graph copyFrom)
                #_"Object[]" :values (Arrays/copyOf (:values copyFrom), (count (:values copyFrom)))
            )
        )
    )

    (ยง override! #_"T" #_"Map." get [#_"NodeMap<T>" this, #_"Node" node]
        (ยง cast #_"T" (nth (:values this) (:nid node)))
    )

    (defn- #_"this" NodeMap''checkAndGrow-2 [#_"NodeMap<T>" this, #_"Node" node]
        (when (NodeMap''isNew-2 this, node) => this
            (assoc this :values (Arrays/copyOf (:values this), (max NodeMap'MIN_REALLOC_SIZE (quot (* (count (:gNodes (:graph this))) 3) 2))))
        )
    )

    (defn #_"T" NodeMap''getAndGrow-2 [#_"NodeMap<T>" this, #_"Node" node]
        (ยง ass! this (NodeMap''checkAndGrow-2 this, node))
        (ยง cast #_"T" (nth (:values this) (:nid node)))
    )

    (ยง override! #_"boolean" #_"Map." containsKey [#_"NodeMap<T>" this, #_"Node" node]
        (and (= (:graph node) (:graph this)) (some? (get this node)))
    )

    (defn #_"void" NodeMap''set-3 [#_"NodeMap<T>" this, #_"Node" node, #_"T" value]
        (aset (:values this) (:nid node) value)
        nil
    )

    (defn #_"this" NodeMap''setAndGrow-3 [#_"NodeMap<T>" this, #_"Node" node, #_"T" value]
        (let [
            this (NodeMap''checkAndGrow-2 this, node)
        ]
            (NodeMap''set-3 this, node, value)
            this
        )
    )

    ;;;
     ; @return the key for the entry at index {@code i}
     ;;
    (defn #_"Node" NodeMap''getKey-2 [#_"NodeMap<T>" this, #_"int" i]
        (nth (:gNodes (:graph this)) i)
    )

    (defn #_"boolean" NodeMap''isNew-2 [#_"NodeMap<T>" this, #_"Node" node]
        (<= (count (:values this)) (:nid node))
    )

    (ยง override! #_"Iterable<Node>" #_"UnmodifiableEconomicMap." getKeys [#_"NodeMap<T>" this]
        (let [
            #_"NodeMap" owner this
        ]
            (reify Iterable #_"<Node>"
                (#_"Iterator<Node>" iterator [#_"Iterable<Node>" this]
                    (let [
                        #_"int" i 0
                    ]
                        (reify Iterator #_"<Node>"
                            (defn- #_"void" Iterator'forward-0k []
                                (while (and (< i (count (:values owner))) (or (nil? (NodeMap''getKey-2 owner, i)) (nil? (nth (:values owner) i))))
                                    (ยง ass! i (inc i))
                                )
                                nil
                            )

                            (#_"boolean" hasNext [#_"Iterator<Node>" this]
                                (Iterator'forward-0k)
                                (< i (count (:values owner)))
                            )

                            (#_"Node" next [#_"Iterator<Node>" this]
                                (let [
                                    #_"Node" key (NodeMap''getKey-2 owner, i)
                                ]
                                    (ยง ass! i (inc i))
                                    (Iterator'forward-0k)
                                    key
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (ยง override! #_"Iterable<T>" #_"UnmodifiableEconomicMap." getValues [#_"NodeMap<T>" this]
        (let [
            #_"NodeMap" owner this
        ]
            (reify Iterable #_"<T>"
                (#_"Iterator<T>" iterator [#_"Iterable<T>" this]
                    (let [
                        #_"int" i 0
                    ]
                        (reify Iterator #_"<T>"
                            (defn- #_"void" Iterator'forward-0v []
                                (while (and (< i (count (:values owner))) (or (nil? (NodeMap''getKey-2 owner, i)) (nil? (nth (:values owner) i))))
                                    (ยง ass! i (inc i))
                                )
                                nil
                            )

                            (#_"boolean" hasNext [#_"Iterator<T>" this]
                                (Iterator'forward-0v)
                                (< i (count (:values owner)))
                            )

                            (#_"T" next [#_"Iterator<T>" this]
                                (let [
                                    #_"T" value (nth (:values owner) i)
                                ]
                                    (ยง ass! i (inc i))
                                    (Iterator'forward-0v)
                                    value
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (ยง override! #_"MapCursor<Node, T>" #_"UnmodifiableEconomicMap." getEntries [#_"NodeMap<T>" this]
        (let [
            #_"NodeMap" owner this
            #_"int" i -1
        ]
            (reify MapCursor #_"<Node, T>"
                (#_"boolean" advance [#_"MapCursor<Node, T>" this]
                    (ยง ass! i (inc i))
                    (while (and (< i (count (:values owner))) (or (nil? (nth (:values owner) i)) (nil? (NodeMap''getKey-2 owner, i))))
                        (ยง ass! i (inc i))
                    )
                    (< i (count (:values owner)))
                )

                (#_"Node" getKey [#_"MapCursor<Node, T>" this]
                    (NodeMap''getKey-2 owner, i)
                )

                (#_"T" getValue [#_"MapCursor<Node, T>" this]
                    (nth (:values owner) i)
                )
            )
        )
    )

    (ยง override! #_"T" #_"Map." put [#_"NodeMap<T>" this, #_"Node" key, #_"T" value]
        (let [
            #_"T" result (get this key)
        ]
            (NodeMap''set-3 this, key, value)
            result
        )
    )
)

(class-ns NodeWorkList [#_"Iterable" #_"<Node>"]
    (defn #_"NodeWorkList" NodeWorkList'new-2 [#_"Graph" graph, #_"boolean" fill?]
        (let [
            #_"NodeWorkList" this
                (merge (NodeWorkList'class.)
                    (hash-map
                        #_"Queue<Node>" :worklist (ArrayDeque.)
                    )
                )
        ]
            (when fill?
                (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                    (#_"Queue" .add (:worklist this), node)
                )
            )
            this
        )
    )

    (defn #_"void" NodeWorkList''addAll-2 [#_"NodeWorkList" this, #_"Node*" nodes]
        (doseq [#_"Node" node nodes]
            (when (Node''isAlive-1 node)
                (NodeWorkList'''add-2 this, node)
            )
        )
        nil
    )
)

(class-ns IterativeNodeWorkList [NodeWorkList, #_"Iterable" #_"<Node>"]
    (defn #_"IterativeNodeWorkList" IterativeNodeWorkList'new-3 [#_"Graph" graph, #_"boolean" fill?, #_"int" iterationLimitPerNode]
        (merge (IterativeNodeWorkList'class.) (NodeWorkList'new-2 graph, fill?)
            (hash-map
                #_"int" :iterationLimit (int (Long/min (* (Graph''getNodeCount-1 graph) (long iterationLimitPerNode)), Integer/MAX_VALUE))
                #_"NodeBitMap" :inQueue nil
            )
        )
    )

    (ยง override! #_"Iterator<Node>" #_"Iterable." iterator [#_"IterativeNodeWorkList" this]
        (let [
            #_"IterativeNodeWorkList" owner this
        ]
            (reify Iterator #_"<Node>"
                (defn- #_"void" Iterator'dropDeleted-0i []
                    (while (and (not (#_"Queue" .isEmpty (:worklist owner))) (Node''isDeleted-1 (#_"Queue" .peek (:worklist owner))))
                        (#_"Queue" .remove (:worklist owner))
                    )
                    nil
                )

                (#_"boolean" hasNext [#_"Iterator<Node>" this]
                    (Iterator'dropDeleted-0i)
                    (and (pos? (:iterationLimit owner)) (not (#_"Queue" .isEmpty (:worklist owner))))
                )

                (#_"Node" next [#_"Iterator<Node>" this]
                    (try
                        (when-not (pos? (:iterationLimit owner))
                            (throw (NoSuchElementException.))
                        )
                        (finally
                            (ยง ass owner (update owner :iterationLimit dec))
                        )
                    )
                    (Iterator'dropDeleted-0i)
                    (let [
                        #_"Node" node (#_"Queue" .remove (:worklist owner))
                    ]
                        (when (some? (:inQueue owner))
                            (ยง ass! (:inQueue owner) (NodeBitMap''clearAndGrow-2 (:inQueue owner), node))
                        )
                        node
                    )
                )
            )
        )
    )

    (defn- #_"this" IterativeNodeWorkList''inflateToBitMap-2 [#_"IterativeNodeWorkList" this, #_"Graph" graph]
        (let [
            this (assoc this :inQueue (NodeBitMap'new-1 graph))
        ]
            (doseq [#_"Node" queuedNode (:worklist this)]
                (when (Node''isAlive-1 queuedNode)
                    (NodeBitMap''mark-2 (:inQueue this), queuedNode)
                )
            )
            this
        )
    )

    (def- #_"int" IterativeNodeWorkList'EXPLICIT_BITMAP_THRESHOLD 10)

    (defm IterativeNodeWorkList NodeWorkList
        (#_"void" NodeWorkList'''add-2 [#_"IterativeNodeWorkList" this, #_"Node" node]
            (when (some? node)
                (when (and (nil? (:inQueue this)) (< IterativeNodeWorkList'EXPLICIT_BITMAP_THRESHOLD (#_"Queue" .size (:worklist this))))
                    (ยง ass! this (IterativeNodeWorkList''inflateToBitMap-2 this, (:graph node)))
                )
                (or
                    (if (some? (:inQueue this))
                        (when (NodeBitMap''isMarkedAndGrow-2 (:inQueue this), node)
                            :done
                        )
                        (loop-when [#_"ISeq" s (seq (:worklist this))] (some? s)
                            (when (= (first s) node) => (recur (next s))
                                :done
                            )
                        )
                    )
                    (do
                        (when (some? (:inQueue this))
                            (ยง ass! (:inQueue this) (NodeBitMap''markAndGrow-2 (:inQueue this), node))
                        )
                        (#_"Queue" .add (:worklist this), node)
                    )
                )
            )
            nil
        )
    )
)

(class-ns SingletonNodeWorkList [NodeWorkList, #_"Iterable" #_"<Node>"]
    (defn #_"SingletonNodeWorkList" SingletonNodeWorkList'new-1 [#_"Graph" graph]
        (merge (SingletonNodeWorkList'class.) (NodeWorkList'new-2 graph, false)
            (hash-map
                #_"NodeBitMap" :visited (NodeBitMap'new-1 graph)
            )
        )
    )

    (defm SingletonNodeWorkList NodeWorkList
        (#_"void" NodeWorkList'''add-2 [#_"SingletonNodeWorkList" this, #_"Node" node]
            (when (some? node)
                (when-not (NodeBitMap''isMarkedAndGrow-2 (:visited this), node)
                    (NodeBitMap''mark-2 (:visited this), node)
                    (#_"Queue" .add (:worklist this), node)
                )
            )
            nil
        )
    )

    (ยง override! #_"Iterator<Node>" #_"Iterable." iterator [#_"SingletonNodeWorkList" this]
        (let [
            #_"SingletonNodeWorkList" owner this
        ]
            (reify Iterator #_"<Node>"
                (defn- #_"void" Iterator'dropDeleted-0s []
                    (while (and (not (#_"Queue" .isEmpty (:worklist owner))) (Node''isDeleted-1 (#_"Queue" .peek (:worklist owner))))
                        (#_"Queue" .remove (:worklist owner))
                    )
                    nil
                )

                (#_"boolean" hasNext [#_"Iterator<Node>" this]
                    (Iterator'dropDeleted-0s)
                    (not (#_"Queue" .isEmpty (:worklist owner)))
                )

                (#_"Node" next [#_"Iterator<Node>" this]
                    (Iterator'dropDeleted-0s)
                    (#_"Queue" .remove (:worklist owner))
                )
            )
        )
    )
)

(class-ns NullCheckOptimizer [LIRPhase #_"<LIRPhaseContext>"] ;; PostAllocationPhase
    (defn #_"NullCheckOptimizer" NullCheckOptimizer'new-0 []
        (NullCheckOptimizer'class.)
    )

    (defm NullCheckOptimizer LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"NullCheckOptimizer" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (doseq [#_"Block" block (:codeEmittingOrder (:lir lirGenRes))]
                (when (some? block)
                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir lirGenRes), block)
                    ]
                        (when (seq ops)
                            (loop-when [#_"LIRInstruction" ins' (nth ops 0) #_"int" i 0] (< i (count ops))
                                (let [
                                    #_"LIRInstruction" ins (nth ops i)
                                    ins
                                        (when (and (satisfies? ImplicitNullCheck ins) (satisfies? NullCheck ins') (ImplicitNullCheck'''makeNullCheckFor-3 ins, (NullCheck'''getCheckedValue-1 ins'), (.implicitNullCheckLimit HotSpot'target))) => ins
                                            (#_"ArrayList" .remove ops, (dec i))
                                            (if (< i (count ops)) (nth ops i) ins)
                                        )
                                ]
                                    (recur ins (inc i))
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; This class describes the state of a virtual object while iterating over the graph.
 ; It describes the fields or array elements (called "entries") and the lock count if the object is
 ; still virtual. If the object was materialized, it contains the current materialized value.
 ;;
(class-ns ObjectState []
    (defn- #_"ObjectState" ObjectState'init-0 []
        (hash-map
            ;;;
             ; Users of this method are not allowed to change the entries of the returned array.
             ;;
            #_"ValueNode[]" :entries nil
            #_"ValueNode" :materializedValue nil
            #_"LockState" :locks nil
            #_"boolean" :ensureVirtualized false
            #_"EscapeObjectState" :cachedState nil
            ;;;
             ; ObjectStates are duplicated lazily, if this field is true then the state needs to
             ; be copied before it is modified.
             ;;
            #_"boolean" :copyOnWrite false
        )
    )

    (defn #_"ObjectState" ObjectState'new-3m [#_"ValueNode[]" entries, #_"List<MonitorIdNode>" locks, #_"boolean" ensureVirtualized]
        (let [
            #_"ObjectState" this (merge (ObjectState'class.) (ObjectState'new-3s entries, nil, ensureVirtualized))
        ]
            (loop-when-recur [this this #_"int" i (dec (count locks))]
                             (<= 0 i)
                             [(assoc this :locks (LockState'new-2 (nth locks i), (:locks this))) (dec i)]
                          => this
            )
        )
    )

    (defn #_"ObjectState" ObjectState'new-3s [#_"ValueNode[]" entries, #_"LockState" locks, #_"boolean" ensureVirtualized]
        (let [
            #_"ObjectState" this
                (merge (ObjectState'class.)
                    (ObjectState'init-0)
                )
            this (assoc this :entries entries)
            this (assoc this :locks locks)
            this (assoc this :ensureVirtualized ensureVirtualized)
        ]
            this
        )
    )

    (defn #_"ObjectState" ObjectState'new-3v [#_"ValueNode" materializedValue, #_"LockState" locks, #_"boolean" ensureVirtualized]
        (let [
            #_"ObjectState" this
                (merge (ObjectState'class.)
                    (ObjectState'init-0)
                )
            this (assoc this :materializedValue materializedValue)
            this (assoc this :locks locks)
            this (assoc this :ensureVirtualized ensureVirtualized)
        ]
            this
        )
    )

    (defn- #_"ObjectState" ObjectState'copy-1 [#_"ObjectState" other]
        (let [
            #_"ObjectState" this
                (merge (ObjectState'class.)
                    (ObjectState'init-0)
                )
            this (assoc this :entries (when (some? (:entries other)) (#_"Object" .clone (:entries other))))
            this (assoc this :materializedValue (:materializedValue other))
            this (assoc this :locks (:locks other))
            this (assoc this :cachedState (:cachedState other))
            this (assoc this :ensureVirtualized (:ensureVirtualized other))
        ]
            this
        )
    )

    (defn #_"EscapeObjectState" ObjectState''createEscapeObjectState-2 [#_"ObjectState" this, #_"VirtualObjectNode" virtual]
        (when (nil? (:cachedState this))
            (if (ObjectState''isVirtual-1 this)
                ;; Clear out entries that are default values anyway.
                ;;
                ;; TODO this should be propagated into ObjectState.entries, but that will take some more refactoring
                (let [
                    #_"ValueNode[]" entries (#_"Object" .clone (:entries this))
                ]
                    (dotimes [#_"int" i (count entries)]
                        (when (= (ValueNode''asJavaConstant-1 (nth entries i)) (JavaConstant/defaultForKind (#_"JavaKind" .getStackKind (VirtualObjectNode'''entryKind-2 virtual, i))))
                            (aset entries i nil)
                        )
                    )
                    (ยง ass! this (assoc this :cachedState (VirtualObjectState'new-2 virtual, entries)))
                )
                (ยง ass! this (assoc this :cachedState (MaterializedObjectState'new-2 virtual, (:materializedValue this))))
            )
        )
        (:cachedState this)
    )

    (defn #_"boolean" ObjectState''isVirtual-1 [#_"ObjectState" this]
        (nil? (:materializedValue this))
    )

    (defn #_"ValueNode" ObjectState''getEntry-2 [#_"ObjectState" this, #_"int" index]
        (nth (:entries this) index)
    )

    (defn #_"this" ObjectState''setEntry-3 [#_"ObjectState" this, #_"int" index, #_"ValueNode" value]
        (let [
            this (assoc this :cachedState nil)
        ]
            (aset (:entries this) index value)
            this
        )
    )

    (defn #_"this" ObjectState''escape-2 [#_"ObjectState" this, #_"ValueNode" materialized]
        (let [
            this (assoc this :materializedValue materialized)
            this (assoc this :entries nil)
            this (assoc this :cachedState nil)
        ]
            this
        )
    )

    (defn #_"this" ObjectState''updateMaterializedValue-2 [#_"ObjectState" this, #_"ValueNode" value]
        (let [
            this (assoc this :cachedState nil)
            this (assoc this :materializedValue value)
        ]
            this
        )
    )

    (defn #_"ObjectState" ObjectState''addLock-2 [#_"ObjectState" this, #_"MonitorIdNode" monitorId]
        (assoc this :locks (LockState'new-2 monitorId, (:locks this)))
    )

    (defn #_"MonitorIdNode" ObjectState''removeLock-1 [#_"ObjectState" this]
        (try
            (:monitorId (:locks this))
            (finally
                (ยง ass! this (assoc this :locks (:next (:locks this))))
            )
        )
    )

    (defn #_"boolean" ObjectState''hasLocks-1 [#_"ObjectState" this]
        (some? (:locks this))
    )

    (defn #_"boolean" ObjectState''locksEqual-2 [#_"ObjectState" this, #_"ObjectState" other]
        (loop-when-recur [#_"LockState" a (:locks this) #_"LockState" b (:locks other)]
                         (and (some? a) (some? b) (= (:monitorId a) (:monitorId b)))
                         [(:next a) (:next b)]
                      => (and (nil? a) (nil? b))
        )
    )

    (defn #_"ObjectState" ObjectState''setEnsureVirtualized-2 [#_"ObjectState" this, #_"boolean" ensureVirtualized]
        (assoc this :ensureVirtualized ensureVirtualized)
    )

    (ยง override! #_"boolean" #_"Object." equals [#_"ObjectState" this, #_"Object" that]
        (or (= this that)
            (and (some? that) (= (#_"Object" .getClass this) (#_"Object" .getClass that))
                (Arrays/equals (:entries this), (:entries that))
                (ObjectState''locksEqual-2 this, that)
                (if (nil? (:materializedValue this))
                    (nil? (:materializedValue that))
                    (= (:materializedValue this) (:materializedValue that))
                )
            )
        )
    )

    (defn #_"this" ObjectState''share-1 [#_"ObjectState" this]
        (ยง ass this (assoc this :copyOnWrite true))
        this
    )
)

(class-ns OperandModeAnnotation []
    (defn #_"OperandModeAnnotation" OperandModeAnnotation'new-0 []
        (merge (OperandModeAnnotation'class.)
            (hash-map
                #_"ArrayList<ValueFieldInfo>" :values (ArrayList.)
                ;;;
                 ; Number of non-array fields in #values.
                 ;;
                #_"int" :directCount 0
            )
        )
    )
)

(class-ns OperandSize []
    (ยง enum OperandSize'BYTE
        (ยง proxy #_"OperandSize" (OperandSize'new-2 1, AMD64Kind/BYTE)
            (#_"void" OperandSize'''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitByte-2 asm, imm)
                nil
            )
        )
    )

    (ยง enum OperandSize'WORD
        (ยง proxy #_"OperandSize" (OperandSize'new-3 2, AMD64Kind/WORD, 0x66)
            (#_"void" OperandSize'''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitShort-2 asm, imm)
                nil
            )
        )
    )

    (ยง enum OperandSize'DWORD
        (ยง proxy #_"OperandSize" (OperandSize'new-2 4, AMD64Kind/DWORD)
            (#_"void" OperandSize'''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitInt-2 asm, imm)
                nil
            )
        )
    )

    (ยง enum OperandSize'QWORD
        (ยง proxy #_"OperandSize" (OperandSize'new-2 8, AMD64Kind/QWORD)
            (#_"void" OperandSize'''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitInt-2 asm, imm)
                nil
            )
        )
    )

    (defn #_"OperandSize" OperandSize'new-3 [#_"int" bytes, #_"AMD64Kind" kind, #_"int" sizePrefix]
        (merge (OperandSize'class.)
            (hash-map
                #_"int" :bytes bytes
                #_"AMD64Kind" :kind kind
                #_"int" :sizePrefix sizePrefix
            )
        )
    )

    (defn #_"OperandSize" OperandSize'new-2 [#_"int" bytes, #_"AMD64Kind" kind]
        (OperandSize'new-3 bytes, kind, 0)
    )
)

(class-ns OptimisticOptimizations []
    (defn #_"OptimisticOptimizations" OptimisticOptimizations'new-1 [#_"Set<Optimization>" enabledOpts]
        (merge (OptimisticOptimizations'class.)
            (hash-map
                #_"Set<Optimization>" :enabledOpts enabledOpts
            )
        )
    )

    (ยง def #_"OptimisticOptimizations" OptimisticOptimizations'ALL (OptimisticOptimizations'new-1 (EnumSet/allOf Optimization)))
    (ยง def #_"OptimisticOptimizations" OptimisticOptimizations'NONE (OptimisticOptimizations'new-1 (EnumSet/noneOf Optimization)))

    (defn #_"boolean" OptimisticOptimizations''removeNeverExecutedCode-1 [#_"OptimisticOptimizations" this]
        (and GraalOptions'removeNeverExecutedCode (contains? (:enabledOpts this) Optimization'RemoveNeverExecutedCode))
    )

    (defn #_"boolean" OptimisticOptimizations''devirtualizeInvokes-1 [#_"OptimisticOptimizations" this]
        (and GraalOptions'optDevirtualizeInvokesOptimistically (contains? (:enabledOpts this) Optimization'UseTypeCheckedInlining))
    )

    (defn #_"boolean" OptimisticOptimizations''useLoopLimitChecks-1 [#_"OptimisticOptimizations" this]
        (and GraalOptions'useLoopLimitChecks (contains? (:enabledOpts this) Optimization'UseLoopLimitChecks))
    )

    (defn #_"boolean" OptimisticOptimizations''lessOptimisticThan-2 [#_"OptimisticOptimizations" this, #_"OptimisticOptimizations" other]
        (loop [#_"ISeq" s (seq (Optimization'values-0))]
            (and (some? s)
                (let [
                    #_"Optimization" opt (first s)
                ]
                    (or (and (not (contains? (:enabledOpts this) opt)) (contains? (:enabledOpts other) opt))
                        (recur (next s))
                    )
                )
            )
        )
    )
)

(class-ns PhaseContext []
    (defn #_"PhaseContext" PhaseContext'new-1 [#_"OptimisticOptimizations" optimisticOpts]
        (merge (PhaseContext'class.)
            (hash-map
                #_"OptimisticOptimizations" :optimisticOpts optimisticOpts
            )
        )
    )
)

;;;
 ; A compiler phase that can apply an ordered collection of phases to a graph.
 ;;
(class-ns PhaseSuite [Phase]
    (defn #_"PhaseSuite" PhaseSuite'new-0 []
        (merge (PhaseSuite'class.)
            (hash-map
                #_"List<Phase>" :phases (ArrayList.)
            )
        )
    )

    (defn #_"void" PhaseSuite''appendPhase-2 [#_"PhaseSuite" this, #_"Phase" phase]
        (#_"List" .add (:phases this), phase)
        nil
    )

    (defn- #_"boolean" PhaseSuite'findNextPhase-3 [#_"ListIterator<Phase>" it, #_"Class<? implements Phase>" phaseClass, #_"boolean" recursive?]
        (loop []
            (and (#_"ListIterator" .hasNext it)
                (let [
                    #_"Phase" phase (#_"ListIterator" .next it)
                ]
                    (cond
                        (#_"Class" .isInstance phaseClass, phase)     true
                        (and recursive? (satisfies? PhaseSuite phase)) (or (some? (PhaseSuite''findPhase-3 phase, phaseClass, true)) (recur))
                        :else                                         (recur)
                    )
                )
            )
        )
    )

    ;;;
     ; Returns a ListIterator at the position of the first phase which is an instance of {@code phaseClass} or,
     ; if {@code recursive} is true, is a PhaseSuite containing a phase which is an instance of {@code phaseClass}.
     ; This method returns nil if no such phase can be found.
     ;
     ; Calling ListIterator#previous() would return the phase or phase suite that was found.
     ;
     ; @param phaseClass the type of phase to look for
     ; @param recursive whether to recursively look into phase suites.
     ;;
    (defn #_"ListIterator<Phase>" PhaseSuite''findPhase-3 [#_"PhaseSuite" this, #_"Class<? implements Phase>" phaseClass, #_"boolean" recursive?]
        (let [
            #_"ListIterator<Phase>" it (#_"List" .listIterator (:phases this))
        ]
            (when (PhaseSuite'findNextPhase-3 it, phaseClass, recursive?) it)
        )
    )

    ;;;
     ; Returns a ListIterator at the position of the first phase which is an instance of {@code phaseClass}
     ; or nil if no such phase can be found.
     ;
     ; Calling ListIterator#previous() would return the phase that was found.
     ;
     ; @param phaseClass the type of phase to look for.
     ;;
    (defn #_"ListIterator<Phase>" PhaseSuite''findPhase-2 [#_"PhaseSuite" this, #_"Class<? implements Phase>" phaseClass]
        (PhaseSuite''findPhase-3 this, phaseClass, false)
    )

    (defm PhaseSuite Phase
        (#_"Graph" Phase'''run-3 [#_"PhaseSuite" this, #_"Graph" graph, #_"PhaseContext" context]
            (reduce #(Phase'''run-3 %2, %1, context) graph (:phases this))
        )
    )
)

(class-ns HighTier [PhaseSuite, Phase]
    (defn #_"HighTier" HighTier'new-0 []
        (let [
            #_"HighTier" this (merge (HighTier'class.) (PhaseSuite'new-0))
            #_"CanonicalizerPhase" canonicalizer (CanonicalizerPhase'new-0)
            #_"LoopPolicies" loopPolicies (DefaultLoopPolicies'new-0)
        ]
            (PhaseSuite''appendPhase-2 this, canonicalizer)
            (when GraalOptions'inline
                (PhaseSuite''appendPhase-2 this, (InliningPhase'new-1 canonicalizer))
                (PhaseSuite''appendPhase-2 this, (DeadCodeEliminationPhase'new-1 Optionality'Optional))
            )
            (when GraalOptions'optConvertDeoptsToGuards
                (PhaseSuite''appendPhase-2 this, (IncrementalCanonicalizerPhase'new-2 canonicalizer, (ConvertDeoptimizeToGuardPhase'new-0)))
            )
            (when GraalOptions'conditionalElimination
                (PhaseSuite''appendPhase-2 this, (IterativeConditionalEliminationPhase'new-2 canonicalizer, false))
            )
            (when GraalOptions'fullUnroll
                (PhaseSuite''appendPhase-2 this, (LoopFullUnrollPhase'new-2 canonicalizer, loopPolicies))
            )
            (when GraalOptions'optLoopTransform
                (when GraalOptions'loopPeeling
                    (PhaseSuite''appendPhase-2 this, (LoopPeelingPhase'new-1 loopPolicies))
                )
                (when GraalOptions'loopUnswitch
                    (PhaseSuite''appendPhase-2 this, (LoopUnswitchingPhase'new-1 loopPolicies))
                )
            )
            (PhaseSuite''appendPhase-2 this, canonicalizer)
            (when GraalOptions'partialEscapeAnalysis
                (PhaseSuite''appendPhase-2 this, (PartialEscapePhase'new-2 true, canonicalizer))
            )
            (when GraalOptions'optReadElimination
                (PhaseSuite''appendPhase-2 this, (EarlyReadEliminationPhase'new-1 canonicalizer))
            )
            (PhaseSuite''appendPhase-2 this, (RemoveValueProxyPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (LoweringPhase'new-2 canonicalizer, LoweringStage'HIGH_TIER))
            this
        )
    )
)

;;;
 ; A phase suite that applies canonicalization to a graph after all
 ; phases in the suite have been applied if any of the phases changed the graph.
 ;;
(class-ns IncrementalCanonicalizerPhase [PhaseSuite, Phase]
    (defn #_"IncrementalCanonicalizerPhase" IncrementalCanonicalizerPhase'new-1 [#_"CanonicalizerPhase" canonicalizer]
        (merge (IncrementalCanonicalizerPhase'class.) (PhaseSuite'new-0)
            (hash-map
                #_"CanonicalizerPhase" :canonicalizer canonicalizer
            )
        )
    )

    (defn #_"IncrementalCanonicalizerPhase" IncrementalCanonicalizerPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"Phase" phase]
        (let [
            #_"IncrementalCanonicalizerPhase" this (merge (IncrementalCanonicalizerPhase'class.) (IncrementalCanonicalizerPhase'new-1 canonicalizer))
        ]
            (PhaseSuite''appendPhase-2 this, phase)
            this
        )
    )

    ; @SuppressWarnings("try")
    (defm IncrementalCanonicalizerPhase Phase
        (#_"Graph" Phase'''run-3 [#_"IncrementalCanonicalizerPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
                graph
                    (try (ยง with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                        (Phase'''run-3 (ยง super #_"PhaseSuite"), graph, context)
                    )
            ]
                (when (seq (:nodes listener))
                    (CanonicalizerPhase''applyIncremental-3i (:canonicalizer this), graph, (:nodes listener))
                )
                graph
            )
        )
    )
)

(class-ns LowTier [PhaseSuite, Phase]
    (defn #_"LowTier" LowTier'new-0 []
        (let [
            #_"LowTier" this (merge (LowTier'class.) (PhaseSuite'new-0))
        ]
            (PhaseSuite''appendPhase-2 this, (LoweringPhase'new-2 (CanonicalizerPhase'new-0), LoweringStage'LOW_TIER))
            (PhaseSuite''appendPhase-2 this, (ExpandLogicPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (FixReadsPhase'new-1 (SchedulePhase'new-1 (if GraalOptions'stressTestEarlyReads SchedulingStrategy'EARLIEST SchedulingStrategy'LATEST_OUT_OF_LOOPS))))

            (PhaseSuite''appendPhase-2 this, (CanonicalizerPhase'new-0))

            (PhaseSuite''appendPhase-2 this, (UseTrappingNullChecksPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (DeadCodeEliminationPhase'new-1 Optionality'Required))
            (PhaseSuite''appendPhase-2 this, (PropagateDeoptimizeProbabilityPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (SchedulePhase'new-1 SchedulingStrategy'FINAL_SCHEDULE))
            this
        )
    )
)

(class-ns MidTier [PhaseSuite, Phase]
    (defn #_"MidTier" MidTier'new-0 []
        (let [
            #_"MidTier" this (merge (MidTier'class.) (PhaseSuite'new-0))
            #_"CanonicalizerPhase" canonicalizer (CanonicalizerPhase'new-0)
            #_"LoopPolicies" loopPolicies (DefaultLoopPolicies'new-0)
        ]
            (PhaseSuite''appendPhase-2 this, (LockEliminationPhase'new-0))
            (when GraalOptions'optFloatingReads
                (PhaseSuite''appendPhase-2 this, (IncrementalCanonicalizerPhase'new-2 canonicalizer, (FloatingReadPhase'new-0)))
            )
            (when GraalOptions'conditionalElimination
                (PhaseSuite''appendPhase-2 this, (IterativeConditionalEliminationPhase'new-2 canonicalizer, true))
            )
            (PhaseSuite''appendPhase-2 this, (LoopSafepointEliminationPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (LoopSafepointInsertionPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (GuardLoweringPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (LoweringPhase'new-2 canonicalizer, LoweringStage'MID_TIER))
            (PhaseSuite''appendPhase-2 this, (FrameStateAssignmentPhase'new-0))
            (when GraalOptions'optLoopTransform
                (when GraalOptions'partialUnroll
                    (PhaseSuite''appendPhase-2 this, (LoopPartialUnrollPhase'new-2 loopPolicies, canonicalizer))
                )
            )
            (when GraalOptions'reassociateInvariants
                (PhaseSuite''appendPhase-2 this, (ReassociateInvariantPhase'new-0))
            )
            (when GraalOptions'optDeoptimizationGrouping
                (PhaseSuite''appendPhase-2 this, (DeoptimizationGroupingPhase'new-0))
            )
            (PhaseSuite''appendPhase-2 this, canonicalizer)
            this
        )
    )
)

(class-ns PhiInfoElement []
    (defn #_"PhiInfoElement" PhiInfoElement'new-0 []
        (merge (PhiInfoElement'class.)
            (hash-map
                #_"EconomicMap<EndNode, InfoElement>" :infoElements nil
            )
        )
    )

    (defn #_"this" PhiInfoElement''set-3 [#_"PhiInfoElement" this, #_"EndNode" end, #_"InfoElement" infoElement]
        (let [
            this
                (when (nil? (:infoElements this)) => this
                    (assoc this :infoElements (EconomicMap/create))
                )
        ]
            (#_"EconomicMap" .put (:infoElements this), end, infoElement)
            this
        )
    )

    (defn #_"InfoElement" PhiInfoElement''get-2 [#_"PhiInfoElement" this, #_"EndNode" end]
        (when (some? (:infoElements this))
            (get (:infoElements this) end)
        )
    )
)

(class-ns Plugins []
    (defn #_"Plugins" Plugins'new-0 []
        (merge (Plugins'class.)
            (hash-map
                #_"TypePlugin*" :typePlugins nil
                #_"NodePlugin*" :nodePlugins nil
                #_"InlineInvokePlugin*" :inlineInvokePlugins nil
            )
        )
    )

    (defn- #_"Plugins" Plugins''appendTypePlugin-2         [#_"Plugins" this, #_"TypePlugin"         plugin] (update this :typePlugins         #(conj (vec %) plugin)))
    (defn- #_"Plugins" Plugins''appendNodePlugin-2         [#_"Plugins" this, #_"NodePlugin"         plugin] (update this :nodePlugins         #(conj (vec %) plugin)))
    (defn- #_"Plugins" Plugins''appendInlineInvokePlugin-2 [#_"Plugins" this, #_"InlineInvokePlugin" plugin] (update this :inlineInvokePlugins #(conj (vec %) plugin)))

    ;;;
     ; Creates a new set of plugins.
     ;;
    (defn #_"Plugins" Plugins'create-0 []
        (let [
            #_"Plugins" this (Plugins'new-0)
            #_"HotSpotNodePlugin" nodePlugin (HotSpotNodePlugin'new-1 (WordOperationPlugin'new-0))
            this (Plugins''appendTypePlugin-2 this, nodePlugin)
            this (Plugins''appendNodePlugin-2 this, nodePlugin)
            this (Plugins''appendInlineInvokePlugin-2 this, HotSpot'replacements)
            this
                (when GraalOptions'inlineDuringParsing => this
                    (Plugins''appendInlineInvokePlugin-2 this, (InlineDuringParsingPlugin'new-0))
                )
        ]
            this
        )
    )

    (defn #_"Stamp" Plugins''getOverridingStamp-4 [#_"Plugins" this, #_"BytecodeParser" parser, #_"JavaType" type, #_"boolean" never-nil?]
        (loop-when [#_"ISeq" s (seq (:typePlugins this))] (some? s)
            (or (TypePlugin'''interceptType-4 (first s), parser, type, never-nil?)
                (recur (next s))
            )
        )
    )
)

;;;
 ; Describes an edge slot for a NodeClass.
 ;;
(class-ns Position []
    (defn #_"Position" Position'new-3 [#_"Edges" edges, #_"int" index, #_"int" subIndex]
        (merge (Position'class.)
            (hash-map
                ;;;
                 ; The edges in which this position lies.
                 ;;
                #_"Edges" :edges edges
                ;;;
                 ; Index of the Node or NodeList field denoted by this position.
                 ;;
                #_"int" :index index
                ;;;
                 ; Index within a NodeList if #index denotes a NodeList field otherwise Node#NOT_ITERABLE.
                 ;;
                #_"int" :subIndex subIndex
            )
        )
    )

    (defn #_"Node" Position''get-2 [#_"Position" this, #_"Node" node]
        (if (< (:index this) (:directCount (:edges this)))
            (Edges'getNode-3 node, (:offsets (:edges this)), (:index this))
            (nth (Edges'getNodeList-3 node, (:offsets (:edges this)), (:index this)) (:subIndex this))
        )
    )

    (defn #_"InputType" Position''getInputType-1 [#_"Position" this]
        (InputEdges''getInputType-2 (:edges this), (:index this))
    )

    (defn #_"void" Position''set-3 [#_"Position" this, #_"Node" node, #_"Node" value]
        (if (< (:index this) (:directCount (:edges this)))
            (Edges''setNode-4 (:edges this), node, (:index this), value)
            (#_"List" .set (Edges'getNodeList-3 node, (:offsets (:edges this)), (:index this)), (:subIndex this), value)
        )
        nil
    )

    (defn #_"void" Position''initialize-3 [#_"Position" this, #_"Node" node, #_"Node" value]
        (if (< (:index this) (:directCount (:edges this)))
            (Edges''initializeNode-4 (:edges this), node, (:index this), value)
            (NodeList''initialize-3 (Edges'getNodeList-3 node, (:offsets (:edges this)), (:index this)), (:subIndex this), value)
        )
        nil
    )
)

(class-ns ProcessFrame []
    (defn #_"ProcessFrame" ProcessFrame'new-5 [#_"ProcessFrame" parent, #_"LoweringRound" round, #_"Block" block, #_"NodeBitMap" activeGuards, #_"AnchoringNode" anchor]
        (merge (ProcessFrame'class.)
            (hash-map
                #_"ProcessFrame" :parent parent
                #_"Block" :block block
                #_"Block" :dominated (:firstDominated block)
                #_"Block" :alwaysReachedBlock (:postdominator block)
                #_"LoweringRound" :round round
                #_"NodeBitMap" :activeGuards activeGuards
                #_"AnchoringNode" :anchor anchor
            )
        )
    )

    (defn #_"ProcessFrame" ProcessFrame''preprocess-1 [#_"ProcessFrame" this]
        (assoc this :anchor (LoweringRound''process-4 (:round this), (:block this), (:activeGuards this), (:anchor this)))
    )

    (defn #_"ProcessFrame" ProcessFrame''enter-2 [#_"ProcessFrame" this, #_"Block" block]
        (ProcessFrame'new-5 this, (:round this), block, (:activeGuards this), (:beginNode block))
    )

    (defn #_"ProcessFrame" ProcessFrame''enterAlwaysReached-2 [#_"ProcessFrame" this, #_"Block" block]
        (let [
            #_"AnchoringNode" anchor
                (when (and (some? (:parent this)) (not= (:loop block) (:loop (:block (:parent this)))) (not (Block''isLoopHeader-1 block))) => (:anchor this)
                    ;; We are exiting a loop => cannot reuse the anchor without inserting loop proxies.
                    (:beginNode block)
                )
        ]
            (ProcessFrame'new-5 this, (:round this), block, (:activeGuards this), anchor)
        )
    )

    (defn #_"void" ProcessFrame''postprocess-1 [#_"ProcessFrame" this]
        (when (and (= (:anchor this) (:beginNode (:block this))) GraalOptions'optEliminateGuards)
            (doseq [#_"GuardNode" guard (filter #(satisfies? GuardNode %) (:nodeUsages (:anchor this)))]
                (when (NodeBitMap''isMarkedAndGrow-2 (:activeGuards this), guard)
                    (NodeBitMap''clear-2 (:activeGuards this), guard)
                )
            )
        )
        nil
    )
)

;;;
 ; This phase will make sure that the branch leading towards this deopt has 0.0 probability.
 ;;
(class-ns PropagateDeoptimizeProbabilityPhase [Phase]
    (defn #_"PropagateDeoptimizeProbabilityPhase" PropagateDeoptimizeProbabilityPhase'new-0 []
        (PropagateDeoptimizeProbabilityPhase'class.)
    )

    (defm PropagateDeoptimizeProbabilityPhase Phase
        (#_"Graph" Phase'''run-3 [#_"PropagateDeoptimizeProbabilityPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (let [
                ;; Mark all control flow nodes that are post-dominated by a deoptimization.
                #_"{ControlSplitNode {AbstractBeginNode}}" splits
                    (loop-when [splits {} #_"ISeq" s (seq (Graph''getNodes-2 graph, AbstractDeoptimizeNode))] (some? s) => splits
                        (let [
                            splits
                                (loop-when [splits splits #_"Node*" stack (list (AbstractBeginNode'prevBegin-1 (first s)))] (seq stack) => splits
                                    (let [
                                        [#_"AbstractBeginNode" begin & stack] stack
                                        #_"FixedNode" fixed (:predecessor begin)
                                        [splits stack]
                                            (when (some? fixed) => [splits stack] ;; Can happen for start node.
                                                (condp satisfies? fixed
                                                    AbstractMergeNode
                                                        [splits (into stack (map AbstractBeginNode'prevBegin-1 (:ends fixed)))]
                                                    ControlSplitNode
                                                        (if (= (ControlSplitNode'''getSuccessorCount-1 fixed) (dec (count (get splits fixed))))
                                                            ;; All successors of this split lead to deopt, propagate reachability further upwards.
                                                            [(dissoc splits fixed) (cons (AbstractBeginNode'prevBegin-1 (:predecessor fixed)) stack)]
                                                            [(update splits fixed #(conj (apply hash-set %) begin)) stack]
                                                        )
                                                    [splits (cons (AbstractBeginNode'prevBegin-1 fixed) stack)]
                                                )
                                            )
                                    ]
                                        (recur splits stack)
                                    )
                                )
                        ]
                            (recur splits (next s))
                        )
                    )
            ]
                ;; Make sure the probability on the path towards the deoptimization is 0.0.
                (doseq [[#_"ControlSplitNode" split _] splits #_"AbstractBeginNode" begin _]
                    (when-not (= (ControlSplitNode'''probability-2 split, begin) 0.0)
                        (ControlSplitNode'''setProbability-3 split, begin, 0.0)
                    )
                )
                graph
            )
        )
    )
)

(class-ns RMEOptimization []
    (defn #_"RMEOptimization" RMEOptimization'new-1 [#_"FrameMap" frameMap]
        (merge (RMEOptimization'class.)
            (hash-map
                #_"EconomicMap<Block, BlockStates>" :blockData (EconomicMap/create)
                #_"RegisterArray" :callerSaveRegs nil
                ;;;
                 ; Contains the register number for registers which can be optimized and -1 for the others.
                 ;;
                #_"int[]" :eligibleRegs nil
                ;;;
                 ; A map from the StackSlot {@link #getOffset offset} to an index into the state.
                 ; StackSlots of different kinds that map to the same location will map to the same index.
                 ;;
                #_"EconomicMap<Integer, Integer>" :stackIndices (EconomicMap/create)
                #_"int" :numRegs 0
                #_"FrameMap" :frameMap frameMap
            )
        )
    )

    (defn- #_"int" RMEOptimization''getOffset-2 [#_"RMEOptimization" this, #_"StackSlot" stackSlot]
        (#_"StackSlot" .getOffset stackSlot, (FrameMap''totalFrameSize-1 (:frameMap this)))
    )

    ;;;
     ; Returns true for a move instruction which is a candidate for elimination.
     ;;
    (defn- #_"boolean" RMEOptimization'isEligibleMove-1 [#_"LIRInstruction" op]
        (and (satisfies? ValueMoveOp op)
            ;; Moves with mismatching kinds are not moves, but memory loads/stores!
            (= (#_"Value" .getValueKind (ValueMoveOp'''getInput-1 op)) (#_"Value" .getValueKind (MoveOp'''getResult-1 op)))
        )
    )

    ;;;
     ; The maximum number of locations * blocks. This is a complexity limit for the inner loop
     ; in #mergeState (assuming a small number of iterations in #solveDataFlow).
     ;;
    (def- #_"int" RMEOptimization'COMPLEXITY_LIMIT 30000)

    (defn- #_"this" RMEOptimization''initBlockData-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (let [
            this (assoc this :numRegs 0)
            #_"Block[]" blocks (:linearScanOrder lir)
            #_"int" maxStackLocations (quot RMEOptimization'COMPLEXITY_LIMIT (count blocks))
            ;; Search for relevant locations which can be optimized. These are register or stack
            ;; slots which occur as destinations of move instructions.
            this
                (loop-when [this this #_"ISeq" s (seq blocks)] (some? s) => this
                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, (first s))
                        this
                            (loop-when [this this #_"ISeq" s (seq ops)] (some? s) => this
                                (let [
                                    #_"LIRInstruction" op (first s)
                                    this
                                        (when (RMEOptimization'isEligibleMove-1 op) => this
                                            (let [
                                                #_"Value" dest (MoveOp'''getResult-1 op)
                                            ]
                                                (condp instance? dest
                                                    RegisterValue
                                                        (let [
                                                            #_"int" regNum (.number (#_"RegisterValue" .getRegister dest))
                                                        ]
                                                            (when (<= (:numRegs this) regNum) => this
                                                                (assoc this :numRegs (inc regNum))
                                                            )
                                                        )
                                                    StackSlot
                                                        (let [
                                                            #_"Integer" offset (RMEOptimization''getOffset-2 this, dest)
                                                        ]
                                                            (when (and (not (contains? (:stackIndices this) offset)) (< (count (:stackIndices this)) maxStackLocations))
                                                                (#_"EconomicMap" .put (:stackIndices this), offset, (count (:stackIndices this)))
                                                            )
                                                            this
                                                        )
                                                    this
                                                )
                                            )
                                        )
                                ]
                                    (recur this (next s))
                                )
                            )
                    ]
                        (recur this (next s))
                    )
                )
            ;; Now we know the number of locations to optimize, so we can allocate the block states.
            #_"int" numLocations (+ (:numRegs this) (count (:stackIndices this)))
            _
                (doseq [#_"Block" block blocks]
                    (#_"EconomicMap" .put (:blockData this), block, (BlockStates'new-1 numLocations))
                )
        ]
            this
        )
    )

    ;;;
     ; Encodes a value number + the is-object information to a number to be stored in a state.
     ;;
    (defn- #_"int" RMEOptimization'encodeValueNum-2 [#_"int" valueNum, #_"boolean" object?]
        (if object? (- valueNum) valueNum)
    )

    (defn- #_"void" RMEOptimization'clearValues-2 [#_"int[]" state, #_"int" defNum]
        (dotimes [#_"int" i (count state)]
            ;; Let the killed values assume to be object references: it's the save default.
            (ยง aset! state i (RMEOptimization'encodeValueNum-2 (+ defNum i), true))
        )
        nil
    )

    ;; Pseudo value for a not yet assigned location.
    (def- #_"int" RMEOptimization'INIT_VALUE 0)

    ;;;
     ; Returns true if an encoded value number (which is stored in a state) refers to an object reference.
     ;;
    (defn- #_"boolean" RMEOptimization'isObjectValue-1 [#_"int" encodedValueNum]
        (neg? encodedValueNum)
    )

    ;;;
     ; The state merge function for dataflow joins.
     ;;
    (defn- #_"boolean" RMEOptimization'mergeState-3 [#_"int[]" dst*, #_"int[]" src*, #_"int" defNum]
        (loop-when [#_"boolean" changed? false #_"int" i 0] (< i (count src*)) => changed?
            (let [
                #_"int" phiNum (+ defNum i)
                #_"int" dst (nth dst* i)
                #_"int" src (nth src* i)
                changed?
                    (when (and (not= dst src) (not= src RMEOptimization'INIT_VALUE) (not= dst (RMEOptimization'encodeValueNum-2 phiNum, (RMEOptimization'isObjectValue-1 dst)))) => changed?
                        (aset dst* i (if (not= dst RMEOptimization'INIT_VALUE) (RMEOptimization'encodeValueNum-2 phiNum, (or (RMEOptimization'isObjectValue-1 dst) (RMEOptimization'isObjectValue-1 src))) src))
                        true
                    )
            ]
                (recur changed? (inc i))
            )
        )
    )

    (defn- #_"void" RMEOptimization'copyState-2 [#_"int[]" dest, #_"int*" source]
        (dotimes [#_"int" i (count source)]
            (ยง aset! dest i (nth source i))
        )
        nil
    )

    ;;;
     ; Returns the index to the state arrays in BlockStates for a specific location.
     ;;
    (defn- #_"int" RMEOptimization''getStateIdx-2 [#_"RMEOptimization" this, #_"Value" location]
        (condp instance? location
            RegisterValue
                (let [
                    #_"int" n (.number (#_"RegisterValue" .getRegister location))
                ]
                    (if (< n (:numRegs this)) (nth (:eligibleRegs this) n) -1)
                )
            StackSlot
                (let [
                    #_"Integer" i (get (:stackIndices this) (RMEOptimization''getOffset-2 this, location))
                ]
                    (if (some? i) (+ (#_"Integer" .intValue i) (:numRegs this)) -1)
                )
            -1
        )
    )

    ;;;
     ; Updates the state for one instruction.
     ;;
    (defn- #_"int" RMEOptimization''updateState-4 [#_"RMEOptimization" this, #_"int[]" state, #_"LIRInstruction" op, #_"int" initValueNum]
        (when (RMEOptimization'isEligibleMove-1 op)
            ;; handle the special case of a move instruction
            (let [
                #_"int" src (RMEOptimization''getStateIdx-2 this, (ValueMoveOp'''getInput-1 op))
                #_"int" dst (RMEOptimization''getStateIdx-2 this, (MoveOp'''getResult-1 op))
            ]
                (when (and (<= 0 src) (<= 0 dst))
                    (ยง aset! state dst (nth state src))
                    (ยง return initValueNum)
                )
            )
        )

        (let [
            #_"int[]" valueNum (int-array [ initValueNum ])
            _
                (when (LIRInstruction'''destroysCallerSavedRegisters-1 op)
                    (doseq [#_"Register" reg (:callerSaveRegs this)]
                        (when (< (.number reg) (:numRegs this))
                            ;; Kind.Object is the save default
                            (ยง aset! state (.number reg) (RMEOptimization'encodeValueNum-2 (nth valueNum 0), true))
                            (aswap valueNum 0 inc)
                        )
                    )
                )
            #_"RMEOptimization" owner this
            #_"ValueConsumer" outputValueConsumer
                (reify ValueConsumer
                    (#_"void" ValueConsumer'''visitValue-5 [#_"ValueConsumer" _this, #_"LIRInstruction" _op, #_"Value" operand, #_"OperandMode" _mode, #_"EnumSet<OperandFlag>" _flags]
                        (let [
                            #_"int" i (RMEOptimization''getStateIdx-2 owner, operand)
                        ]
                            (when (<= 0 i)
                                ;; Assign a unique number to the output or temp location.
                                (ยง aset! state i (RMEOptimization'encodeValueNum-2 (nth valueNum 0), (not (LIRKind'isValue-1v operand))))
                                (aswap valueNum 0 inc)
                            )
                        )
                        nil
                    )
                )
        ]
            (LIRInstruction''visitEachTemp-2 op, outputValueConsumer)
            ;; Semantically the output values are written _after_ the temp values.
            (LIRInstruction''visitEachOutput-2 op, outputValueConsumer)

            (nth valueNum 0)
        )
    )

    ;;;
     ; Calculates the entry and exit states for all basic blocks.
     ;
     ; @return true on success and false if the control flow is too complex
     ;;
    (defn- #_"boolean" RMEOptimization''solveDataFlow-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (let [
            #_"Block[]" blocks (:linearScanOrder lir)
            ;; Iterate until there are no more changes.
            #_"int" currentValueNum 1
        ]
            (loop [#_"int" iteration 0]
                (let [
                    #_"boolean" changed?
                        (loop-when [changed? false #_"ISeq" s (seq blocks)] (some? s) => changed?
                            (let [
                                #_"Block" block (first s)
                                #_"BlockStates" data (get (:blockData this) block)
                            ]
                                ;; Initialize the number for global value numbering for this block.
                                ;; It is essential that the starting number for a block is consistent
                                ;; at all iterations and also in eliminateMoves().
                                (when (zero? iteration)
                                    (ยง ass! data (assoc data :entryValueNum currentValueNum))
                                )
                                (let [
                                    #_"int" valueNum (:entryValueNum data)
                                    #_"boolean" newState
                                        (if (= block (nth blocks 0))
                                            (do
                                                ;; The entry block has undefined values. And also exception handler blocks:
                                                ;; the LinearScan can insert moves at the end of an exception handler predecessor
                                                ;; block (after the invoke, which throws the exception),
                                                ;; and in reality such moves are not in the control flow in case of an exception.
                                                ;; So we assume a save default for exception handler blocks.
                                                (RMEOptimization'clearValues-2 (:entryState data), valueNum)
                                                false
                                            )
                                            ;; Merge the states of predecessor blocks.
                                            (loop-when-recur [newState false #_"ISeq" s (seq (:predecessors block))]
                                                             (some? s)
                                                             [(or newState (RMEOptimization'mergeState-3 (:entryState data), (:exitState (get (:blockData this) (first s))), valueNum)) (next s)]
                                                          => newState
                                            )
                                        )
                                    ;; Advance by the value numbers which are "consumed" by clearValues and mergeState.
                                    valueNum (+ valueNum (count (:entryState data)))
                                    [valueNum changed?]
                                        (when (or newState (zero? iteration)) => [valueNum changed?]
                                            ;; Derive the exit state from the entry state by iterating through all instructions of the block.
                                            (let [
                                                #_"int[]" iterState (:exitState data)
                                            ]
                                                (RMEOptimization'copyState-2 iterState, (:entryState data))
                                                (let [
                                                    valueNum
                                                        (loop-when-recur [valueNum valueNum #_"ISeq" s (seq (LIR''getLIRforBlock-2 lir, block))]
                                                                         (some? s)
                                                                         [(RMEOptimization''updateState-4 this, iterState, (first s), valueNum) (next s)]
                                                                      => valueNum
                                                        )
                                                ]
                                                    [valueNum true]
                                                )
                                            )
                                        )
                                ]
                                    (when (zero? iteration)
                                        (ยง ass currentValueNum valueNum)
                                    )
                                    (recur changed? (next s))
                                )
                            )
                        )
                    iteration (inc iteration)
                ]
                    (if (< 5 iteration)
                        false ;; fairly rare
                        (recur-if changed? [iteration] => true)
                    )
                )
            )
        )
    )

    ;;;
     ; Deletes all move instructions where the target location already contains the source value.
     ;;
    (defn- #_"void" RMEOptimization''eliminateMoves-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (doseq [#_"Block" block (:linearScanOrder lir)]
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
                #_"BlockStates" data (get (:blockData this) block)
                ;; reuse the entry state for iteration, we don't need it later
                #_"int[]" state (:entryState data)
                ;; add the values which are "consumed" by clearValues and mergeState in solveDataFlow
                #_"boolean" hasDead
                    (loop-when [hasDead false #_"int" valueNum (+ (:entryValueNum data) (count (:entryState data))) #_"int" i 0] (< i (count ops)) => hasDead
                        (let [
                            #_"LIRInstruction" op (nth ops i)
                            hasDead
                                (when (RMEOptimization'isEligibleMove-1 op) => hasDead
                                    (let [
                                        #_"int" src (RMEOptimization''getStateIdx-2 this, (ValueMoveOp'''getInput-1 op))
                                        #_"int" dst (RMEOptimization''getStateIdx-2 this, (MoveOp'''getResult-1 op))
                                    ]
                                        (when (and (<= 0 src) (<= 0 dst) (= (nth state src) (nth state dst))) => hasDead
                                            (#_"ArrayList" .set ops, i, nil)
                                            true
                                        )
                                    )
                                )
                        ]
                            ;; it doesn't harm if updateState is also called for a deleted move
                            (recur hasDead (RMEOptimization''updateState-4 this, state, op, valueNum) (inc i))
                        )
                    )
            ]
                (when hasDead
                    (#_"ArrayList" .removeAll ops, (Collections/singleton nil))
                )
            )
        )
        nil
    )

    ;;;
     ; The main method doing the elimination of redundant moves.
     ;;
    (defn #_"this" RMEOptimization''doOptimize-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (let [
            this (assoc this :callerSaveRegs (#_"RegisterConfig" .getCallerSaveRegisters HotSpot'registerConfig))
            this (RMEOptimization''initBlockData-2 this, lir)
            ;; Compute a table of the registers which are eligible for move optimization.
            ;; Unallocatable registers should never be optimized.
            this (assoc this :eligibleRegs (int-array (:numRegs this)))
            _ (Arrays/fill (:eligibleRegs this), -1)
        ]
            (doseq [#_"Register" reg (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig)]
                (when (< (.number reg) (:numRegs this))
                    (aset (:eligibleRegs this) (.number reg) (.number reg))
                )
            )
            (when (RMEOptimization''solveDataFlow-2 this, lir)
                (RMEOptimization''eliminateMoves-2 this, lir)
            )
            this
        )
    )
)

;;;
 ; Represents a range of integers from a start (inclusive) to an end (exclusive).
 ;;
(class-ns Range []
    (defn #_"boolean" Range''intersects-2 [#_"Range" this, #_"Range" r]
        (not= (Range''intersectsAt-2 this, r) -1)
    )

    ;;;
     ; Creates a new range.
     ;
     ; @param from the start of the range, inclusive
     ; @param to the end of the range, exclusive
     ; @param next link to the next range in a linked list
     ;;
    (defn #_"Range" Range'new-3 [#_"int" from, #_"int" to, #_"Range" _next]
        (merge (Range'class.)
            (hash-map
                ;;;
                 ; The start of the range, inclusive.
                 ;;
                #_"int" :from from
                ;;;
                 ; The end of the range, exclusive.
                 ;;
                #_"int" :to to
                ;;;
                 ; A link to allow the range to be put into a singly linked list.
                 ;;
                #_"Range" :next _next
            )
        )
    )

    (defn #_"boolean" Range''isEndMarker-1 [#_"Range" this]
        (= (:from this) Integer/MAX_VALUE)
    )

    (defn #_"int" Range''intersectsAt-2 [#_"Range" this, #_"Range" other]
        (loop [#_"Range" r1 this #_"Range" r2 other]
            (if (< (:from r1) (:from r2))
                (if (<= (:to r1) (:from r2))
                    (let [
                        r1 (:next r1)
                    ]
                        (if (Range''isEndMarker-1 r1) -1 (recur r1 r2))
                    )
                    (:from r2)
                )
                (if (< (:from r2) (:from r1))
                    (if (<= (:to r2) (:from r1))
                        (let [
                            r2 (:next r2)
                        ]
                            (if (Range''isEndMarker-1 r2) -1 (recur r1 r2))
                        )
                        (:from r1)
                    )
                    ;; r1.from() == r2.from()
                    (if (= (:from r1) (:to r1))
                        (let [
                            r1 (:next r1)
                        ]
                            (if (Range''isEndMarker-1 r1) -1 (recur r1 r2))
                        )
                        (if (= (:from r2) (:to r2))
                            (let [
                                r2 (:next r2)
                            ]
                                (if (Range''isEndMarker-1 r2) -1 (recur r1 r2))
                            )
                            (:from r1)
                        )
                    )
                )
            )
        )
    )
)

(class-ns RawConditionalEliminationVisitor [RecursiveVisitor #_"<Integer>"]
    (defn #_"RawConditionalEliminationVisitor" RawConditionalEliminationVisitor'new-2 [#_"Graph" graph, #_"ScheduleResult" schedule]
        (merge (RawConditionalEliminationVisitor'class.)
            (hash-map
                #_"Graph" :graph graph
                #_"NodeMap<StampElement>" :stampMap (NodeMap'new-1g graph)
                #_"[Node]" :undo []
                #_"ScheduleResult" :schedule schedule
                #_"BlockMap<Integer>" :blockActionStart (BlockMap'new-1 (:cfg schedule))
                #_"EconomicMap<MergeNode, EconomicMap<ValueNode, Stamp>>" :endMaps (EconomicMap/create)
            )
        )
    )

    (defn- #_"Stamp" RawConditionalEliminationVisitor''getBestStamp-2 [#_"RawConditionalEliminationVisitor" this, #_"ValueNode" value]
        (let [
            #_"StampElement" stampElement (NodeMap''getAndGrow-2 (:stampMap this), value)
        ]
            (if (some? stampElement) (:stamp stampElement) (:stamp value))
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''registerNewStamp-3 [#_"RawConditionalEliminationVisitor" this, #_"ValueNode" value, #_"Stamp" stamp]
        (-> this
            (update :stampMap #(NodeMap''setAndGrow-3 %, value, (StampElement'new-2 stamp, (NodeMap''getAndGrow-2 %, value))))
            (update :undo conj value)
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''registerNewValueStamp-3 [#_"RawConditionalEliminationVisitor" this, #_"ValueNode" value, #_"Stamp" stamp]
        (when (and (some? stamp) (not (satisfies? ConstantNode value))) => this
            (let [
                #_"Stamp" betterStamp (Stamp''tryImproveWith-2 (RawConditionalEliminationVisitor''getBestStamp-2 this, value), stamp)
            ]
                (when (some? betterStamp) => this
                    (RawConditionalEliminationVisitor''registerNewStamp-3 this, value, betterStamp)
                )
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''registerCondition-3 [#_"RawConditionalEliminationVisitor" this, #_"LogicNode" logic, #_"boolean" negated?]
        (RawConditionalEliminationVisitor''registerNewStamp-3 this, logic, (if negated? StampFactory'booleanFalse StampFactory'booleanTrue))
    )

    (defn- #_"int" RawConditionalEliminationVisitor''replaceConstantInputs-2 [#_"RawConditionalEliminationVisitor" this, #_"Node" node]
        ;; Check if we can replace any of the inputs with a constant.
        (loop-when [#_"int" n 0 #_"ISeq" s (seq (Node''inputPositions-1 node))] (some? s) => n
            (let [
                #_"Position" p (first s)
                #_"Node" input (Position''get-2 p, node)
                n
                    (when (and (= (Position''getInputType-1 p) InputType'Value) (satisfies? ValueNode input) (not (satisfies? ConstantNode input))) => n
                        (let [
                            #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, input)
                            #_"Constant" constant (Stamp'''asConstant-1 bestStamp)
                        ]
                            (when (some? constant) => n
                                (Position''set-3 p, node, (ConstantNode'forConstant-3s bestStamp, constant, (:graph this)))
                                (inc n)
                            )
                        )
                    )
            ]
                (recur n (next s))
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''registerCombinedStamps-2 [#_"RawConditionalEliminationVisitor" this, #_"MergeNode" node]
        (let [
            #_"MapCursor<ValueNode, Stamp>" entries (#_"EconomicMap" .getEntries (get (:endMaps this) node))
        ]
            (loop-when this (#_"MapCursor" .advance entries) => this
                (let [
                    #_"ValueNode" value (#_"MapCursor" .getKey entries)
                    ;; nodes from this map can be deleted when a loop dies
                    this
                        (when-not (Node''isDeleted-1 value) => this
                            (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, value, (#_"MapCursor" .getValue entries))
                        )
                ]
                    (recur this)
                )
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''registerNewCondition-3 [#_"RawConditionalEliminationVisitor" this, #_"LogicNode" logic, #_"boolean" negated?]
        (let [
            this
                (condp satisfies? logic
                    UnaryOpLogicNode
                        (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, (Unary'''getValue-1 logic), (UnaryOpLogicNode'''getSucceedingStampForValue-2 logic, negated?))
                    BinaryOpLogicNode
                        (let [
                            #_"Stamp" xStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:x logic))
                            #_"Stamp" yStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:y logic))
                        ]
                            (-> this
                                (RawConditionalEliminationVisitor''registerNewValueStamp-3 (:x logic), (BinaryOpLogicNode'''getSucceedingStampForX-4 logic, negated?, xStamp, yStamp))
                                (RawConditionalEliminationVisitor''registerNewValueStamp-3 (:y logic), (BinaryOpLogicNode'''getSucceedingStampForY-4 logic, negated?, xStamp, yStamp))
                            )
                        )
                    this
                )
        ]
            (RawConditionalEliminationVisitor''registerCondition-3 this, logic, negated?)
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''registerIntegerSwitch-3 [#_"RawConditionalEliminationVisitor" this, #_"AbstractBeginNode" beginNode, #_"IntegerSwitchNode" integerSwitchNode]
        (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, (:value integerSwitchNode), (SwitchNode'''getValueStampForSuccessor-2 integerSwitchNode, beginNode))
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processAbstractBegin-2 [#_"RawConditionalEliminationVisitor" this, #_"AbstractBeginNode" beginNode]
        (let [
            #_"Node" pred (:predecessor beginNode)
        ]
            (condp satisfies? pred
                IfNode            (RawConditionalEliminationVisitor''registerNewCondition-3 this, (:logic pred), (= (:falseSuccessor pred) beginNode))
                IntegerSwitchNode (RawConditionalEliminationVisitor''registerIntegerSwitch-3 this, beginNode, pred)
                                  this
            )
        )
    )

    (defn- #_"TriState" RawConditionalEliminationVisitor''tryProveCondition-2 [#_"RawConditionalEliminationVisitor" this, #_"LogicNode" logic]
        (condp = (RawConditionalEliminationVisitor''getBestStamp-2 this, logic)
            StampFactory'booleanTrue  TriState/TRUE
            StampFactory'booleanFalse TriState/FALSE
            (condp satisfies? logic
                UnaryOpLogicNode  (UnaryOpLogicNode'''tryFold-2 logic, (RawConditionalEliminationVisitor''getBestStamp-2 this, (Unary'''getValue-1 logic)))
                BinaryOpLogicNode (BinaryOpLogicNode'''tryFold-3 logic, (RawConditionalEliminationVisitor''getBestStamp-2 this, (:x logic)), (RawConditionalEliminationVisitor''getBestStamp-2 this, (:y logic)))
                TriState/UNKNOWN
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processIf-2 [#_"RawConditionalEliminationVisitor" this, #_"IfNode" node]
        (let [
            #_"TriState" result (RawConditionalEliminationVisitor''tryProveCondition-2 this, (:logic node))
        ]
            (when-not (= result TriState/UNKNOWN) => this
                (let [
                    #_"AbstractBeginNode" survivingSuccessor (IfNode''getSuccessor-2 node, (= result TriState/TRUE))
                ]
                    (ยง ass! survivingSuccessor (Node''replaceAtUsages-2 survivingSuccessor, nil))
                    (Node''replaceAtPredecessor-2 survivingSuccessor, nil)
                    (Node''replaceAtPredecessor-2 node, survivingSuccessor)
                    (GraphUtil'killCFG-1 node)
                    this
                )
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processIntegerSwitch-2 [#_"RawConditionalEliminationVisitor" this, #_"IntegerSwitchNode" node]
        (let [
            #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:value node))
        ]
            (IntegerSwitchNode''tryRemoveUnreachableKeys-3 node, nil, bestStamp)
            this
        )
    )

    (defn- #_"boolean" RawConditionalEliminationVisitor''checkReplaceWithConstant-3 [#_"RawConditionalEliminationVisitor" this, #_"Stamp" stamp, #_"ValueNode" node]
        (let [
            #_"Constant" constant (Stamp'''asConstant-1 stamp)
        ]
            (and (some? constant) (not (satisfies? ConstantNode node))
                (do
                    (Node''replaceAtUsages-3 node, InputType'Value, (ConstantNode'forConstant-3s stamp, constant, (:graph this)))
                    (GraphUtil'tryKillUnused-1 node)
                    true
                )
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processBinary-2 [#_"RawConditionalEliminationVisitor" this, #_"BinaryNode" node]
        (let [
            #_"Stamp" xStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:x node))
            #_"Stamp" yStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:y node))
            #_"Stamp" stamp (BinaryNode'''foldStamp-3 node, xStamp, yStamp)
        ]
            (when-not (RawConditionalEliminationVisitor''checkReplaceWithConstant-3 this, stamp, node) => this
                (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, node, stamp)
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processConditional-2 [#_"RawConditionalEliminationVisitor" this, #_"ConditionalNode" node]
        (let [
            #_"TriState" result (RawConditionalEliminationVisitor''tryProveCondition-2 this, (:logic node))
        ]
            (if (= result TriState/UNKNOWN)
                (let [
                    #_"Stamp" trueStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:trueValue node))
                    #_"Stamp" falseStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:falseValue node))
                ]
                    (RawConditionalEliminationVisitor''registerNewStamp-3 this, node, (Stamp'''meet-2 trueStamp, falseStamp))
                )
                (do
                    (ยง ass! node (Node''replaceAndDelete-2 node, (if (= result TriState/TRUE) (:trueValue node) (:falseValue node))))
                    this
                )
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processUnary-2 [#_"RawConditionalEliminationVisitor" this, #_"UnaryNode" node]
        (let [
            #_"Stamp" stamp (UnaryNode'''foldStamp-2 node, (RawConditionalEliminationVisitor''getBestStamp-2 this, (Unary'''getValue-1 node)))
        ]
            (when-not (RawConditionalEliminationVisitor''checkReplaceWithConstant-3 this, stamp, node) => this
                (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, node, stamp)
            )
        )
    )

    (defn- #_"Block" RawConditionalEliminationVisitor'getBlock-2 [#_"ValueNode" node, #_"NodeMap<Block>" blockToNodeMap]
        (get blockToNodeMap (if (satisfies? PhiNode node) (:merge node) node))
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processEnd-2 [#_"RawConditionalEliminationVisitor" this, #_"EndNode" node]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode'''merge-1 node)
        ]
            (when (satisfies? MergeNode merge) => this
                (let [
                    #_"NodeMap<Block>" blockToNodeMap (:nodeToBlockMap (:schedule this))
                    #_"Block" mergeBlock (get blockToNodeMap merge)
                    #_"Block" mergeBlockDominator (:dominator mergeBlock)
                    #_"EconomicMap<ValueNode, Stamp>" currentEndMap (get (:endMaps this) merge)
                ]
                    (when (or (nil? currentEndMap) (seq currentEndMap)) => this
                        (let [
                            #_"EconomicMap<ValueNode, Stamp>" endMap (EconomicMap/create)
                        ]
                            ;; process phis
                            (doseq [#_"ValuePhiNode" phi (AbstractMergeNode''valuePhis-1 merge)]
                                (when (or (nil? currentEndMap) (contains? currentEndMap phi))
                                    (let [
                                        #_"ValueNode" valueAt (PhiNode''valueAt-2n phi, node)
                                        #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, valueAt)
                                        bestStamp
                                            (when (some? currentEndMap) => bestStamp
                                                (Stamp'''meet-2 bestStamp, (get currentEndMap phi))
                                            )
                                    ]
                                        (when-not (= bestStamp (:stamp phi))
                                            (#_"EconomicMap" .put endMap, phi, bestStamp)
                                        )
                                    )
                                )
                            )

                            (let [
                                #_"int" lastMark (count (:undo this))
                            ]
                                (loop-when [#_"Block" currentBlock (get blockToNodeMap node)] (not= currentBlock mergeBlockDominator)
                                    (let [
                                        #_"int" mark (BlockMap''get-2 (:blockActionStart this), currentBlock)
                                    ]
                                        (loop-when [#_"int" i (dec lastMark)] (<= mark i)
                                            (let [
                                                #_"ValueNode" nodeWithNewStamp (nth (:undo this) i)
                                            ]
                                                (when-not (or (Node''isDeleted-1 nodeWithNewStamp) (satisfies? LogicNode nodeWithNewStamp) (satisfies? ConstantNode nodeWithNewStamp) (NodeMap''isNew-2 blockToNodeMap, nodeWithNewStamp))
                                                    (let [
                                                        #_"Block" block (RawConditionalEliminationVisitor'getBlock-2 nodeWithNewStamp, blockToNodeMap)
                                                    ]
                                                        (when (or (nil? block) (<= (:id block) (:id mergeBlockDominator)))
                                                            ;; Node with new stamp in path to the merge block dominator and that
                                                            ;; at the same time was defined at least in the merge block dominator
                                                            ;; (i.e. therefore can be used after the merge.)
                                                            (let [
                                                                #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, nodeWithNewStamp)
                                                                bestStamp
                                                                    (when (some? currentEndMap) => bestStamp
                                                                        (let [
                                                                            #_"Stamp" otherEndsStamp (get currentEndMap nodeWithNewStamp)
                                                                        ]
                                                                            (when (nil? otherEndsStamp)
                                                                                ;; No stamp registered in one of the previously processed ends => skip.
                                                                                (ยง continue )
                                                                            )
                                                                            (Stamp'''meet-2 bestStamp, otherEndsStamp)
                                                                        )
                                                                    )
                                                            ]
                                                                (when (some? (Stamp''tryImproveWith-2 (:stamp nodeWithNewStamp), bestStamp)) ;; => No point in registering the stamp.
                                                                    (#_"EconomicMap" .put endMap, nodeWithNewStamp, bestStamp)
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (recur (dec i))
                                            )
                                        )
                                        (recur (:dominator currentBlock))
                                    )
                                )

                                (#_"EconomicMap" .put (:endMaps this), merge, endMap)
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"this" RawConditionalEliminationVisitor''processNode-2 [#_"RawConditionalEliminationVisitor" this, #_"Node" node]
        (when GraalOptions'replaceInputsWithConstantsBasedOnStamps
            (RawConditionalEliminationVisitor''replaceConstantInputs-2 this, node)
        )
        (let [
            this
                (when (satisfies? MergeNode node) => this
                    (RawConditionalEliminationVisitor''registerCombinedStamps-2 this, node)
                )
        ]
            (condp satisfies? node
                AbstractBeginNode (RawConditionalEliminationVisitor''processAbstractBegin-2 this, node)
                IfNode            (RawConditionalEliminationVisitor''processIf-2            this, node)
                IntegerSwitchNode (RawConditionalEliminationVisitor''processIntegerSwitch-2 this, node)
                BinaryNode        (RawConditionalEliminationVisitor''processBinary-2        this, node)
                ConditionalNode   (RawConditionalEliminationVisitor''processConditional-2   this, node)
                UnaryNode         (RawConditionalEliminationVisitor''processUnary-2         this, node)
                EndNode           (RawConditionalEliminationVisitor''processEnd-2           this, node)
                                  this
            )
        )
    )

    (defm RawConditionalEliminationVisitor RecursiveVisitor
        (#_"Integer" RecursiveVisitor'''enter-2 [#_"RawConditionalEliminationVisitor" this, #_"Block" block]
            (let [
                #_"int" mark (count (:undo this))
            ]
                (BlockMap''put-3 (:blockActionStart this), block, mark)
                (doseq [#_"Node" node (BlockMap''get-2 (:blockToNodesMap (:schedule this)), block)]
                    (when (Node''isAlive-1 node)
                        (ยง ass! this (RawConditionalEliminationVisitor''processNode-2 this, node))
                    )
                )
                mark
            )
        )

        (#_"this" RecursiveVisitor'''exit-3 [#_"RawConditionalEliminationVisitor" this, #_"Block" block, #_"Integer" state]
            (let [
                #_"int" mark state
            ]
                (loop-when this (< mark (count (:undo this))) => this
                    (let [
                        [#_"Node" node this] [(peek (:undo this)) (update this :undo pop)]
                    ]
                        (when (Node''isAlive-1 node)
                            (NodeMap''set-3 (:stampMap this), node, (:parent (get (:stampMap this) node)))
                        )
                        (recur this)
                    )
                )
            )
        )
    )
)

;;;
 ; An iterator that will iterate over edges.
 ;
 ; An iterator of this type will not return nil values, unless edges are modified concurrently.
 ;;
(class-ns RawEdgesIterator [#_"Iterator" #_"<Node>"]
    (defn #_"RawEdgesIterator" RawEdgesIterator'new-2 [#_"Node" node, #_"long" mask]
        (merge (RawEdgesIterator'class.)
            (hash-map
                #_"Node" :node node
                #_"long" :mask mask
                #_"Node" :nextValue nil
            )
        )
    )

    (defn- #_"Node" RawEdgesIterator''getInput-1 [#_"RawEdgesIterator" this]
        (let [
            #_"int" state (int (& (:mask this) 0x03))
        ]
            (case state
                0   (Edges'getNodeUnsafe-2 (:node this), (& (:mask this) 0xfc))
                1   ;; We are iterating a node list.
                    (let [
                        #_"NodeList" nodeList (Edges'getNodeListUnsafe-2 (:node this), (& (:mask this) 0xfc))
                    ]
                        (nth (:nodes nodeList) (- (count nodeList) 1 (int (& (>>> (:mask this) NodeClass'NEXT_EDGE) 0xffff))))
                    )
                ;; Node list needs to expand first.
                nil
            )
        )
    )

    (defn- #_"long" RawEdgesIterator''advanceInput-1 [#_"RawEdgesIterator" this]
        (let [
            #_"int" state (& (int (:mask this)) 0x03)
        ]
            (case state
                0   ;; Skip normal field.
                    (>>> (:mask this) NodeClass'NEXT_EDGE)
                1   ;; We are iterating a node list.
                    (if (zero? (& (:mask this) 0xffff00))
                        ;; Node list is finished => go to next input.
                        (>>> (:mask this) 24)
                        ;; Node list count is non-zero, decrease by 1.
                        (- (:mask this) 0x100)
                    )
                ;; Need to expand node list.
                (let [
                    #_"NodeList" nodeList (Edges'getNodeListUnsafe-2 (:node this), (& (:mask this) 0xfc))
                ]
                    (when (some? nodeList)
                        (let [
                            #_"int" size (count nodeList)
                        ]
                            (when-not (zero? size)
                                ;; Set pointer to upper most index of node list.
                                (ยง return (| (<< (>>> (:mask this) NodeClass'NEXT_EDGE) 24) (& (:mask this) 0xfd) (<< (dec size) NodeClass'NEXT_EDGE)))
                            )
                        )
                    )
                    ;; Node list is empty or nil => skip.
                    (>>> (:mask this) NodeClass'NEXT_EDGE)
                )
            )
        )
    )

    (defn- #_"Node" RawEdgesIterator''forward-1 [#_"RawEdgesIterator" this]
        (loop-when [] (not (zero? (:mask this)))
            (let [
                #_"Node" _next (RawEdgesIterator''getInput-1 this)
            ]
                (ยง ass! this (assoc this :mask (RawEdgesIterator''advanceInput-1 this)))
                (or _next (recur))
            )
        )
    )

    (ยง override! #_"boolean" #_"Iterator." hasNext [#_"RawEdgesIterator" this]
        (or (some? (:nextValue this))
            (do
                (ยง ass! this (assoc this :nextValue (RawEdgesIterator''forward-1 this)))
                (some? (:nextValue this))
            )
        )
    )

    (ยง override! #_"Node" #_"Iterator." next [#_"RawEdgesIterator" this]
        (let [
            #_"Node" _next (:nextValue this)
        ]
            (when (some? _next) => (or (RawEdgesIterator''forward-1 this) (throw (NoSuchElementException.)))
                (ยง ass! this (assoc this :nextValue nil))
                _next
            )
        )
    )
)

(class-ns ReadCacheEntry []
    (defn #_"ReadCacheEntry" ReadCacheEntry'new-5 [#_"LocationIdentity" identity, #_"ValueNode" object, #_"int" index, #_"JavaKind" kind, #_"boolean" overflowAccess]
        (merge (ReadCacheEntry'class.)
            (hash-map
                #_"LocationIdentity" :identity identity
                #_"ValueNode" :object object
                #_"int" :index index
                #_"JavaKind" :kind kind
                ;; This flag does not affect hashCode or equals implementations.
                #_"boolean" :overflowAccess overflowAccess
            )
        )
    )
)

;;;
 ; Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} so that
 ; invariant parts of the expression can be moved outside of the loop.
 ;;
(class-ns ReassociateInvariantPhase [Phase]
    (defn #_"ReassociateInvariantPhase" ReassociateInvariantPhase'new-0 []
        (ReassociateInvariantPhase'class.)
    )

    (defm ReassociateInvariantPhase Phase
        (#_"Graph" Phase'''run-3 [#_"ReassociateInvariantPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (loop [#_"int" iterations 0]
                (let [
                    #_"LoopsData" dataReassociate (LoopsData'new-1 graph)
                    #_"boolean" changed?
                        (loop-when-recur [changed? false #_"ISeq" s (seq (:loops dataReassociate))]
                                        (some? s)
                                        [(or changed? (LoopEx''reassociateInvariants-1 (first s))) (next s)]
                                    => changed?
                        )
                ]
                    (LoopsData''deleteUnusedNodes-1 dataReassociate)
                    (recur-if changed? [(inc iterations)])
                )
            )
            graph
        )
    )
)

;;;
 ; Removes move instructions, where the destination value is already in place.
 ;;
(class-ns RedundantMoveElimination [LIRPhase #_"<LIRPhaseContext>"] ;; PostAllocationPhase
    (defn #_"RedundantMoveElimination" RedundantMoveElimination'new-0 []
        (RedundantMoveElimination'class.)
    )

    (defm RedundantMoveElimination LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"RedundantMoveElimination" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (let [
                #_"RMEOptimization" optimization (RMEOptimization'new-1 (:frameMap lirGenRes))
            ]
                (ยง ass! optimization (RMEOptimization''doOptimize-2 optimization, (:lir lirGenRes)))
            )
            nil
        )
    )
)

(class-ns RefCount []
    (defn #_"RefCount" RefCount'new-0 []
        (merge (RefCount'class.)
            (hash-map
                #_"int" :refCount 1
            )
        )
    )
)

(class-ns RegisterBackupPair []
    (defn #_"RegisterBackupPair" RegisterBackupPair'new-2 [#_"Register" register, #_"VirtualStackSlot" backupSlot]
        (merge (RegisterBackupPair'class.)
            (hash-map
                #_"Register" :register register
                #_"VirtualStackSlot" :backupSlot backupSlot
            )
        )
    )
)

;;;
 ; A set of interval lists, one per binding type.
 ;;
(class-ns RegisterBindingLists []
    (defn #_"RegisterBindingLists" RegisterBindingLists'new-3 [#_"Interval" fixed, #_"Interval" any, #_"Interval" stack]
        (merge (RegisterBindingLists'class.)
            (hash-map
                ;;;
                 ; List of intervals whose binding is currently RegisterBinding#Fixed.
                 ;;
                #_"Interval" :fixed fixed
                ;;;
                 ; List of intervals whose binding is currently RegisterBinding#Any.
                 ;;
                #_"Interval" :any any
                ;;;
                 ; List of intervals whose binding is currently RegisterBinding#Stack.
                 ;;
                #_"Interval" :stack stack
            )
        )
    )

    ;;;
     ; Gets the list for a specified binding.
     ;
     ; @param binding specifies the list to be returned
     ; @return the list of intervals whose binding is {@code binding}
     ;;
    (defn #_"Interval" RegisterBindingLists''get-2 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding]
        (condp = binding
            RegisterBinding'Any   (:any this)
            RegisterBinding'Fixed (:fixed this)
            RegisterBinding'Stack (:stack this)
        )
    )

    ;;;
     ; Sets the list for a specified binding.
     ;
     ; @param binding specifies the list to be replaced
     ; @param list a list of intervals whose binding is {@code binding}
     ;;
    (defn #_"RegisterBindingLists" RegisterBindingLists''set-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" list]
        (condp = binding
            RegisterBinding'Any   (assoc this :any   list)
            RegisterBinding'Fixed (assoc this :fixed list)
            RegisterBinding'Stack (assoc this :stack list)
        )
    )

    ;;;
     ; Adds an interval to a list sorted by {@linkplain Interval#currentFrom() current from} positions.
     ;
     ; @param binding specifies the list to be updated
     ; @param interval the interval to add
     ;;
    (defn #_"RegisterBindingLists" RegisterBindingLists''addToListSortedByCurrentFromPositions-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" interval]
        (let [
            #_"Interval" list (RegisterBindingLists''get-2 this, binding)
            [#_"Interval" prev #_"Interval" cur]
                (loop-when-recur [prev nil cur list] (< (Interval''currentFrom-1 cur) (Interval''currentFrom-1 interval)) [cur (:next cur)] => [prev cur])
            #_"Interval" result list
        ]
            (if (nil? prev)
                (ยง ass result interval)                   ;; add to head of list
                (ยง ass! prev (assoc prev :next interval)) ;; add before 'cur'
            )
            (ยง ass! interval (assoc interval :next cur))
            (RegisterBindingLists''set-3 this, binding, result)
        )
    )

    ;;;
     ; Adds an interval to a list sorted by {@linkplain Interval#from() start} positions and
     ; {@linkplain Interval#firstUsage(RegisterPriority) first usage} positions.
     ;
     ; @param binding specifies the list to be updated
     ; @param interval the interval to add
     ;;
    (defn #_"RegisterBindingLists" RegisterBindingLists''addToListSortedByStartAndUsePositions-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" interval]
        (let [
            #_"Interval" list (RegisterBindingLists''get-2 this, binding)
            [#_"Interval" prev #_"Interval" cur]
                (loop-when-recur [prev nil cur list] (or (< (Interval''from-1 cur) (Interval''from-1 interval)) (and (= (Interval''from-1 cur) (Interval''from-1 interval)) (< (Interval''firstUsage-2 cur, RegisterPriority'None) (Interval''firstUsage-2 interval, RegisterPriority'None)))) [cur (:next cur)] => [prev cur])
        ]
            (if (nil? prev)
                (ยง ass list interval)
                (ยง ass! prev (assoc prev :next interval))
            )
            (ยง ass! interval (assoc interval :next cur))
            (RegisterBindingLists''set-3 this, binding, list)
        )
    )

    ;;;
     ; Removes an interval from a list.
     ;
     ; @param binding specifies the list to be updated
     ; @param i the interval to remove
     ;;
    (defn #_"this" RegisterBindingLists''remove-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" i]
        (let [
            #_"Interval" list (RegisterBindingLists''get-2 this, binding)
            [#_"Interval" prev #_"Interval" cur]
                (loop-when-recur [prev nil cur list] (not= cur i) [cur (:next cur)] => [prev cur])
        ]
            (if (nil? prev)
                (ยง ass! this (RegisterBindingLists''set-3 this, binding, (:next cur)))
                (ยง ass! prev (assoc prev :next (:next cur)))
            )
            this
        )
    )
)

(class-ns RegisterMap []
    (defn #_"RegisterMap" RegisterMap'new-1 [#_"Architecture" arch]
        (merge (RegisterMap'class.)
            (hash-map
                #_"Variable[]" :values (make-array Variable'iface (#_"RegisterArray" .size (#_"Architecture" .getRegisters arch)))
                #_"Architecture" :arch arch
            )
        )
    )

    (defn #_"void" RegisterMap''put-3 [#_"RegisterMap" this, #_"Register" reg, #_"Variable" value]
        (aset (:values this) (.number reg) value)
        nil
    )

    (defn #_"void" RegisterMap''forEach-2 [#_"RegisterMap" this, #_"fn void [Register Variable]" f'consumer-2]
        (dotimes [#_"int" i (count (:values this))]
            (let [
                #_"Variable" value (nth (:values this) i)
            ]
                (when (some? value)
                    (f'consumer-2 (#_"RegisterArray" .get (#_"Architecture" .getRegisters (:arch this)), i), value)
                )
            )
        )
        nil
    )
)

(class-ns RemoveValueProxyPhase [Phase]
    (defn #_"RemoveValueProxyPhase" RemoveValueProxyPhase'new-0 []
        (RemoveValueProxyPhase'class.)
    )

    (defm RemoveValueProxyPhase Phase
        (#_"Graph" Phase'''run-3 [#_"RemoveValueProxyPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (doseq [#_"LoopExitNode" exit (Graph''getNodes-2 graph, LoopExitNode)]
                (doseq [#_"ProxyNode" vpn (ยง snap (LoopExitNode''proxies-1 exit))]
                    (ยง ass! vpn (Node''replaceAtUsagesAndDelete-2 vpn, (:value vpn)))
                )
                (let [
                    #_"FrameState" stateAfter (:stateAfter exit)
                ]
                    (when (some? stateAfter)
                        (StateSplit'''setStateAfter-2 exit, nil)
                        (when (Node''hasNoUsages-1 stateAfter)
                            (GraphUtil'killWithUnusedFloatingInputs-1 stateAfter)
                        )
                    )
                )
            )
            (Graph''setHasValueProxies-2 graph, false)
        )
    )
)

(class-ns Replacements [InlineInvokePlugin]
    (defn #_"Replacements" Replacements'new-0 []
        (Replacements'class.)
    )

    ;;;
     ; Determines whether a given method should be inlined based on whether it has a substitution or
     ; whether the inlining context is already within a substitution.
     ;
     ; @return an object specifying how {@code method} is to be inlined or nil if it should not be
     ;         inlined based on substitution related criteria
     ;;
    (defm Replacements InlineInvokePlugin
        (#_"InlineInvokeInfo" InlineInvokePlugin'''shouldInlineInvoke-4 [#_"Replacements" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
            (when (BytecodeParser''parsingIntrinsic-1 parser)
                ;; force inlining when parsing replacements
                (InlineInvokeInfo'createIntrinsicInlineInfo-1 method)
            )
        )

        (#_"void" InlineInvokePlugin'''notifyNotInlined-4 [#_"Replacements" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke]
            (when (BytecodeParser''parsingIntrinsic-1 parser)
                (let [
                    #_"IntrinsicContext" intrinsic (:intrinsicContext parser)
                ]
                    (when-not (IntrinsicContext''isCallToOriginal-2 intrinsic, method)
                        (throw! (str "All non-recursive calls in the intrinsic " (#_"ResolvedJavaMethod" .format (:intrinsicMethod intrinsic), "%H.\n(%p)") " must be inlined or intrinsified: found call to " (#_"ResolvedJavaMethod" .format method, "%h.\n(%p)")))
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Builds the initial graph for a replacement.
     ;;
    (defn- #_"Graph" Replacements'buildInitialGraph-1 [#_"ResolvedJavaMethod" method]
        (let [
            #_"IntrinsicContext" intrinsic
                (if (some? (#_"ResolvedJavaMethod" .getAnnotation method, Snippet))
                    ;; snippet
                    (IntrinsicContext'new-4 method, method, HotSpot'defaultBytecodeProvider, CompilationContext'INLINE_AFTER_PARSING)
                    ;; post-parse inlined intrinsic
                    (IntrinsicContext'new-4 nil, method, HotSpot'defaultBytecodeProvider, CompilationContext'INLINE_AFTER_PARSING)
                )
            #_"Graph" graph (Graph'new-1 method)
            graph (Phase'''run-3 (GraphBuilderInstance'new-2 OptimisticOptimizations'NONE, intrinsic), graph, nil)
            graph (Phase'''run-3 (CanonicalizerPhase'new-0), graph, nil)
        ]
            graph
        )
    )

    ;;;
     ; Does final processing of a snippet graph.
     ;;
    (defn- #_"Graph" Replacements'finalizeGraph-1 [#_"Graph" graph]
        (let [
            graph (Phase'''run-3 (ConvertDeoptimizeToGuardPhase'new-0), graph, nil)
            graph (Phase'''run-3 (DeadCodeEliminationPhase'new-1 Optionality'Required), graph, nil)
        ]
            graph
        )
    )

    ;;;
     ; Creates a preprocessed graph for a snippet.
     ;;
    (defn #_"Graph" Replacements'createSnippet-1 [#_"ResolvedJavaMethod" method]
        (Replacements'finalizeGraph-1 (Replacements'buildInitialGraph-1 method))
    )

    (defm Replacements InlineInvokePlugin
        (#_"void" InlineInvokePlugin'''notifyBeforeInline-2 [#_"Replacements" this, #_"ResolvedJavaMethod" methodToInline]
            nil
        )

        (#_"void" InlineInvokePlugin'''notifyAfterInline-2 [#_"Replacements" this, #_"ResolvedJavaMethod" methodToInline]
            nil
        )
    )
)

;;;
 ; Direct access to the bytecode of a ResolvedJavaMethod that will reflect any
 ; instrumentation and rewriting performed on the ResolvedJavaMethod.
 ;;
(class-ns ResolvedJavaMethodBytecode [Bytecode]
    (defn #_"ResolvedJavaMethodBytecode" ResolvedJavaMethodBytecode'new-1 [#_"ResolvedJavaMethod" method]
        (merge (ResolvedJavaMethodBytecode'class.)
            (hash-map
                #_"ResolvedJavaMethod" :method method
            )
        )
    )

    (defm ResolvedJavaMethodBytecode Bytecode
        (#_"ResolvedJavaMethod" Bytecode'''getMethod-1 [#_"ResolvedJavaMethodBytecode" this]
            (:method this)
        )

        (#_"byte[]" Bytecode'''getCode-1 [#_"ResolvedJavaMethodBytecode" this]
            (#_"ResolvedJavaMethod" .getCode (:method this))
        )

        (#_"int" Bytecode'''getCodeSize-1 [#_"ResolvedJavaMethodBytecode" this]
            (#_"ResolvedJavaMethod" .getCodeSize (:method this))
        )

        (#_"int" Bytecode'''getMaxStackSize-1 [#_"ResolvedJavaMethodBytecode" this]
            (#_"ResolvedJavaMethod" .getMaxStackSize (:method this))
        )

        (#_"int" Bytecode'''getMaxLocals-1 [#_"ResolvedJavaMethodBytecode" this]
            (#_"ResolvedJavaMethod" .getMaxLocals (:method this))
        )

        (#_"ConstantPool" Bytecode'''getConstantPool-1 [#_"ResolvedJavaMethodBytecode" this]
            (#_"ResolvedJavaMethod" .getConstantPool (:method this))
        )
    )
)

;;;
 ; BytecodeProvider that returns ResolvedJavaMethodBytecode objects.
 ;;
(class-ns ResolvedJavaMethodBytecodeProvider [BytecodeProvider]
    (defn- #_"ResolvedJavaMethodBytecodeProvider" ResolvedJavaMethodBytecodeProvider'new-0 []
        (ResolvedJavaMethodBytecodeProvider'class.)
    )

    ;;;
     ; A state-less, shared ResolvedJavaMethodBytecodeProvider instance.
     ;;
    (def #_"ResolvedJavaMethodBytecodeProvider" ResolvedJavaMethodBytecodeProvider'INSTANCE (ResolvedJavaMethodBytecodeProvider'new-0))

    (defm ResolvedJavaMethodBytecodeProvider BytecodeProvider
        (#_"Bytecode" BytecodeProvider'''getBytecode-2 [#_"ResolvedJavaMethodBytecodeProvider" this, #_"ResolvedJavaMethod" method]
            (ResolvedJavaMethodBytecode'new-1 method)
        )
    )
)

(class-ns ReturnToCallerData []
    (defn #_"ReturnToCallerData" ReturnToCallerData'new-2 [#_"ValueNode" returnValue, #_"FixedWithNextNode" beforeReturnNode]
        (merge (ReturnToCallerData'class.)
            (hash-map
                #_"ValueNode" :returnValue returnValue
                #_"FixedWithNextNode" :beforeReturnNode beforeReturnNode
            )
        )
    )

    (defn #_"boolean" ReturnToCallerData'containsReturnValue-2 [#_"List<ReturnToCallerData>" list, #_"ValueNode" value]
        (loop [#_"ISeq" s (seq list)] (and (some? s) (or (= (:returnValue (first s)) value) (recur (next s)))))
    )
)

(class-ns SaveCalleeSaveRegisters [LIRPhase #_"<LIRPhaseContext>"] ;; PreAllocationPhase
    (defn #_"SaveCalleeSaveRegisters" SaveCalleeSaveRegisters'new-0 []
        (SaveCalleeSaveRegisters'class.)
    )

    (defn- #_"RegisterMap" SaveCalleeSaveRegisters'saveAtEntry-4 [#_"LIR" lir, #_"LIRGenerator" lirGen, #_"RegisterArray" calleeSaveRegisters, #_"Architecture" arch]
        (let [
            #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg lir))
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, startBlock)
            #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer''init-2 (LIRInsertionBuffer'new-0), ops)
            #_"LabelOp" entry (nth ops 0)
            #_"RegisterValue[]" savedRegisterValues (make-array RegisterValue (#_"RegisterArray" .size calleeSaveRegisters))
            #_"RegisterMap" saveMap (RegisterMap'new-1 arch)
        ]
            (loop-when [#_"int" i 0 #_"ISeq" s (seq calleeSaveRegisters)] (some? s)
                (let [
                    #_"Register" register (first s)
                    #_"PlatformKind" registerPlatformKind (#_"Architecture" .getLargestStorableKind arch, (#_"Register" .getRegisterCategory register))
                    #_"LIRKind" lirKind (LIRKind'value-1 registerPlatformKind)
                    #_"RegisterValue" registerValue (#_"Register" .asValue register, lirKind)
                    #_"Variable" saveVariable (LIRGenerator''newVariable-2 lirGen, lirKind)
                    #_"LIRInstruction" save (MoveFactory'createMove-2 saveVariable, registerValue)
                ]
                    (ยง ass! buffer (LIRInsertionBuffer''append-3 buffer, 1, save))
                    (RegisterMap''put-3 saveMap, register, saveVariable)
                    (aset savedRegisterValues i registerValue)
                    (recur (inc i) (next s))
                )
            )
            (ยง ass! entry (LabelOp''addIncomingValues-2 entry, savedRegisterValues))
            (ยง ass! buffer (LIRInsertionBuffer''finish-1 buffer))
            saveMap
        )
    )

    (defn- #_"void" SaveCalleeSaveRegisters'restoreAtExit-4 [#_"LIR" lir, #_"MoveFactory" moveFactory, #_"RegisterMap" calleeSaveRegisters, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
            #_"int" i (dec (count ops))
            #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer'new-0)
        ]
            (ยง ass! buffer (LIRInsertionBuffer''init-2 buffer, ops))
            (RegisterMap''forEach-2 calleeSaveRegisters,
                (fn #_"void" [#_"Register" register, #_"Variable" saved]
                    (ยง ass! buffer (LIRInsertionBuffer''append-3 buffer, i, (MoveFactory'createMove-2 (#_"Register" .asValue register, (#_"Value" .getValueKind saved)), saved)))
                    nil
                )
            )
            (ยง ass! buffer (LIRInsertionBuffer''finish-1 buffer))
        )
        nil
    )

    (defm SaveCalleeSaveRegisters LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"SaveCalleeSaveRegisters" this, #_"LIRGenerationResult" lirGenRes, #_"LIRPhaseContext" context]
            (let [
                #_"RegisterArray" calleeSaveRegisters (#_"RegisterConfig" .getCalleeSaveRegisters HotSpot'registerConfig)
            ]
                (when (and (some? calleeSaveRegisters) (not (zero? (#_"RegisterArray" .size calleeSaveRegisters))))
                    (let [
                        #_"LIR" lir (:lir lirGenRes)
                        #_"RegisterMap" savedRegisters (SaveCalleeSaveRegisters'saveAtEntry-4 lir, (:lirGen context), calleeSaveRegisters, (.arch HotSpot'target))
                    ]
                        (doseq [#_"Block" block (:codeEmittingOrder lir)]
                            (when (and (some? block) (empty? (:successors block)))
                                (SaveCalleeSaveRegisters'restoreAtExit-4 lir, (:moveFactory (:lirGen context)), savedRegisters, block)
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; Utility for emitting the instruction to save RBP.
 ;;
(class-ns SaveRbp []
    (defn #_"SaveRbp" SaveRbp'new-2 [#_"LIRGenerator" gen, #_"NoOp" placeholder]
        (merge (SaveRbp'class.)
            (hash-map
                #_"LIRGenerator" :gen gen
                #_"NoOp" :placeholder placeholder
                ;;;
                 ; The slot reserved for saving RBP.
                 ;;
                #_"StackSlot" :reservedSlot (FrameMapBuilder''allocateRBPSpillSlot-1 (:frameMapBuilder (:res gen)))
            )
        )
    )

    ;;;
     ; Replaces this operation with the appropriate move for saving rbp.
     ;
     ; @param useStack specifies if rbp must be saved to the stack
     ;;
    (defn #_"AllocatableValue" SaveRbp''finalize-2 [#_"SaveRbp" this, #_"boolean" useStack]
        (let [
            #_"AllocatableValue" dst
                (if useStack
                    (:reservedSlot this)
                    (do
                        (ยง ass! (:frameMapBuilder (:res (:gen this))) (FrameMapBuilder''freeRBPSpillSlot-1 (:frameMapBuilder (:res (:gen this)))))
                        (LIRGenerator''newVariable-2 (:gen this), (LIRKind'value-1 AMD64Kind/QWORD))
                    )
                )
        ]
            (NoOp''replace-3 (:placeholder this), (:lir (:res (:gen this))), (MoveFromRegOp'new-3 AMD64Kind/QWORD, dst, (#_"Register" .asValue AMD64/rbp, (LIRKind'value-1 AMD64Kind/QWORD))))
            dst
        )
    )
)

;;;
 ; A scaling factor used in the SIB addressing mode.
 ;;
(class-ns Scale []
    (defn- #_"Scale" Scale'new-2 [#_"int" value, #_"int" shift]
        (merge (Scale'class.)
            (hash-map
                ;;;
                 ; The value (or multiplier) of this scale.
                 ;;
                #_"int" :value value
                ;;;
                 ; The shift (value log 2) of this scale.
                 ;;
                #_"int" :shift shift
            )
        )
    )

    (ยง def Scale'Times1 (Scale'new-2 1, 0))
    (ยง def Scale'Times2 (Scale'new-2 2, 1))
    (ยง def Scale'Times4 (Scale'new-2 4, 2))
    (ยง def Scale'Times8 (Scale'new-2 8, 3))

    (defn #_"Scale" Scale'fromInt-1   [#_"int" scale] (case scale 1 Scale'Times1 2 Scale'Times2 4 Scale'Times4 8 Scale'Times8 nil))
    (defn #_"Scale" Scale'fromShift-1 [#_"int" shift] (case shift 0 Scale'Times1 1 Scale'Times2 2 Scale'Times4 3 Scale'Times8 nil))
)

(class-ns ScheduleInstance []
    (def- #_"double" ScheduleInstance'IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR 2)

    (defn #_"ScheduleInstance" ScheduleInstance'new-0 []
        (ScheduleInstance'new-1 nil)
    )

    (defn #_"ScheduleInstance" ScheduleInstance'new-1 [#_"ControlFlowGraph" cfg]
        (merge (ScheduleInstance'class.)
            (hash-map
                #_"ControlFlowGraph" :cfg cfg
                #_"BlockMap<List<Node>>" :blockToNodesMap nil
                #_"NodeMap<Block>" :nodeToBlockMap nil
            )
        )
    )

    (defn- #_"Node*" ScheduleInstance'processStackPhi-4 [#_"Node*" stack, #_"PhiNode" phi, #_"NodeMap<MicroBlock>" mapping, #_"NodeBitMap" visited]
        (when (NodeBitMap''checkAndMarkInc-2 visited, phi) => stack
            (let [
                _ (NodeMap''set-3 mapping, phi, (get mapping (:merge phi)))
            ]
                (dotimes [#_"int" i (AbstractMergeNode''forwardEndCount-1 (:merge phi))]
                    (let [
                        #_"Node" input (PhiNode''valueAt-2i phi, i)
                    ]
                        (when (and (some? input) (nil? (get mapping input)))
                            (ยง ass! stack (cons input stack))
                        )
                    )
                )
                stack
            )
        )
    )

    (defn- #_"Node*" ScheduleInstance'processStackProxy-4 [#_"Node*" stack, #_"ProxyNode" proxy, #_"NodeMap<MicroBlock>" mapping, #_"NodeBitMap" visited]
        (when (NodeBitMap''checkAndMarkInc-2 visited, proxy) => stack
            (let [
                _ (NodeMap''set-3 mapping, proxy, (get mapping (:loopExit proxy)))
                #_"Node" input (:value proxy)
            ]
                (when (and (some? input) (nil? (get mapping input))) => stack
                    (cons input stack)
                )
            )
        )
    )

    ;;;
     ; Processes the inputs of given block. Pushes unprocessed inputs onto the stack. Returns nil if there
     ; were still unprocessed inputs, otherwise returns the earliest block given node can be scheduled in.
     ;;
    (defn- #_"MicroBlock" ScheduleInstance'processInputs-4 [#_"MicroBlock" start, #_"Node*" stack, #_"Node" node, #_"NodeMap<MicroBlock>" mapping]
        (when-not (:isLeafNode (:nodeClass node)) => start
            (loop-when [#_"MicroBlock" earliest start #_"ISeq" s (seq (Node''inputs-1 node))] (some? s) => earliest
                (let [
                    #_"Node" input (first s)
                    #_"MicroBlock" block (get mapping input)
                    earliest
                        (when (nil? block) => (if (and (some? earliest) (< (:id earliest) (:id block))) block earliest)
                            (ยง ass! stack (cons input stack))
                            nil
                        )
                ]
                    (recur earliest (next s))
                )
            )
        )
    )

    (defn- #_"void" ScheduleInstance'processStack-4 [#_"Node" node, #_"MicroBlock" start, #_"NodeMap<MicroBlock>" mapping, #_"NodeBitMap" visited]
        (loop [#_"Node*" stack (list node)]
            (let [
                node (first stack)
                stack
                    (condp satisfies? node
                        PhiNode   (ScheduleInstance'processStackPhi-4 (next stack), node, mapping, visited)
                        ProxyNode (ScheduleInstance'processStackProxy-4 (next stack), node, mapping, visited)
                        (when (nil? (get mapping node)) => (next stack)
                            (let [
                                #_"MicroBlock" earliest (ScheduleInstance'processInputs-4 start, stack, node, mapping)
                            ]
                                (when (some? earliest) => stack ;; We need to delay until inputs are processed.
                                    ;; Can immediately process and pop.
                                    (NodeBitMap''checkAndMarkInc-2 visited, node)
                                    (NodeMap''set-3 mapping, node, earliest)
                                    (ยง ass! earliest (MicroBlock''add-2 earliest, node))
                                    (next stack)
                                )
                            )
                        )
                    )
            ]
                (recur-if (seq stack) [stack])
            )
        )
        nil
    )

    (defn- #_"void" ScheduleInstance'processNodes-4 [#_"Node*" nodes, #_"MicroBlock" start, #_"NodeMap<MicroBlock>" mapping, #_"NodeBitMap" visited]
        (doseq [#_"Node" node nodes]
            (when (nil? (get mapping node))
                (ScheduleInstance'processStack-4 node, start, mapping, visited)
            )
        )
        nil
    )

    (defn- #_"void" ScheduleInstance'scheduleEarliestIterative-6 [#_"ControlFlowGraph" cfg, #_"BlockMap<List<Node>>" blockToNodes, #_"NodeMap<Block>" nodeToBlock, #_"NodeBitMap" visited, #_"Graph" graph, #_"boolean" withGuardOrder]
        (let [
            #_"NodeMap<MicroBlock>" mapping (NodeMap'new-1g graph)
            ;; Initialize with fixed nodes.
            [#_"MicroBlock" start #_"int" nextId]
                (loop-when [start nil nextId 1 #_"ISeq" s (seq (:reversePostOrder cfg))] (some? s) => [start nextId]
                    (let [
                        #_"Block" block (first s)
                        [start nextId]
                            (loop-when [start start nextId nextId #_"ISeq" s (seq (AbstractBeginNode''getBlockNodes-1 (:beginNode block)))] (some? s) => [start nextId]
                                (let [
                                    #_"FixedNode" node (first s)
                                    #_"MicroBlock" microBlock (MicroBlock'new-1 nextId)
                                ]
                                    (NodeMap''set-3 mapping, node, microBlock)
                                    (NodeBitMap''checkAndMarkInc-2 visited, node)
                                    (recur (or start microBlock) (inc nextId) (next s))
                                )
                            )
                    ]
                        (recur start nextId (next s))
                    )
                )
        ]
            (when (GuardsStage'allowsFloatingGuards-1 (:guardsStage graph))
                (let [
                    #_"GuardNode*" guards (Graph''getNodes-2 graph, GuardNode)
                ]
                    (when (seq guards)
                        ;; Now process guards.
                        (when (and GraalOptions'guardPriorities withGuardOrder) => (ScheduleInstance'processNodes-4 guards, start, mapping, visited)
                            ;; 'EnumMap.values' returns values in "natural" key order.
                            (doseq [#_"GuardNode*" guards' (#_"EnumMap" .values (reduce #(let [#_"GuardPriority" p (StaticDeoptimizingNode'''computePriority-1 %2)] (assoc %1 p (conj (vec (get %1 p)) %2))) (sorted-map) guards))]
                                (ScheduleInstance'processNodes-4 guards', start, mapping, visited)
                            )
                            (GuardOrder'resortGuards-2 graph, mapping)
                        )
                    )
                )
            )
            ;; Now process inputs of fixed nodes.
            (doseq [#_"Block" b (:reversePostOrder cfg) #_"FixedNode" n (AbstractBeginNode''getBlockNodes-1 (:beginNode b))]
                (ScheduleInstance'processNodes-4 (Node''inputs-1 n), start, mapping, visited)
            )
            (when (< (:counter visited) (Graph''getNodeCount-1 graph))
                ;; Visit back input edges of loop phis.
                (loop []
                    (let [
                        [#_"boolean" unmarked? #_"boolean" changed?]
                            (loop-when [unmarked? false changed? false #_"ISeq" s (seq (Graph''getNodes-2 graph, LoopBeginNode))] (some? s) => [unmarked? changed?]
                                (let [
                                    #_"LoopBeginNode" loopBegin (first s)
                                    [unmarked? changed?]
                                        (loop-when [unmarked? unmarked? changed? changed? #_"ISeq" s (seq (AbstractMergeNode''phis-1 loopBegin))] (some? s) => [unmarked? changed?]
                                            (let [
                                                #_"PhiNode" phi (first s)
                                                [unmarked? changed?]
                                                    (when (NodeBitMap''isMarked-2n visited, phi) => [true changed?]
                                                        (loop-when [unmarked? unmarked? changed? changed? #_"int" i 0] (< i (:nextEndIndex loopBegin)) => [unmarked? changed?]
                                                            (let [
                                                                #_"Node" node (PhiNode''valueAt-2i phi, (+ i (AbstractMergeNode''forwardEndCount-1 loopBegin)))
                                                                changed?
                                                                    (when (and (some? node) (nil? (get mapping node))) => changed?
                                                                        (ScheduleInstance'processStack-4 node, start, mapping, visited)
                                                                        true
                                                                    )
                                                            ]
                                                                (recur unmarked? changed? (inc i))
                                                            )
                                                        )
                                                    )
                                            ]
                                                (recur unmarked? changed? (next s))
                                            )
                                        )
                                ]
                                    (recur unmarked? changed? (next s))
                                )
                            )
                    ]
                        ;; The processing of one loop phi could have marked a previously checked loop phi, therefore this needs to be iterative.
                        (recur-if (and unmarked? changed?) [])
                    )
                )
            )
            ;; Check for dead nodes.
            (when (< (:counter visited) (Graph''getNodeCount-1 graph))
                (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                    (when-not (NodeBitMap''isMarked-2n visited, node)
                        (Node''clearInputs-1 node)
                        (Node''markDeleted-1 node)
                    )
                )
            )
            (doseq [#_"Block" block (:reversePostOrder cfg)]
                (let [
                    #_"FixedNode" fixedNode (:endNode block)
                ]
                    (when (satisfies? ControlSplitNode fixedNode)
                        (let [
                            #_"AbstractBeginNode" primarySuccessor (ControlSplitNode'''getPrimarySuccessor-1 fixedNode)
                        ]
                            (when (some? primarySuccessor)
                                (ยง ass! (get mapping fixedNode) (MicroBlock''prependChildrenTo-2 (get mapping fixedNode), (get mapping primarySuccessor)))
                            )
                        )
                    )
                )
            )
            (doseq [#_"Block" block (:reversePostOrder cfg)]
                (let [
                    #_"ArrayList<Node>" nodes (ArrayList.)
                ]
                    (doseq [#_"FixedNode" node (AbstractBeginNode''getBlockNodes-1 (:beginNode block))]
                        (NodeMap''set-3 nodeToBlock, node, block)
                        (#_"ArrayList" .add nodes, node)
                        (loop-when-recur [#_"NodeEntry" _next (:head (get mapping node))] (some? _next) [(:next _next)]
                            (NodeMap''set-3 nodeToBlock, (:node _next), block)
                            (#_"ArrayList" .add nodes, (:node _next))
                        )
                    )
                    (BlockMap''put-3 blockToNodes, block, nodes)
                )
            )
        )
        nil
    )

    (defn- #_"void" ScheduleInstance'fillKillSet-2 [#_"LocationSet" killed, #_"Node*" nodes]
        (when-not (LocationSet''isAny-1 killed)
            (loop-when [#_"ISeq" s (seq nodes)] (some? s)
                (let [
                    #_"Node" node (first s)
                ]
                    (or
                        ;; Check if this node kills a node in the watch list.
                        (condp satisfies? node
                            Single
                                (do
                                    (ยง ass! killed (LocationSet''add-2 killed, (Single'''getLocationIdentity-1 node)))
                                    (when (LocationSet''isAny-1 killed)
                                        :done
                                    )
                                )
                            Multi
                                (loop-when [#_"ISeq" s (seq (Multi'''getLocationIdentities-1 node))] (some? s)
                                    (ยง ass! killed (LocationSet''add-2 killed, (first s)))
                                    (when (LocationSet''isAny-1 killed) => (recur (next s))
                                        :done
                                    )
                                )
                            nil
                        )
                        (recur (next s))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"Block" ScheduleInstance'calcBlockForUsage-4 [#_"Node" node, #_"Node" usage, #_"Block" block, #_"NodeMap<Block>" mapping]
        (condp satisfies? usage
            PhiNode
                ;; An input to a PhiNode is used at the end of the predecessor block that
                ;; corresponds to the PhiNode input. One PhiNode can use an input multiple times.
                (let [
                    #_"Block" mergeBlock (get mapping (:merge usage))
                ]
                    (loop-when-recur [block block #_"int" i 0]
                                     (< i (PhiNode''valueCount-1 usage))
                                     [(if (= (PhiNode''valueAt-2i usage, i) node) (ControlFlowGraph'commonDominator-2 block, (nth (:predecessors mergeBlock) i)) block) (inc i)]
                                  => block
                    )
                )
            AbstractBeginNode
                (let [
                    #_"Block" otherBlock (get mapping usage)
                ]
                    (ControlFlowGraph'commonDominator-2 block, (if (satisfies? StartNode usage) otherBlock (:dominator otherBlock)))
                )
            #_else
                ;; All other types of usages: Put the input into the same block as the usage.
                (let [
                    #_"Block" otherBlock (get mapping (if (satisfies? ProxyNode usage) (:loopExit usage) usage))
                ]
                    (ControlFlowGraph'commonDominator-2 block, otherBlock)
                )
        )
    )

    (defn- #_"Block" ScheduleInstance'checkKillsBetween-3 [#_"Block" earliest, #_"Block" latest, #_"LocationIdentity" location]
        (let [
            ;; Collect dominator chain that needs checking.
            #_"List<Block>" dominators (ArrayList.)
            _ (#_"List" .add dominators, latest)
            _
                (loop-when-recur [#_"Block" block (:dominator latest)] (not= block earliest) [(:dominator block)]
                    ;; Current is an intermediate dominator between earliest and latest.
                    (when (Block''canKill-2 block, location)
                        (#_"List" .clear dominators)
                    )
                    (#_"List" .add dominators, block)
                )
        ]
            ;; The first element of dominators now contains the latest possible block.
            (loop-when [#_"Block" last earliest #_"int" i (dec (count dominators))] (<= 0 i) => last
                (let [
                    #_"Block" block (nth dominators i)
                    ;; We are entering a loop boundary. The new loops must not kill the location for the crossing to be safe.
                    ? (or (and (< (Block''getLoopDepth-1 last) (Block''getLoopDepth-1 block)) (some? (:loop block)) (Loop''canKill-2 (:loop block), location)) (Block''canKillBetweenThisAndDominator-2 block, location))
                ]
                    (if ? last (recur block (dec i)))
                )
            )
        )
    )

    (defn- #_"Node" ScheduleInstance'getUnproxifiedUncompressed-1 [#_"Node" node]
        (loop [node node]
            (condp satisfies? node
                ValueProxy
                    (recur (Proxy'''getOriginalNode-1 node))
                ConvertNode
                    (when (ConvertNode'''mayNullCheckSkipConversion-1 node) => node
                        (recur (ConvertNode'''getValue-1 node))
                    )
                node
            )
        )
    )

    (defn- #_"boolean" ScheduleInstance'isImplicitNullOpportunity-2 [#_"FloatingReadNode" floatingReadNode, #_"Block" block]
        (let [
            #_"Node" pred (:predecessor (:beginNode block))
        ]
            (and (satisfies? IfNode pred) (satisfies? IsNullNode (:logic pred))
                (= (ScheduleInstance'getUnproxifiedUncompressed-1 (AddressNode'''getBase-1 (Access'''getAddress-1 floatingReadNode)))
                   (ScheduleInstance'getUnproxifiedUncompressed-1 (Unary'''getValue-1 (:logic pred)))
                )
            )
        )
    )

    (defn- #_"void" ScheduleInstance'selectLatestBlock-7 [#_"Node" currentNode, #_"Block" currentBlock, #_"Block" latestBlock, #_"NodeMap<Block>" currentNodeMap, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"LocationIdentity" constrainingLocation, #_"BlockMap<List<Node>>" latestBlockToNodesMap]
        (when-not (= currentBlock latestBlock)
            (ยง ass! currentNodeMap (NodeMap''setAndGrow-3 currentNodeMap, currentNode, latestBlock))

            (when (and (some? constrainingLocation) (Block''canKill-2 latestBlock, constrainingLocation))
                (when (nil? (BlockMap''get-2 watchListMap, latestBlock))
                    (BlockMap''put-3 watchListMap, latestBlock, (ArrayList.))
                )
                (#_"ArrayList" .add (BlockMap''get-2 watchListMap, latestBlock), (ยง cast #_"FloatingReadNode" currentNode))
            )
        )

        (#_"List" .add (BlockMap''get-2 latestBlockToNodesMap, latestBlock), currentNode)
        nil
    )

    (defn- #_"void" ScheduleInstance'calcLatestBlock-8 [#_"Block" earliest, #_"SchedulingStrategy" strategy, #_"Node" node, #_"NodeMap<Block>" nodeMap, #_"LocationIdentity" constrainingLocation, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"NodeBitMap" visited]
        (let [
            #_"Block" latest
                (when (Node''hasUsages-1 node) => earliest
                    (let [
                        latest
                            (loop-when-recur [latest nil #_"ISeq" s (seq (:nodeUsages node))] (some? s) [(ScheduleInstance'calcBlockForUsage-4 node, (first s), latest, nodeMap) (next s)] => latest)
                        latest
                            (when (any = strategy SchedulingStrategy'FINAL_SCHEDULE SchedulingStrategy'LATEST_OUT_OF_LOOPS) => latest
                                (loop-when [latest latest #_"Block" block latest] (and (< (Block''getLoopDepth-1 earliest) (Block''getLoopDepth-1 block)) (not= block (:dominator earliest))) => latest
                                    (let [
                                        #_"Block" prior block
                                        block (:dominator block)
                                        ;; Only assign new latest block if frequency is actually lower or if loop proxies would be required otherwise.
                                        ? (and (Block''isLoopHeader-1 prior) (or (< (:probability block) (:probability latest)) (:hasValueProxies (:graph node))))
                                    ]
                                        (recur (if ? block latest) block)
                                    )
                                )
                            )
                    ]
                        (when (and (not= latest earliest) (not= latest (:dominator earliest)) (some? constrainingLocation)) => latest
                            (ScheduleInstance'checkKillsBetween-3 earliest, latest, constrainingLocation)
                        )
                    )
                )
            ? (and (not= latest earliest) (satisfies? FloatingReadNode node) (ScheduleInstance'isImplicitNullOpportunity-2 node, earliest) (< (:probability earliest) (* (:probability latest) ScheduleInstance'IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR)))
        ]
            (ScheduleInstance'selectLatestBlock-7 node, earliest, (if ? earliest latest), nodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap)
        )
        nil
    )

    (defn- #_"BlockMap<ArrayList<FloatingReadNode>>" ScheduleInstance''calcLatestBlocks-6 [#_"ScheduleInstance" this, #_"SchedulingStrategy" strategy, #_"NodeMap<Block>" currentNodeMap, #_"BlockMap<List<Node>>" earliestBlockToNodesMap, #_"NodeBitMap" visited, #_"BlockMap<List<Node>>" latestBlockToNodesMap]
        (let [
            #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap (BlockMap'new-1 (:cfg this))
            #_"Block[]" reversePostOrder (:reversePostOrder (:cfg this))
        ]
            (loop-when-recur [#_"int" j (dec (count reversePostOrder))] (<= 0 j) [(dec j)]
                (let [
                    #_"Block" block (nth reversePostOrder j)
                    #_"List<Node>" blockToNodes (BlockMap''get-2 earliestBlockToNodesMap, block)
                ]
                    (loop-when [#_"LocationSet" killed nil #_"int" i' (count blockToNodes) #_"int" i (dec i')] (<= 0 i)
                        (let [
                            #_"Node" node (nth blockToNodes i)
                            [killed i']
                                (when-not (satisfies? FixedNode node) => [killed i'] ;; For these nodes, the earliest is at the same time the latest block.
                                    (let [
                                        [killed i' #_"LocationIdentity" constrainingLocation #_"Block" latestBlock]
                                            (when (satisfies? FloatingReadNode node) => [killed i' nil nil]
                                                ;; We are scheduling a floating read node => check memory anti-dependencies.
                                                (let [
                                                    #_"LocationIdentity" location (Access'''getLocationIdentity-1 node)
                                                ]
                                                    (when-not (:immutable location) => [killed i' nil nil]
                                                        ;; Location can be killed.
                                                        (let [
                                                            constrainingLocation location
                                                            [killed i' latestBlock]
                                                                (when (Block''canKill-2 block, location) => [killed i' nil]
                                                                    (let [
                                                                        killed (or killed (LocationSet'new-0))
                                                                    ]
                                                                        (ScheduleInstance'fillKillSet-2 killed, (#_"List" .subList blockToNodes, (inc i), i'))
                                                                        ;; Earliest block kills location => we need to stay within earliest block.
                                                                        [killed i (when (LocationSet''contains-2 killed, location) block)]
                                                                    )
                                                                )
                                                        ]
                                                            [killed i' constrainingLocation latestBlock]
                                                        )
                                                    )
                                                )
                                            )
                                    ]
                                        (if (nil? latestBlock)
                                            ;; We are not constraint within earliest block => calculate optimized schedule.
                                            (ScheduleInstance'calcLatestBlock-8 block, strategy, node, currentNodeMap, constrainingLocation, watchListMap, latestBlockToNodesMap, visited)
                                            (ScheduleInstance'selectLatestBlock-7 node, block, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap)
                                        )
                                        [killed i']
                                    )
                                )
                        ]
                            (recur killed i' (dec i))
                        )
                    )
                )
            )
            watchListMap
        )
    )

    (defn- #_"void" ScheduleInstance'sortIntoList-6 [#_"Node" node, #_"Block" block, #_"ArrayList<Node>" result, #_"NodeMap<Block>" nodeMap, #_"NodeBitMap" unprocessed, #_"Node" excludeNode]
        (when-not (satisfies? PhiNode node)
            (NodeBitMap''clear-2 unprocessed, node)
            (doseq [#_"Node" input (Node''inputs-1 node)]
                (when (and (= (get nodeMap input) block) (NodeBitMap''isMarked-2n unprocessed, input) (not= input excludeNode))
                    (ScheduleInstance'sortIntoList-6 input, block, result, nodeMap, unprocessed, excludeNode)
                )
            )
            (when-not (satisfies? ProxyNode node) ;; skip proxy nodes
                (#_"ArrayList" .add result, node)
            )
        )
        nil
    )

    (defn- #_"boolean" ScheduleInstance'isFixedEnd-1 [#_"FixedNode" endNode]
        (or (satisfies? ControlSplitNode endNode) (satisfies? ControlSinkNode endNode) (satisfies? AbstractEndNode endNode))
    )

    (defn- #_"void" ScheduleInstance'checkWatchList-6a [#_"ArrayList<FloatingReadNode>" watchList, #_"LocationIdentity" location, #_"Block" block, #_"ArrayList<Node>" result, #_"NodeMap<Block>" nodeMap, #_"NodeBitMap" unprocessed]
        (cond
            (:immutable location)
                nil ;; Nothing to do. This can happen for an initialization write.
            (LocationIdentity''isAny-1 location)
                (do
                    (doseq [#_"FloatingReadNode" r watchList]
                        (when (NodeBitMap''isMarked-2n unprocessed, r)
                            (ScheduleInstance'sortIntoList-6 r, block, result, nodeMap, unprocessed, nil)
                        )
                    )
                    (#_"ArrayList" .clear watchList)
                )
            :else
                (loop-when [#_"int" i 0] (< i (count watchList))
                    (let [
                        #_"FloatingReadNode" r (nth watchList i)
                    ]
                        (when (NodeBitMap''isMarked-2n unprocessed, r)
                            (if (LocationIdentity''overlaps-2 location, (Access'''getLocationIdentity-1 r))
                                (ScheduleInstance'sortIntoList-6 r, block, result, nodeMap, unprocessed, nil)
                                (ยง continue (inc i))
                            )
                        )
                        (let [
                            #_"int" end (dec (count watchList))
                        ]
                            (#_"ArrayList" .set watchList, i, (nth watchList end))
                            (#_"ArrayList" .remove watchList, end)
                            (recur i)
                        )
                    )
                )
        )
        nil
    )

    (defn- #_"void" ScheduleInstance'checkWatchList-6b [#_"Block" block, #_"NodeMap<Block>" nodeMap, #_"NodeBitMap" unprocessed, #_"ArrayList<Node>" result, #_"ArrayList<FloatingReadNode>" watchList, #_"Node" node]
        (when (seq watchList)
            ;; Check if this node kills a node in the watch list.
            (condp satisfies? node
                Single
                    (let [
                        #_"LocationIdentity" location (Single'''getLocationIdentity-1 node)
                    ]
                        (ScheduleInstance'checkWatchList-6a watchList, location, block, result, nodeMap, unprocessed)
                    )
                Multi
                    (doseq [#_"LocationIdentity" location (Multi'''getLocationIdentities-1 node)]
                        (ScheduleInstance'checkWatchList-6a watchList, location, block, result, nodeMap, unprocessed)
                    )
                nil
            )
        )
        nil
    )

    (defn- #_"void" ScheduleInstance'sortNodesLatestWithinBlock-6b [#_"Block" block, #_"BlockMap<List<Node>>" earliestBlockToNodesMap, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"NodeMap<Block>" nodeMap, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"NodeBitMap" unprocessed]
        (let [
            #_"List<Node>" earliestSorting (BlockMap''get-2 earliestBlockToNodesMap, block)
            #_"ArrayList<Node>" result (ArrayList.)
            #_"ArrayList<FloatingReadNode>" watchList (when (some? watchListMap) (BlockMap''get-2 watchListMap, block))
            #_"AbstractBeginNode" beginNode (:beginNode block)
        ]
            (when (satisfies? LoopExitNode beginNode)
                (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 beginNode)]
                    (NodeBitMap''clear-2 unprocessed, proxy)
                    (let [
                        #_"ValueNode" value (:value proxy)
                    ]
                        ;; if multiple proxies reference the same value, schedule the value of a proxy once
                        (when (and (some? value) (= (get nodeMap value) block) (NodeBitMap''isMarked-2n unprocessed, value))
                            (ScheduleInstance'sortIntoList-6 value, block, result, nodeMap, unprocessed, nil)
                        )
                    )
                )
            )
            (let [
                #_"FixedNode" endNode (:endNode block)
                ;; Only if the end node is either a control split or an end node,
                ;; we need to force it to be the last node in the schedule.
                #_"FixedNode" fixedEndNode (when (ScheduleInstance'isFixedEnd-1 endNode) endNode)
            ]
                (loop-when [watchList watchList #_"ISeq" s (seq earliestSorting)] (some? s)
                    (let [
                        #_"Node" node (first s)
                        watchList
                            (when-not (= node fixedEndNode) => watchList
                                (cond
                                    (satisfies? FixedNode node)
                                        (do
                                            (ScheduleInstance'checkWatchList-6b block, nodeMap, unprocessed, result, watchList, node)
                                            (ScheduleInstance'sortIntoList-6 node, block, result, nodeMap, unprocessed, nil)
                                            watchList
                                        )
                                    (and (= (get nodeMap node) block) (satisfies? FloatingReadNode node))
                                        (if (ScheduleInstance'isImplicitNullOpportunity-2 node, block)
                                            (do
                                                ;; Schedule at the beginning of the block.
                                                (ScheduleInstance'sortIntoList-6 node, block, result, nodeMap, unprocessed, nil)
                                                watchList
                                            )
                                            (when (Block''canKill-2 block, (Access'''getLocationIdentity-1 node)) => watchList
                                                ;; This read can be killed in this block, add to watch list.
                                                (let [
                                                    watchList (or watchList (ArrayList.))
                                                ]
                                                    (#_"ArrayList" .add watchList, node)
                                                    watchList
                                                )
                                            )
                                        )
                                    :else
                                        watchList
                                )
                            )
                    ]
                        (recur watchList (next s))
                    )
                )
                (doseq [#_"Node" node (BlockMap''get-2 latestBlockToNodesMap, block)]
                    (when (NodeBitMap''isMarked-2n unprocessed, node)
                        (ScheduleInstance'sortIntoList-6 node, block, result, nodeMap, unprocessed, fixedEndNode)
                    )
                )
                (when (and (some? endNode) (NodeBitMap''isMarked-2n unprocessed, endNode))
                    (ScheduleInstance'sortIntoList-6 endNode, block, result, nodeMap, unprocessed, nil)
                )
                (BlockMap''put-3 latestBlockToNodesMap, block, result)
            )
        )
        nil
    )

    (defn- #_"void" ScheduleInstance'sortNodesLatestWithinBlock-6c [#_"ControlFlowGraph" cfg, #_"BlockMap<List<Node>>" earliestBlockToNodesMap, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"NodeMap<Block>" currentNodeMap, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"NodeBitMap" visited]
        (doseq [#_"Block" block (:reversePostOrder cfg)]
            (ScheduleInstance'sortNodesLatestWithinBlock-6b block, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited)
        )
        nil
    )

    (defn #_"ScheduleInstance" ScheduleInstance''run-3 [#_"ScheduleInstance" this, #_"Graph" graph, #_"SchedulingStrategy" selectedStrategy]
        (let [
            this
                (when (nil? (:cfg this)) => this
                    (assoc this :cfg (ControlFlowGraph'compute-5 graph, true, true, true, false))
                )
            #_"NodeMap<Block>" currentNodeMap (NodeMap'new-1g graph)
            #_"NodeBitMap" visited (NodeBitMap'new-1 graph)
            #_"BlockMap<List<Node>>" earliestBlockToNodesMap (BlockMap'new-1 (:cfg this))
            this (assoc this :nodeToBlockMap currentNodeMap)
            this (assoc this :blockToNodesMap earliestBlockToNodesMap)
        ]
            (ScheduleInstance'scheduleEarliestIterative-6 (:cfg this), earliestBlockToNodesMap, currentNodeMap, visited, graph, (= selectedStrategy SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER))

            (let [
                this
                    (when-not (SchedulingStrategy'isEarliest-1 selectedStrategy) => this
                        ;; For non-earliest schedules, we need to do a second pass.
                        (let [
                            #_"BlockMap<List<Node>>" latestBlockToNodesMap (BlockMap'new-1 (:cfg this))
                            _
                                (doseq [#_"Block" block (:reversePostOrder (:cfg this))]
                                    (BlockMap''put-3 latestBlockToNodesMap, block, (ArrayList.))
                                )
                            #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap (ScheduleInstance''calcLatestBlocks-6 this, selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap)
                        ]
                            (ScheduleInstance'sortNodesLatestWithinBlock-6c (:cfg this), earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited)

                            (assoc this :blockToNodesMap latestBlockToNodesMap)
                        )
                    )
                _ (ยง ass! (:cfg this) (ControlFlowGraph''setNodeToBlock-2 (:cfg this), currentNodeMap))
                _ (ยง ass! graph (Graph''setLastSchedule-2 graph, (ScheduleResult'new-3 (:cfg this), (:nodeToBlockMap this), (:blockToNodesMap this))))
            ]
                this
            )
        )
    )
)

(class-ns SchedulePhase [Phase]
    (defn #_"SchedulePhase" SchedulePhase'new-1 [#_"SchedulingStrategy" strategy]
        (merge (SchedulePhase'class.)
            (hash-map
                #_"SchedulingStrategy" :selectedStrategy strategy
            )
        )
    )

    (defn #_"SchedulePhase" SchedulePhase'new-0 []
        (SchedulePhase'new-1 (if GraalOptions'optScheduleOutOfLoops SchedulingStrategy'LATEST_OUT_OF_LOOPS SchedulingStrategy'LATEST))
    )

    (defm SchedulePhase Phase
        (#_"Graph" Phase'''run-3 [#_"SchedulePhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (ยง ass! instance (ScheduleInstance''run-3 (ScheduleInstance'new-0), graph, (:selectedStrategy this)))
            graph
        )
    )

    (defn #_"void" SchedulePhase'run-3 [#_"Graph" graph, #_"SchedulingStrategy" strategy, #_"ControlFlowGraph" cfg]
        (ยง ass! instance (ScheduleInstance''run-3 (ScheduleInstance'new-1 cfg), graph, strategy))
        nil
    )
)

(class-ns ScheduleResult []
    (defn #_"ScheduleResult" ScheduleResult'new-3 [#_"ControlFlowGraph" cfg, #_"NodeMap<Block>" nodeToBlockMap, #_"BlockMap<List<Node>>" blockToNodesMap]
        (merge (ScheduleResult'class.)
            (hash-map
                #_"ControlFlowGraph" :cfg cfg
                #_"NodeMap<Block>" :nodeToBlockMap nodeToBlockMap
                #_"BlockMap<List<Node>>" :blockToNodesMap blockToNodesMap
            )
        )
    )

    (defn #_"List<Node>" ScheduleResult''nodesFor-2 [#_"ScheduleResult" this, #_"Block" block]
        (BlockMap''get-2 (:blockToNodesMap this), block)
    )
)

(class-ns ScheduledNodeIterator []
    (defn #_"ScheduledNodeIterator" ScheduledNodeIterator'new-0 []
        (merge (ScheduledNodeIterator'class.)
            (hash-map
                #_"FixedWithNextNode" :lastFixed nil
                #_"FixedWithNextNode" :reconnect nil
                #_"ListIterator<Node>" :iterator nil
            )
        )
    )

    (defn #_"void" ScheduledNodeIterator''processNodes-3 [#_"ScheduledNodeIterator" this, #_"Block" block, #_"ScheduleResult" schedule]
        (ยง ass! this (assoc this :lastFixed (:beginNode block)))
        (ยง ass! this (assoc this :reconnect nil))
        (ยง ass! this (assoc this :iterator (#_"List" .listIterator (ScheduleResult''nodesFor-2 schedule, block))))

        (loop-when-recur [] (#_"ListIterator" .hasNext (:iterator this)) []
            (let [
                #_"Node" node (#_"ListIterator" .next (:iterator this))
            ]
                (when (Node''isAlive-1 node)
                    (when (and (some? (:reconnect this)) (satisfies? FixedNode node))
                        (ยง ass! (:reconnect this) (FixedWithNextNode''setNext-2 (:reconnect this), node))
                        (ยง ass! this (assoc this :reconnect nil))
                    )
                    (when (satisfies? FixedWithNextNode node)
                        (ยง ass! this (assoc this :lastFixed node))
                    )
                    (ScheduledNodeIterator'''processNode-2 this, node)
                )
            )
        )
        (when (some? (:reconnect this))
            (ยง ass! (:reconnect this) (FixedWithNextNode''setNext-2 (:reconnect this), (:beginNode (Block''getFirstSuccessor-1 block))))
        )
        nil
    )

    (defn #_"this" ScheduledNodeIterator''insert-3 [#_"ScheduledNodeIterator" this, #_"FixedNode" start, #_"FixedWithNextNode" end]
        (let [
            _ (ยง ass! (:lastFixed this) (FixedWithNextNode''setNext-2 (:lastFixed this), start))
            this (assoc this :lastFixed end)
            this (assoc this :reconnect end)
        ]
            this
        )
    )

    (defn #_"ScheduledNodeIterator" ScheduledNodeIterator''replaceCurrent-2 [#_"ScheduledNodeIterator" this, #_"FixedWithNextNode" newNode]
        (let [
            #_"Node" current (#_"ListIterator" .previous (:iterator this))
        ]
            (#_"ListIterator" .next (:iterator this)) ;; needed because of the previous() call
            (let [
                _ (ยง ass! current (Node''replaceAndDelete-2 current, newNode))
                this (ScheduledNodeIterator''insert-3 this, newNode, newNode)
            ]
                (#_"ListIterator" .set (:iterator this), newNode)
                this
            )
        )
    )
)

(class-ns FixReadsClosure [ScheduledNodeIterator]
    (defn #_"FixReadsClosure" FixReadsClosure'new-0 []
        (merge (FixReadsClosure'class.) (ScheduledNodeIterator'new-0))
    )

    (defm FixReadsClosure ScheduledNodeIterator
        (#_"void" ScheduledNodeIterator'''processNode-2 [#_"FixReadsClosure" this, #_"Node" node]
            (condp satisfies? node
                AbstractMergeNode
                    (doseq [#_"MemoryPhiNode" memoryPhi (ยง snap (AbstractMergeNode''memoryPhis-1 node))]
                        ;; Memory phi nodes are no longer necessary at this point.
                        (ยง ass! memoryPhi (Node''replaceAtUsages-2 memoryPhi, nil))
                        (Node''safeDelete-1 memoryPhi)
                    )
                FloatingAccessNode
                    (do
                        (MemoryAccess'''setLastLocationAccess-2 node, nil)
                        (ยง ass! this (ScheduledNodeIterator''replaceCurrent-2 this, (FloatingAccessNode'''asFixedNode-1 node)))
                    )
                PiNode
                    (when (Stamp'''isCompatible-2s (:stamp node), (:stamp (Proxy'''getOriginalNode-1 node)))
                        ;; Pi nodes are no longer necessary at this point.
                        (ยง ass! node (Node''replaceAndDelete-2 node, (Proxy'''getOriginalNode-1 node)))
                    )
                MemoryAccess
                    (MemoryAccess'''setLastLocationAccess-2 node, nil)
                nil
            )
            nil
        )
    )
)

(class-ns LowerGuards [ScheduledNodeIterator]
    (defn #_"LowerGuards" LowerGuards'new-1 [#_"Block" block]
        (merge (LowerGuards'class.) (ScheduledNodeIterator'new-0)
            (hash-map
                #_"Block" :block block
            )
        )
    )

    (defn- #_"void" LowerGuards''insertLoopExits-2 [#_"LowerGuards" this, #_"DeoptimizeNode" deopt]
        (let [
            #_"Graph" graph (:graph deopt)
        ]
            (loop-when-recur [#_"Loop" _loop (:loop (:block this))] (some? _loop) [(:parent _loop)]
                (Graph''addBeforeFixed-3 graph, deopt, (Graph''add-2 graph, (LoopExitNode'new-1 (:beginNode (:header _loop)))))
            )
        )
        nil
    )

    (defn- #_"void" LowerGuards''lowerToIf-2 [#_"LowerGuards" this, #_"GuardNode" guard]
        (let [
            #_"Graph" graph (:graph guard)
            #_"AbstractBeginNode" fastPath (Graph''add-2 graph, (BeginNode'new-0))
            #_"DeoptimizeNode" deopt (Graph''add-2 graph, (DeoptimizeNode'new-5 (:action guard), (:reason guard), DeoptimizeNode'DEFAULT_DEBUG_ID, (:speculation guard), nil))
            #_"AbstractBeginNode" deoptBranch (BeginNode'begin-1 deopt)
            _ (LowerGuards''insertLoopExits-2 this, deopt)
            [#_"AbstractBeginNode" then #_"AbstractBeginNode" else] (if (:negated? guard) [deoptBranch fastPath] [fastPath deoptBranch])
            #_"IfNode" ifNode (Graph''add-2 graph, (IfNode'new-4b (DeoptimizingGuard'''getCondition-1 guard), then, else, (if (= then fastPath) 1 0)))
        ]
            (ยง ass! guard (Node''replaceAndDelete-2 guard, fastPath))
            (ยง ass! this (ScheduledNodeIterator''insert-3 this, ifNode, fastPath))
        )
        nil
    )

    (defm LowerGuards ScheduledNodeIterator
        (#_"void" ScheduledNodeIterator'''processNode-2 [#_"LowerGuards" this, #_"Node" node]
            (when (satisfies? GuardNode node)
                (LowerGuards''lowerToIf-2 this, node)
            )
            nil
        )
    )
)

;;;
 ; A scope holds information for the contents of one loop or of the root of the method.
 ;
 ; It does not include child loops, i.e. the iteration in #process(NodeWorkList)
 ; explicitly excludes the nodes of child loops.
 ;;
(class-ns Scope []
    (defn #_"Scope" Scope'new-3 [#_"ComputeInliningRelevance" relevance, #_"FixedNode" start, #_"Scope" parent]
        (merge (Scope'class.)
            (hash-map
                #_"ComputeInliningRelevance" :relevance relevance
                #_"FixedNode" :start start
                #_"Scope" :parent parent ;; can be nil for the outermost scope
                ;;;
                 ; The minimum probability along the most probable path in this scope. Computed lazily.
                 ;;
                #_"double" :fastPathMinProbability ComputeInliningRelevance'UNINITIALIZED
                ;;;
                 ; A measure of how important this scope is within its parent scope. Computed lazily.
                 ;;
                #_"double" :scopeRelevanceWithinParent ComputeInliningRelevance'UNINITIALIZED
            )
        )
    )

    (defn #_"double" Scope''getFastPathMinProbability-1 [#_"Scope" this]
        (when (= (:fastPathMinProbability this) ComputeInliningRelevance'UNINITIALIZED)
            (ยง ass! this (assoc this :fastPathMinProbability (max ComputeInliningRelevance'EPSILON (ComputeInliningRelevance''computeFastPathMinProbability-2 (:relevance this), (:start this)))))
        )
        (:fastPathMinProbability this)
    )

    ;;;
     ; Computes the ratio between the probabilities of the current scope's entry point and the
     ; parent scope's fastPathMinProbability.
     ;;
    (defn #_"double" Scope''getScopeRelevanceWithinParent-1 [#_"Scope" this]
        (when (= (:scopeRelevanceWithinParent this) ComputeInliningRelevance'UNINITIALIZED)
            (ยง ass! this (assoc this :scopeRelevanceWithinParent (if (satisfies? LoopBeginNode (:start this)) (/ (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities (:relevance this)), (LoopBeginNode''forwardEnd-1 (:start this))) (Scope''getFastPathMinProbability-1 (:parent this))) 1.0)))
        )
        (:scopeRelevanceWithinParent this)
    )

    ;;;
     ; Processes all invokes in this scope by starting at the scope's start node and iterating
     ; all fixed nodes. Child loops are skipped by going from loop entries directly to the loop
     ; exits. Processing stops at loop exits of the current loop.
     ;;
    (defn #_"void" Scope''process-2 [#_"Scope" this, #_"NodeWorkList" workList]
        (NodeWorkList''addAll-2 workList, (Node''successors-1 (:start this)))

        (doseq [#_"Node" node workList]
            (condp satisfies? node
                InvokeNode
                (do
                    ;; process the invoke and queue its successors
                    (#_"EconomicMap" .put (:nodeRelevances (:relevance this)), node, (Scope''computeInvokeRelevance-2 this, node))
                    (NodeWorkList''addAll-2 workList, (Node''successors-1 node))
                )
                LoopBeginNode
                    ;; skip child loops by advancing over the loop exits
                    (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 node)]
                        (NodeWorkList'''add-2 workList, (:next exit))
                    )
                LoopEndNode       nil ;; nothing to do
                LoopExitNode      nil ;; nothing to do
                FixedWithNextNode (NodeWorkList'''add-2 workList, (:next node))
                EndNode           (NodeWorkList'''add-2 workList, (AbstractEndNode'''merge-1 node))
                ControlSinkNode   nil ;; nothing to do
                ControlSplitNode  (NodeWorkList''addAll-2 workList, (Node''successors-1 node))
                nil
            )
        )
        nil
    )

    ;;;
     ; The relevance of an invoke is the ratio between the invoke's probability and the current
     ; scope's fastPathMinProbability, adjusted by scopeRelevanceWithinParent.
     ;;
    (defn #_"double" Scope''computeInvokeRelevance-2 [#_"Scope" this, #_"InvokeNode" invoke]
        (* (/ (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities (:relevance this)), invoke) (Scope''getFastPathMinProbability-1 this)) (min (Scope''getScopeRelevanceWithinParent-1 this) 1.0))
    )
)

(class-ns SnippetInfo []
    (defn #_"SnippetInfo" SnippetInfo'new-2 [#_"ResolvedJavaMethod" method, #_"LocationIdentity[]" privateLocations]
        (merge (SnippetInfo'class.)
            (hash-map
                #_"ResolvedJavaMethod" :method method
                #_"LocationIdentity[]" :privateLocations privateLocations
            )
        )
    )
)

;;;
 ; A snippet template is a graph created by parsing a snippet method and then specialized by binding
 ; constants to the snippet's ConstantParameter parameters.
 ;;
(class-ns SnippetTemplate []
    (defn- #_"void" SnippetTemplate'explodeLoops-1 [#_"Graph" snippetCopy]
        ;; do any required loop explosion
        (loop []
            (let [
                #_"boolean" exploded? false
                #_"ExplodeLoopNode" explodeLoop (first (Graph''getNodes-2 snippetCopy, ExplodeLoopNode))
            ]
                (when (some? explodeLoop) ;; earlier canonicalization may have removed the loop altogether
                    (let [
                        #_"LoopBeginNode" loopBegin (ExplodeLoopNode''findLoopBegin-1 explodeLoop)
                    ]
                        (when (some? loopBegin)
                            (let [
                                #_"LoopEx" _loop (LoopsData''loop-2 (LoopsData'new-1 snippetCopy), loopBegin)
                                #_"int" mark (Graph''getMark-1 snippetCopy)
                            ]
                                (LoopTransformations'fullUnroll-2 _loop, (CanonicalizerPhase'new-0))
                                (CanonicalizerPhase''applyIncremental-3m (CanonicalizerPhase'new-0), snippetCopy, mark)
                                (LoopEx''deleteUnusedNodes-1 _loop)
                            )
                        )
                        (GraphUtil'removeFixedWithUnusedInputs-1 explodeLoop)
                        (ยง ass exploded? true)
                    )
                )
                (recur-if exploded? [])
            )
        )
        nil
    )

    (defn #_"SnippetTemplate" SnippetTemplate'new-2 [#_"Arguments" args, #_"Node" replacee]
        (let [
            #_"SnippetTemplate" this
                (merge (SnippetTemplate'class.)
                    (hash-map
                        ;;;
                         ; The graph built from the snippet method.
                         ;;
                        #_"Graph" :snippet nil
                        #_"SnippetInfo" :info (:info args)
                        ;;;
                         ; The named parameters of this template that must be bound to values during instantiation.
                         ; For a parameter that is still live after specialization, the value in this map is either
                         ; a ParameterNode instance or a ParameterNode array. For an eliminated parameter,
                         ; the value is identical to the key.
                         ;;
                        #_"Object[]" :parameters nil
                        ;;;
                         ; The return node (if any) of the snippet.
                         ;;
                        #_"ReturnNode" :returnNode nil
                        ;;;
                         ; The memory anchor (if any) of the snippet.
                         ;;
                        #_"MemoryAnchorNode" :memoryAnchor nil
                        ;;;
                         ; Nodes that inherit the StateSplit#stateAfter() from the replacee during instantiation.
                         ;;
                        #_"ArrayList<StateSplit>" :sideEffectNodes nil
                        ;;;
                         ; Nodes that inherit a deoptimization FrameState from the replacee during instantiation.
                         ;;
                        #_"ArrayList<DeoptimizingNode>" :deoptNodes nil
                        ;;;
                         ; Nodes that have a stamp originating from a Placeholder.
                         ;;
                        #_"ArrayList<ValueNode>" :placeholderStampedNodes nil
                        ;;;
                         ; The nodes to be inlined when this specialization is instantiated.
                         ;;
                        #_"ArrayList<Node>" :nodes nil
                    )
                )
            #_"Graph" snippetGraph (Replacements'createSnippet-1 (:method (:info args)))
            #_"ResolvedJavaMethod" method (:rootMethod snippetGraph)
            #_"Signature" signature (#_"ResolvedJavaMethod" .getSignature method)
            ;; copy snippet graph replacing constant parameters with given arguments
            #_"Graph" snippetCopy (Graph'new-1 (:rootMethod snippetGraph))
            #_"EconomicMap<Node, Node>" nodeReplacements (EconomicMap/create)
            _ (#_"EconomicMap" .put nodeReplacements, (:start snippetGraph), (:start snippetCopy))
            _ (Graph''addDuplicates-5m snippetCopy, (Graph''getNodes-1 snippetGraph), snippetGraph, (Graph''getNodeCount-1 snippetGraph), nodeReplacements)
            ;; gather the template parameters
            #_"int" parameterCount (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature (:method (:info args))), false)
            this (assoc this :parameters (make-array Object parameterCount))
            _
                (loop-when-recur [#_"int" i 0] (< i parameterCount) [(inc i)]
                    (aset (:parameters this) i (or (Graph''getParameter-2 snippetCopy, i) "UNUSED_PARAMETER")) ;; parameter value was eliminated
                )
            _ (SnippetTemplate'explodeLoops-1 snippetCopy)
            ;; perform lowering on the snippet
            snippetCopy
                (when-not (GuardsStage'allowsFloatingGuards-1 (:guardsStage args)) => snippetCopy
                    (Phase'''run-3 (GuardLoweringPhase'new-0), snippetCopy, nil)
                )
            snippetCopy (Graph''setGuardsStage-2 snippetCopy, (:guardsStage args))
            snippetCopy (Phase'''run-3 (LoweringPhase'new-2 (CanonicalizerPhase'new-0), (:loweringStage args)), snippetCopy, nil)
            #_"ArrayList<StateSplit>" curSideEffectNodes (ArrayList.)
            #_"ArrayList<DeoptimizingNode>" curDeoptNodes (ArrayList.)
            #_"ArrayList<ValueNode>" curPlaceholderStampedNodes (ArrayList.)
            _
                (doseq [#_"Node" node (Graph''getNodes-1 snippetCopy)]
                    (when (and (satisfies? ValueNode node) (= (:stamp node) PlaceholderStamp'SINGLETON))
                        (#_"ArrayList" .add curPlaceholderStampedNodes, node)
                    )
                    (when (satisfies? StateSplit node)
                        (let [
                            #_"FrameState" frameState (:stateAfter node)
                        ]
                            (when (StateSplit'''hasSideEffect-1 node)
                                (#_"ArrayList" .add curSideEffectNodes, node)
                            )
                            (when (some? frameState)
                                (StateSplit'''setStateAfter-2 node, nil)
                            )
                        )
                    )
                    (when (and (satisfies? DeoptimizingNode node) (DeoptimizingNode'''canDeoptimize-1 node))
                        (#_"ArrayList" .add curDeoptNodes, node)
                    )
                )
            snippetCopy (Phase'''run-3 (DeadCodeEliminationPhase'new-1 Optionality'Required), snippetCopy, nil)
            snippetCopy (Phase'''run-3 (FloatingReadPhase'new-2 true, true), snippetCopy, nil)
            snippetCopy (Phase'''run-3 (RemoveValueProxyPhase'new-0), snippetCopy, nil)
            #_"MemoryAnchorNode" anchor (Graph''add-2 snippetCopy, (MemoryAnchorNode'new-0))
            _ (Node''replaceAtUsages-3 (:start snippetCopy), InputType'Memory, anchor)
            this (assoc this :snippet snippetCopy)
            #_"StartNode" start (:start (:snippet this))
            this
                (if (Node''hasNoUsages-1 anchor)
                    (do
                        (Node''safeDelete-1 anchor)
                        (assoc this :memoryAnchor nil)
                    )
                    ;; find out if all the return memory maps point to the anchor (i.e. there's no kill anywhere)
                    (let [
                        #_"boolean" needsMemoryMaps
                            (loop-when [#_"ISeq" s (seq (Graph''getNodes-2 (:snippet this), ReturnNode))] (some? s) => false
                                (let [
                                    #_"MemoryMapNode" memoryMap (:memoryMap (first s))
                                ]
                                    (or (< 1 (count (MemoryMap'''getLocations-1 memoryMap))) (not= (MemoryMap'''getLastLocationAccess-2 memoryMap, LocationIdentity'ANY) anchor)
                                        (recur (next s))
                                    )
                                )
                            )
                        #_"boolean" needsAnchor
                            (or needsMemoryMaps
                                ;; check that all those memory maps where the only usages of the anchor
                                (let [
                                    needsAnchor (seq (remove #(satisfies? MemoryMapNode %) (:nodeUsages anchor)))
                                    ;; remove the useless memory map
                                    #_"MemoryMapNode" memoryMap
                                        (loop-when [memoryMap nil #_"ISeq" s (seq (Graph''getNodes-2 (:snippet this), ReturnNode))] (some? s) => memoryMap
                                            (let [
                                                #_"ReturnNode" retNode (first s)
                                                memoryMap (or memoryMap (:memoryMap retNode))
                                            ]
                                                (ยง ass! retNode (ReturnNode''setMemoryMap-2 retNode, nil))
                                                (recur memoryMap (next s))
                                            )
                                        )
                                ]
                                    (Node''safeDelete-1 memoryMap)
                                    needsAnchor
                                )
                            )
                    ]
                        (if needsAnchor
                            (do
                                (Graph''addAfterFixed-3 snippetCopy, (:start snippetCopy), anchor)
                                (assoc this :memoryAnchor anchor)
                            )
                            (do
                                (Node''safeDelete-1 anchor)
                                (assoc this :memoryAnchor nil)
                            )
                        )
                    )
                )
            #_"ReturnNode*" returnNodes (Graph''getNodes-2 (:snippet this), ReturnNode)
            this
                (case (count returnNodes)
                    0 (assoc this :returnNode nil)
                    1 (assoc this :returnNode (nth returnNodes 0))
                    (let [
                        #_"AbstractMergeNode" merge (Graph''add-2 (:snippet this), (MergeNode'new-0))
                        #_"List<MemoryMapNode>" memMaps (ArrayList.)
                        _
                            (doseq [#_"ReturnNode" r returnNodes]
                                (let [
                                    #_"MemoryMapNode" memoryMapNode (:memoryMap r)
                                ]
                                    (when (some? memoryMapNode)
                                        (#_"List" .add memMaps, memoryMapNode)
                                    )
                                )
                            )
                        this (assoc this :returnNode (Graph''add-2 (:snippet this), (ReturnNode'new-1 (ValueMergeUtil'mergeReturns-2 merge, returnNodes))))
                    ]
                        (when (seq memMaps)
                            (let [
                                #_"MemoryMapNode" memoryMap (Graph''add-2 (:snippet this), (MemoryMapNode'new-1 (:lastMemorySnapshot (FloatingReadPhase'mergeMemoryMaps-2 merge, memMaps))))
                            ]
                                (ยง ass! (:returnNode this) (ReturnNode''setMemoryMap-2 (:returnNode this), memoryMap))
                                (doseq [#_"MemoryMapNode" m memMaps]
                                    (when (and (not= m memoryMap) (Node''isAlive-1 m))
                                        (GraphUtil'killWithUnusedFloatingInputs-1 m)
                                    )
                                )
                            )
                        )
                        (ยง ass! merge (FixedWithNextNode''setNext-2 merge, (:returnNode this)))
                        this
                    )
                )
            this (assoc this :sideEffectNodes curSideEffectNodes)
            this (assoc this :deoptNodes curDeoptNodes)
            this (assoc this :placeholderStampedNodes curPlaceholderStampedNodes)
            this (assoc this :nodes (ArrayList.))
            _
                (doseq [#_"Node" node (Graph''getNodes-1 (:snippet this))]
                    (when-not (any = node start (:stateAfter start))
                        (#_"ArrayList" .add (:nodes this), node)
                    )
                )
        ]
            (ยง ass! (:snippet this) (Graph''freeze-1 (:snippet this)))

            this
        )
    )

    ;;;
     ; Converts a Java boxed value to a JavaConstant of the right kind. This adjusts for the
     ; limitation that a Local's kind is a {@linkplain JavaKind#getStackKind() stack kind}
     ; and so cannot be used for re-boxing primitives smaller than an int.
     ;
     ; @param argument a Java boxed value
     ; @param localKind the kind of the Local to which {@code argument} will be bound
     ;;
    (defn- #_"JavaConstant" SnippetTemplate'forBoxed-2 [#_"Object" argument, #_"JavaKind" localKind]
        (if (= localKind JavaKind/Int)
            (JavaConstant/forBoxedPrimitive argument)
            (SnippetReflection'forBoxed-2 localKind, argument)
        )
    )

    ;;;
     ; Gets the instantiation-time bindings to this template's parameters.
     ;
     ; @return the map that will be used to bind arguments to parameters when inlining this template
     ;;
    (defn- #_"EconomicMap<Node, Node>" SnippetTemplate''bind-3 [#_"SnippetTemplate" this, #_"Graph" replaceeGraph, #_"Arguments" args]
        (let [
            #_"EconomicMap<Node, Node>" replacements (EconomicMap/create)
        ]
            (loop-when-recur [#_"int" i 0] (< i (count (:parameters this))) [(inc i)]
                (let [
                    #_"Object" parameter (nth (:parameters this) i)
                    #_"Object" argument (nth (:values args) i)
                ]
                    (condp instance? parameter
                        ParameterNode'iface
                            (#_"EconomicMap" .put replacements, parameter, (if (satisfies? ValueNode argument) argument (ConstantNode'forConstant-2c (SnippetTemplate'forBoxed-2 argument, (ValueNode''getStackKind-1 parameter)), replaceeGraph)))
                        (ร ParameterNode'array)
                            (let [
                                [#_"List" list #_"Object" array] (if (instance? List (:value argument)) [(:value argument) nil] [nil (:value argument)])
                            ]
                                (dotimes [#_"int" j (count parameter)]
                                    (let [
                                        #_"ParameterNode" param (nth parameter j)
                                        #_"Object" value (nth (or list array) j)
                                    ]
                                        (#_"EconomicMap" .put replacements, param, (if (satisfies? ValueNode value) value (ConstantNode'forConstant-2c (SnippetTemplate'forBoxed-2 value, (ValueNode''getStackKind-1 param)), replaceeGraph)))
                                    )
                                )
                            )
                        nil
                    )
                )
            )
            replacements
        )
    )

    (defn- #_"{Node Node}" SnippetTemplate''inlineSnippet-4 [#_"SnippetTemplate" this, #_"Node" replacee, #_"Graph" replaceeGraph, #_"EconomicMap<Node, Node>" replacements]
        (Graph''addDuplicates-5m replaceeGraph, (:nodes this), (:snippet this), (Graph''getNodeCount-1 (:snippet this)), replacements)
    )

    (defn- #_"void" SnippetTemplate''rewireFrameStates-3 [#_"SnippetTemplate" this, #_"ValueNode" replacee, #_"{Node Node}" duplicates]
        (when (satisfies? StateSplit replacee)
            (doseq [#_"StateSplit" sideEffectNode (:sideEffectNodes this)]
                (StateSplit'''setStateAfter-2 (get duplicates sideEffectNode), (:stateAfter replacee))
            )
        )
        nil
    )

    (defn- #_"void" SnippetTemplate''propagateStamp-2 [#_"SnippetTemplate" this, #_"Node" node]
        (when (and (satisfies? PhiNode node) (ValueNode'''inferStamp-1 node))
            (doseq [#_"Node" usage (:nodeUsages node)]
                (SnippetTemplate''propagateStamp-2 this, usage)
            )
        )
        nil
    )

    (defn- #_"void" SnippetTemplate''updateStamps-3 [#_"SnippetTemplate" this, #_"ValueNode" replacee, #_"{Node Node}" duplicates]
        (doseq [#_"ValueNode" node (:placeholderStampedNodes this)]
            (let [
                #_"ValueNode" dup (get duplicates node)
                #_"Stamp" replaceeStamp (:stamp replacee)
            ]
                (if (satisfies? Placeholder node)
                    (Placeholder'''makeReplacement-2 dup, replaceeStamp)
                    (ยง ass! dup (ValueNode''setStamp-2 dup, replaceeStamp))
                )
            )
        )
        (doseq [#_"ParameterNode" paramNode (Graph''getNodes-2 (:snippet this), ParameterNode) #_"Node" usage (:nodeUsages paramNode)]
            (SnippetTemplate''propagateStamp-2 this, (get duplicates usage))
        )
        nil
    )

    (defn- #_"LocationIdentity" SnippetTemplate'getLocationIdentity-1 [#_"Node" node]
        (condp satisfies? node
            MemoryAccess  (MemoryAccess'''getLocationIdentity-1 node)
            MemoryPhiNode (:locationIdentity node)
            nil
        )
    )

    (defn- #_"void" SnippetTemplate'replaceMemoryUsages-2 [#_"ValueNode" node, #_"MemoryMap" map]
        (doseq [#_"Node" usage (:nodeUsages node)]
            (when-not (satisfies? MemoryMapNode usage)
                (when-some [#_"LocationIdentity" location (SnippetTemplate'getLocationIdentity-1 usage)]
                    (doseq [#_"Position" pos (Node''inputPositions-1 usage)]
                        (when (and (= (Position''getInputType-1 pos) InputType'Memory) (= (Position''get-2 pos, usage) node))
                            (when-some [#_"MemoryNode" replacement (MemoryMap'''getLastLocationAccess-2 map, location)]
                                (Position''set-3 pos, usage, replacement)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" SnippetTemplate''rewireMemoryGraph-3 [#_"SnippetTemplate" this, #_"ValueNode" replacee, #_"{Node Node}" duplicates]
        (when (:isAfterFloatingReadPhase (:graph replacee))
            ;; rewire outgoing memory edges
            (SnippetTemplate'replaceMemoryUsages-2 replacee, (MemoryOutputMap'new-3 this, replacee, duplicates))

            (when (some? (:returnNode this))
                (when-some [#_"ReturnNode" ret (get duplicates (:returnNode this))]
                    (when-some [#_"MemoryMapNode" memoryMap (:memoryMap ret)]
                        (ยง ass! ret (ReturnNode''setMemoryMap-2 ret, nil))
                        (Node''safeDelete-1 memoryMap)
                    )
                )
            )
            (when (some? (:memoryAnchor this))
                ;; rewire incoming memory edges
                (let [
                    #_"MemoryAnchorNode" memoryDuplicate (get duplicates (:memoryAnchor this))
                ]
                    (SnippetTemplate'replaceMemoryUsages-2 memoryDuplicate, (MemoryInputMap'new-1 replacee))

                    (when (Node''hasNoUsages-1 memoryDuplicate)
                        (if (some? (:next memoryDuplicate))
                            (Graph''removeFixed-2 (:graph memoryDuplicate), memoryDuplicate)
                            ;; this was a dummy memory node used when instantiating pure data-flow
                            ;; snippets: it was not attached to the control flow
                            (Node''safeDelete-1 memoryDuplicate)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Represents the default {@link UsageReplacer usage replacer} logic which simply delegates to Node#replaceAtUsages(Node).
     ;;
    (def- #_"UsageReplacer" SnippetTemplate'DEFAULT_REPLACER
        (reify UsageReplacer
            (#_"void" UsageReplacer'''replace-3 [#_"UsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode]
                (when (some? newNode)
                    (ยง ass! oldNode (Node''replaceAtUsages-2 oldNode, newNode))
                )
                nil
            )
        )
    )

    ;;;
     ; Replaces a given fixed node with this specialized snippet.
     ;
     ; @param replacee the node that will be replaced
     ; @param args the arguments to be bound to the flattened positional parameters of the snippet
     ; @return the map of duplicated nodes (original -> duplicate)
     ;;
    (defn #_"void" SnippetTemplate''instantiate-3 [#_"SnippetTemplate" this, #_"FixedNode" replacee, #_"Arguments" args]
        ;; inline the snippet nodes replacing parameters with the given args in the process
        (let [
            #_"StartNode" start (:start (:snippet this))
            #_"FixedNode" firstCFGNode (:next start)
            #_"EconomicMap<Node, Node>" replacements (SnippetTemplate''bind-3 this, (:graph replacee), args)
            _ (#_"EconomicMap" .put replacements, start, (AbstractBeginNode'prevBegin-1 replacee))
            #_"{Node Node}" duplicates (SnippetTemplate''inlineSnippet-4 this, replacee, (:graph replacee), replacements)
        ]
            ;; re-wire the control flow graph around the replacee
            (Node''replaceAtPredecessor-2 replacee, (get duplicates firstCFGNode))

            (SnippetTemplate''rewireFrameStates-3 this, replacee, duplicates)

            (when (satisfies? DeoptimizingNode replacee)
                (let [
                    #_"FrameState" stateBefore nil
                    #_"FrameState" stateDuring nil
                    #_"FrameState" stateAfter nil
                ]
                    (when (DeoptimizingNode'''canDeoptimize-1 replacee)
                        (when (satisfies? DeoptBefore replacee)
                            (ยง ass stateBefore (:stateBefore replacee))
                        )
                        (when (satisfies? DeoptDuring replacee)
                            (ยง ass stateDuring (:stateDuring replacee))
                        )
                        (when (satisfies? DeoptAfter replacee)
                            (ยง ass stateAfter (:stateAfter replacee))
                        )
                    )

                    (doseq [#_"DeoptimizingNode" deoptNode (:deoptNodes this)]
                        (let [
                            #_"DeoptimizingNode" deoptDup (get duplicates deoptNode)
                        ]
                            (when (DeoptimizingNode'''canDeoptimize-1 deoptDup)
                                (when (satisfies? DeoptBefore deoptDup)
                                    (DeoptBefore'''setStateBefore-2 deoptDup, stateBefore)
                                )
                                (when (satisfies? DeoptDuring deoptDup)
                                    (cond
                                        (some? stateDuring) (DeoptDuring'''setStateDuring-2 deoptDup, stateDuring)
                                        (some? stateAfter)  (DeoptDuring'''computeStateDuring-2 deoptDup, stateAfter)
                                        (some? stateBefore) (DeoptDuring'''setStateDuring-2 deoptDup, stateBefore)
                                    )
                                )
                                (when (satisfies? DeoptAfter deoptDup)
                                    (StateSplit'''setStateAfter-2 deoptDup, (or stateAfter stateBefore))
                                )
                            )
                        )
                    )
                )
            )

            (SnippetTemplate''updateStamps-3 this, replacee, duplicates)
            (SnippetTemplate''rewireMemoryGraph-3 this, replacee, duplicates)

            ;; replace all usages of the replacee with the value returned by the snippet
            (when (and (some? (:returnNode this)) (not (satisfies? ControlSinkNode replacee)))
                (let [
                    #_"ReturnNode" returnDuplicate (get duplicates (:returnNode this))
                ]
                    (UsageReplacer'''replace-3 SnippetTemplate'DEFAULT_REPLACER, replacee, (:result returnDuplicate))
                    (when (Node''isAlive-1 returnDuplicate)
                        (let [
                            #_"FixedNode" _next
                                (when (satisfies? FixedWithNextNode replacee)
                                    (let [
                                        _next (:next replacee)
                                    ]
                                        (ยง ass! replacee (FixedWithNextNode''setNext-2 replacee, nil))
                                        _next
                                    )
                                )
                        ]
                            (ยง ass! returnDuplicate (Node''replaceAndDelete-2 returnDuplicate, _next))
                        )
                    )
                )
            )

            (GraphUtil'killCFG-1 replacee)
        )
        nil
    )

    ;;;
     ; Replaces a given floating node with this specialized snippet.
     ;
     ; @param replacee the node that will be replaced
     ; @param replacer object that replaces the usages of {@code replacee}
     ; @param lowerer lowering tool used to insert the snippet into the control-flow
     ; @param args the arguments to be bound to the flattened positional parameters of the snippet
     ;;
    (defn #_"void" SnippetTemplate''instantiate-5 [#_"SnippetTemplate" this, #_"FloatingNode" replacee, #_"UsageReplacer" replacer, #_"LoweringTool" lowerer, #_"Arguments" args]
        ;; inline the snippet nodes replacing parameters with the given args in the process
        (let [
            #_"StartNode" start (:start (:snippet this))
            #_"FixedNode" firstCFGNode (:next start)
            #_"EconomicMap<Node, Node>" replacements (SnippetTemplate''bind-3 this, (:graph replacee), args)
            _ (#_"EconomicMap" .put replacements, start, (:guardAnchor lowerer))
            #_"{Node Node}" duplicates (SnippetTemplate''inlineSnippet-4 this, replacee, (:graph replacee), replacements)
            #_"FixedWithNextNode" lastFixedNode (:lastFixedNode lowerer)
            #_"FixedNode" _next (:next lastFixedNode)
            _ (ยง ass! lastFixedNode (FixedWithNextNode''setNext-2 lastFixedNode, nil))
        ]
            (Graph''addAfterFixed-3 (:graph replacee), lastFixedNode, (get duplicates firstCFGNode))

            (SnippetTemplate''rewireFrameStates-3 this, replacee, duplicates)
            (SnippetTemplate''updateStamps-3 this, replacee, duplicates)
            (SnippetTemplate''rewireMemoryGraph-3 this, replacee, duplicates)

            ;; replace all usages of the replacee with the value returned by the snippet
            (let [
                #_"ReturnNode" returnDuplicate (get duplicates (:returnNode this))
            ]
                (UsageReplacer'''replace-3 replacer, replacee, (:result returnDuplicate))

                (when (Node''isAlive-1 returnDuplicate)
                    (ยง ass! returnDuplicate (Node''replaceAndDelete-2 returnDuplicate, _next))
                )
            )
        )
        nil
    )
)

(class-ns StackInterval []
    (def- #_"int" StackInterval'INVALID_START Integer/MAX_VALUE)
    (def- #_"int" StackInterval'INVALID_END Integer/MIN_VALUE)

    (defn #_"StackInterval" StackInterval'new-2 [#_"VirtualStackSlot" operand, #_"ValueKind" kind]
        (merge (StackInterval'class.)
            (hash-map
                #_"VirtualStackSlot" :operand operand
                #_"StackInterval" :hint nil
                #_"ValueKind" :kind kind
                #_"int" :from StackInterval'INVALID_START
                #_"int" :to StackInterval'INVALID_END
                #_"StackSlot" :location nil
            )
        )
    )

    (defn #_"this" StackInterval''addTo-2 [#_"StackInterval" this, #_"int" opId]
        (when (<= (:to this) opId) => this
            (assoc this :to opId)
        )
    )

    (defn #_"StackInterval" StackInterval''addFrom-2 [#_"StackInterval" this, #_"int" opId]
        (when (< opId (:from this)) => this
            (let [
                this (assoc this :from opId)
            ]
                ;; set opId also as to if it has not yet been set
                (when (= (:to this) StackInterval'INVALID_END) => this
                    (assoc this :to opId)
                )
            )
        )
    )

    (defn #_"StackInterval" StackInterval''setLocation-2 [#_"StackInterval" this, #_"StackSlot" location]
        (assoc this :location location)
    )

    (defn #_"StackInterval" StackInterval''setLocationHint-2 [#_"StackInterval" this, #_"StackInterval" locationHint]
        (assoc this :hint locationHint)
    )
)

;;;
 ; Replaces sequential AMD64StackMoves of the same type with a single AMD64MultiStackMove
 ; to avoid storing/restoring the scratch register multiple times.
 ;
 ; Note: this phase must be inserted <b>after</b> RedundantMoveElimination phase because
 ; AMD64MultiStackMove are not probably detected.
 ;;
(class-ns StackMoveOptimizationPhase [LIRPhase #_"<LIRPhaseContext>"] ;; PostAllocationPhase
    (defn #_"StackMoveOptimizationPhase" StackMoveOptimizationPhase'new-0 []
        (StackMoveOptimizationPhase'class.)
    )

    (defn- #_"List<LIRInstruction>" StackMoveOptimizationPhase'replaceStackMoves-2 [#_"List<LIRInstruction>" ops, #_"?" c]
        (let [
            #_"int" i (:begin c)
            #_"int" n (count (:dst c))
        ]
            (when (< 1 n) => ops
                (#_"List" .set ops, i, (AMD64MultiStackMove'new-4 (:dst c), (:src c), (:reg c), (:slot c)))
                (Collections/fill (#_"List" .subList ops, (inc i), (+ i n)), nil)
                ops
            )
        )
    )

    (defn- #_"List<LIRInstruction>" StackMoveOptimizationPhase'process-1 [#_"List<LIRInstruction>" ops]
        (let [
            #_"?" c0
                (hash-map
                    #_"int" :begin -1
                    #_"[AllocatableValue]" :dst []
                    #_"[Value]" :src []
                    #_"Register" :reg nil
                    #_"AllocatableValue" :slot nil
                )
            ops
                (loop-when [ops ops #_"?" c c0 #_"int" i 0] (< i (count ops)) => ops
                    (let [
                        #_"LIRInstruction" op (nth ops i)
                        [ops c]
                            (if (satisfies? AMD64StackMove op)
                                (let [
                                    [ops c]
                                        (when (and (some? (:reg c)) (not (= (:reg c) (:scratch op)))) => [ops c]
                                            [(StackMoveOptimizationPhase'replaceStackMoves-2 ops, c) c0]
                                        )
                                    c (update c :dst conj (MoveOp'''getResult-1 op))
                                    c (update c :src conj (ValueMoveOp'''getInput-1 op))
                                    c
                                        (when (= (:begin c) -1) => c
                                            (assoc c :begin i :reg (:scratch op) :slot (:backupSlot op))
                                        )
                                ]
                                    [ops c]
                                )
                                (when-not (= (:begin c) -1) => [ops c]
                                    [(StackMoveOptimizationPhase'replaceStackMoves-2 ops, c) c0]
                                )
                            )
                    ]
                        (recur ops c (inc i))
                    )
                )
        ]
            (#_"List" .removeAll ops, (Collections/singleton nil))
            ops
        )
    )

    (defm StackMoveOptimizationPhase LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"StackMoveOptimizationPhase" this, #_"LIRGenerationResult" res, #_"LIRPhaseContext" context]
            (doseq [#_"Block" block (:reversePostOrder (:cfg (:lir res)))]
                (let [
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir res), block)
                ]
                    (ยง ass! ops (StackMoveOptimizationPhase'process-1 ops))
                )
            )
            nil
        )
    )
)

;;;
 ; Linear Scan stack slot allocator.
 ;
 ; Remark: The analysis works under the assumption that a stack slot is no longer live after its last usage.
 ; If an {@link LIRInstruction instruction} transfers the raw address of the stack slot to another location,
 ; e.g. a registers, and this location is referenced later on, the {@link Use usage} of the stack slot must be
 ; marked with the OperandFlag#UNINITIALIZED. Otherwise the stack slot might be reused and its content destroyed.
 ;;
(class-ns StackSlotAllocator [LIRPhase #_"<LIRPhaseContext>"] ;; AllocationPhase
    (defn #_"StackSlotAllocator" StackSlotAllocator'new-0 []
        (StackSlotAllocator'class.)
    )

    (defm StackSlotAllocator LIRPhase
        (#_"void" LIRPhase'''run-3 [#_"StackSlotAllocator" this, #_"LIRGenerationResult" res, #_"LIRPhaseContext" context]
            (when (pos? (:numStackSlots (:frameMapBuilder res)))
                (Allocator''allocate-1 (Allocator'new-2 (:lir res), (:frameMapBuilder res)))
            )
            (ยง ass! res (LIRGenerationResult''buildFrameMap-1 res))
            nil
        )
    )
)

(class-ns StampElement []
    (defn #_"StampElement" StampElement'new-2 [#_"Stamp" stamp, #_"StampElement" parent]
        (merge (StampElement'class.)
            (hash-map
                #_"Stamp" :stamp stamp
                #_"StampElement" :parent parent
            )
        )
    )
)

(class-ns Stamp []
    (defn #_"Stamp" Stamp'new-0 []
        (Stamp'class.)
    )

    (defm Stamp Stamp
        (#_"boolean" Stamp'''alwaysDistinct-2 [#_"Stamp" this, #_"Stamp" other]
            (Stamp''isEmpty-1 (Stamp'''join-2 this, other))
        )
    )

    ;;;
     ; Tests whether this stamp represents an illegal value.
     ;;
    (defn #_"boolean" Stamp''isEmpty-1 [#_"Stamp" this]
        (not (Stamp'''hasValues-1 this))
    )

    (defm Stamp Stamp
        (#_"boolean" Stamp'''isUnrestricted-1 [#_"Stamp" this]
            (= this (Stamp'''unrestricted-1 this))
        )

        (#_"Constant" Stamp'''asConstant-1 [#_"Stamp" this]
            nil
        )
    )

    ;;;
     ; Tries to improve this stamp with the stamp given as parameter. If successful, returns the new
     ; improved stamp. Otherwise, returns nil.
     ;
     ; @param other the stamp that should be used to improve this stamp
     ; @return the newly improved stamp or nil if an improvement was not possible
     ;;
    (defn #_"Stamp" Stamp''tryImproveWith-2 [#_"Stamp" this, #_"Stamp" other]
        (let [
            #_"Stamp" improved (Stamp'''improveWith-2 this, other)
        ]
            (when-not (= improved this)
                improved
            )
        )
    )

    (defn #_"boolean" Stamp''neverDistinct-2 [#_"Stamp" this, #_"Stamp" other]
        (let [
            #_"Constant" constant (Stamp'''asConstant-1 this)
        ]
            (and (some? constant)
                (let [
                    #_"Constant" otherConstant (Stamp'''asConstant-1 other)
                ]
                    (and (some? otherConstant) (= constant otherConstant))
                )
            )
        )
    )
)

(class-ns AbstractPointerStamp [Stamp]
    (defn #_"AbstractPointerStamp" AbstractPointerStamp'new-2 [#_"boolean" never-nil?, #_"boolean" always-nil?]
        (merge (AbstractPointerStamp'class.) (Stamp'new-0)
            (hash-map
                #_"boolean" :never-nil? never-nil?
                #_"boolean" :always-nil? always-nil?
            )
        )
    )

    (defn #_"Stamp" AbstractPointerStamp''defaultPointerJoin-2 [#_"AbstractPointerStamp" this, #_"Stamp" other]
        (let [
            #_"boolean" joinNonNull (or (:never-nil? this) (:never-nil? other))
            #_"boolean" joinAlwaysNull (or (:always-nil? this) (:always-nil? other))
        ]
            (if (and joinNonNull joinAlwaysNull)
                (Stamp'''empty-1 this)
                (AbstractPointerStamp'''copyWith-3 this, joinNonNull, joinAlwaysNull)
            )
        )
    )

    (defm AbstractPointerStamp Stamp
        (#_"Stamp" Stamp'''improveWith-2 [#_"AbstractPointerStamp" this, #_"Stamp" other]
            (Stamp'''join-2 this, other)
        )

        (#_"Stamp" Stamp'''meet-2 [#_"AbstractPointerStamp" this, #_"Stamp" other]
            (let [
                #_"boolean" meetNonNull (and (:never-nil? this) (:never-nil? other))
                #_"boolean" meetAlwaysNull (and (:always-nil? this) (:always-nil? other))
            ]
                (AbstractPointerStamp'''copyWith-3 this, meetNonNull, meetAlwaysNull)
            )
        )

        (#_"Stamp" Stamp'''unrestricted-1 [#_"AbstractPointerStamp" this]
            (AbstractPointerStamp'''copyWith-3 this, false, false)
        )
    )

    (defn #_"Stamp" AbstractPointerStamp''asNonNull-1 [#_"AbstractPointerStamp" this]
        (when-not (Stamp''isEmpty-1 this) => this
            (AbstractPointerStamp'''copyWith-3 this, true, false)
        )
    )

    (defn #_"Stamp" AbstractPointerStamp''asMaybeNull-1 [#_"AbstractPointerStamp" this]
        (when-not (Stamp''isEmpty-1 this) => this
            (AbstractPointerStamp'''copyWith-3 this, false, false)
        )
    )

    (defn #_"Stamp" AbstractPointerStamp''asAlwaysNull-1 [#_"AbstractPointerStamp" this]
        (when-not (Stamp''isEmpty-1 this) => this
            (AbstractPointerStamp'''copyWith-3 this, false, true)
        )
    )

    (defm AbstractPointerStamp Stamp
        (#_"Constant" Stamp'''asConstant-1 [#_"AbstractPointerStamp" this]
            (when (:always-nil? this) JavaConstant/NULL_POINTER)
        )

        (#_"JavaKind" Stamp'''getStackKind-1 [#_"AbstractPointerStamp" this]
            JavaKind/Illegal
        )
    )
)

(class-ns AbstractObjectStamp [AbstractPointerStamp, Stamp]
    (defn #_"AbstractObjectStamp" AbstractObjectStamp'new-4 [#_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?]
        (merge (AbstractObjectStamp'class.) (AbstractPointerStamp'new-2 never-nil?, always-nil?)
            (hash-map
                #_"ResolvedJavaType" :type type
                #_"boolean" :exact-type? exact-type?
            )
        )
    )

    (defm AbstractObjectStamp AbstractPointerStamp
        (#_"AbstractPointerStamp" AbstractPointerStamp'''copyWith-3 [#_"AbstractObjectStamp" this, #_"boolean" never-nil?, #_"boolean" always-nil?]
            (AbstractObjectStamp'''copyWith-5 this, (:type this), (:exact-type? this), never-nil?, always-nil?)
        )
    )

    (defm AbstractObjectStamp Stamp
        (#_"Stamp" Stamp'''unrestricted-1 [#_"AbstractObjectStamp" this]
            (AbstractObjectStamp'''copyWith-5 this, nil, false, false, false)
        )

        (#_"Stamp" Stamp'''empty-1 [#_"AbstractObjectStamp" this]
            (AbstractObjectStamp'''copyWith-5 this, nil, true, true, false)
        )

        (#_"Stamp" Stamp'''constant-2 [#_"AbstractObjectStamp" this, #_"Constant" c]
            (let [
                #_"ResolvedJavaType" constType (when-not (#_"JavaConstant" .isNull c) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, c))
            ]
                (AbstractObjectStamp'''copyWith-5 this, constType, (#_"JavaConstant" .isNonNull c), (#_"JavaConstant" .isNonNull c), (#_"JavaConstant" .isNull c))
            )
        )

        (#_"boolean" Stamp'''hasValues-1 [#_"AbstractObjectStamp" this]
            (or (not (:exact-type? this)) (and (some? (:type this)) (AbstractObjectStamp'isConcreteType-1 (:type this))))
        )

        (#_"JavaKind" Stamp'''getStackKind-1 [#_"AbstractObjectStamp" this]
            JavaKind/Object
        )

        (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"AbstractObjectStamp" this]
            (or (:type this) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Object))
        )
    )

    (defn #_"boolean" AbstractObjectStamp''isExactType-1 [#_"AbstractObjectStamp" this]
        (and (:exact-type? this) (some? (:type this)))
    )

    (defn- #_"boolean" AbstractObjectStamp'isInterfaceOrArrayOfInterface-1 [#_"ResolvedJavaType" t]
        (or (#_"ResolvedJavaType" .isInterface t) (and (#_"ResolvedJavaType" .isArray t) (#_"ResolvedJavaType" .isInterface (#_"ResolvedJavaType" .getElementalType t))))
    )

    (defn- #_"Stamp" AbstractObjectStamp''join0-3 [#_"AbstractObjectStamp" this, #_"Stamp" that, #_"boolean" improve?]
        (if (= this that)
            this
            (let [
                #_"AbstractObjectStamp" a this
                #_"AbstractObjectStamp" b that
            ]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"boolean" always-nil? (or (:always-nil? a) (:always-nil? b))
                            #_"boolean" never-nil? (or (:never-nil? a) (:never-nil? b))
                            #_"boolean" exact-type? (or (:exact-type? a) (:exact-type? b))
                            [#_"ResolvedJavaType" type exact-type? always-nil?]
                                (cond
                                    (= (:type a) (:type b))                                       [(:type a) exact-type? always-nil?]
                                    (nil? (:type a))                                              [(:type b) exact-type? always-nil?]
                                    (nil? (:type b))                                              [(:type a) exact-type? always-nil?]
                                    (#_"ResolvedJavaType" .isAssignableFrom (:type a), (:type b)) [(:type b) exact-type? (or (:exact-type? a) always-nil?)]
                                    (#_"ResolvedJavaType" .isAssignableFrom (:type b), (:type a)) [(:type a) exact-type? (or (:exact-type? b) always-nil?)]
                                    :else
                                        (let [
                                            [type exact-type?] (if improve? [(:type a) (:exact-type? a)] [nil exact-type?])
                                            always-nil?
                                                (or exact-type?
                                                    (and (not (AbstractObjectStamp'isInterfaceOrArrayOfInterface-1 (:type a)))
                                                         (not (AbstractObjectStamp'isInterfaceOrArrayOfInterface-1 (:type b)))
                                                    )
                                                    always-nil?
                                                )
                                        ]
                                            [type exact-type? always-nil?]
                                        )
                                )
                            [type exact-type?] (if always-nil? [nil false] [type exact-type?])
                        ]
                            (cond
                                (and exact-type? (nil? type))                                       (Stamp'''empty-1 a)
                                (and always-nil? never-nil?)                                        (Stamp'''empty-1 a)
                                (and exact-type? (not (AbstractObjectStamp'isConcreteType-1 type))) (Stamp'''empty-1 a)
                                (and (= type (:type a)) (= exact-type? (:exact-type? a)) (= never-nil? (:never-nil? a)) (= always-nil? (:always-nil? a)))
                                    a
                                (and (= type (:type b)) (= exact-type? (:exact-type? b)) (= never-nil? (:never-nil? b)) (= always-nil? (:always-nil? b)))
                                    b
                                :else
                                    (AbstractObjectStamp'''copyWith-5 a, type, exact-type?, never-nil?, always-nil?)
                            )
                        )
                )
            )
        )
    )

    (declare AbstractObjectStamp'meetTypes-2)

    (defn- #_"ResolvedJavaType" AbstractObjectStamp'meetOrderedNonNullTypes-2 [#_"ResolvedJavaType" a, #_"ResolvedJavaType" b]
        (let [
            #_"ResolvedJavaType" type (#_"ResolvedJavaType" .findLeastCommonAncestor a, b)
        ]
            (when (and (#_"ResolvedJavaType" .isJavaLangObject type) (#_"ResolvedJavaType" .isInterface a) (#_"ResolvedJavaType" .isInterface b)) => type
                ;; Both types are incompatible interfaces => search for first possible common
                ;; ancestor match among super interfaces.
                (let [
                    #_"ResolvedJavaType[]" a* (#_"ResolvedJavaType" .getInterfaces a)
                    #_"ResolvedJavaType[]" b* (#_"ResolvedJavaType" .getInterfaces b)
                ]
                    (loop-when [#_"int" i 0] (< i (count a*)) => type
                        (loop-when [#_"int" j 0] (< j (count b*))
                            (let [
                                #_"ResolvedJavaType" leastCommon (AbstractObjectStamp'meetTypes-2 (nth a* i), (nth b* j))
                            ]
                                (when (#_"ResolvedJavaType" .isInterface leastCommon) => (recur (inc j))
                                    (ยง return leastCommon)
                                )
                            )
                        )
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (defn- #_"ResolvedJavaType" AbstractObjectStamp'meetTypes-2 [#_"ResolvedJavaType" a, #_"ResolvedJavaType" b]
        (cond
            (= a b) a
            (or (nil? a) (nil? b))  nil
            :else
                ;; The 'meetTypes' operation must be commutative. One way to achieve this is
                ;; to totally order the types and always call 'meetOrderedNonNullTypes' in the
                ;; same order. We establish the order by first comparing the hash-codes for
                ;; performance reasons, and then comparing the internal names of the types.
                (let [
                    #_"int" hashA (#_"Object" .hashCode (#_"ResolvedJavaType" .getName a))
                    #_"int" hashB (#_"Object" .hashCode (#_"ResolvedJavaType" .getName b))
                ]
                    (cond
                        (< hashA hashB) (AbstractObjectStamp'meetOrderedNonNullTypes-2 a, b)
                        (< hashB hashA) (AbstractObjectStamp'meetOrderedNonNullTypes-2 b, a)
                        :else
                            (if (<= (#_"String" .compareTo (#_"ResolvedJavaType" .getName a), (#_"ResolvedJavaType" .getName b)) 0)
                                (AbstractObjectStamp'meetOrderedNonNullTypes-2 a, b)
                                (AbstractObjectStamp'meetOrderedNonNullTypes-2 b, a)
                            )
                    )
                )
        )
    )

    (defm AbstractObjectStamp Stamp
        (#_"Stamp" Stamp'''meet-2 [#_"AbstractObjectStamp" this, #_"Stamp" that]
            (if (= this that)
                this
                (let [
                    #_"AbstractObjectStamp" a this
                    #_"AbstractObjectStamp" b that
                ]
                    (cond
                        (Stamp''isEmpty-1 a) b
                        (Stamp''isEmpty-1 b) a
                        :else
                            (let [
                                [#_"ResolvedJavaType" type #_"boolean" exact-type? #_"boolean" never-nil? #_"boolean" always-nil?]
                                    (cond
                                        (:always-nil? b)
                                            [(:type a) (:exact-type? a) false (:always-nil? a)]
                                        (:always-nil? a)
                                            [(:type b) (:exact-type? b) false (:always-nil? b)]
                                        :else
                                            (let [
                                                type (AbstractObjectStamp'meetTypes-2 (:type a), (:type b))
                                                exact-type? (and (:exact-type? a) (:exact-type? b))
                                                exact-type?
                                                    (when (and exact-type? (some? (:type a)) (some? (:type b))) => exact-type?
                                                        ;; meeting two valid exact types may result in a non-exact type
                                                        (= type (:type a) (:type b))
                                                    )
                                                never-nil? (and (:never-nil? a) (:never-nil? b))
                                                always-nil? false
                                            ]
                                                [type exact-type? never-nil? always-nil?]
                                            )
                                    )
                            ]
                                (cond
                                    (and (= type (:type a)) (= exact-type? (:exact-type? a)) (= never-nil? (:never-nil? a)) (= always-nil? (:always-nil? a)))
                                        a
                                    (and (= type (:type b)) (= exact-type? (:exact-type? b)) (= never-nil? (:never-nil? b)) (= always-nil? (:always-nil? b)))
                                        b
                                    :else
                                        (AbstractObjectStamp'''copyWith-5 a, type, exact-type?, never-nil?, always-nil?)
                                )
                            )
                    )
                )
            )
        )

        (#_"Stamp" Stamp'''join-2 [#_"AbstractObjectStamp" this, #_"Stamp" that]
            (AbstractObjectStamp''join0-3 this, that, false)
        )

        ;;;
         ; Returns the stamp representing the type of this stamp after a cast to the type represented by
         ; the {@code to} stamp. While this is very similar to a #join operation, in the case where both
         ; types are not obviously related, the cast operation will prefer the type of the {@code to} stamp.
         ; This is necessary as long as ObjectStamps are not able to accurately represent intersection types.
         ;
         ; For example when joining the RandomAccess type with the AbstractList type, without intersection
         ; types, this would result in the most generic type (Object). For this reason, in some cases
         ; a {@code castTo} operation is preferable in order to keep at least the AbstractList type.
         ;
         ; @param that the stamp this stamp should be casted to
         ; @return the new improved stamp or nil if this stamp cannot be improved
         ;;
        (#_"Stamp" Stamp'''improveWith-2 [#_"AbstractObjectStamp" this, #_"Stamp" that]
            (AbstractObjectStamp''join0-3 this, that, true)
        )
    )

    (defn #_"boolean" AbstractObjectStamp'isConcreteType-1 [#_"ResolvedJavaType" type]
        (not (and (#_"ResolvedJavaType" .isAbstract type) (not (#_"ResolvedJavaType" .isArray type))))
    )

    (ยง override #_"boolean" #_"Object." equals [#_"AbstractObjectStamp" this, #_"Object" that]
        (or (= this that)
            (and (some? that) (= (#_"Object" .getClass this) (#_"Object" .getClass that))
                (let [
                    #_"AbstractObjectStamp" a this
                    #_"AbstractObjectStamp" b that
                ]
                    (and (= (:exact-type? a) (:exact-type? b))
                        ;; nil == java.lang.Object
                        (cond
                            (nil? (:type a)) (or (nil? (:type b)) (#_"ResolvedJavaType" .isJavaLangObject (:type b)))
                            (nil? (:type b)) (or (nil? (:type a)) (#_"ResolvedJavaType" .isJavaLangObject (:type a)))
                            :else                                 (= (:type a) (:type b))
                        )
                        (= (ยง super #_"AbstractPointerStamp") b)
                    )
                )
            )
        )
    )
)

(class-ns NarrowOopStamp [AbstractObjectStamp, AbstractPointerStamp, Stamp]
    (defn #_"NarrowOopStamp" NarrowOopStamp'new-5 [#_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?, #_"CompressEncoding" encoding]
        (merge (NarrowOopStamp'class.) (AbstractObjectStamp'new-4 type, exact-type?, never-nil?, always-nil?)
            (hash-map
                #_"CompressEncoding" :encoding encoding
            )
        )
    )

    (defm NarrowOopStamp NarrowOopStamp
        (#_"Stamp" NarrowOopStamp'''uncompressed-1 [#_"NarrowOopStamp" this]
            (ObjectStamp'new-4 (:type this), (AbstractObjectStamp''isExactType-1 this), (:never-nil? this), (:always-nil? this))
        )
    )

    (defn #_"CompressEncoding" NarrowOopStamp''getEncoding-1 [#_"NarrowOopStamp" this]
        (:encoding this)
    )

    (defm NarrowOopStamp Stamp
        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"NarrowOopStamp" this]
            (LIRKindTool'getNarrowOopKind-0)
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"NarrowOopStamp" this, #_"Stamp" other]
            (or (= this other)
                (and (satisfies? NarrowOopStamp other)
                    (= (:encoding this) (:encoding other))
                )
            )
        )
    )
)

(class-ns HotSpotNarrowOopStamp [NarrowOopStamp, AbstractObjectStamp, AbstractPointerStamp, Stamp]
    (defn- #_"HotSpotNarrowOopStamp" HotSpotNarrowOopStamp'new-5 [#_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?, #_"CompressEncoding" encoding]
        (merge (HotSpotNarrowOopStamp'class.) (NarrowOopStamp'new-5 type, exact-type?, never-nil?, always-nil?, encoding))
    )

    (defm HotSpotNarrowOopStamp AbstractObjectStamp
        (#_"AbstractObjectStamp" AbstractObjectStamp'''copyWith-5 [#_"HotSpotNarrowOopStamp" this, #_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?]
            (HotSpotNarrowOopStamp'new-5 type, exact-type?, never-nil?, always-nil?, (NarrowOopStamp''getEncoding-1 this))
        )
    )

    (defn #_"Stamp" HotSpotNarrowOopStamp'compressed-2 [#_"AbstractObjectStamp" stamp, #_"CompressEncoding" encoding]
        (HotSpotNarrowOopStamp'new-5 (:type stamp), (AbstractObjectStamp''isExactType-1 stamp), (:never-nil? stamp), (:always-nil? stamp), encoding)
    )

    (defm HotSpotNarrowOopStamp Stamp
        (#_"Constant" Stamp'''readConstant-4 [#_"HotSpotNarrowOopStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (try
                (#_"HotSpotMemoryAccessProvider" .readNarrowOopConstant provider, base, displacement)
                (catch IllegalArgumentException _
                    nil
                )
            )
        )

        (#_"JavaConstant" Stamp'''asConstant-1 [#_"HotSpotNarrowOopStamp" this]
            (when (:always-nil? this) HotSpotCompressedNullConstant/COMPRESSED_NULL)
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"HotSpotNarrowOopStamp" this, #_"Constant" other]
            (if (instance? HotSpotObjectConstant other)
                (#_"HotSpotObjectConstant" .isCompressed other)
                true
            )
        )
    )

    (defn #_"Stamp" HotSpotNarrowOopStamp'mkStamp-3 [#_"CompressionOp" op, #_"Stamp" input, #_"CompressEncoding" encoding]
        (condp = op
            CompressionOp'Compress
                (condp satisfies? input
                    ObjectStamp       (HotSpotNarrowOopStamp'compressed-2 input, encoding) ;; compressed oop
                    KlassPointerStamp (KlassPointerStamp''compressed-2 input, encoding)    ;; compressed klass pointer
                )
            CompressionOp'Uncompress
                (condp satisfies? input
                    NarrowOopStamp    (NarrowOopStamp'''uncompressed-1 input)    ;; oop
                    KlassPointerStamp (KlassPointerStamp''uncompressed-1 input) ;; metaspace pointer
                )
        )
    )
)

(class-ns ObjectStamp [AbstractObjectStamp, AbstractPointerStamp, Stamp]
    (defn #_"ObjectStamp" ObjectStamp'new-4 [#_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?]
        (merge (ObjectStamp'class.) (AbstractObjectStamp'new-4 type, exact-type?, never-nil?, always-nil?))
    )

    (defm ObjectStamp AbstractObjectStamp
        (#_"ObjectStamp" AbstractObjectStamp'''copyWith-5 [#_"ObjectStamp" this, #_"ResolvedJavaType" type, #_"boolean" exact-type?, #_"boolean" never-nil?, #_"boolean" always-nil?]
            (ObjectStamp'new-4 type, exact-type?, never-nil?, always-nil?)
        )
    )

    (defm ObjectStamp Stamp
        (#_"Stamp" Stamp'''unrestricted-1 [#_"ObjectStamp" this]
            StampFactory'objectStamp
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"ObjectStamp" this, #_"Stamp" other]
            (or (= this other) (satisfies? ObjectStamp other))
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"ObjectStamp" this, #_"Constant" constant]
            (and (instance? JavaConstant constant)
                (#_"JavaKind" .isObject (#_"JavaConstant" .getJavaKind constant))
            )
        )

        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"ObjectStamp" this]
            (LIRKindTool'getObjectKind-0)
        )

        (#_"Constant" Stamp'''readConstant-4 [#_"ObjectStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (try
                (#_"MemoryAccessProvider" .readObjectConstant provider, base, displacement)
                (catch IllegalArgumentException _
                    nil ;; it's possible that the base and displacement aren't valid together, so simply return nil
                )
            )
        )
    )
)

;;;
 ; A stamp for Placeholder nodes which are only used in snippets. It is replaced by an
 ; actual stamp when the snippet is instantiated.
 ;;
(class-ns PlaceholderStamp [ObjectStamp, AbstractObjectStamp, AbstractPointerStamp, Stamp]
    (defn- #_"PlaceholderStamp" PlaceholderStamp'new-0 []
        (merge (PlaceholderStamp'class.) (ObjectStamp'new-4 nil, false, false, false))
    )

    (def #_"PlaceholderStamp" PlaceholderStamp'SINGLETON (ยง soon PlaceholderStamp'new-0))

    (ยง override! #_"boolean" #_"Object." equals [#_"PlaceholderStamp" this, #_"Object" obj]
        (= this obj)
    )
)

(class-ns KlassPointerStamp [AbstractPointerStamp, Stamp]
    (defn- #_"KlassPointerStamp" KlassPointerStamp'new-3 [#_"boolean" never-nil?, #_"boolean" always-nil?, #_"CompressEncoding" encoding]
        (merge (KlassPointerStamp'class.) (AbstractPointerStamp'new-2 never-nil?, always-nil?)
            (hash-map
                #_"CompressEncoding" :encoding encoding
            )
        )
    )

    (defn- #_"KlassPointerStamp" KlassPointerStamp'new-2 [#_"boolean" never-nil?, #_"boolean" always-nil?]
        (KlassPointerStamp'new-3 never-nil?, always-nil?, nil)
    )

    (ยง def #_"KlassPointerStamp" KlassPointerStamp'KLASS             (KlassPointerStamp'new-2 false, false))
    (ยง def #_"KlassPointerStamp" KlassPointerStamp'KLASS_NON_NULL    (KlassPointerStamp'new-2 true, false))
    (ยง def #_"KlassPointerStamp" KlassPointerStamp'KLASS_ALWAYS_NULL (KlassPointerStamp'new-2 false, true))

    (defm KlassPointerStamp AbstractPointerStamp
        (#_"AbstractPointerStamp" AbstractPointerStamp'''copyWith-3 [#_"KlassPointerStamp" this, #_"boolean" never-nil?, #_"boolean" always-nil?]
            (KlassPointerStamp'new-3 never-nil?, always-nil?, (:encoding this))
        )
    )

    (defm KlassPointerStamp Stamp
        (#_"Stamp" Stamp'''empty-1 [#_"KlassPointerStamp" this]
            ;; there is no empty pointer stamp
            this
        )

        (#_"boolean" Stamp'''hasValues-1 [#_"KlassPointerStamp" this]
            true
        )

        (#_"Stamp" Stamp'''join-2 [#_"KlassPointerStamp" this, #_"Stamp" other]
            (AbstractPointerStamp''defaultPointerJoin-2 this, other)
        )

        (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"KlassPointerStamp" this]
            (throw! "metaspace pointer has no Java type")
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"KlassPointerStamp" this, #_"Stamp" that]
            (or (= this that)
                (and (satisfies? KlassPointerStamp that)
                    (= (:encoding this) (:encoding that))
                )
            )
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"KlassPointerStamp" this, #_"Constant" constant]
            (if (instance? HotSpotMetaspaceConstant constant)
                (some? (#_"HotSpotMetaspaceConstant" .asResolvedJavaType constant))
                (#_"Constant" .isDefaultForKind constant)
            )
        )

        (#_"Stamp" Stamp'''constant-2 [#_"KlassPointerStamp" this, #_"Constant" constant]
            (if (KlassPointerStamp''isCompressed-1 this)
                (when (= HotSpotCompressedNullConstant/COMPRESSED_NULL constant)
                    (ยง return (KlassPointerStamp'new-3 false, true, (:encoding this)))
                )
                (when (= JavaConstant/NULL_POINTER constant)
                    (ยง return KlassPointerStamp'KLASS_ALWAYS_NULL)
                )
            )

            (cond
                (:never-nil? this)                       this
                (KlassPointerStamp''isCompressed-1 this) (KlassPointerStamp'new-3 true, false, (:encoding this))
                :else                                    KlassPointerStamp'KLASS_NON_NULL
            )
        )

        (#_"Constant" Stamp'''asConstant-1 [#_"KlassPointerStamp" this]
            (if (and (:always-nil? this) (KlassPointerStamp''isCompressed-1 this))
                HotSpotCompressedNullConstant/COMPRESSED_NULL
                (Stamp'''asConstant-1 (ยง super AbstractPointerStamp'iface))
            )
        )

        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"KlassPointerStamp" this]
            (if (KlassPointerStamp''isCompressed-1 this)
                (LIRKindTool'getNarrowPointerKind-0)
                (LIRKindTool'getWordKind-0)
            )
        )
    )

    (defn #_"boolean" KlassPointerStamp''isCompressed-1 [#_"KlassPointerStamp" this]
        (some? (:encoding this))
    )

    (defn #_"KlassPointerStamp" KlassPointerStamp''compressed-2 [#_"KlassPointerStamp" this, #_"CompressEncoding" newEncoding]
        (KlassPointerStamp'new-3 (:never-nil? this), (:always-nil? this), newEncoding)
    )

    (defn #_"KlassPointerStamp" KlassPointerStamp''uncompressed-1 [#_"KlassPointerStamp" this]
        (KlassPointerStamp'new-2 (:never-nil? this), (:always-nil? this))
    )

    (defm KlassPointerStamp Stamp
        (#_"Constant" Stamp'''readConstant-4 [#_"KlassPointerStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (if (KlassPointerStamp''isCompressed-1 this)
                (#_"HotSpotMemoryAccessProvider" .readNarrowKlassPointerConstant provider, base, displacement)
                (#_"HotSpotMemoryAccessProvider" .readKlassPointerConstant provider, base, displacement)
            )
        )
    )
)

;;;
 ; Type describing pointers to raw memory. This stamp is used for example for direct pointers
 ; to fields or array elements.
 ;;
(class-ns RawPointerStamp [AbstractPointerStamp, Stamp]
    (defn #_"RawPointerStamp" RawPointerStamp'new-0 []
        (merge (RawPointerStamp'class.) (AbstractPointerStamp'new-2 false, false))
    )

    (defm RawPointerStamp Stamp
        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"RawPointerStamp" this]
            (LIRKindTool'getWordKind-0)
        )
    )

    (defm RawPointerStamp AbstractPointerStamp
        (#_"AbstractPointerStamp" AbstractPointerStamp'''copyWith-3 [#_"RawPointerStamp" this, #_"boolean" never-nil?, #_"boolean" always-nil?]
            ;; RawPointerStamp is a singleton
            this
        )
    )

    (defm RawPointerStamp Stamp
        (#_"Stamp" Stamp'''meet-2 [#_"RawPointerStamp" this, #_"Stamp" other]
            this
        )

        (#_"Stamp" Stamp'''improveWith-2 [#_"RawPointerStamp" this, #_"Stamp" other]
            this
        )

        (#_"Stamp" Stamp'''join-2 [#_"RawPointerStamp" this, #_"Stamp" other]
            this
        )

        (#_"Stamp" Stamp'''unrestricted-1 [#_"RawPointerStamp" this]
            this
        )

        (#_"Stamp" Stamp'''empty-1 [#_"RawPointerStamp" this]
            ;; there is no empty pointer stamp
            this
        )

        (#_"boolean" Stamp'''hasValues-1 [#_"RawPointerStamp" this]
            true
        )

        (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"RawPointerStamp" this]
            (throw! "pointer has no Java type")
        )

        (#_"Stamp" Stamp'''constant-2 [#_"RawPointerStamp" this, #_"Constant" constant]
            this
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"RawPointerStamp" this, #_"Stamp" other]
            (satisfies? RawPointerStamp other)
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"RawPointerStamp" this, #_"Constant" constant]
            (and (instance? PrimitiveConstant constant) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant)))
        )

        (#_"Constant" Stamp'''readConstant-4 [#_"RawPointerStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (throw! "can't read raw pointer")
        )
    )
)

;;;
 ; Type describing values that support arithmetic operations.
 ;;
(class-ns ArithmeticStamp [Stamp]
    (defn #_"ArithmeticStamp" ArithmeticStamp'new-1 [#_"ArithmeticOpTable" ops]
        (merge (ArithmeticStamp'class.) (Stamp'new-0)
            (hash-map
                #_"ArithmeticOpTable" :ops ops
            )
        )
    )

    (defm ArithmeticStamp Stamp
        (#_"Stamp" Stamp'''improveWith-2 [#_"ArithmeticStamp" this, #_"Stamp" other]
            (when (Stamp'''isCompatible-2s this, other) => this
                (Stamp'''join-2 this, other)
            )
        )
    )
)

;;;
 ; Type describing primitive values.
 ;;
(class-ns PrimitiveStamp [ArithmeticStamp, Stamp]
    (defn #_"PrimitiveStamp" PrimitiveStamp'new-2 [#_"int" bits, #_"ArithmeticOpTable" ops]
        (merge (PrimitiveStamp'class.) (ArithmeticStamp'new-1 ops)
            (hash-map
                ;;;
                 ; The width in bits of the value described by this stamp.
                 ;;
                #_"int" :bits bits
            )
        )
    )

    (defn #_"int" PrimitiveStamp'getBits-1 [#_"Stamp" stamp]
        (if (satisfies? PrimitiveStamp stamp) (:bits stamp) 0)
    )

    (defm PrimitiveStamp Stamp
        (#_"Constant" Stamp'''readConstant-4 [#_"PrimitiveStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (try
                (#_"MemoryAccessProvider" .readPrimitiveConstant provider, (Stamp'''getStackKind-1 this), base, displacement, (:bits this))
                (catch IllegalArgumentException _
                    nil ;; it's possible that the base and displacement aren't valid together, so simply return nil
                )
            )
        )
    )
)

;;;
 ; Describes the possible values of a node that produces an int or long result.
 ;
 ; The description consists of (inclusive) lower and upper bounds and up (may be set) and down
 ; (always set) bit-masks.
 ;;
(class-ns IntegerStamp [PrimitiveStamp, ArithmeticStamp, Stamp]
    (defn- #_"IntegerStamp" IntegerStamp'new-5 [#_"int" bits, #_"long" lowerBound, #_"long" upperBound, #_"long" downMask, #_"long" upMask]
        (merge (IntegerStamp'class.) (PrimitiveStamp'new-2 bits, IntegerStamp'OPS)
            (hash-map
                ;;;
                 ; The signed inclusive lower bound on the value described by this stamp.
                 ;;
                #_"long" :lowerBound lowerBound
                ;;;
                 ; The signed inclusive upper bound on the value described by this stamp.
                 ;;
                #_"long" :upperBound upperBound
                ;;;
                 ; This bit-mask describes the bits that are always set in the value described by this stamp.
                 ;;
                #_"long" :downMask downMask
                ;;;
                 ; This bit-mask describes the bits that can be set in the value described by this stamp.
                 ;;
                #_"long" :upMask upMask
            )
        )
    )

    (defn- #_"long" IntegerStamp'significantBit-2 [#_"long" bits, #_"long" value]
        (& (>>> value (dec bits)) 1)
    )

    (defn- #_"long" IntegerStamp'minValueForMasks-3 [#_"int" bits, #_"long" downMask, #_"long" upMask]
        (if (zero? (IntegerStamp'significantBit-2 bits, upMask))
            ;; Value is always positive. Minimum value always positive.
            downMask
            ;; Value can be positive or negative. Minimum value always negative.
            (| downMask (<< -1 (dec bits)))
        )
    )

    (defn- #_"long" IntegerStamp'maxValueForMasks-3 [#_"int" bits, #_"long" downMask, #_"long" upMask]
        (if (= (IntegerStamp'significantBit-2 bits, downMask) 1)
            ;; Value is always negative. Maximum value always negative.
            (CodeUtil/signExtend upMask, bits)
            ;; Value can be positive or negative. Maximum value always positive.
            (& upMask (>>> (CodeUtil/mask bits) 1))
        )
    )

    (defn #_"IntegerStamp" IntegerStamp'create-5 [#_"int" bits, #_"long" lowerBoundInput, #_"long" upperBoundInput, #_"long" downMask, #_"long" upMask]
        ;; Set lower bound, use masks to make it more precise.
        (let [
            #_"long" minValue (IntegerStamp'minValueForMasks-3 bits, downMask, upMask)
            #_"long" lowerBoundTmp (max lowerBoundInput minValue)
            ;; Set upper bound, use masks to make it more precise.
            #_"long" maxValue (IntegerStamp'maxValueForMasks-3 bits, downMask, upMask)
            #_"long" upperBoundTmp (min upperBoundInput maxValue)
            ;; Assign masks now with the bounds in mind.
            #_"long" defaultMask (CodeUtil/mask bits)
            [#_"long" boundedDownMask #_"long" boundedUpMask]
                (cond
                    (= lowerBoundTmp upperBoundTmp) [lowerBoundTmp lowerBoundTmp]
                    (<= 0 lowerBoundTmp)
                        (let [
                            #_"int" upperBoundLeadingZeros (Long/numberOfLeadingZeros upperBoundTmp)
                            #_"long" differentBits (bit-xor lowerBoundTmp upperBoundTmp)
                            #_"int" sameBitCount (Long/numberOfLeadingZeros (<< differentBits upperBoundLeadingZeros))
                        ]
                           [(& upperBoundTmp (bit-not (>>> -1 (+ upperBoundLeadingZeros sameBitCount))))
                            (| upperBoundTmp          (>>> -1 (+ upperBoundLeadingZeros sameBitCount)))]
                        )
                    (<= 0 upperBoundTmp) [0 defaultMask]
                    :else
                        (let [
                            #_"int" lowerBoundLeadingOnes (Long/numberOfLeadingZeros (bit-not lowerBoundTmp))
                            #_"long" differentBits (bit-xor lowerBoundTmp upperBoundTmp)
                            #_"int" sameBitCount (Long/numberOfLeadingZeros (<< differentBits lowerBoundLeadingOnes))
                        ]
                           [(| (& lowerBoundTmp (bit-not (>>> -1 (+ lowerBoundLeadingOnes sameBitCount)))) (bit-not (>>> -1 lowerBoundLeadingOnes)))
                            (|    lowerBoundTmp          (>>> -1 (+ lowerBoundLeadingOnes sameBitCount))   (bit-not (>>> -1 lowerBoundLeadingOnes)))]
                        )
                )
        ]
            (IntegerStamp'new-5 bits, lowerBoundTmp, upperBoundTmp, (& defaultMask (| downMask boundedDownMask)), (& defaultMask upMask boundedUpMask))
        )
    )

    #_unused
    (defn #_"IntegerStamp" IntegerStamp'create-3 [#_"int" bits, #_"long" lowerBoundInput, #_"long" upperBoundInput]
        (IntegerStamp'create-5 bits, lowerBoundInput, upperBoundInput, 0, (CodeUtil/mask bits))
    )

    (defn #_"IntegerStamp" IntegerStamp'stampForMask-3 [#_"int" bits, #_"long" downMask, #_"long" upMask]
        (IntegerStamp'new-5 bits, (IntegerStamp'minValueForMasks-3 bits, downMask, upMask), (IntegerStamp'maxValueForMasks-3 bits, downMask, upMask), downMask, upMask)
    )

    (defm IntegerStamp Stamp
        (#_"IntegerStamp" Stamp'''unrestricted-1 [#_"IntegerStamp" this]
            (IntegerStamp'new-5 (:bits this), (CodeUtil/minValue (:bits this)), (CodeUtil/maxValue (:bits this)), 0, (CodeUtil/mask (:bits this)))
        )

        (#_"IntegerStamp" Stamp'''empty-1 [#_"IntegerStamp" this]
            (IntegerStamp'new-5 (:bits this), (CodeUtil/maxValue (:bits this)), (CodeUtil/minValue (:bits this)), (CodeUtil/mask (:bits this)), 0)
        )

        (#_"Stamp" Stamp'''constant-2 [#_"IntegerStamp" this, #_"Constant" constant]
            (when (instance? PrimitiveConstant constant) => this
                (let [
                    #_"long" value (#_"PrimitiveConstant" .asLong constant)
                ]
                    (StampFactory'forInteger-3i (:bits this), value, value)
                )
            )
        )

        (#_"boolean" Stamp'''hasValues-1 [#_"IntegerStamp" this]
            (<= (:lowerBound this) (:upperBound this))
        )

        (#_"JavaKind" Stamp'''getStackKind-1 [#_"IntegerStamp" this]
            (if (< 32 (:bits this)) JavaKind/Long JavaKind/Int)
        )

        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"IntegerStamp" this]
            (LIRKindTool'getIntegerKind-1 (:bits this))
        )

        (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"IntegerStamp" this]
            (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess,
                (case (:bits this) 1 boolean'class 8 byte'class 16 short'class 32 int'class 64 long'class)
            )
        )

        (#_"boolean" Stamp'''isUnrestricted-1 [#_"IntegerStamp" this]
            (and (= (:lowerBound this) (CodeUtil/minValue (:bits this))) (= (:upperBound this) (CodeUtil/maxValue (:bits this))) (zero? (:downMask this)) (= (:upMask this) (CodeUtil/mask (:bits this))))
        )
    )

    (defn #_"boolean" IntegerStamp''contains-2 [#_"IntegerStamp" this, #_"long" value]
        (and (<= (:lowerBound this) value (:upperBound this)) (= (& value (:downMask this)) (:downMask this)) (= (& value (:upMask this)) (& value (CodeUtil/mask (:bits this)))))
    )

    (defn #_"boolean" IntegerStamp''isPositive-1 [#_"IntegerStamp" this]
        (<= 0 (:lowerBound this))
    )

    (defn #_"boolean" IntegerStamp''isNegative-1 [#_"IntegerStamp" this]
        (<= (:upperBound this) 0)
    )

    (defn #_"boolean" IntegerStamp''isStrictlyPositive-1 [#_"IntegerStamp" this]
        (< 0 (:lowerBound this))
    )

    (defn #_"boolean" IntegerStamp''isStrictlyNegative-1 [#_"IntegerStamp" this]
        (< (:upperBound this) 0)
    )

    (defn #_"boolean" IntegerStamp''canBePositive-1 [#_"IntegerStamp" this]
        (< 0 (:upperBound this))
    )

    (defn #_"boolean" IntegerStamp''canBeNegative-1 [#_"IntegerStamp" this]
        (< (:lowerBound this) 0)
    )

    (defn- #_"IntegerStamp" IntegerStamp''createStamp-6 [#_"IntegerStamp" this, #_"IntegerStamp" other, #_"long" lb, #_"long" ub, #_"long" dm, #_"long" um]
        (cond
            (or (< ub lb) (not (zero? (& dm (bit-not um)))) (and (zero? um) (or (pos? lb) (neg? ub))))
                (Stamp'''empty-1 this)
            (and (= lb (:lowerBound this)) (= ub (:upperBound this)) (= dm (:downMask this)) (= um (:upMask this)))
                this
            (and (= lb (:lowerBound other)) (= ub (:upperBound other)) (= dm (:downMask other)) (= um (:upMask other)))
                other
            :else
                (IntegerStamp'create-5 (:bits this), lb, ub, dm, um)
        )
    )

    (defm IntegerStamp Stamp
        (#_"Stamp" Stamp'''meet-2 [#_"IntegerStamp" this, #_"Stamp" stamp]
            (cond
                (= stamp this)           this
                (Stamp''isEmpty-1 this)  stamp
                (Stamp''isEmpty-1 stamp) this
                :else                    (IntegerStamp''createStamp-6 this, stamp, (min (:lowerBound this) (:lowerBound stamp)), (max (:upperBound this) (:upperBound stamp)), (& (:downMask this) (:downMask stamp)), (| (:upMask this) (:upMask stamp)))
            )
        )

        (#_"IntegerStamp" Stamp'''join-2 [#_"IntegerStamp" this, #_"Stamp" stamp]
            (cond
                (= stamp this) this
                :else          (IntegerStamp''createStamp-6 this, stamp, (max (:lowerBound this) (:lowerBound stamp)), (min (:upperBound this) (:upperBound stamp)), (| (:downMask this) (:downMask stamp)), (& (:upMask this) (:upMask stamp)))
            )
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"IntegerStamp" this, #_"Stamp" stamp]
            (or (= this stamp)
                (and (satisfies? IntegerStamp stamp)
                    (= (:bits this) (:bits stamp))
                )
            )
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"IntegerStamp" this, #_"Constant" constant]
            (and (instance? PrimitiveConstant constant)
                (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant))
            )
        )
    )

    (defn- #_"boolean" IntegerStamp''sameSignBounds-1 [#_"IntegerStamp" this]
        (NumUtil'sameSign-2 (:lowerBound this), (:upperBound this))
    )

    (defn #_"long" IntegerStamp''unsignedUpperBound-1 [#_"IntegerStamp" this]
        (if (IntegerStamp''sameSignBounds-1 this)
            (CodeUtil/zeroExtend (:upperBound this), (:bits this))
            (NumUtil'maxValueUnsigned-1 (:bits this))
        )
    )

    (defn #_"long" IntegerStamp''unsignedLowerBound-1 [#_"IntegerStamp" this]
        (if (IntegerStamp''sameSignBounds-1 this)
            (CodeUtil/zeroExtend (:lowerBound this), (:bits this))
            0
        )
    )

    (defn- #_"long" IntegerStamp'upMaskFor-3 [#_"int" bits, #_"long" lowerBound, #_"long" upperBound]
        (let [
            #_"long" mask (| lowerBound upperBound)
        ]
            (if (zero? mask) 0 (& (>>> -1 (Long/numberOfLeadingZeros mask)) (CodeUtil/mask bits)))
        )
    )

    ;;;
     ; Checks if the 2 stamps represent values of the same sign. Returns true if the two stamps are
     ; both positive or nil or if they are both strictly negative.
     ;;
    (defn #_"boolean" IntegerStamp'sameSign-2 [#_"IntegerStamp" s1, #_"IntegerStamp" s2]
        (or (and (IntegerStamp''isPositive-1 s1) (IntegerStamp''isPositive-1 s2))
            (and (IntegerStamp''isStrictlyNegative-1 s1) (IntegerStamp''isStrictlyNegative-1 s2))
        )
    )

    (defm IntegerStamp Stamp
        (#_"JavaConstant" Stamp'''asConstant-1 [#_"IntegerStamp" this]
            (when (= (:lowerBound this) (:upperBound this))
                (case (:bits this)
                    1 (JavaConstant/forBoolean (not (zero? (:lowerBound this))))
                    8 (JavaConstant/forByte          (byte (:lowerBound this)))
                    16 (JavaConstant/forShort        (short (:lowerBound this)))
                    32 (JavaConstant/forInt            (int (:lowerBound this)))
                    64 (JavaConstant/forLong                (:lowerBound this))
                    nil
                )
            )
        )
    )

    (defn #_"boolean" IntegerStamp'addCanOverflow-2 [#_"IntegerStamp" a, #_"IntegerStamp" b]
        (or (IntegerStamp'addOverflowsPositively-3 (:upperBound a), (:upperBound b), (:bits a))
            (IntegerStamp'addOverflowsNegatively-3 (:lowerBound a), (:lowerBound b), (:bits a))
        )
    )

    (defn #_"boolean" IntegerStamp'addOverflowsPositively-3 [#_"long" x, #_"long" y, #_"int" bits]
        (let [
            #_"long" z (+ x y)
        ]
            (if (= bits 64) (neg? (& (bit-not x) (bit-not y) z)) (< (CodeUtil/maxValue bits) z))
        )
    )

    (defn #_"boolean" IntegerStamp'addOverflowsNegatively-3 [#_"long" x, #_"long" y, #_"int" bits]
        (let [
            #_"long" z (+ x y)
        ]
            (if (= bits 64) (neg? (& x y (bit-not z))) (< z (CodeUtil/minValue bits)))
        )
    )

    (defn #_"long" IntegerStamp'carryBits-2 [#_"long" x, #_"long" y]
        (bit-xor (+ x y) x y)
    )

    (defn- #_"long" IntegerStamp'saturate-2 [#_"long" v, #_"int" bits]
        (when (< bits 64) => v
            (min (max (CodeUtil/minValue bits) v) (CodeUtil/maxValue bits))
        )
    )

    (defn #_"boolean" IntegerStamp'multiplicationOverflows-3 [#_"long" a, #_"long" b, #_"int" bits]
        (let [
            #_"long" result (* a b)
            ;; result is positive if the sign is the same
            #_"boolean" positive (or (and (<= 0 a) (<= 0 b)) (and (neg? a) (neg? b)))
        ]
            (if (= bits 64)
                (cond
                    (and (pos? a) (pos? b)) (> a (quot 0x7fffffffffffffff b))
                    (and (pos? a) (<= b 0)) (< b (quot 0x8000000000000000 a))
                    (and (<= a 0) (pos? b)) (< a (quot 0x8000000000000000 b))
                    :else ;; a <= 0 && b <= 0
                       (and (not (zero? a)) (< b (quot 0x7fffffffffffffff a)))
                )
                (if positive (< (CodeUtil/maxValue bits) result) (< result (CodeUtil/minValue bits)))
            )
        )
    )

    (defn #_"boolean" IntegerStamp'multiplicationCanOverflow-2 [#_"IntegerStamp" a, #_"IntegerStamp" b]
        ;; see IntegerStamp#foldStamp for details
        (cond
            (zero? (:upMask a)) false
            (zero? (:upMask b)) false
            (Stamp'''isUnrestricted-1 a) true
            (Stamp'''isUnrestricted-1 b) true
            :else
                (let [
                    #_"int" bits (:bits a)
                    #_"long" minNegA (:lowerBound a)
                    #_"long" maxNegA (min 0 (:upperBound a))
                    #_"long" minPosA (max 0 (:lowerBound a))
                    #_"long" maxPosA (:upperBound a)
                    #_"long" minNegB (:lowerBound b)
                    #_"long" maxNegB (min 0 (:upperBound b))
                    #_"long" minPosB (max 0 (:lowerBound b))
                    #_"long" maxPosB (:upperBound b)
                    #_"boolean" mayOverflow false
                ]
                    (when (IntegerStamp''canBePositive-1 a)
                        (when (IntegerStamp''canBePositive-1 b)
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxPosA, maxPosB, bits)))
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minPosA, minPosB, bits)))
                        )
                        (when (IntegerStamp''canBeNegative-1 b)
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minPosA, maxNegB, bits)))
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxPosA, minNegB, bits)))
                        )
                    )
                    (when (IntegerStamp''canBeNegative-1 a)
                        (when (IntegerStamp''canBePositive-1 b)
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxNegA, minPosB, bits)))
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minNegA, maxPosB, bits)))
                        )
                        (when (IntegerStamp''canBeNegative-1 b)
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minNegA, minNegB, bits)))
                            (ยง ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxNegA, maxNegB, bits)))
                        )
                    )
                    mayOverflow
                )
        )
    )

    (defn #_"boolean" IntegerStamp'subtractionCanOverflow-2 [#_"IntegerStamp" x, #_"IntegerStamp" y]
        (or (IntegerStamp'subtractionOverflows-3 (:lowerBound x), (:upperBound y), (:bits x))
            (IntegerStamp'subtractionOverflows-3 (:upperBound x), (:lowerBound y), (:bits x))
        )
    )

    (defn #_"boolean" IntegerStamp'subtractionOverflows-3 [#_"long" x, #_"long" y, #_"int" bits]
        (if (= bits 64)
            (neg? (& (bit-xor x y) (bit-xor x (- x y))))
            (not (<= (CodeUtil/minValue bits) (- x y) (CodeUtil/maxValue bits)))
        )
    )

    (ยง def #_"ArithmeticOpTable" IntegerStamp'OPS (ร ArithmeticOpTable'new
    (ยง args
        (ยง proxy #_"Neg" (Neg'new-0)
            (defm Neg UnaryOp
                (#_"Constant" UnaryOp'''foldConstant-2 [#_"Neg" this, #_"Constant" value]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind value), (- (#_"PrimitiveConstant" .asLong value)))
                )

                (#_"Stamp" UnaryOp'''foldStamp-2 [#_"Neg" this, #_"Stamp" stamp]
                    (when-not (Stamp''isEmpty-1 stamp) => stamp
                        (let [
                            #_"int" bits (:bits stamp)
                        ]
                            (cond
                                (= (:lowerBound stamp) (:upperBound stamp))
                                    (let [
                                        #_"long" value (CodeUtil/convert (- (:lowerBound stamp)), bits, false)
                                    ]
                                        (StampFactory'forInteger-3i bits, value, value)
                                    )
                                (not= (:lowerBound stamp) (CodeUtil/minValue bits))
                                    ;; TODO check if the mask calculation is correct
                                    (StampFactory'forInteger-3i bits, (- (:upperBound stamp)), (- (:lowerBound stamp)))
                                :else
                                    (Stamp'''unrestricted-1 stamp)
                            )
                        )
                    )
                )
            )
        )

        (ยง proxy #_"Add" (Add'new-2 true, true)
            (defm Add BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Add" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (+ (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Add" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else
                            (let [
                                #_"int" bits (:bits a)
                            ]
                                (cond
                                    (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)))
                                        (let [
                                            #_"long" value (CodeUtil/convert (+ (:lowerBound a) (:lowerBound b)), bits, false)
                                        ]
                                            (StampFactory'forInteger-3i bits, value, value)
                                        )
                                    (Stamp'''isUnrestricted-1 a) a
                                    (Stamp'''isUnrestricted-1 b) b
                                    :else
                                        (let [
                                            #_"long" defaultMask (CodeUtil/mask bits)
                                            #_"long" variableBits (| (bit-xor (:downMask a) (:upMask a)) (bit-xor (:downMask b) (:upMask b)))
                                            #_"long" variableBitsWithCarry (| variableBits (bit-xor (IntegerStamp'carryBits-2 (:downMask a), (:downMask b)) (IntegerStamp'carryBits-2 (:upMask a), (:upMask b))))
                                            #_"long" newDownMask (& (+ (:downMask a) (:downMask b)) (bit-not variableBitsWithCarry))
                                            #_"long" newUpMask (| (+ (:downMask a) (:downMask b)) variableBitsWithCarry)
                                            newDownMask (& newDownMask defaultMask)
                                            newUpMask (& newUpMask defaultMask)
                                            [#_"long" lower #_"long" upper]
                                                (if (or (and (IntegerStamp'addOverflowsNegatively-3 (:lowerBound a), (:lowerBound b), bits) (not (IntegerStamp'addOverflowsNegatively-3 (:upperBound a), (:upperBound b), bits))) (and (not (IntegerStamp'addOverflowsPositively-3 (:lowerBound a), (:lowerBound b), bits)) (IntegerStamp'addOverflowsPositively-3 (:upperBound a), (:upperBound b), bits)))
                                                    [(CodeUtil/minValue bits) (CodeUtil/maxValue bits)]
                                                    [(CodeUtil/signExtend (& (+ (:lowerBound a) (:lowerBound b)) defaultMask), bits) (CodeUtil/signExtend (& (+ (:upperBound a) (:upperBound b)) defaultMask), bits)]
                                                )
                                            #_"IntegerStamp" limit (StampFactory'forInteger-3i bits, lower, upper)
                                            newUpMask (& newUpMask (:upMask limit))
                                            upper (CodeUtil/signExtend (& upper newUpMask), bits)
                                            newDownMask (| newDownMask (:downMask limit))
                                            lower (| lower newDownMask)
                                        ]
                                            (IntegerStamp'new-5 bits, lower, upper, newDownMask, newUpMask)
                                        )
                                )
                            )
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"Add" this, #_"Constant" value]
                    (zero? (#_"PrimitiveConstant" .asLong value))
                )
            )
        )

        (ยง proxy #_"Sub" (Sub'new-2 true, false)
            (defm Sub BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Sub" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (- (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Sub" this, #_"Stamp" a, #_"Stamp" b]
                    (BinaryOp'''foldStamp-3 (:add IntegerStamp'OPS), a, (UnaryOp'''foldStamp-2 (:neg IntegerStamp'OPS), b))
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"Sub" this, #_"Constant" value]
                    (zero? (#_"PrimitiveConstant" .asLong value))
                )

                (#_"Constant" BinaryOp'''getZero-2 [#_"Sub" this, #_"Stamp" stamp]
                    (JavaConstant/forPrimitiveInt (:bits stamp), 0)
                )
            )
        )

        (ยง proxy #_"Mul" (Mul'new-2 true, true)
            (defm Mul BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Mul" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (* (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Mul" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else
                            (let [
                                #_"int" bits (:bits a)
                            ]
                                (cond
                                    (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)))
                                        (let [
                                            #_"long" value (CodeUtil/convert (* (:lowerBound a) (:lowerBound b)), bits, false)
                                        ]
                                            (StampFactory'forInteger-3i bits, value, value)
                                        )
                                    ;; if a==0 or b==0 result of a*b is always 0
                                    (zero? (:upMask a)) a
                                    (zero? (:upMask b)) b
                                    ;; if a or b has the full range, the result will also have it
                                    (Stamp'''isUnrestricted-1 a) a
                                    (Stamp'''isUnrestricted-1 b) b
                                    :else
                                        ;; a != 0 && b != 0 holds
                                        (let [
                                            #_"long" lower Long/MAX_VALUE
                                            #_"long" upper Long/MIN_VALUE
                                            ;; Based on the signs of the incoming stamps lower and upper bound
                                            ;; of the result of the multiplication may be swapped. LowerBound
                                            ;; can become upper bound if both signs are negative, and so on. To
                                            ;; determine the new values for lower and upper bound we need to
                                            ;; look at the max and min of the cases blow:
                                            ;;
                                            ;; a.lowerBound * b.lowerBound
                                            ;; a.lowerBound * b.upperBound
                                            ;; a.upperBound * b.lowerBound
                                            ;; a.upperBound * b.upperBound
                                            ;;
                                            ;; We are only interested in those cases that are relevant due to
                                            ;; the sign of the involved stamps (whether a stamp includes
                                            ;; negative and/or positive values). Based on the signs, the maximum
                                            ;; or minimum of the above multiplications form the new lower and
                                            ;; upper bounds.
                                            ;;
                                            ;; The table below contains the interesting candidates for lower and
                                            ;; upper bound after multiplication.
                                            ;;
                                            ;; For example if we consider two stamps a & b that both contain
                                            ;; negative and positive values, the product of minNegA * minNegB
                                            ;; (both the smallest negative value for each stamp) can only be the
                                            ;; highest positive number. The other candidates can be computed in
                                            ;; a similar fashion. Some of them can never be a new minimum or
                                            ;; maximum and are therefore excluded.
                                            ;;
                                            ;;          [x................0................y]
                                            ;;          -------------------------------------
                                            ;;          [minNeg     maxNeg minPos     maxPos]
                                            ;;
                                            ;;          where maxNeg = min(0,y) && minPos = max(0,x)
                                            ;;
                                            ;;                 |minNegA  maxNegA    minPosA  maxPosA
                                            ;;         _______ |____________________________________
                                            ;;         minNegB | MAX        /     :     /      MIN
                                            ;;         maxNegB |  /        MIN    :    MAX      /
                                            ;;                 |------------------+-----------------
                                            ;;         minPosB |  /        MAX    :    MIN      /
                                            ;;         maxPosB | MIN        /     :     /      MAX

                                            ;; We materialize all factors here. If they are needed, the signs of
                                            ;; the stamp will ensure the correct value is used.
                                            #_"long" minNegA (:lowerBound a)
                                            #_"long" maxNegA (min 0 (:upperBound a))
                                            #_"long" minPosA (max 0 (:lowerBound a))
                                            #_"long" maxPosA (:upperBound a)
                                            #_"long" minNegB (:lowerBound b)
                                            #_"long" maxNegB (min 0 (:upperBound b))
                                            #_"long" minPosB (max 0 (:lowerBound b))
                                            #_"long" maxPosB (:upperBound b)
                                            ;; multiplication has shift semantics
                                            #_"long" newUpMask (& (bit-not (CodeUtil/mask (min 64 (+ (Long/numberOfTrailingZeros (:upMask a)) (Long/numberOfTrailingZeros (:upMask b)))))) (CodeUtil/mask bits))
                                        ]
                                            (when (IntegerStamp''canBePositive-1 a)
                                                (when (IntegerStamp''canBePositive-1 b)
                                                    (when (IntegerStamp'multiplicationOverflows-3 maxPosA, maxPosB, bits)
                                                        (ยง return (Stamp'''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" maxCandidate (* maxPosA maxPosB)
                                                    ]
                                                        (when (IntegerStamp'multiplicationOverflows-3 minPosA, minPosB, bits)
                                                            (ยง return (Stamp'''unrestricted-1 a))
                                                        )
                                                        (let [
                                                            #_"long" minCandidate (* minPosA minPosB)
                                                        ]
                                                            (ยง ass lower (min lower minCandidate))
                                                            (ยง ass upper (max upper maxCandidate))
                                                        )
                                                    )
                                                )
                                                (when (IntegerStamp''canBeNegative-1 b)
                                                    (when (IntegerStamp'multiplicationOverflows-3 minPosA, maxNegB, bits)
                                                        (ยง return (Stamp'''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" maxCandidate (* minPosA maxNegB)
                                                    ]
                                                        (when (IntegerStamp'multiplicationOverflows-3 maxPosA, minNegB, bits)
                                                            (ยง return (Stamp'''unrestricted-1 a))
                                                        )
                                                        (let [
                                                            #_"long" minCandidate (* maxPosA minNegB)
                                                        ]
                                                            (ยง ass lower (min lower minCandidate))
                                                            (ยง ass upper (max upper maxCandidate))
                                                        )
                                                    )
                                                )
                                            )
                                            (when (IntegerStamp''canBeNegative-1 a)
                                                (when (IntegerStamp''canBePositive-1 b)
                                                    (when (IntegerStamp'multiplicationOverflows-3 maxNegA, minPosB, bits)
                                                        (ยง return (Stamp'''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" maxCandidate (* maxNegA minPosB)
                                                    ]
                                                        (when (IntegerStamp'multiplicationOverflows-3 minNegA, maxPosB, bits)
                                                            (ยง return (Stamp'''unrestricted-1 a))
                                                        )
                                                        (let [
                                                            #_"long" minCandidate (* minNegA maxPosB)
                                                        ]
                                                            (ยง ass lower (min lower minCandidate))
                                                            (ยง ass upper (max upper maxCandidate))
                                                        )
                                                    )
                                                )
                                                (when (IntegerStamp''canBeNegative-1 b)
                                                    (when (IntegerStamp'multiplicationOverflows-3 minNegA, minNegB, bits)
                                                        (ยง return (Stamp'''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" maxCandidate (* minNegA minNegB)
                                                    ]
                                                        (when (IntegerStamp'multiplicationOverflows-3 maxNegA, maxNegB, bits)
                                                            (ยง return (Stamp'''unrestricted-1 a))
                                                        )
                                                        (let [
                                                            #_"long" minCandidate (* maxNegA maxNegB)
                                                        ]
                                                            (ยง ass lower (min lower minCandidate))
                                                            (ยง ass upper (max upper maxCandidate))
                                                        )
                                                    )
                                                )
                                            )

                                            (StampFactory'forIntegerWithMask-5 bits, lower, upper, 0, newUpMask)
                                        )
                                )
                            )
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"Mul" this, #_"Constant" value]
                    (= (#_"PrimitiveConstant" .asLong value) 1)
                )
            )
        )

        (ยง proxy #_"MulHigh" (MulHigh'new-2 true, true)
            (defn- #_"long" MulHigh'multiplyHigh-3 [#_"long" x, #_"long" y, #_"JavaKind" javaKind]
                (if (= javaKind JavaKind/Int)
                    (>> (* x y) 32)
                    (let [
                        #_"long" x0 (& x 0xffffffff)
                        #_"long" x1 (>> x 32)
                        #_"long" y0 (& y 0xffffffff)
                        #_"long" y1 (>> y 32)
                        #_"long" z0 (* x0 y0)
                        #_"long" t (+ (* x1 y0) (>>> z0 32))
                        #_"long" z1 (& t 0xffffffff)
                        #_"long" z2 (>> t 32)
                        z1 (+ z1 (* x0 y1))
                    ]
                        (+ (* x1 y1) z2 (>> z1 32))
                    )
                )
            )

            (defm MulHigh BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"MulHigh" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (MulHigh'multiplyHigh-3 (#_"PrimitiveConstant" .asLong a), (#_"PrimitiveConstant" .asLong b), (#_"PrimitiveConstant" .getJavaKind a)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"MulHigh" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        (or (Stamp''isEmpty-1 a)        (Stamp''isEmpty-1 b))        (Stamp'''empty-1 a)
                        (or (Stamp'''isUnrestricted-1 a) (Stamp'''isUnrestricted-1 b)) (Stamp'''unrestricted-1 a)
                        :else
                            (let [
                                #_"JavaKind" javaKind (Stamp'''getStackKind-1 a)
                                #_"long[]" xExtremes (ยง array (:lowerBound a), (:upperBound a) )
                                #_"long[]" yExtremes (ยง array (:lowerBound b), (:upperBound b) )
                                [#_"long" lower #_"long" upper]
                                    (loop-when [lower Long/MAX_VALUE upper Long/MIN_VALUE #_"ISeq" s (seq xExtremes)] (some? s) => [lower upper]
                                        (let [
                                            #_"long" x (first s)
                                            [lower upper]
                                                (loop-when [lower lower upper upper #_"ISeq" s (seq yExtremes)] (some? s) => [lower upper]
                                                    (let [
                                                        #_"long" y (first s)
                                                        #_"long" z (MulHigh'multiplyHigh-3 x, y, javaKind)
                                                    ]
                                                        (recur (min lower z) (max upper z) (next s))
                                                    )
                                                )
                                        ]
                                            (recur lower upper (next s))
                                        )
                                    )
                            ]
                                (StampFactory'forInteger-3k javaKind, lower, upper)
                            )
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"MulHigh" this, #_"Constant" value]
                    false
                )
            )
        )

        (ยง proxy #_"UMulHigh" (UMulHigh'new-2 true, true)
            (defn- #_"long" UMulHigh'multiplyHighUnsigned-3 [#_"long" x, #_"long" y, #_"JavaKind" javaKind]
                (if (= javaKind JavaKind/Int)
                    (let [
                        #_"long" xl (& x 0xffffffff)
                        #_"long" yl (& y 0xffffffff)
                        #_"long" r (* xl yl)
                    ]
                        (int (>>> r 32))
                    )
                    (let [
                        #_"long" x0 (& x 0xffffffff)
                        #_"long" x1 (>>> x 32)
                        #_"long" y0 (& y 0xffffffff)
                        #_"long" y1 (>>> y 32)
                        #_"long" z0 (* x0 y0)
                        #_"long" t (+ (* x1 y0) (z0 >>> 32))
                        #_"long" z1 (& t 0xffffffff)
                        #_"long" z2 (>>> t 32)
                        z1 (+ z1 (* x0 y1))
                    ]
                        (+ (* x1 y1) z2 (>>> z1 32))
                    )
                )
            )

            (defn- #_"long[]" UMulHigh'getUnsignedExtremes-1 [#_"IntegerStamp" stamp]
                (if (and (< (:lowerBound stamp) 0) (<= 0 (:upperBound stamp)))
                    ;; If -1 and 0 are both in the signed range, then we can't say anything
                    ;; about the unsigned range, so we have to return [0, MAX_UNSIGNED].
                    (long-array [ 0, -1 ])
                    (long-array [ (:lowerBound stamp), (:upperBound stamp) ])
                )
            )

            (defm UMulHigh BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"UMulHigh" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (UMulHigh'multiplyHighUnsigned-3 (#_"PrimitiveConstant" .asLong a), (#_"PrimitiveConstant" .asLong b), (#_"PrimitiveConstant" .getJavaKind a)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"UMulHigh" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        (or (Stamp''isEmpty-1 a)         (Stamp''isEmpty-1 b))         (Stamp'''empty-1 a)
                        (or (Stamp'''isUnrestricted-1 a) (Stamp'''isUnrestricted-1 b)) (Stamp'''unrestricted-1 a)
                        :else
                            ;; Note that the minima and maxima are calculated using signed min/max
                            ;; functions, while the values themselves are unsigned.
                            (let [
                                #_"JavaKind" javaKind (Stamp'''getStackKind-1 a)
                                #_"long[]" xExtremes (UMulHigh'getUnsignedExtremes-1 a)
                                #_"long[]" yExtremes (UMulHigh'getUnsignedExtremes-1 b)
                                [#_"long" lower #_"long" upper]
                                    (loop-when [lower Long/MAX_VALUE upper Long/MIN_VALUE #_"ISeq" s (seq xExtremes)] (some? s) => [lower upper]
                                        (let [
                                            #_"long" x (first s)
                                            [lower upper]
                                                (loop-when [lower lower upper upper #_"ISeq" s (seq yExtremes)] (some? s) => [lower upper]
                                                    (let [
                                                        #_"long" y (first s)
                                                        #_"long" z (UMulHigh'multiplyHighUnsigned-3 x, y, javaKind)
                                                    ]
                                                        (recur (min lower z) (max upper z) (next s))
                                                    )
                                                )
                                        ]
                                            (recur lower upper (next s))
                                        )
                                    )
                            ]
                                ;; if min is negative, then the value can reach into the unsigned range
                                (if (or (= lower upper) (<= 0 lower))
                                    (StampFactory'forInteger-3k javaKind, lower, upper)
                                    (StampFactory'forKind-1 javaKind)
                                )
                            )
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"UMulHigh" this, #_"Constant" value]
                    false
                )
            )
        )

        (ยง proxy #_"Div" (Div'new-2 true, false)
            (defm Div BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Div" this, #_"Constant" a, #_"Constant" b]
                    (when-not (zero? (#_"PrimitiveConstant" .asLong b))
                        (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (quot (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                    )
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Div" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else
                            (let [
                                #_"int" bits (:bits a)
                            ]
                                (cond
                                    (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)) (not (zero? (:lowerBound b))))
                                        (let [
                                            #_"long" value (CodeUtil/convert (quot (:lowerBound a) (:lowerBound b)), bits, false)
                                        ]
                                            (StampFactory'forInteger-3i bits, value, value)
                                        )
                                    (IntegerStamp''isStrictlyPositive-1 b)
                                        (let [
                                            #_"long" lower (if (neg? (:lowerBound a)) (quot (:lowerBound a) (:lowerBound b)) (quot (:lowerBound a) (:upperBound b)))
                                            #_"long" upper (if (neg? (:upperBound a)) (quot (:upperBound a) (:upperBound b)) (quot (:upperBound a) (:lowerBound b)))
                                        ]
                                            (StampFactory'forInteger-3i bits, lower, upper)
                                        )
                                    :else
                                        (Stamp'''unrestricted-1 a)
                                )
                            )
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"Div" this, #_"Constant" value]
                    (= (#_"PrimitiveConstant" .asLong value) 1)
                )
            )
        )

        (ยง proxy #_"Rem" (Rem'new-2 false, false)
            (defm Rem BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Rem" this, #_"Constant" a, #_"Constant" b]
                    (when-not (zero? (#_"PrimitiveConstant" .asLong b))
                        (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (% (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                    )
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Rem" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else
                            (let [
                                #_"int" bits (:bits a)
                            ]
                                (if (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)) (not (zero? (:lowerBound b))))
                                    (let [
                                        #_"long" value (CodeUtil/convert (% (:lowerBound a) (:lowerBound b)), bits, false)
                                    ]
                                        (StampFactory'forInteger-3i bits, value, value)
                                    )
                                    ;; zero is always possible
                                    (let [
                                        #_"long" lower (min (:lowerBound a) 0)
                                        #_"long" upper (max (:upperBound a) 0)
                                        ;; the maximum absolute value of the result, derived from b
                                        #_"long" magnitude
                                            (if (= (:lowerBound b) (CodeUtil/minValue (:bits b)))
                                                ;; Math.abs(...) - 1 does not work in a case
                                                (CodeUtil/maxValue (:bits b))
                                                (dec (max (abs (:lowerBound b)) (abs (:upperBound b))))
                                            )
                                        lower (max lower (- magnitude))
                                        upper (min upper magnitude)
                                    ]
                                        (StampFactory'forInteger-3i bits, lower, upper)
                                    )
                                )
                            )
                    )
                )
            )
        )

        (ยง proxy #_"Not" (Not'new-0)
            (defm Not UnaryOp
                (#_"Constant" UnaryOp'''foldConstant-2 [#_"Not" this, #_"Constant" constant]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind constant), (bit-not (#_"PrimitiveConstant" .asLong constant)))
                )

                (#_"Stamp" UnaryOp'''foldStamp-2 [#_"Not" this, #_"Stamp" stamp]
                    (when-not (Stamp''isEmpty-1 stamp) => stamp
                        (let [
                            #_"int" bits (:bits stamp)
                            #_"long" mask (CodeUtil/mask bits)
                        ]
                            (IntegerStamp'new-5 bits, (bit-not (:upperBound stamp)), (bit-not (:lowerBound stamp)), (& (bit-not (:upMask stamp)) mask), (& (bit-not (:downMask stamp)) mask))
                        )
                    )
                )
            )
        )

        (ยง proxy #_"And" (And'new-2 true, true)
            (defm And BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"And" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (& (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"And" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else                (IntegerStamp'stampForMask-3 (:bits a), (& (:downMask a) (:downMask b)), (& (:upMask a) (:upMask b)))
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"And" this, #_"Constant" value]
                    (let [
                        #_"long" mask (CodeUtil/mask (#_"JavaKind" .getBitCount (#_"PrimitiveConstant" .getJavaKind value)))
                    ]
                        (= (& (#_"PrimitiveConstant" .asLong value) mask) mask)
                    )
                )
            )
        )

        (ยง proxy #_"Or" (Or'new-2 true, true)
            (defm Or BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Or" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (| (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Or" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else                (IntegerStamp'stampForMask-3 (:bits a), (| (:downMask a) (:downMask b)), (| (:upMask a) (:upMask b)))
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"Or" this, #_"Constant" value]
                    (zero? (#_"PrimitiveConstant" .asLong value))
                )
            )
        )

        (ยง proxy #_"Xor" (Xor'new-2 true, true)
            (defm Xor BinaryOp
                (#_"Constant" BinaryOp'''foldConstant-3 [#_"Xor" this, #_"Constant" a, #_"Constant" b]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (bit-xor (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )

                (#_"Stamp" BinaryOp'''foldStamp-3 [#_"Xor" this, #_"Stamp" a, #_"Stamp" b]
                    (cond
                        (Stamp''isEmpty-1 a) a
                        (Stamp''isEmpty-1 b) b
                        :else
                            (let [
                                #_"long" variableBits (| (bit-xor (:downMask a) (:upMask a)) (bit-xor (:downMask b) (:upMask b)))
                                #_"long" downMask (& (bit-xor (:downMask a) (:downMask b)) (bit-not variableBits))
                                #_"long" upMask (| (bit-xor (:downMask a) (:downMask b)) variableBits)
                            ]
                                (IntegerStamp'stampForMask-3 (:bits a), downMask, upMask)
                            )
                    )
                )

                (#_"boolean" BinaryOp'''isNeutral-2 [#_"Xor" this, #_"Constant" value]
                    (zero? (#_"PrimitiveConstant" .asLong value))
                )

                (#_"Constant" BinaryOp'''getZero-2 [#_"Xor" this, #_"Stamp" stamp]
                    (JavaConstant/forPrimitiveInt (:bits stamp), 0)
                )
            )
        )

        (ยง proxy #_"Shl" (Shl'new-0)
            (defm Shl ShiftOp
                (#_"Constant" ShiftOp'''foldConstant-3 [#_"Shl" this, #_"Constant" value, #_"int" amount]
                    (condp = (#_"PrimitiveConstant" .getJavaKind value)
                        JavaKind/Int  (JavaConstant/forInt (<< (#_"PrimitiveConstant" .asInt value) amount))
                        JavaKind/Long (JavaConstant/forLong (<< (#_"PrimitiveConstant" .asLong value) amount))
                    )
                )

                (#_"Stamp" ShiftOp'''foldStamp-3 [#_"Shl" this, #_"Stamp" stamp, #_"IntegerStamp" shift]
                    (let [
                        #_"int" bits (:bits stamp)
                    ]
                        (cond
                            (Stamp''isEmpty-1 stamp) stamp
                            (Stamp''isEmpty-1 shift) (Stamp'''empty-1 (StampFactory'forInteger-1 bits))
                            (zero? (:upMask stamp))  stamp
                            :else
                                (let [
                                    #_"int" shiftMask (ShiftOp'getShiftAmountMask-1 stamp)
                                    #_"int" shiftBits (Integer/bitCount shiftMask)
                                ]
                                    (when (= (:lowerBound shift) (:upperBound shift))
                                        (let [
                                            #_"int" shiftAmount (int (& (:lowerBound shift) shiftMask))
                                        ]
                                            (when (zero? shiftAmount)
                                                (ยง return stamp)
                                            )
                                            ;; the mask of bits that will be lost or shifted into the sign bit
                                            (let [
                                                #_"long" removedBits (<< -1 (- bits shiftAmount 1))
                                            ]
                                                (when (and (zero? (& (:lowerBound stamp) removedBits)) (zero? (& (:upperBound stamp) removedBits)))
                                                    ;; use a better stamp if neither lower nor upper bound can lose bits
                                                    (ยง return (IntegerStamp'new-5 bits, (<< (:lowerBound stamp) shiftAmount), (<< (:upperBound stamp) shiftAmount), (<< (:downMask stamp) shiftAmount), (<< (:upMask stamp) shiftAmount)))
                                                )
                                            )
                                        )
                                    )
                                    (when (= (>>> (:lowerBound shift) shiftBits) (>>> (:upperBound shift) shiftBits)) => (Stamp'''unrestricted-1 stamp)
                                        (let [
                                            #_"long" defaultMask (CodeUtil/mask bits)
                                            [#_"long" downMask #_"long" upMask]
                                                (loop-when [downMask defaultMask upMask 0 #_"long" i (:lowerBound shift)] (<= i (:upperBound shift)) => [downMask upMask]
                                                    (let [
                                                        [downMask upMask]
                                                            (when (IntegerStamp''contains-2 shift, i) => [downMask upMask]
                                                                [(& downMask (<< (:downMask stamp) (& i shiftMask))) (| upMask (<< (:upMask stamp) (& i shiftMask)))]
                                                            )
                                                    ]
                                                        (recur downMask upMask (inc i))
                                                    )
                                                )
                                        ]
                                            (IntegerStamp'stampForMask-3 bits, downMask, (& upMask defaultMask))
                                        )
                                    )
                                )
                        )
                    )
                )
            )
        )

        (ยง proxy #_"Shr" (Shr'new-0)
            (defm Shr ShiftOp
                (#_"Constant" ShiftOp'''foldConstant-3 [#_"Shr" this, #_"Constant" value, #_"int" amount]
                    (condp = (#_"PrimitiveConstant" .getJavaKind value)
                        JavaKind/Int  (JavaConstant/forInt (>> (#_"PrimitiveConstant" .asInt value) amount))
                        JavaKind/Long (JavaConstant/forLong (>> (#_"PrimitiveConstant" .asLong value) amount))
                    )
                )

                (#_"Stamp" ShiftOp'''foldStamp-3 [#_"Shr" this, #_"Stamp" stamp, #_"IntegerStamp" shift]
                    (let [
                        #_"int" bits (:bits stamp)
                    ]
                        (cond
                            (Stamp''isEmpty-1 stamp) stamp
                            (Stamp''isEmpty-1 shift) (Stamp'''empty-1 (StampFactory'forInteger-1 bits))
                            (= (:lowerBound shift) (:upperBound shift))
                                (let [
                                    #_"long" shiftAmount (& (:lowerBound shift) (ShiftOp'getShiftAmountMask-1 stamp))
                                ]
                                    (when-not (zero? shiftAmount) => stamp
                                        (let [
                                            #_"int" extraBits (- 64 bits)
                                            #_"long" defaultMask (CodeUtil/mask bits)
                                            ;; shifting back and forth performs sign extension
                                            #_"long" downMask (& (>> (<< (:downMask stamp) extraBits) (+ shiftAmount extraBits)) defaultMask)
                                            #_"long" upMask (& (>> (<< (:upMask stamp) extraBits) (+ shiftAmount extraBits)) defaultMask)
                                        ]
                                            (IntegerStamp'new-5 bits, (>> (:lowerBound stamp) shiftAmount), (>> (:upperBound stamp) shiftAmount), downMask, upMask)
                                        )
                                    )
                                )
                            :else
                                (IntegerStamp'stampForMask-3 bits, 0, (IntegerStamp'upMaskFor-3 bits, (:lowerBound stamp), (:upperBound stamp)))
                        )
                    )
                )
            )
        )

        (ยง proxy #_"UShr" (UShr'new-0)
            (defm UShr ShiftOp
                (#_"Constant" ShiftOp'''foldConstant-3 [#_"UShr" this, #_"Constant" value, #_"int" amount]
                    (condp = (#_"PrimitiveConstant" .getJavaKind value)
                        JavaKind/Int  (JavaConstant/forInt (>>> (#_"PrimitiveConstant" .asInt value) amount))
                        JavaKind/Long (JavaConstant/forLong (>>> (#_"PrimitiveConstant" .asLong value) amount))
                    )
                )

                (#_"Stamp" ShiftOp'''foldStamp-3 [#_"UShr" this, #_"Stamp" stamp, #_"IntegerStamp" shift]
                    (let [
                        #_"int" bits (:bits stamp)
                    ]
                        (cond
                            (Stamp''isEmpty-1 stamp) stamp
                            (Stamp''isEmpty-1 shift) (Stamp'''empty-1 (StampFactory'forInteger-1 bits))
                            (= (:lowerBound shift) (:upperBound shift))
                                (let [
                                    #_"long" shiftAmount (& (:lowerBound shift) (ShiftOp'getShiftAmountMask-1 stamp))
                                ]
                                    (when-not (zero? shiftAmount) => stamp
                                        (let [
                                            #_"long" downMask (>>> (:downMask stamp) shiftAmount)
                                            #_"long" upMask (>>> (:upMask stamp) shiftAmount)
                                        ]
                                            (if (neg? (:lowerBound stamp))
                                                (IntegerStamp'new-5 bits, downMask, upMask, downMask, upMask)
                                                (IntegerStamp'new-5 bits, (>>> (:lowerBound stamp) shiftAmount), (>>> (:upperBound stamp) shiftAmount), downMask, upMask)
                                            )
                                        )
                                    )
                                )
                            :else
                                (IntegerStamp'stampForMask-3 bits, 0, (IntegerStamp'upMaskFor-3 bits, (:lowerBound stamp), (:upperBound stamp)))
                        )
                    )
                )
            )
        )

        (ยง proxy #_"Abs" (Abs'new-0)
            (defm Abs UnaryOp
                (#_"Constant" UnaryOp'''foldConstant-2 [#_"Abs" this, #_"Constant" constant]
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind constant), (abs (#_"PrimitiveConstant" .asLong constant)))
                )

                (#_"Stamp" UnaryOp'''foldStamp-2 [#_"Abs" this, #_"Stamp" stamp]
                    (cond
                        (Stamp''isEmpty-1 stamp)
                            stamp
                        (= (:lowerBound stamp) (:upperBound stamp))
                            (let [
                                #_"long" value (CodeUtil/convert (abs (:lowerBound stamp)), (:bits stamp), false)
                            ]
                                (StampFactory'forInteger-3i (:bits stamp), value, value)
                            )
                        (= (:lowerBound stamp) (CodeUtil/minValue (:bits stamp)))
                            (Stamp'''unrestricted-1 stamp)
                        :else
                            (StampFactory'forInteger-3i (:bits stamp), 0, (max (- (:lowerBound stamp)) (:upperBound stamp)))
                    )
                )
            )
        )

        (ยง proxy #_"ZeroExtend" (ZeroExtend'new-0)
            (defm ZeroExtend IntegerConvertOp
                (#_"Constant" IntegerConvertOp'''foldConstant-4 [#_"ZeroExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" constant]
                    (JavaConstant/forPrimitiveInt resultBits, (CodeUtil/zeroExtend (#_"PrimitiveConstant" .asLong constant), inputBits))
                )

                (#_"Stamp" IntegerConvertOp'''foldStamp-4 [#_"ZeroExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                    (cond
                        (Stamp''isEmpty-1 stamp) (Stamp'''empty-1 (StampFactory'forInteger-1 resultBits))
                        (= inputBits resultBits) stamp
                        :else
                            (let [
                                #_"long" downMask (CodeUtil/zeroExtend (:downMask stamp), inputBits)
                                #_"long" upMask (CodeUtil/zeroExtend (:upMask stamp), inputBits)
                                #_"long" lowerBound (IntegerStamp''unsignedLowerBound-1 stamp)
                                #_"long" upperBound (IntegerStamp''unsignedUpperBound-1 stamp)
                            ]
                                (IntegerStamp'create-5 resultBits, lowerBound, upperBound, downMask, upMask)
                            )
                    )
                )

                (#_"Stamp" IntegerConvertOp'''invertStamp-4 [#_"ZeroExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                    (if (Stamp''isEmpty-1 stamp)
                        (Stamp'''empty-1 (StampFactory'forInteger-1 inputBits))
                        (StampFactory'forUnsignedInteger-5 inputBits, (:lowerBound stamp), (:upperBound stamp), (:downMask stamp), (:upMask stamp))
                    )
                )
            )
        )

        (ยง proxy #_"SignExtend" (SignExtend'new-0)
            (defm SignExtend IntegerConvertOp
                (#_"Constant" IntegerConvertOp'''foldConstant-4 [#_"SignExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" constant]
                    (JavaConstant/forPrimitiveInt resultBits, (CodeUtil/signExtend (#_"PrimitiveConstant" .asLong constant), inputBits))
                )

                (#_"Stamp" IntegerConvertOp'''foldStamp-4 [#_"SignExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                    (if (Stamp''isEmpty-1 stamp)
                        (Stamp'''empty-1 (StampFactory'forInteger-1 resultBits))
                        (let [
                            #_"long" defaultMask (CodeUtil/mask resultBits)
                            #_"long" downMask (CodeUtil/signExtend (:downMask stamp), (& inputBits defaultMask))
                            #_"long" upMask (CodeUtil/signExtend (:upMask stamp), (& inputBits defaultMask))
                        ]
                            (IntegerStamp'new-5 resultBits, (:lowerBound stamp), (:upperBound stamp), downMask, upMask)
                        )
                    )
                )

                (#_"Stamp" IntegerConvertOp'''invertStamp-4 [#_"SignExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                    (if (Stamp''isEmpty-1 stamp)
                        (Stamp'''empty-1 (StampFactory'forInteger-1 inputBits))
                        (let [
                            #_"long" mask (CodeUtil/mask inputBits)
                        ]
                            (StampFactory'forIntegerWithMask-5 inputBits, (:lowerBound stamp), (:upperBound stamp), (& (:downMask stamp) mask), (& (:upMask stamp) mask))
                        )
                    )
                )
            )
        )

        (ยง proxy #_"Narrow" (Narrow'new-0)
            (defm Narrow IntegerConvertOp
                (#_"Constant" IntegerConvertOp'''foldConstant-4 [#_"Narrow" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" constant]
                    (JavaConstant/forPrimitiveInt resultBits, (CodeUtil/narrow (#_"PrimitiveConstant" .asLong constant), resultBits))
                )

                (#_"Stamp" IntegerConvertOp'''foldStamp-4 [#_"Narrow" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                    (cond
                        (Stamp''isEmpty-1 stamp) (Stamp'''empty-1 (StampFactory'forInteger-1 resultBits))
                        (= inputBits resultBits) stamp
                        :else
                            (let [
                                #_"long" upperBound
                                    (if (< (:lowerBound stamp) (CodeUtil/minValue resultBits))
                                        (CodeUtil/maxValue resultBits)
                                        (IntegerStamp'saturate-2 (:upperBound stamp), resultBits)
                                    )
                                #_"long" lowerBound
                                    (if (< (CodeUtil/maxValue resultBits) (:upperBound stamp))
                                        (CodeUtil/minValue resultBits)
                                        (IntegerStamp'saturate-2 (:lowerBound stamp), resultBits)
                                    )
                                #_"long" defaultMask (CodeUtil/mask resultBits)
                                #_"long" downMask (& (:downMask stamp) defaultMask)
                                #_"long" upMask (& (:upMask stamp) defaultMask)
                                #_"long" lower (CodeUtil/signExtend (& (| lowerBound downMask) upMask), resultBits)
                                #_"long" upper (CodeUtil/signExtend (& (| upperBound downMask) upMask), resultBits)
                            ]
                                (IntegerStamp'new-5 resultBits, lower, upper, downMask, upMask)
                            )
                    )
                )
            )
        )
    )))
)

;;;
 ; This stamp represents the type of the JavaKind#Illegal value in the second slot
 ; of JavaKind#Long values. It can only appear in framestates or virtual objects.
 ;;
(class-ns IllegalStamp [Stamp]
    (defn- #_"IllegalStamp" IllegalStamp'new-0 []
        (merge (IllegalStamp'class.) (Stamp'new-0))
    )

    (defm IllegalStamp Stamp
        (#_"JavaKind" Stamp'''getStackKind-1 [#_"IllegalStamp" this]
            JavaKind/Illegal
        )

        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"IllegalStamp" this]
            LIRKind'Illegal
        )

        (#_"Stamp" Stamp'''unrestricted-1 [#_"IllegalStamp" this]
            this
        )

        (#_"boolean" Stamp'''isUnrestricted-1 [#_"IllegalStamp" this]
            true
        )

        (#_"Stamp" Stamp'''empty-1 [#_"IllegalStamp" this]
            this
        )

        (#_"Stamp" Stamp'''constant-2 [#_"IllegalStamp" this, #_"Constant" constant]
            this
        )

        (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"IllegalStamp" this]
            (throw! "illegal stamp has no Java type")
        )

        (#_"Stamp" Stamp'''meet-2 [#_"IllegalStamp" this, #_"Stamp" other]
            this
        )

        (#_"Stamp" Stamp'''join-2 [#_"IllegalStamp" this, #_"Stamp" other]
            this
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"IllegalStamp" this, #_"Stamp" stamp]
            (satisfies? IllegalStamp stamp)
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"IllegalStamp" this, #_"Constant" constant]
            (and (instance? PrimitiveConstant constant) (= (#_"PrimitiveConstant" .getJavaKind constant) JavaKind/Illegal))
        )

        (#_"boolean" Stamp'''hasValues-1 [#_"IllegalStamp" this]
            true
        )

        (#_"Stamp" Stamp'''improveWith-2 [#_"IllegalStamp" this, #_"Stamp" other]
            this
        )

        (#_"Constant" Stamp'''readConstant-4 [#_"IllegalStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (throw! "can't read values of illegal stamp")
        )
    )

    (ยง def #_"IllegalStamp" IllegalStamp'instance (IllegalStamp'new-0))
)

;;;
 ; Singleton stamp representing the value of type {@code void}.
 ;;
(class-ns VoidStamp [Stamp]
    (defn- #_"VoidStamp" VoidStamp'new-0 []
        (merge (VoidStamp'class.) (Stamp'new-0))
    )

    (defm VoidStamp Stamp
        (#_"Stamp" Stamp'''unrestricted-1 [#_"VoidStamp" this]
            this
        )

        (#_"boolean" Stamp'''isUnrestricted-1 [#_"VoidStamp" this]
            true
        )

        (#_"JavaKind" Stamp'''getStackKind-1 [#_"VoidStamp" this]
            JavaKind/Void
        )

        (#_"Stamp" Stamp'''improveWith-2 [#_"VoidStamp" this, #_"Stamp" other]
            this
        )

        (#_"LIRKind" Stamp'''getLIRKind-1 [#_"VoidStamp" this]
            (throw! "void stamp has no value")
        )

        (#_"ResolvedJavaType" Stamp'''javaType-1 [#_"VoidStamp" this]
            (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, void'class)
        )

        (#_"boolean" Stamp'''alwaysDistinct-2 [#_"VoidStamp" this, #_"Stamp" other]
            (not= this other)
        )

        (#_"Stamp" Stamp'''meet-2 [#_"VoidStamp" this, #_"Stamp" other]
            this
        )

        (#_"Stamp" Stamp'''join-2 [#_"VoidStamp" this, #_"Stamp" other]
            this
        )

        (#_"boolean" Stamp'''isCompatible-2s [#_"VoidStamp" this, #_"Stamp" stamp]
            (satisfies? VoidStamp stamp)
        )

        (#_"boolean" Stamp'''isCompatible-2c [#_"VoidStamp" this, #_"Constant" constant]
            false
        )

        (#_"Stamp" Stamp'''empty-1 [#_"VoidStamp" this]
            ;; the void stamp is always empty
            this
        )

        (#_"boolean" Stamp'''hasValues-1 [#_"VoidStamp" this]
            false
        )

        (#_"Constant" Stamp'''readConstant-4 [#_"VoidStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
            (throw! "can't read values of void stamp")
        )

        (#_"Stamp" Stamp'''constant-2 [#_"VoidStamp" this, #_"Constant" constant]
            (throw! "void stamp has no value")
        )
    )

    (ยง def #_"VoidStamp" VoidStamp'instance (VoidStamp'new-0))
)

(class-ns SuccessorInfo []
    (defn #_"SuccessorInfo" SuccessorInfo'new-1 [#_"int" blockSuccessorIndex]
        (merge (SuccessorInfo'class.)
            (hash-map
                #_"int" :blockIndex blockSuccessorIndex
                #_"int" :actualIndex -1
            )
        )
    )
)

(class-ns Suites []
    (defn #_"PhaseSuite" Suites'createGraphBuilderSuite-0 []
        (let [
            #_"PhaseSuite" suite (PhaseSuite'new-0)
        ]
            (PhaseSuite''appendPhase-2 suite, (GraphBuilderPhase'new-0))
            suite
        )
    )

    (defn #_"Suites" Suites'createSuites-0 []
        (let [
            #_"Suites" suites (Suites'new-3 (HighTier'new-0), (MidTier'new-0), (LowTier'new-0))
            _ (PhaseSuite''appendPhase-2 (:midTier suites), (WriteBarrierAdditionPhase'new-0))
            #_"ListIterator<Phase>" findPhase
                (or (PhaseSuite''findPhase-2 (:lowTier suites), FixReadsPhase'iface)
                    (PhaseSuite''findPhase-2 (:lowTier suites), ExpandLogicPhase'iface)
                )
        ]
            (#_"ListIterator" .add findPhase, (AddressLoweringPhase'new-1 (AddressLowering'new-1 HotSpot'heapBaseRegister)))
            suites
        )
    )

    (defn #_"Suites" Suites'new-3 [#_"PhaseSuite" highTier, #_"PhaseSuite" midTier, #_"PhaseSuite" lowTier]
        (merge (Suites'class.)
            (hash-map
                #_"PhaseSuite" :highTier highTier
                #_"PhaseSuite" :midTier midTier
                #_"PhaseSuite" :lowTier lowTier
            )
        )
    )
)

(class-ns SwitchStrategy []
    (defn #_"SwitchStrategy" SwitchStrategy'new-1 [#_"double[]" keyProbabilities]
        (merge (SwitchStrategy'class.)
            (hash-map
                #_"double[]" :keyProbabilities keyProbabilities
                #_"double" :averageEffort -1
                #_"EffortClosure" :effortClosure nil
            )
        )
    )

    (defm SwitchStrategy SwitchStrategy
        (#_"double" SwitchStrategy'''getAverageEffort-1 [#_"SwitchStrategy" this]
            (:averageEffort this)
        )
    )

    ;;;
     ; Tells the system that the given (inclusive) range of keys is reached after depth number
     ; of comparisons, which is used to calculate the average effort.
     ;;
    (defn #_"void" SwitchStrategy''registerEffort-4 [#_"SwitchStrategy" this, #_"int" rangeStart, #_"int" rangeEnd, #_"int" depth]
        (when (some? (:effortClosure this))
            (loop-when-recur [#_"int" i rangeStart] (<= i rangeEnd) [(inc i)]
                (aswap (:keyEfforts (:effortClosure this)) i + depth)
                (aswap (:keyCounts (:effortClosure this)) i inc)
            )
        )
        nil
    )

    ;;;
     ; Tells the system that the default successor is reached after depth number of comparisons,
     ; which is used to calculate average effort.
     ;;
    (defn #_"SwitchStrategy" SwitchStrategy''registerDefaultEffort-2 [#_"SwitchStrategy" this, #_"int" depth]
        (when (some? (:effortClosure this)) => this
            (let [
                this (update-in this [:effortClosure :defaultEffort] + depth)
                this (update-in this [:effortClosure :defaultCount] inc)
            ]
                this
            )
        )
    )

    (defn- #_"SwitchStrategy[]" SwitchStrategy'getStrategies-3 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants, #_"LabelRef[]" keyTargets]
        (let [
            #_"SwitchStrategy[]" strategies
                (into-array SwitchStrategy'iface
                    [
                        (SequentialStrategy'new-2 keyProbabilities, keyConstants),
                        (RangesStrategy'new-2 keyProbabilities, keyConstants),
                        (BinaryStrategy'new-2 keyProbabilities, keyConstants)
                    ]
                )
        ]
            (loop-when-recur [#_"ISeq" s (seq strategies)] (some? s) [(next s)]
                (let [
                    #_"SwitchStrategy" strategy (first s)
                ]
                    (ยง ass! strategy (assoc strategy :effortClosure (EffortClosure'new-2 strategy, keyTargets)))
                    (SwitchStrategy'''run-2 strategy, (:effortClosure strategy))
                    (ยง ass! strategy (assoc strategy :averageEffort (EffortClosure''getAverageEffort-1 (:effortClosure strategy))))
                    (ยง ass! strategy (assoc strategy :effortClosure nil))
                )
            )
            strategies
        )
    )

    ;;;
     ; Creates all switch strategies for the given switch, evaluates them (based on average effort)
     ; and returns the best one.
     ;;
    (defn #_"SwitchStrategy" SwitchStrategy'getBestStrategy-3 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants, #_"LabelRef[]" keyTargets]
        (let [
            #_"SwitchStrategy[]" strategies (SwitchStrategy'getStrategies-3 keyProbabilities, keyConstants, keyTargets)
        ]
            (loop-when [#_"double" bestEffort Integer/MAX_VALUE #_"SwitchStrategy" bestStrategy nil #_"ISeq" s (seq strategies)] (some? s) => bestStrategy
                (let [
                    #_"SwitchStrategy" strategy (first s)
                    [bestEffort bestStrategy]
                        (when (< (SwitchStrategy'''getAverageEffort-1 strategy) bestEffort) => [bestEffort bestStrategy]
                            [(SwitchStrategy'''getAverageEffort-1 strategy) strategy]
                        )
                ]
                    (recur bestEffort bestStrategy (next s))
                )
            )
        )
    )
)

;;;
 ; Base class for strategies that rely on primitive integer keys.
 ;;
(class-ns PrimitiveStrategy [SwitchStrategy]
    (defn #_"PrimitiveStrategy" PrimitiveStrategy'new-2 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants]
        (merge (PrimitiveStrategy'class.) (SwitchStrategy'new-1 keyProbabilities)
            (hash-map
                #_"JavaConstant[]" :keyConstants keyConstants
            )
        )
    )

    ;;;
     ; Looks for the end of a stretch of key constants that are successive numbers and have the same target.
     ;;
    (defn #_"int" PrimitiveStrategy''getSliceEnd-3 [#_"PrimitiveStrategy" this, #_"SwitchClosure" closure, #_"int" pos]
        (let [
            #_"JavaConstant[]" a (:keyConstants this)
        ]
            (loop-when-recur [#_"int" i pos]
                             (and (< i (dec (count a)))
                                  (= (#_"JavaConstant" .asLong (nth a (inc i))) (inc (#_"JavaConstant" .asLong (nth a i))))
                                  (SwitchClosure'''isSameTarget-3 closure, i, (inc i))
                             )
                             [(inc i)]
                          => i
            )
        )
    )
)

;;;
 ; This strategy recursively subdivides the list of keys to create a binary search based on probabilities.
 ;;
(class-ns BinaryStrategy [PrimitiveStrategy, SwitchStrategy]
    (def- #_"double" BinaryStrategy'MIN_PROBABILITY 0.00001)

    (defn #_"BinaryStrategy" BinaryStrategy'new-2 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants]
        (let [
            #_"BinaryStrategy" this
                (merge (BinaryStrategy'class.) (PrimitiveStrategy'new-2 keyProbabilities, keyConstants)
                    (hash-map
                        #_"double[]" :probabilitySums (double-array (inc (count keyProbabilities)))
                    )
                )
            _
                (loop-when [#_"double" sum 0.0 #_"int" i 0] (< i (count keyConstants))
                    (let [
                        sum (+ sum (max BinaryStrategy'MIN_PROBABILITY (nth keyProbabilities i)))
                    ]
                        (aset (:probabilitySums this) (inc i) sum)
                        (recur sum (inc i))
                    )
                )
        ]
            this
        )
    )

    ;;;
     ; Recursively generate a list of comparisons that always subdivides the keys in the given
     ; (inclusive) range in the middle (in terms of probability, not index). If left is bigger
     ; than zero, then we always know that the value is equal to or bigger than the left key.
     ; This does not hold for the right key, as there may be a gap afterwards.
     ;;
    (defn- #_"void" BinaryStrategy''recurseBinarySwitch-5 [#_"BinaryStrategy" this, #_"SwitchClosure" closure, #_"int" left, #_"int" right, #_"int" depth]
        (let [
            #_"boolean" leftBorder (zero? left)
            #_"boolean" rightBorder (= right (dec (count (:keyConstants this))))
        ]
            (if (= (inc left) right)
                ;; only two possible values
                (if (or leftBorder rightBorder (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) right))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc right)))) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) left))) (#_"JavaConstant" .asLong (nth (:keyConstants this) right))))
                    (do
                        (SwitchClosure'''conditionalJump-4 closure, left, Condition'EQ, false)
                        (ยง ass depth (inc depth))
                        (SwitchStrategy''registerEffort-4 this, left, left, depth)
                        (SwitchClosure'''conditionalJumpOrDefault-4 closure, right, Condition'EQ, rightBorder)
                        (ยง ass depth (inc depth))
                        (SwitchStrategy''registerEffort-4 this, right, right, depth)
                        (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                    )
                    (do
                        ;; here we know that the value can only be one of these two keys in the range
                        (SwitchClosure'''conditionalJump-4 closure, left, Condition'EQ, false)
                        (ยง ass depth (inc depth))
                        (SwitchStrategy''registerEffort-4 this, left, left, depth)
                        (SwitchClosure'''conditionalJump-4 closure, right, nil, false)
                        (SwitchStrategy''registerEffort-4 this, right, right, depth)
                    )
                )
                (let [
                    #_"double" probabilityStart (nth (:probabilitySums this) left)
                    #_"double" probabilityMiddle (/ (+ probabilityStart (nth (:probabilitySums this) (inc right))) 2)
                    #_"int" middle
                        (loop [middle left]
                            (let [#_"int" end (PrimitiveStrategy''getSliceEnd-3 this, closure, (inc middle))]
                                (recur-if (and (< end right) (< (nth (:probabilitySums this) end) probabilityMiddle))
                                        [end]
                                    => (PrimitiveStrategy''getSliceEnd-3 this, closure, middle)
                                )
                            )
                        )
                ]
                    (cond
                        (= (PrimitiveStrategy''getSliceEnd-3 this, closure, left) middle)
                            (do
                                (when (zero? left)
                                    (SwitchClosure'''conditionalJump-4 closure, 0, Condition'LT, true)
                                    (ยง ass depth (inc depth))
                                    (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                )
                                (SwitchClosure'''conditionalJump-4 closure, middle, Condition'LE, false)
                                (ยง ass depth (inc depth))
                                (SwitchStrategy''registerEffort-4 this, left, middle, depth)

                                (if (= (inc middle) right)
                                    (do
                                        (SwitchClosure'''conditionalJumpOrDefault-4 closure, right, Condition'EQ, rightBorder)
                                        (ยง ass depth (inc depth))
                                        (SwitchStrategy''registerEffort-4 this, right, right, depth)
                                        (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                    )
                                    (do
                                        (when-not (= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) middle))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc middle))))
                                            (SwitchClosure'''conditionalJump-4 closure, (inc middle), Condition'LT, true)
                                            (ยง ass depth (inc depth))
                                            (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                        )
                                        (if (= (PrimitiveStrategy''getSliceEnd-3 this, closure, (inc middle)) right)
                                            (if (or (= right (dec (count (:keyConstants this)))) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) right))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc right)))))
                                                (do
                                                    (SwitchClosure'''conditionalJumpOrDefault-4 closure, right, Condition'LE, rightBorder)
                                                    (ยง ass depth (inc depth))
                                                    (SwitchStrategy''registerEffort-4 this, (inc middle), right, depth)
                                                    (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                                )
                                                (do
                                                    (SwitchClosure'''conditionalJump-4 closure, (inc middle), nil, false)
                                                    (SwitchStrategy''registerEffort-4 this, (inc middle), right, depth)
                                                )
                                            )
                                            (BinaryStrategy''recurseBinarySwitch-5 this, closure, (inc middle), right, depth)
                                        )
                                    )
                                )
                            )
                        (= (PrimitiveStrategy''getSliceEnd-3 this, closure, (inc middle)) right)
                            (do
                                (when (or rightBorder (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) right))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc right)))))
                                    (SwitchClosure'''conditionalJump-4 closure, right, Condition'GT, true)
                                    (ยง ass depth (inc depth))
                                    (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                )
                                (SwitchClosure'''conditionalJump-4 closure, (inc middle), Condition'GE, false)
                                (ยง ass depth (inc depth))
                                (SwitchStrategy''registerEffort-4 this, (inc middle), right, depth)
                                (BinaryStrategy''recurseBinarySwitch-5 this, closure, left, middle, depth)
                            )
                        :else
                            (let [
                                #_"Label" label (SwitchClosure'''conditionalJump-3 closure, (inc middle), Condition'GE)
                            ]
                                (ยง ass depth (inc depth))
                                (BinaryStrategy''recurseBinarySwitch-5 this, closure, left, middle, depth)
                                (SwitchClosure'''bind-2 closure, label)
                                (BinaryStrategy''recurseBinarySwitch-5 this, closure, (inc middle), right, depth)
                            )
                    )
                )
            )
        )
        nil
    )

    (defm BinaryStrategy SwitchStrategy
        (#_"void" SwitchStrategy'''run-2 [#_"BinaryStrategy" this, #_"SwitchClosure" closure]
            (BinaryStrategy''recurseBinarySwitch-5 this, closure, 0, (dec (count (:keyConstants this))), 0)
            nil
        )
    )
)

;;;
 ; This strategy divides the keys into ranges of successive keys with the same target and
 ; creates comparisons for these ranges.
 ;;
(class-ns RangesStrategy [PrimitiveStrategy, SwitchStrategy]
    (defn #_"RangesStrategy" RangesStrategy'new-2 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants]
        (let [
            #_"RangesStrategy" this
                (merge (RangesStrategy'class.) (PrimitiveStrategy'new-2 keyProbabilities, keyConstants)
                    (hash-map
                        #_"Integer[]" :indexes (let [#_"int" n (count keyConstants) a (make-array Integer n) _ (dotimes [#_"int" i n] (aset a i i))] a)
                    )
                )
            _
                (Arrays/sort (:indexes this),
                    (reify Comparator #_"<Integer>"
                        (#_"int" compare [#_"Comparator<Integer>" this, #_"Integer" i1, #_"Integer" i2]
                            (cond (< (nth keyProbabilities i1) (nth keyProbabilities i2)) 1 (> (nth keyProbabilities i1) (nth keyProbabilities i2)) -1 :else 0)
                        )
                    )
                )
        ]
            this
        )
    )

    (defm RangesStrategy SwitchStrategy
        (#_"void" SwitchStrategy'''run-2 [#_"RangesStrategy" this, #_"SwitchClosure" closure]
            (let [
                #_"int'" v'depth (volatile! 0)
            ]
                (SwitchClosure'''conditionalJump-4 closure, 0, Condition'LT, true)
                (vswap! v'depth inc)
                (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, @v'depth))
                (let [
                    [#_"int" start #_"int" end]
                        (loop-when [start 0 end (PrimitiveStrategy''getSliceEnd-3 this, closure, start)] (not= end (dec (count (:keyConstants this)))) => [start end]
                            (if (= start end)
                                (do
                                    (SwitchClosure'''conditionalJump-4 closure, start, Condition'EQ, false)
                                    (vswap! v'depth inc)
                                    (SwitchStrategy''registerEffort-4 this, start, end, @v'depth)
                                )
                                (do
                                    (when (or (zero? start) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) (dec start)))) (#_"JavaConstant" .asLong (nth (:keyConstants this) start))))
                                        (SwitchClosure'''conditionalJump-4 closure, start, Condition'LT, true)
                                        (vswap! v'depth inc)
                                        (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, @v'depth))
                                    )
                                    (SwitchClosure'''conditionalJump-4 closure, end, Condition'LE, false)
                                    (vswap! v'depth inc)
                                    (SwitchStrategy''registerEffort-4 this, start, end, @v'depth)
                                )
                            )
                            (let [
                                start (inc end)
                            ]
                                (recur start (PrimitiveStrategy''getSliceEnd-3 this, closure, start))
                            )
                        )
                ]
                    (if (= start end)
                        (do
                            (SwitchClosure'''conditionalJumpOrDefault-4 closure, start, Condition'EQ, true)
                            (vswap! v'depth inc)
                            (SwitchStrategy''registerEffort-4 this, start, end, @v'depth)
                            (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, @v'depth))
                        )
                        (do
                            (when (or (zero? start) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) (dec start)))) (#_"JavaConstant" .asLong (nth (:keyConstants this) start))))
                                (SwitchClosure'''conditionalJump-4 closure, start, Condition'LT, true)
                                (vswap! v'depth inc)
                                (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, @v'depth))
                            )
                            (SwitchClosure'''conditionalJumpOrDefault-4 closure, end, Condition'LE, true)
                            (vswap! v'depth inc)
                            (SwitchStrategy''registerEffort-4 this, start, end, @v'depth)
                            (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, @v'depth))
                        )
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; This strategy orders the keys according to their probability and creates one equality comparison per key.
 ;;
(class-ns SequentialStrategy [SwitchStrategy]
    (defn #_"SequentialStrategy" SequentialStrategy'new-2 [#_"double[]" keyProbabilities, #_"Constant[]" keyConstants]
        (let [
            #_"SequentialStrategy" this
                (merge (SequentialStrategy'class.) (SwitchStrategy'new-1 keyProbabilities)
                    (hash-map
                        #_"Integer[]" :indexes (let [#_"int" n (count keyConstants) a (make-array Integer n) _ (dotimes [#_"int" i n] (aset a i i))] a)
                        #_"Constant[]" :keyConstants keyConstants
                    )
                )
            _
                (Arrays/sort (:indexes this),
                    (reify Comparator #_"<Integer>"
                        (#_"int" compare [#_"Comparator<Integer>" this, #_"Integer" i1, #_"Integer" i2]
                            (cond (< (nth keyProbabilities i1) (nth keyProbabilities i2)) 1 (> (nth keyProbabilities i1) (nth keyProbabilities i2)) -1 :else 0)
                        )
                    )
                )
        ]
            this
        )
    )

    (defm SequentialStrategy SwitchStrategy
        (#_"void" SwitchStrategy'''run-2 [#_"SequentialStrategy" this, #_"SwitchClosure" closure]
            (dotimes [#_"int" i (dec (count (:keyConstants this)))]
                (SwitchClosure'''conditionalJump-4 closure, (nth (:indexes this) i), Condition'EQ, false)
                (SwitchStrategy''registerEffort-4 this, (nth (:indexes this) i), (nth (:indexes this) i), (inc i))
            )
            (SwitchClosure'''conditionalJumpOrDefault-4 closure, (nth (:indexes this) (dec (count (:keyConstants this)))), Condition'EQ, true)
            (SwitchStrategy''registerEffort-4 this, (nth (:indexes this) (dec (count (:keyConstants this)))), (nth (:indexes this) (dec (count (:keyConstants this)))), (count (:keyConstants this)))
            (ยง ass! this (SwitchStrategy''registerDefaultEffort-2 this, (count (:keyConstants this))))
            nil
        )
    )
)

(class-ns Tool [SimplifierTool, CanonicalizerTool]
    (defn #_"Tool" Tool'new-1 [#_"CanonicalizerInstance" instance]
        (merge (Tool'class.)
            (hash-map
                #_"CanonicalizerInstance" :instance instance
            )
        )
    )

    (defm Tool SimplifierTool
        (#_"void" SimplifierTool'''deleteBranch-2 [#_"Tool" this, #_"Node" branch]
            (Node''replaceFirstSuccessor-3 (:predecessor branch), branch, nil)
            (GraphUtil'killCFG-1 branch)
            nil
        )

        (#_"void" SimplifierTool'''addToWorkList-2n [#_"Tool" this, #_"Node" node]
            (NodeWorkList'''add-2 (:workList (:instance this)), node)
            nil
        )

        (#_"void" SimplifierTool'''addToWorkList-2s [#_"Tool" this, #_"Node*" nodes]
            (NodeWorkList''addAll-2 (:workList (:instance this)), nodes)
            nil
        )

        (#_"void" SimplifierTool'''removeIfUnused-2 [#_"Tool" this, #_"Node" node]
            (GraphUtil'tryKillUnused-1 node)
            nil
        )
    )

    (defm Tool CanonicalizerTool
        (#_"boolean" CanonicalizerTool'''canonicalizeReads-1 [#_"Tool" this]
            true
        )

        (#_"boolean" CanonicalizerTool'''allUsagesAvailable-1 [#_"Tool" this]
            true
        )

        (#_"Integer" CanonicalizerTool'''smallestCompareWidth-1 [#_"Tool" this]
            (Lowerer'smallestCompareWidth-0)
        )
    )
)

;;;
 ; This class represents a reference to a Java type and whether this reference is referring only
 ; to the represented type or also to its sub types in the class hierarchy. When creating a type
 ; reference, the following options have to be considered:
 ;
 ; (1) The reference should always only refer to the given concrete type. Use
 ; #createExactTrusted(ResolvedJavaType) for this purpose.
 ;
 ; (2) The reference should be created without assumptions about the class hierarchy. The returned
 ; reference is exact only when the type is a leaf type (i.e. it cannot have subclasses). Depending
 ; on whether interface types can be trusted for this type reference use
 ; #createWithoutAssumptions or #createTrustedWithoutAssumptions.
 ;
 ; (3) The reference should be created using assumptions about the class hierarchy. The returned
 ; reference is also exact, when there is only a single concrete sub type for the given type.
 ; Depending on whether interface types can be trusted for this type reference use #create
 ; or #createTrusted.
 ;
 ; For the methods with untrusted interface types, a nil reference will be constructed for
 ; untrusted interface types. Examples for interface types that cannot be trusted are types for
 ; parameters, fields, and return values. They are not checked by the Java verifier.
 ;;
(class-ns TypeReference []
    (defn- #_"TypeReference" TypeReference'new-2 [#_"ResolvedJavaType" type, #_"boolean" exactReference]
        (merge (TypeReference'class.)
            (hash-map
                ;;;
                 ; The type this reference refers to.
                 ;;
                #_"ResolvedJavaType" :type type
                ;;;
                 ; true if this reference is exact = only refers to the given type,
                 ; false if it also refers to its sub-types
                 ;;
                #_"boolean" :exactReference exactReference
            )
        )
    )

    ;;;
     ; Creates an exact type reference using the given type.
     ;;
    (defn #_"TypeReference" TypeReference'createExactTrusted-1 [#_"ResolvedJavaType" type]
        (when (some? type) (TypeReference'new-2 type, true))
    )

    (defn- #_"ResolvedJavaType" TypeReference'filterInterfaceTypesOut-1 [#_"ResolvedJavaType" type]
        (when (some? type)
            (if (#_"ResolvedJavaType" .isArray type)
                (let [
                    #_"ResolvedJavaType" componentType (TypeReference'filterInterfaceTypesOut-1 (#_"ResolvedJavaType" .getComponentType type))
                ]
                    (#_"ResolvedJavaType" .getArrayClass (or componentType (#_"ResolvedJavaType" .getSuperclass type))) ;; returns Object[].class
                )
                (when-not (#_"ResolvedJavaType" .isInterface type)
                    type
                )
            )
        )
    )

    ;;;
     ; Creates a type reference using the given type without trusting interface types.
     ;;
    (defn #_"TypeReference" TypeReference'create-1 [#_"ResolvedJavaType" type]
        (TypeReference'createTrusted-1 (TypeReference'filterInterfaceTypesOut-1 type))
    )

    ;;;
     ; Creates a type reference using the given type with trusting interface types.
     ;;
    (defn #_"TypeReference" TypeReference'createTrusted-1 [#_"ResolvedJavaType" type]
        (when (some? type)
            (let [
                #_"ResolvedJavaType" exact (when (#_"ResolvedJavaType" .isLeaf type) type)
            ]
                (if (some? exact) (TypeReference'new-2 exact, true) (TypeReference'new-2 type, false))
            )
        )
    )

    ;;;
     ; @return a new reference that is guaranteed to be exact
     ;;
    #_unused
    (defn #_"TypeReference" TypeReference''asExactReference-1 [#_"TypeReference" this]
        (if (:exactReference this) this (TypeReference'new-2 (:type this), true))
    )
)

(class-ns UnsignedLong []
    (defn #_"UnsignedLong" UnsignedLong'new-1 [#_"long" value]
        (merge (UnsignedLong'class.)
            (hash-map
                #_"long" :value value
            )
        )
    )

    (defn #_"long" UnsignedLong''asLong-1 [#_"UnsignedLong" this]
        (:value this)
    )

    (defn #_"boolean" UnsignedLong''equals-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (= (:value this) unsignedValue)
    )

    (defn #_"boolean" UnsignedLong''isLessThan-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (< (Long/compareUnsigned (:value this), unsignedValue) 0)
    )

    (defn #_"boolean" UnsignedLong''isLessOrEqualTo-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (<= (Long/compareUnsigned (:value this), unsignedValue) 0)
    )

    (defn #_"UnsignedLong" UnsignedLong''times-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (when (and (not (zero? unsignedValue)) (pos? (Long/compareUnsigned (:value this), (Long/divideUnsigned 0xffffffffffffffff, unsignedValue))))
            (throw (ArithmeticException.))
        )
        (UnsignedLong'new-1 (* (:value this) unsignedValue))
    )

    (defn #_"UnsignedLong" UnsignedLong''minus-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (when (neg? (Long/compareUnsigned (:value this), unsignedValue))
            (throw (ArithmeticException.))
        )
        (UnsignedLong'new-1 (- (:value this) unsignedValue))
    )

    #_unused
    (defn #_"UnsignedLong" UnsignedLong''plus-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (when (neg? (Long/compareUnsigned (- 0xffffffffffffffff unsignedValue), (:value this)))
            (throw (ArithmeticException.))
        )
        (UnsignedLong'new-1 (+ (:value this) unsignedValue))
    )

    (defn #_"UnsignedLong" UnsignedLong''wrappingPlus-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (UnsignedLong'new-1 (+ (:value this) unsignedValue))
    )

    (defn #_"UnsignedLong" UnsignedLong''wrappingTimes-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (UnsignedLong'new-1 (* (:value this) unsignedValue))
    )
)

;;;
 ; Represents a usage of a constant.
 ;;
(class-ns UseEntry []
    (defn #_"UseEntry" UseEntry'new-3 [#_"Block" block, #_"LIRInstruction" instruction, #_"Value" value]
        (merge (UseEntry'class.)
            (hash-map
                #_"Block" :block block
                #_"LIRInstruction" :instruction instruction
                #_"Value" :value value
            )
        )
    )

    (defn- #_"void" UseEntry'replaceValue-3 [#_"LIRInstruction" op, #_"Value" oldValue, #_"Value" newValue]
        (let [
            #_"ValueProcedure" proc
                (reify ValueProcedure
                    (#_"Value" ValueProcedure'''doValue-5 [#_"ValueProcedure" _this, #_"LIRInstruction" _op, #_"Value" value, #_"OperandMode" _mode, #_"{OperandFlag}" _flags]
                        (if (= value oldValue) newValue value)
                    )
                )
        ]
            (LIRInstruction''forEachAlive-2 op, proc)
            (LIRInstruction''forEachInput-2 op, proc)
            (LIRInstruction''forEachOutput-2 op, proc)
            (LIRInstruction''forEachTemp-2 op, proc)
        )
        nil
    )

    (defn #_"void" UseEntry''setValue-2 [#_"UseEntry" this, #_"Value" newValue]
        (UseEntry'replaceValue-3 (:instruction this), (:value this), newValue)
        nil
    )
)

;;;
 ; List of use positions. Each entry in the list records the use position and register priority
 ; associated with the use position. The entries in the list are in descending order of use position.
 ;;
(class-ns UsePosList []
    (defn- #_"UsePosList" UsePosList'new-1l [#_"IntList" list]
        (merge (UsePosList'class.)
            (hash-map
                #_"IntList" :list list
            )
        )
    )

    ;;;
     ; Creates a use list.
     ;
     ; @param capacity the initial capacity of the list in terms of entries
     ;;
    (defn #_"UsePosList" UsePosList'new-1i [#_"int" capacity]
        (UsePosList'new-1l (IntList'new-1 (* capacity 2)))
    )

    ;;;
     ; Splits this list around a given position. All entries in this list with a use position
     ; greater or equal than {@code at} are removed from this list and added to the returned list.
     ;
     ; @param at the position for the split
     ; @return a use position list containing all entries removed from this list that have a use
     ;         position greater or equal than {@code at}
     ;;
    (defn #_"UsePosList" UsePosList''splitAt-2 [#_"UsePosList" this, #_"int" at]
        (let [
            [#_"int" i #_"int" n]
                (loop-when-recur [i (dec (UsePosList''size-1 this)) n 0]
                                 (and (<= 0 i) (< (UsePosList''usePos-2 this, i) at))
                                 [(dec i) (+ n 2)]
                              => [(<< (inc i) 1) n]
                )
            #_"IntList" list (:list this)
        ]
            (ยง ass! this (assoc this :list (IntList'copy-3 (:list this), i, n)))
            (ยง ass! list (IntList''setSize-2 list, i))
            (UsePosList'new-1l list)
        )
    )

    ;;;
     ; Gets the use position at a specified index in this list.
     ;
     ; @param index the index of the entry for which the use position is returned
     ; @return the use position of entry {@code index} in this list
     ;;
    (defn #_"int" UsePosList''usePos-2 [#_"UsePosList" this, #_"int" index]
        (IntList''get-2 (:list this), (<< index 1))
    )

    ;;;
     ; Gets the register priority for the use position at a specified index in this list.
     ;
     ; @param index the index of the entry for which the register priority is returned
     ; @return the register priority of entry {@code index} in this list
     ;;
    (defn #_"RegisterPriority" UsePosList''registerPriority-2 [#_"UsePosList" this, #_"int" index]
        (nth RegisterPriority'VALUES (IntList''get-2 (:list this), (inc (<< index 1))))
    )

    (defn #_"void" UsePosList''add-3 [#_"UsePosList" this, #_"int" usePos, #_"RegisterPriority" registerPriority]
        (ยง ass! (:list this) (IntList''add-2 (:list this), usePos))
        (ยง ass! (:list this) (IntList''add-2 (:list this), (RegisterPriority''ordinal-1 registerPriority)))
        nil
    )

    (defn #_"int" UsePosList''size-1 [#_"UsePosList" this]
        (>> (:size (:list this)) 1)
    )

    (defn #_"void" UsePosList''removeLowestUsePos-1 [#_"UsePosList" this]
        (ยง ass! (:list this) (IntList''setSize-2 (:list this), (- (:size (:list this)) 2)))
        nil
    )

    (defn #_"void" UsePosList''setRegisterPriority-3 [#_"UsePosList" this, #_"int" index, #_"RegisterPriority" registerPriority]
        (IntList''set-3 (:list this), (inc (<< index 1)), (RegisterPriority''ordinal-1 registerPriority))
        nil
    )
)

(class-ns UseTrappingNullChecksPhase [Phase]
    (defn #_"UseTrappingNullChecksPhase" UseTrappingNullChecksPhase'new-0 []
        (UseTrappingNullChecksPhase'class.)
    )

    (defn- #_"void" UseTrappingNullChecksPhase'replaceWithTrappingNullCheck-5 [#_"AbstractDeoptimizeNode" deopt, #_"IfNode" ifNode, #_"LogicNode" logic, #_"DeoptimizationReason" deoptimizationReason, #_"long" implicitNullCheckLimit]
        (let [
            #_"AbstractBeginNode" nonTrappingContinuation (:falseSuccessor ifNode)
            #_"AbstractBeginNode" trappingContinuation (:trueSuccessor ifNode)
            #_"FixedNode" nextNonTrapping (:next nonTrappingContinuation)
            #_"ValueNode" value (Unary'''getValue-1 logic)
            #_"DeoptimizingFixedWithNextNode" trappingNullCheck
                (when (and GraalOptions'optImplicitNullChecks (pos? implicitNullCheckLimit) (satisfies? FixedAccessNode nextNonTrapping) (Access'''canNullCheck-1 nextNonTrapping))
                    (let [
                        #_"AddressNode" address (Access'''getAddress-1 nextNonTrapping)
                        #_"ValueNode" base (AddressNode'''getBase-1 address)
                        #_"ValueNode" index (AddressNode'''getIndex-1 address)
                        ;; allow for architectures which cannot fold an intervening uncompress out of the address chain
                        base (if (and (some? base) (satisfies? CompressionNode base)) (Unary'''getValue-1 base) base)
                        index (if (and (some? index) (satisfies? CompressionNode index)) (Unary'''getValue-1 index) index)
                    ]
                        (when (and (or (and (= base value) (nil? index)) (and (nil? base) (= index value))) (< (AddressNode'''getMaxConstantDisplacement-1 address) implicitNullCheckLimit))
                            ;; Opportunity for implicit nil-check as part of an existing read found!
                            (DeoptBefore'''setStateBefore-2 nextNonTrapping, (:stateBefore deopt))
                            (ยง ass! nextNonTrapping (FixedAccessNode''setNullCheck-2 nextNonTrapping, true))
                            (Graph''removeSplit-3 (:graph deopt), ifNode, nonTrappingContinuation)
                            nextNonTrapping
                        )
                    )
                )
            trappingNullCheck
                (or trappingNullCheck
                    ;; Need to add a nil-check node.
                    (let [
                        trappingNullCheck (Graph''add-2 (:graph deopt), (NullCheckNode'new-1 value))
                    ]
                        (Graph''replaceSplit-4 (:graph deopt), ifNode, trappingNullCheck, nonTrappingContinuation)
                        trappingNullCheck
                    )
                )
        ]
            (DeoptBefore'''setStateBefore-2 trappingNullCheck, (:stateBefore deopt))

            ;; We now have the pattern NullCheck/BeginNode/... It's possible some node is using the
            ;; BeginNode as a guard input, so replace guard users of the Begin with the NullCheck and
            ;; then remove the Begin from the graph.
            (Node''replaceAtUsages-3 nonTrappingContinuation, InputType'Guard, trappingNullCheck)

            (when (satisfies? BeginNode nonTrappingContinuation)
                (GraphUtil'unlinkFixedNode-1 nonTrappingContinuation)
                (Node''safeDelete-1 nonTrappingContinuation)
            )

            (GraphUtil'killCFG-1 trappingContinuation)
            (GraphUtil'tryKillUnused-1 logic)
        )
        nil
    )

    (defn- #_"void" UseTrappingNullChecksPhase'checkPredecessor-4 [#_"AbstractDeoptimizeNode" deopt, #_"Node" predecessor, #_"DeoptimizationReason" deoptimizationReason, #_"long" implicitNullCheckLimit]
        (let [
            [#_"Node" node #_"AbstractBeginNode" branch]
                (loop-when [node predecessor branch nil] (satisfies? AbstractBeginNode node) => [node branch]
                    (if (seq (AbstractBeginNode'''anchored-1 node))
                        nil ;; some input of the deopt framestate is anchored to this branch
                        (recur (:predecessor node) node)
                    )
                )
        ]
            (when (and (satisfies? IfNode node) (= branch (:trueSuccessor node)) (satisfies? IsNullNode (:logic node)))
                (UseTrappingNullChecksPhase'replaceWithTrappingNullCheck-5 deopt, node, (:logic node), deoptimizationReason, implicitNullCheckLimit)
            )
        )
        nil
    )

    (defn- #_"void" UseTrappingNullChecksPhase'tryUseTrappingNullCheck-5 [#_"AbstractDeoptimizeNode" deopt, #_"Node" predecessor, #_"DeoptimizationReason" deoptimizationReason, #_"JavaConstant" speculation, #_"long" implicitNullCheckLimit]
        (when (and (any = deoptimizationReason DeoptimizationReason/NullCheckException DeoptimizationReason/UnreachedCode)
                   (or (nil? speculation) (= speculation JavaConstant/NULL_POINTER))
              )
            (condp satisfies? predecessor
                AbstractMergeNode
                    (when (empty? (AbstractMergeNode''phis-1 predecessor))
                        (doseq [#_"AbstractEndNode" end (ยง snap (Node'''cfgPredecessors-1 predecessor))]
                            (UseTrappingNullChecksPhase'checkPredecessor-4 deopt, (:predecessor end), deoptimizationReason, implicitNullCheckLimit)
                        )
                    )
                AbstractBeginNode
                    (UseTrappingNullChecksPhase'checkPredecessor-4 deopt, predecessor, deoptimizationReason, implicitNullCheckLimit)
                nil
            )
        )
        nil
    )

    (defn- #_"void" UseTrappingNullChecksPhase'tryUseTrappingNullCheck-2 [#_"DynamicDeoptimizeNode" deopt, #_"long" implicitNullCheckLimit]
        (let [
            #_"Node" predecessor (:predecessor deopt)
        ]
            (when (satisfies? AbstractMergeNode predecessor)
                (let [
                    #_"AbstractMergeNode" merge predecessor
                    ;; Process each predecessor at the merge, unpacking the reasons and speculations as needed.
                    #_"ValueNode" reason (:actionAndReason deopt)
                    [#_"List<ValueNode>" reasons #_"int" expectedPhis]
                        (condp satisfies? reason
                            ValuePhiNode
                                (if (= (:merge reason) merge)
                                    [(ยง snap (:values reason)) 1]
                                    (ยง return )
                                )
                            ConstantNode
                                [nil 0]
                            (ยง return )
                        )
                ]
                    (let [
                        #_"ValueNode" speculation (:speculation deopt)
                        [#_"List<ValueNode>" speculations expectedPhis]
                            (when (satisfies? ValuePhiNode speculation) => [nil expectedPhis]
                                (if-not (= (:merge speculation) merge)
                                    (ยง return )
                                    [(ยง snap (:values speculation)) (inc expectedPhis)]
                                )
                            )
                    ]
                        (when (= (count (AbstractMergeNode''phis-1 merge)) expectedPhis)
                            (loop-when [#_"int" i 0 #_"ISeq" s (seq (ยง snap (Node'''cfgPredecessors-1 merge)))] (some? s)
                                (let [
                                    #_"AbstractEndNode" end (first s)
                                    #_"ValueNode" thisReason (if (some? reasons) (nth reasons i) reason)
                                    #_"ValueNode" thisSpeculation (if (some? speculations) (nth speculations i) speculation)
                                    i (if (some? speculations) (inc i) i)
                                ]
                                    (when (and (satisfies? ConstantNode thisReason) (satisfies? ConstantNode thisSpeculation) (= (:value thisSpeculation) JavaConstant/NULL_POINTER))
                                        (UseTrappingNullChecksPhase'tryUseTrappingNullCheck-5 deopt, (:predecessor end), (#_"MetaAccessProvider" .decodeDeoptReason HotSpot'metaAccess, (ValueNode''asJavaConstant-1 thisReason)), nil, implicitNullCheckLimit)
                                    )
                                    (recur i (next s))
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defm UseTrappingNullChecksPhase Phase
        (#_"Graph" Phase'''run-3 [#_"UseTrappingNullChecksPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (when-not (or (not GraalOptions'useTrappingNullChecks) (<= (.implicitNullCheckLimit HotSpot'target) 0))
                (let [
                    #_"long" implicitNullCheckLimit (.implicitNullCheckLimit HotSpot'target)
                ]
                    (doseq [#_"DeoptimizeNode" deopt (Graph''getNodes-2 graph, DeoptimizeNode)]
                        (UseTrappingNullChecksPhase'tryUseTrappingNullCheck-5 deopt, (:predecessor deopt), (:reason deopt), (:speculation deopt), implicitNullCheckLimit)
                    )
                    (doseq [#_"DynamicDeoptimizeNode" deopt (Graph''getNodes-2 graph, DynamicDeoptimizeNode)]
                        (UseTrappingNullChecksPhase'tryUseTrappingNullCheck-2 deopt, implicitNullCheckLimit)
                    )
                )
            )
            graph
        )
    )
)

(class-ns CompositeValue [#_"Value"]
    (defn #_"CompositeValue" CompositeValue'new-1 [#_"ValueKind" kind]
        (merge (CompositeValue'class.) (ร Value. kind))
    )
)

(class-ns AMD64AddressValue [CompositeValue, #_"Value"]
    (def- #_"{OperandFlag}" AMD64AddressValue'flags #{ OperandFlag'REG OperandFlag'ILLEGAL })

    (defn #_"AMD64AddressValue" AMD64AddressValue'new-3 [#_"ValueKind" kind, #_"AllocatableValue" base, #_"int" displacement]
        (AMD64AddressValue'new-5 kind, base, Value/ILLEGAL, Scale'Times1, displacement)
    )

    (defn #_"AMD64AddressValue" AMD64AddressValue'new-5 [#_"ValueKind" kind, #_"AllocatableValue" base, #_"AllocatableValue" index, #_"Scale" scale, #_"int" displacement]
        (merge (AMD64AddressValue'class.) (CompositeValue'new-1 kind)
            (hash-map
                #_"AllocatableValue" :base base
                #_"AllocatableValue" :index index
                #_"Scale" :scale scale
                #_"int" :displacement displacement
            )
        )
    )

    (defm AMD64AddressValue CompositeValue
        (#_"CompositeValue" CompositeValue'''forEachComponent-4 [#_"AMD64AddressValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"ValueProcedure" proc]
            (let [
                #_"AllocatableValue" base (ValueProcedure'''doValue-5 proc, op, (:base this), mode, AMD64AddressValue'flags)
                #_"AllocatableValue" index (ValueProcedure'''doValue-5 proc, op, (:index this), mode, AMD64AddressValue'flags)
            ]
                (if (and (= (:base this) base) (= (:index this) index))
                    this
                    (AMD64AddressValue'new-5 (#_"Value" .getValueKind this), base, index, (:scale this), (:displacement this))
                )
            )
        )

        (#_"void" CompositeValue'''visitEachComponent-4 [#_"AMD64AddressValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"ValueConsumer" proc]
            (ValueConsumer'''visitValue-5 proc, op, (:base this), mode, AMD64AddressValue'flags)
            (ValueConsumer'''visitValue-5 proc, op, (:index this), mode, AMD64AddressValue'flags)
            nil
        )
    )

    (defn- #_"Register" AMD64AddressValue'toRegister-1 [#_"AllocatableValue" value]
        (if (= value Value/ILLEGAL) Register/None (#_"RegisterValue" .getRegister value))
    )

    (defn #_"AMD64Address" AMD64AddressValue''toAddress-1 [#_"AMD64AddressValue" this]
        (AMD64Address'new-4 (AMD64AddressValue'toRegister-1 (:base this)), (AMD64AddressValue'toRegister-1 (:index this)), (:scale this), (:displacement this))
    )

    (defn #_"boolean" AMD64AddressValue''isValidImplicitNullCheckFor-3 [#_"AMD64AddressValue" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (and (= value (:base this)) (= (:index this) Value/ILLEGAL) (< -1 (:displacement this) implicitNullCheckLimit))
    )
)

;;;
 ; Represents an inlined Constant value.
 ;;
(class-ns ConstantValue [#_"Value"]
    (defn #_"ConstantValue" ConstantValue'new-2 [#_"ValueKind" kind, #_"Constant" constant]
        (merge (ConstantValue'class.) (ร Value. kind)
            (hash-map
                #_"Constant" :constant constant
            )
        )
    )
)

;;;
 ; Represents the type of values in the LIR. It is composed of a PlatformKind that gives the
 ; low level representation of the value, a #referenceMask that describes the location of
 ; object references in the value, a #referenceCompressionMask that indicates which of these
 ; references are compressed references, and for derived references a #derivedReferenceBase.
 ;
 ; Constructing LIRKind instances
 ;
 ; During LIR generation, every new Value should get a LIRKind of the correct
 ; PlatformKind that also contains the correct reference information. {@linkplain LIRKind
 ; LIRKinds} should be created as follows:
 ;
 ; If the result value is created from one or more input values, the LIRKind should be
 ; created with LIRKind#combine(inputs). If the result has a different PlatformKind
 ; than the inputs, LIRKind#combine(inputs).#changeType(resultKind) should be used.
 ;
 ; If the result is an exact copy of one of the inputs, Value#getValueKind() can be used.
 ; Note that this is only correct for move-like operations, like conditional move or
 ; compare-and-swap. For convert operations, LIRKind#combine should be used.
 ;
 ; If it is known that the result will be a reference (e.g. pointer arithmetic where the end result
 ; is a valid oop), #reference or LIRKind#compressedReference should be used.
 ;
 ; If it is known that the result will neither be a reference nor be derived from a reference,
 ; LIRKind#value can be used. If the operation producing this value has inputs, this is very
 ; likely wrong, and LIRKind#combine should be used instead.
 ;
 ; If it is known that the result is derived from a reference in a way that the garbage collector
 ; can not track, LIRKind#unknownReference can be used. In most cases,
 ; LIRKind#combine should be used instead, since it is able to detect this automatically.
 ;;
(class-ns LIRKind [#_"ValueKind" #_"<LIRKind>"]
    (def- #_"int" LIRKind'UNKNOWN_REFERENCE -1)

    (ยง def #_"LIRKind" LIRKind'Illegal (LIRKind'unknownReference-1 (#_"ValueKind" .getPlatformKind ValueKind/Illegal)))

    (defn- #_"LIRKind" LIRKind'new-4 [#_"PlatformKind" platformKind, #_"int" referenceMask, #_"int" referenceCompressionMask, #_"AllocatableValue" derivedReferenceBase]
        (merge (LIRKind'class.) (ValueKind. platformKind)
            (hash-map
                ;;;
                 ; The location of object references in the value. If the value is a vector type, each bit
                 ; represents one component of the vector.
                 ;;
                #_"int" :referenceMask referenceMask
                ;;;
                 ; Mask with 1-bits indicating which references in #referenceMask are compressed.
                 ;;
                #_"int" :referenceCompressionMask referenceCompressionMask
                ;;;
                 ; Base value of a derived reference.
                 ;;
                #_"AllocatableValue" :derivedReferenceBase derivedReferenceBase
            )
        )
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a primitive value.
     ; Should be only used when it's guaranteed that the value is not even indirectly derived
     ; from a reference. Otherwise, #combine(Value...) should be used instead.
     ;;
    (defn #_"LIRKind" LIRKind'value-1 [#_"PlatformKind" platformKind]
        (LIRKind'new-4 platformKind, 0, 0, nil)
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a single, tracked,
     ; uncompressed oop reference.
     ;;
    (defn #_"LIRKind" LIRKind'reference-1 [#_"PlatformKind" platformKind]
        (LIRKind'derivedReference-3 platformKind, nil, false)
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a single, tracked,
     ; compressed oop reference.
     ;;
    (defn #_"LIRKind" LIRKind'compressedReference-1 [#_"PlatformKind" platformKind]
        (LIRKind'derivedReference-3 platformKind, nil, true)
    )

    ;;;
     ; Create the correct LIRKind for a given Architecture and JavaKind.
     ;;
    (defn #_"LIRKind" LIRKind'fromJavaKind-2 [#_"Architecture" arch, #_"JavaKind" javaKind]
        (let [
            #_"PlatformKind" platformKind (#_"Architecture" .getPlatformKind arch, javaKind)
        ]
            (if (#_"JavaKind" .isObject javaKind) (LIRKind'reference-1 platformKind) (LIRKind'value-1 platformKind))
        )
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a derived reference.
     ;;
    (defn #_"LIRKind" LIRKind'derivedReference-3 [#_"PlatformKind" platformKind, #_"AllocatableValue" base, #_"boolean" compressed?]
        (let [
            #_"int" length (#_"PlatformKind" .getVectorLength platformKind)
            #_"int" referenceMask (dec (<< 1 length))
            #_"int" referenceCompressionMask (if compressed? referenceMask 0)
        ]
            (LIRKind'new-4 platformKind, referenceMask, referenceCompressionMask, base)
        )
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a value that is derived
     ; from a reference in a non-linear way. Values of this LIRKind can not be live at
     ; safepoints. In most cases, this should not be called directly. #combine should be
     ; used instead to automatically propagate this information.
     ;;
    (defn #_"LIRKind" LIRKind'unknownReference-1 [#_"PlatformKind" platformKind]
        (LIRKind'new-4 platformKind, LIRKind'UNKNOWN_REFERENCE, LIRKind'UNKNOWN_REFERENCE, nil)
    )

    ;;;
     ; Create a derived reference.
     ;
     ; @param base An AllocatableValue containing the base pointer of the derived reference.
     ;;
    (defn #_"LIRKind" LIRKind''makeDerivedReference-2 [#_"LIRKind" this, #_"AllocatableValue" base]
        (cond
            (= base Value/ILLEGAL)    (LIRKind''makeUnknownReference-1 this)
            (LIRKind''isValue-1 this) (LIRKind'derivedReference-3 (#_"ValueKind" .getPlatformKind this), base, false)
            :else                     (LIRKind'new-4 (#_"ValueKind" .getPlatformKind this), (:referenceMask this), (:referenceCompressionMask this), base)
        )
    )

    ;;;
     ; Derive a new type from inputs. The result will have the PlatformKind of one of the inputs.
     ; If all inputs are values, the result is a value. Otherwise, the result is an unknown reference.
     ;
     ; This method should be used to construct the result LIRKind of any operation that
     ; modifies values (e.g. arithmetics).
     ;;
    (defn #_"LIRKind" LIRKind'combine-1* [& #_"Value..." inputs]
        (loop-when [#_"ISeq" s (seq inputs)] (some? s) => (#_"Value" .getValueKind (nth inputs 0), LIRKind'iface) ;; all inputs are values, just return one of them
            (let [
                #_"LIRKind" kind (#_"Value" .getValueKind (first s), LIRKind'iface)
            ]
                (cond
                    (LIRKind''isUnknownReference-1 kind) kind
                    (not (LIRKind''isValue-1 kind))      (LIRKind''makeUnknownReference-1 kind)
                    :else                                (recur (next s))
                )
            )
        )
    )

    ;;;
     ; Helper method to construct derived reference kinds. Returns the base value of a reference or
     ; derived reference. For values it returns nil, and for unknown references it returns Value#ILLEGAL.
     ;;
    (defn #_"AllocatableValue" LIRKind'derivedBaseFromValue-1 [#_"AllocatableValue" value]
        (let [
            #_"ValueKind" valueKind (#_"Value" .getValueKind value)
        ]
            (when (satisfies? LIRKind valueKind) => Value/ILLEGAL
                (let [
                    #_"LIRKind" kind (#_"Value" .getValueKind value, LIRKind'iface)
                ]
                    (cond
                        (LIRKind''isValue-1 kind)            nil
                        (LIRKind''isDerivedReference-1 kind) (:derivedReferenceBase kind)
                        (LIRKind''isUnknownReference-1 kind) Value/ILLEGAL
                        :else                                value ;; kind is a reference
                    )
                )
            )
        )
    )

    ;;;
     ; Helper method to construct derived reference kinds. If one of {@code base1} or {@code base2}
     ; are set, it creates a derived reference using it as the base. If both are set, the result is
     ; an unknown reference.
     ;;
    (defn #_"LIRKind" LIRKind'combineDerived-3 [#_"LIRKind" kind, #_"AllocatableValue" base1, #_"AllocatableValue" base2]
        (cond
            (and (nil? base1) (nil? base2)) kind
            (nil? base1)                    (LIRKind''makeDerivedReference-2 kind, base2)
            (nil? base2)                    (LIRKind''makeDerivedReference-2 kind, base1)
            :else                           (LIRKind''makeUnknownReference-1 kind)
        )
    )

    ;;;
     ; Merges the reference information of the inputs. The result will have the PlatformKind
     ; of {@code mergeKind}. If all inputs are values (references), the result is a value (reference).
     ; Otherwise, the result is an unknown reference.
     ;
     ; The correctness of the PlatformKind is not verified.
     ;;
    (defn #_"LIRKind" LIRKind'mergeReferenceInformation-2 [#_"LIRKind" mergeKind, #_"LIRKind" inputKind]
        (cond
            ;; mergeKind is an unknown reference: the result should be also an unknown reference
            (LIRKind''isUnknownReference-1 mergeKind) mergeKind
            ;; mergeKind is a value: if input consists of values and references, make the result an unknown reference
            (LIRKind''isValue-1 mergeKind) (if (LIRKind''isValue-1 inputKind) mergeKind (LIRKind''makeUnknownReference-1 mergeKind))
            ;; mergeKind is a reference and reference masks do not match: the result can only be an unknown reference
            (not (and (= (:referenceMask mergeKind) (:referenceMask inputKind))
                      (= (:referenceCompressionMask mergeKind) (:referenceCompressionMask inputKind)))
            )
                (LIRKind''makeUnknownReference-1 mergeKind)
            ;; both are references
            (LIRKind''isDerivedReference-1 mergeKind)
                (if (and (LIRKind''isDerivedReference-1 inputKind)
                         (= (:derivedReferenceBase mergeKind) (:derivedReferenceBase inputKind))
                    )
                    ;; same reference base: they must be equal
                    mergeKind
                    ;; base pointers differ: make the result an unknown reference
                    (LIRKind''makeUnknownReference-1 mergeKind)
                )
            ;; mergeKind is not derived, but inputKind is: make the result an unknown reference
            (LIRKind''isDerivedReference-1 inputKind) (LIRKind''makeUnknownReference-1 mergeKind)
            ;; both are not derived references: they must be equal
            :else mergeKind
        )
    )

    ;;;
     ; Create a new LIRKind with the same reference information and a new platform kind.
     ; If the new kind is a longer vector than this, the new elements are marked as untracked values.
     ;;
    (ยง override! #_"LIRKind" #_"ValueKind." changeType [#_"LIRKind" this, #_"PlatformKind" kind]
        (cond
            (= kind (#_"ValueKind" .getPlatformKind this)) this
            (LIRKind''isUnknownReference-1 this)           (LIRKind'unknownReference-1 kind)
            (zero? (:referenceMask this))                  (LIRKind'value-1 kind) ;; value type
            :else ;; reference type
                (let [
                    #_"int" n (min 32 (#_"PlatformKind" .getVectorLength kind))
                    #_"int" lengthMask (>>> 0xffffffff (- 32 n))
                    #_"int" referenceMask (& (:referenceMask this) lengthMask)
                    #_"int" referenceCompressionMask (& (:referenceCompressionMask this) lengthMask)
                ]
                    (LIRKind'new-4 kind, referenceMask, referenceCompressionMask, (:derivedReferenceBase this))
                )
        )
    )

    ;;;
     ; Create a new LIRKind with the same type, but marked as containing an LIRKind#unknownReference.
     ;;
    (defn #_"LIRKind" LIRKind''makeUnknownReference-1 [#_"LIRKind" this]
        (LIRKind'new-4 (#_"ValueKind" .getPlatformKind this), LIRKind'UNKNOWN_REFERENCE, LIRKind'UNKNOWN_REFERENCE, nil)
    )

    ;;;
     ; Check whether this value is a derived reference.
     ;;
    (defn #_"boolean" LIRKind''isDerivedReference-1 [#_"LIRKind" this]
        (some? (:derivedReferenceBase this))
    )

    ;;;
     ; Check whether this value is derived from a reference in a non-linear way. If this returns
     ; true, this value must not be live at safepoints.
     ;;
    (defn #_"boolean" LIRKind''isUnknownReference-1 [#_"LIRKind" this]
        (= (:referenceMask this) LIRKind'UNKNOWN_REFERENCE)
    )

    (defn #_"boolean" LIRKind'isUnknownReference-1k [#_"ValueKind" kind]
        (or (not (satisfies? LIRKind kind)) (LIRKind''isUnknownReference-1 kind))
    )

    #_unused
    (defn #_"boolean" LIRKind'isUnknownReference-1v [#_"Value" value]
        (LIRKind'isUnknownReference-1k (#_"Value" .getValueKind value))
    )

    #_unused
    (defn #_"int" LIRKind''getReferenceCount-1 [#_"LIRKind" this]
        (Integer/bitCount (:referenceMask this))
    )

    ;;;
     ; Check whether the {@code idx}th part of this value is a reference that must be tracked at safepoints.
     ;
     ; @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar kind.
     ;;
    (defn #_"boolean" LIRKind''isReference-2 [#_"LIRKind" this, #_"int" idx]
        (and (not (LIRKind''isUnknownReference-1 this)) (not (zero? (& (:referenceMask this) (<< 1 idx)))))
    )

    ;;;
     ; Check whether the {@code idx}th part of this value is a <b>compressed</b> reference.
     ;
     ; @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar kind.
     ;;
    #_unused
    (defn #_"boolean" LIRKind''isCompressedReference-2 [#_"LIRKind" this, #_"int" idx]
        (and (not (LIRKind''isUnknownReference-1 this)) (not (zero? (& (:referenceCompressionMask this) (<< 1 idx)))))
    )

    ;;;
     ; Check whether this kind is a value type that doesn't need to be tracked at safepoints.
     ;;
    (defn #_"boolean" LIRKind''isValue-1 [#_"LIRKind" this]
        (zero? (:referenceMask this))
    )

    (defn #_"boolean" LIRKind'isValue-1k [#_"ValueKind" kind]
        (and (satisfies? LIRKind kind) (LIRKind''isValue-1 kind))
    )

    (defn #_"boolean" LIRKind'isValue-1v [#_"Value" value]
        (LIRKind'isValue-1k (#_"Value" .getValueKind value))
    )

    (ยง override! #_"boolean" #_"Object." equals [#_"LIRKind" this, #_"Object" that]
        (or (= this that)
            (and (satisfies? LIRKind that)
                (= (#_"ValueKind" .getPlatformKind this) (#_"ValueKind" .getPlatformKind that))
                (= (:referenceMask this) (:referenceMask that))
                (= (:referenceCompressionMask this) (:referenceCompressionMask that))
                (when (LIRKind''isDerivedReference-1 this) => (not (LIRKind''isDerivedReference-1 that))
                    (and (LIRKind''isDerivedReference-1 that)
                        (= (:derivedReferenceBase this) (:derivedReferenceBase that))
                    )
                )
            )
        )
    )
)

(class-ns VariableMap []
    (defn #_"VariableMap" VariableMap'new-0 []
        (merge (VariableMap'class.)
            (hash-map
                #_"ArrayList<DefUseTree>" :content (ArrayList.)
            )
        )
    )

    (defn #_"DefUseTree" VariableMap''get-2 [#_"VariableMap" this, #_"Variable" key]
        (when (and (some? key) (< (:index key) (count (:content this))))
            (nth (:content this) (:index key))
        )
    )

    (defn #_"DefUseTree" VariableMap''put-3 [#_"VariableMap" this, #_"Variable" key, #_"DefUseTree" value]
        (while (<= (count (:content this)) (:index key))
            (#_"ArrayList" .add (:content this), nil)
        )
        (#_"ArrayList" .set (:content this), (:index key), value)
    )

    (defn #_"DefUseTree" VariableMap''remove-2 [#_"VariableMap" this, #_"Variable" key]
        (when (< (:index key) (count (:content this)))
            (#_"ArrayList" .set (:content this), (:index key), nil)
        )
    )

    (defn #_"void" VariableMap''forEach-2 [#_"VariableMap" this, #_"Consumer<DefUseTree>" action]
        (doseq [#_"DefUseTree" e (:content this)]
            (when (some? e)
                (#_"Consumer" .accept action, e)
            )
        )
        nil
    )

    ;;;
     ; Keeps only keys which match the given predicate.
     ;;
    (defn #_"void" VariableMap''filter-2 [#_"VariableMap" this, #_"fn boolean [DefUseTree]" f'predicate-1]
        (dotimes [#_"int" i (count (:content this))]
            (let [
                #_"DefUseTree" e (nth (:content this) i)
            ]
                (when (and (some? e) (not (f'predicate-1 e)))
                    (#_"ArrayList" .set (:content this), i, nil)
                )
            )
        )
        nil
    )
)

;;;
 ; Forwards calls from VirtualizerTool to the actual PartialEscapeBlockState.
 ;;
(class-ns VirtualizerTool [CanonicalizerTool]
    (defn #_"VirtualizerTool" VirtualizerTool'new-1 [#_"PartialEscapeClosure" closure]
        (merge (VirtualizerTool'class.)
            (hash-map
                #_"PartialEscapeClosure" :closure closure
                #_"ConstantNode" :illegalConstant nil
                #_"boolean" :deleted false
                #_"PartialEscapeBlockState" :state nil
                #_"ValueNode" :current nil
                #_"FixedNode" :position nil
                #_"GraphEffectList" :effects nil
            )
        )
    )

    (defn #_"this" VirtualizerTool''reset-5 [#_"VirtualizerTool" this, #_"PartialEscapeBlockState" state, #_"ValueNode" current, #_"FixedNode" position, #_"GraphEffectList" effects]
        (let [
            this (assoc this :deleted false)
            this (assoc this :state state)
            this (assoc this :current current)
            this (assoc this :position position)
            this (assoc this :effects effects)
        ]
            this
        )
    )

    (defn- #_"ValueNode" VirtualizerTool''getIllegalConstant-1 [#_"VirtualizerTool" this]
        (when (nil? (:illegalConstant this))
            (ยง ass! this (assoc this :illegalConstant (ConstantNode'forConstant-1 (JavaConstant/forIllegal))))
            (VirtualizerTool'''addNode-2 this, (:illegalConstant this))
        )
        (:illegalConstant this)
    )

    (defm VirtualizerTool VirtualizerTool
        (#_"ValueNode" VirtualizerTool'''getAlias-2 [#_"VirtualizerTool" this, #_"ValueNode" value]
            (PartialEscapeClosure''getAliasAndResolve-3 (:closure this), (:state this), value)
        )

        (#_"ValueNode" VirtualizerTool'''getEntry-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index]
            (ObjectState''getEntry-2 (nth (:objectStates (:state this)) (:oid virtualObject)), index)
        )

        (#_"boolean" VirtualizerTool'''setVirtualEntry-6 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtual, #_"int" index, #_"ValueNode" value, #_"JavaKind" theAccessKind, #_"long" offset]
            (let [
                #_"ObjectState" obj (nth (:objectStates (:state this)) (:oid virtual))
                #_"JavaKind" entryKind (VirtualObjectNode'''entryKind-2 virtual, index)
                #_"JavaKind" accessKind (or theAccessKind entryKind)
                #_"ValueNode" newValue (when (some? value) (PartialEscapeClosure''getAliasAndResolve-3 (:closure this), (:state this), value))
                #_"ValueNode" oldValue (VirtualizerTool'''getEntry-3 this, virtual, index)
                #_"boolean" canVirtualize
                    (or (= entryKind accessKind) (and (= entryKind (#_"JavaKind" .getStackKind accessKind)) (satisfies? VirtualInstanceNode virtual))
                        ;; Special case: If the entryKind is long, allow arbitrary kinds as long as a value of the
                        ;; same kind is already there. This can only happen if some other node initialized the entry with
                        ;; a value of a different kind. One example where this happens is the Truffle NewFrameNode.
                        (and (= entryKind JavaKind/Long) (= (ValueNode''getStackKind-1 oldValue) (ValueNode''getStackKind-1 newValue)) (#_"JavaKind" .isPrimitive (ValueNode''getStackKind-1 oldValue)))
                        ;; Special case: Allow storing a single long or double value into two consecutive int slots.
                        (and (= entryKind JavaKind/Int) (= accessKind JavaKind/Long) (zero? (% offset 8)) (not (= (VirtualObjectNode'''entryIndexForOffset-3 virtual, (+ offset 4), JavaKind/Int) -1)))
                    )
            ]
                (when canVirtualize => false ;; should only occur if there are mismatches between the entry and access kind
                    (PartialEscapeBlockState''setEntry-4 (:state this), (:oid virtual), index, newValue)
                    (when (= entryKind JavaKind/Int)
                        (cond
                            (#_"JavaKind" .needsTwoSlots accessKind)
                                ;; storing double word value two int slots
                                (PartialEscapeBlockState''setEntry-4 (:state this), (:oid virtual), (inc index), (VirtualizerTool''getIllegalConstant-1 this))
                            (= (ValueNode''getStackKind-1 oldValue) JavaKind/Long)
                                ;; splitting double word constant by storing over it with an int
                                (let [
                                    #_"ValueNode" secondHalf (UnpackEndianHalfNode'create-2 oldValue, false)
                                ]
                                    (VirtualizerTool'''addNode-2 this, secondHalf)
                                    (PartialEscapeBlockState''setEntry-4 (:state this), (:oid virtual), (inc index), secondHalf)
                                )
                        )
                    )
                    (when (and (satisfies? ConstantNode oldValue) (= (:value oldValue) (JavaConstant/forIllegal)))
                        ;; storing into second half of double, so replace previous value
                        (let [
                            #_"ValueNode" previous (VirtualizerTool'''getEntry-3 this, virtual, (dec index))
                            #_"ValueNode" firstHalf (UnpackEndianHalfNode'create-2 previous, true)
                        ]
                            (VirtualizerTool'''addNode-2 this, firstHalf)
                            (PartialEscapeBlockState''setEntry-4 (:state this), (:oid virtual), (dec index), firstHalf)
                        )
                    )
                    true
                )
            )
        )

        (#_"void" VirtualizerTool'''setVirtualEntry-4 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index, #_"ValueNode" value]
            (when-not (VirtualizerTool'''setVirtualEntry-6 this, virtualObject, index, value, nil, 0)
                (throw! "unexpected failure when updating virtual entry")
            )
            nil
        )
    )

    (defm VirtualizerTool VirtualizerTool
        (#_"boolean" VirtualizerTool'''getEnsureVirtualized-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" object]
            (:ensureVirtualized (nth (:objectStates (:state this)) (:oid object)))
        )

        (#_"void" VirtualizerTool'''replaceWithVirtual-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" object]
            (PartialEscapeClosure''addVirtualAlias-3 (:closure this), object, (:current this))
            (GraphEffectList''deleteNode-2 (:effects this), (:current this))
            (ยง ass! this (assoc this :deleted true))
            nil
        )

        (#_"void" VirtualizerTool'''replaceWithValue-2 [#_"VirtualizerTool" this, #_"ValueNode" replacement]
            (GraphEffectList''replaceAtUsages-4 (:effects this), (:current this), (EffectsClosure''getScalarAlias-2 (:closure this), replacement), (:position this))
            (EffectsClosure''addScalarAlias-3 (:closure this), (:current this), replacement)
            (ยง ass! this (assoc this :deleted true))
            nil
        )

        (#_"void" VirtualizerTool'''delete-1 [#_"VirtualizerTool" this]
            (GraphEffectList''deleteNode-2 (:effects this), (:current this))
            (ยง ass! this (assoc this :deleted true))
            nil
        )

        (#_"void" VirtualizerTool'''replaceFirstInput-3 [#_"VirtualizerTool" this, #_"Node" oldInput, #_"Node" replacement]
            (GraphEffectList''replaceFirstInput-4 (:effects this), (:current this), oldInput, replacement)
            nil
        )

        (#_"void" VirtualizerTool'''addNode-2 [#_"VirtualizerTool" this, #_"ValueNode" node]
            (if (satisfies? FloatingNode node)
                (GraphEffectList''addFloatingNode-3 (:effects this), node, "VirtualizerTool")
                (GraphEffectList''addFixedNodeBefore-3 (:effects this), node, (:position this))
            )
            nil
        )

        (#_"void" VirtualizerTool'''createVirtualObject-5 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"ValueNode[]" entryState, #_"List<MonitorIdNode>" locks, #_"boolean" ensureVirtualized]
            (when-not (Node''isAlive-1 virtualObject)
                (GraphEffectList''addFloatingNode-3 (:effects this), virtualObject, "newVirtualObject")
            )
            (dotimes [#_"int" i (count entryState)]
                (let [
                    #_"ValueNode" entry (nth entryState i)
                ]
                    (ยง aset! entryState i (if (satisfies? VirtualObjectNode entry) entry (PartialEscapeClosure''getAliasAndResolve-3 (:closure this), (:state this), entry)))
                )
            )
            (let [
                #_"int" id (:oid virtualObject)
                id
                    (when (= id -1) => id
                        (let [
                            id (count (:virtualObjects (:closure this)))
                        ]
                            (#_"ArrayList" .add (:virtualObjects (:closure this)), virtualObject)
                            (ยง ass! virtualObject (VirtualObjectNode''setObjectId-2 virtualObject, id))
                            id
                        )
                    )
            ]
                (PartialEscapeBlockState''addObject-3 (:state this), id, (ObjectState'new-3m entryState, locks, ensureVirtualized))
                (PartialEscapeClosure''addVirtualAlias-3 (:closure this), virtualObject, virtualObject)
                (ยง ass! (:effects this) (GraphEffectList''addVirtualizationDelta-2 (:effects this), 1))
            )
            nil
        )

        (#_"int" VirtualizerTool'''getMaximumEntryCount-1 [#_"VirtualizerTool" this]
            GraalOptions'maximumEscapeAnalysisArrayLength
        )

        (#_"void" VirtualizerTool'''replaceWith-2 [#_"VirtualizerTool" this, #_"ValueNode" node]
            (if (satisfies? VirtualObjectNode node)
                (VirtualizerTool'''replaceWithVirtual-2 this, node)
                (VirtualizerTool'''replaceWithValue-2 this, node)
            )
            nil
        )
    )

    (defm VirtualizerTool VirtualizerTool
        (#_"boolean" VirtualizerTool'''ensureMaterialized-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" object]
            (PartialEscapeClosure''ensureMaterialized-5 (:closure this), (:state this), (:oid object), (:position this), (:effects this))
        )

        (#_"void" VirtualizerTool'''addLock-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" object, #_"MonitorIdNode" monitorId]
            (PartialEscapeBlockState''addLock-3 (:state this), (:oid object), monitorId)
            nil
        )

        (#_"MonitorIdNode" VirtualizerTool'''removeLock-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" object]
            (PartialEscapeBlockState''removeLock-2 (:state this), (:oid object))
        )
    )

    (defm VirtualizerTool CanonicalizerTool
        (#_"boolean" CanonicalizerTool'''canonicalizeReads-1 [#_"VirtualizerTool" this]
            false
        )

        (#_"boolean" CanonicalizerTool'''allUsagesAvailable-1 [#_"VirtualizerTool" this]
            true
        )

        (#_"Integer" CanonicalizerTool'''smallestCompareWidth-1 [#_"VirtualizerTool" this]
            (Lowerer'smallestCompareWidth-0)
        )
    )
)

(class-ns Word []
    (defn- #_"Word" Word'new-1 [#_"long" rawValue]
        (merge (Word'class.)
            (hash-map
                #_"long" :rawValue rawValue
            )
        )
    )

    ;; Outside users must use the different signed() and unsigned() methods to ensure proper
    ;; expansion of 32-bit values on 64-bit systems.
    #_memoize
    (defn #_"Word" Word'box-1 [#_"long" val]
        (Word'new-1 val)
    )

    (defn #_"long" Word''unbox-1 [#_"Word" this]
        (:rawValue this)
    )

    (defn- #_"Word" Word'intParam-1 [#_"int" val]
        (Word'box-1 val)
    )

    ; @WordOperation(opcode = WordOpcode'TO_RAW_VALUE)
    (defn #_"long" Word''rawValue-1 [#_"Word" this]
        (Word''unbox-1 this)
    )

    ;;;
     ; Convert an Object to a Pointer, keeping the reference information. If the returned pointer
     ; or any value derived from it is alive across a safepoint, it will be tracked. Depending on
     ; the arithmetic on the pointer and the capabilities of the backend to deal with derived
     ; references, this may work correctly, or result in a compiler error.
     ;;
    ; @WordOperation(opcode = WordOpcode'FROM_OBJECT)
    (ยง native #_"Word" Word'objectToTrackedPointer-1 [#_"Object" val])

    ; @WordOperation(opcode = WordOpcode'FROM_ADDRESS)
    (ยง native #_"Word" Word'fromAddress-1 [#_"Address" address])

    ; @WordOperation(opcode = WordOpcode'TO_OBJECT)
    (ยง native #_"Object" Word''toObject-1 [#_"Word" this])

    ; @WordOperation(opcode = WordOpcode'TO_OBJECT_NON_NULL)
    (ยง native #_"Object" Word''toObjectNonNull-1 [#_"Word" this])

    ; @WordOperation(node = AddNode.class)
    (defn #_"Word" Word''add-2i [#_"Word" this, #_"int" val]
        (Word''add-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = AddNode.class)
    (defn #_"Word" Word''add-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (+ (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = SubNode.class)
    (defn #_"Word" Word''subtract-2i [#_"Word" this, #_"int" val]
        (Word''subtract-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = SubNode.class)
    (defn #_"Word" Word''subtract-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (- (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = MulNode.class)
    (defn #_"Word" Word''multiply-2i [#_"Word" this, #_"int" val]
        (Word''multiply-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = MulNode.class)
    (defn #_"Word" Word''multiply-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (* (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = SignedDivNode.class)
    #_unused
    (defn #_"Word" Word''signedDivide-2i [#_"Word" this, #_"int" val]
        (Word''signedDivide-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = SignedDivNode.class)
    (defn #_"Word" Word''signedDivide-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (quot (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = UnsignedDivNode.class)
    #_unused
    (defn #_"Word" Word''unsignedDivide-2i [#_"Word" this, #_"int" val]
        (Word''signedDivide-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = UnsignedDivNode.class)
    (defn #_"Word" Word''unsignedDivide-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (Long/divideUnsigned (Word''unbox-1 this), (Word''unbox-1 val)))
    )

    ; @WordOperation(node = SignedRemNode.class)
    #_unused
    (defn #_"Word" Word''signedRemainder-2i [#_"Word" this, #_"int" val]
        (Word''signedRemainder-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = SignedRemNode.class)
    (defn #_"Word" Word''signedRemainder-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (% (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = UnsignedRemNode.class)
    #_unused
    (defn #_"Word" Word''unsignedRemainder-2i [#_"Word" this, #_"int" val]
        (Word''signedRemainder-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = UnsignedRemNode.class)
    #_unused
    (defn #_"Word" Word''unsignedRemainder-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (Long/remainderUnsigned (Word''unbox-1 this), (Word''unbox-1 val)))
    )

    ; @WordOperation(node = LeftShiftNode.class, rightOperandIsInt = true)
    #_unused
    (defn #_"Word" Word''shiftLeft-2i [#_"Word" this, #_"int" val]
        (Word''shiftLeft-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = LeftShiftNode.class, rightOperandIsInt = true)
    (defn #_"Word" Word''shiftLeft-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (<< (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = RightShiftNode.class, rightOperandIsInt = true)
    #_unused
    (defn #_"Word" Word''signedShiftRight-2i [#_"Word" this, #_"int" val]
        (Word''signedShiftRight-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = RightShiftNode.class, rightOperandIsInt = true)
    (defn #_"Word" Word''signedShiftRight-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (>> (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = UnsignedRightShiftNode.class, rightOperandIsInt = true)
    (defn #_"Word" Word''unsignedShiftRight-2i [#_"Word" this, #_"int" val]
        (Word''unsignedShiftRight-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = UnsignedRightShiftNode.class, rightOperandIsInt = true)
    (defn #_"Word" Word''unsignedShiftRight-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (>>> (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = AndNode.class)
    (defn #_"Word" Word''and-2i [#_"Word" this, #_"int" val]
        (Word''and-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = AndNode.class)
    (defn #_"Word" Word''and-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (& (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = OrNode.class)
    (defn #_"Word" Word''or-2i [#_"Word" this, #_"int" val]
        (Word''or-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = OrNode.class)
    (defn #_"Word" Word''or-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (| (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(node = XorNode.class)
    #_unused
    (defn #_"Word" Word''xor-2i [#_"Word" this, #_"int" val]
        (Word''xor-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(node = XorNode.class)
    (defn #_"Word" Word''xor-2w [#_"Word" this, #_"Word" val]
        (Word'box-1 (bit-xor (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @WordOperation(opcode = WordOpcode'NOT)
    #_unused
    (defn #_"Word" Word''not-1 [#_"Word" this]
        (Word'box-1 (bit-not (Word''unbox-1 this)))
    )

    ; @WordOperation(opcode = WordOpcode'IS_NULL)
    #_unused
    (defn #_"boolean" Word''isNull-1 [#_"Word" this]
        (Word''equal-2w this, (WordFactory'zero-0))
    )

    ; @WordOperation(opcode = WordOpcode'IS_NON_NULL)
    #_unused
    (defn #_"boolean" Word''isNonNull-1 [#_"Word" this]
        (Word''notEqual-2w this, (WordFactory'zero-0))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (defn #_"boolean" Word''equal-2i [#_"Word" this, #_"int" val]
        (Word''equal-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (defn #_"boolean" Word''equal-2w [#_"Word" this, #_"Word" val]
        (= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (defn #_"boolean" Word''notEqual-2i [#_"Word" this, #_"int" val]
        (Word''notEqual-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (defn #_"boolean" Word''notEqual-2w [#_"Word" this, #_"Word" val]
        (not= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'LT)
    #_unused
    (defn #_"boolean" Word''lessThan-2i [#_"Word" this, #_"int" val]
        (Word''lessThan-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'LT)
    (defn #_"boolean" Word''lessThan-2w [#_"Word" this, #_"Word" val]
        (< (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'LE)
    #_unused
    (defn #_"boolean" Word''lessOrEqual-2i [#_"Word" this, #_"int" val]
        (Word''lessOrEqual-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'LE)
    (defn #_"boolean" Word''lessOrEqual-2w [#_"Word" this, #_"Word" val]
        (<= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'GT)
    #_unused
    (defn #_"boolean" Word''greaterThan-2i [#_"Word" this, #_"int" val]
        (Word''greaterThan-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'GT)
    (defn #_"boolean" Word''greaterThan-2w [#_"Word" this, #_"Word" val]
        (> (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'GE)
    #_unused
    (defn #_"boolean" Word''greaterOrEqual-2i [#_"Word" this, #_"int" val]
        (Word''greaterOrEqual-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'GE)
    (defn #_"boolean" Word''greaterOrEqual-2w [#_"Word" this, #_"Word" val]
        (>= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'BT)
    #_unused
    (defn #_"boolean" Word''belowThan-2i [#_"Word" this, #_"int" val]
        (Word''belowThan-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'BT)
    (defn #_"boolean" Word''belowThan-2w [#_"Word" this, #_"Word" val]
        (UnsignedMath'belowThan-2l (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'BE)
    #_unused
    (defn #_"boolean" Word''belowOrEqual-2i [#_"Word" this, #_"int" val]
        (Word''belowOrEqual-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'BE)
    (defn #_"boolean" Word''belowOrEqual-2w [#_"Word" this, #_"Word" val]
        (UnsignedMath'belowOrEqual-2l (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'AT)
    #_unused
    (defn #_"boolean" Word''aboveThan-2i [#_"Word" this, #_"int" val]
        (Word''aboveThan-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'AT)
    (defn #_"boolean" Word''aboveThan-2w [#_"Word" this, #_"Word" val]
        (UnsignedMath'aboveThan-2l (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'AE)
    #_unused
    (defn #_"boolean" Word''aboveOrEqual-2i [#_"Word" this, #_"int" val]
        (Word''aboveOrEqual-2w this, (Word'intParam-1 val))
    )

    ; @WordOperation(opcode = WordOpcode'COMPARISON, condition = Condition'AE)
    (defn #_"boolean" Word''aboveOrEqual-2w [#_"Word" this, #_"Word" val]
        (UnsignedMath'aboveOrEqual-2l (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;
     ; The offset is always treated as a SignedWord value. However, the static type is Word to avoid the frequent casts
     ; of UnsignedWord values (where the caller knows that the highest-order bit of the unsigned value is never used).
     ;;
    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"byte" Word''readByte-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location]
        (.getByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"char" Word''readChar-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location]
        (.getChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"short" Word''readShort-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location]
        (.getShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"int" Word''readInt-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location]
        (.getInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"long" Word''readLong-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location]
        (.getLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"Word" Word''readWord-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location]
        (Word'box-1 (.getAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset))))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (ยง native #_"Object" Word''readObject-3w [#_"Word" this, #_"Word" offset, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"byte" Word''readByte-3i [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readByte-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (defn #_"char" Word''readChar-3i [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readChar-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (defn #_"short" Word''readShort-3i [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readShort-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"int" Word''readInt-3i [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readInt-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"long" Word''readLong-3i [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readLong-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"Word" Word''readWord-3i [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readWord-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"Object" Word''readObject-3il [#_"Word" this, #_"int" offset, #_"LocationIdentity" location]
        (Word''readObject-3w this, (WordFactory'signed-1i offset), location)
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeByte-4w [#_"Word" this, #_"Word" offset, #_"byte" val, #_"LocationIdentity" location]
        (.putByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeChar-4w [#_"Word" this, #_"Word" offset, #_"char" val, #_"LocationIdentity" location]
        (.putChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeShort-4w [#_"Word" this, #_"Word" offset, #_"short" val, #_"LocationIdentity" location]
        (.putShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeInt-4w [#_"Word" this, #_"Word" offset, #_"int" val, #_"LocationIdentity" location]
        (.putInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeLong-4w [#_"Word" this, #_"Word" offset, #_"long" val, #_"LocationIdentity" location]
        (.putLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeWord-4w [#_"Word" this, #_"Word" offset, #_"Word" val, #_"LocationIdentity" location]
        (.putAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), (Word''unbox-1 val))
        nil
    )

    ; @WordOperation(opcode = WordOpcode'INITIALIZE)
    (defn #_"void" Word''initializeLong-4w [#_"Word" this, #_"Word" offset, #_"long" val, #_"LocationIdentity" location]
        (.putLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (ยง native #_"void" Word''writeObject-4 [#_"Word" this, #_"Word" offset, #_"Object" val, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeByte-4i [#_"Word" this, #_"int" offset, #_"byte" val, #_"LocationIdentity" location]
        (Word''writeByte-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeChar-4i [#_"Word" this, #_"int" offset, #_"char" val, #_"LocationIdentity" location]
        (Word''writeChar-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeShort-4i [#_"Word" this, #_"int" offset, #_"short" val, #_"LocationIdentity" location]
        (Word''writeShort-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeInt-4i [#_"Word" this, #_"int" offset, #_"int" val, #_"LocationIdentity" location]
        (Word''writeInt-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeLong-4i [#_"Word" this, #_"int" offset, #_"long" val, #_"LocationIdentity" location]
        (Word''writeLong-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeWord-4i [#_"Word" this, #_"int" offset, #_"Word" val, #_"LocationIdentity" location]
        (Word''writeWord-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'INITIALIZE)
    (defn #_"void" Word''initializeLong-4i [#_"Word" this, #_"int" offset, #_"long" val, #_"LocationIdentity" location]
        (Word''initializeLong-4w this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeObject-4 [#_"Word" this, #_"int" offset, #_"Object" val, #_"LocationIdentity" location]
        (Word''writeObject-4 this, (WordFactory'signed-1i offset), val, location)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"byte" Word''readByte-2w [#_"Word" this, #_"Word" offset]
        (.getByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"char" Word''readChar-2w [#_"Word" this, #_"Word" offset]
        (.getChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"short" Word''readShort-2w [#_"Word" this, #_"Word" offset]
        (.getShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"int" Word''readInt-2w [#_"Word" this, #_"Word" offset]
        (.getInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"long" Word''readLong-2w [#_"Word" this, #_"Word" offset]
        (.getLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"Word" Word''readWord-2w [#_"Word" this, #_"Word" offset]
        (Word'box-1 (.getAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset))))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (ยง native #_"Object" Word''readObject-2 [#_"Word" this, #_"Word" offset])

    ; @WordOperation(opcode = WordOpcode'READ_HEAP)
    (ยง native #_"Object" Word''readObject-3w [#_"Word" this, #_"Word" offset, #_"BarrierType" barrierType])

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"byte" Word''readByte-2i [#_"Word" this, #_"int" offset]
        (Word''readByte-2w this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (defn #_"char" Word''readChar-2i [#_"Word" this, #_"int" offset]
        (Word''readChar-2w this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (defn #_"short" Word''readShort-2i [#_"Word" this, #_"int" offset]
        (Word''readShort-2w this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (defn #_"int" Word''readInt-2i [#_"Word" this, #_"int" offset]
        (Word''readInt-2w this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (defn #_"long" Word''readLong-2i [#_"Word" this, #_"int" offset]
        (Word''readLong-2w this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"Word" Word''readWord-2i [#_"Word" this, #_"int" offset]
        (Word''readWord-2w this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_POINTER)
    (defn #_"Object" Word''readObject-2 [#_"Word" this, #_"int" offset]
        (Word''readObject-2 this, (WordFactory'signed-1i offset))
    )

    ; @WordOperation(opcode = WordOpcode'READ_HEAP)
    (defn #_"Object" Word''readObject-3ib [#_"Word" this, #_"int" offset, #_"BarrierType" barrierType]
        (Word''readObject-3w this, (WordFactory'signed-1i offset), barrierType)
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeByte-3w [#_"Word" this, #_"Word" offset, #_"byte" val]
        (.putByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeChar-3w [#_"Word" this, #_"Word" offset, #_"char" val]
        (.putChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeShort-3w [#_"Word" this, #_"Word" offset, #_"short" val]
        (.putShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeInt-3w [#_"Word" this, #_"Word" offset, #_"int" val]
        (.putInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeLong-3w [#_"Word" this, #_"Word" offset, #_"long" val]
        (.putLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (ยง native #_"int" Word''compareAndSwapInt-5 [#_"Word" this, #_"Word" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (ยง native #_"long" Word''compareAndSwapLong-5 [#_"Word" this, #_"Word" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (ยง native #_"Word" Word''compareAndSwapWord-5 [#_"Word" this, #_"Word" offset, #_"Word" expectedValue, #_"Word" newValue, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (ยง native #_"Object" Word''compareAndSwapObject-5 [#_"Word" this, #_"Word" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"boolean" Word''logicCompareAndSwapInt-5w [#_"Word" this, #_"Word" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" location]
        (.compareAndSwapInt HotSpot'unsafe, (Word''toObject-1 this), (Word''unbox-1 offset), expectedValue, newValue)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"boolean" Word''logicCompareAndSwapLong-5w [#_"Word" this, #_"Word" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" location]
        (.compareAndSwapLong HotSpot'unsafe, (Word''toObject-1 this), (Word''unbox-1 offset), expectedValue, newValue)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (ยง native #_"boolean" Word''logicCompareAndSwapWord-5 [#_"Word" this, #_"Word" offset, #_"Word" expectedValue, #_"Word" newValue, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"boolean" Word''logicCompareAndSwapObject-5w [#_"Word" this, #_"Word" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" location]
        (.compareAndSwapObject HotSpot'unsafe, (Word''toObject-1 this), (Word''unbox-1 offset), expectedValue, newValue)
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeWord-3w [#_"Word" this, #_"Word" offset, #_"Word" val]
        (.putAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2w this, offset)), (Word''unbox-1 val))
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (ยง native #_"void" Word''writeObject-3 [#_"Word" this, #_"Word" offset, #_"Object" val])

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeByte-3i [#_"Word" this, #_"int" offset, #_"byte" val]
        (Word''writeByte-3w this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeChar-3i [#_"Word" this, #_"int" offset, #_"char" val]
        (Word''writeChar-3w this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeShort-3i [#_"Word" this, #_"int" offset, #_"short" val]
        (Word''writeShort-3w this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeInt-3i [#_"Word" this, #_"int" offset, #_"int" val]
        (Word''writeInt-3w this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (defn #_"void" Word''writeLong-3i [#_"Word" this, #_"int" offset, #_"long" val]
        (Word''writeLong-3w this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeWord-3i [#_"Word" this, #_"int" offset, #_"Word" val]
        (Word''writeWord-3w this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (defn #_"void" Word''writeObject-3 [#_"Word" this, #_"int" offset, #_"Object" val]
        (Word''writeObject-3 this, (WordFactory'signed-1i offset), val)
        nil
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"int" Word''compareAndSwapInt-5 [#_"Word" this, #_"int" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" location]
        (Word''compareAndSwapInt-5 this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"long" Word''compareAndSwapLong-5 [#_"Word" this, #_"int" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" location]
        (Word''compareAndSwapLong-5 this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"Word" Word''compareAndSwapWord-5 [#_"Word" this, #_"int" offset, #_"Word" expectedValue, #_"Word" newValue, #_"LocationIdentity" location]
        (Word''compareAndSwapWord-5 this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"Object" Word''compareAndSwapObject-5 [#_"Word" this, #_"int" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" location]
        (Word''compareAndSwapObject-5 this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    #_unused
    (defn #_"boolean" Word''logicCompareAndSwapInt-5i [#_"Word" this, #_"int" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" location]
        (Word''logicCompareAndSwapInt-5w this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    #_unused
    (defn #_"boolean" Word''logicCompareAndSwapLong-5i [#_"Word" this, #_"int" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" location]
        (Word''logicCompareAndSwapLong-5w this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    (defn #_"boolean" Word''logicCompareAndSwapWord-5 [#_"Word" this, #_"int" offset, #_"Word" expectedValue, #_"Word" newValue, #_"LocationIdentity" location]
        (Word''logicCompareAndSwapWord-5 this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @WordOperation(opcode = WordOpcode'CAS_POINTER)
    #_unused
    (defn #_"boolean" Word''logicCompareAndSwapObject-5i [#_"Word" this, #_"int" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" location]
        (Word''logicCompareAndSwapObject-5w this, (WordFactory'signed-1i offset), expectedValue, newValue, location)
    )

    ; @MetaspaceOperation(opcode = MetaspaceOpcode'POINTER_EQ)
    (ยง native #_"boolean" Word''klassPointersEqual-2 [#_"KlassPointer" this, #_"KlassPointer" other])

    ; @MetaspaceOperation(opcode = MetaspaceOpcode'POINTER_NE)
    (ยง native #_"boolean" Word''klassPointersNotEqual-2 [#_"KlassPointer" this, #_"KlassPointer" other])

    ; @MetaspaceOperation(opcode = MetaspaceOpcode'TO_KLASS_POINTER)
    (ยง native #_"KlassPointer" Word'klassPointerFromWord-1 [#_"Word" pointer])

    ; @MetaspaceOperation(opcode = MetaspaceOpcode'READ_KLASS_POINTER)
    (ยง native #_"KlassPointer" Word''readKlassPointer-3 [#_"KlassPointer" this, #_"int" offset, #_"LocationIdentity" location])

    ; @WordOperation(opcode = WordOpcode'WRITE_POINTER)
    (ยง native #_"void" Word''writeKlassPointer-4 [#_"KlassPointer" this, #_"int" offset, #_"KlassPointer" t, #_"LocationIdentity" location])

    ; @MetaspaceOperation(opcode = MetaspaceOpcode'IS_NULL)
    (ยง native #_"boolean" Word''klassPointerIsNull-1 [#_"KlassPointer" this])

    ; @MetaspaceOperation(opcode = MetaspaceOpcode'FROM_POINTER)
    #_unused
    (ยง native #_"Word" Word''klassPointerAsWord-1 [#_"KlassPointer" this])
)

;;;
 ; A plugin for calls to word operations, as well as all other nodes that need special handling for Word types.
 ;;
(class-ns WordOperationPlugin [NodePlugin, TypePlugin, InlineInvokePlugin]
    (defn #_"WordOperationPlugin" WordOperationPlugin'new-0 []
        (WordOperationPlugin'class.)
    )

    (defn- #_"ValueNode" WordOperationPlugin'convert-4 [#_"BytecodeParser" parser, #_"ValueNode" value, #_"JavaKind" toKind, #_"boolean" unsigned?]
        (cond
            (= (ValueNode''getStackKind-1 value) toKind) value
            (= toKind JavaKind/Int)                      (BytecodeParser''add-2 parser, (NarrowNode'new-2 value, 32))
            unsigned?                                    (BytecodeParser''add-2 parser, (ZeroExtendNode'new-2 value, 64))
            :else                                        (BytecodeParser''add-2 parser, (SignExtendNode'new-2 value, 64))
        )
    )

    (defn #_"ValueNode" WordOperationPlugin'fromUnsigned-2 [#_"BytecodeParser" parser, #_"ValueNode" value]
        (WordOperationPlugin'convert-4 parser, value, WordTypes'wordKind, true)
    )

    (defn #_"ValueNode" WordOperationPlugin'fromSigned-2 [#_"BytecodeParser" parser, #_"ValueNode" value]
        (WordOperationPlugin'convert-4 parser, value, WordTypes'wordKind, false)
    )

    (defn #_"ValueNode" WordOperationPlugin'toUnsigned-3 [#_"BytecodeParser" parser, #_"ValueNode" value, #_"JavaKind" toKind]
        (WordOperationPlugin'convert-4 parser, value, toKind, true)
    )

    (defn #_"AddressNode" WordOperationPlugin'makeAddress-3 [#_"BytecodeParser" parser, #_"ValueNode" base, #_"ValueNode" offset]
        (BytecodeParser''add-2 parser, (OffsetAddressNode'new-2 base, (WordOperationPlugin'fromSigned-2 parser, offset)))
    )

    (defn- #_"void" WordOperationPlugin'processMetaspaceOperation-4 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode*" args, #_"MetaspaceOperation" operation]
        (let [
            #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature method))
        ]
            (condp =? (MetaspaceOperation''opcode-1 operation)
               [MetaspaceOpcode'POINTER_EQ MetaspaceOpcode'POINTER_NE]
                    (let [
                        #_"MetaspaceOpcode" opcode (MetaspaceOperation''opcode-1 operation)
                        #_"PointerEqualsNode" comparison (BytecodeParser''add-2 parser, (PointerEqualsNode'new-2 (nth args 0), (nth args 1)))
                        #_"ValueNode" eqValue (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 (= opcode MetaspaceOpcode'POINTER_EQ)))
                        #_"ValueNode" neValue (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 (= opcode MetaspaceOpcode'POINTER_NE)))
                    ]
                        (BytecodeParser''addPush-3 parser, returnKind, (ConditionalNode'create-3 comparison, eqValue, neValue))
                    )
                MetaspaceOpcode'IS_NULL
                    (let [
                        #_"LogicNode" isNull (BytecodeParser''add-2 parser, (IsNullNode'create-1 (nth args 0)))
                    ]
                        (BytecodeParser''addPush-3 parser, returnKind, (ConditionalNode'create-3 isNull, (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 true)), (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 false))))
                    )
                MetaspaceOpcode'FROM_POINTER
                    (BytecodeParser''addPush-3 parser, returnKind, (PointerCastNode'new-2 (StampFactory'forKind-1 WordTypes'wordKind), (nth args 0)))
                MetaspaceOpcode'TO_KLASS_POINTER
                    (BytecodeParser''addPush-3 parser, returnKind, (PointerCastNode'new-2 KlassPointerStamp'KLASS, (nth args 0)))
                MetaspaceOpcode'READ_KLASS_POINTER
                    (let [
                        #_"AddressNode" address (WordOperationPlugin'makeAddress-3 parser, (nth args 0), (nth args 1))
                        #_"LocationIdentity" location
                            (if (= (count args) 2)
                                LocationIdentity'ANY
                                (SnippetReflection'asObject-2c LocationIdentity'iface, (ValueNode''asJavaConstant-1 (nth args 2)))
                            )
                    ]
                        (BytecodeParser''push-3 parser, returnKind, (BytecodeParser''add-2 parser, (ReadNode'new-4 address, location, KlassPointerStamp'KLASS, BarrierType'NONE)))
                    )
            )
        )
        nil
    )

    ;;;
     ; Create an instance of a binary node which is used to lower Word operations.
     ; This method is called for all Word operations which are annotated with
     ; @WordOperation(node = ...) and encapsulates the reflective allocation of the node.
     ;;
    (defn- #_"ValueNode" WordOperationPlugin'createBinaryNodeInstance-3 [#_"Class<? implements ValueNode>" nodeClass, #_"ValueNode" left, #_"ValueNode" right]
        (#_"Constructor" .newInstance (#_"Class" .getDeclaredConstructor nodeClass, ValueNode'iface, ValueNode'iface), left, right)
    )

    (defn- #_"ValueNode" WordOperationPlugin'comparisonOp-4 [#_"BytecodeParser" parser, #_"Condition" condition, #_"ValueNode" left, #_"ValueNode" right]
        (let [
            #_"CanonicalizedCondition" canonical (Condition''canonicalize-1 condition)
            #_"ValueNode" a (if (:mirror? canonical) right left)
            #_"ValueNode" b (if (:mirror? canonical) left right)
            #_"CompareNode" comparison
                (condp = (:canonicalCondition canonical)
                    CanonicalCondition'EQ (IntegerEqualsNode'new-2 a, b)
                    CanonicalCondition'BT (IntegerBelowNode'new-2 a, b)
                                          (IntegerLessThanNode'new-2 a, b)
                )
            #_"ConstantNode" t (BytecodeParser''add-2 parser, (ConstantNode'forInt-1 1))
            #_"ConstantNode" f (BytecodeParser''add-2 parser, (ConstantNode'forInt-1 0))
            [t f] (if (:negate? canonical) [f t] [t f])
        ]
            (BytecodeParser''add-2 parser, (ConditionalNode'new-3 (BytecodeParser''add-2 parser, comparison), t, f))
        )
    )

    (defn- #_"ValueNode" WordOperationPlugin'readOp-6 [#_"BytecodeParser" parser, #_"JavaKind" readKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"BarrierType" barrierType, #_"boolean" compressible?]
        ;; A JavaReadNode lowered to a ReadNode that will not float. This means it cannot float above
        ;; an explicit zero check on its base address or any other test that ensures the read is safe.
        (BytecodeParser''add-2 parser, (JavaReadNode'new-5 readKind, address, location, barrierType, compressible?))
    )

    (defn- #_"ValueNode" WordOperationPlugin'readOp-5 [#_"BytecodeParser" parser, #_"JavaKind" readKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"WordOpcode" op]
        (let [
            #_"BarrierType" barrier (if (= op WordOpcode'READ_BARRIERED) BarrierType'PRECISE BarrierType'NONE)
            #_"boolean" compressible? (any = op WordOpcode'READ_OBJECT WordOpcode'READ_BARRIERED)
        ]
            (WordOperationPlugin'readOp-6 parser, readKind, address, location, barrier, compressible?)
        )
    )

    (defn- #_"void" WordOperationPlugin'writeOp-6 [#_"BytecodeParser" parser, #_"JavaKind" writeKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"WordOpcode" op]
        (let [
            #_"BarrierType" barrier (if (= op WordOpcode'WRITE_BARRIERED) BarrierType'PRECISE BarrierType'NONE)
            #_"boolean" compressible? (any = op WordOpcode'WRITE_OBJECT WordOpcode'WRITE_BARRIERED)
        ]
            (BytecodeParser''add-2 parser, (JavaWriteNode'new-6 writeKind, address, location, value, barrier, compressible?))
        )
        nil
    )

    (defn- #_"AbstractCompareAndSwapNode" WordOperationPlugin'casOp-6 [#_"JavaKind" writeKind, #_"JavaKind" returnKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" expectedValue, #_"ValueNode" newValue]
        (if (= returnKind JavaKind/Boolean)
            (LogicCompareAndSwapNode'new-4 address, expectedValue, newValue, location)
            (ValueCompareAndSwapNode'new-4 address, expectedValue, newValue, location)
        )
    )

    (defn- #_"void" WordOperationPlugin'processWordOperation-3 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode*" args]
        (let [
            #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature method))
            #_"WordFactoryOperation" factoryOperation (#_"ResolvedJavaMethod" .getAnnotation method, WordFactoryOperation)
        ]
            (or
                (when (some? factoryOperation)
                    (condp = (WordFactoryOperation''opcode-1 factoryOperation)
                        WordFactoryOpcode'ZERO
                        (do
                            (BytecodeParser''addPush-3 parser, returnKind, (ConstantNode'forIntegerKind-2 WordTypes'wordKind, 0))
                            :done
                        )
                        WordFactoryOpcode'FROM_UNSIGNED
                        (do
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'fromUnsigned-2 parser, (nth args 0)))
                            :done
                        )
                        WordFactoryOpcode'FROM_SIGNED
                        (do
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'fromSigned-2 parser, (nth args 0)))
                            :done
                        )
                        nil
                    )
                )

                (let [
                    #_"WordOperation" operation (#_"ResolvedJavaMethod" .getAnnotation method, WordOperation)
                ]
                    (when (nil? operation)
                        (throw! (str "cannot call method on a word value: " (#_"ResolvedJavaMethod" .format method, "%H.\n(%p)")))
                    )
                    (condp =? (WordOperation''opcode-1 operation)
                        WordOpcode'NODE_CLASS
                            (let [
                                #_"ValueNode" left (nth args 0)
                                #_"ValueNode" right (if (WordOperation''rightOperandIsInt-1 operation) (WordOperationPlugin'toUnsigned-3 parser, (nth args 1), JavaKind/Int) (WordOperationPlugin'fromSigned-2 parser, (nth args 1)))
                            ]
                                (BytecodeParser''addPush-3 parser, returnKind, (WordOperationPlugin'createBinaryNodeInstance-3 (WordOperation''node-1 operation), left, right))
                            )
                        WordOpcode'COMPARISON
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'comparisonOp-4 parser, (WordOperation''condition-1 operation), (nth args 0), (WordOperationPlugin'fromSigned-2 parser, (nth args 1))))
                        WordOpcode'IS_NULL
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'comparisonOp-4 parser, Condition'EQ, (nth args 0), (ConstantNode'forIntegerKind-2 WordTypes'wordKind, 0)))
                        WordOpcode'IS_NON_NULL
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'comparisonOp-4 parser, Condition'NE, (nth args 0), (ConstantNode'forIntegerKind-2 WordTypes'wordKind, 0)))
                        WordOpcode'NOT
                            (BytecodeParser''addPush-3 parser, returnKind, (XorNode'new-2 (nth args 0), (BytecodeParser''add-2 parser, (ConstantNode'forIntegerKind-2 WordTypes'wordKind, -1))))
                       [WordOpcode'READ_POINTER WordOpcode'READ_OBJECT WordOpcode'READ_BARRIERED]
                            (let [
                                #_"JavaKind" readKind (WordTypes'asKind-1 (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature method), (#_"ResolvedJavaMethod" .getDeclaringClass method)))
                                #_"AddressNode" address (WordOperationPlugin'makeAddress-3 parser, (nth args 0), (nth args 1))
                                #_"LocationIdentity" location
                                    (if (= (count args) 2)
                                        LocationIdentity'ANY
                                        (SnippetReflection'asObject-2c LocationIdentity'iface, (ValueNode''asJavaConstant-1 (nth args 2)))
                                    )
                            ]
                                (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'readOp-5 parser, readKind, address, location, (WordOperation''opcode-1 operation)))
                            )
                        WordOpcode'READ_HEAP
                            (let [
                                #_"JavaKind" readKind (WordTypes'asKind-1 (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature method), (#_"ResolvedJavaMethod" .getDeclaringClass method)))
                                #_"AddressNode" address (WordOperationPlugin'makeAddress-3 parser, (nth args 0), (nth args 1))
                                #_"BarrierType" barrierType (SnippetReflection'asObject-2c BarrierType, (ValueNode''asJavaConstant-1 (nth args 2)))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'readOp-6 parser, readKind, address, LocationIdentity'ANY, barrierType, true))
                            )
                       [WordOpcode'WRITE_POINTER WordOpcode'WRITE_OBJECT WordOpcode'WRITE_BARRIERED WordOpcode'INITIALIZE]
                            (let [
                                #_"JavaKind" writeKind (WordTypes'asKind-1 (#_"Signature" .getParameterType (#_"ResolvedJavaMethod" .getSignature method), (if (#_"ResolvedJavaMethod" .isStatic method) 2 1), (#_"ResolvedJavaMethod" .getDeclaringClass method)))
                                #_"AddressNode" address (WordOperationPlugin'makeAddress-3 parser, (nth args 0), (nth args 1))
                                #_"LocationIdentity" location
                                    (if (= (count args) 3)
                                        LocationIdentity'ANY
                                        (SnippetReflection'asObject-2c LocationIdentity'iface, (ValueNode''asJavaConstant-1 (nth args 3)))
                                    )
                            ]
                                (WordOperationPlugin'writeOp-6 parser, writeKind, address, location, (nth args 2), (WordOperation''opcode-1 operation))
                            )
                        WordOpcode'TO_RAW_VALUE
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'toUnsigned-3 parser, (nth args 0), JavaKind/Long))
                        WordOpcode'FROM_OBJECT
                            (let [
                                #_"WordCastNode" objectToTracked (BytecodeParser''add-2 parser, (WordCastNode'objectToWord-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, objectToTracked)
                            )
                        WordOpcode'FROM_ADDRESS
                            (let [
                                #_"WordCastNode" addressToWord (BytecodeParser''add-2 parser, (WordCastNode'addressToWord-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, addressToWord)
                            )
                        WordOpcode'TO_OBJECT
                            (let [
                                #_"WordCastNode" wordToObject (BytecodeParser''add-2 parser, (WordCastNode'wordToObject-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, wordToObject)
                            )
                        WordOpcode'TO_OBJECT_NON_NULL
                            (let [
                                #_"WordCastNode" wordToObjectNonNull (BytecodeParser''add-2 parser, (WordCastNode'wordToObjectNonNull-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, wordToObjectNonNull)
                            )
                        WordOpcode'CAS_POINTER
                            (let [
                                #_"AddressNode" address (WordOperationPlugin'makeAddress-3 parser, (nth args 0), (nth args 1))
                                #_"JavaKind" valueKind (WordTypes'asKind-1 (#_"Signature" .getParameterType (#_"ResolvedJavaMethod" .getSignature method), 1, (#_"ResolvedJavaMethod" .getDeclaringClass method)))
                                #_"LocationIdentity" location (SnippetReflection'asObject-2c LocationIdentity'iface, (ValueNode''asJavaConstant-1 (nth args 4)))
                                #_"JavaType" returnType (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature method), (#_"ResolvedJavaMethod" .getDeclaringClass method))
                            ]
                                (BytecodeParser''addPush-3 parser, returnKind, (WordOperationPlugin'casOp-6 valueKind, (WordTypes'asKind-1 returnType), address, location, (nth args 2), (nth args 3)))
                            )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Processes a call to a method if it is annotated as a word operation by adding nodes to the graph being
     ; built that implement the denoted operation.
     ;
     ; @return true iff {@code method} is annotated with WordOperation (and was thus processed by this method)
     ;;
    (defm WordOperationPlugin NodePlugin
        (#_"boolean" NodePlugin'''handleInvoke-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode*" args]
            (and (WordTypes'isWordOperation-1 method)
                (let [
                    #_"MetaspaceOperation" operation (#_"ResolvedJavaMethod" .getAnnotation method, MetaspaceOperation)
                ]
                    (if (some? operation)
                        (WordOperationPlugin'processMetaspaceOperation-4 parser, method, args, operation)
                        (WordOperationPlugin'processWordOperation-3 parser, method, args)
                    )
                    true
                )
            )
        )
    )

    (defm WordOperationPlugin TypePlugin
        (#_"Stamp" TypePlugin'''interceptType-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"JavaType" type, #_"boolean" never-nil?]
            (when (instance? ResolvedJavaType type)
                (cond
                    (WordTypes'isWord-1j type)
                        (WordTypes'getWordStamp-1 type)
                    (and (#_"ResolvedJavaType" .isArray type) (WordTypes'isWord-1j (#_"ResolvedJavaType" .getElementalType type)))
                        (StampFactory'object-2 (TypeReference'createTrusted-1 type), never-nil?)
                )
            )
        )
    )

    (defm WordOperationPlugin InlineInvokePlugin
        (#_"void" InlineInvokePlugin'''notifyNotInlined-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke]
            (when (WordTypes'isWord-1v invoke)
                (ยง ass! invoke (ValueNode''setStamp-2 invoke, (WordTypes'getWordStamp-1 (StampTool'typeOrNull-1 (:stamp invoke)))))
            )
            nil
        )
    )

    (defm WordOperationPlugin NodePlugin
        (#_"boolean" NodePlugin'''handleLoadField-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" receiver, #_"ResolvedJavaField" field]
            (let [
                #_"Stamp" wordStamp (TypePlugin'''interceptType-4 this, parser, (#_"ResolvedJavaField" .getType field), false)
            ]
                (and (some? wordStamp)
                    (do
                        (BytecodeParser''addPush-3 parser, (#_"ResolvedJavaField" .getJavaKind field), (LoadFieldNode'createOverrideStamp-3 wordStamp, receiver, field))
                        true
                    )
                )
            )
        )

        (#_"boolean" NodePlugin'''handleLoadStaticField-3 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" staticField]
            (NodePlugin'''handleLoadField-4 this, parser, nil, staticField)
        )
    )

    (defn- #_"LoadIndexedNode" WordOperationPlugin'createLoadIndexedNode-2 [#_"ValueNode" array, #_"ValueNode" index]
        (let [
            #_"ResolvedJavaType" arrayType (StampTool'typeOrNull-1 (:stamp array))
            #_"Stamp" componentStamp (WordTypes'getWordStamp-1 (#_"ResolvedJavaType" .getComponentType arrayType))
        ]
            (if (satisfies? KlassPointerStamp componentStamp)
                (LoadIndexedPointerNode'new-3 componentStamp, array, index)
                (LoadIndexedNode'new-3 array, index, WordTypes'wordKind)
            )
        )
    )

    (defn- #_"StoreIndexedNode" WordOperationPlugin'createStoreIndexedNode-3 [#_"ValueNode" array, #_"ValueNode" index, #_"ValueNode" value]
        (StoreIndexedNode'new-4 array, index, WordTypes'wordKind, value)
    )

    (defm WordOperationPlugin NodePlugin
        (#_"boolean" NodePlugin'''handleLoadIndexed-5 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
            (let [
                #_"ResolvedJavaType" arrayType (StampTool'typeOrNull-1 (:stamp array))
            ]
                ;; There are cases where the array does not have a known type yet, i.e. the type is nil.
                ;; In that case we assume it is not a word type.
                (and (some? arrayType) (WordTypes'isWord-1j (#_"ResolvedJavaType" .getComponentType arrayType))
                    (do
                        (BytecodeParser''addPush-3 parser, elementKind, (WordOperationPlugin'createLoadIndexedNode-2 array, index))
                        true
                    )
                )
            )
        )

        (#_"boolean" NodePlugin'''handleStoreField-5 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
            (and (= (#_"ResolvedJavaField" .getJavaKind field) JavaKind/Object)
                (let [
                    #_"boolean" isWordField (WordTypes'isWord-1j (#_"ResolvedJavaField" .getType field))
                    #_"boolean" isWordValue (= (ValueNode''getStackKind-1 value) WordTypes'wordKind)
                ]
                    (cond
                        (and isWordField (not isWordValue))
                            (throw! (str "cannot store a non-word value into a word field: " (#_"ResolvedJavaField" .format field, "%H.\n")))
                        (and (not isWordField) isWordValue)
                            (throw! (str "cannot store a word value into a non-word field: " (#_"ResolvedJavaField" .format field, "%H.\n")))
                        :else
                            false ;; we never need to intercept the field store
                    )
                )
            )
        )

        (#_"boolean" NodePlugin'''handleStoreStaticField-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"ValueNode" value]
            (NodePlugin'''handleStoreField-5 this, parser, nil, field, value)
        )

        (#_"boolean" NodePlugin'''handleStoreIndexed-6 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
            (let [
                #_"ResolvedJavaType" arrayType (StampTool'typeOrNull-1 (:stamp array))
            ]
                (if (and (some? arrayType) (WordTypes'isWord-1j (#_"ResolvedJavaType" .getComponentType arrayType)))
                    (do
                        (when-not (= (ValueNode''getStackKind-1 value) WordTypes'wordKind)
                            (throw! (str "cannot store a non-word value into a word array: " (#_"ResolvedJavaType" .toJavaName arrayType, true)))
                        )
                        (BytecodeParser''add-2 parser, (WordOperationPlugin'createStoreIndexedNode-3 array, index, value))
                        true
                    )
                    (do
                        (when (and (= elementKind JavaKind/Object) (= (ValueNode''getStackKind-1 value) WordTypes'wordKind))
                            (throw! (str "cannot store a word value into a non-word array: " (#_"ResolvedJavaType" .toJavaName arrayType, true)))
                        )
                        false
                    )
                )
            )
        )

        (#_"boolean" NodePlugin'''handleCheckCast-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
            (if (WordTypes'isWord-1j type)
                (when (= (ValueNode''getStackKind-1 object) WordTypes'wordKind) => (throw! (str "cannot cast a non-word value to a word type: " (#_"ResolvedJavaType" .toJavaName type, true)))
                    (BytecodeParser''push-3 parser, JavaKind/Object, object)
                    true
                )
                (when (= (ValueNode''getStackKind-1 object) JavaKind/Object) => (throw! (str "cannot cast a word value to a non-word type: " (#_"ResolvedJavaType" .toJavaName type, true)))
                    false
                )
            )
        )

        (#_"boolean" NodePlugin'''handleInstanceOf-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
            (cond
                (WordTypes'isWord-1j type)
                    (throw! (str "cannot use instanceof for word a type: " (#_"ResolvedJavaType" .toJavaName type, true)))
                (not= (ValueNode''getStackKind-1 object) JavaKind/Object)
                    (throw! (str "cannot use instanceof on a word value: " (#_"ResolvedJavaType" .toJavaName type, true)))
                :else
                    false
            )
        )
    )

    (defm WordOperationPlugin InlineInvokePlugin
        (#_"InlineInvokeInfo" InlineInvokePlugin'''shouldInlineInvoke-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
            nil
        )

        (#_"void" InlineInvokePlugin'''notifyBeforeInline-2 [#_"WordOperationPlugin" this, #_"ResolvedJavaMethod" methodToInline]
            nil
        )

        (#_"void" InlineInvokePlugin'''notifyAfterInline-2 [#_"WordOperationPlugin" this, #_"ResolvedJavaMethod" methodToInline]
            nil
        )
    )
)

(class-ns WorkListEntry []
    (defn #_"WorkListEntry" WorkListEntry'new-2 [#_"Node" n, #_"NodeBitMap" loopNodes]
        (merge (WorkListEntry'class.)
            (hash-map
                #_"Node*" :usages (:nodeUsages n)
                #_"Node" :n n
                #_"boolean" :isLoopNode (NodeBitMap''isMarked-2n loopNodes, n)
            )
        )
    )

    (ยง override! #_"boolean" #_"Object." equals [#_"WorkListEntry" this, #_"Object" obj]
        (and (satisfies? WorkListEntry obj) (= (:n this) (:n obj)))
    )
)

(class-ns WriteBarrierAdditionPhase [Phase]
    (defn #_"WriteBarrierAdditionPhase" WriteBarrierAdditionPhase'new-0 []
        (WriteBarrierAdditionPhase'class.)
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 [#_"FixedAccessNode" node, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" doLoad, #_"boolean" nullCheck, #_"Graph" graph]
        (let [
            #_"G1PreWriteBarrier" preBarrier (Graph''add-2 graph, (G1PreWriteBarrier'new-4 address, value, doLoad, nullCheck))
        ]
            (DeoptBefore'''setStateBefore-2 preBarrier, (:stateBefore node))
            (ยง ass! node (FixedAccessNode''setNullCheck-2 node, false))
            (DeoptBefore'''setStateBefore-2 node, nil)
            (Graph''addBeforeFixed-3 graph, node, preBarrier)
        )
        nil
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addG1PostWriteBarrier-5 [#_"FixedAccessNode" node, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"Graph" graph]
        (Graph''addAfterFixed-3 graph, node, (Graph''add-2 graph, (G1PostWriteBarrier'new-4 address, value, precise?, (StampTool'isPointerAlwaysNull-1 (:stamp value)))))
        nil
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addSerialPostWriteBarrier-5 [#_"FixedAccessNode" node, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"Graph" graph]
        (when-not (StampTool'isPointerAlwaysNull-1 (:stamp value)) ;; serial barrier isn't needed for nil value
            (Graph''addAfterFixed-3 graph, node, (Graph''add-2 graph, (SerialWriteBarrier'new-2 address, precise?)))
        )
        nil
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addReadNodeBarriers-2 [#_"ReadNode" node, #_"Graph" graph]
        (when (= (:barrierType node) BarrierType'PRECISE)
            (Graph''addAfterFixed-3 graph, node, (Graph''add-2 graph, (G1ReferentFieldReadBarrier'new-3 (Access'''getAddress-1 node), node, false)))
        )
        nil
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addWriteNodeBarriers-2 [#_"WriteNode" node, #_"Graph" graph]
        (condp =? (:barrierType node)
            [BarrierType'IMPRECISE BarrierType'PRECISE]
                (let [
                    #_"boolean" precise? (= (:barrierType node) BarrierType'PRECISE)
                ]
                    (if HotSpot'useG1GC
                        (do
                            (when-not (LocationIdentity''isInit-1 (Access'''getLocationIdentity-1 node))
                                (WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 node, (Access'''getAddress-1 node), nil, true, (:nullCheck node), graph)
                            )
                            (WriteBarrierAdditionPhase'addG1PostWriteBarrier-5 node, (Access'''getAddress-1 node), (:value node), precise?, graph)
                        )
                        (WriteBarrierAdditionPhase'addSerialPostWriteBarrier-5 node, (Access'''getAddress-1 node), (:value node), precise?, graph)
                    )
                )
            BarrierType'NONE nil ;; nothing to do
        )
        nil
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addAtomicReadWriteNodeBarriers-2 [#_"LoweredAtomicReadAndWriteNode" node, #_"Graph" graph]
        (condp =? (:barrierType node)
            [BarrierType'IMPRECISE BarrierType'PRECISE]
                (let [
                    #_"boolean" precise? (= (:barrierType node) BarrierType'PRECISE)
                ]
                    (if HotSpot'useG1GC
                        (do
                            (WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 node, (Access'''getAddress-1 node), nil, true, (:nullCheck node), graph)
                            (WriteBarrierAdditionPhase'addG1PostWriteBarrier-5 node, (Access'''getAddress-1 node), (:newValue node), precise?, graph)
                        )
                        (WriteBarrierAdditionPhase'addSerialPostWriteBarrier-5 node, (Access'''getAddress-1 node), (:newValue node), precise?, graph)
                    )
                )
            BarrierType'NONE nil ;; nothing to do
        )
        nil
    )

    (defn- #_"void" WriteBarrierAdditionPhase'addCASBarriers-2 [#_"AbstractCompareAndSwapNode" node, #_"Graph" graph]
        (condp =? (:barrierType node)
            [BarrierType'IMPRECISE BarrierType'PRECISE]
                (let [
                    #_"boolean" precise? (= (:barrierType node) BarrierType'PRECISE)
                ]
                    (if HotSpot'useG1GC
                        (do
                            (WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 node, (Access'''getAddress-1 node), (:expectedValue node), false, false, graph)
                            (WriteBarrierAdditionPhase'addG1PostWriteBarrier-5 node, (Access'''getAddress-1 node), (AbstractCompareAndSwapNode''getNewValue-1 node), precise?, graph)
                        )
                        (WriteBarrierAdditionPhase'addSerialPostWriteBarrier-5 node, (Access'''getAddress-1 node), (AbstractCompareAndSwapNode''getNewValue-1 node), precise?, graph)
                    )
                )
            BarrierType'NONE nil ;; nothing to do
        )
        nil
    )

    (defm WriteBarrierAdditionPhase Phase
        (#_"Graph" Phase'''run-3 [#_"WriteBarrierAdditionPhase" this, #_"Graph" graph, #_"PhaseContext" context]
            (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                (condp satisfies? node
                    ReadNode                      (WriteBarrierAdditionPhase'addReadNodeBarriers-2 node, graph)
                    WriteNode                     (WriteBarrierAdditionPhase'addWriteNodeBarriers-2 node, graph)
                    LoweredAtomicReadAndWriteNode (WriteBarrierAdditionPhase'addAtomicReadWriteNodeBarriers-2 node, graph)
                    AbstractCompareAndSwapNode    (WriteBarrierAdditionPhase'addCASBarriers-2 node, graph)
                    nil
                )
            )
            graph
        )
    )
)

(value-ns StampFactory
    (defn- #_"void" StampFactory'setCache-3 [#_"Stamp[]" cache, #_"JavaKind" kind, #_"Stamp" stamp]
        (ยง aset! cache (#_"JavaKind" .ordinal kind) stamp)
        nil
    )

    (defn- #_"void" StampFactory'setCache-2 [#_"Stamp[]" cache, #_"JavaKind" kind]
        (let [
            #_"int" bits (#_"JavaKind" .getBitCount (#_"JavaKind" .getStackKind kind))
            #_"long" mask (CodeUtil/mask (if (#_"JavaKind" .isUnsigned kind) (#_"JavaKind" .getBitCount kind) bits))
        ]
            (StampFactory'setCache-3 cache, kind, (IntegerStamp'create-5 bits, (#_"JavaKind" .getMinValue kind), (#_"JavaKind" .getMaxValue kind), 0, mask))
        )
        nil
    )

    (def- #_"Stamp[]" StampFactory'stampCache
        (let [
            #_"Stamp[]" cache (make-array Stamp'iface (count (JavaKind/values)))
        ]
            (StampFactory'setCache-2 cache, JavaKind/Boolean)
            (StampFactory'setCache-2 cache, JavaKind/Byte)
            (StampFactory'setCache-2 cache, JavaKind/Short)
            (StampFactory'setCache-2 cache, JavaKind/Char)
            (StampFactory'setCache-2 cache, JavaKind/Int)
            (StampFactory'setCache-2 cache, JavaKind/Long)

            (StampFactory'setCache-3 cache, JavaKind/Object, StampFactory'objectStamp)
            (StampFactory'setCache-3 cache, JavaKind/Void, VoidStamp'instance)
            (StampFactory'setCache-3 cache, JavaKind/Illegal, IllegalStamp'instance)

            cache
        )
    )

    ;;;
     ; Return a stamp for a Java kind, as it would be represented on the bytecode stack.
     ;;
    (defn #_"Stamp" StampFactory'forKind-1 [#_"JavaKind" kind]
        (nth StampFactory'stampCache (#_"JavaKind" .ordinal kind))
    )

    (defn #_"IntegerStamp" StampFactory'forInteger-5 [#_"JavaKind" kind, #_"long" lowerBound, #_"long" upperBound, #_"long" downMask, #_"long" upMask]
        (IntegerStamp'create-5 (#_"JavaKind" .getBitCount kind), lowerBound, upperBound, downMask, upMask)
    )

    (defn #_"IntegerStamp" StampFactory'forInteger-3k [#_"JavaKind" kind, #_"long" lowerBound, #_"long" upperBound]
        (StampFactory'forInteger-3i (#_"JavaKind" .getBitCount kind), lowerBound, upperBound)
    )

    ;;;
     ; Create a new stamp use {@code lower} and {@code upper} computing the appropriate IntegerStamp#upMask
     ; and IntegerStamp#downMask and incorporating any mask information from {@code maskStamp}.
     ;
     ; @return a new stamp with the appropriate bounds and masks
     ;;
    #_unused
    (defn #_"IntegerStamp" StampFactory'forIntegerWithMask-4 [#_"int" bits, #_"long" lower, #_"long" upper, #_"IntegerStamp" maskStamp]
        (let [
            #_"IntegerStamp" limit (StampFactory'forInteger-3i bits, lower, upper)
        ]
            (IntegerStamp'create-5 bits, lower, upper, (| (:downMask limit) (:downMask maskStamp)), (& (:upMask limit) (:upMask maskStamp)))
        )
    )

    (defn #_"IntegerStamp" StampFactory'forIntegerWithMask-5 [#_"int" bits, #_"long" lower, #_"long" upper, #_"long" downMask, #_"long" upMask]
        (let [
            #_"IntegerStamp" limit (StampFactory'forInteger-3i bits, lower, upper)
        ]
            (IntegerStamp'create-5 bits, lower, upper, (| (:downMask limit) downMask), (& (:upMask limit) upMask))
        )
    )

    (defn #_"IntegerStamp" StampFactory'forInteger-1 [#_"int" bits]
        (IntegerStamp'create-5 bits, (CodeUtil/minValue bits), (CodeUtil/maxValue bits), 0, (CodeUtil/mask bits))
    )

    #_unused
    (defn #_"IntegerStamp" StampFactory'forUnsignedInteger-1 [#_"int" bits]
        (StampFactory'forUnsignedInteger-5 bits, 0, (NumUtil'maxValueUnsigned-1 bits), 0, (CodeUtil/mask bits))
    )

    (defn #_"IntegerStamp" StampFactory'forUnsignedInteger-3 [#_"int" bits, #_"long" unsignedLowerBound, #_"long" unsignedUpperBound]
        (StampFactory'forUnsignedInteger-5 bits, unsignedLowerBound, unsignedUpperBound, 0, (CodeUtil/mask bits))
    )

    (defn #_"IntegerStamp" StampFactory'forUnsignedInteger-5 [#_"int" bits, #_"long" unsignedLowerBound, #_"long" unsignedUpperBound, #_"long" downMask, #_"long" upMask]
        (let [
            #_"long" lowerBound (CodeUtil/signExtend unsignedLowerBound, bits)
            #_"long" upperBound (CodeUtil/signExtend unsignedUpperBound, bits)
            [lowerBound upperBound]
                (when-not (NumUtil'sameSign-2 lowerBound, upperBound) => [lowerBound upperBound]
                    [(CodeUtil/minValue bits) (CodeUtil/maxValue bits)]
                )
            #_"long" mask (CodeUtil/mask bits)
        ]
            (IntegerStamp'create-5 bits, lowerBound, upperBound, (& downMask mask), (& upMask mask))
        )
    )

    (defn #_"IntegerStamp" StampFactory'forInteger-3i [#_"int" bits, #_"long" lowerBound, #_"long" upperBound]
        (IntegerStamp'create-5 bits, lowerBound, upperBound, 0, (CodeUtil/mask bits))
    )

    (defn #_"Stamp" StampFactory'forPrimitiveConstant-1 [#_"JavaConstant" value]
        (let [
            #_"JavaKind" kind (#_"JavaConstant" .getJavaKind value)
        ]
            (condp =? kind
               [JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Short JavaKind/Int JavaKind/Long]
                    (let [
                        #_"long" mask (& (#_"JavaConstant" .asLong value) (CodeUtil/mask (#_"JavaKind" .getBitCount kind)))
                    ]
                        (StampFactory'forInteger-5 (#_"JavaKind" .getStackKind kind), (#_"JavaConstant" .asLong value), (#_"JavaConstant" .asLong value), mask, mask)
                    )
                JavaKind/Illegal
                    (StampFactory'forKind-1 JavaKind/Illegal)
                JavaKind/Object
                    (if (#_"JavaConstant" .isNull value) StampFactory'objectAlwaysNullStamp StampFactory'objectNonNullStamp)
            )
        )
    )

    (defn #_"Stamp" StampFactory'forConstant-1 [#_"JavaConstant" value]
        (when (= (#_"JavaConstant" .getJavaKind value) JavaKind/Object) => (StampFactory'forPrimitiveConstant-1 value)
            (let [
                #_"ResolvedJavaType" type (when-not (#_"JavaConstant" .isNull value) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, value))
            ]
                (ObjectStamp'new-4 type, (#_"JavaConstant" .isNonNull value), (#_"JavaConstant" .isNonNull value), (#_"JavaConstant" .isNull value))
            )
        )
    )

    (defn #_"ObjectStamp" StampFactory'object-1 [#_"TypeReference" type]
        (StampFactory'object-2 type, false)
    )

    (defn #_"ObjectStamp" StampFactory'objectNonNull-1 [#_"TypeReference" type]
        (StampFactory'object-2 type, true)
    )

    (defn #_"ObjectStamp" StampFactory'object-2 [#_"TypeReference" type, #_"boolean" never-nil?]
        (if (some? type)
            (ObjectStamp'new-4 (:type type), (:exactReference type), never-nil?, false)
            (ObjectStamp'new-4 nil, false, never-nil?, false)
        )
    )

    (defn #_"Stamp" StampFactory'forDeclaredType-2 [#_"JavaType" type, #_"boolean" never-nil?]
        (if (and (= (#_"JavaType" .getJavaKind type) JavaKind/Object) (instance? ResolvedJavaType type))
            (StampFactory'object-2 (TypeReference'create-1 type), never-nil?)
            (StampFactory'forKind-1 (#_"JavaType" .getJavaKind type))
        )
    )

    (ยง def #_"Stamp" StampFactory'objectStamp           (ObjectStamp'new-4 nil, false, false, false))
    (ยง def #_"Stamp" StampFactory'objectNonNullStamp    (ObjectStamp'new-4 nil, false, true, false))
    (ยง def #_"Stamp" StampFactory'objectAlwaysNullStamp (ObjectStamp'new-4 nil, false, false, true))

    (ยง def #_"Stamp" StampFactory'nonNegativeInt (StampFactory'forInteger-5 JavaKind/Int, 0, Integer/MAX_VALUE, 0, Integer/MAX_VALUE))
    (ยง def #_"Stamp" StampFactory'booleanTrue    (StampFactory'forInteger-5 JavaKind/Boolean, -1, -1, 1, 1))
    (ยง def #_"Stamp" StampFactory'booleanFalse   (StampFactory'forInteger-5 JavaKind/Boolean, 0, 0, 0, 0))

    (ยง def #_"Stamp" StampFactory'rawPointer (RawPointerStamp'new-0))
)

(value-ns Compiler
    (defn #_"void" Compiler'emitStackOverflowCheck-1 [#_"Assembler" asm]
        (when HotSpot'useStackBanging
            ;; Each code entry causes one stack bang n pages down the stack where n is configurable
            ;; by StackShadowPages. The setting depends on the maximum depth of VM call stack or native
            ;; before going back into java code, since only java code can raise a stack overflow exception
            ;; using the stack banging mechanism. The VM and native code does not detect stack overflow.
            ;; The code in JavaCalls::call() checks that there is at least n pages available, so all
            ;; entry code needs to do is bang once for the end of this shadow zone.
            ;; The entry code may need to bang additional pages if the framesize is greater than a page.
            (let [
                #_"int" end (NumUtil'roundUp-2i (* HotSpot'stackShadowPages 4 CodeUtil/K), HotSpot'vmPageSize)
                ;; This is how far the previous frame's stack banging extended.
                #_"int" frameSize (:frameSize (:frameMap asm))
                #_"int" end' (if (< HotSpot'vmPageSize frameSize) (+ end frameSize) end)
            ]
                (loop-when-recur [#_"int" i end] (<= i end') [(+ i HotSpot'vmPageSize)]
                    ;; Need at least one stack bang at end of shadow zone.
                    (Assembler''movl-3ar asm, (AMD64Address'new-2 AMD64/rsp, (- i)), AMD64/rax)
                )
            )
        )
        nil
    )

    (defn #_"void" Compiler'emitFrontEnd-3 [#_"Graph" graph, #_"OptimisticOptimizations" optimisticOpts, #_"Suites" suites]
        (let [
            #_"PhaseContext" context (PhaseContext'new-1 optimisticOpts)
        ]
            (when (nil? (:next (:start graph)))
                (ยง ass! graph (Phase'''run-3 HotSpot'graphBuilderSuite, graph, context))
                (ยง ass! graph (Phase'''run-3 (DeadCodeEliminationPhase'new-1 Optionality'Optional), graph, nil))
            )
            (ยง ass! graph (Phase'''run-3 (:highTier suites), graph, context))
            (ยง ass! graph (Phase'''run-3 (:midTier suites), graph, context))
            (ยง ass! graph (Phase'''run-3 (:lowTier suites), graph, nil))
        )
        nil
    )

    (defn #_"LIRGenerationResult" Compiler'emitLowLevel-3 [#_"LIRGenerationResult" res, #_"LIRGenerator" gen, #_"LIRSuites" suites]
        (let [
            #_"LIRPhaseContext" context (LIRPhaseContext'new-1 gen)
        ]
            (LIRPhase'''run-3 (:preAllocStage suites), res, context)
            (LIRPhase'''run-3 (:allocStage suites), res, context)
            (LIRPhase'''run-3 (:postAllocStage suites), res, nil)
            res
        )
    )

    (defn #_"LIRGenerationResult" Compiler'emitLIR-2 [#_"Graph" graph, #_"LIRSuites" suites]
        (let [
            #_"ScheduleResult" schedule (:lastSchedule graph)
            #_"Block[]" blocks (:reversePostOrder (:cfg schedule))
            #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg schedule))
            #_"Block[]" codeEmittingOrder (ComputeBlockOrder'computeCodeEmittingOrder-1 startBlock)
            #_"Block[]" linearScanOrder (ComputeBlockOrder'computeLinearScanOrder-1 startBlock)
            #_"LIR" lir (LIR'new-3 (:cfg schedule), linearScanOrder, codeEmittingOrder)
            #_"CallingConvention" callingConvention (CodeUtil/getCallingConvention HotSpot'codeCache, HotSpotCallingConventionType/JavaCallee, (:rootMethod graph), HotSpot'valueKindFactory)
            #_"LIRGenerationResult" res (LIRGenerationResult'new-2 lir, callingConvention)
            #_"LIRGenerator" gen (LIRGenerator'new-1 res)
            #_"LIRBuilder" builder (LIRBuilder'new-2 graph, gen)
        ]
            (LIRPhase'''run-3 (LIRGenerationPhase'new-0), res, (LIRGenerationContext'new-4 gen, builder, graph, schedule))
            (Compiler'emitLowLevel-3 res, gen, suites)
        )
    )

    (defn #_"CompilationResult" Compiler'emitBackEnd-2 [#_"Graph" graph, #_"LIRSuites" suites]
        (let [
            #_"Assembler" asm (Assembler'new-1 (Compiler'emitLIR-2 graph, suites))
        ]
            (ยง ass! asm (Assembler''assemble-1 asm))
            (Assembler''finish-1 asm)
        )
    )

    (defn #_"CompilationResult" Compiler'compileGraph-1 [#_"Graph" graph]
        (Compiler'emitFrontEnd-3 graph, OptimisticOptimizations'ALL, (Suites'createSuites-0))
        (Compiler'emitBackEnd-2 graph, (LIRSuites'new-0))
    )

    #_unused
    (defn #_"CompilationResult" Compiler'compileMethod-1 [#_"ResolvedJavaMethod" method]
        (Compiler'compileGraph-1 (Graph'new-1 method))
    )

    ;;;
     ; HotSpot expects sites to be presented in ascending order of PC (see {@code DebugInformationRecorder::add_new_pc_offset}).
     ;;
    (defn- #_"Site[]" Compiler'getSortedSites-1 [#_"CompilationResult" result]
        (let [
            #_"List<Site>" sites (ArrayList.)
        ]
            (#_"List" .addAll sites, (or (:dataPatches result) ()))
            (#_"List" .addAll sites, (or (:marks result) ()))

            (Collections/sort sites,
                (reify Comparator #_"<Site>"
                    (#_"int" compare [#_"Comparator<Site>" this, #_"Site" s1, #_"Site" s2]
                        (let [
                            #_"int" cmp (- (.pcOffset s1) (.pcOffset s2))
                        ]
                            (when (zero? cmp) => cmp
                                ;; Marks must come first since patching a call site
                                ;; may need to know the mark denoting the call type
                                ;; (see uses of CodeInstaller::_next_call_type).
                                (let [
                                    #_"boolean" m1 (instance? Mark s1)
                                    #_"boolean" m2 (instance? Mark s2)
                                ]
                                    (when-not (= m1 m2) => cmp
                                        (if m1 -1 1)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (into-array Site sites)
        )
    )

    ;;;
     ; Turns a CompilationResult into a CompiledCode that can be passed to the VM for installation.
     ;;
    (defn #_"HotSpotCompiledCode" Compiler'createCompiledCode-1 [#_"CompilationResult" result]
        (let [
            #_"byte[]" code (:targetCode result)
            #_"int" codeSize (:targetCodeSize result)
            #_"Site[]" sites (Compiler'getSortedSites-1 result)
            #_"DataSection" section (:dataSection result)
            #_"byte[]" data (byte-array (DataSection''getSectionSize-1 section))
            #_"ByteBuffer" buffer (#_"ByteBuffer" .order (ByteBuffer/wrap data), (ByteOrder/nativeOrder))
            #_"Stream$Builder<DataPatch>" builder (Stream/builder)
            _
                (DataSection''buildDataSection-3 section, buffer,
                    (ร (position, vmConstant) 
                        (ยง fun #_"Patches'''registerPatch-3"
                            (#_"Stream$Builder" .accept builder, (DataPatch. position, (ConstantReference. vmConstant)))
                        )
                    )
                )
            #_"int" alignment (DataSection''getSectionAlignment-1 section)
            #_"DataPatch[]" patches (#_"Stream" .toArray (#_"Stream$Builder" .build builder), (ร (len)  (ยง fun (make-array DataPatch len))))
            #_"int" frameSize (:totalFrameSize result)
        ]
            (HotSpotCompiledCode. nil, code, codeSize, sites, nil, nil, nil, data, alignment, patches, false, frameSize, nil)
        )
    )

    ;;;
     ; Installs code based on a given compilation result.
     ;
     ; @param method the method compiled to produce {@code compiledCode} or nil if the input
     ;            to {@code result} was not a ResolvedJavaMethod
     ; @param result the code to be installed
     ; @param predefinedInstalledCode a pre-allocated InstalledCode object to use as a reference
     ;            to the installed code. If nil, a new InstalledCode object will be created.
     ; @return a reference to the compiled and ready-to-run installed code
     ;;
    #_unused
    (defn #_"InstalledCode" Compiler'createInstalledCode-4 [#_"ResolvedJavaMethod" method, #_"CompilationResult" result, #_"InstalledCode" predefinedInstalledCode, #_"boolean" default?]
        (#_"CodeCacheProvider" .installCode HotSpot'codeCache, method, (Compiler'createCompiledCode-1 result), predefinedInstalledCode, nil, default?)
    )
)
